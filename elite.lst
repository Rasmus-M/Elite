XAS99 CROSS-ASSEMBLER   VERSION 3.6.5
     **** ****     > main.a99
0001                      copy "equates.a99"
     **** ****     > equates.a99
0001               **
0002               * Memory mapped addresses
0003               *
0004               vdpwd:                                 ; VDP write data
0005                      equ  >8c00
0006               vdpwa:                                 ; VDP set read/write address
0007                      equ  >8c02
0008               vdprd:                                 ; VDP read data
0009                      equ  >8800
0010               vdpsta:                                ; VDP status
0011                      equ  >8802
0012               sound:                                 ; Sound
0013                      equ  >8400
0014               spchwt:
0015                      equ  >9400
0016               spchrd:
0017                      equ  >9000
0018               
0019               workspace:
0020                      equ  8300
0021               
0022               **
0023               * VDP memory map
0024               *
0025               pattern_table:                         ; Pattern table
0026                      equ  >0000
0027               sprite_pattern_table:                  ; Sprite pattern table
0028                      equ  >1800
0029               name_table:                            ; Name table
0030                      equ  >3800
0031               sprite_attr_table:                     ; Sprite attribute table
0032                      equ  >3b00
0033               color_table:                           ; Color table
0034                      equ  >2000
0035               
0036               **
0037               * Register map
0038               *
0039               rtmp:
0040      0000            requ 0
0041               rtmplb:
0042                      equ workspace + 1
0043               rtmp2:
0044      0000            requ 1
0045               rtmp2lb:
0046                      equ workspace + 3
0047               rtmp3:
0048      0000            requ 2
0049               rtmp3lb:
0050                      equ workspace + 5
0051               rtmp4:
0052      0000            requ 3
0053               rarg1:
0054      0000            requ 4
0055               rarg2:
0056      0000            requ 5
0057               rzero:
0058      0000            requ 6
0059               rone:
0060      0000            requ 7
0061               rmone:
0062      0000            requ 8
0063               rvdpwd:
0064      0000            requ 9
0065               rsp:
0066      0000            requ 10
0067               rsplb:
0068                      equ workspace + 21
0069               r11lb:
0070                      equ workspace + 23
0071               ra:
0072      0000            requ 13
0073               ralb:
0074                      equ workspace + 27
0075               rx:
0076      0000            requ 14
0077               ry:
0078      0000            requ 15
0079               
0080               **
0081               * Constants
0082               *
0083               _MAX_COMMANDER:
0084                      equ  0
0085               _REMOVE_CHECKSUMS:
0086                      equ  1
0087               ZERO_PAGE.:
0088                      equ >0000
0089               STACK.:
0090                      equ >0100
0091               T.:
0092                      equ >0300
0093               CODE_WORDS.:
0094                      equ >0400
0095               K.:
0096                      equ >0900
0097               WP.:
0098                      equ >0D40
0099               CODE.:
0100                      equ >0F40
0101               CODE_UPPER.:
0102                      equ >A000
0103               CODE_PYTHON.:
0104                      equ >F200
0105               
0106               scr_buffer:
0107                      equ >6000
                   < main.a99
0002                      copy "macros.a99"
     **** ****     > macros.a99
0001               **
0002               * Macros
0003               *
0013               
0021               
0031               
0043               
0056               
0070               
0075               
0080               
0086               
0092               
0099               
0106               
0117               
0124               
0131               
0137               
0146               
0154               
0160               
0166               
0173               
0180               
0185               
0190               
0198               
0204               
0209               
0216               
0222               
0228               
0229               
0230               
0234               
0238               
0246               
0266               
0270               
0275               
0280               
                   < main.a99
0003                      copy "elite.a99"
     **** ****     > elite.a99
0001               * ******************************************************************************
0002               *
0003               * ELITE GAME SOURCE
0004               *
0005               * Elite was written by Ian Bell and David Braben and is copyright Acornsoft 1984
0006               *
0007               * The code on this site is identical to the source discs released on Ian Bell's
0008               * personal website at http://www.elitehomepage.org/ (it's just been reformatted
0009               * to be more readable)
0010               *
0011               * The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
0012               * in the documentation are entirely my fault
0013               *
0014               * The terminology and notations used in this commentary are explained at
0015               * https://elite.bbcelite.com/terminology
0016               *
0017               * The deep dive articles referred to in this commentary can be found at
0018               * https://elite.bbcelite.com/deep_dives
0019               *
0020               * ------------------------------------------------------------------------------
0021               *
0022               * This source file produces the following binary files:
0023               *
0024               * * ELTA.bin
0025               * * ELTB.bin
0026               * * ELTC.bin
0027               * * ELTD.bin
0028               * * ELTE.bin
0029               * * ELTF.bin
0030               * * ELTG.bin
0031               * * PYTHON.bin
0032               * * SHIPS.bin
0033               * * WORDS9.bin
0034               *
0035               * ******************************************************************************
0036               
0037                      ; INCLUDE "1-source-files/main-sources/elite-build-options.asm"
0038               
0039               _SOURCE_DISC:                                              ; (_VARIANT = 1)
0040                      equ 0
0041               _TEXT_SOURCES:                                             ; (_VARIANT = 2)
0042                      equ 0
0043               _STH_CASSETTE:                                             ; (_VARIANT = 3)
0044                      equ 1
0045               
0046                      ; GUARD &6000                                       ; Guard against assembling over screen memory
0047               
0048               * ******************************************************************************
0049               *
0050               * Configuration variables
0051               *
0052               * ******************************************************************************
0053               
0054               * ZERO_PAGE% = &0000
0055               
0056               * STACK% = &0100
0057               
0058               * CODE% = &0F40         \ The address where the code will be run
0059               
0060               LOAD.:                                                     ; The address where the code will be loaded
0061                      equ >1128
0062               
0063               * T% = &0300            \ Current commander data and stardust data blocks
0064               
0065               * CODE_WORDS% = &0400   \ The address where the text data will be run
0066               
0067               LOAD_WORDS.:                                               ; The address where the text data will be loaded
0068                      equ >1100
0069               
0070               * K% = &0900
0071               
0072               * WP% = &0D40
0073               
0074               * CODE_PYTHON% = &7F00
0075               
0076               Q.:                                                        ; Set Q% to TRUE to max out the default commander, FALSE
0077                      equ _MAX_COMMANDER
0078                                                                          ; for the standard default commander
0079               
0080               NOST:                                                      ; The number of stardust particles in normal space (this
0081                      equ 18
0082                                                                          ; goes down to 3 in witchspace)
0083               
0084               NOSH:                                                      ; The maximum number of ships in our local bubble of
0085                      equ 12
0086                                                                          ; universe
0087               
0088               NTY:                                                       ; The number of different ship types
0089                      equ 13
0090               
0091               COPS:                                                      ; Ship type for a Viper
0092                      equ 2
0093               
0094               THG:                                                       ; Ship type for a Thargoid
0095                      equ 6
0096               
0097               CYL:                                                       ; Ship type for a Cobra Mk III (trader)
0098                      equ 7
0099               
0100               SST:                                                       ; Ship type for the space station
0101                      equ 8
0102               
0103               MSL:                                                       ; Ship type for a missile
0104                      equ 9
0105               
0106               AST:                                                       ; Ship type for an asteroid
0107                      equ 10
0108               
0109               OIL:                                                       ; Ship type for a cargo canister
0110                      equ 11
0111               
0112               TGL:                                                       ; Ship type for a Thargon
0113                      equ 12
0114               
0115               ESC:                                                       ; Ship type for an escape pod
0116                      equ 13
0117               
0118               POW:                                                       ; Pulse laser power
0119                      equ 15
0120               
0121               NI.:                                                       ; The number of bytes in each ship's data block (as
0122                      equ 36
0123                                                                          ; stored in INWK and K%)
0124               
0125               VSCAN:                                                     ; Defines the split position in the split-screen mode
0126                      equ 57
0127               
0128               X:                                                         ; The centre x-coordinate of the 256 x 192 space view
0129                      equ 128
0130               
0131               Y:                                                         ; The centre y-coordinate of the 256 x 192 space view
0132                      equ 96
0133               
0134               f0_:                                                       ; Internal key number for red key f0 (Launch, Front)
0135                      equ >20
0136               
0137               f1_:                                                       ; Internal key number for red key f1 (Buy Cargo, Rear)
0138                      equ >71
0139               
0140               f2_:                                                       ; Internal key number for red key f2 (Sell Cargo, Left)
0141                      equ >72
0142               
0143               f3_:                                                       ; Internal key number for red key f3 (Equip Ship, Right)
0144                      equ >73
0145               
0146               f4_:                                                       ; Internal key number for red key f4 (Long-range Chart)
0147                      equ >14
0148               
0149               f5_:                                                       ; Internal key number for red key f5 (Short-range Chart)
0150                      equ >74
0151               
0152               f6_:                                                       ; Internal key number for red key f6 (Data on System)
0153                      equ >75
0154               
0155               f7_:                                                       ; Internal key number for red key f7 (Market Price)
0156                      equ >16
0157               
0158               f8_:                                                       ; Internal key number for red key f8 (Status Mode)
0159                      equ >76
0160               
0161               f9_:                                                       ; Internal key number for red key f9 (Inventory)
0162                      equ >77
0163               
0164               RE:                                                        ; The obfuscation byte used to hide the recursive tokens
0165                      equ >23
0166                                                                          ; table from crackers viewing the binary code
0167               
0168               VIA:                                                       ; Memory-mapped space for accessing internal hardware,
0169                      equ >FE00
0170                                                                          ; such as the video ULA, 6845 CRTC and 6522 VIAs (also
0171                                                                          ; known as SHEILA)
0172               
0173               * OSBYTE = &FFF4        \ The address for the OSBYTE routine, which is used
0174                                                                          ; three times in the main game code
0175               
0176               * OSWORD = &FFF1        \ The address for the OSWORD routine, which is used
0177                                                                          ; twice in the main game code
0178               
0179               * OSFILE = &FFDD        \ The address for the OSFILE routine, which is used
0180                                                                          ; once in the main game code
0181               
0182               * ******************************************************************************
0183               *
0184               * Name: ZP
0185               * Type: Workspace
0186               * Address: &0000 to &00B0
0187               * Category: Workspaces
0188               * Summary: Lots of important variables are stored in the zero page workspace
0189               * as it is quicker and more space-efficient to access memory here
0190               *
0191               * ******************************************************************************
0192               
0193                      aorg ZERO_PAGE.
0194               
0195               ZP:
0196 0000                 bss 0                                               ; The start of the zero page workspace
0197               
0198               RAND:
0199 0000                 bss 4                                               ; Four 8-bit seeds for the random number generation
0200                                                                          ; system implemented in the DORND routine
0201               
0202               TRTB.:
0203 0004                 bss 2                                               ; Contains the address of the keyboard translation
0204                                                                          ; table, which is used to translate internal key
0205                                                                          ; numbers to ASCII
0206               
0207               T1:
0208 0006                 bss 1                                               ; Temporary storage, used in a number of places
0209               
0210               SC:
0211 0007                 bss 1                                               ; Screen address (low byte)
0212                                                                          ;
0213                                                                          ; Elite draws on-screen by poking bytes directly into
0214                                                                          ; screen memory, and SC(1 0) is typically set to the
0215                                                                          ; address of the character block containing the pixel
0216                                                                          ; we want to draw (see the deep dives on "Drawing
0217                                                                          ; monochrome pixels in mode 4" and "Drawing colour
0218                                                                          ; pixels in mode 5" for more details)
0219               
0220               SCH:
0221 0008                 bss 1                                               ; Screen address (high byte)
0222               
0223               XX16:
0224 0009                 bss 18                                              ; Temporary storage for a block of values, used in a
0225                                                                          ; number of places
0226               
0227               P:
0228 001B                 bss 3                                               ; Temporary storage, used in a number of places
0229               
0230               XX0:
0231 001E                 bss 2                                               ; Temporary storage, used to store the address of a ship
0232                                                                          ; blueprint. For example, it is used when we add a new
0233                                                                          ; ship to the local bubble in routine NWSHP, and it
0234                                                                          ; contains the address of the current ship's blueprint
0235                                                                          ; as we loop through all the nearby ships in the main
0236                                                                          ; flight loop
0237               
0238               INF:
0239 0020                 bss 2                                               ; Temporary storage, typically used for storing the
0240                                                                          ; address of a ship's data block, so it can be copied
0241                                                                          ; to and from the internal workspace at INWK
0242               
0243               V:
0244 0022                 bss 2                                               ; Temporary storage, typically used for storing an
0245                                                                          ; address pointer
0246               
0247               XX:
0248 0024                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0249                                                                          ; x-coordinate
0250               
0251               YY:
0252 0026                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0253                                                                          ; y-coordinate
0254               
0255               SUNX:
0256 0028                 bss 2                                               ; The 16-bit x-coordinate of the vertical centre axis
0257                                                                          ; of the sun (which might be off-screen)
0258               
0259               BETA:
0260 002A                 bss 1                                               ; The current pitch angle beta, which is reduced from
0261                                                                          ; JSTY to a sign-magnitude value between -8 and +8
0262                                                                          ;
0263                                                                          ; This describes how fast we are pitching our ship, and
0264                                                                          ; determines how fast the universe pitches around us
0265                                                                          ;
0266                                                                          ; The sign bit is also stored in BET2, while the
0267                                                                          ; opposite sign is stored in BET2+1
0268               
0269               BET1:
0270 002B                 bss 1                                               ; The magnitude of the pitch angle beta, i.e. |beta|,
0271                                                                          ; which is a positive value between 0 and 8
0272               
0273               XC:
0274 002C                 bss 1                                               ; The x-coordinate of the text cursor (i.e. the text
0275                                                                          ; column), which can be from 0 to 32
0276                                                                          ;
0277                                                                          ; A value of 0 denotes the leftmost column and 32 the
0278                                                                          ; rightmost column, but because the top part of the
0279                                                                          ; screen (the space view) has a white border that
0280                                                                          ; clashes with columns 0 and 32, text is only shown
0281                                                                          ; in columns 1-31
0282               
0283               YC:
0284 002D                 bss 1                                               ; The y-coordinate of the text cursor (i.e. the text
0285                                                                          ; row), which can be from 0 to 23
0286                                                                          ;
0287                                                                          ; The screen actually has 31 character rows if you
0288                                                                          ; include the dashboard, but the text printing routines
0289                                                                          ; only work on the top part (the space view), so the
0290                                                                          ; text cursor only goes up to a maximum of 23, the row
0291                                                                          ; just before the screen splits
0292                                                                          ;
0293                                                                          ; A value of 0 denotes the top row, but because the
0294                                                                          ; top part of the screen has a white border that clashes
0295                                                                          ; with row 0, text is always shown at row 1 or greater
0296               
0297               QQ22:
0298 002E                 bss 2                                               ; The two hyperspace countdown counters
0299                                                                          ;
0300                                                                          ; Before a hyperspace jump, both QQ22 and QQ22+1 are
0301                                                                          ; set to 15
0302                                                                          ;
0303                                                                          ; QQ22 is an internal counter that counts down by 1
0304                                                                          ; each time TT102 is called, which happens every
0305                                                                          ; iteration of the main game loop. When it reaches
0306                                                                          ; zero, the on-screen counter in QQ22+1 gets
0307                                                                          ; decremented, and QQ22 gets set to 5 and the countdown
0308                                                                          ; continues (so the first tick of the hyperspace counter
0309                                                                          ; takes 15 iterations to happen, but subsequent ticks
0310                                                                          ; take 5 iterations each)
0311                                                                          ;
0312                                                                          ; QQ22+1 contains the number that's shown on-screen
0313                                                                          ; during the countdown. It counts down from 15 to 1, and
0314                                                                          ; when it hits 0, the hyperspace engines kick in
0315               
0316               ECMA:
0317 0030                 bss 1                                               ; The E.C.M. countdown timer, which determines whether
0318                                                                          ; an E.C.M. system is currently operating:
0319                                                                          ;
0320                                                                          ; * 0 = E.C.M. is off
0321                                                                          ;
0322                                                                          ; * Non-zero = E.C.M. is on and is counting down
0323                                                                          ;
0324                                                                          ; The counter starts at 32 when an E.C.M. is activated,
0325                                                                          ; either by us or by an opponent, and it decreases by 1
0326                                                                          ; in each iteration of the main flight loop until it
0327                                                                          ; reaches zero, at which point the E.C.M. switches off.
0328                                                                          ; Only one E.C.M. can be active at any one time, so
0329                                                                          ; there is only one counter
0330               
0331               XX15:
0332 0031                 bss 0                                               ; Temporary storage, typically used for storing screen
0333                                                                          ; coordinates in line-drawing routines
0334                                                                          ;
0335                                                                          ; There are six bytes of storage, from XX15 TO XX15+5.
0336                                                                          ; The first four bytes have the following aliases:
0337                                                                          ;
0338                                                                          ; X1 = XX15
0339                                                                          ; Y1 = XX15+1
0340                                                                          ; X2 = XX15+2
0341                                                                          ; Y2 = XX15+3
0342                                                                          ;
0343                                                                          ; These are typically used for describing lines in terms
0344                                                                          ; of screen coordinates, i.e. (X1, Y1) to (X2, Y2)
0345                                                                          ;
0346                                                                          ; The last two bytes of XX15 do not have aliases
0347               
0348               X1:
0349 0031                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0350                                                                          ; line-drawing routines
0351               
0352               Y1:
0353 0032                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0354                                                                          ; line-drawing routines
0355               
0356               X2:
0357 0033                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0358                                                                          ; line-drawing routines
0359               
0360               Y2:
0361 0034                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0362                                                                          ; line-drawing routines
0363               
0364 0035                 bss 2                                               ; The last two bytes of the XX15 block
0365               
0366               XX12:
0367 0037                 bss 6                                               ; Temporary storage for a block of values, used in a
0368                                                                          ; number of places
0369               
0370               K:
0371 003D                 bss 4                                               ; Temporary storage, used in a number of places
0372               
0373               KL:
0374 0041                 bss 1                                               ; The following bytes implement a key logger that
0375                                                                          ; enables Elite to scan for concurrent key presses of
0376                                                                          ; the primary flight keys, plus a secondary flight key
0377                                                                          ;
0378                                                                          ; See the deep dive on "The key logger" for more details
0379                                                                          ;
0380                                                                          ; If a key is being pressed that is not in the keyboard
0381                                                                          ; table at KYTB, it can be stored here (as seen in
0382                                                                          ; routine DK4, for example)
0383               
0384               KY1:
0385 0042                 bss 1                                               ; "?" is being pressed
0386                                                                          ;
0387                                                                          ; * 0 = no
0388                                                                          ;
0389                                                                          ; * Non-zero = yes
0390               
0391               KY2:
0392 0043                 bss 1                                               ; Space is being pressed
0393                                                                          ;
0394                                                                          ; * 0 = no
0395                                                                          ;
0396                                                                          ; * Non-zero = yes
0397               
0398               KY3:
0399 0044                 bss 1                                               ; "<" is being pressed
0400                                                                          ;
0401                                                                          ; * 0 = no
0402                                                                          ;
0403                                                                          ; * Non-zero = yes
0404               
0405               KY4:
0406 0045                 bss 1                                               ; ">" is being pressed
0407                                                                          ;
0408                                                                          ; * 0 = no
0409                                                                          ;
0410                                                                          ; * Non-zero = yes
0411               
0412               KY5:
0413 0046                 bss 1                                               ; "X" is being pressed
0414                                                                          ;
0415                                                                          ; * 0 = no
0416                                                                          ;
0417                                                                          ; * Non-zero = yes
0418               
0419               KY6:
0420 0047                 bss 1                                               ; "S" is being pressed
0421                                                                          ;
0422                                                                          ; * 0 = no
0423                                                                          ;
0424                                                                          ; * Non-zero = yes
0425               
0426               KY7:
0427 0048                 bss 1                                               ; "A" is being pressed
0428                                                                          ;
0429                                                                          ; * 0 = no
0430                                                                          ;
0431                                                                          ; * Non-zero = yes
0432                                                                          ;
0433                                                                          ; This is also set when the joystick fire button has
0434                                                                          ; been pressed
0435               
0436               KY12:
0437 0049                 bss 1                                               ; TAB is being pressed
0438                                                                          ;
0439                                                                          ; * 0 = no
0440                                                                          ;
0441                                                                          ; * Non-zero = yes
0442               
0443               KY13:
0444 004A                 bss 1                                               ; ESCAPE is being pressed
0445                                                                          ;
0446                                                                          ; * 0 = no
0447                                                                          ;
0448                                                                          ; * Non-zero = yes
0449               
0450               KY14:
0451 004B                 bss 1                                               ; "T" is being pressed
0452                                                                          ;
0453                                                                          ; * 0 = no
0454                                                                          ;
0455                                                                          ; * Non-zero = yes
0456               
0457               KY15:
0458 004C                 bss 1                                               ; "U" is being pressed
0459                                                                          ;
0460                                                                          ; * 0 = no
0461                                                                          ;
0462                                                                          ; * Non-zero = yes
0463               
0464               KY16:
0465 004D                 bss 1                                               ; "M" is being pressed
0466                                                                          ;
0467                                                                          ; * 0 = no
0468                                                                          ;
0469                                                                          ; * Non-zero = yes
0470               
0471               KY17:
0472 004E                 bss 1                                               ; "E" is being pressed
0473                                                                          ;
0474                                                                          ; * 0 = no
0475                                                                          ;
0476                                                                          ; * Non-zero = yes
0477               
0478               KY18:
0479 004F                 bss 1                                               ; "J" is being pressed
0480                                                                          ;
0481                                                                          ; * 0 = no
0482                                                                          ;
0483                                                                          ; * Non-zero = yes
0484               
0485               KY19:
0486 0050                 bss 1                                               ; "C" is being pressed
0487                                                                          ;
0488                                                                          ; * 0 = no
0489                                                                          ;
0490                                                                          ; * Non-zero = yes
0491               
0492               LAS:
0493 0051                 bss 1                                               ; Contains the laser power of the laser fitted to the
0494                                                                          ; current space view (or 0 if there is no laser fitted
0495                                                                          ; to the current view)
0496                                                                          ;
0497                                                                          ; This gets set to bits 0-6 of the laser power byte from
0498                                                                          ; the commander data block, which contains the laser's
0499                                                                          ; power (bit 7 doesn't denote laser power, just whether
0500                                                                          ; or not the laser pulses, so that is not stored here)
0501               
0502               MSTG:
0503 0052                 bss 1                                               ; The current missile lock target
0504                                                                          ;
0505                                                                          ; * &FF = no target
0506                                                                          ;
0507                                                                          ; * 1-12 = the slot number of the ship that our
0508                                                                          ; missile is locked onto
0509               
0510               XX1:
0511 0053                 bss 0                                               ; This is an alias for INWK that is used in the main
0512                                                                          ; ship-drawing routine at LL9
0513               
0514               INWK:
0515 0053                 bss 33                                              ; The zero-page internal workspace for the current ship
0516                                                                          ; data block
0517                                                                          ;
0518                                                                          ; As operations on zero page locations are faster and
0519                                                                          ; have smaller opcodes than operations on the rest of
0520                                                                          ; the addressable memory, Elite tends to store oft-used
0521                                                                          ; data here. A lot of the routines in Elite need to
0522                                                                          ; access and manipulate ship data, so to make this an
0523                                                                          ; efficient exercise, the ship data is first copied from
0524                                                                          ; the ship data blocks at K% into INWK (or, when new
0525                                                                          ; ships are spawned, from the blueprints at XX21). See
0526                                                                          ; the deep dive on "Ship data blocks" for details of
0527                                                                          ; what each of the bytes in the INWK data block
0528                                                                          ; represents
0529               
0530               XX19:
0531 0074                 bss NI. - 33                                        ; XX19(1 0) shares its location with INWK(34 33), which
0532                                                                          ; contains the address of the ship line heap
0533               
0534               LSP:
0535 0077                 bss 1                                               ; The ball line heap pointer, which contains the number
0536                                                                          ; of the first free byte after the end of the LSX2 and
0537                                                                          ; LSY2 heaps (see the deep dive on "The ball line heap"
0538                                                                          ; for details)
0539               
0540               QQ15:
0541 0078                 bss 6                                               ; The three 16-bit seeds for the selected system, i.e.
0542                                                                          ; the one in the crosshairs in the Short-range Chart
0543                                                                          ;
0544                                                                          ; See the deep dives on "Galaxy and system seeds" and
0545                                                                          ; "Twisting the system seeds" for more details
0546               
0547               K5:
0548 007E                 bss 0                                               ; Temporary storage used to store segment coordinates
0549                                                                          ; across successive calls to BLINE, the ball line
0550                                                                          ; routine
0551               
0552               XX18:
0553 007E                 bss 0                                               ; Temporary storage used to store coordinates in the
0554                                                                          ; LL9 ship-drawing routine
0555               
0556               QQ17:
0557 007E                 bss 1                                               ; Contains a number of flags that affect how text tokens
0558                                                                          ; are printed, particularly capitalisation:
0559                                                                          ;
0560                                                                          ; * If all bits are set (255) then text printing is
0561                                                                          ; disabled
0562                                                                          ;
0563                                                                          ; * Bit 7: 0 = ALL CAPS
0564                                                                          ; 1 = Sentence Case, bit 6 determines the
0565                                                                          ; case of the next letter to print
0566                                                                          ;
0567                                                                          ; * Bit 6: 0 = print the next letter in upper case
0568                                                                          ; 1 = print the next letter in lower case
0569                                                                          ;
0570                                                                          ; * Bits 0-5: If any of bits 0-5 are set, print in
0571                                                                          ; lower case
0572                                                                          ;
0573                                                                          ; So:
0574                                                                          ;
0575                                                                          ; * QQ17 = 0 means case is set to ALL CAPS
0576                                                                          ;
0577                                                                          ; * QQ17 = %10000000 means Sentence Case, currently
0578                                                                          ; printing upper case
0579                                                                          ;
0580                                                                          ; * QQ17 = %11000000 means Sentence Case, currently
0581                                                                          ; printing lower case
0582                                                                          ;
0583                                                                          ; * QQ17 = %11111111 means printing is disabled
0584               
0585               QQ19:
0586 007F                 bss 3                                               ; Temporary storage, used in a number of places
0587               
0588               K6:
0589 0082                 bss 5                                               ; Temporary storage, typically used for storing
0590                                                                          ; coordinates during vector calculations
0591               
0592               ALP1:
0593 0087                 bss 1                                               ; Magnitude of the roll angle alpha, i.e. |alpha|,
0594                                                                          ; which is a positive value between 0 and 31
0595               
0596               ALP2:
0597 0088                 bss 2                                               ; Bit 7 of ALP2 = sign of the roll angle in ALPHA
0598                                                                          ;
0599                                                                          ; Bit 7 of ALP2+1 = opposite sign to ALP2 and ALPHA
0600               
0601               BET2:
0602 008A                 bss 2                                               ; Bit 7 of BET2 = sign of the pitch angle in BETA
0603                                                                          ;
0604                                                                          ; Bit 7 of BET2+1 = opposite sign to BET2 and BETA
0605               
0606               DELTA:
0607 008C                 bss 1                                               ; Our current speed, in the range 1-40
0608               
0609               DELT4:
0610 008D                 bss 2                                               ; Our current speed * 64 as a 16-bit value
0611                                                                          ;
0612                                                                          ; This is stored as DELT4(1 0), so the high byte in
0613                                                                          ; DELT4+1 therefore contains our current speed / 4
0614               
0615               U:
0616 008F                 bss 1                                               ; Temporary storage, used in a number of places
0617               
0618               Q:
0619 0090                 bss 1                                               ; Temporary storage, used in a number of places
0620               
0621               R:
0622 0091                 bss 1                                               ; Temporary storage, used in a number of places
0623               
0624               S:
0625 0092                 bss 1                                               ; Temporary storage, used in a number of places
0626               
0627               XSAV:
0628 0093                 bss 1                                               ; Temporary storage for saving the value of the X
0629                                                                          ; register, used in a number of places
0630               
0631               YSAV:
0632 0094                 bss 1                                               ; Temporary storage for saving the value of the Y
0633                                                                          ; register, used in a number of places
0634               
0635               XX17:
0636 0095                 bss 1                                               ; Temporary storage, used in BPRNT to store the number
0637                                                                          ; of characters to print, and as the edge counter in the
0638                                                                          ; main ship-drawing routine
0639               
0640               QQ11:
0641 0096                 bss 1                                               ; The type of the current view:
0642                                                                          ;
0643                                                                          ; 0   = Space view
0644                                                                          ; 1   = Title screen
0645                                                                          ; Get commander name ("@", save/load commander)
0646                                                                          ; In-system jump just arrived ("J")
0647                                                                          ; Data on System screen (red key f6)
0648                                                                          ; Buy Cargo screen (red key f1)
0649                                                                          ; Mis-jump just arrived (witchspace)
0650                                                                          ; 4   = Sell Cargo screen (red key f2)
0651                                                                          ; 6   = Death screen
0652                                                                          ; 8   = Status Mode screen (red key f8)
0653                                                                          ; Inventory screen (red key f9)
0654                                                                          ; 16  = Market Price screen (red key f7)
0655                                                                          ; 32  = Equip Ship screen (red key f3)
0656                                                                          ; 64  = Long-range Chart (red key f4)
0657                                                                          ; 128 = Short-range Chart (red key f5)
0658                                                                          ;
0659                                                                          ; This value is typically set by calling routine TT66
0660               
0661               ZZ:
0662 0097                 bss 1                                               ; Temporary storage, typically used for distance values
0663               
0664               XX13:
0665 0098                 bss 1                                               ; Temporary storage, typically used in the line-drawing
0666                                                                          ; routines
0667               
0668               MCNT:
0669 0099                 bss 1                                               ; The main loop counter
0670                                                                          ;
0671                                                                          ; This counter determines how often certain actions are
0672                                                                          ; performed within the main loop. See the deep dive on
0673                                                                          ; "Scheduling tasks with the main loop counter" for more
0674                                                                          ; details
0675               
0676               DL:
0677 009A                 bss 1                                               ; Vertical sync flag
0678                                                                          ;
0679                                                                          ; DL gets set to 30 every time we reach vertical sync on
0680                                                                          ; the video system, which happens 50 times a second
0681                                                                          ; (50Hz). The WSCAN routine uses this to pause until the
0682                                                                          ; vertical sync, by setting DL to 0 and then monitoring
0683                                                                          ; its value until it changes to 30
0684               
0685               TYPE:
0686 009B                 bss 1                                               ; The current ship type
0687                                                                          ;
0688                                                                          ; This is where we store the current ship type for when
0689                                                                          ; we are iterating through the ships in the local bubble
0690                                                                          ; as part of the main flight loop. See the table at XX21
0691                                                                          ; for information about ship types
0692               
0693               JSTX:
0694 009C                 bss 1                                               ; Our current roll rate
0695                                                                          ;
0696                                                                          ; This value is shown in the dashboard's RL indicator,
0697                                                                          ; and determines the rate at which we are rolling
0698                                                                          ;
0699                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0700                                                                          ; point, so 1 means roll is decreasing at the maximum
0701                                                                          ; rate, 128 means roll is not changing, and 255 means
0702                                                                          ; roll is increasing at the maximum rate
0703                                                                          ;
0704                                                                          ; This value is updated by "<" and ">" key presses, or
0705                                                                          ; if joysticks are enabled, from the joystick. If
0706                                                                          ; keyboard damping is enabled (which it is by default),
0707                                                                          ; the value is slowly moved towards the centre value of
0708                                                                          ; 128 (no roll) if there are no key presses or joystick
0709                                                                          ; movement
0710               
0711               JSTY:
0712 009D                 bss 1                                               ; Our current pitch rate
0713                                                                          ;
0714                                                                          ; This value is shown in the dashboard's DC indicator,
0715                                                                          ; and determines the rate at which we are pitching
0716                                                                          ;
0717                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0718                                                                          ; point, so 1 means pitch is decreasing at the maximum
0719                                                                          ; rate, 128 means pitch is not changing, and 255 means
0720                                                                          ; pitch is increasing at the maximum rate
0721                                                                          ;
0722                                                                          ; This value is updated by "S" and "X" key presses, or
0723                                                                          ; if joysticks are enabled, from the joystick. If
0724                                                                          ; keyboard damping is enabled (which it is by default),
0725                                                                          ; the value is slowly moved towards the centre value of
0726                                                                          ; 128 (no pitch) if there are no key presses or joystick
0727                                                                          ; movement
0728               
0729               ALPHA:
0730 009E                 bss 1                                               ; The current roll angle alpha, which is reduced from
0731                                                                          ; JSTX to a sign-magnitude value between -31 and +31
0732                                                                          ;
0733                                                                          ; This describes how fast we are rolling our ship, and
0734                                                                          ; determines how fast the universe rolls around us
0735                                                                          ;
0736                                                                          ; The sign bit is also stored in ALP2, while the
0737                                                                          ; opposite sign is stored in ALP2+1
0738               
0739               QQ12:
0740 009F                 bss 1                                               ; Our "docked" status
0741                                                                          ;
0742                                                                          ; * 0 = we are not docked
0743                                                                          ;
0744                                                                          ; * &FF = we are docked
0745               
0746               TGT:
0747 00A0                 bss 1                                               ; Temporary storage, typically used as a target value
0748                                                                          ; for counters when drawing explosion clouds and partial
0749                                                                          ; circles
0750               
0751               SWAP:
0752 00A1                 bss 1                                               ; Temporary storage, used to store a flag that records
0753                                                                          ; whether or not we had to swap a line's start and end
0754                                                                          ; coordinates around when clipping the line in routine
0755                                                                          ; LL145 (the flag is used in places like BLINE to swap
0756                                                                          ; them back)
0757               
0758               COL:
0759 00A2                 bss 1                                               ; Temporary storage, used to store colour information
0760                                                                          ; when drawing pixels in the dashboard
0761               
0762               FLAG:
0763 00A3                 bss 1                                               ; A flag that's used to define whether this is the first
0764                                                                          ; call to the ball line routine in BLINE, so it knows
0765                                                                          ; whether to wait for the second call before storing
0766                                                                          ; segment data in the ball line heap
0767               
0768               CNT:
0769 00A4                 bss 1                                               ; Temporary storage, typically used for storing the
0770                                                                          ; number of iterations required when looping
0771               
0772               CNT2:
0773 00A5                 bss 1                                               ; Temporary storage, used in the planet-drawing routine
0774                                                                          ; to store the segment number where the arc of a partial
0775                                                                          ; circle should start
0776               
0777               STP:
0778 00A6                 bss 1                                               ; The step size for drawing circles
0779                                                                          ;
0780                                                                          ; Circles in Elite are split up into 64 points, and the
0781                                                                          ; step size determines how many points to skip with each
0782                                                                          ; straight-line segment, so the smaller the step size,
0783                                                                          ; the smoother the circle. The values used are:
0784                                                                          ;
0785                                                                          ; * 2 for big planets and the circles on the charts
0786                                                                          ; * 4 for medium planets and the launch tunnel
0787                                                                          ; * 8 for small planets and the hyperspace tunnel
0788                                                                          ;
0789                                                                          ; As the step size increases we move from smoother
0790                                                                          ; circles at the top to more polygonal at the bottom.
0791                                                                          ; See the CIRCLE2 routine for more details
0792               
0793               XX4:
0794 00A7                 bss 1                                               ; Temporary storage, used in a number of places
0795               
0796               XX20:
0797 00A8                 bss 1                                               ; Temporary storage, used in a number of places
0798               
0799               XX14:
0800 00A9                 bss 1                                               ; This byte appears to be unused
0801               
0802               RAT:
0803 00AA                 bss 1                                               ; Used to store different signs depending on the current
0804                                                                          ; space view, for use in calculating stardust movement
0805               
0806               RAT2:
0807 00AB                 bss 1                                               ; Temporary storage, used to store the pitch and roll
0808                                                                          ; signs when moving objects and stardust
0809               
0810               K2:
0811 00AC                 bss 4                                               ; Temporary storage, used in a number of places
0812               
0813               * RM: At &00B0 = 176
0814               
0815                      aorg ZERO_PAGE.+>00D1
0816               
0817               T:
0818 00D1                 bss 1                                               ; Temporary storage, used in a number of places
0819               
0820               K3:
0821 00D2                 bss 0                                               ; Temporary storage, used in a number of places
0822               
0823               XX2:
0824 00D2                 bss 14                                              ; Temporary storage, used to store the visibility of the
0825                                                                          ; ship's faces during the ship-drawing routine at LL9
0826               
0827               K4:
0828 00E0                 bss 2                                               ; Temporary storage, used in a number of places
0829               
0830                      ; PRINT "Zero page variables from ", ~ZP, " to ", ~P%
0831               
0832               * ******************************************************************************
0833               *
0834               * Name: XX3
0835               * Type: Workspace
0836               * Address: &0100 to the top of the descending stack
0837               * Category: Workspaces
0838               * Summary: Temporary storage space for complex calculations
0839               *
0840               * ------------------------------------------------------------------------------
0841               *
0842               * Used as heap space for storing temporary data during calculations. Shared with
0843               * the descending 6502 stack, which works down from &01FF.
0844               *
0845               * ******************************************************************************
0846               
0847                      aorg STACK.
0848               
0849               XX3:
0850 0100                 bss 256                                             ; Temporary storage, typically used for storing tables
0851                                                                          ; of values such as screen coordinates or ship data
0852               
0853               * ******************************************************************************
0854               *
0855               * Name: T%
0856               * Type: Workspace
0857               * Address: &0300 to &035F
0858               * Category: Workspaces
0859               * Summary: Current commander data and stardust data blocks
0860               *
0861               * ------------------------------------------------------------------------------
0862               *
0863               * Contains the current commander data (NT% bytes at location TP), and the
0864               * stardust data blocks (NOST bytes at location SX)
0865               *
0866               * ******************************************************************************
0867               
0868                      aorg T.
0869               
0870 0300                 bss 0                                               ; The start of the T% workspace
0871               
0872               TP:
0873 0300                 bss 1                                               ; The current mission status, which is always 0 for the
0874                                                                          ; cassette version of Elite as there are no missions
0875               
0876               QQ0:
0877 0301                 bss 1                                               ; The current system's galactic x-coordinate (0-256)
0878               
0879               QQ1:
0880 0302                 bss 1                                               ; The current system's galactic y-coordinate (0-256)
0881               
0882               QQ21:
0883 0303                 bss 6                                               ; The three 16-bit seeds for the current galaxy
0884                                                                          ;
0885                                                                          ; These seeds define system 0 in the current galaxy, so
0886                                                                          ; they can be used as a starting point to generate all
0887                                                                          ; 256 systems in the galaxy
0888                                                                          ;
0889                                                                          ; Using a galactic hyperdrive rotates each byte to the
0890                                                                          ; left (rolling each byte within itself) to get the
0891                                                                          ; seeds for the next galaxy, so after eight galactic
0892                                                                          ; jumps, the seeds roll around to the first galaxy again
0893                                                                          ;
0894                                                                          ; See the deep dives on "Galaxy and system seeds" and
0895                                                                          ; "Twisting the system seeds" for more details
0896               
0897               CASH:
0898 0309                 bss 4                                               ; Our current cash pot
0899                                                                          ;
0900                                                                          ; The cash stash is stored as a 32-bit unsigned integer,
0901                                                                          ; with the most significant byte in CASH and the least
0902                                                                          ; significant in CASH+3. This is big-endian, which is
0903                                                                          ; the opposite way round to most of the numbers used in
0904                                                                          ; Elite - to use our notation for multi-byte numbers,
0905                                                                          ; the amount of cash is CASH(0 1 2 3)
0906               
0907               QQ14:
0908 030D                 bss 1                                               ; Our current fuel level (0-70)
0909                                                                          ;
0910                                                                          ; The fuel level is stored as the number of light years
0911                                                                          ; multiplied by 10, so QQ14 = 1 represents 0.1 light
0912                                                                          ; years, and the maximum possible value is 70, for 7.0
0913                                                                          ; light years
0914               
0915               COK:
0916 030E                 bss 1                                               ; Flags used to generate the competition code
0917                                                                          ;
0918                                                                          ; See the deep dive on "The competition code" for
0919                                                                          ; details of these flags and how they are used in
0920                                                                          ; generating and decoding the competition code
0921               
0922               GCNT:
0923 030F                 bss 1                                               ; The number of the current galaxy (0-7)
0924                                                                          ;
0925                                                                          ; When this is displayed in-game, 1 is added to the
0926                                                                          ; number, so we start in galaxy 1 in-game, but it's
0927                                                                          ; stored as galaxy 0 internally
0928                                                                          ;
0929                                                                          ; The galaxy number increases by one every time a
0930                                                                          ; galactic hyperdrive is used, and wraps back around to
0931                                                                          ; the start after eight galaxies
0932               
0933               LASER:
0934 0310                 bss 4                                               ; The specifications of the lasers fitted to each of the
0935                                                                          ; four space views:
0936                                                                          ;
0937                                                                          ; * Byte #0 = front view
0938                                                                          ; * Byte #1 = rear view
0939                                                                          ; * Byte #2 = left view
0940                                                                          ; * Byte #3 = right view
0941                                                                          ;
0942                                                                          ; For each of the views:
0943                                                                          ;
0944                                                                          ; * 0 = no laser is fitted to this view
0945                                                                          ;
0946                                                                          ; * Non-zero = a laser is fitted to this view, with
0947                                                                          ; the following specification:
0948                                                                          ;
0949                                                                          ; * Bits 0-6 contain the laser's power
0950                                                                          ;
0951                                                                          ; * Bit 7 determines whether or not the laser pulses
0952                                                                          ; (0 = pulse laser) or is always on (1 = beam
0953                                                                          ; laser)
0954               
0955 0314                 bss 2                                               ; These bytes appear to be unused (they were originally
0956                                                                          ; used for up/down lasers, but they were dropped)
0957               
0958               CRGO:
0959 0316                 bss 1                                               ; Our ship's cargo capacity
0960                                                                          ;
0961                                                                          ; * 22 = standard cargo bay of 20 tonnes
0962                                                                          ;
0963                                                                          ; * 37 = large cargo bay of 35 tonnes
0964                                                                          ;
0965                                                                          ; The value is two greater than the actual capacity to
0966                                                                          ; make the maths in tnpr slightly more efficient
0967               
0968               QQ20:
0969 0317                 bss 17                                              ; The contents of our cargo hold
0970                                                                          ;
0971                                                                          ; The amount of market item X that we have in our hold
0972                                                                          ; can be found in the X-th byte of QQ20. For example:
0973                                                                          ;
0974                                                                          ; * QQ20 contains the amount of food (item 0)
0975                                                                          ;
0976                                                                          ; * QQ20+7 contains the amount of computers (item 7)
0977                                                                          ;
0978                                                                          ; See QQ23 for a list of market item numbers and their
0979                                                                          ; storage units
0980               
0981               ECM:
0982 0328                 bss 1                                               ; E.C.M. system
0983                                                                          ;
0984                                                                          ; * 0 = not fitted
0985                                                                          ;
0986                                                                          ; * &FF = fitted
0987               
0988               BST:
0989 0329                 bss 1                                               ; Fuel scoops (BST stands for "barrel status")
0990                                                                          ;
0991                                                                          ; * 0 = not fitted
0992                                                                          ;
0993                                                                          ; * &FF = fitted
0994               
0995               BOMB:
0996 032A                 bss 1                                               ; Energy bomb
0997                                                                          ;
0998                                                                          ; * 0 = not fitted
0999                                                                          ;
1000                                                                          ; * &7F = fitted
1001               
1002               ENGY:
1003 032B                 bss 1                                               ; Energy unit
1004                                                                          ;
1005                                                                          ; * 0 = not fitted
1006                                                                          ;
1007                                                                          ; * Non-zero = fitted
1008                                                                          ;
1009                                                                          ; The actual value determines the refresh rate of our
1010                                                                          ; energy banks, as they refresh by ENGY+1 each time (so
1011                                                                          ; our ship's energy level goes up by 2 each time if we
1012                                                                          ; have an energy unit fitted, otherwise it goes up by 1)
1013               
1014               DKCMP:
1015 032C                 bss 1                                               ; Docking computer
1016                                                                          ;
1017                                                                          ; * 0 = not fitted
1018                                                                          ;
1019                                                                          ; * &FF = fitted
1020               
1021               GHYP:
1022 032D                 bss 1                                               ; Galactic hyperdrive
1023                                                                          ;
1024                                                                          ; * 0 = not fitted
1025                                                                          ;
1026                                                                          ; * &FF = fitted
1027               
1028               ESCP:
1029 032E                 bss 1                                               ; Escape pod
1030                                                                          ;
1031                                                                          ; * 0 = not fitted
1032                                                                          ;
1033                                                                          ; * &FF = fitted
1034               
1035 032F                 bss 4                                               ; These bytes appear to be unused
1036               
1037               NOMSL:
1038 0333                 bss 1                                               ; The number of missiles we have fitted (0-4)
1039               
1040               FIST:
1041 0334                 bss 1                                               ; Our legal status (FIST stands for "fugitive/innocent
1042                                                                          ; status"):
1043                                                                          ;
1044                                                                          ; * 0 = Clean
1045                                                                          ;
1046                                                                          ; * 1-49 = Offender
1047                                                                          ;
1048                                                                          ; * 50+ = Fugitive
1049                                                                          ;
1050                                                                          ; You get 64 points if you kill a cop, so that's a fast
1051                                                                          ; ticket to fugitive status
1052               
1053               AVL:
1054 0335                 bss 17                                              ; Market availability in the current system
1055                                                                          ;
1056                                                                          ; The available amount of market item X is stored in
1057                                                                          ; the X-th byte of AVL, so for example:
1058                                                                          ;
1059                                                                          ; * AVL contains the amount of food (item 0)
1060                                                                          ;
1061                                                                          ; * AVL+7 contains the amount of computers (item 7)
1062                                                                          ;
1063                                                                          ; See QQ23 for a list of market item numbers and their
1064                                                                          ; storage units, and the deep dive on "Market item
1065                                                                          ; prices and availability" for details of the algorithm
1066                                                                          ; used for calculating each item's availability
1067               
1068               QQ26:
1069 0346                 bss 1                                               ; A random value used to randomise market data
1070                                                                          ;
1071                                                                          ; This value is set to a new random number for each
1072                                                                          ; change of system, so we can add a random factor into
1073                                                                          ; the calculations for market prices (for details of how
1074                                                                          ; this is used, see the deep dive on "Market prices")
1075               
1076               TALLY:
1077 0347                 bss 2                                               ; Our combat rank
1078                                                                          ;
1079                                                                          ; The combat rank is stored as the number of kills, in a
1080                                                                          ; 16-bit number TALLY(1 0) - so the high byte is in
1081                                                                          ; TALLY+1 and the low byte in TALLY
1082                                                                          ;
1083                                                                          ; If the high byte in TALLY+1 is 0 then we have between
1084                                                                          ; 0 and 255 kills, so our rank is Harmless, Mostly
1085                                                                          ; Harmless, Poor, Average or Above Average, according to
1086                                                                          ; the value of the low byte in TALLY:
1087                                                                          ;
1088                                                                          ; Harmless        = %00000000 to %00000011 = 0 to 3
1089                                                                          ; Mostly Harmless = %00000100 to %00000111 = 4 to 7
1090                                                                          ; Poor            = %00001000 to %00001111 = 8 to 15
1091                                                                          ; Average         = %00010000 to %00011111 = 16 to 31
1092                                                                          ; Above Average   = %00100000 to %11111111 = 32 to 255
1093                                                                          ;
1094                                                                          ; If the high byte in TALLY+1 is non-zero then we are
1095                                                                          ; Competent, Dangerous, Deadly or Elite, according to
1096                                                                          ; the high byte in TALLY+1:
1097                                                                          ;
1098                                                                          ; Competent       = 1           = 256 to 511 kills
1099                                                                          ; Dangerous       = 2 to 9      = 512 to 2559 kills
1100                                                                          ; Deadly          = 10 to 24    = 2560 to 6399 kills
1101                                                                          ; Elite           = 25 and up   = 6400 kills and up
1102                                                                          ;
1103                                                                          ; You can see the rating calculation in the STATUS
1104                                                                          ; subroutine
1105               
1106               SVC:
1107 0349                 bss 1                                               ; The save count
1108                                                                          ;
1109                                                                          ; When a new commander is created, the save count gets
1110                                                                          ; set to 128. This value gets halved each time the
1111                                                                          ; commander file is saved, but it is otherwise unused.
1112                                                                          ; It is presumably part of the security system for the
1113                                                                          ; competition, possibly another flag to catch out
1114                                                                          ; entries with manually altered commander files
1115               
1116 034A                 bss 2                                               ; The commander file checksum
1117                                                                          ;
1118                                                                          ; These two bytes are reserved for the commander file
1119                                                                          ; checksum, so when the current commander block is
1120                                                                          ; copied from here to the last saved commander block at
1121                                                                          ; NA%, CHK and CHK2 get overwritten
1122               
1123               NT.:                                                       ; This sets the variable NT% to the size of the current
1124                      equ SVC + 2 - TP
1125                                                                          ; commander data block, which starts at TP and ends at
1126                                                                          ; SVC+2 (inclusive)
1127               
1128               SX:
1129 034C                 bss NOST + 1                                        ; This is where we store the x_hi coordinates for all
1130                                                                          ; the stardust particles
1131               
1132               SXL:
1133 035F                 bss NOST + 1                                        ; This is where we store the x_lo coordinates for all
1134                                                                          ; the stardust particles
1135               
1136                      ; PRINT "T% workspace from  ", ~T%, " to ", ~P%
1137               
1138               * ******************************************************************************
1139               *
1140               * ELITE RECURSIVE TEXT TOKEN FILE
1141               *
1142               * Produces the binary file WORDS9.bin that gets loaded by elite-loader.asm.
1143               *
1144               * The recursive token table is loaded at &1100 and is moved down to &0400 as
1145               * part of elite-loader.asm, so it ends up at &0400 to &07FF.
1146               *
1147               * ******************************************************************************
1148               
1149                      aorg CODE_WORDS.
1150               
1151               * ******************************************************************************
1152               *
1153               * Name: CHAR
1154               * Type: Macro
1155               * Category: Text
1156               * Summary: Macro definition for characters in the recursive token table
1157               * Deep dive: Printing text tokens
1158               *
1159               * ------------------------------------------------------------------------------
1160               *
1161               * The following macro is used when building the recursive token table:
1162               *
1163               * CHAR 'x'            Insert ASCII character "x"
1164               *
1165               * To include an apostrophe, use a backtick character, as in CHAR '`'.
1166               *
1167               * See the deep dive on "Printing text tokens" for details on how characters are
1168               * stored in the recursive token table.
1169               *
1170               * ------------------------------------------------------------------------------
1171               *
1172               * Arguments:
1173               *
1174               * 'x'                 The character to insert into the table
1175               *
1176               * ******************************************************************************
1177               
1178                      ; MACRO CHAR x
1179               
1180                      ; IF x = '`'                    ;
1181                      ; EQUB 39 EOR RE                ;
1182                      ; ELSE                          ;
1183                      ; EQUB x EOR RE                 ;
1184                      ; ENDIF                         ;
1185               
1186                      ; ENDMACRO
1187               
1188               * ******************************************************************************
1189               *
1190               * Name: TWOK
1191               * Type: Macro
1192               * Category: Text
1193               * Summary: Macro definition for two-letter tokens in the token table
1194               * Deep dive: Printing text tokens
1195               *
1196               * ------------------------------------------------------------------------------
1197               *
1198               * The following macro is used when building the recursive token table:
1199               *
1200               * TWOK 'x', 'y'       Insert two-letter token "xy"
1201               *
1202               * See the deep dive on "Printing text tokens" for details on how two-letter
1203               * tokens are stored in the recursive token table.
1204               *
1205               * ------------------------------------------------------------------------------
1206               *
1207               * Arguments:
1208               *
1209               * 'x'                 The first letter of the two-letter token to insert into
1210               * the table
1211               *
1212               * 'y'                 The second letter of the two-letter token to insert into
1213               * the table
1214               *
1215               * ******************************************************************************
1216               
1217                      ; MACRO TWOK t, k
1218               
1219                      ; IF t = 'A' AND k = 'L' : EQUB 128 EOR RE : ENDIF ;
1220                      ; IF t = 'L' AND k = 'E' : EQUB 129 EOR RE : ENDIF ;
1221                      ; IF t = 'X' AND k = 'E' : EQUB 130 EOR RE : ENDIF ;
1222                      ; IF t = 'G' AND k = 'E' : EQUB 131 EOR RE : ENDIF ;
1223                      ; IF t = 'Z' AND k = 'A' : EQUB 132 EOR RE : ENDIF ;
1224                      ; IF t = 'C' AND k = 'E' : EQUB 133 EOR RE : ENDIF ;
1225                      ; IF t = 'B' AND k = 'I' : EQUB 134 EOR RE : ENDIF ;
1226                      ; IF t = 'S' AND k = 'O' : EQUB 135 EOR RE : ENDIF ;
1227                      ; IF t = 'U' AND k = 'S' : EQUB 136 EOR RE : ENDIF ;
1228                      ; IF t = 'E' AND k = 'S' : EQUB 137 EOR RE : ENDIF ;
1229                      ; IF t = 'A' AND k = 'R' : EQUB 138 EOR RE : ENDIF ;
1230                      ; IF t = 'M' AND k = 'A' : EQUB 139 EOR RE : ENDIF ;
1231                      ; IF t = 'I' AND k = 'N' : EQUB 140 EOR RE : ENDIF ;
1232                      ; IF t = 'D' AND k = 'I' : EQUB 141 EOR RE : ENDIF ;
1233                      ; IF t = 'R' AND k = 'E' : EQUB 142 EOR RE : ENDIF ;
1234                      ; IF t = 'A' AND k = '?' : EQUB 143 EOR RE : ENDIF ;
1235                      ; IF t = 'E' AND k = 'R' : EQUB 144 EOR RE : ENDIF ;
1236                      ; IF t = 'A' AND k = 'T' : EQUB 145 EOR RE : ENDIF ;
1237                      ; IF t = 'E' AND k = 'N' : EQUB 146 EOR RE : ENDIF ;
1238                      ; IF t = 'B' AND k = 'E' : EQUB 147 EOR RE : ENDIF ;
1239                      ; IF t = 'R' AND k = 'A' : EQUB 148 EOR RE : ENDIF ;
1240                      ; IF t = 'L' AND k = 'A' : EQUB 149 EOR RE : ENDIF ;
1241                      ; IF t = 'V' AND k = 'E' : EQUB 150 EOR RE : ENDIF ;
1242                      ; IF t = 'T' AND k = 'I' : EQUB 151 EOR RE : ENDIF ;
1243                      ; IF t = 'E' AND k = 'D' : EQUB 152 EOR RE : ENDIF ;
1244                      ; IF t = 'O' AND k = 'R' : EQUB 153 EOR RE : ENDIF ;
1245                      ; IF t = 'Q' AND k = 'U' : EQUB 154 EOR RE : ENDIF ;
1246                      ; IF t = 'A' AND k = 'N' : EQUB 155 EOR RE : ENDIF ;
1247                      ; IF t = 'T' AND k = 'E' : EQUB 156 EOR RE : ENDIF ;
1248                      ; IF t = 'I' AND k = 'S' : EQUB 157 EOR RE : ENDIF ;
1249                      ; IF t = 'R' AND k = 'I' : EQUB 158 EOR RE : ENDIF ;
1250                      ; IF t = 'O' AND k = 'N' : EQUB 159 EOR RE : ENDIF ;
1251               
1252                      ; ENDMACRO
1253               
1254               * ******************************************************************************
1255               *
1256               * Name: CONT
1257               * Type: Macro
1258               * Category: Text
1259               * Summary: Macro definition for control codes in the recursive token table
1260               * Deep dive: Printing text tokens
1261               *
1262               * ------------------------------------------------------------------------------
1263               *
1264               * The following macro is used when building the recursive token table:
1265               *
1266               * CONT n              Insert control code token {n}
1267               *
1268               * See the deep dive on "Printing text tokens" for details on how characters are
1269               * stored in the recursive token table.
1270               *
1271               * ------------------------------------------------------------------------------
1272               *
1273               * Arguments:
1274               *
1275               * n                   The control code to insert into the table
1276               *
1277               * ******************************************************************************
1278               
1279                      ; MACRO CONT n
1280               
1281                      ; EQUB n EOR RE                 ;
1282               
1283                      ; ENDMACRO
1284               
1285               * ******************************************************************************
1286               *
1287               * Name: RTOK
1288               * Type: Macro
1289               * Category: Text
1290               * Summary: Macro definition for recursive tokens in the recursive token table
1291               * Deep dive: Printing text tokens
1292               *
1293               * ------------------------------------------------------------------------------
1294               *
1295               * The following macro is used when building the recursive token table:
1296               *
1297               * RTOK n              Insert recursive token [n]
1298               *
1299               * * Tokens 0-95 get stored as n + 160
1300               *
1301               * * Tokens 128-145 get stored as n - 114
1302               *
1303               * * Tokens 96-127 get stored as n
1304               *
1305               * See the deep dive on "Printing text tokens" for details on how recursive
1306               * tokens are stored in the recursive token table.
1307               *
1308               * ------------------------------------------------------------------------------
1309               *
1310               * Arguments:
1311               *
1312               * n                   The number of the recursive token to insert into the
1313               * table, in the range 0 to 145
1314               *
1315               * ******************************************************************************
1316               
1317                      ; MACRO RTOK n
1318               
1319                      ; IF n >= 0 AND n <= 95         ;
1320                      ; t = n + 160                   ;
1321                      ; ELIF n >= 128                 ;
1322                      ; t = n - 114                   ;
1323                      ; ELSE                          ;
1324                      ; t = n                         ;
1325                      ; ENDIF                         ;
1326               
1327                      ; EQUB t EOR RE                 ;
1328               
1329                      ; ENDMACRO
1330               
1331               * ******************************************************************************
1332               *
1333               * Name: QQ18
1334               * Type: Variable
1335               * Category: Text
1336               * Summary: The recursive token table for tokens 0-148
1337               * Deep dive: Printing text tokens
1338               *
1339               * ******************************************************************************
1340               
1341               QQ18:
1342                      .rtok 111                                           ; Token 0:      "FUEL SCOOPS ON {beep}"
     **** ****     > RTOK
0008 0400 4C              byte 111 ^ RE
                   < elite.a99
1343                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0401   32            byte (131 - 114) ^ RE
                   < elite.a99
1344                      .cont 7                                             ; Encoded as:   "[111][131]{7}"
     **** ****     > CONT
0001 0402 24              byte 7 ^ RE
                   < elite.a99
1345 0403   00            byte >00
1346               
1347                      .char ' '                                           ; Token 1:      " CHART"
     **** ****     > CHAR
0004 0404 03              byte ' ' ^ RE
                   < elite.a99
1348                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0405   60            byte 'C' ^ RE
                   < elite.a99
1349                      .char 'H'                                           ; Encoded as:   " CH<138>T"
     **** ****     > CHAR
0004 0406 6B              byte 'H' ^ RE
                   < elite.a99
1350 0407   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1351                      .char 'T'
     **** ****     > CHAR
0004 0408 77              byte 'T' ^ RE
                   < elite.a99
1352 0409   00            byte >00
1353               
1354                      .char 'G'                                           ; Token 2:      "GOVERNMENT"
     **** ****     > CHAR
0004 040A 64              byte 'G' ^ RE
                   < elite.a99
1355                      .char 'O'                                           ;
     **** ****     > CHAR
0004 040B   6C            byte 'O' ^ RE
                   < elite.a99
1356 040C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "GO<150>RNM<146>T"
1357                      .char 'R'
     **** ****     > CHAR
0004 040D   71            byte 'R' ^ RE
                   < elite.a99
1358                      .char 'N'
     **** ****     > CHAR
0004 040E 6D              byte 'N' ^ RE
                   < elite.a99
1359                      .char 'M'
     **** ****     > CHAR
0004 040F   6E            byte 'M' ^ RE
                   < elite.a99
1360 0410 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1361                      .char 'T'
     **** ****     > CHAR
0004 0411   77            byte 'T' ^ RE
                   < elite.a99
1362 0412 00              byte >00
1363               
1364                      .char 'D'                                           ; Token 3:      "DATA ON {selected system name}"
     **** ****     > CHAR
0004 0413   67            byte 'D' ^ RE
                   < elite.a99
1365 0414 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T'
1366                      .char 'A'                                           ; Encoded as:   "D<145>A[131]{3}"
     **** ****     > CHAR
0004 0415   62            byte 'A' ^ RE
                   < elite.a99
1367                      .rtok 131
     **** ****     > RTOK
0006 0416 32              byte (131 - 114) ^ RE
                   < elite.a99
1368                      .cont 3
     **** ****     > CONT
0001 0417   20            byte 3 ^ RE
                   < elite.a99
1369 0418 00              byte >00
1370               
1371 0419   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 4:      "INVENTORY{crlf}
1372 041A B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' "
1373                      .char 'N'                                           ;
     **** ****     > CHAR
0004 041B   6D            byte 'N' ^ RE
                   < elite.a99
1374                      .char 'T'                                           ; Encoded as:   "<140><150>NT<153>Y{13}"
     **** ****     > CHAR
0004 041C 77              byte 'T' ^ RE
                   < elite.a99
1375 041D   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1376                      .char 'Y'
     **** ****     > CHAR
0004 041E 7A              byte 'Y' ^ RE
                   < elite.a99
1377                      .cont 13
     **** ****     > CONT
0001 041F   2E            byte 13 ^ RE
                   < elite.a99
1378 0420 00              byte >00
1379               
1380                      .char 'S'                                           ; Token 5:      "SYSTEM"
     **** ****     > CHAR
0004 0421   70            byte 'S' ^ RE
                   < elite.a99
1381                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0422 7A              byte 'Y' ^ RE
                   < elite.a99
1382                      .char 'S'                                           ; Encoded as:   "SYS<156>M"
     **** ****     > CHAR
0004 0423   70            byte 'S' ^ RE
                   < elite.a99
1383 0424 BF              byte 156 ^ RE                                       ; TWOK 'T', 'E' null
1384                      .char 'M'
     **** ****     > CHAR
0004 0425   6E            byte 'M' ^ RE
                   < elite.a99
1385 0426 00              byte >00
1386               
1387                      .char 'P'                                           ; Token 6:      "PRICE"
     **** ****     > CHAR
0004 0427   73            byte 'P' ^ RE
                   < elite.a99
1388 0428 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I'
1389 0429   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' Encoded as:   "P<158><133>"
1390 042A 00              byte >00
1391               
1392                      .cont 2                                             ; Token 7:      "{current system name} MARKET PRICES"
     **** ****     > CONT
0001 042B   21            byte 2 ^ RE
                   < elite.a99
1393                      .char ' '                                           ;
     **** ****     > CHAR
0004 042C 03              byte ' ' ^ RE
                   < elite.a99
1394 042D   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A' Encoded as:   "{2} <139>RKET [6]S"
1395                      .char 'R'
     **** ****     > CHAR
0004 042E 71              byte 'R' ^ RE
                   < elite.a99
1396                      .char 'K'
     **** ****     > CHAR
0004 042F   68            byte 'K' ^ RE
                   < elite.a99
1397                      .char 'E'
     **** ****     > CHAR
0004 0430 66              byte 'E' ^ RE
                   < elite.a99
1398                      .char 'T'
     **** ****     > CHAR
0004 0431   77            byte 'T' ^ RE
                   < elite.a99
1399                      .char ' '
     **** ****     > CHAR
0004 0432 03              byte ' ' ^ RE
                   < elite.a99
1400                      .rtok 6
     **** ****     > RTOK
0003 0433   85            byte (6 + 160) ^ RE
                   < elite.a99
1401                      .char 'S'
     **** ****     > CHAR
0004 0434 70              byte 'S' ^ RE
                   < elite.a99
1402 0435   00            byte >00
1403               
1404 0436 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 8:      "INDUSTRIAL"
1405                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0437   67            byte 'D' ^ RE
                   < elite.a99
1406 0438 AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' Encoded as:   "<140>D<136>T<158><128>"
1407                      .char 'T'
     **** ****     > CHAR
0004 0439   77            byte 'T' ^ RE
                   < elite.a99
1408 043A BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1409 043B   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1410 043C 00              byte >00
1411               
1412                      .char 'A'                                           ; Token 9:      "AGRICULTURAL"
     **** ****     > CHAR
0004 043D   62            byte 'A' ^ RE
                   < elite.a99
1413                      .char 'G'                                           ;
     **** ****     > CHAR
0004 043E 64              byte 'G' ^ RE
                   < elite.a99
1414 043F   BD            byte 158 ^ RE                                       ; TWOK 'R', 'I' Encoded as:   "AG<158>CULTU<148>L"
1415                      .char 'C'
     **** ****     > CHAR
0004 0440 60              byte 'C' ^ RE
                   < elite.a99
1416                      .char 'U'
     **** ****     > CHAR
0004 0441   76            byte 'U' ^ RE
                   < elite.a99
1417                      .char 'L'
     **** ****     > CHAR
0004 0442 6F              byte 'L' ^ RE
                   < elite.a99
1418                      .char 'T'
     **** ****     > CHAR
0004 0443   77            byte 'T' ^ RE
                   < elite.a99
1419                      .char 'U'
     **** ****     > CHAR
0004 0444 76              byte 'U' ^ RE
                   < elite.a99
1420 0445   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1421                      .char 'L'
     **** ****     > CHAR
0004 0446 6F              byte 'L' ^ RE
                   < elite.a99
1422 0447   00            byte >00
1423               
1424 0448 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 10:     "RICH "
1425                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0449   60            byte 'C' ^ RE
                   < elite.a99
1426                      .char 'H'                                           ; Encoded as:   "<158>CH "
     **** ****     > CHAR
0004 044A 6B              byte 'H' ^ RE
                   < elite.a99
1427                      .char ' '
     **** ****     > CHAR
0004 044B   03            byte ' ' ^ RE
                   < elite.a99
1428 044C 00              byte >00
1429               
1430                      .char 'A'                                           ; Token 11:     "AVERAGE "
     **** ****     > CHAR
0004 044D   62            byte 'A' ^ RE
                   < elite.a99
1431 044E B5              byte 150 ^ RE                                       ; TWOK 'V', 'E'
1432 044F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Encoded as:   "A<150><148><131> "
1433 0450 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' null
1434                      .char ' '
     **** ****     > CHAR
0004 0451   03            byte ' ' ^ RE
                   < elite.a99
1435 0452 00              byte >00
1436               
1437                      .char 'P'                                           ; Token 12:     "POOR "
     **** ****     > CHAR
0004 0453   73            byte 'P' ^ RE
                   < elite.a99
1438                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0454 6C              byte 'O' ^ RE
                   < elite.a99
1439 0455   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "PO<153> "
1440                      .char ' '
     **** ****     > CHAR
0004 0456 03              byte ' ' ^ RE
                   < elite.a99
1441 0457   00            byte >00
1442               
1443 0458 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 13:     "MAINLY "
1444 0459   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1445                      .char 'L'                                           ; Encoded as:   "<139><140>LY "
     **** ****     > CHAR
0004 045A 6F              byte 'L' ^ RE
                   < elite.a99
1446                      .char 'Y'
     **** ****     > CHAR
0004 045B   7A            byte 'Y' ^ RE
                   < elite.a99
1447                      .char ' '
     **** ****     > CHAR
0004 045C 03              byte ' ' ^ RE
                   < elite.a99
1448 045D   00            byte >00
1449               
1450                      .char 'U'                                           ; Token 14:     "UNIT"
     **** ****     > CHAR
0004 045E 76              byte 'U' ^ RE
                   < elite.a99
1451                      .char 'N'                                           ;
     **** ****     > CHAR
0004 045F   6D            byte 'N' ^ RE
                   < elite.a99
1452                      .char 'I'                                           ; Encoded as:   "UNIT"
     **** ****     > CHAR
0004 0460 6A              byte 'I' ^ RE
                   < elite.a99
1453                      .char 'T'
     **** ****     > CHAR
0004 0461   77            byte 'T' ^ RE
                   < elite.a99
1454 0462 00              byte >00
1455               
1456                      .char 'V'                                           ; Token 15:     "VIEW "
     **** ****     > CHAR
0004 0463   75            byte 'V' ^ RE
                   < elite.a99
1457                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0464 6A              byte 'I' ^ RE
                   < elite.a99
1458                      .char 'E'                                           ; Encoded as:   "VIEW "
     **** ****     > CHAR
0004 0465   66            byte 'E' ^ RE
                   < elite.a99
1459                      .char 'W'
     **** ****     > CHAR
0004 0466 74              byte 'W' ^ RE
                   < elite.a99
1460                      .char ' '
     **** ****     > CHAR
0004 0467   03            byte ' ' ^ RE
                   < elite.a99
1461 0468 00              byte >00
1462               
1463 0469   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Token 16:     "QUANTITY"
1464 046A B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1465 046B   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<154><155><151>TY"
1466                      .char 'T'
     **** ****     > CHAR
0004 046C 77              byte 'T' ^ RE
                   < elite.a99
1467                      .char 'Y'
     **** ****     > CHAR
0004 046D   7A            byte 'Y' ^ RE
                   < elite.a99
1468 046E 00              byte >00
1469               
1470 046F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Token 17:     "ANARCHY"
1471 0470 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1472                      .char 'C'                                           ; Encoded as:   "<155><138>CHY"
     **** ****     > CHAR
0004 0471   60            byte 'C' ^ RE
                   < elite.a99
1473                      .char 'H'
     **** ****     > CHAR
0004 0472 6B              byte 'H' ^ RE
                   < elite.a99
1474                      .char 'Y'
     **** ****     > CHAR
0004 0473   7A            byte 'Y' ^ RE
                   < elite.a99
1475 0474 00              byte >00
1476               
1477                      .char 'F'                                           ; Token 18:     "FEUDAL"
     **** ****     > CHAR
0004 0475   65            byte 'F' ^ RE
                   < elite.a99
1478                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0476 66              byte 'E' ^ RE
                   < elite.a99
1479                      .char 'U'                                           ; Encoded as:   "FEUD<128>"
     **** ****     > CHAR
0004 0477   76            byte 'U' ^ RE
                   < elite.a99
1480                      .char 'D'
     **** ****     > CHAR
0004 0478 67              byte 'D' ^ RE
                   < elite.a99
1481 0479   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1482 047A 00              byte >00
1483               
1484                      .char 'M'                                           ; Token 19:     "MULTI-GOVERNMENT"
     **** ****     > CHAR
0004 047B   6E            byte 'M' ^ RE
                   < elite.a99
1485                      .char 'U'                                           ;
     **** ****     > CHAR
0004 047C 76              byte 'U' ^ RE
                   < elite.a99
1486                      .char 'L'                                           ; Encoded as:   "MUL<151>-[2]"
     **** ****     > CHAR
0004 047D   6F            byte 'L' ^ RE
                   < elite.a99
1487 047E B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1488                      .char '-'
     **** ****     > CHAR
0004 047F   0E            byte '-' ^ RE
                   < elite.a99
1489                      .rtok 2
     **** ****     > RTOK
0003 0480 81              byte (2 + 160) ^ RE
                   < elite.a99
1490 0481   00            byte >00
1491               
1492 0482 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 20:     "DICTATORSHIP"
1493                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0483   60            byte 'C' ^ RE
                   < elite.a99
1494                      .char 'T'                                           ; Encoded as:   "<141>CT<145><153>[25]"
     **** ****     > CHAR
0004 0484 77              byte 'T' ^ RE
                   < elite.a99
1495 0485   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1496 0486 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1497                      .rtok 25
     **** ****     > RTOK
0003 0487   9A            byte (25 + 160) ^ RE
                   < elite.a99
1498 0488 00              byte >00
1499               
1500                      .rtok 91                                            ; Token 21:     "COMMUNIST"
     **** ****     > RTOK
0003 0489   D8            byte (91 + 160) ^ RE
                   < elite.a99
1501                      .char 'M'                                           ;
     **** ****     > CHAR
0004 048A 6E              byte 'M' ^ RE
                   < elite.a99
1502                      .char 'U'                                           ; Encoded as:   "[91]MUN<157>T"
     **** ****     > CHAR
0004 048B   76            byte 'U' ^ RE
                   < elite.a99
1503                      .char 'N'
     **** ****     > CHAR
0004 048C 6D              byte 'N' ^ RE
                   < elite.a99
1504 048D   BE            byte 157 ^ RE                                       ; TWOK 'I', 'S' null
1505                      .char 'T'
     **** ****     > CHAR
0004 048E 77              byte 'T' ^ RE
                   < elite.a99
1506 048F   00            byte >00
1507               
1508                      .char 'C'                                           ; Token 22:     "CONFEDERACY"
     **** ****     > CHAR
0004 0490 60              byte 'C' ^ RE
                   < elite.a99
1509 0491   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1510                      .char 'F'                                           ; Encoded as:   "C<159>F<152><144>ACY"
     **** ****     > CHAR
0004 0492 65              byte 'F' ^ RE
                   < elite.a99
1511 0493   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1512 0494 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1513                      .char 'A'
     **** ****     > CHAR
0004 0495   62            byte 'A' ^ RE
                   < elite.a99
1514                      .char 'C'
     **** ****     > CHAR
0004 0496 60              byte 'C' ^ RE
                   < elite.a99
1515                      .char 'Y'
     **** ****     > CHAR
0004 0497   7A            byte 'Y' ^ RE
                   < elite.a99
1516 0498 00              byte >00
1517               
1518                      .char 'D'                                           ; Token 23:     "DEMOCRACY"
     **** ****     > CHAR
0004 0499   67            byte 'D' ^ RE
                   < elite.a99
1519                      .char 'E'                                           ;
     **** ****     > CHAR
0004 049A 66              byte 'E' ^ RE
                   < elite.a99
1520                      .char 'M'                                           ; Encoded as:   "DEMOC<148>CY"
     **** ****     > CHAR
0004 049B   6E            byte 'M' ^ RE
                   < elite.a99
1521                      .char 'O'
     **** ****     > CHAR
0004 049C 6C              byte 'O' ^ RE
                   < elite.a99
1522                      .char 'C'
     **** ****     > CHAR
0004 049D   60            byte 'C' ^ RE
                   < elite.a99
1523 049E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1524                      .char 'C'
     **** ****     > CHAR
0004 049F   60            byte 'C' ^ RE
                   < elite.a99
1525                      .char 'Y'
     **** ****     > CHAR
0004 04A0 7A              byte 'Y' ^ RE
                   < elite.a99
1526 04A1   00            byte >00
1527               
1528                      .char 'C'                                           ; Token 24:     "CORPORATE STATE"
     **** ****     > CHAR
0004 04A2 60              byte 'C' ^ RE
                   < elite.a99
1529 04A3   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R'
1530                      .char 'P'                                           ; Encoded as:   "C<153>P<153><145>E [43]<145>E"
     **** ****     > CHAR
0004 04A4 73              byte 'P' ^ RE
                   < elite.a99
1531 04A5   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1532 04A6 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1533                      .char 'E'
     **** ****     > CHAR
0004 04A7   66            byte 'E' ^ RE
                   < elite.a99
1534                      .char ' '
     **** ****     > CHAR
0004 04A8 03              byte ' ' ^ RE
                   < elite.a99
1535                      .rtok 43
     **** ****     > RTOK
0003 04A9   E8            byte (43 + 160) ^ RE
                   < elite.a99
1536 04AA B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1537                      .char 'E'
     **** ****     > CHAR
0004 04AB   66            byte 'E' ^ RE
                   < elite.a99
1538 04AC 00              byte >00
1539               
1540                      .char 'S'                                           ; Token 25:     "SHIP"
     **** ****     > CHAR
0004 04AD   70            byte 'S' ^ RE
                   < elite.a99
1541                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04AE 6B              byte 'H' ^ RE
                   < elite.a99
1542                      .char 'I'                                           ; Encoded as:   "SHIP"
     **** ****     > CHAR
0004 04AF   6A            byte 'I' ^ RE
                   < elite.a99
1543                      .char 'P'
     **** ****     > CHAR
0004 04B0 73              byte 'P' ^ RE
                   < elite.a99
1544 04B1   00            byte >00
1545               
1546                      .char 'P'                                           ; Token 26:     "PRODUCT"
     **** ****     > CHAR
0004 04B2 73              byte 'P' ^ RE
                   < elite.a99
1547                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04B3   71            byte 'R' ^ RE
                   < elite.a99
1548                      .char 'O'                                           ; Encoded as:   "PRODUCT"
     **** ****     > CHAR
0004 04B4 6C              byte 'O' ^ RE
                   < elite.a99
1549                      .char 'D'
     **** ****     > CHAR
0004 04B5   67            byte 'D' ^ RE
                   < elite.a99
1550                      .char 'U'
     **** ****     > CHAR
0004 04B6 76              byte 'U' ^ RE
                   < elite.a99
1551                      .char 'C'
     **** ****     > CHAR
0004 04B7   60            byte 'C' ^ RE
                   < elite.a99
1552                      .char 'T'
     **** ****     > CHAR
0004 04B8 77              byte 'T' ^ RE
                   < elite.a99
1553 04B9   00            byte >00
1554               
1555                      .char ' '                                           ; Token 27:     " LASER"
     **** ****     > CHAR
0004 04BA 03              byte ' ' ^ RE
                   < elite.a99
1556 04BB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1557                      .char 'S'                                           ; Encoded as:   " <149>S<144>"
     **** ****     > CHAR
0004 04BC 70              byte 'S' ^ RE
                   < elite.a99
1558 04BD   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1559 04BE 00              byte >00
1560               
1561                      .char 'H'                                           ; Token 28:     "HUMAN COLONIAL"
     **** ****     > CHAR
0004 04BF   6B            byte 'H' ^ RE
                   < elite.a99
1562                      .char 'U'                                           ;
     **** ****     > CHAR
0004 04C0 76              byte 'U' ^ RE
                   < elite.a99
1563                      .char 'M'                                           ; Encoded as:   "HUM<155> COL<159>I<128>"
     **** ****     > CHAR
0004 04C1   6E            byte 'M' ^ RE
                   < elite.a99
1564 04C2 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1565                      .char ' '
     **** ****     > CHAR
0004 04C3   03            byte ' ' ^ RE
                   < elite.a99
1566                      .char 'C'
     **** ****     > CHAR
0004 04C4 60              byte 'C' ^ RE
                   < elite.a99
1567                      .char 'O'
     **** ****     > CHAR
0004 04C5   6C            byte 'O' ^ RE
                   < elite.a99
1568                      .char 'L'
     **** ****     > CHAR
0004 04C6 6F              byte 'L' ^ RE
                   < elite.a99
1569 04C7   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1570                      .char 'I'
     **** ****     > CHAR
0004 04C8 6A              byte 'I' ^ RE
                   < elite.a99
1571 04C9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1572 04CA 00              byte >00
1573               
1574                      .char 'H'                                           ; Token 29:     "HYPERSPACE "
     **** ****     > CHAR
0004 04CB   6B            byte 'H' ^ RE
                   < elite.a99
1575                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 04CC 7A              byte 'Y' ^ RE
                   < elite.a99
1576                      .char 'P'                                           ; Encoded as:   "HYP<144>SPA<133> "
     **** ****     > CHAR
0004 04CD   73            byte 'P' ^ RE
                   < elite.a99
1577 04CE B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1578                      .char 'S'
     **** ****     > CHAR
0004 04CF   70            byte 'S' ^ RE
                   < elite.a99
1579                      .char 'P'
     **** ****     > CHAR
0004 04D0 73              byte 'P' ^ RE
                   < elite.a99
1580                      .char 'A'
     **** ****     > CHAR
0004 04D1   62            byte 'A' ^ RE
                   < elite.a99
1581 04D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1582                      .char ' '
     **** ****     > CHAR
0004 04D3   03            byte ' ' ^ RE
                   < elite.a99
1583 04D4 00              byte >00
1584               
1585                      .char 'S'                                           ; Token 30:     "SHORT RANGE CHART"
     **** ****     > CHAR
0004 04D5   70            byte 'S' ^ RE
                   < elite.a99
1586                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04D6 6B              byte 'H' ^ RE
                   < elite.a99
1587 04D7   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "SH<153>T [42][1]"
1588                      .char 'T'
     **** ****     > CHAR
0004 04D8 77              byte 'T' ^ RE
                   < elite.a99
1589                      .char ' '
     **** ****     > CHAR
0004 04D9   03            byte ' ' ^ RE
                   < elite.a99
1590                      .rtok 42
     **** ****     > RTOK
0003 04DA E9              byte (42 + 160) ^ RE
                   < elite.a99
1591                      .rtok 1
     **** ****     > RTOK
0003 04DB   82            byte (1 + 160) ^ RE
                   < elite.a99
1592 04DC 00              byte >00
1593               
1594 04DD   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 31:     "DISTANCE"
1595                      .rtok 43                                            ;
     **** ****     > RTOK
0003 04DE E8              byte (43 + 160) ^ RE
                   < elite.a99
1596 04DF   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "<141>[43]<155><133>"
1597 04E0 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1598 04E1   00            byte >00
1599               
1600                      .char 'P'                                           ; Token 32:     "POPULATION"
     **** ****     > CHAR
0004 04E2 73              byte 'P' ^ RE
                   < elite.a99
1601                      .char 'O'                                           ;
     **** ****     > CHAR
0004 04E3   6C            byte 'O' ^ RE
                   < elite.a99
1602                      .char 'P'                                           ; Encoded as:   "POPUL<145>I<159>"
     **** ****     > CHAR
0004 04E4 73              byte 'P' ^ RE
                   < elite.a99
1603                      .char 'U'
     **** ****     > CHAR
0004 04E5   76            byte 'U' ^ RE
                   < elite.a99
1604                      .char 'L'
     **** ****     > CHAR
0004 04E6 6F              byte 'L' ^ RE
                   < elite.a99
1605 04E7   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1606                      .char 'I'
     **** ****     > CHAR
0004 04E8 6A              byte 'I' ^ RE
                   < elite.a99
1607 04E9   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1608 04EA 00              byte >00
1609               
1610                      .char 'G'                                           ; Token 33:     "GROSS PRODUCTIVITY"
     **** ****     > CHAR
0004 04EB   64            byte 'G' ^ RE
                   < elite.a99
1611                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04EC 71              byte 'R' ^ RE
                   < elite.a99
1612                      .char 'O'                                           ; Encoded as:   "GROSS [26]IVITY"
     **** ****     > CHAR
0004 04ED   6C            byte 'O' ^ RE
                   < elite.a99
1613                      .char 'S'
     **** ****     > CHAR
0004 04EE 70              byte 'S' ^ RE
                   < elite.a99
1614                      .char 'S'
     **** ****     > CHAR
0004 04EF   70            byte 'S' ^ RE
                   < elite.a99
1615                      .char ' '
     **** ****     > CHAR
0004 04F0 03              byte ' ' ^ RE
                   < elite.a99
1616                      .rtok 26
     **** ****     > RTOK
0003 04F1   99            byte (26 + 160) ^ RE
                   < elite.a99
1617                      .char 'I'
     **** ****     > CHAR
0004 04F2 6A              byte 'I' ^ RE
                   < elite.a99
1618                      .char 'V'
     **** ****     > CHAR
0004 04F3   75            byte 'V' ^ RE
                   < elite.a99
1619                      .char 'I'
     **** ****     > CHAR
0004 04F4 6A              byte 'I' ^ RE
                   < elite.a99
1620                      .char 'T'
     **** ****     > CHAR
0004 04F5   77            byte 'T' ^ RE
                   < elite.a99
1621                      .char 'Y'
     **** ****     > CHAR
0004 04F6 7A              byte 'Y' ^ RE
                   < elite.a99
1622 04F7   00            byte >00
1623               
1624                      .char 'E'                                           ; Token 34:     "ECONOMY"
     **** ****     > CHAR
0004 04F8 66              byte 'E' ^ RE
                   < elite.a99
1625                      .char 'C'                                           ;
     **** ****     > CHAR
0004 04F9   60            byte 'C' ^ RE
                   < elite.a99
1626 04FA BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "EC<159>OMY"
1627                      .char 'O'
     **** ****     > CHAR
0004 04FB   6C            byte 'O' ^ RE
                   < elite.a99
1628                      .char 'M'
     **** ****     > CHAR
0004 04FC 6E              byte 'M' ^ RE
                   < elite.a99
1629                      .char 'Y'
     **** ****     > CHAR
0004 04FD   7A            byte 'Y' ^ RE
                   < elite.a99
1630 04FE 00              byte >00
1631               
1632                      .char ' '                                           ; Token 35:     " LIGHT YEARS"
     **** ****     > CHAR
0004 04FF   03            byte ' ' ^ RE
                   < elite.a99
1633                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0500 6F              byte 'L' ^ RE
                   < elite.a99
1634                      .char 'I'                                           ; Encoded as:   " LIGHT YE<138>S"
     **** ****     > CHAR
0004 0501   6A            byte 'I' ^ RE
                   < elite.a99
1635                      .char 'G'
     **** ****     > CHAR
0004 0502 64              byte 'G' ^ RE
                   < elite.a99
1636                      .char 'H'
     **** ****     > CHAR
0004 0503   6B            byte 'H' ^ RE
                   < elite.a99
1637                      .char 'T'
     **** ****     > CHAR
0004 0504 77              byte 'T' ^ RE
                   < elite.a99
1638                      .char ' '
     **** ****     > CHAR
0004 0505   03            byte ' ' ^ RE
                   < elite.a99
1639                      .char 'Y'
     **** ****     > CHAR
0004 0506 7A              byte 'Y' ^ RE
                   < elite.a99
1640                      .char 'E'
     **** ****     > CHAR
0004 0507   66            byte 'E' ^ RE
                   < elite.a99
1641 0508 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1642                      .char 'S'
     **** ****     > CHAR
0004 0509   70            byte 'S' ^ RE
                   < elite.a99
1643 050A 00              byte >00
1644               
1645 050B   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 36:     "TECH.LEVEL"
1646                      .char 'C'                                           ;
     **** ****     > CHAR
0004 050C 60              byte 'C' ^ RE
                   < elite.a99
1647                      .char 'H'                                           ; Encoded as:   "<156>CH.<129><150>L"
     **** ****     > CHAR
0004 050D   6B            byte 'H' ^ RE
                   < elite.a99
1648                      .char '.'
     **** ****     > CHAR
0004 050E 0D              byte '.' ^ RE
                   < elite.a99
1649 050F   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
1650 0510 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1651                      .char 'L'
     **** ****     > CHAR
0004 0511   6F            byte 'L' ^ RE
                   < elite.a99
1652 0512 00              byte >00
1653               
1654                      .char 'C'                                           ; Token 37:     "CASH"
     **** ****     > CHAR
0004 0513   60            byte 'C' ^ RE
                   < elite.a99
1655                      .char 'A'                                           ;
     **** ****     > CHAR
0004 0514 62              byte 'A' ^ RE
                   < elite.a99
1656                      .char 'S'                                           ; Encoded as:   "CASH"
     **** ****     > CHAR
0004 0515   70            byte 'S' ^ RE
                   < elite.a99
1657                      .char 'H'
     **** ****     > CHAR
0004 0516 6B              byte 'H' ^ RE
                   < elite.a99
1658 0517   00            byte >00
1659               
1660                      .char ' '                                           ; Token 38:     " BILLION"
     **** ****     > CHAR
0004 0518 03              byte ' ' ^ RE
                   < elite.a99
1661 0519   A5            byte 134 ^ RE                                       ; TWOK 'B', 'I'
1662                      .rtok 118                                           ; Encoded as:   " <134>[118]I<159>"
     **** ****     > RTOK
0008 051A 55              byte 118 ^ RE
                   < elite.a99
1663                      .char 'I'
     **** ****     > CHAR
0004 051B   6A            byte 'I' ^ RE
                   < elite.a99
1664 051C BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1665 051D   00            byte >00
1666               
1667                      .rtok 122                                           ; Token 39:     "GALACTIC CHART{galaxy number}"
     **** ****     > RTOK
0008 051E 59              byte 122 ^ RE
                   < elite.a99
1668                      .rtok 1                                             ;
     **** ****     > RTOK
0003 051F   82            byte (1 + 160) ^ RE
                   < elite.a99
1669                      .cont 1                                             ; Encoded as:   "[122][1]{1}"
     **** ****     > CONT
0001 0520 22              byte 1 ^ RE
                   < elite.a99
1670 0521   00            byte >00
1671               
1672                      .char 'T'                                           ; Token 40:     "TARGET LOST"
     **** ****     > CHAR
0004 0522 77              byte 'T' ^ RE
                   < elite.a99
1673 0523   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
1674 0524 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "T<138><131>T LO[43]"
1675                      .char 'T'
     **** ****     > CHAR
0004 0525   77            byte 'T' ^ RE
                   < elite.a99
1676                      .char ' '
     **** ****     > CHAR
0004 0526 03              byte ' ' ^ RE
                   < elite.a99
1677                      .char 'L'
     **** ****     > CHAR
0004 0527   6F            byte 'L' ^ RE
                   < elite.a99
1678                      .char 'O'
     **** ****     > CHAR
0004 0528 6C              byte 'O' ^ RE
                   < elite.a99
1679                      .rtok 43
     **** ****     > RTOK
0003 0529   E8            byte (43 + 160) ^ RE
                   < elite.a99
1680 052A 00              byte >00
1681               
1682                      .rtok 106                                           ; Token 41:     "MISSILE JAMMED"
     **** ****     > RTOK
0008 052B   49            byte 106 ^ RE
                   < elite.a99
1683                      .char ' '                                           ;
     **** ****     > CHAR
0004 052C 03              byte ' ' ^ RE
                   < elite.a99
1684                      .char 'J'                                           ; Encoded as:   "[106] JAMM<152>"
     **** ****     > CHAR
0004 052D   69            byte 'J' ^ RE
                   < elite.a99
1685                      .char 'A'
     **** ****     > CHAR
0004 052E 62              byte 'A' ^ RE
                   < elite.a99
1686                      .char 'M'
     **** ****     > CHAR
0004 052F   6E            byte 'M' ^ RE
                   < elite.a99
1687                      .char 'M'
     **** ****     > CHAR
0004 0530 6E              byte 'M' ^ RE
                   < elite.a99
1688 0531   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1689 0532 00              byte >00
1690               
1691                      .char 'R'                                           ; Token 42:     "RANGE"
     **** ****     > CHAR
0004 0533   71            byte 'R' ^ RE
                   < elite.a99
1692 0534 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1693 0535   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "R<155><131>"
1694 0536 00              byte >00
1695               
1696                      .char 'S'                                           ; Token 43:     "ST"
     **** ****     > CHAR
0004 0537   70            byte 'S' ^ RE
                   < elite.a99
1697                      .char 'T'                                           ;
     **** ****     > CHAR
0004 0538 77              byte 'T' ^ RE
                   < elite.a99
1698 0539   00            byte >00                                            ; Encoded as:   "ST"
1699               
1700                      .rtok 16                                            ; Token 44:     "QUANTITY OF "
     **** ****     > RTOK
0003 053A 93              byte (16 + 160) ^ RE
                   < elite.a99
1701                      .char ' '                                           ;
     **** ****     > CHAR
0004 053B   03            byte ' ' ^ RE
                   < elite.a99
1702                      .char 'O'                                           ; Encoded as:   "[16] OF "
     **** ****     > CHAR
0004 053C 6C              byte 'O' ^ RE
                   < elite.a99
1703                      .char 'F'
     **** ****     > CHAR
0004 053D   65            byte 'F' ^ RE
                   < elite.a99
1704                      .char ' '
     **** ****     > CHAR
0004 053E 03              byte ' ' ^ RE
                   < elite.a99
1705 053F   00            byte >00
1706               
1707                      .char 'S'                                           ; Token 45:     "SELL"
     **** ****     > CHAR
0004 0540 70              byte 'S' ^ RE
                   < elite.a99
1708                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0541   66            byte 'E' ^ RE
                   < elite.a99
1709                      .rtok 118                                           ; Encoded as:   "SE[118]"
     **** ****     > RTOK
0008 0542 55              byte 118 ^ RE
                   < elite.a99
1710 0543   00            byte >00
1711               
1712                      .char ' '                                           ; Token 46:     " CARGO{sentence case}"
     **** ****     > CHAR
0004 0544 03              byte ' ' ^ RE
                   < elite.a99
1713                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0545   60            byte 'C' ^ RE
                   < elite.a99
1714 0546 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' Encoded as:   " C<138>GO{6}"
1715                      .char 'G'
     **** ****     > CHAR
0004 0547   64            byte 'G' ^ RE
                   < elite.a99
1716                      .char 'O'
     **** ****     > CHAR
0004 0548 6C              byte 'O' ^ RE
                   < elite.a99
1717                      .cont 6
     **** ****     > CONT
0001 0549   25            byte 6 ^ RE
                   < elite.a99
1718 054A 00              byte >00
1719               
1720                      .char 'E'                                           ; Token 47:     "EQUIP"
     **** ****     > CHAR
0004 054B   66            byte 'E' ^ RE
                   < elite.a99
1721 054C B9              byte 154 ^ RE                                       ; TWOK 'Q', 'U'
1722                      .char 'I'                                           ; Encoded as:   "E<154>IP"
     **** ****     > CHAR
0004 054D   6A            byte 'I' ^ RE
                   < elite.a99
1723                      .char 'P'
     **** ****     > CHAR
0004 054E 73              byte 'P' ^ RE
                   < elite.a99
1724 054F   00            byte >00
1725               
1726                      .char 'F'                                           ; Token 48:     "FOOD"
     **** ****     > CHAR
0004 0550 65              byte 'F' ^ RE
                   < elite.a99
1727                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0551   6C            byte 'O' ^ RE
                   < elite.a99
1728                      .char 'O'                                           ; Encoded as:   "FOOD"
     **** ****     > CHAR
0004 0552 6C              byte 'O' ^ RE
                   < elite.a99
1729                      .char 'D'
     **** ****     > CHAR
0004 0553   67            byte 'D' ^ RE
                   < elite.a99
1730 0554 00              byte >00
1731               
1732 0555   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 49:     "TEXTILES"
1733                      .char 'X'                                           ;
     **** ****     > CHAR
0004 0556 7B              byte 'X' ^ RE
                   < elite.a99
1734 0557   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<156>X<151>L<137>"
1735                      .char 'L'
     **** ****     > CHAR
0004 0558 6F              byte 'L' ^ RE
                   < elite.a99
1736 0559   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1737 055A 00              byte >00
1738               
1739 055B   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 50:     "RADIOACTIVES"
1740 055C AE              byte 141 ^ RE                                       ; TWOK 'D', 'I'
1741                      .char 'O'                                           ; Encoded as:   "<148><141>OAC<151><150>S"
     **** ****     > CHAR
0004 055D   6C            byte 'O' ^ RE
                   < elite.a99
1742                      .char 'A'
     **** ****     > CHAR
0004 055E 62              byte 'A' ^ RE
                   < elite.a99
1743                      .char 'C'
     **** ****     > CHAR
0004 055F   60            byte 'C' ^ RE
                   < elite.a99
1744 0560 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1745 0561   B5            byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1746                      .char 'S'
     **** ****     > CHAR
0004 0562 70              byte 'S' ^ RE
                   < elite.a99
1747 0563   00            byte >00
1748               
1749                      .char 'S'                                           ; Token 51:     "SLAVES"
     **** ****     > CHAR
0004 0564 70              byte 'S' ^ RE
                   < elite.a99
1750 0565   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1751 0566 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "S<149><150>S"
1752                      .char 'S'
     **** ****     > CHAR
0004 0567   70            byte 'S' ^ RE
                   < elite.a99
1753 0568 00              byte >00
1754               
1755                      .char 'L'                                           ; Token 52:     "LIQUOR/WINES"
     **** ****     > CHAR
0004 0569   6F            byte 'L' ^ RE
                   < elite.a99
1756                      .char 'I'                                           ;
     **** ****     > CHAR
0004 056A 6A              byte 'I' ^ RE
                   < elite.a99
1757 056B   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Encoded as:   "LI<154><153>/W<140><137>"
1758 056C BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1759                      .char '/'
     **** ****     > CHAR
0004 056D   0C            byte '/' ^ RE
                   < elite.a99
1760                      .char 'W'
     **** ****     > CHAR
0004 056E 74              byte 'W' ^ RE
                   < elite.a99
1761 056F   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1762 0570 AA              byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1763 0571   00            byte >00
1764               
1765                      .char 'L'                                           ; Token 53:     "LUXURIES"
     **** ****     > CHAR
0004 0572 6F              byte 'L' ^ RE
                   < elite.a99
1766                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0573   76            byte 'U' ^ RE
                   < elite.a99
1767                      .char 'X'                                           ; Encoded as:   "LUXU<158><137>"
     **** ****     > CHAR
0004 0574 7B              byte 'X' ^ RE
                   < elite.a99
1768                      .char 'U'
     **** ****     > CHAR
0004 0575   76            byte 'U' ^ RE
                   < elite.a99
1769 0576 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1770 0577   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1771 0578 00              byte >00
1772               
1773                      .char 'N'                                           ; Token 54:     "NARCOTICS"
     **** ****     > CHAR
0004 0579   6D            byte 'N' ^ RE
                   < elite.a99
1774 057A A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1775                      .char 'C'                                           ; Encoded as:   "N<138>CO<151>CS"
     **** ****     > CHAR
0004 057B   60            byte 'C' ^ RE
                   < elite.a99
1776                      .char 'O'
     **** ****     > CHAR
0004 057C 6C              byte 'O' ^ RE
                   < elite.a99
1777 057D   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1778                      .char 'C'
     **** ****     > CHAR
0004 057E 60              byte 'C' ^ RE
                   < elite.a99
1779                      .char 'S'
     **** ****     > CHAR
0004 057F   70            byte 'S' ^ RE
                   < elite.a99
1780 0580 00              byte >00
1781               
1782                      .rtok 91                                            ; Token 55:     "COMPUTERS"
     **** ****     > RTOK
0003 0581   D8            byte (91 + 160) ^ RE
                   < elite.a99
1783                      .char 'P'                                           ;
     **** ****     > CHAR
0004 0582 73              byte 'P' ^ RE
                   < elite.a99
1784                      .char 'U'                                           ; Encoded as:   "[91]PUT<144>S"
     **** ****     > CHAR
0004 0583   76            byte 'U' ^ RE
                   < elite.a99
1785                      .char 'T'
     **** ****     > CHAR
0004 0584 77              byte 'T' ^ RE
                   < elite.a99
1786 0585   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1787                      .char 'S'
     **** ****     > CHAR
0004 0586 70              byte 'S' ^ RE
                   < elite.a99
1788 0587   00            byte >00
1789               
1790 0588 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 56:     "MACHINERY"
1791                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0589   60            byte 'C' ^ RE
                   < elite.a99
1792                      .char 'H'                                           ; Encoded as:   "<139>CH<140><144>Y"
     **** ****     > CHAR
0004 058A 6B              byte 'H' ^ RE
                   < elite.a99
1793 058B   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1794 058C B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1795                      .char 'Y'
     **** ****     > CHAR
0004 058D   7A            byte 'Y' ^ RE
                   < elite.a99
1796 058E 00              byte >00
1797               
1798                      .rtok 117                                           ; Token 57:     "ALLOYS"
     **** ****     > RTOK
0008 058F   56            byte 117 ^ RE
                   < elite.a99
1799                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0590 6C              byte 'O' ^ RE
                   < elite.a99
1800                      .char 'Y'                                           ; Encoded as:   "[117]OYS"
     **** ****     > CHAR
0004 0591   7A            byte 'Y' ^ RE
                   < elite.a99
1801                      .char 'S'
     **** ****     > CHAR
0004 0592 70              byte 'S' ^ RE
                   < elite.a99
1802 0593   00            byte >00
1803               
1804                      .char 'F'                                           ; Token 58:     "FIREARMS"
     **** ****     > CHAR
0004 0594 65              byte 'F' ^ RE
                   < elite.a99
1805                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0595   6A            byte 'I' ^ RE
                   < elite.a99
1806 0596 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' Encoded as:   "FI<142><138>MS"
1807 0597   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1808                      .char 'M'
     **** ****     > CHAR
0004 0598 6E              byte 'M' ^ RE
                   < elite.a99
1809                      .char 'S'
     **** ****     > CHAR
0004 0599   70            byte 'S' ^ RE
                   < elite.a99
1810 059A 00              byte >00
1811               
1812                      .char 'F'                                           ; Token 59:     "FURS"
     **** ****     > CHAR
0004 059B   65            byte 'F' ^ RE
                   < elite.a99
1813                      .char 'U'                                           ;
     **** ****     > CHAR
0004 059C 76              byte 'U' ^ RE
                   < elite.a99
1814                      .char 'R'                                           ; Encoded as:   "FURS"
     **** ****     > CHAR
0004 059D   71            byte 'R' ^ RE
                   < elite.a99
1815                      .char 'S'
     **** ****     > CHAR
0004 059E 70              byte 'S' ^ RE
                   < elite.a99
1816 059F   00            byte >00
1817               
1818                      .char 'M'                                           ; Token 60:     "MINERALS"
     **** ****     > CHAR
0004 05A0 6E              byte 'M' ^ RE
                   < elite.a99
1819 05A1   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1820 05A2 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "M<140><144><128>S"
1821 05A3   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1822                      .char 'S'
     **** ****     > CHAR
0004 05A4 70              byte 'S' ^ RE
                   < elite.a99
1823 05A5   00            byte >00
1824               
1825                      .char 'G'                                           ; Token 61:     "GOLD"
     **** ****     > CHAR
0004 05A6 64              byte 'G' ^ RE
                   < elite.a99
1826                      .char 'O'                                           ;
     **** ****     > CHAR
0004 05A7   6C            byte 'O' ^ RE
                   < elite.a99
1827                      .char 'L'                                           ; Encoded as:   "GOLD"
     **** ****     > CHAR
0004 05A8 6F              byte 'L' ^ RE
                   < elite.a99
1828                      .char 'D'
     **** ****     > CHAR
0004 05A9   67            byte 'D' ^ RE
                   < elite.a99
1829 05AA 00              byte >00
1830               
1831                      .char 'P'                                           ; Token 62:     "PLATINUM"
     **** ****     > CHAR
0004 05AB   73            byte 'P' ^ RE
                   < elite.a99
1832                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05AC 6F              byte 'L' ^ RE
                   < elite.a99
1833 05AD   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' Encoded as:   "PL<145><140>UM"
1834 05AE AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1835                      .char 'U'
     **** ****     > CHAR
0004 05AF   76            byte 'U' ^ RE
                   < elite.a99
1836                      .char 'M'
     **** ****     > CHAR
0004 05B0 6E              byte 'M' ^ RE
                   < elite.a99
1837 05B1   00            byte >00
1838               
1839 05B2 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Token 63:     "GEM-STONES"
1840                      .char 'M'                                           ;
     **** ****     > CHAR
0004 05B3   6E            byte 'M' ^ RE
                   < elite.a99
1841                      .char '-'                                           ; Encoded as:   "<131>M-[43]<159><137>"
     **** ****     > CHAR
0004 05B4 0E              byte '-' ^ RE
                   < elite.a99
1842                      .rtok 43
     **** ****     > RTOK
0003 05B5   E8            byte (43 + 160) ^ RE
                   < elite.a99
1843 05B6 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1844 05B7   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1845 05B8 00              byte >00
1846               
1847 05B9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' Token 64:     "ALIEN ITEMS"
1848                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05BA 6A              byte 'I' ^ RE
                   < elite.a99
1849 05BB   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "<128>I<146> [127]S"
1850                      .char ' '
     **** ****     > CHAR
0004 05BC 03              byte ' ' ^ RE
                   < elite.a99
1851                      .rtok 127
     **** ****     > RTOK
0008 05BD   5C            byte 127 ^ RE
                   < elite.a99
1852                      .char 'S'
     **** ****     > CHAR
0004 05BE 70              byte 'S' ^ RE
                   < elite.a99
1853 05BF   00            byte >00
1854               
1855                      .char '('                                           ; Token 65:     "(Y/N)?"
     **** ****     > CHAR
0004 05C0 0B              byte '(' ^ RE
                   < elite.a99
1856                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 05C1   7A            byte 'Y' ^ RE
                   < elite.a99
1857                      .char '/'                                           ; Encoded as:   "(Y/N)?"
     **** ****     > CHAR
0004 05C2 0C              byte '/' ^ RE
                   < elite.a99
1858                      .char 'N'
     **** ****     > CHAR
0004 05C3   6D            byte 'N' ^ RE
                   < elite.a99
1859                      .char ')'
     **** ****     > CHAR
0004 05C4 0A              byte ')' ^ RE
                   < elite.a99
1860                      .char '?'
     **** ****     > CHAR
0004 05C5   1C            byte '?' ^ RE
                   < elite.a99
1861 05C6 00              byte >00
1862               
1863                      .char ' '                                           ; Token 66:     " CR"
     **** ****     > CHAR
0004 05C7   03            byte ' ' ^ RE
                   < elite.a99
1864                      .char 'C'                                           ;
     **** ****     > CHAR
0004 05C8 60              byte 'C' ^ RE
                   < elite.a99
1865                      .char 'R'                                           ; Encoded as:   " CR"
     **** ****     > CHAR
0004 05C9   71            byte 'R' ^ RE
                   < elite.a99
1866 05CA 00              byte >00
1867               
1868                      .char 'L'                                           ; Token 67:     "LARGE"
     **** ****     > CHAR
0004 05CB   6F            byte 'L' ^ RE
                   < elite.a99
1869 05CC A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1870 05CD   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "L<138><131>"
1871 05CE 00              byte >00
1872               
1873                      .char 'F'                                           ; Token 68:     "FIERCE"
     **** ****     > CHAR
0004 05CF   65            byte 'F' ^ RE
                   < elite.a99
1874                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05D0 6A              byte 'I' ^ RE
                   < elite.a99
1875 05D1   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "FI<144><133>"
1876 05D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1877 05D3   00            byte >00
1878               
1879                      .char 'S'                                           ; Token 69:     "SMALL"
     **** ****     > CHAR
0004 05D4 70              byte 'S' ^ RE
                   < elite.a99
1880 05D5   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A'
1881                      .rtok 118                                           ; Encoded as:   "S<139>[118]"
     **** ****     > RTOK
0008 05D6 55              byte 118 ^ RE
                   < elite.a99
1882 05D7   00            byte >00
1883               
1884                      .char 'G'                                           ; Token 70:     "GREEN"
     **** ****     > CHAR
0004 05D8 64              byte 'G' ^ RE
                   < elite.a99
1885 05D9   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E'
1886 05DA B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "G<142><146>"
1887 05DB   00            byte >00
1888               
1889                      .char 'R'                                           ; Token 71:     "RED"
     **** ****     > CHAR
0004 05DC 71              byte 'R' ^ RE
                   < elite.a99
1890 05DD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D'
1891 05DE 00              byte >00                                            ; Encoded as:   "R<152>"
1892               
1893                      .char 'Y'                                           ; Token 72:     "YELLOW"
     **** ****     > CHAR
0004 05DF   7A            byte 'Y' ^ RE
                   < elite.a99
1894                      .char 'E'                                           ;
     **** ****     > CHAR
0004 05E0 66              byte 'E' ^ RE
                   < elite.a99
1895                      .rtok 118                                           ; Encoded as:   "YE[118]OW"
     **** ****     > RTOK
0008 05E1   55            byte 118 ^ RE
                   < elite.a99
1896                      .char 'O'
     **** ****     > CHAR
0004 05E2 6C              byte 'O' ^ RE
                   < elite.a99
1897                      .char 'W'
     **** ****     > CHAR
0004 05E3   74            byte 'W' ^ RE
                   < elite.a99
1898 05E4 00              byte >00
1899               
1900                      .char 'B'                                           ; Token 73:     "BLUE"
     **** ****     > CHAR
0004 05E5   61            byte 'B' ^ RE
                   < elite.a99
1901                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05E6 6F              byte 'L' ^ RE
                   < elite.a99
1902                      .char 'U'                                           ; Encoded as:   "BLUE"
     **** ****     > CHAR
0004 05E7   76            byte 'U' ^ RE
                   < elite.a99
1903                      .char 'E'
     **** ****     > CHAR
0004 05E8 66              byte 'E' ^ RE
                   < elite.a99
1904 05E9   00            byte >00
1905               
1906                      .char 'B'                                           ; Token 74:     "BLACK"
     **** ****     > CHAR
0004 05EA 61              byte 'B' ^ RE
                   < elite.a99
1907 05EB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1908                      .char 'C'                                           ; Encoded as:   "B<149>CK"
     **** ****     > CHAR
0004 05EC 60              byte 'C' ^ RE
                   < elite.a99
1909                      .char 'K'
     **** ****     > CHAR
0004 05ED   68            byte 'K' ^ RE
                   < elite.a99
1910 05EE 00              byte >00
1911               
1912                      .rtok 136                                           ; Token 75:     "HARMLESS"
     **** ****     > RTOK
0006 05EF   35            byte (136 - 114) ^ RE
                   < elite.a99
1913 05F0 00              byte >00                                            ;
1914                                                                          ; Encoded as:   "[136]"
1915               
1916                      .char 'S'                                           ; Token 76:     "SLIMY"
     **** ****     > CHAR
0004 05F1   70            byte 'S' ^ RE
                   < elite.a99
1917                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05F2 6F              byte 'L' ^ RE
                   < elite.a99
1918                      .char 'I'                                           ; Encoded as:   "SLIMY"
     **** ****     > CHAR
0004 05F3   6A            byte 'I' ^ RE
                   < elite.a99
1919                      .char 'M'
     **** ****     > CHAR
0004 05F4 6E              byte 'M' ^ RE
                   < elite.a99
1920                      .char 'Y'
     **** ****     > CHAR
0004 05F5   7A            byte 'Y' ^ RE
                   < elite.a99
1921 05F6 00              byte >00
1922               
1923                      .char 'B'                                           ; Token 77:     "BUG-EYED"
     **** ****     > CHAR
0004 05F7   61            byte 'B' ^ RE
                   < elite.a99
1924                      .char 'U'                                           ;
     **** ****     > CHAR
0004 05F8 76              byte 'U' ^ RE
                   < elite.a99
1925                      .char 'G'                                           ; Encoded as:   "BUG-EY<152>"
     **** ****     > CHAR
0004 05F9   64            byte 'G' ^ RE
                   < elite.a99
1926                      .char '-'
     **** ****     > CHAR
0004 05FA 0E              byte '-' ^ RE
                   < elite.a99
1927                      .char 'E'
     **** ****     > CHAR
0004 05FB   66            byte 'E' ^ RE
                   < elite.a99
1928                      .char 'Y'
     **** ****     > CHAR
0004 05FC 7A              byte 'Y' ^ RE
                   < elite.a99
1929 05FD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1930 05FE 00              byte >00
1931               
1932                      .char 'H'                                           ; Token 78:     "HORNED"
     **** ****     > CHAR
0004 05FF   6B            byte 'H' ^ RE
                   < elite.a99
1933 0600 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R'
1934                      .char 'N'                                           ; Encoded as:   "H<153>N<152>"
     **** ****     > CHAR
0004 0601   6D            byte 'N' ^ RE
                   < elite.a99
1935 0602 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1936 0603   00            byte >00
1937               
1938                      .char 'B'                                           ; Token 79:     "BONY"
     **** ****     > CHAR
0004 0604 61              byte 'B' ^ RE
                   < elite.a99
1939 0605   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1940                      .char 'Y'                                           ; Encoded as:   "B<159>Y"
     **** ****     > CHAR
0004 0606 7A              byte 'Y' ^ RE
                   < elite.a99
1941 0607   00            byte >00
1942               
1943                      .char 'F'                                           ; Token 80:     "FAT"
     **** ****     > CHAR
0004 0608 65              byte 'F' ^ RE
                   < elite.a99
1944 0609   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T'
1945 060A 00              byte >00                                            ; Encoded as:   "F<145>"
1946               
1947                      .char 'F'                                           ; Token 81:     "FURRY"
     **** ****     > CHAR
0004 060B   65            byte 'F' ^ RE
                   < elite.a99
1948                      .char 'U'                                           ;
     **** ****     > CHAR
0004 060C 76              byte 'U' ^ RE
                   < elite.a99
1949                      .char 'R'                                           ; Encoded as:   "FURRY"
     **** ****     > CHAR
0004 060D   71            byte 'R' ^ RE
                   < elite.a99
1950                      .char 'R'
     **** ****     > CHAR
0004 060E 71              byte 'R' ^ RE
                   < elite.a99
1951                      .char 'Y'
     **** ****     > CHAR
0004 060F   7A            byte 'Y' ^ RE
                   < elite.a99
1952 0610 00              byte >00
1953               
1954                      .char 'R'                                           ; Token 82:     "RODENT"
     **** ****     > CHAR
0004 0611   71            byte 'R' ^ RE
                   < elite.a99
1955                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0612 6C              byte 'O' ^ RE
                   < elite.a99
1956                      .char 'D'                                           ; Encoded as:   "ROD<146>T"
     **** ****     > CHAR
0004 0613   67            byte 'D' ^ RE
                   < elite.a99
1957 0614 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1958                      .char 'T'
     **** ****     > CHAR
0004 0615   77            byte 'T' ^ RE
                   < elite.a99
1959 0616 00              byte >00
1960               
1961                      .char 'F'                                           ; Token 83:     "FROG"
     **** ****     > CHAR
0004 0617   65            byte 'F' ^ RE
                   < elite.a99
1962                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0618 71              byte 'R' ^ RE
                   < elite.a99
1963                      .char 'O'                                           ; Encoded as:   "FROG"
     **** ****     > CHAR
0004 0619   6C            byte 'O' ^ RE
                   < elite.a99
1964                      .char 'G'
     **** ****     > CHAR
0004 061A 64              byte 'G' ^ RE
                   < elite.a99
1965 061B   00            byte >00
1966               
1967                      .char 'L'                                           ; Token 84:     "LIZARD"
     **** ****     > CHAR
0004 061C 6F              byte 'L' ^ RE
                   < elite.a99
1968                      .char 'I'                                           ;
     **** ****     > CHAR
0004 061D   6A            byte 'I' ^ RE
                   < elite.a99
1969 061E A7              byte 132 ^ RE                                       ; TWOK 'Z', 'A' Encoded as:   "LI<132>RD"
1970                      .char 'R'
     **** ****     > CHAR
0004 061F   71            byte 'R' ^ RE
                   < elite.a99
1971                      .char 'D'
     **** ****     > CHAR
0004 0620 67              byte 'D' ^ RE
                   < elite.a99
1972 0621   00            byte >00
1973               
1974                      .char 'L'                                           ; Token 85:     "LOBSTER"
     **** ****     > CHAR
0004 0622 6F              byte 'L' ^ RE
                   < elite.a99
1975                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0623   6C            byte 'O' ^ RE
                   < elite.a99
1976                      .char 'B'                                           ; Encoded as:   "LOB[43]<144>"
     **** ****     > CHAR
0004 0624 61              byte 'B' ^ RE
                   < elite.a99
1977                      .rtok 43
     **** ****     > RTOK
0003 0625   E8            byte (43 + 160) ^ RE
                   < elite.a99
1978 0626 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1979 0627   00            byte >00
1980               
1981 0628 A5              byte 134 ^ RE                                       ; TWOK 'B', 'I' Token 86:     "BIRD"
1982                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0629   71            byte 'R' ^ RE
                   < elite.a99
1983                      .char 'D'                                           ; Encoded as:   "<134>RD"
     **** ****     > CHAR
0004 062A 67              byte 'D' ^ RE
                   < elite.a99
1984 062B   00            byte >00
1985               
1986                      .char 'H'                                           ; Token 87:     "HUMANOID"
     **** ****     > CHAR
0004 062C 6B              byte 'H' ^ RE
                   < elite.a99
1987                      .char 'U'                                           ;
     **** ****     > CHAR
0004 062D   76            byte 'U' ^ RE
                   < elite.a99
1988                      .char 'M'                                           ; Encoded as:   "HUM<155>OID"
     **** ****     > CHAR
0004 062E 6E              byte 'M' ^ RE
                   < elite.a99
1989 062F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1990                      .char 'O'
     **** ****     > CHAR
0004 0630 6C              byte 'O' ^ RE
                   < elite.a99
1991                      .char 'I'
     **** ****     > CHAR
0004 0631   6A            byte 'I' ^ RE
                   < elite.a99
1992                      .char 'D'
     **** ****     > CHAR
0004 0632 67              byte 'D' ^ RE
                   < elite.a99
1993 0633   00            byte >00
1994               
1995                      .char 'F'                                           ; Token 88:     "FELINE"
     **** ****     > CHAR
0004 0634 65              byte 'F' ^ RE
                   < elite.a99
1996                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0635   66            byte 'E' ^ RE
                   < elite.a99
1997                      .char 'L'                                           ; Encoded as:   "FEL<140>E"
     **** ****     > CHAR
0004 0636 6F              byte 'L' ^ RE
                   < elite.a99
1998 0637   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1999                      .char 'E'
     **** ****     > CHAR
0004 0638 66              byte 'E' ^ RE
                   < elite.a99
2000 0639   00            byte >00
2001               
2002 063A AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 89:     "INSECT"
2003                      .char 'S'                                           ;
     **** ****     > CHAR
0004 063B   70            byte 'S' ^ RE
                   < elite.a99
2004                      .char 'E'                                           ; Encoded as:   "<140>SECT"
     **** ****     > CHAR
0004 063C 66              byte 'E' ^ RE
                   < elite.a99
2005                      .char 'C'
     **** ****     > CHAR
0004 063D   60            byte 'C' ^ RE
                   < elite.a99
2006                      .char 'T'
     **** ****     > CHAR
0004 063E 77              byte 'T' ^ RE
                   < elite.a99
2007 063F   00            byte >00
2008               
2009                      .rtok 11                                            ; Token 90:     "AVERAGE RADIUS"
     **** ****     > RTOK
0003 0640 88              byte (11 + 160) ^ RE
                   < elite.a99
2010 0641   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A'
2011 0642 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Encoded as:   "[11]<148><141><136>"
2012 0643   AB            byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2013 0644 00              byte >00
2014               
2015                      .char 'C'                                           ; Token 91:     "COM"
     **** ****     > CHAR
0004 0645   60            byte 'C' ^ RE
                   < elite.a99
2016                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0646 6C              byte 'O' ^ RE
                   < elite.a99
2017                      .char 'M'                                           ; Encoded as:   "COM"
     **** ****     > CHAR
0004 0647   6E            byte 'M' ^ RE
                   < elite.a99
2018 0648 00              byte >00
2019               
2020                      .rtok 91                                            ; Token 92:     "COMMANDER"
     **** ****     > RTOK
0003 0649   D8            byte (91 + 160) ^ RE
                   < elite.a99
2021                      .char 'M'                                           ;
     **** ****     > CHAR
0004 064A 6E              byte 'M' ^ RE
                   < elite.a99
2022 064B   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "[91]M<155>D<144>"
2023                      .char 'D'
     **** ****     > CHAR
0004 064C 67              byte 'D' ^ RE
                   < elite.a99
2024 064D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2025 064E 00              byte >00
2026               
2027                      .char ' '                                           ; Token 93:     " DESTROYED"
     **** ****     > CHAR
0004 064F   03            byte ' ' ^ RE
                   < elite.a99
2028                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0650 67              byte 'D' ^ RE
                   < elite.a99
2029 0651   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Encoded as:   " D<137>TROY<152>"
2030                      .char 'T'
     **** ****     > CHAR
0004 0652 77              byte 'T' ^ RE
                   < elite.a99
2031                      .char 'R'
     **** ****     > CHAR
0004 0653   71            byte 'R' ^ RE
                   < elite.a99
2032                      .char 'O'
     **** ****     > CHAR
0004 0654 6C              byte 'O' ^ RE
                   < elite.a99
2033                      .char 'Y'
     **** ****     > CHAR
0004 0655   7A            byte 'Y' ^ RE
                   < elite.a99
2034 0656 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
2035 0657   00            byte >00
2036               
2037                      .char 'B'                                           ; Token 94:     "BY D.BRABEN & I.BELL"
     **** ****     > CHAR
0004 0658 61              byte 'B' ^ RE
                   < elite.a99
2038                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0659   7A            byte 'Y' ^ RE
                   < elite.a99
2039                      .char ' '                                           ; Encoded as:   "BY D.B<148><147>N & I.<147>[118]"
     **** ****     > CHAR
0004 065A 03              byte ' ' ^ RE
                   < elite.a99
2040                      .char 'D'
     **** ****     > CHAR
0004 065B   67            byte 'D' ^ RE
                   < elite.a99
2041                      .char '.'
     **** ****     > CHAR
0004 065C 0D              byte '.' ^ RE
                   < elite.a99
2042                      .char 'B'
     **** ****     > CHAR
0004 065D   61            byte 'B' ^ RE
                   < elite.a99
2043 065E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2044 065F   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2045                      .char 'N'
     **** ****     > CHAR
0004 0660 6D              byte 'N' ^ RE
                   < elite.a99
2046                      .char ' '
     **** ****     > CHAR
0004 0661   03            byte ' ' ^ RE
                   < elite.a99
2047                      .char '&'
     **** ****     > CHAR
0004 0662 05              byte '&' ^ RE
                   < elite.a99
2048                      .char ' '
     **** ****     > CHAR
0004 0663   03            byte ' ' ^ RE
                   < elite.a99
2049                      .char 'I'
     **** ****     > CHAR
0004 0664 6A              byte 'I' ^ RE
                   < elite.a99
2050                      .char '.'
     **** ****     > CHAR
0004 0665   0D            byte '.' ^ RE
                   < elite.a99
2051 0666 B0              byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2052                      .rtok 118
     **** ****     > RTOK
0008 0667   55            byte 118 ^ RE
                   < elite.a99
2053 0668 00              byte >00
2054               
2055                      .rtok 14                                            ; Token 95:     "UNIT  QUANTITY{crlf}
     **** ****     > RTOK
0003 0669   8D            byte (14 + 160) ^ RE
                   < elite.a99
2056                      .char ' '                                           ; PRODUCT   UNIT PRICE FOR SALE{crlf}
     **** ****     > CHAR
0004 066A 03              byte ' ' ^ RE
                   < elite.a99
2057                      .char ' '                                           ; {lf}"
     **** ****     > CHAR
0004 066B   03            byte ' ' ^ RE
                   < elite.a99
2058                      .rtok 16                                            ;
     **** ****     > RTOK
0003 066C 93              byte (16 + 160) ^ RE
                   < elite.a99
2059                      .cont 13                                            ; Encoded as:   "[14]  [16]{13} [26]   [14] [6] F<153>
     **** ****     > CONT
0001 066D   2E            byte 13 ^ RE
                   < elite.a99
2060                      .char ' '                                           ; SA<129>{13}{10}"
     **** ****     > CHAR
0004 066E 03              byte ' ' ^ RE
                   < elite.a99
2061                      .rtok 26
     **** ****     > RTOK
0003 066F   99            byte (26 + 160) ^ RE
                   < elite.a99
2062                      .char ' '
     **** ****     > CHAR
0004 0670 03              byte ' ' ^ RE
                   < elite.a99
2063                      .char ' '
     **** ****     > CHAR
0004 0671   03            byte ' ' ^ RE
                   < elite.a99
2064                      .char ' '
     **** ****     > CHAR
0004 0672 03              byte ' ' ^ RE
                   < elite.a99
2065                      .rtok 14
     **** ****     > RTOK
0003 0673   8D            byte (14 + 160) ^ RE
                   < elite.a99
2066                      .char ' '
     **** ****     > CHAR
0004 0674 03              byte ' ' ^ RE
                   < elite.a99
2067                      .rtok 6
     **** ****     > RTOK
0003 0675   85            byte (6 + 160) ^ RE
                   < elite.a99
2068                      .char ' '
     **** ****     > CHAR
0004 0676 03              byte ' ' ^ RE
                   < elite.a99
2069                      .char 'F'
     **** ****     > CHAR
0004 0677   65            byte 'F' ^ RE
                   < elite.a99
2070 0678 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2071                      .char ' '
     **** ****     > CHAR
0004 0679   03            byte ' ' ^ RE
                   < elite.a99
2072                      .char 'S'
     **** ****     > CHAR
0004 067A 70              byte 'S' ^ RE
                   < elite.a99
2073                      .char 'A'
     **** ****     > CHAR
0004 067B   62            byte 'A' ^ RE
                   < elite.a99
2074 067C A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2075                      .cont 13
     **** ****     > CONT
0001 067D   2E            byte 13 ^ RE
                   < elite.a99
2076                      .cont 10
     **** ****     > CONT
0001 067E 29              byte 10 ^ RE
                   < elite.a99
2077 067F   00            byte >00
2078               
2079                      .char 'F'                                           ; Token 96:     "FRONT"
     **** ****     > CHAR
0004 0680 65              byte 'F' ^ RE
                   < elite.a99
2080                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0681   71            byte 'R' ^ RE
                   < elite.a99
2081 0682 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "FR<159>T"
2082                      .char 'T'
     **** ****     > CHAR
0004 0683   77            byte 'T' ^ RE
                   < elite.a99
2083 0684 00              byte >00
2084               
2085 0685   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E' Token 97:     "REAR"
2086 0686 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
2087 0687   00            byte >00                                            ; Encoded as:   "<142><138>"
2088               
2089 0688 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' Token 98:     "LEFT"
2090                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0689   65            byte 'F' ^ RE
                   < elite.a99
2091                      .char 'T'                                           ; Encoded as:   "<129>FT"
     **** ****     > CHAR
0004 068A 77              byte 'T' ^ RE
                   < elite.a99
2092 068B   00            byte >00
2093               
2094 068C BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 99:     "RIGHT"
2095                      .char 'G'                                           ;
     **** ****     > CHAR
0004 068D   64            byte 'G' ^ RE
                   < elite.a99
2096                      .char 'H'                                           ; Encoded as:   "<158>GHT"
     **** ****     > CHAR
0004 068E 6B              byte 'H' ^ RE
                   < elite.a99
2097                      .char 'T'
     **** ****     > CHAR
0004 068F   77            byte 'T' ^ RE
                   < elite.a99
2098 0690 00              byte >00
2099               
2100                      .rtok 121                                           ; Token 100:    "ENERGY LOW{beep}"
     **** ****     > RTOK
0008 0691   5A            byte 121 ^ RE
                   < elite.a99
2101                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0692 6F              byte 'L' ^ RE
                   < elite.a99
2102                      .char 'O'                                           ; Encoded as:   "[121]LOW{7}"
     **** ****     > CHAR
0004 0693   6C            byte 'O' ^ RE
                   < elite.a99
2103                      .char 'W'
     **** ****     > CHAR
0004 0694 74              byte 'W' ^ RE
                   < elite.a99
2104                      .cont 7
     **** ****     > CONT
0001 0695   24            byte 7 ^ RE
                   < elite.a99
2105 0696 00              byte >00
2106               
2107                      .rtok 99                                            ; Token 101:    "RIGHT ON COMMANDER!"
     **** ****     > RTOK
0008 0697   40            byte 99 ^ RE
                   < elite.a99
2108                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0698 32              byte (131 - 114) ^ RE
                   < elite.a99
2109                      .rtok 92                                            ; Encoded as:   "[99][131][92]!"
     **** ****     > RTOK
0003 0699   DF            byte (92 + 160) ^ RE
                   < elite.a99
2110                      .char '!'
     **** ****     > CHAR
0004 069A 02              byte '!' ^ RE
                   < elite.a99
2111 069B   00            byte >00
2112               
2113                      .char 'E'                                           ; Token 102:    "EXTRA "
     **** ****     > CHAR
0004 069C 66              byte 'E' ^ RE
                   < elite.a99
2114                      .char 'X'                                           ;
     **** ****     > CHAR
0004 069D   7B            byte 'X' ^ RE
                   < elite.a99
2115                      .char 'T'                                           ; Encoded as:   "EXT<148> "
     **** ****     > CHAR
0004 069E 77              byte 'T' ^ RE
                   < elite.a99
2116 069F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2117                      .char ' '
     **** ****     > CHAR
0004 06A0 03              byte ' ' ^ RE
                   < elite.a99
2118 06A1   00            byte >00
2119               
2120                      .char 'P'                                           ; Token 103:    "PULSE LASER"
     **** ****     > CHAR
0004 06A2 73              byte 'P' ^ RE
                   < elite.a99
2121                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06A3   76            byte 'U' ^ RE
                   < elite.a99
2122                      .char 'L'                                           ; Encoded as:   "PULSE[27]"
     **** ****     > CHAR
0004 06A4 6F              byte 'L' ^ RE
                   < elite.a99
2123                      .char 'S'
     **** ****     > CHAR
0004 06A5   70            byte 'S' ^ RE
                   < elite.a99
2124                      .char 'E'
     **** ****     > CHAR
0004 06A6 66              byte 'E' ^ RE
                   < elite.a99
2125                      .rtok 27
     **** ****     > RTOK
0003 06A7   98            byte (27 + 160) ^ RE
                   < elite.a99
2126 06A8 00              byte >00
2127               
2128 06A9   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' Token 104:    "BEAM LASER"
2129                      .char 'A'                                           ;
     **** ****     > CHAR
0004 06AA 62              byte 'A' ^ RE
                   < elite.a99
2130                      .char 'M'                                           ; Encoded as:   "<147>AM[27]"
     **** ****     > CHAR
0004 06AB   6E            byte 'M' ^ RE
                   < elite.a99
2131                      .rtok 27
     **** ****     > RTOK
0003 06AC 98              byte (27 + 160) ^ RE
                   < elite.a99
2132 06AD   00            byte >00
2133               
2134                      .char 'F'                                           ; Token 105:    "FUEL"
     **** ****     > CHAR
0004 06AE 65              byte 'F' ^ RE
                   < elite.a99
2135                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06AF   76            byte 'U' ^ RE
                   < elite.a99
2136                      .char 'E'                                           ; Encoded as:   "FUEL"
     **** ****     > CHAR
0004 06B0 66              byte 'E' ^ RE
                   < elite.a99
2137                      .char 'L'
     **** ****     > CHAR
0004 06B1   6F            byte 'L' ^ RE
                   < elite.a99
2138 06B2 00              byte >00
2139               
2140                      .char 'M'                                           ; Token 106:    "MISSILE"
     **** ****     > CHAR
0004 06B3   6E            byte 'M' ^ RE
                   < elite.a99
2141 06B4 BE              byte 157 ^ RE                                       ; TWOK 'I', 'S'
2142                      .char 'S'                                           ; Encoded as:   "M<157>SI<129>"
     **** ****     > CHAR
0004 06B5   70            byte 'S' ^ RE
                   < elite.a99
2143                      .char 'I'
     **** ****     > CHAR
0004 06B6 6A              byte 'I' ^ RE
                   < elite.a99
2144 06B7   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2145 06B8 00              byte >00
2146               
2147                      .rtok 67                                            ; Token 107:    "LARGE CARGO{sentence case} BAY"
     **** ****     > RTOK
0003 06B9   C0            byte (67 + 160) ^ RE
                   < elite.a99
2148                      .rtok 46                                            ;
     **** ****     > RTOK
0003 06BA ED              byte (46 + 160) ^ RE
                   < elite.a99
2149                      .char ' '                                           ; Encoded as:   "[67][46] BAY"
     **** ****     > CHAR
0004 06BB   03            byte ' ' ^ RE
                   < elite.a99
2150                      .char 'B'
     **** ****     > CHAR
0004 06BC 61              byte 'B' ^ RE
                   < elite.a99
2151                      .char 'A'
     **** ****     > CHAR
0004 06BD   62            byte 'A' ^ RE
                   < elite.a99
2152                      .char 'Y'
     **** ****     > CHAR
0004 06BE 7A              byte 'Y' ^ RE
                   < elite.a99
2153 06BF   00            byte >00
2154               
2155                      .char 'E'                                           ; Token 108:    "E.C.M.SYSTEM"
     **** ****     > CHAR
0004 06C0 66              byte 'E' ^ RE
                   < elite.a99
2156                      .char '.'                                           ;
     **** ****     > CHAR
0004 06C1   0D            byte '.' ^ RE
                   < elite.a99
2157                      .char 'C'                                           ; Encoded as:   "E.C.M.[5]"
     **** ****     > CHAR
0004 06C2 60              byte 'C' ^ RE
                   < elite.a99
2158                      .char '.'
     **** ****     > CHAR
0004 06C3   0D            byte '.' ^ RE
                   < elite.a99
2159                      .char 'M'
     **** ****     > CHAR
0004 06C4 6E              byte 'M' ^ RE
                   < elite.a99
2160                      .char '.'
     **** ****     > CHAR
0004 06C5   0D            byte '.' ^ RE
                   < elite.a99
2161                      .rtok 5
     **** ****     > RTOK
0003 06C6 86              byte (5 + 160) ^ RE
                   < elite.a99
2162 06C7   00            byte >00
2163               
2164                      .rtok 102                                           ; Token 109:    "EXTRA PULSE LASERS"
     **** ****     > RTOK
0008 06C8 45              byte 102 ^ RE
                   < elite.a99
2165                      .rtok 103                                           ;
     **** ****     > RTOK
0008 06C9   44            byte 103 ^ RE
                   < elite.a99
2166                      .char 'S'                                           ; Encoded as:   "[102][103]S"
     **** ****     > CHAR
0004 06CA 70              byte 'S' ^ RE
                   < elite.a99
2167 06CB   00            byte >00
2168               
2169                      .rtok 102                                           ; Token 110:    "EXTRA BEAM LASERS"
     **** ****     > RTOK
0008 06CC 45              byte 102 ^ RE
                   < elite.a99
2170                      .rtok 104                                           ;
     **** ****     > RTOK
0008 06CD   4B            byte 104 ^ RE
                   < elite.a99
2171                      .char 'S'                                           ; Encoded as:   "[102][104]S"
     **** ****     > CHAR
0004 06CE 70              byte 'S' ^ RE
                   < elite.a99
2172 06CF   00            byte >00
2173               
2174                      .rtok 105                                           ; Token 111:    "FUEL SCOOPS"
     **** ****     > RTOK
0008 06D0 4A              byte 105 ^ RE
                   < elite.a99
2175                      .char ' '                                           ;
     **** ****     > CHAR
0004 06D1   03            byte ' ' ^ RE
                   < elite.a99
2176                      .char 'S'                                           ; Encoded as:   "[105] SCOOPS"
     **** ****     > CHAR
0004 06D2 70              byte 'S' ^ RE
                   < elite.a99
2177                      .char 'C'
     **** ****     > CHAR
0004 06D3   60            byte 'C' ^ RE
                   < elite.a99
2178                      .char 'O'
     **** ****     > CHAR
0004 06D4 6C              byte 'O' ^ RE
                   < elite.a99
2179                      .char 'O'
     **** ****     > CHAR
0004 06D5   6C            byte 'O' ^ RE
                   < elite.a99
2180                      .char 'P'
     **** ****     > CHAR
0004 06D6 73              byte 'P' ^ RE
                   < elite.a99
2181                      .char 'S'
     **** ****     > CHAR
0004 06D7   70            byte 'S' ^ RE
                   < elite.a99
2182 06D8 00              byte >00
2183               
2184 06D9   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Token 112:    "ESCAPE POD"
2185                      .char 'C'                                           ;
     **** ****     > CHAR
0004 06DA 60              byte 'C' ^ RE
                   < elite.a99
2186                      .char 'A'                                           ; Encoded as:   "<137>CAPE POD"
     **** ****     > CHAR
0004 06DB   62            byte 'A' ^ RE
                   < elite.a99
2187                      .char 'P'
     **** ****     > CHAR
0004 06DC 73              byte 'P' ^ RE
                   < elite.a99
2188                      .char 'E'
     **** ****     > CHAR
0004 06DD   66            byte 'E' ^ RE
                   < elite.a99
2189                      .char ' '
     **** ****     > CHAR
0004 06DE 03              byte ' ' ^ RE
                   < elite.a99
2190                      .char 'P'
     **** ****     > CHAR
0004 06DF   73            byte 'P' ^ RE
                   < elite.a99
2191                      .char 'O'
     **** ****     > CHAR
0004 06E0 6C              byte 'O' ^ RE
                   < elite.a99
2192                      .char 'D'
     **** ****     > CHAR
0004 06E1   67            byte 'D' ^ RE
                   < elite.a99
2193 06E2 00              byte >00
2194               
2195                      .rtok 121                                           ; Token 113:    "ENERGY BOMB"
     **** ****     > RTOK
0008 06E3   5A            byte 121 ^ RE
                   < elite.a99
2196                      .char 'B'                                           ;
     **** ****     > CHAR
0004 06E4 61              byte 'B' ^ RE
                   < elite.a99
2197                      .char 'O'                                           ; Encoded as:   "[121]BOMB"
     **** ****     > CHAR
0004 06E5   6C            byte 'O' ^ RE
                   < elite.a99
2198                      .char 'M'
     **** ****     > CHAR
0004 06E6 6E              byte 'M' ^ RE
                   < elite.a99
2199                      .char 'B'
     **** ****     > CHAR
0004 06E7   61            byte 'B' ^ RE
                   < elite.a99
2200 06E8 00              byte >00
2201               
2202                      .rtok 121                                           ; Token 114:    "ENERGY UNIT"
     **** ****     > RTOK
0008 06E9   5A            byte 121 ^ RE
                   < elite.a99
2203                      .rtok 14                                            ;
     **** ****     > RTOK
0003 06EA 8D              byte (14 + 160) ^ RE
                   < elite.a99
2204 06EB   00            byte >00                                            ; Encoded as:   "[121][14]"
2205               
2206                      .rtok 124                                           ; Token 115:    "DOCKING COMPUTERS"
     **** ****     > RTOK
0008 06EC 5F              byte 124 ^ RE
                   < elite.a99
2207 06ED   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
2208                      .char 'G'                                           ; Encoded as:   "[124]<140>G [55]"
     **** ****     > CHAR
0004 06EE 64              byte 'G' ^ RE
                   < elite.a99
2209                      .char ' '
     **** ****     > CHAR
0004 06EF   03            byte ' ' ^ RE
                   < elite.a99
2210                      .rtok 55
     **** ****     > RTOK
0003 06F0 F4              byte (55 + 160) ^ RE
                   < elite.a99
2211 06F1   00            byte >00
2212               
2213                      .rtok 122                                           ; Token 116:    "GALACTIC HYPERSPACE "
     **** ****     > RTOK
0008 06F2 59              byte 122 ^ RE
                   < elite.a99
2214                      .char ' '                                           ;
     **** ****     > CHAR
0004 06F3   03            byte ' ' ^ RE
                   < elite.a99
2215                      .rtok 29                                            ; Encoded as:   "[122] [29]"
     **** ****     > RTOK
0003 06F4 9E              byte (29 + 160) ^ RE
                   < elite.a99
2216 06F5   00            byte >00
2217               
2218                      .char 'A'                                           ; Token 117:    "ALL"
     **** ****     > CHAR
0004 06F6 62              byte 'A' ^ RE
                   < elite.a99
2219                      .rtok 118                                           ;
     **** ****     > RTOK
0008 06F7   55            byte 118 ^ RE
                   < elite.a99
2220 06F8 00              byte >00                                            ; Encoded as:   "A[118]"
2221               
2222                      .char 'L'                                           ; Token 118:    "LL"
     **** ****     > CHAR
0004 06F9   6F            byte 'L' ^ RE
                   < elite.a99
2223                      .char 'L'                                           ;
     **** ****     > CHAR
0004 06FA 6F              byte 'L' ^ RE
                   < elite.a99
2224 06FB   00            byte >00                                            ; Encoded as:   "LL"
2225               
2226                      .rtok 37                                            ; Token 119:    "CASH:{cash} CR{crlf}
     **** ****     > RTOK
0003 06FC E6              byte (37 + 160) ^ RE
                   < elite.a99
2227                      .char ':'                                           ; "
     **** ****     > CHAR
0004 06FD   19            byte ':' ^ RE
                   < elite.a99
2228                      .cont 0                                             ;
     **** ****     > CONT
0001 06FE 23              byte 0 ^ RE
                   < elite.a99
2229 06FF   00            byte >00                                            ; Encoded as:   "[37]:{0}"
2230               
2231 0700 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 120:    "INCOMING MISSILE"
2232                      .rtok 91                                            ;
     **** ****     > RTOK
0003 0701   D8            byte (91 + 160) ^ RE
                   < elite.a99
2233 0702 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Encoded as:   "<140>[91]<140>G [106]"
2234                      .char 'G'
     **** ****     > CHAR
0004 0703   64            byte 'G' ^ RE
                   < elite.a99
2235                      .char ' '
     **** ****     > CHAR
0004 0704 03              byte ' ' ^ RE
                   < elite.a99
2236                      .rtok 106
     **** ****     > RTOK
0008 0705   49            byte 106 ^ RE
                   < elite.a99
2237 0706 00              byte >00
2238               
2239 0707   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Token 121:    "ENERGY "
2240 0708 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R'
2241                      .char 'G'                                           ; Encoded as:   "<146><144>GY "
     **** ****     > CHAR
0004 0709   64            byte 'G' ^ RE
                   < elite.a99
2242                      .char 'Y'
     **** ****     > CHAR
0004 070A 7A              byte 'Y' ^ RE
                   < elite.a99
2243                      .char ' '
     **** ****     > CHAR
0004 070B   03            byte ' ' ^ RE
                   < elite.a99
2244 070C 00              byte >00
2245               
2246                      .char 'G'                                           ; Token 122:    "GALACTIC"
     **** ****     > CHAR
0004 070D   64            byte 'G' ^ RE
                   < elite.a99
2247                      .char 'A'                                           ;
     **** ****     > CHAR
0004 070E 62              byte 'A' ^ RE
                   < elite.a99
2248 070F   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A' Encoded as:   "GA<149>C<151>C"
2249                      .char 'C'
     **** ****     > CHAR
0004 0710 60              byte 'C' ^ RE
                   < elite.a99
2250 0711   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2251                      .char 'C'
     **** ****     > CHAR
0004 0712 60              byte 'C' ^ RE
                   < elite.a99
2252 0713   00            byte >00
2253               
2254                      .cont 13                                            ; Token 123:    "{crlf}
     **** ****     > CONT
0001 0714 2E              byte 13 ^ RE
                   < elite.a99
2255                      .rtok 92                                            ; COMMANDER'S NAME? "
     **** ****     > RTOK
0003 0715   DF            byte (92 + 160) ^ RE
                   < elite.a99
2256                      .char '`'                                           ;
     **** ****     > CHAR
0002 0716 04              byte 39 ^ RE
                   < elite.a99
2257                      .char 'S'                                           ; Encoded as:   "{13}[92]'S NAME? "
     **** ****     > CHAR
0004 0717   70            byte 'S' ^ RE
                   < elite.a99
2258                      .char ' '
     **** ****     > CHAR
0004 0718 03              byte ' ' ^ RE
                   < elite.a99
2259                      .char 'N'
     **** ****     > CHAR
0004 0719   6D            byte 'N' ^ RE
                   < elite.a99
2260                      .char 'A'
     **** ****     > CHAR
0004 071A 62              byte 'A' ^ RE
                   < elite.a99
2261                      .char 'M'
     **** ****     > CHAR
0004 071B   6E            byte 'M' ^ RE
                   < elite.a99
2262                      .char 'E'
     **** ****     > CHAR
0004 071C 66              byte 'E' ^ RE
                   < elite.a99
2263                      .char '?'
     **** ****     > CHAR
0004 071D   1C            byte '?' ^ RE
                   < elite.a99
2264                      .char ' '
     **** ****     > CHAR
0004 071E 03              byte ' ' ^ RE
                   < elite.a99
2265 071F   00            byte >00
2266               
2267                      .char 'D'                                           ; Token 124:    "DOCK"
     **** ****     > CHAR
0004 0720 67              byte 'D' ^ RE
                   < elite.a99
2268                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0721   6C            byte 'O' ^ RE
                   < elite.a99
2269                      .char 'C'                                           ; Encoded as:   "DOCK"
     **** ****     > CHAR
0004 0722 60              byte 'C' ^ RE
                   < elite.a99
2270                      .char 'K'
     **** ****     > CHAR
0004 0723   68            byte 'K' ^ RE
                   < elite.a99
2271 0724 00              byte >00
2272               
2273                      .cont 5                                             ; Token 125:    "FUEL: {fuel level} LIGHT YEARS{crlf}
     **** ****     > CONT
0001 0725   26            byte 5 ^ RE
                   < elite.a99
2274 0726 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' CASH:{cash} CR{crlf}
2275                      .char 'G'                                           ; LEGAL STATUS:"
     **** ****     > CHAR
0004 0727   64            byte 'G' ^ RE
                   < elite.a99
2276 0728 A3              byte 128 ^ RE                                       ; TWOK 'A', 'L'
2277                      .char ' '                                           ; Encoded as:   "{5}<129>G<128> [43]<145><136>:"
     **** ****     > CHAR
0004 0729   03            byte ' ' ^ RE
                   < elite.a99
2278                      .rtok 43
     **** ****     > RTOK
0003 072A E8              byte (43 + 160) ^ RE
                   < elite.a99
2279 072B   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
2280 072C AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2281                      .char ':'
     **** ****     > CHAR
0004 072D   19            byte ':' ^ RE
                   < elite.a99
2282 072E 00              byte >00
2283               
2284                      .rtok 92                                            ; Token 126:    "COMMANDER {commander name}{crlf}
     **** ****     > RTOK
0003 072F   DF            byte (92 + 160) ^ RE
                   < elite.a99
2285                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 0730 03              byte ' ' ^ RE
                   < elite.a99
2286                      .cont 4                                             ; {crlf}
     **** ****     > CONT
0001 0731   27            byte 4 ^ RE
                   < elite.a99
2287                      .cont 13                                            ; {sentence case}PRESENT SYSTEM{tab to
     **** ****     > CONT
0001 0732 2E              byte 13 ^ RE
                   < elite.a99
2288                      .cont 13                                            ; column 21}:{current system name}{crlf}
     **** ****     > CONT
0001 0733   2E            byte 13 ^ RE
                   < elite.a99
2289                      .cont 13                                            ; HYPERSPACE SYSTEM{tab to column 21}:
     **** ****     > CONT
0001 0734 2E              byte 13 ^ RE
                   < elite.a99
2290                      .cont 6                                             ; {selected system name}{crlf}
     **** ****     > CONT
0001 0735   25            byte 6 ^ RE
                   < elite.a99
2291                      .rtok 145                                           ; CONDITION{tab to column 21}:"
     **** ****     > RTOK
0006 0736 3C              byte (145 - 114) ^ RE
                   < elite.a99
2292                      .char ' '                                           ;
     **** ****     > CHAR
0004 0737   03            byte ' ' ^ RE
                   < elite.a99
2293                      .rtok 5                                             ; Encoded as:   "[92] {4}{13}{13}{13}{6}[145] [5]{9}{2}
     **** ****     > RTOK
0003 0738 86              byte (5 + 160) ^ RE
                   < elite.a99
2294                      .cont 9                                             ; {13}[29][5]{9}{3}{13}C<159><141><151>
     **** ****     > CONT
0001 0739   2A            byte 9 ^ RE
                   < elite.a99
2295                      .cont 2                                             ; <159>{9}"
     **** ****     > CONT
0001 073A 21              byte 2 ^ RE
                   < elite.a99
2296                      .cont 13
     **** ****     > CONT
0001 073B   2E            byte 13 ^ RE
                   < elite.a99
2297                      .rtok 29
     **** ****     > RTOK
0003 073C 9E              byte (29 + 160) ^ RE
                   < elite.a99
2298                      .rtok 5
     **** ****     > RTOK
0003 073D   86            byte (5 + 160) ^ RE
                   < elite.a99
2299                      .cont 9
     **** ****     > CONT
0001 073E 2A              byte 9 ^ RE
                   < elite.a99
2300                      .cont 3
     **** ****     > CONT
0001 073F   20            byte 3 ^ RE
                   < elite.a99
2301                      .cont 13
     **** ****     > CONT
0001 0740 2E              byte 13 ^ RE
                   < elite.a99
2302                      .char 'C'
     **** ****     > CHAR
0004 0741   60            byte 'C' ^ RE
                   < elite.a99
2303 0742 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2304 0743   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' null
2305 0744 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2306 0745   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2307                      .cont 9
     **** ****     > CONT
0001 0746 2A              byte 9 ^ RE
                   < elite.a99
2308 0747   00            byte >00
2309               
2310                      .char 'I'                                           ; Token 127:    "ITEM"
     **** ****     > CHAR
0004 0748 6A              byte 'I' ^ RE
                   < elite.a99
2311 0749   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E'
2312                      .char 'M'                                           ; Encoded as:   "I<156>M"
     **** ****     > CHAR
0004 074A 6E              byte 'M' ^ RE
                   < elite.a99
2313 074B   00            byte >00
2314               
2315                      .char ' '                                           ; Token 128:    "  LOAD NEW COMMANDER (Y/N)?{crlf}
     **** ****     > CHAR
0004 074C 03              byte ' ' ^ RE
                   < elite.a99
2316                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 074D   03            byte ' ' ^ RE
                   < elite.a99
2317                      .char 'L'                                           ; "
     **** ****     > CHAR
0004 074E 6F              byte 'L' ^ RE
                   < elite.a99
2318                      .char 'O'                                           ;
     **** ****     > CHAR
0004 074F   6C            byte 'O' ^ RE
                   < elite.a99
2319                      .char 'A'                                           ; Encoded as:   "  LOAD NEW [92] [65]{13}{13}"
     **** ****     > CHAR
0004 0750 62              byte 'A' ^ RE
                   < elite.a99
2320                      .char 'D'
     **** ****     > CHAR
0004 0751   67            byte 'D' ^ RE
                   < elite.a99
2321                      .char ' '
     **** ****     > CHAR
0004 0752 03              byte ' ' ^ RE
                   < elite.a99
2322                      .char 'N'
     **** ****     > CHAR
0004 0753   6D            byte 'N' ^ RE
                   < elite.a99
2323                      .char 'E'
     **** ****     > CHAR
0004 0754 66              byte 'E' ^ RE
                   < elite.a99
2324                      .char 'W'
     **** ****     > CHAR
0004 0755   74            byte 'W' ^ RE
                   < elite.a99
2325                      .char ' '
     **** ****     > CHAR
0004 0756 03              byte ' ' ^ RE
                   < elite.a99
2326                      .rtok 92
     **** ****     > RTOK
0003 0757   DF            byte (92 + 160) ^ RE
                   < elite.a99
2327                      .char ' '
     **** ****     > CHAR
0004 0758 03              byte ' ' ^ RE
                   < elite.a99
2328                      .rtok 65
     **** ****     > RTOK
0003 0759   C2            byte (65 + 160) ^ RE
                   < elite.a99
2329                      .cont 13
     **** ****     > CONT
0001 075A 2E              byte 13 ^ RE
                   < elite.a99
2330                      .cont 13
     **** ****     > CONT
0001 075B   2E            byte 13 ^ RE
                   < elite.a99
2331 075C 00              byte >00
2332               
2333                      .cont 6                                             ; Token 129:    "{sentence case}DOCKED"
     **** ****     > CONT
0001 075D   25            byte 6 ^ RE
                   < elite.a99
2334                      .rtok 124                                           ;
     **** ****     > RTOK
0008 075E 5F              byte 124 ^ RE
                   < elite.a99
2335 075F   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' Encoded as:   "{6}[124]<152>"
2336 0760 00              byte >00
2337               
2338 0761   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 130:    "RATING:"
2339 0762 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I'
2340                      .char 'N'                                           ; Encoded as:   "<148><151>NG:"
     **** ****     > CHAR
0004 0763   6D            byte 'N' ^ RE
                   < elite.a99
2341                      .char 'G'
     **** ****     > CHAR
0004 0764 64              byte 'G' ^ RE
                   < elite.a99
2342                      .char ':'
     **** ****     > CHAR
0004 0765   19            byte ':' ^ RE
                   < elite.a99
2343 0766 00              byte >00
2344               
2345                      .char ' '                                           ; Token 131:    " ON "
     **** ****     > CHAR
0004 0767   03            byte ' ' ^ RE
                   < elite.a99
2346 0768 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N'
2347                      .char ' '                                           ; Encoded as:   " <159> "
     **** ****     > CHAR
0004 0769   03            byte ' ' ^ RE
                   < elite.a99
2348 076A 00              byte >00
2349               
2350                      .cont 13                                            ; Token 132:    "{crlf}
     **** ****     > CONT
0001 076B   2E            byte 13 ^ RE
                   < elite.a99
2351                      .cont 8                                             ; {all caps}EQUIPMENT: {sentence case}"
     **** ****     > CONT
0001 076C 2B              byte 8 ^ RE
                   < elite.a99
2352                      .rtok 47                                            ;
     **** ****     > RTOK
0003 076D   EC            byte (47 + 160) ^ RE
                   < elite.a99
2353                      .char 'M'                                           ; Encoded as:   "{13}{8}[47]M<146>T:{6}"
     **** ****     > CHAR
0004 076E 6E              byte 'M' ^ RE
                   < elite.a99
2354 076F   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2355                      .char 'T'
     **** ****     > CHAR
0004 0770 77              byte 'T' ^ RE
                   < elite.a99
2356                      .char ':'
     **** ****     > CHAR
0004 0771   19            byte ':' ^ RE
                   < elite.a99
2357                      .cont 6
     **** ****     > CONT
0001 0772 25              byte 6 ^ RE
                   < elite.a99
2358 0773   00            byte >00
2359               
2360                      .char 'C'                                           ; Token 133:    "CLEAN"
     **** ****     > CHAR
0004 0774 60              byte 'C' ^ RE
                   < elite.a99
2361 0775   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E'
2362 0776 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "C<129><155>"
2363 0777   00            byte >00
2364               
2365                      .char 'O'                                           ; Token 134:    "OFFENDER"
     **** ****     > CHAR
0004 0778 6C              byte 'O' ^ RE
                   < elite.a99
2366                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0779   65            byte 'F' ^ RE
                   < elite.a99
2367                      .char 'F'                                           ; Encoded as:   "OFF<146>D<144>"
     **** ****     > CHAR
0004 077A 65              byte 'F' ^ RE
                   < elite.a99
2368 077B   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2369                      .char 'D'
     **** ****     > CHAR
0004 077C 67              byte 'D' ^ RE
                   < elite.a99
2370 077D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2371 077E 00              byte >00
2372               
2373                      .char 'F'                                           ; Token 135:    "FUGITIVE"
     **** ****     > CHAR
0004 077F   65            byte 'F' ^ RE
                   < elite.a99
2374                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0780 76              byte 'U' ^ RE
                   < elite.a99
2375                      .char 'G'                                           ; Encoded as:   "FUGI<151><150>"
     **** ****     > CHAR
0004 0781   64            byte 'G' ^ RE
                   < elite.a99
2376                      .char 'I'
     **** ****     > CHAR
0004 0782 6A              byte 'I' ^ RE
                   < elite.a99
2377 0783   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2378 0784 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2379 0785   00            byte >00
2380               
2381                      .char 'H'                                           ; Token 136:    "HARMLESS"
     **** ****     > CHAR
0004 0786 6B              byte 'H' ^ RE
                   < elite.a99
2382 0787   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
2383                      .char 'M'                                           ; Encoded as:   "H<138>M<129>SS"
     **** ****     > CHAR
0004 0788 6E              byte 'M' ^ RE
                   < elite.a99
2384 0789   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2385                      .char 'S'
     **** ****     > CHAR
0004 078A 70              byte 'S' ^ RE
                   < elite.a99
2386                      .char 'S'
     **** ****     > CHAR
0004 078B   70            byte 'S' ^ RE
                   < elite.a99
2387 078C 00              byte >00
2388               
2389                      .char 'M'                                           ; Token 137:    "MOSTLY HARMLESS"
     **** ****     > CHAR
0004 078D   6E            byte 'M' ^ RE
                   < elite.a99
2390                      .char 'O'                                           ;
     **** ****     > CHAR
0004 078E 6C              byte 'O' ^ RE
                   < elite.a99
2391                      .rtok 43                                            ; Encoded as:   "MO[43]LY [136]"
     **** ****     > RTOK
0003 078F   E8            byte (43 + 160) ^ RE
                   < elite.a99
2392                      .char 'L'
     **** ****     > CHAR
0004 0790 6F              byte 'L' ^ RE
                   < elite.a99
2393                      .char 'Y'
     **** ****     > CHAR
0004 0791   7A            byte 'Y' ^ RE
                   < elite.a99
2394                      .char ' '
     **** ****     > CHAR
0004 0792 03              byte ' ' ^ RE
                   < elite.a99
2395                      .rtok 136
     **** ****     > RTOK
0006 0793   35            byte (136 - 114) ^ RE
                   < elite.a99
2396 0794 00              byte >00
2397               
2398                      .rtok 12                                            ; Token 138:    "POOR "
     **** ****     > RTOK
0003 0795   8F            byte (12 + 160) ^ RE
                   < elite.a99
2399 0796 00              byte >00                                            ;
2400                                                                          ; Encoded as:   "[12]"
2401               
2402                      .rtok 11                                            ; Token 139:    "AVERAGE "
     **** ****     > RTOK
0003 0797   88            byte (11 + 160) ^ RE
                   < elite.a99
2403 0798 00              byte >00                                            ;
2404                                                                          ; Encoded as:   "[11]"
2405               
2406                      .char 'A'                                           ; Token 140:    "ABOVE AVERAGE "
     **** ****     > CHAR
0004 0799   62            byte 'A' ^ RE
                   < elite.a99
2407                      .char 'B'                                           ;
     **** ****     > CHAR
0004 079A 61              byte 'B' ^ RE
                   < elite.a99
2408                      .char 'O'                                           ; Encoded as:   "ABO<150> [11]"
     **** ****     > CHAR
0004 079B   6C            byte 'O' ^ RE
                   < elite.a99
2409 079C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2410                      .char ' '
     **** ****     > CHAR
0004 079D   03            byte ' ' ^ RE
                   < elite.a99
2411                      .rtok 11
     **** ****     > RTOK
0003 079E 88              byte (11 + 160) ^ RE
                   < elite.a99
2412 079F   00            byte >00
2413               
2414                      .rtok 91                                            ; Token 141:    "COMPETENT"
     **** ****     > RTOK
0003 07A0 D8              byte (91 + 160) ^ RE
                   < elite.a99
2415                      .char 'P'                                           ;
     **** ****     > CHAR
0004 07A1   73            byte 'P' ^ RE
                   < elite.a99
2416                      .char 'E'                                           ; Encoded as:   "[91]PET<146>T"
     **** ****     > CHAR
0004 07A2 66              byte 'E' ^ RE
                   < elite.a99
2417                      .char 'T'
     **** ****     > CHAR
0004 07A3   77            byte 'T' ^ RE
                   < elite.a99
2418 07A4 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2419                      .char 'T'
     **** ****     > CHAR
0004 07A5   77            byte 'T' ^ RE
                   < elite.a99
2420 07A6 00              byte >00
2421               
2422                      .char 'D'                                           ; Token 142:    "DANGEROUS"
     **** ****     > CHAR
0004 07A7   67            byte 'D' ^ RE
                   < elite.a99
2423 07A8 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
2424 07A9   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "D<155><131>RO<136>"
2425                      .char 'R'
     **** ****     > CHAR
0004 07AA 71              byte 'R' ^ RE
                   < elite.a99
2426                      .char 'O'
     **** ****     > CHAR
0004 07AB   6C            byte 'O' ^ RE
                   < elite.a99
2427 07AC AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2428 07AD   00            byte >00
2429               
2430                      .char 'D'                                           ; Token 143:    "DEADLY"
     **** ****     > CHAR
0004 07AE 67              byte 'D' ^ RE
                   < elite.a99
2431                      .char 'E'                                           ;
     **** ****     > CHAR
0004 07AF   66            byte 'E' ^ RE
                   < elite.a99
2432                      .char 'A'                                           ; Encoded as:   "DEADLY"
     **** ****     > CHAR
0004 07B0 62              byte 'A' ^ RE
                   < elite.a99
2433                      .char 'D'
     **** ****     > CHAR
0004 07B1   67            byte 'D' ^ RE
                   < elite.a99
2434                      .char 'L'
     **** ****     > CHAR
0004 07B2 6F              byte 'L' ^ RE
                   < elite.a99
2435                      .char 'Y'
     **** ****     > CHAR
0004 07B3   7A            byte 'Y' ^ RE
                   < elite.a99
2436 07B4 00              byte >00
2437               
2438                      .char '-'                                           ; Token 144:    "---- E L I T E ----"
     **** ****     > CHAR
0004 07B5   0E            byte '-' ^ RE
                   < elite.a99
2439                      .char '-'                                           ;
     **** ****     > CHAR
0004 07B6 0E              byte '-' ^ RE
                   < elite.a99
2440                      .char '-'                                           ; Encoded as:   "---- E L I T E ----"
     **** ****     > CHAR
0004 07B7   0E            byte '-' ^ RE
                   < elite.a99
2441                      .char '-'
     **** ****     > CHAR
0004 07B8 0E              byte '-' ^ RE
                   < elite.a99
2442                      .char ' '
     **** ****     > CHAR
0004 07B9   03            byte ' ' ^ RE
                   < elite.a99
2443                      .char 'E'
     **** ****     > CHAR
0004 07BA 66              byte 'E' ^ RE
                   < elite.a99
2444                      .char ' '
     **** ****     > CHAR
0004 07BB   03            byte ' ' ^ RE
                   < elite.a99
2445                      .char 'L'
     **** ****     > CHAR
0004 07BC 6F              byte 'L' ^ RE
                   < elite.a99
2446                      .char ' '
     **** ****     > CHAR
0004 07BD   03            byte ' ' ^ RE
                   < elite.a99
2447                      .char 'I'
     **** ****     > CHAR
0004 07BE 6A              byte 'I' ^ RE
                   < elite.a99
2448                      .char ' '
     **** ****     > CHAR
0004 07BF   03            byte ' ' ^ RE
                   < elite.a99
2449                      .char 'T'
     **** ****     > CHAR
0004 07C0 77              byte 'T' ^ RE
                   < elite.a99
2450                      .char ' '
     **** ****     > CHAR
0004 07C1   03            byte ' ' ^ RE
                   < elite.a99
2451                      .char 'E'
     **** ****     > CHAR
0004 07C2 66              byte 'E' ^ RE
                   < elite.a99
2452                      .char ' '
     **** ****     > CHAR
0004 07C3   03            byte ' ' ^ RE
                   < elite.a99
2453                      .char '-'
     **** ****     > CHAR
0004 07C4 0E              byte '-' ^ RE
                   < elite.a99
2454                      .char '-'
     **** ****     > CHAR
0004 07C5   0E            byte '-' ^ RE
                   < elite.a99
2455                      .char '-'
     **** ****     > CHAR
0004 07C6 0E              byte '-' ^ RE
                   < elite.a99
2456                      .char '-'
     **** ****     > CHAR
0004 07C7   0E            byte '-' ^ RE
                   < elite.a99
2457 07C8 00              byte >00
2458               
2459                      .char 'P'                                           ; Token 145:    "PRESENT"
     **** ****     > CHAR
0004 07C9   73            byte 'P' ^ RE
                   < elite.a99
2460 07CA AD              byte 142 ^ RE                                       ; TWOK 'R', 'E'
2461                      .char 'S'                                           ; Encoded as:   "P<142>S<146>T"
     **** ****     > CHAR
0004 07CB   70            byte 'S' ^ RE
                   < elite.a99
2462 07CC B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2463                      .char 'T'
     **** ****     > CHAR
0004 07CD   77            byte 'T' ^ RE
                   < elite.a99
2464 07CE 00              byte >00
2465               
2466                      .cont 8                                             ; Token 146:    "{all caps}GAME OVER"
     **** ****     > CONT
0001 07CF   2B            byte 8 ^ RE
                   < elite.a99
2467                      .char 'G'                                           ;
     **** ****     > CHAR
0004 07D0 64              byte 'G' ^ RE
                   < elite.a99
2468                      .char 'A'                                           ; Encoded as:   "{8}GAME O<150>R"
     **** ****     > CHAR
0004 07D1   62            byte 'A' ^ RE
                   < elite.a99
2469                      .char 'M'
     **** ****     > CHAR
0004 07D2 6E              byte 'M' ^ RE
                   < elite.a99
2470                      .char 'E'
     **** ****     > CHAR
0004 07D3   66            byte 'E' ^ RE
                   < elite.a99
2471                      .char ' '
     **** ****     > CHAR
0004 07D4 03              byte ' ' ^ RE
                   < elite.a99
2472                      .char 'O'
     **** ****     > CHAR
0004 07D5   6C            byte 'O' ^ RE
                   < elite.a99
2473 07D6 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2474                      .char 'R'
     **** ****     > CHAR
0004 07D7   71            byte 'R' ^ RE
                   < elite.a99
2475 07D8 00              byte >00
2476               
2477                      .char 'P'                                           ; Token 147:    "PRESS FIRE OR SPACE,COMMANDER.{crlf}
     **** ****     > CHAR
0004 07D9   73            byte 'P' ^ RE
                   < elite.a99
2478                      .char 'R'                                           ; {crlf}
     **** ****     > CHAR
0004 07DA 71              byte 'R' ^ RE
                   < elite.a99
2479 07DB   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' "
2480                      .char 'S'                                           ;
     **** ****     > CHAR
0004 07DC 70              byte 'S' ^ RE
                   < elite.a99
2481                      .char ' '                                           ; Encoded as:   "PR<137>S FI<142> <153> SPA<133>,[92].
     **** ****     > CHAR
0004 07DD   03            byte ' ' ^ RE
                   < elite.a99
2482                      .char 'F'                                           ; {13}{13}"
     **** ****     > CHAR
0004 07DE 65              byte 'F' ^ RE
                   < elite.a99
2483                      .char 'I'
     **** ****     > CHAR
0004 07DF   6A            byte 'I' ^ RE
                   < elite.a99
2484 07E0 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' null
2485                      .char ' '
     **** ****     > CHAR
0004 07E1   03            byte ' ' ^ RE
                   < elite.a99
2486 07E2 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2487                      .char ' '
     **** ****     > CHAR
0004 07E3   03            byte ' ' ^ RE
                   < elite.a99
2488                      .char 'S'
     **** ****     > CHAR
0004 07E4 70              byte 'S' ^ RE
                   < elite.a99
2489                      .char 'P'
     **** ****     > CHAR
0004 07E5   73            byte 'P' ^ RE
                   < elite.a99
2490                      .char 'A'
     **** ****     > CHAR
0004 07E6 62              byte 'A' ^ RE
                   < elite.a99
2491 07E7   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' null
2492                      .char ','
     **** ****     > CHAR
0004 07E8 0F              byte ',' ^ RE
                   < elite.a99
2493                      .rtok 92
     **** ****     > RTOK
0003 07E9   DF            byte (92 + 160) ^ RE
                   < elite.a99
2494                      .char '.'
     **** ****     > CHAR
0004 07EA 0D              byte '.' ^ RE
                   < elite.a99
2495                      .cont 13
     **** ****     > CONT
0001 07EB   2E            byte 13 ^ RE
                   < elite.a99
2496                      .cont 13
     **** ****     > CONT
0001 07EC 2E              byte 13 ^ RE
                   < elite.a99
2497 07ED   00            byte >00
2498               
2499                      .char '('                                           ; Token 148:    "(C) ACORNSOFT 1984"
     **** ****     > CHAR
0004 07EE 0B              byte '(' ^ RE
                   < elite.a99
2500                      .char 'C'                                           ;
     **** ****     > CHAR
0004 07EF   60            byte 'C' ^ RE
                   < elite.a99
2501                      .char ')'                                           ; Encoded as:   "(C) AC<153>N<135>FT 1984"
     **** ****     > CHAR
0004 07F0 0A              byte ')' ^ RE
                   < elite.a99
2502                      .char ' '
     **** ****     > CHAR
0004 07F1   03            byte ' ' ^ RE
                   < elite.a99
2503                      .char 'A'
     **** ****     > CHAR
0004 07F2 62              byte 'A' ^ RE
                   < elite.a99
2504                      .char 'C'
     **** ****     > CHAR
0004 07F3   60            byte 'C' ^ RE
                   < elite.a99
2505 07F4 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2506                      .char 'N'
     **** ****     > CHAR
0004 07F5   6D            byte 'N' ^ RE
                   < elite.a99
2507 07F6 A4              byte 135 ^ RE                                       ; TWOK 'S', 'O' null
2508                      .char 'F'
     **** ****     > CHAR
0004 07F7   65            byte 'F' ^ RE
                   < elite.a99
2509                      .char 'T'
     **** ****     > CHAR
0004 07F8 77              byte 'T' ^ RE
                   < elite.a99
2510                      .char ' '
     **** ****     > CHAR
0004 07F9   03            byte ' ' ^ RE
                   < elite.a99
2511                      .char '1'
     **** ****     > CHAR
0004 07FA 12              byte '1' ^ RE
                   < elite.a99
2512                      .char '9'
     **** ****     > CHAR
0004 07FB   1A            byte '9' ^ RE
                   < elite.a99
2513                      .char '8'
     **** ****     > CHAR
0004 07FC 1B              byte '8' ^ RE
                   < elite.a99
2514                      .char '4'
     **** ****     > CHAR
0004 07FD   17            byte '4' ^ RE
                   < elite.a99
2515 07FE 00              byte >00
2516               
2517               * ******************************************************************************
2518               *
2519               * Save WORDS9.bin
2520               *
2521               * ******************************************************************************
2522               
2523                      ; PRINT "WORDS9"
2524                      ; PRINT "Assembled at ", ~CODE_WORDS%
2525                      ; PRINT "Ends at ", ~P%
2526                      ; PRINT "Code size is ", ~(P% - CODE_WORDS%)
2527                      ; PRINT "Execute at ", ~LOAD_WORDS%
2528                      ; PRINT "Reload at ", ~LOAD_WORDS%
2529               
2530                      ; PRINT "S.WORDS9 ",~CODE_WORDS%," ",~P%," ",~LOAD_WORDS%," ",~LOAD_WORDS%
2531                      ; SAVE "3-assembled-output/WORDS9.bin", CODE_WORDS%, P%, LOAD_WORDS%
2532               
2533               * ******************************************************************************
2534               *
2535               * Name: K%
2536               * Type: Workspace
2537               * Address: &0900 to &0AAF
2538               * Category: Workspaces
2539               * Summary: Ship data blocks and ship line heaps
2540               * Deep dive: Ship data blocks
2541               * The local bubble of universe
2542               *
2543               * ------------------------------------------------------------------------------
2544               *
2545               * Contains ship data for all the ships, planets, suns and space stations in our
2546               * local bubble of universe, along with their corresponding ship line heaps.
2547               *
2548               * The blocks are pointed to by the lookup table at location UNIV. The first 432
2549               * bytes of the K% workspace hold ship data on up to 12 ships, with 36 (NI%)
2550               * bytes per ship, and the ship line heap grows downwards from WP at the end of
2551               * the K% workspace.
2552               *
2553               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
2554               * the deep dive on "The local bubble of universe" for details of how Elite
2555               * stores the local universe in K%, FRIN and UNIV.
2556               *
2557               * ******************************************************************************
2558               
2559                      aorg K.
2560               
2561 0900                 bss NOSH * NI.                                      ; Ship data blocks and ship line heap
2562               
2563               * ******************************************************************************
2564               *
2565               * Name: WP
2566               * Type: Workspace
2567               * Address: &0D40 to &0F33
2568               * Category: Workspaces
2569               * Summary: Ship slots, variables
2570               *
2571               * ******************************************************************************
2572               
2573                      aorg WP.
2574               
2575 0D40                 bss 0                                               ; The start of the WP workspace
2576               
2577               FRIN:
2578 0D40                 bss NOSH + 1                                        ; Slots for the ships in the local bubble of universe
2579                                                                          ;
2580                                                                          ; There are #NOSH + 1 slots, but the ship-spawning
2581                                                                          ; routine at NWSHP only populates #NOSH of them, so
2582                                                                          ; there are 13 slots but only 12 are used for ships
2583                                                                          ; (the last slot is effectively used as a null
2584                                                                          ; terminator when shuffling the slots down in the
2585                                                                          ; KILLSHP routine)
2586                                                                          ;
2587                                                                          ; See the deep dive on "The local bubble of universe"
2588                                                                          ; for details of how Elite stores the local universe in
2589                                                                          ; FRIN, UNIV and K%
2590               
2591               CABTMP:
2592 0D4D                 bss 0                                               ; Cabin temperature
2593                                                                          ;
2594                                                                          ; The ambient cabin temperature in deep space is 30,
2595                                                                          ; which is displayed as one notch on the dashboard bar
2596                                                                          ;
2597                                                                          ; We get higher temperatures closer to the sun
2598                                                                          ;
2599                                                                          ; CABTMP shares a location with MANY, but that's OK as
2600                                                                          ; MANY+0 would contain the number of ships of type 0,
2601                                                                          ; and as there is no ship type 0 (they start at 1), the
2602                                                                          ; byte at MANY+0 is not used for storing a ship type
2603                                                                          ; and can be used for the cabin temperature instead
2604               
2605               MANY:
2606 0D4D                 bss SST                                             ; The number of ships of each type in the local bubble
2607                                                                          ; of universe
2608                                                                          ;
2609                                                                          ; The number of ships of type X in the local bubble is
2610                                                                          ; stored at MANY+X
2611                                                                          ;
2612                                                                          ; See the deep dive on "Ship blueprints" for a list of
2613                                                                          ; ship types
2614               
2615               SSPR:
2616 0D55                 bss NTY + 1 - SST                                   ; "Space station present" flag
2617                                                                          ;
2618                                                                          ; * Non-zero if we are inside the space station's safe
2619                                                                          ; zone
2620                                                                          ;
2621                                                                          ; * 0 if we aren't (in which case we can show the sun)
2622                                                                          ;
2623                                                                          ; This flag is at MANY+SST, which is no coincidence, as
2624                                                                          ; MANY+SST is a count of how many space stations there
2625                                                                          ; are in our local bubble, which is the same as saying
2626                                                                          ; "space station present"
2627               
2628               ECMP:
2629 0D5B                 bss 1                                               ; Our E.C.M. status
2630                                                                          ;
2631                                                                          ; * 0 = E.C.M. is off
2632                                                                          ;
2633                                                                          ; * Non-zero = E.C.M. is on
2634               
2635               MJ:
2636 0D5C                 bss 1                                               ; Are we in witchspace (i.e. have we mis-jumped)?
2637                                                                          ;
2638                                                                          ; * 0 = no, we are in normal space
2639                                                                          ;
2640                                                                          ; * &FF = yes, we are in witchspace
2641               
2642               LAS2:
2643 0D5D                 bss 1                                               ; Laser power for the current laser
2644                                                                          ;
2645                                                                          ; * Bits 0-6 contain the laser power of the current
2646                                                                          ; space view
2647                                                                          ;
2648                                                                          ; * Bit 7 denotes whether or not the laser pulses:
2649                                                                          ;
2650                                                                          ; * 0 = pulsing laser
2651                                                                          ;
2652                                                                          ; * 1 = beam laser (i.e. always on)
2653               
2654               MSAR:
2655 0D5E                 bss 1                                               ; The targeting state of our leftmost missile
2656                                                                          ;
2657                                                                          ; * 0 = missile is not looking for a target, or it
2658                                                                          ; already has a target lock (indicator is not
2659                                                                          ; yellow/white)
2660                                                                          ;
2661                                                                          ; * Non-zero = missile is currently looking for a
2662                                                                          ; target (indicator is yellow/white)
2663               
2664               VIEW:
2665 0D5F                 bss 1                                               ; The number of the current space view
2666                                                                          ;
2667                                                                          ; * 0 = front
2668                                                                          ; * 1 = rear
2669                                                                          ; * 2 = left
2670                                                                          ; * 3 = right
2671               
2672               LASCT:
2673 0D60                 bss 1                                               ; The laser pulse count for the current laser
2674                                                                          ;
2675                                                                          ; This is a counter that defines the gap between the
2676                                                                          ; pulses of a pulse laser. It is set as follows:
2677                                                                          ;
2678                                                                          ; * 0 for a beam laser
2679                                                                          ;
2680                                                                          ; * 10 for a pulse laser
2681                                                                          ;
2682                                                                          ; It gets decremented every vertical sync (in the LINSCN
2683                                                                          ; routine, which is called 50 times a second) and is set
2684                                                                          ; to a non-zero value for pulse lasers only
2685                                                                          ;
2686                                                                          ; The laser only fires when the value of LASCT hits
2687                                                                          ; zero, so for pulse lasers with a value of 10, that
2688                                                                          ; means the laser fires once every 10 vertical syncs (or
2689                                                                          ; 5 times a second)
2690                                                                          ;
2691                                                                          ; In comparison, beam lasers fire continuously as the
2692                                                                          ; value of LASCT is always 0
2693               
2694               GNTMP:
2695 0D61                 bss 1                                               ; Laser temperature (or "gun temperature")
2696                                                                          ;
2697                                                                          ; If the laser temperature exceeds 242 then the laser
2698                                                                          ; overheats and cannot be fired again until it has
2699                                                                          ; cooled down
2700               
2701               HFX:
2702 0D62                 bss 1                                               ; A flag that toggles the hyperspace colour effect
2703                                                                          ;
2704                                                                          ; * 0 = no colour effect
2705                                                                          ;
2706                                                                          ; * Non-zero = hyperspace colour effect enabled
2707                                                                          ;
2708                                                                          ; When HFX is set to 1, the mode 4 screen that makes
2709                                                                          ; up the top part of the display is temporarily switched
2710                                                                          ; to mode 5 (the same screen mode as the dashboard),
2711                                                                          ; which has the effect of blurring and colouring the
2712                                                                          ; hyperspace rings in the top part of the screen. The
2713                                                                          ; code to do this is in the LINSCN routine, which is
2714                                                                          ; called as part of the screen mode routine at IRQ1.
2715                                                                          ; It's in LINSCN that HFX is checked, and if it is
2716                                                                          ; non-zero, the top part of the screen is not switched
2717                                                                          ; to mode 4, thus leaving the top part of the screen in
2718                                                                          ; the more colourful mode 5
2719               
2720               EV:
2721 0D63                 bss 1                                               ; The "extra vessels" spawning counter
2722                                                                          ;
2723                                                                          ; This counter is set to 0 on arrival in a system and
2724                                                                          ; following an in-system jump, and is bumped up when we
2725                                                                          ; spawn bounty hunters or pirates (i.e. "extra vessels")
2726                                                                          ;
2727                                                                          ; It decreases by 1 each time we consider spawning more
2728                                                                          ; "extra vessels" in part 4 of the main game loop, so
2729                                                                          ; increasing the value of EV has the effect of delaying
2730                                                                          ; the spawning of more vessels
2731                                                                          ;
2732                                                                          ; In other words, this counter stops bounty hunters and
2733                                                                          ; pirates from continually appearing, and ensures that
2734                                                                          ; there's a delay between spawnings
2735               
2736               DLY:
2737 0D64                 bss 1                                               ; In-flight message delay
2738                                                                          ;
2739                                                                          ; This counter is used to keep an in-flight message up
2740                                                                          ; for a specified time before it gets removed. The value
2741                                                                          ; in DLY is decremented each time we start another
2742                                                                          ; iteration of the main game loop at TT100
2743               
2744               de_:
2745 0D65                 bss 1                                               ; Equipment destruction flag
2746                                                                          ;
2747                                                                          ; * Bit 1 denotes whether or not the in-flight message
2748                                                                          ; about to be shown by the MESS routine is about
2749                                                                          ; destroyed equipment:
2750                                                                          ;
2751                                                                          ; * 0 = the message is shown normally
2752                                                                          ;
2753                                                                          ; * 1 = the string " DESTROYED" gets added to the
2754                                                                          ; end of the message
2755               
2756               LSX:
2757 0D66                 bss 0                                               ; LSX is an alias that points to the first byte of the
2758                                                                          ; sun line heap at LSO
2759                                                                          ;
2760                                                                          ; * &FF indicates the sun line heap is empty
2761                                                                          ;
2762                                                                          ; * Otherwise the LSO heap contains the line data for
2763                                                                          ; the sun
2764               
2765               LSO:
2766 0D66                 bss 192                                             ; The ship line heap for the space station (see NWSPS)
2767                                                                          ; and the sun line heap (see SUN)
2768                                                                          ;
2769                                                                          ; The spaces can be shared as our local bubble of
2770                                                                          ; universe can support either the sun or a space
2771                                                                          ; station, but not both
2772               
2773               LSX2:
2774 0E26                 bss 78                                              ; The ball line heap for storing x-coordinates (see the
2775                                                                          ; deep dive on "The ball line heap" for details)
2776               
2777               LSY2:
2778 0E74                 bss 78                                              ; The ball line heap for storing y-coordinates (see the
2779                                                                          ; deep dive on "The ball line heap" for details)
2780               
2781               SY:
2782 0EC2                 bss NOST + 1                                        ; This is where we store the y_hi coordinates for all
2783                                                                          ; the stardust particles
2784               
2785               SYL:
2786 0ED5                 bss NOST + 1                                        ; This is where we store the y_lo coordinates for all
2787                                                                          ; the stardust particles
2788               
2789               SZ:
2790 0EE8                 bss NOST + 1                                        ; This is where we store the z_hi coordinates for all
2791                                                                          ; the stardust particles
2792               
2793               SZL:
2794 0EFB                 bss NOST + 1                                        ; This is where we store the z_lo coordinates for all
2795                                                                          ; the stardust particles
2796               
2797               XSAV2:
2798 0F0E                 bss 1                                               ; Temporary storage, used for storing the value of the X
2799                                                                          ; register in the TT26 routine
2800               
2801               YSAV2:
2802 0F0F                 bss 1                                               ; Temporary storage, used for storing the value of the Y
2803                                                                          ; register in the TT26 routine
2804               
2805               MCH:
2806 0F10                 bss 1                                               ; The text token number of the in-flight message that is
2807                                                                          ; currently being shown, and which will be removed by
2808                                                                          ; the me2 routine when the counter in DLY reaches zero
2809               
2810               FSH:
2811 0F11                 bss 1                                               ; Forward shield status
2812                                                                          ;
2813                                                                          ; * 0 = empty
2814                                                                          ;
2815                                                                          ; * &FF = full
2816               
2817               ASH:
2818 0F12                 bss 1                                               ; Aft shield status
2819                                                                          ;
2820                                                                          ; * 0 = empty
2821                                                                          ;
2822                                                                          ; * &FF = full
2823               
2824               ENERGY:
2825 0F13                 bss 1                                               ; Energy bank status
2826                                                                          ;
2827                                                                          ; * 0 = empty
2828                                                                          ;
2829                                                                          ; * &FF = full
2830               
2831               LASX:
2832 0F14                 bss 1                                               ; The x-coordinate of the tip of the laser line
2833               
2834               LASY:
2835 0F15                 bss 1                                               ; The y-coordinate of the tip of the laser line
2836               
2837               COMX:
2838 0F16                 bss 1                                               ; The x-coordinate of the compass dot
2839               
2840               COMY:
2841 0F17                 bss 1                                               ; The y-coordinate of the compass dot
2842               
2843               QQ24:
2844 0F18                 bss 1                                               ; Temporary storage, used to store the current market
2845                                                                          ; item's price in routine TT151
2846               
2847               QQ25:
2848 0F19                 bss 1                                               ; Temporary storage, used to store the current market
2849                                                                          ; item's availability in routine TT151
2850               
2851               QQ28:
2852 0F1A                 bss 1                                               ; The current system's economy (0-7)
2853                                                                          ;
2854                                                                          ; * 0 = Rich Industrial
2855                                                                          ; * 1 = Average Industrial
2856                                                                          ; * 2 = Poor Industrial
2857                                                                          ; * 3 = Mainly Industrial
2858                                                                          ; * 4 = Mainly Agricultural
2859                                                                          ; * 5 = Rich Agricultural
2860                                                                          ; * 6 = Average Agricultural
2861                                                                          ; * 7 = Poor Agricultural
2862                                                                          ;
2863                                                                          ; See the deep dive on "Generating system data" for more
2864                                                                          ; information on economies
2865               
2866               QQ29:
2867 0F1B                 bss 1                                               ; Temporary storage, used in a number of places
2868               
2869               gov_:
2870 0F1C                 bss 1                                               ; The current system's government type (0-7)
2871                                                                          ;
2872                                                                          ; See the deep dive on "Generating system data" for
2873                                                                          ; details of the various government types
2874               
2875               tek_:
2876 0F1D                 bss 1                                               ; The current system's tech level (0-14)
2877                                                                          ;
2878                                                                          ; See the deep dive on "Generating system data" for more
2879                                                                          ; information on tech levels
2880               
2881               SLSP:
2882 0F1E                 bss 2                                               ; The address of the bottom of the ship line heap
2883                                                                          ;
2884                                                                          ; The ship line heap is a descending block of memory
2885                                                                          ; that starts at WP and descends down to SLSP. It can be
2886                                                                          ; extended downwards by the NWSHP routine when adding
2887                                                                          ; new ships (and their associated ship line heaps), in
2888                                                                          ; which case SLSP is lowered to provide more heap space,
2889                                                                          ; assuming there is enough free memory to do so
2890               
2891               XX24:
2892 0F20                 bss 1                                               ; This byte appears to be unused
2893               
2894               ALTIT:
2895 0F21                 bss 1                                               ; Our altitude above the surface of the planet or sun
2896                                                                          ;
2897                                                                          ; * 255 = we are a long way above the surface
2898                                                                          ;
2899                                                                          ; * 1-254 = our altitude as the square root of:
2900                                                                          ;
2901                                                                          ; x_hi^2 + y_hi^2 + z_hi^2 - 6^2
2902                                                                          ;
2903                                                                          ; where our ship is at the origin, the centre of the
2904                                                                          ; planet/sun is at (x_hi, y_hi, z_hi), and the
2905                                                                          ; radius of the planet/sun is 6
2906                                                                          ;
2907                                                                          ; * 0 = we have crashed into the surface
2908               
2909               QQ2:
2910 0F22                 bss 6                                               ; The three 16-bit seeds for the current system, i.e.
2911                                                                          ; the one we are currently in
2912                                                                          ;
2913                                                                          ; See the deep dives on "Galaxy and system seeds" and
2914                                                                          ; "Twisting the system seeds" for more details
2915               
2916               QQ3:
2917 0F28                 bss 1                                               ; The selected system's economy (0-7)
2918                                                                          ;
2919                                                                          ; * 0 = Rich Industrial
2920                                                                          ; * 1 = Average Industrial
2921                                                                          ; * 2 = Poor Industrial
2922                                                                          ; * 3 = Mainly Industrial
2923                                                                          ; * 4 = Mainly Agricultural
2924                                                                          ; * 5 = Rich Agricultural
2925                                                                          ; * 6 = Average Agricultural
2926                                                                          ; * 7 = Poor Agricultural
2927                                                                          ;
2928                                                                          ; See the deep dive on "Generating system data" for more
2929                                                                          ; information on economies
2930               
2931               QQ4:
2932 0F29                 bss 1                                               ; The selected system's government (0-7)
2933                                                                          ;
2934                                                                          ; See the deep dive on "Generating system data" for more
2935                                                                          ; details of the various government types
2936               
2937               QQ5:
2938 0F2A                 bss 1                                               ; The selected system's tech level (0-14)
2939                                                                          ;
2940                                                                          ; See the deep dive on "Generating system data" for more
2941                                                                          ; information on tech levels
2942               
2943               QQ6:
2944 0F2B                 bss 2                                               ; The selected system's population in billions * 10
2945                                                                          ; (1-71), so the maximum population is 7.1 billion
2946                                                                          ;
2947                                                                          ; See the deep dive on "Generating system data" for more
2948                                                                          ; details on population levels
2949               
2950               QQ7:
2951 0F2D                 bss 2                                               ; The selected system's productivity in M CR (96-62480)
2952                                                                          ;
2953                                                                          ; See the deep dive on "Generating system data" for more
2954                                                                          ; details about productivity levels
2955               
2956               QQ8:
2957 0F2F                 bss 2                                               ; The distance from the current system to the selected
2958                                                                          ; system in light years * 10, stored as a 16-bit number
2959                                                                          ;
2960                                                                          ; The distance will be 0 if the selected system is the
2961                                                                          ; current system
2962                                                                          ;
2963                                                                          ; The galaxy chart is 102.4 light years wide and 51.2
2964                                                                          ; light years tall (see the intra-system distance
2965                                                                          ; calculations in routine TT111 for details), which
2966                                                                          ; equates to 1024 x 512 in terms of QQ8
2967               
2968               QQ9:
2969 0F31                 bss 1                                               ; The galactic x-coordinate of the crosshairs in the
2970                                                                          ; galaxy chart (and, most of the time, the selected
2971                                                                          ; system's galactic x-coordinate)
2972               
2973               QQ10:
2974 0F32                 bss 1                                               ; The galactic y-coordinate of the crosshairs in the
2975                                                                          ; galaxy chart (and, most of the time, the selected
2976                                                                          ; system's galactic y-coordinate)
2977               
2978               NOSTM:
2979 0F33                 bss 1                                               ; The number of stardust particles shown on screen,
2980                                                                          ; which is 18 (#NOST) for normal space, and 3 for
2981                                                                          ; witchspace
2982               
2983                      ; PRINT "WP workspace from  ", ~WP," to ", ~P%
2984               
2985               * ******************************************************************************
2986               *
2987               * ELITE A FILE
2988               *
2989               * Produces the binary file ELTA.bin that gets loaded by elite-bcfs.asm.
2990               *
2991               * The main game code (ELITE A through G, plus the ship data) is loaded at &1128
2992               * and is moved down to &0F40 as part of elite-loader.asm.
2993               *
2994               * ******************************************************************************
2995               
2996                      aorg CODE.
2997               
2998               LOAD_A.:
2999                      equ LOAD.
3000               
3001               * ******************************************************************************
3002               *
3003               * Name: S%
3004               * Type: Workspace
3005               * Address: &0F40 to &0F50
3006               * Category: Workspaces
3007               * Summary: Vector addresses, compass colour and configuration settings
3008               *
3009               * ------------------------------------------------------------------------------
3010               *
3011               * Contains addresses that are used by the loader to set up vectors, the current
3012               * compass colour, and the game's configuration settings.
3013               *
3014               * ******************************************************************************
3015               
3016               S.:
3017 0F40 C5A4            data TT170                                          ; The entry point for the main game; once the main code
3018                                                                          ; has been loaded, decrypted and moved to the right
3019                                                                          ; place by elite-loader.asm, the game is started by a
3020                                                                          ; JMP (S%) instruction, which jumps to the main entry
3021                                                                          ; point at TT170 via this location
3022               
3023 0F42 3172            data TT26                                           ; WRCHV is set to point here by elite-loader.asm
3024               
3025 0F44 35EA            data IRQ1                                           ; IRQ1V is set to point here by elite-loader.asm
3026               
3027 0F46 C5AC            data BR1                                            ; BRKV is set to point here by elite-loader.asm
3028               
3029               COMC:
3030 0F48                 bss 1                                               ; The colour of the dot on the compass
3031                                                                          ;
3032                                                                          ; * &F0 = the object in the compass is in front of us,
3033                                                                          ; so the dot is yellow/white
3034                                                                          ;
3035                                                                          ; * &FF = the object in the compass is behind us, so
3036                                                                          ; the dot is green/cyan
3037               
3038               DNOIZ:
3039 0F49                 bss 1                                               ; Sound on/off configuration setting
3040                                                                          ;
3041                                                                          ; * 0 = sound is on (default)
3042                                                                          ;
3043                                                                          ; * Non-zero = sound is off
3044                                                                          ;
3045                                                                          ; Toggled by pressing "S" when paused, see the DK4
3046                                                                          ; routine for details
3047               
3048               DAMP:
3049 0F4A                 bss 1                                               ; Keyboard damping configuration setting
3050                                                                          ;
3051                                                                          ; * 0 = damping is enabled (default)
3052                                                                          ;
3053                                                                          ; * &FF = damping is disabled
3054                                                                          ;
3055                                                                          ; Toggled by pressing CAPS LOCK when paused, see the
3056                                                                          ; DKS3 routine for details
3057               
3058               DJD:
3059 0F4B                 bss 1                                               ; Keyboard auto-recentre configuration setting
3060                                                                          ;
3061                                                                          ; * 0 = auto-recentre is enabled (default)
3062                                                                          ;
3063                                                                          ; * &FF = auto-recentre is disabled
3064                                                                          ;
3065                                                                          ; Toggled by pressing "A" when paused, see the DKS3
3066                                                                          ; routine for details
3067               
3068               PATG:
3069 0F4C                 bss 1                                               ; Configuration setting to show the author names on the
3070                                                                          ; start-up screen and enable manual hyperspace mis-jumps
3071                                                                          ;
3072                                                                          ; * 0 = no author names or manual mis-jumps (default)
3073                                                                          ;
3074                                                                          ; * &FF = show author names and allow manual mis-jumps
3075                                                                          ;
3076                                                                          ; Toggled by pressing "X" when paused, see the DKS3
3077                                                                          ; routine for details
3078                                                                          ;
3079                                                                          ; This needs to be turned on for manual mis-jumps to be
3080                                                                          ; possible. To do a manual mis-jump, first toggle the
3081                                                                          ; author display by pausing the game (COPY) and pressing
3082                                                                          ; "X", and during the next hyperspace, hold down CTRL to
3083                                                                          ; force a mis-jump. See routine ee5 for the "AND PATG"
3084                                                                          ; instruction that implements this logic
3085               
3086               FLH:
3087 0F4D                 bss 1                                               ; Flashing console bars configuration setting
3088                                                                          ;
3089                                                                          ; * 0 = static bars (default)
3090                                                                          ;
3091                                                                          ; * &FF = flashing bars
3092                                                                          ;
3093                                                                          ; Toggled by pressing "F" when paused, see the DKS3
3094                                                                          ; routine for details
3095               
3096               JSTGY:
3097 0F4E                 bss 1                                               ; Reverse joystick Y-channel configuration setting
3098                                                                          ;
3099                                                                          ; * 0 = standard Y-channel (default)
3100                                                                          ;
3101                                                                          ; * &FF = reversed Y-channel
3102                                                                          ;
3103                                                                          ; Toggled by pressing "Y" when paused, see the DKS3
3104                                                                          ; routine for details
3105               
3106               JSTE:
3107 0F4F                 bss 1                                               ; Reverse both joystick channels configuration setting
3108                                                                          ;
3109                                                                          ; * 0 = standard channels (default)
3110                                                                          ;
3111                                                                          ; * &FF = reversed channels
3112                                                                          ;
3113                                                                          ; Toggled by pressing "J" when paused, see the DKS3
3114                                                                          ; routine for details
3115               
3116               JSTK:
3117 0F50                 bss 1                                               ; Keyboard or joystick configuration setting
3118                                                                          ;
3119                                                                          ; * 0 = keyboard (default)
3120                                                                          ;
3121                                                                          ; * &FF = joystick
3122                                                                          ;
3123                                                                          ; Toggled by pressing "K" when paused, see the DKS3
3124                                                                          ; routine for details
3125               
3126               * ******************************************************************************
3127               *
3128               * Name: Main flight loop (Part 1 of 16)
3129               * Type: Subroutine
3130               * Category: Main loop
3131               * Summary: Seed the random number generator
3132               * Deep dive: Program flow of the main game loop
3133               * Generating random numbers
3134               *
3135               * ------------------------------------------------------------------------------
3136               *
3137               * The main flight loop covers most of the flight-specific aspects of Elite. This
3138               * section covers the following:
3139               *
3140               * * Seed the random number generator
3141               *
3142               * ------------------------------------------------------------------------------
3143               *
3144               * Other entry points:
3145               *
3146               * M%                  The entry point for the main flight loop
3147               *
3148               * ******************************************************************************
3149               
3150               M.:
3151 0F52 D360  22        movb @K.,ra                     ; LDA K%            ; We want to seed the random number generator with a
     0F54 0900     
3152                                                                          ; pretty random number, so fetch the contents of K%,
3153                                                                          ; which is the x_lo coordinate of the planet. This value
3154                                                                          ; will be fairly unpredictable, so it's a pretty good
3155                                                                          ; candidate
3156               
3157 0F56 D80D  22        movb ra,@RAND                   ; STA RAND          ; Store the seed in the first byte of the four-byte
     0F58 0000     
3158                                                                          ; random number seed that's stored in RAND
3159               
3160               * ******************************************************************************
3161               *
3162               * Name: Main flight loop (Part 2 of 16)
3163               * Type: Subroutine
3164               * Category: Main loop
3165               * Summary: Calculate the alpha and beta angles from the current pitch and
3166               * roll of our ship
3167               * Deep dive: Program flow of the main game loop
3168               * Pitching and rolling
3169               *
3170               * ------------------------------------------------------------------------------
3171               *
3172               * The main flight loop covers most of the flight-specific aspects of Elite. This
3173               * section covers the following:
3174               *
3175               * * Calculate the alpha and beta angles from the current pitch and roll
3176               *
3177               * Here we take the current rate of pitch and roll, as set by the joystick or
3178               * keyboard, and convert them into alpha and beta angles that we can use in the
3179               * matrix functions to rotate space around our ship. The alpha angle covers
3180               * roll, while the beta angle covers pitch (there is no yaw in this version of
3181               * Elite). The angles are in radians, which allows us to use the small angle
3182               * approximation when moving objects in the sky (see the MVEIT routine for more
3183               * on this). Also, the signs of the two angles are stored separately, in both
3184               * the sign and the flipped sign, as this makes calculations easier.
3185               *
3186               * ******************************************************************************
3187               
3188 0F5A D3A0  22        movb @JSTX,rx                   ; LDX JSTX          ; Set X to the current rate of roll in JSTX
     0F5C 009C     
3189               
3190 0F5E 0200  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping twice (if enabled) so the roll
     0F60 4714     
3191 0F62 06A0  24        bl   @jsr                       ;
     0F64 FE1E     
3192 0F66 0200  12        li   rtmp,cntr_                 ; JSR cntr          ; rate in X creeps towards the centre by 2
     0F68 4714     
3193 0F6A 06A0  24        bl   @jsr                       ;
     0F6C FE1E     
3194               
3195                                                                          ; The roll rate in JSTX increases if we press ">" (and
3196                                                                          ; the RL indicator on the dashboard goes to the right)
3197                                                                          ;
3198                                                                          ; This rolls our ship to the right (clockwise), but we
3199                                                                          ; actually implement this by rolling everything else
3200                                                                          ; to the left (anti-clockwise), so a positive roll rate
3201                                                                          ; in JSTX translates to a negative roll angle alpha
3202               
3203 0F6E D34E  14        movb rx,ra                      ; TXA               ; Set A and Y to the roll rate but with the sign bit
3204                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped (i.e. set them to the sign we want for alpha)
     **** ****     > EOI
0001 0F70 0200  12        li   rtmp,(>80*256)
     0F72 8000     
0002 0F74 2B40  14        xor  rtmp,ra
                   < elite.a99
3205 0F76 D3CD  14        movb ra,ry                      ; TAY
3206               
3207 0F78 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the roll rate and store
     0F7A 8000     
3208 0F7C D80D  22        movb ra,@ALP2                   ; STA ALP2          ; in ALP2 (so ALP2 contains the sign of the roll angle
     0F7E 0088     
3209                                                                          ; alpha)
3210               
3211 0F80 D80E  22        movb rx,@JSTX                   ; STX JSTX          ; Update JSTX with the damped value that's still in X
     0F82 009C     
3212               
3213                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the roll rate and store
     **** ****     > EOI
0001 0F84 0200  12        li   rtmp,(>80*256)
     0F86 8000     
0002 0F88 2B40  14        xor  rtmp,ra
                   < elite.a99
3214 0F8A D80D  22        movb ra,@ALP2+1                 ; STA ALP2+1        ; in ALP2+1 (so ALP2+1 contains the flipped sign of the
     0F8C 0089     
3215                                                                          ; roll angle alpha)
3216               
3217 0F8E D34F  14        movb ry,ra                      ; TYA               ; Set A to the roll rate but with the sign bit flipped
3218               
3219 0F90 1508  10        jgt  B01                        ; BPL B01           ; If the value of A is positive, skip the following
3220                                                                          ; three instructions
3221               
3222                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so change the sign of A using two's
     **** ****     > EOI
0001 0F92 0200  12        li   rtmp,(>FF*256)
     0F94 FF00     
0002 0F96 2B40  14        xor  rtmp,ra
                   < elite.a99
3223                      .clc                            ; CLC               ; complement so that A is now positive and contains
     **** ****     > CLC
0001 0F98 0A16  14        sla  rzero,1
                   < elite.a99
3224                      .adi (>01*256)                  ; ADC #1            ; the absolute value of the roll rate, i.e. |JSTX|
     **** ****     > ADI
0001 0F9A 1701  10        jnc  !
0002 0F9C B347  14        ab   rone,ra
0003               !:
0004 0F9E 022D  14        ai   ra,(>01*256)
     0FA0 0100     
                   < elite.a99
3225               
3226               B01:
3227 0FA2 091D  14        srl  ra,1                       ; LSR A             ; Divide the (positive) roll rate in A by 4
3228 0FA4 091D  14        srl  ra,1                       ; LSR A
3229               
3230 0FA6 028D  14        ci   ra,>08*256                 ; CMP #8            ; If A >= 8, skip the following two instructions
     0FA8 0800     
3231 0FAA 1802  10        joc  B02                        ; BCS B02
3232               
3233 0FAC 091D  14        srl  ra,1                       ; LSR A             ; A < 8, so halve A again
3234               
3235                      .clc                            ; CLC               ; This instruction has no effect, as we only get here
     **** ****     > CLC
0001 0FAE 0A16  14        sla  rzero,1
                   < elite.a99
3236                                                                          ; if the C flag is clear (if it is set, we skip this
3237                                                                          ; instruction)
3238               B02:
3239 0FB0 D80D  22        movb ra,@ALP1                   ; STA ALP1          ; Store A in ALP1, so we now have:
     0FB2 0087     
3240                                                                          ;
3241                                                                          ; ALP1 = |JSTX| / 8    if |JSTX| < 32
3242                                                                          ;
3243                                                                          ; ALP1 = |JSTX| / 4    if |JSTX| >= 32
3244                                                                          ;
3245                                                                          ; This means that at lower roll rates, the roll angle is
3246                                                                          ; reduced closer to zero than at higher roll rates,
3247                                                                          ; which gives us finer control over the ship's roll at
3248                                                                          ; lower roll rates
3249                                                                          ;
3250                                                                          ; Because JSTX is in the range -127 to +127, ALP1 is
3251                                                                          ; in the range 0 to 31
3252               
3253 0FB4 F360  22        socb @ALP2,ra                   ; ORA ALP2          ; Store A in ALPHA, but with the sign set to ALP2 (so
     0FB6 0088     
3254 0FB8 D80D  22        movb ra,@ALPHA                  ; STA ALPHA         ; ALPHA has a different sign to the actual roll rate)
     0FBA 009E     
3255               
3256 0FBC D3A0  22        movb @JSTY,rx                   ; LDX JSTY          ; Set X to the current rate of pitch in JSTY
     0FBE 009D     
3257               
3258 0FC0 0200  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping so the pitch rate in X creeps
     0FC2 4714     
3259 0FC4 06A0  24        bl   @jsr                       ;
     0FC6 FE1E     
3260                                                                          ; towards the centre by 1
3261               
3262 0FC8 D34E  14        movb rx,ra                      ; TXA               ; Set A and Y to the pitch rate but with the sign bit
3263                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped
     **** ****     > EOI
0001 0FCA 0200  12        li   rtmp,(>80*256)
     0FCC 8000     
0002 0FCE 2B40  14        xor  rtmp,ra
                   < elite.a99
3264 0FD0 D3CD  14        movb ra,ry                      ; TAY
3265               
3266 0FD2 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the pitch rate into A
     0FD4 8000     
3267               
3268 0FD6 D80E  22        movb rx,@JSTY                   ; STX JSTY          ; Update JSTY with the damped value that's still in X
     0FD8 009D     
3269               
3270 0FDA D80D  22        movb ra,@BET2+1                 ; STA BET2+1        ; Store the flipped sign of the pitch rate in BET2+1
     0FDC 008B     
3271               
3272                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the pitch rate and store
     **** ****     > EOI
0001 0FDE 0200  12        li   rtmp,(>80*256)
     0FE0 8000     
0002 0FE2 2B40  14        xor  rtmp,ra
                   < elite.a99
3273 0FE4 D80D  22        movb ra,@BET2                   ; STA BET2          ; it in BET2
     0FE6 008A     
3274               
3275 0FE8 D34F  14        movb ry,ra                      ; TYA               ; Set A to the pitch rate but with the sign bit flipped
3276               
3277 0FEA 1503  10        jgt  B03                        ; BPL B03           ; If the value of A is positive, skip the following
3278                                                                          ; instruction
3279               
3280                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so flip the bits
     **** ****     > EOI
0001 0FEC 0200  12        li   rtmp,(>FF*256)
     0FEE FF00     
0002 0FF0 2B40  14        xor  rtmp,ra
                   < elite.a99
3281               
3282               B03:
3283                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the (positive) pitch rate, so the maximum
     **** ****     > ADI
0001 0FF2 1701  10        jnc  !
0002 0FF4 B347  14        ab   rone,ra
0003               !:
0004 0FF6 022D  14        ai   ra,(>04*256)
     0FF8 0400     
                   < elite.a99
3284                                                                          ; value is now up to 131 (rather than 127)
3285               
3286 0FFA 091D  14        srl  ra,1                       ; LSR A             ; Divide the (positive) pitch rate in A by 16
3287 0FFC 091D  14        srl  ra,1                       ; LSR A
3288 0FFE 091D  14        srl  ra,1                       ; LSR A
3289 1000 091D  14        srl  ra,1                       ; LSR A
3290               
3291 1002 028D  14        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, skip the following instruction
     1004 0300     
3292 1006 1801  10        joc  B04                        ; BCS B04
3293               
3294 1008 091D  14        srl  ra,1                       ; LSR A             ; A < 3, so halve A again
3295               
3296               B04:
3297 100A D80D  22        movb ra,@BET1                   ; STA BET1          ; Store A in BET1, so we now have:
     100C 002B     
3298                                                                          ;
3299                                                                          ; BET1 = |JSTY| / 32    if |JSTY| < 48
3300                                                                          ;
3301                                                                          ; BET1 = |JSTY| / 16    if |JSTY| >= 48
3302                                                                          ;
3303                                                                          ; This means that at lower pitch rates, the pitch angle
3304                                                                          ; is reduced closer to zero than at higher pitch rates,
3305                                                                          ; which gives us finer control over the ship's pitch at
3306                                                                          ; lower pitch rates
3307                                                                          ;
3308                                                                          ; Because JSTY is in the range -131 to +131, BET1 is in
3309                                                                          ; the range 0 to 8
3310               
3311 100E F360  22        socb @BET2,ra                   ; ORA BET2          ; Store A in BETA, but with the sign set to BET2 (so
     1010 008A     
3312 1012 D80D  22        movb ra,@BETA                   ; STA BETA          ; BETA has the same sign as the actual pitch rate)
     1014 002A     
3313               
3314               * ******************************************************************************
3315               *
3316               * Name: Main flight loop (Part 3 of 16)
3317               * Type: Subroutine
3318               * Category: Main loop
3319               * Summary: Scan for flight keys and process the results
3320               * Deep dive: Program flow of the main game loop
3321               * The key logger
3322               *
3323               * ------------------------------------------------------------------------------
3324               *
3325               * The main flight loop covers most of the flight-specific aspects of Elite. This
3326               * section covers the following:
3327               *
3328               * * Scan for flight keys and process the results
3329               *
3330               * Flight keys are logged in the key logger at location KY1 onwards, with a
3331               * non-zero value in the relevant location indicating a key press. See the deep
3332               * dive on "The key logger" for more details.
3333               *
3334               * The key presses that are processed are as follows:
3335               *
3336               * * Space and "?" to speed up and slow down
3337               * * "U", "T" and "M" to disarm, arm and fire missiles
3338               * * TAB to fire an energy bomb
3339               * * ESCAPE to launch an escape pod
3340               * * "J" to initiate an in-system jump
3341               * * "E" to deploy E.C.M. anti-missile countermeasures
3342               * * "C" to use the docking computer
3343               * * "A" to fire lasers
3344               *
3345               * ******************************************************************************
3346               
3347 1016 D360  22        movb @KY2,ra                    ; LDA KY2           ; If Space is being pressed, keep going, otherwise jump
     1018 0043     
3348 101A 1306  10        jeq  MA17                       ; BEQ MA17          ; down to MA17 to skip the following
3349               
3350 101C D360  22        movb @DELTA,ra                  ; LDA DELTA         ; The "go faster" key is being pressed, so first we
     101E 008C     
3351 1020 028D  14        ci   ra,>28*256                 ; CMP #40           ; fetch the current speed from DELTA into A, and if
     1022 2800     
3352 1024 1801  10        joc  MA17                       ; BCS MA17          ; A >= 40, we are already going at full pelt, so jump
3353                                                                          ; down to MA17 to skip the following
3354               
3355 1026 B347  14        ab   rone,ra                    ; INC DELTA         ; We can go a bit faster, so increment the speed in
3356                                                                          ; location DELTA
3357               
3358               MA17:
3359 1028 D360  22        movb @KY1,ra                    ; LDA KY1           ; If "?" is being pressed, keep going, otherwise jump
     102A 0042     
3360 102C 1303  10        jeq  MA4                        ; BEQ MA4           ; down to MA4 to skip the following
3361               
3362 102E 7347  14        sb   rone,ra                    ; DEC DELTA         ; The "slow down" key is being pressed, so we decrement
3363                                                                          ; the current ship speed in DELTA
3364               
3365 1030 1601  10        jne  MA4                        ; BNE MA4           ; If the speed is still greater than zero, jump to MA4
3366               
3367 1032 B347  14        ab   rone,ra                    ; INC DELTA         ; Otherwise we just braked a little too hard, so bump
3368                                                                          ; the speed back up to the minimum value of 1
3369               
3370               MA4:
3371 1034 D360  22        movb @KY15,ra                   ; LDA KY15          ; If "U" is being pressed and the number of missiles
     1036 004C     
3372                      .and @NOMSL                     ; AND NOMSL         ; in NOMSL is non-zero, keep going, otherwise jump down
     **** ****     > AND
0001 1038 D020  22        movb @NOMSL,rtmp
     103A 0333     
0002 103C 0540  10        inv  rtmp
0003 103E 5340  14        szcb rtmp,ra
                   < elite.a99
3373 1040 1310  10        jeq  MA20                       ; BEQ MA20          ; to MA20 to skip the following
3374               
3375 1042 020F  12        li   ry,>ee*256                 ; LDY #&EE          ; The "disarm missiles" key is being pressed, so call
     1044 EE00     
3376 1046 0200  12        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     1048 B0A2     
3377 104A 06A0  24        bl   @jsr                       ;
     104C FE1E     
3378                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
3379               
3380 104E 020D  12        li   ra,>28*256                 ; LDA #40           ; Call the NOISE routine with A = 40 to make a low,
     1050 2800     
3381 1052 0200  12        li   rtmp,NOISE                 ; JSR NOISE         ; long beep to indicate the missile is now disarmed
     1054 CBB0     
3382 1056 06A0  24        bl   @jsr                       ;
     1058 FE1E     
3383               
3384               MA31:
3385 105A 020D  12        li   ra,>00*256                 ; LDA #0            ; Set MSAR to 0 to indicate that no missiles are
     105C 0000     
3386 105E D80D  22        movb ra,@MSAR                   ; STA MSAR          ; currently armed
     1060 0D5E     
3387               
3388               MA20:
3389 1062 D360  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG is positive (i.e. it does not have bit 7 set),
     1064 0052     
3390 1066 150E  10        jgt  MA25                       ; BPL MA25          ; then it indicates we already have a missile locked on
3391                                                                          ; a target (in which case MSTG contains the ship number
3392                                                                          ; of the target), so jump to MA25 to skip targeting. Or
3393                                                                          ; to put it another way, if MSTG = &FF, which means
3394                                                                          ; there is no current target lock, keep going
3395               
3396 1068 D360  22        movb @KY14,ra                   ; LDA KY14          ; If "T" is being pressed, keep going, otherwise jump
     106A 004B     
3397 106C 130B  10        jeq  MA25                       ; BEQ MA25          ; down to MA25 to skip the following
3398               
3399 106E D3A0  22        movb @NOMSL,rx                  ; LDX NOMSL         ; If the number of missiles in NOMSL is zero, jump down
     1070 0333     
3400 1072 1308  10        jeq  MA25                       ; BEQ MA25          ; to MA25 to skip the following
3401               
3402 1074 D80D  22        movb ra,@MSAR                   ; STA MSAR          ; The "target missile" key is being pressed and we have
     1076 0D5E     
3403                                                                          ; at least one missile, so set MSAR = &FF to denote that
3404                                                                          ; our missile is currently armed (we know A has the
3405                                                                          ; value &FF, as we just loaded it from MSTG and checked
3406                                                                          ; that it was negative)
3407               
3408 1078 020F  12        li   ry,>e0*256                 ; LDY #&E0          ; Change the leftmost missile indicator to yellow/white
     107A E000     
3409 107C 0200  12        li   rtmp,MSBAR                 ; JSR MSBAR         ; on the missile bar (this call changes the leftmost
     107E B10E     
3410 1080 06A0  24        bl   @jsr                       ;
     1082 FE1E     
3411                                                                          ; indicator because we set X to the number of missiles
3412                                                                          ; in NOMSL above, and the indicators are numbered from
3413                                                                          ; right to left, so X is the number of the leftmost
3414                                                                          ; indicator)
3415               
3416               MA25:
3417 1084 D360  22        movb @KY16,ra                   ; LDA KY16          ; If "M" is being pressed, keep going, otherwise jump
     1086 004D     
3418 1088 1307  10        jeq  MA24                       ; BEQ MA24          ; down to MA24 to skip the following
3419               
3420 108A D360  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG = &FF then there is no target lock, so jump to
     108C 0052     
3421 108E 112D  10        jlt  MA64                       ; BMI MA64          ; MA64 to skip the following (also skipping the checks
3422                                                                          ; for TAB, ESCAPE, "J" and "E")
3423               
3424 1090 0200  12        li   rtmp,FRMIS                 ; JSR FRMIS         ; The "fire missile" key is being pressed and we have
     1092 3C2A     
3425 1094 06A0  24        bl   @jsr                       ;
     1096 FE1E     
3426                                                                          ; a missile lock, so call the FRMIS routine to fire
3427                                                                          ; the missile
3428               
3429               MA24:
3430 1098 D360  22        movb @KY12,ra                   ; LDA KY12          ; If TAB is being pressed, keep going, otherwise jump
     109A 0049     
3431 109C 1307  10        jeq  MA76                       ; BEQ MA76          ; down to MA76 to skip the following
3432               
3433                      .asl @BOMB                      ; ASL BOMB          ; The "energy bomb" key is being pressed, so double
     **** ****     > ASL
0001 109E D020  22        movb @BOMB,rtmp
     10A0 032A     
0002 10A2 0240  14        andi rtmp,>ff00
     10A4 FF00     
0003 10A6 0A10  14        sla  rtmp,1
0004 10A8 D800  22        movb rtmp,@BOMB
     10AA 032A     
                   < elite.a99
3434                                                                          ; the value in BOMB. If we have an energy bomb fitted,
3435                                                                          ; BOMB will contain &7F (%01111111) before this shift
3436                                                                          ; and will contain &FE (%11111110) after the shift; if
3437                                                                          ; we don't have an energy bomb fitted, BOMB will still
3438                                                                          ; contain 0. The bomb explosion is dealt with in the
3439                                                                          ; MAL1 routine below - this just registers the fact that
3440                                                                          ; we've set the bomb ticking
3441               
3442               MA76:
3443 10AC D360  22        movb @KY13,ra                   ; LDA KY13          ; If ESCAPE is being pressed and we have an escape pod
     10AE 004A     
3444                      .and @ESCP                      ; AND ESCP          ; fitted, keep going, otherwise skip the next
     **** ****     > AND
0001 10B0 D020  22        movb @ESCP,rtmp
     10B2 032E     
0002 10B4 0540  10        inv  rtmp
0003 10B6 5340  14        szcb rtmp,ra
                   < elite.a99
3445 10B8 1302  10        jeq  B05                        ; BEQ B05           ; instruction
3446               
3447 10BA 0460  20        b    @ESCAPE                    ; JMP ESCAPE        ; The button is being pressed to launch an escape pod
     10BC 3646     
3448                                                                          ; and we have an escape pod fitted, so jump to ESCAPE to
3449                                                                          ; launch it, and exit the main flight loop using a tail
3450                                                                          ; call
3451               
3452               B05:
3453 10BE D360  22        movb @KY18,ra                   ; LDA KY18          ; If "J" is being pressed, keep going, otherwise skip
     10C0 004F     
3454 10C2 1304  10        jeq  B06                        ; BEQ B06           ; the next instruction
3455               
3456 10C4 0200  12        li   rtmp,WARP                  ; JSR WARP          ; Call the WARP routine to do an in-system jump
     10C6 4838     
3457 10C8 06A0  24        bl   @jsr                       ;
     10CA FE1E     
3458               
3459               B06:
3460 10CC D360  22        movb @KY17,ra                   ; LDA KY17          ; If "E" is being pressed and we have an E.C.M. fitted,
     10CE 004E     
3461                      .and @ECM                       ; AND ECM           ; keep going, otherwise jump down to MA64 to skip the
     **** ****     > AND
0001 10D0 D020  22        movb @ECM,rtmp
     10D2 0328     
0002 10D4 0540  10        inv  rtmp
0003 10D6 5340  14        szcb rtmp,ra
                   < elite.a99
3462 10D8 1308  10        jeq  MA64                       ; BEQ MA64          ; following
3463               
3464 10DA D360  22        movb @ECMA,ra                   ; LDA ECMA          ; If ECMA is non-zero, that means an E.C.M. is already
     10DC 0030     
3465 10DE 1605  10        jne  MA64                       ; BNE MA64          ; operating and is counting down (this can be either
3466                                                                          ; our E.C.M. or an opponent's), so jump down to MA64 to
3467                                                                          ; skip the following (as we can't have two E.C.M.
3468                                                                          ; systems operating at the same time)
3469               
3470 10E0 7347  14        sb   rone,ra                    ; DEC ECMP          ; The E.C.M. button is being pressed and nobody else
3471                                                                          ; is operating their E.C.M., so decrease the value of
3472                                                                          ; ECMP to make it non-zero, to denote that our E.C.M.
3473                                                                          ; is now on
3474               
3475 10E2 0200  12        li   rtmp,ECBLB2                ; JSR ECBLB2        ; Call ECBLB2 to light up the E.C.M. indicator bulb on
     10E4 B0BE     
3476 10E6 06A0  24        bl   @jsr                       ;
     10E8 FE1E     
3477                                                                          ; the dashboard, set the E.C.M. countdown timer to 32,
3478                                                                          ; and start making the E.C.M. sound
3479               
3480               MA64:
3481 10EA D360  22        movb @KY19,ra                   ; LDA KY19          ; If "C" is being pressed, and we have a docking
     10EC 0050     
3482                      .and @DKCMP                     ; AND DKCMP         ; computer fitted, and we are inside the space station's
     **** ****     > AND
0001 10EE D020  22        movb @DKCMP,rtmp
     10F0 032C     
0002 10F2 0540  10        inv  rtmp
0003 10F4 5340  14        szcb rtmp,ra
                   < elite.a99
3483                      .and @SSPR                      ; AND SSPR          ; safe zone, keep going, otherwise jump down to MA68 to
     **** ****     > AND
0001 10F6 D020  22        movb @SSPR,rtmp
     10F8 0D55     
0002 10FA 0540  10        inv  rtmp
0003 10FC 5340  14        szcb rtmp,ra
                   < elite.a99
3484 10FE 1305  10        jeq  MA68                       ; BEQ MA68          ; skip the following
3485               
3486 1100 D360  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     1102 0944     
3487 1104 1102  10        jlt  MA68                       ; BMI MA68          ; from the ship data workspace at K%, which is reserved
3488                                                                          ; for the sun or the space station (in this case it's
3489                                                                          ; the latter as we are in the safe zone). If byte #32 is
3490                                                                          ; negative, meaning the station is hostile, then jump
3491                                                                          ; down to MA68 to skip the following (so we can't use
3492                                                                          ; the docking computer to dock at a station that has
3493                                                                          ; turned against us)
3494               
3495 1106 0460  16        b    @GOIN                      ; JMP GOIN          ; The Docking Computer button has been pressed and
     1108 130A     
3496                                                                          ; we are allowed to dock at the station, so jump to
3497                                                                          ; GOIN to dock (or "go in"), and exit the main flight
3498                                                                          ; loop using a tail call
3499               
3500               MA68:
3501 110A 020D  12        li   ra,>00*256                 ; LDA #0            ; Set LAS = 0, to switch the laser off while we do the
     110C 0000     
3502 110E D80D  22        movb ra,@LAS                    ; STA LAS           ; following logic
     1110 0051     
3503               
3504 1112 D80D  22        movb ra,@DELT4                  ; STA DELT4         ; Take the 16-bit value (DELTA 0) - i.e. a two-byte
     1114 008D     
3505 1116 D360  22        movb @DELTA,ra                  ; LDA DELTA         ; number with DELTA as the high byte and 0 as the low
     1118 008C     
3506 111A 091D  14        srl  ra,1                       ; LSR A             ; byte - and divide it by 4, storing the 16-bit result
3507 111C 0204  12        li   rarg1,DELT4                ; ROR DELT4         ; in DELT4(1 0). This has the effect of storing the
     111E 008D     
3508 1120 06A0  24        bl   @ror                       ;
     1122 FE70     
3509 1124 091D  14        srl  ra,1                       ; LSR A             ; current speed * 64 in the 16-bit location DELT4(1 0)
3510 1126 0204  12        li   rarg1,DELT4                ; ROR DELT4
     1128 008D     
3511 112A 06A0  24        bl   @ror                       ;
     112C FE70     
3512 112E D80D  22        movb ra,@DELT4+1                ; STA DELT4+1
     1130 008E     
3513               
3514 1132 D360  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT is zero, keep going, otherwise the laser is
     1134 0D60     
3515 1136 1628  10        jne  MA3                        ; BNE MA3           ; a pulse laser that is between pulses, so jump down to
3516                                                                          ; MA3 to skip the following
3517               
3518 1138 D360  22        movb @KY7,ra                    ; LDA KY7           ; If "A" is being pressed, keep going, otherwise jump
     113A 0048     
3519 113C 1325  10        jeq  MA3                        ; BEQ MA3           ; down to MA3 to skip the following
3520               
3521 113E D360  22        movb @GNTMP,ra                  ; LDA GNTMP         ; If the laser temperature >= 242 then the laser has
     1140 0D61     
3522 1142 028D  14        ci   ra,>f2*256                 ; CMP #242          ; overheated, so jump down to MA3 to skip the following
     1144 F200     
3523 1146 1820  10        joc  MA3                        ; BCS MA3
3524               
3525 1148 D3A0  22        movb @VIEW,rx                   ; LDX VIEW          ; If the current space view has a laser fitted (i.e. the
     114A 0D5F     
3526 114C D36E  26        movb @LASER(rx),ra              ; LDA LASER,X       ; laser power for this view is greater than zero), then
     114E 0310     
3527 1150 131B  10        jeq  MA3                        ; BEQ MA3           ; keep going, otherwise jump down to MA3 to skip the
3528                                                                          ; following
3529               
3530                                                                          ; If we get here, then the "fire" button is being
3531                                                                          ; pressed, our laser hasn't overheated and isn't already
3532                                                                          ; being fired, and we actually have a laser fitted to
3533                                                                          ; the current space view, so it's time to hit me with
3534                                                                          ; those laser beams
3535               
3536                      .pha                            ; PHA               ; Store the current view's laser power on the stack
     **** ****     > PHA
0001 1152 D68D  26        movb ra,*rsp
0002 1154 060A  10        dec  rsp
                   < elite.a99
3537               
3538 1156 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Set LAS and LAS2 to bits 0-6 of the laser power
     1158 7F00     
3539 115A D80D  22        movb ra,@LAS                    ; STA LAS
     115C 0051     
3540 115E D80D  22        movb ra,@LAS2                   ; STA LAS2
     1160 0D5D     
3541               
3542 1162 020D  12        li   ra,>00*256                 ; LDA #0            ; Call the NOISE routine with A = 0 to make the sound
     1164 0000     
3543 1166 0200  12        li   rtmp,NOISE                 ; JSR NOISE         ; of our laser firing
     1168 CBB0     
3544 116A 06A0  24        bl   @jsr                       ;
     116C FE1E     
3545               
3546 116E 0200  12        li   rtmp,LASLI                 ; JSR LASLI         ; Call LASLI to draw the laser lines
     1170 48DA     
3547 1172 06A0  24        bl   @jsr                       ;
     1174 FE1E     
3548               
3549                      .pla                            ; PLA               ; Restore the current view's laser power into A
     **** ****     > PLA
0001 1176 058A  10        inc  rsp
0002 1178 D35A  22        movb *rsp,ra
                   < elite.a99
3550               
3551 117A 1502  10        jgt  ma1_                       ; BPL ma1           ; If the laser power has bit 7 set, then it's an "always
3552                                                                          ; on" laser rather than a pulsing laser, so keep going,
3553                                                                          ; otherwise jump down to ma1 to skip the following
3554                                                                          ; instruction
3555               
3556 117C 020D  12        li   ra,>00*256                 ; LDA #0            ; This is an "always on" laser (i.e. a beam laser,
     117E 0000     
3557                                                                          ; as this version of Elite doesn't have military
3558                                                                          ; lasers), so set A = 0, which will be stored in LASCT
3559                                                                          ; to denote that this is not a pulsing laser
3560               
3561               ma1_:
3562 1180 024D  14        andi ra,>fa*256                 ; AND #%11111010    ; LASCT will be set to 0 for beam lasers, and to the
     1182 FA00     
3563 1184 D80D  22        movb ra,@LASCT                  ; STA LASCT         ; laser power AND %11111010 for pulse lasers, which
     1186 0D60     
3564                                                                          ; comes to 10 (as pulse lasers have a power of 15). See
3565                                                                          ; MA23 below for more on laser pulsing and LASCT
3566               
3567               * ******************************************************************************
3568               *
3569               * Name: Main flight loop (Part 4 of 16)
3570               * Type: Subroutine
3571               * Category: Main loop
3572               * Summary: For each nearby ship: Copy the ship's data block from K% to the
3573               * zero-page workspace at INWK
3574               * Deep dive: Program flow of the main game loop
3575               * Ship data blocks
3576               *
3577               * ------------------------------------------------------------------------------
3578               *
3579               * The main flight loop covers most of the flight-specific aspects of Elite. This
3580               * section covers the following:
3581               *
3582               * * Start looping through all the ships in the local bubble, and for each
3583               * one:
3584               *
3585               * * Copy the ship's data block from K% to INWK
3586               *
3587               * * Set XX0 to point to the ship's blueprint (if this is a ship)
3588               *
3589               * ------------------------------------------------------------------------------
3590               *
3591               * Other entry points:
3592               *
3593               * MAL1                Marks the beginning of the ship analysis loop, so we
3594               * can jump back here from part 12 of the main flight loop
3595               * to work our way through each ship in the local bubble.
3596               * We also jump back here when a ship is removed from the
3597               * bubble, so we can continue processing from the next ship
3598               *
3599               * ******************************************************************************
3600               
3601               MA3:
3602 1188 020E  12        li   rx,>00*256                 ; LDX #0            ; We're about to work our way through all the ships in
     118A 0000     
3603                                                                          ; our local bubble of universe, so set a counter in X,
3604                                                                          ; starting from 0, to refer to each ship slot in turn
3605               
3606               MAL1:
3607 118C D80E  22        movb rx,@XSAV                   ; STX XSAV          ; Store the current slot number in XSAV
     118E 0093     
3608               
3609 1190 D36E  26        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the contents of this slot into A. If it is 0
     1192 0D40     
3610 1194 1602  10        jne  B07                        ; BNE B07           ; then this slot is empty and we have no more ships to
3611 1196 0460  16        b    @MA18                      ; JMP MA18          ; process, so jump to MA18 below, otherwise A contains
     1198 1516     
3612                                                                          ; the type of ship that's in this slot, so skip over the
3613                                                                          ; JMP MA18 instruction and keep going
3614               
3615               B07:
3616 119A D80D  22        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     119C 009B     
3617               
3618 119E 0200  12        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to fetch the address of the ship data block
     11A0 AF0C     
3619 11A2 06A0  24        bl   @jsr                       ;
     11A4 FE1E     
3620                                                                          ; for the ship in slot X and store it in INF. The data
3621                                                                          ; block is in the K% workspace, which is where all the
3622                                                                          ; ship data blocks are stored
3623               
3624                                                                          ; Next we want to copy the ship data block from INF to
3625                                                                          ; the zero-page workspace at INWK, so we can process it
3626                                                                          ; more efficiently
3627               
3628 11A6 020F  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in each ship data block (and in
     11A8 2300     
3629                                                                          ; the INWK workspace, so we set a counter in Y so we can
3630                                                                          ; loop through them
3631               
3632               MAL2:
3633                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Load the Y-th byte of INF and store it in the Y-th
     **** ****     > LD_IND_Y_IDX
0001 11AA D820  38        movb @INF,@rtmplb
     11AC 0020     
     11AE 206D     
0002 11B0 D020  22        movb @INF+1,rtmp
     11B2 0021     
0003 11B4 A00F  14        a    ry,rtmp
0004 11B6 D350  22        movb *rtmp,RA
                   < elite.a99
3634 11B8 DBCD  30        movb ra,@INWK(ry)               ; STA INWK,Y        ; byte of INWK
     11BA 0053     
3635               
3636 11BC 73C7  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3637               
3638 11BE 15F5  10        jgt  MAL2                       ; BPL MAL2          ; Loop back for the next byte until we have copied the
3639                                                                          ; last byte from INF to INWK
3640               
3641 11C0 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     11C2 009B     
3642 11C4 1121  10        jlt  MA21                       ; BMI MA21          ; planet or sun, so jump down to MA21, as the next bit
3643                                                                          ; sets up a pointer to the ship blueprint, and then
3644                                                                          ; checks for energy bomb damage, and neither of these
3645                                                                          ; apply to planets and suns
3646               
3647                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 11C6 024D  14        andi ra,>ff00
     11C8 FF00     
0002 11CA 0A1D  14        sla  ra,1
                   < elite.a99
3648 11CC D3CD  14        movb ra,ry                      ; TAY
3649               
3650 11CE D36F  26        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     11D0 E7E0     
3651 11D2 D80D  22        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     11D4 001E     
3652                                                                          ; so this fetches the low byte of this particular ship
3653                                                                          ; type's blueprint and stores it in XX0
3654               
3655 11D6 D36F  26        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     11D8 E7E1     
3656 11DA D80D  22        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1
     11DC 001F     
3657               
3658               * ******************************************************************************
3659               *
3660               * Name: Main flight loop (Part 5 of 16)
3661               * Type: Subroutine
3662               * Category: Main loop
3663               * Summary: For each nearby ship: If an energy bomb has been set off,
3664               * potentially kill this ship
3665               * Deep dive: Program flow of the main game loop
3666               *
3667               * ------------------------------------------------------------------------------
3668               *
3669               * The main flight loop covers most of the flight-specific aspects of Elite. This
3670               * section covers the following:
3671               *
3672               * * Continue looping through all the ships in the local bubble, and for each
3673               * one:
3674               *
3675               * * If an energy bomb has been set off and this ship can be killed, kill it
3676               * and increase the kill tally
3677               *
3678               * ******************************************************************************
3679               
3680 11DE D360  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     11E0 032A     
3681 11E2 1512  10        jgt  MA21                       ; BPL MA21          ; BOMB is now negative, so this skips to MA21 if our
3682                                                                          ; energy bomb is not going off
3683               
3684 11E4 028F  14        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship in Y is the space station, jump to BA21
     11E6 1000     
3685 11E8 130F  10        jeq  MA21                       ; BEQ MA21          ; as energy bombs are useless against space stations
3686               
3687 11EA D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; If the ship we are checking has bit 5 set in its ship
     11EC 0072     
3688 11EE 024D  14        andi ra,>20*256                 ; AND #%00100000    ; byte #31, then it is already exploding, so jump to
     11F0 2000     
3689 11F2 160A  10        jne  MA21                       ; BNE MA21          ; BA21 as ships can't explode more than once
3690               
3691 11F4 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; The energy bomb is killing this ship, so set bit 7 of
     11F6 0072     
3692 11F8 026D  14        ori  ra,>80*256                 ; ORA #%10000000    ; the ship byte #31 to indicate that it has now been
     11FA 8000     
3693 11FC D80D  22        movb ra,@INWK+31                ; STA INWK+31       ; killed
     11FE 0072     
3694               
3695 1200 0200  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     1202 CB60     
3696 1204 06A0  24        bl   @jsr                       ;
     1206 FE1E     
3697                                                                          ; ship (so increase the kill tally, make an explosion
3698                                                                          ; sound and possibly display "RIGHT ON COMMANDER!")
3699               
3700               * ******************************************************************************
3701               *
3702               * Name: Main flight loop (Part 6 of 16)
3703               * Type: Subroutine
3704               * Category: Main loop
3705               * Summary: For each nearby ship: Move the ship in space and copy the updated
3706               * INWK data block back to K%
3707               * Deep dive: Program flow of the main game loop
3708               * Program flow of the ship-moving routine
3709               * Ship data blocks
3710               *
3711               * ------------------------------------------------------------------------------
3712               *
3713               * The main flight loop covers most of the flight-specific aspects of Elite. This
3714               * section covers the following:
3715               *
3716               * * Continue looping through all the ships in the local bubble, and for each
3717               * one:
3718               *
3719               * * Move the ship in space
3720               *
3721               * * Copy the updated ship's data block from INWK back to K%
3722               *
3723               * ******************************************************************************
3724               
3725               MA21:
3726 1208 0200  12        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the ship we are processing in space
     120A 17E2     
3727 120C 06A0  24        bl   @jsr                       ;
     120E FE1E     
3728               
3729                                                                          ; Now that we are done processing this ship, we need to
3730                                                                          ; copy the ship data back from INWK to the correct place
3731                                                                          ; in the K% workspace. We already set INF in part 4 to
3732                                                                          ; point to the ship's data block in K%, so we can simply
3733                                                                          ; do the reverse of the copy we did before, this time
3734                                                                          ; copying from INWK to INF
3735               
3736 1210 020F  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Set a counter in Y so we can loop through the NI%
     1212 2300     
3737                                                                          ; bytes in the ship data block
3738               
3739               MAL3:
3740 1214 D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store it in the Y-th
     1216 0053     
3741                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; byte of INF
     **** ****     > ST_IND_Y_IDX
0001 1218 D820  38        movb @INF,@rtmplb
     121A 0020     
     121C 206D     
0002 121E D020  22        movb @INF+1,rtmp
     1220 0021     
0003 1222 A00F  14        a    ry,rtmp
0004 1224 D40D  26        movb RA,*rtmp
                   < elite.a99
3742               
3743 1226 73C7  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3744               
3745 1228 15F5  10        jgt  MAL3                       ; BPL MAL3          ; Loop back for the next byte, until we have copied the
3746                                                                          ; last byte from INWK back to INF
3747               
3748               * ******************************************************************************
3749               *
3750               * Name: Main flight loop (Part 7 of 16)
3751               * Type: Subroutine
3752               * Category: Main loop
3753               * Summary: For each nearby ship: Check whether we are docking, scooping or
3754               * colliding with it
3755               * Deep dive: Program flow of the main game loop
3756               *
3757               * ------------------------------------------------------------------------------
3758               *
3759               * The main flight loop covers most of the flight-specific aspects of Elite. This
3760               * section covers the following:
3761               *
3762               * * Continue looping through all the ships in the local bubble, and for each
3763               * one:
3764               *
3765               * * Check how close we are to this ship and work out if we are docking,
3766               * scooping or colliding with it
3767               *
3768               * ******************************************************************************
3769               
3770 122A D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the status of this ship from bits 5 (is ship
     122C 0072     
3771 122E 024D  14        andi ra,>a0*256                 ; AND #%10100000    ; exploding?) and bit 7 (has ship been killed?) from
     1230 A000     
3772                                                                          ; ship byte #31 into A
3773               
3774 1232 0200  12        li   rtmp,MAS4                  ; JSR MAS4          ; Or this value with x_hi, y_hi and z_hi
     1234 C46E     
3775 1236 06A0  24        bl   @jsr                       ;
     1238 FE1E     
3776               
3777 123A 164C  10        jne  MA65                       ; BNE MA65          ; If this value is non-zero, then either the ship is
3778                                                                          ; far away (i.e. has a non-zero high byte in at least
3779                                                                          ; one of the three axes), or it is already exploding,
3780                                                                          ; or has been flagged as being killed - in which case
3781                                                                          ; jump to MA65 to skip the following, as we can't dock
3782                                                                          ; scoop or collide with it
3783               
3784 123C D360  22        movb @INWK,ra                   ; LDA INWK          ; Set A = (x_lo OR y_lo OR z_lo), and if bit 7 of the
     123E 0053     
3785 1240 F360  22        socb @INWK+3,ra                 ; ORA INWK+3        ; result is set, the ship is still a fair distance
     1242 0056     
3786 1244 F360  22        socb @INWK+6,ra                 ; ORA INWK+6        ; away (further than 127 in at least one axis), so jump
     1246 0059     
3787 1248 1145  10        jlt  MA65                       ; BMI MA65          ; to MA65 to skip the following, as it's too far away to
3788                                                                          ; dock, scoop or collide with
3789               
3790 124A D3A0  22        movb @TYPE,rx                   ; LDX TYPE          ; If the current ship type is negative then it's either
     124C 009B     
3791 124E 1142  10        jlt  MA65                       ; BMI MA65          ; a planet or a sun, so jump down to MA65 to skip the
3792                                                                          ; following, as we can't dock with it or scoop it
3793               
3794 1250 028E  14        ci   rx,(SST)*256               ; CPX #SST          ; If this ship is the space station, jump to ISDK to
     1252 0800     
3795 1254 1341  10        jeq  ISDK                       ; BEQ ISDK          ; check whether we are docking with it
3796               
3797 1256 024D  14        andi ra,>c0*256                 ; AND #%11000000    ; If bit 6 of (x_lo OR y_lo OR z_lo) is set, then the
     1258 C000     
3798 125A 163C  10        jne  MA65                       ; BNE MA65          ; ship is still a reasonable distance away (further than
3799                                                                          ; 63 in at least one axis), so jump to MA65 to skip the
3800                                                                          ; following, as it's too far away to dock, scoop or
3801                                                                          ; collide with
3802               
3803 125C 028E  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If this ship is a missile, jump down to MA65 to skip
     125E 0900     
3804 1260 1339  10        jeq  MA65                       ; BEQ MA65          ; the following, as we can't scoop or dock with a
3805                                                                          ; missile, and it has its own dedicated collision
3806                                                                          ; checks in the TACTICS routine
3807               
3808 1262 028E  14        ci   rx,(OIL)*256               ; CPX #OIL          ; If ship type >= OIL (i.e. it's a cargo canister,
     1264 0B00     
3809 1266 1802  10        joc  B08                        ; BCS B08           ; Thargon or escape pod), skip the JMP instruction and
3810 1268 0460  16        b    @MA58                      ; JMP MA58          ; continue on, otherwise jump to MA58 to process a
     126A 1368     
3811                                                                          ; potential collision
3812               
3813               B08:
3814 126C D360  22        movb @BST,ra                    ; LDA BST           ; If we have fuel scoops fitted then BST will be &FF,
     126E 0329     
3815                                                                          ; otherwise it will be 0
3816               
3817                      .and @INWK+5                    ; AND INWK+5        ; Ship byte #5 contains the y_sign of this ship, so a
     **** ****     > AND
0001 1270 D020  22        movb @INWK+5,rtmp
     1272 0058     
0002 1274 0540  10        inv  rtmp
0003 1276 5340  14        szcb rtmp,ra
                   < elite.a99
3818                                                                          ; negative value here means the canister is below us,
3819                                                                          ; which means the result of the AND will be negative if
3820                                                                          ; the canister is below us and we have a fuel scoop
3821                                                                          ; fitted
3822               
3823 1278 1577  10        jgt  MA58                       ; BPL MA58          ; If the result is positive, then we either have no
3824                                                                          ; scoop or the canister is above us, and in both cases
3825                                                                          ; this means we can't scoop the item, so jump to MA58
3826                                                                          ; to process a collision
3827               
3828               * ******************************************************************************
3829               *
3830               * Name: Main flight loop (Part 8 of 16)
3831               * Type: Subroutine
3832               * Category: Main loop
3833               * Summary: For each nearby ship: Process us potentially scooping this item
3834               * Deep dive: Program flow of the main game loop
3835               *
3836               * ------------------------------------------------------------------------------
3837               *
3838               * The main flight loop covers most of the flight-specific aspects of Elite. This
3839               * section covers the following:
3840               *
3841               * * Continue looping through all the ships in the local bubble, and for each
3842               * one:
3843               *
3844               * * Process us potentially scooping this item
3845               *
3846               * ******************************************************************************
3847               
3848 127A 020D  12        li   ra,>03*256                 ; LDA #3            ; Set A to 3 to denote we may be scooping an escape pod
     127C 0300     
3849               
3850 127E 028E  14        ci   rx,(TGL)*256               ; CPX #TGL          ; If ship type < Thargon, i.e. it's a canister, jump
     1280 0C00     
3851 1282 1704  10        jnc  oily_                      ; BCC oily          ; to oily to randomly decide the canister's contents
3852               
3853 1284 1609  10        jne  slvy2_                     ; BNE slvy2         ; If ship type <> Thargon, i.e. it's an escape pod,
3854                                                                          ; jump to slvy2 with A set to 3, so we scoop up the
3855                                                                          ; escape pod as slaves
3856               
3857 1286 020D  12        li   ra,>10*256                 ; LDA #16           ; Otherwise this is a Thargon, so jump to slvy2 with
     1288 1000     
3858 128A 1606  10        jne  slvy2_                     ; BNE slvy2         ; A set to 16, so we scoop up the Thargon as alien items
3859                                                                          ; (this BNE is effectively a JMP as A will never be
3860                                                                          ; zero)
3861               
3862               oily_:
3863 128C 0200  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers and reduce A to a
     128E C07C     
3864 1290 06A0  24        bl   @jsr                       ;
     1292 FE1E     
3865 1294 024D  14        andi ra,>07*256                 ; AND #7            ; random number in the range 0-7
     1296 0700     
3866               
3867               slvy2_:
3868                                                                          ; By the time we get here, we are scooping, and A
3869                                                                          ; contains the type of item we are scooping (a random
3870                                                                          ; number 0-7 if we are scooping a cargo canister, 3 if
3871                                                                          ; we are scooping an escape pod, or 16 if we are
3872                                                                          ; scooping a Thargon). These numbers correspond to the
3873                                                                          ; relevant market items (see QQ23 for a list), so a
3874                                                                          ; cargo canister can contain anything from food to
3875                                                                          ; computers, while escape pods contain slaves, and
3876                                                                          ; Thargons become alien items when scooped
3877 1298 D80D  22        movb ra,@QQ29                   ; STA QQ29          ; Call tnpr with the scooped cargo type stored in QQ29
     129A 0F1B     
3878 129C 020D  12        li   ra,>01*256                 ; LDA #1            ; and A set to 1, to work out whether we have room in
     129E 0100     
3879 12A0 0200  12        li   rtmp,tnpr_                 ; JSR tnpr          ; the hold for the scooped item (A is preserved by this
     12A2 4DF4     
3880 12A4 06A0  24        bl   @jsr                       ;
     12A6 FE1E     
3881                                                                          ; call, and the C flag contains the result)
3882               
3883 12A8 020F  12        li   ry,>4e*256                 ; LDY #78           ; This instruction has no effect, so presumably it used
     12AA 4E00     
3884                                                                          ; to do something, but didn't get removed
3885               
3886 12AC 1845  10        joc  MA59                       ; BCS MA59          ; If the C flag is set then we have no room in the hold
3887                                                                          ; for the scooped item, so jump down to MA59 make a
3888                                                                          ; sound to indicate failure, before destroying the
3889                                                                          ; canister
3890               
3891 12AE D3E0  22        movb @QQ29,ry                   ; LDY QQ29          ; Scooping was successful, so set Y to the type of
     12B0 0F1B     
3892                                                                          ; item we just scooped, which we stored in QQ29 above
3893               
3894                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Add A (which we set to 1 above) to the number of items
     **** ****     > ADC
0001 12B2 1701  10        jnc  !
0002 12B4 B347  14        ab   rone,ra
0003               !:
0004 12B6 B36F  26        ab   @QQ20(RY),ra
     12B8 0317     
                   < elite.a99
3895 12BA DBCD  30        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; of type Y in the cargo hold, as we just successfully
     12BC 0317     
3896                                                                          ; scooped one canister of type Y
3897               
3898 12BE D34F  14        movb ry,ra                      ; TYA               ; Print recursive token 48 + Y as an in-flight token,
3899                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 12C0 1701  10        jnc  !
0002 12C2 B347  14        ab   rone,ra
0003               !:
0004 12C4 022D  14        ai   ra,(>D0*256)
     12C6 D000     
                   < elite.a99
3900 12C8 0200  12        li   rtmp,MESS                  ; JSR MESS          ; ITEMS"), so this prints the scooped item's name
     12CA CE5E     
3901 12CC 06A0  24        bl   @jsr                       ;
     12CE FE1E     
3902               
3903 12D0 0460  16        b    @MA60                      ; JMP MA60          ; We are done scooping, so jump down to MA60 to set the
     12D2 1340     
3904                                                                          ; kill flag on the canister, as it no longer exists in
3905                                                                          ; the local bubble
3906               
3907               MA65:
3908 12D4 0460  16        b    @MA26                      ; JMP MA26          ; If we get here, then the ship we are processing was
     12D6 139A     
3909                                                                          ; too far away to be scooped, docked or collided with,
3910                                                                          ; so jump to MA26 to skip over the collision routines
3911                                                                          ; and move on to missile targeting
3912               
3913               * ******************************************************************************
3914               *
3915               * Name: Main flight loop (Part 9 of 16)
3916               * Type: Subroutine
3917               * Category: Main loop
3918               * Summary: For each nearby ship: If it is a space station, check whether we
3919               * are successfully docking with it
3920               * Deep dive: Program flow of the main game loop
3921               * Docking checks
3922               *
3923               * ------------------------------------------------------------------------------
3924               *
3925               * The main flight loop covers most of the flight-specific aspects of Elite. This
3926               * section covers the following:
3927               *
3928               * * Process docking with a space station
3929               *
3930               * For details on the various docking checks in this routine, see the deep dive
3931               * on "Docking checks".
3932               *
3933               * ------------------------------------------------------------------------------
3934               *
3935               * Other entry points:
3936               *
3937               * GOIN                We jump here from part 3 of the main flight loop if the
3938               * docking computer is activated by pressing "C"
3939               *
3940               * ******************************************************************************
3941               
3942               ISDK:
3943 12D8 D360  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; 1. Fetch the AI counter (byte #32) of the second ship
     12DA 0944     
3944 12DC 1126  10        jlt  MA62                       ; BMI MA62          ; in the ship data workspace at K%, which is reserved
3945                                                                          ; for the sun or the space station (in this case it's
3946                                                                          ; the latter), and if it's negative, i.e. bit 7 is set,
3947                                                                          ; meaning the station is hostile, jump down to MA62 to
3948                                                                          ; fail docking (so trying to dock at a station that we
3949                                                                          ; have annoyed does not end well)
3950               
3951 12DE D360  22        movb @INWK+14,ra                ; LDA INWK+14       ; 2. If nosev_z_hi < 214, jump down to MA62 to fail
     12E0 0061     
3952 12E2 028D  14        ci   ra,>d6*256                 ; CMP #214          ; docking, as the angle of approach is greater than 26
     12E4 D600     
3953 12E6 1721  10        jnc  MA62                       ; BCC MA62          ; degrees
3954               
3955 12E8 0200  12        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to get the vector to the space station
     12EA AD58     
3956 12EC 06A0  24        bl   @jsr                       ;
     12EE FE1E     
3957                                                                          ; into XX15
3958               
3959 12F0 D360  22        movb @XX15+2,ra                 ; LDA XX15+2        ; 3. Check the sign of the z-axis (bit 7 of XX15+2) and
     12F2 0033     
3960 12F4 111A  10        jlt  MA62                       ; BMI MA62          ; if it is negative, we are facing away from the
3961                                                                          ; station, so jump to MA62 to fail docking
3962               
3963 12F6 028D  14        ci   ra,>59*256                 ; CMP #89           ; 4. If z-axis < 89, jump to MA62 to fail docking, as
     12F8 5900     
3964 12FA 1717  10        jnc  MA62                       ; BCC MA62          ; we are not in the 22.0 degree safe cone of approach
3965               
3966 12FC D360  22        movb @INWK+16,ra                ; LDA INWK+16       ; 5. If |roofv_x_hi| < 80, jump to MA62 to fail docking,
     12FE 0063     
3967 1300 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; as the slot is more than 36.6 degrees from horizontal
     1302 7F00     
3968 1304 028D  14        ci   ra,>50*256                 ; CMP #80
     1306 5000     
3969 1308 1710  10        jnc  MA62                       ; BCC MA62
3970               
3971               GOIN:
3972                                                                          ; If we arrive here, either the docking computer has
3973                                                                          ; been activated, or we just docked successfully
3974 130A 020D  12        li   ra,>00*256                 ; LDA #0            ; Set the on-screen hyperspace counter to 0
     130C 0000     
3975 130E D80D  22        movb ra,@QQ22+1                 ; STA QQ22+1
     1310 002F     
3976               
3977 1312 020D  12        li   ra,>08*256                 ; LDA #8            ; This instruction has no effect, so presumably it used
     1314 0800     
3978                                                                          ; to do something, and didn't get removed
3979               
3980 1316 0200  12        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     1318 3E62     
3981 131A 06A0  24        bl   @jsr                       ;
     131C FE1E     
3982               
3983 131E 0200  12        li   rtmp,RES4                  ; JSR RES4          ; Reset the shields and energy banks, stardust and INWK
     1320 BF22     
3984 1322 06A0  24        bl   @jsr                       ;
     1324 FE1E     
3985                                                                          ; workspace
3986               
3987 1326 0460  20        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     1328 C65C     
3988                                                                          ; screen)
3989               
3990               MA62:
3991                                                                          ; If we arrive here, docking has just failed
3992 132A D360  22        movb @DELTA,ra                  ; LDA DELTA         ; If the ship's speed is < 5, jump to MA67 to register
     132C 008C     
3993 132E 028D  14        ci   ra,>05*256                 ; CMP #5            ; some damage, but not a huge amount
     1330 0500     
3994 1332 1713  10        jnc  MA67                       ; BCC MA67
3995               
3996 1334 0460  20        b    @DEATH                     ; JMP DEATH         ; Otherwise we have just crashed into the station, so
     1336 C47E     
3997                                                                          ; process our death
3998               
3999               * ******************************************************************************
4000               *
4001               * Name: Main flight loop (Part 10 of 16)
4002               * Type: Subroutine
4003               * Category: Main loop
4004               * Summary: For each nearby ship: Remove if scooped, or process collisions
4005               * Deep dive: Program flow of the main game loop
4006               *
4007               * ------------------------------------------------------------------------------
4008               *
4009               * The main flight loop covers most of the flight-specific aspects of Elite. This
4010               * section covers the following:
4011               *
4012               * * Continue looping through all the ships in the local bubble, and for each
4013               * one:
4014               *
4015               * * Remove scooped item after both successful and failed scooping attempts
4016               *
4017               * * Process collisions
4018               *
4019               * ******************************************************************************
4020               
4021               MA59:
4022                                                                          ; If we get here then scooping failed
4023 1338 0200  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the cargo canister being destroyed
     133A CB2E     
4024 133C 06A0  24        bl   @jsr                       ;
     133E FE1E     
4025                                                                          ; and fall through into MA60 to remove the canister
4026                                                                          ; from our local bubble
4027               
4028               MA60:
4029                                                                          ; If we get here then scooping was successful
4030                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the scooped or destroyed item, to denote
     **** ****     > ASL
0001 1340 D020  22        movb @INWK+31,rtmp
     1342 0072     
0002 1344 0240  14        andi rtmp,>ff00
     1346 FF00     
0003 1348 0A10  14        sla  rtmp,1
0004 134A D800  22        movb rtmp,@INWK+31
     134C 0072     
                   < elite.a99
4031                      .sec                            ; SEC               ; that it has been killed and should be removed from
     **** ****     > SEC
0001 134E 0A18  14        sla  rmone,1
                   < elite.a99
4032 1350 0204  12        li   rarg1,INWK+31              ; ROR INWK+31       ; the local bubble
     1352 0072     
4033 1354 06A0  24        bl   @ror                       ;
     1356 FE70     
4034               
4035               MA61:
4036 1358 1620  10        jne  MA26                       ; BNE MA26          ; Jump to MA26 to skip over the collision routines and
4037                                                                          ; to move on to missile targeting (this BNE is
4038                                                                          ; effectively a JMP as A will never be zero)
4039               
4040               MA67:
4041                                                                          ; If we get here then we have collided with something,
4042                                                                          ; but not fatally
4043 135A 020D  12        li   ra,>01*256                 ; LDA #1            ; Set the speed in DELTA to 1 (i.e. a sudden stop)
     135C 0100     
4044 135E D80D  22        movb ra,@DELTA                  ; STA DELTA
     1360 008C     
4045               
4046 1362 020D  12        li   ra,>05*256                 ; LDA #5            ; Set the amount of damage in A to 5 (a small dent) and
     1364 0500     
4047 1366 1611  10        jne  MA63                       ; BNE MA63          ; jump down to MA63 to process the damage (this BNE is
4048                                                                          ; effectively a JMP as A will never be zero)
4049               
4050               MA58:
4051                                                                          ; If we get here, we have collided with something in a
4052                                                                          ; potentially fatal way
4053                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the ship we just collided with, to
     **** ****     > ASL
0001 1368 D020  22        movb @INWK+31,rtmp
     136A 0072     
0002 136C 0240  14        andi rtmp,>ff00
     136E FF00     
0003 1370 0A10  14        sla  rtmp,1
0004 1372 D800  22        movb rtmp,@INWK+31
     1374 0072     
                   < elite.a99
4054                      .sec                            ; SEC               ; denote that it has been killed and should be removed
     **** ****     > SEC
0001 1376 0A18  14        sla  rmone,1
                   < elite.a99
4055 1378 0204  12        li   rarg1,INWK+31              ; ROR INWK+31       ; from the local bubble
     137A 0072     
4056 137C 06A0  24        bl   @ror                       ;
     137E FE70     
4057               
4058 1380 D360  22        movb @INWK+35,ra                ; LDA INWK+35       ; Load A with the energy level of the ship we just hit
     1382 0076     
4059               
4060                      .sec                            ; SEC               ; Set the amount of damage in A to 128 + A / 2, so
     **** ****     > SEC
0001 1384 0A18  14        sla  rmone,1
                   < elite.a99
4061 1386 06A0  24        bl   @rora                      ; ROR A             ; this is quite a big dent, and colliding with higher
     1388 FE58     
4062                                                                          ; energy ships will cause more damage
4063               
4064               MA63:
4065 138A 0200  12        li   rtmp,OOPS                  ; JSR OOPS          ; The amount of damage is in A, so call OOPS to reduce
     138C AE76     
4066 138E 06A0  24        bl   @jsr                       ;
     1390 FE1E     
4067                                                                          ; our shields, and if the shields are gone, there's a
4068                                                                          ; chance of cargo loss or even death
4069               
4070 1392 0200  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of colliding with the other ship and
     1394 CB2E     
4071 1396 06A0  24        bl   @jsr                       ;
     1398 FE1E     
4072                                                                          ; fall through into MA26 to try targeting a missile
4073               
4074               * ******************************************************************************
4075               *
4076               * Name: Main flight loop (Part 11 of 16)
4077               * Type: Subroutine
4078               * Category: Main loop
4079               * Summary: For each nearby ship: Process missile lock and firing our laser
4080               * Deep dive: Program flow of the main game loop
4081               * Flipping axes between space views
4082               *
4083               * ------------------------------------------------------------------------------
4084               *
4085               * The main flight loop covers most of the flight-specific aspects of Elite. This
4086               * section covers the following:
4087               *
4088               * * Continue looping through all the ships in the local bubble, and for each
4089               * one:
4090               *
4091               * * If this is not the front space view, flip the axes of the ship's
4092               * coordinates in INWK
4093               *
4094               * * Process missile lock
4095               *
4096               * * Process our laser firing
4097               *
4098               * ******************************************************************************
4099               
4100               MA26:
4101 139A D360  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to MA15 to skip
     139C 0096     
4102 139E 1662  10        jne  MA15                       ; BNE MA15          ; missile and laser locking
4103               
4104 13A0 0200  12        li   rtmp,PLUT                  ; JSR PLUT          ; Call PLUT to update the geometric axes in INWK to
     13A2 4984     
4105 13A4 06A0  24        bl   @jsr                       ;
     13A6 FE1E     
4106                                                                          ; match the view (front, rear, left, right)
4107               
4108 13A8 0200  12        li   rtmp,HITCH                 ; JSR HITCH         ; Call HITCH to see if this ship is in the crosshairs,
     13AA 3B3E     
4109 13AC 06A0  24        bl   @jsr                       ;
     13AE FE1E     
4110 13B0 1755  10        jnc  MA8                        ; BCC MA8           ; in which case the C flag will be set (so if there is
4111                                                                          ; no missile or laser lock, we jump to MA8 to skip the
4112                                                                          ; following)
4113               
4114 13B2 D360  22        movb @MSAR,ra                   ; LDA MSAR          ; We have missile lock, so check whether the leftmost
     13B4 0D5E     
4115 13B6 130C  10        jeq  MA47                       ; BEQ MA47          ; missile is currently armed, and if not, jump to MA47
4116                                                                          ; to process laser fire, as we can't lock an unarmed
4117                                                                          ; missile
4118               
4119 13B8 0200  12        li   rtmp,BEEP                  ; JSR BEEP          ; We have missile lock and an armed missile, so call
     13BA CBAC     
4120 13BC 06A0  24        bl   @jsr                       ;
     13BE FE1E     
4121                                                                          ; the BEEP subroutine to make a short, high beep
4122               
4123 13C0 D3A0  22        movb @XSAV,rx                   ; LDX XSAV          ; Call ABORT2 to store the details of this missile
     13C2 0093     
4124 13C4 020F  12        li   ry,>0e*256                 ; LDY #&0E          ; lock, with the targeted ship's slot number in X
     13C6 0E00     
4125 13C8 0200  12        li   rtmp,ABORT2                ; JSR ABORT2        ; (which we stored in XSAV at the start of this ship's
     13CA B0A6     
4126 13CC 06A0  24        bl   @jsr                       ;
     13CE FE1E     
4127                                                                          ; loop at MAL1), and set the colour of the missile
4128                                                                          ; indicator to the colour in Y (red = &0E)
4129               
4130               MA47:
4131                                                                          ; If we get here then the ship is in our sights, but
4132                                                                          ; we didn't lock a missile, so let's see if we're
4133                                                                          ; firing the laser
4134 13D0 D360  22        movb @LAS,ra                    ; LDA LAS           ; If we are firing the laser then LAS will contain the
     13D2 0051     
4135 13D4 1343  10        jeq  MA8                        ; BEQ MA8           ; laser power (which we set in MA68 above), so if this
4136                                                                          ; is zero, jump down to MA8 to skip the following
4137               
4138 13D6 020E  12        li   rx,>0f*256                 ; LDX #15           ; We are firing our laser and the ship in INWK is in
     13D8 0F00     
4139 13DA 0200  12        li   rtmp,EXNO                  ; JSR EXNO          ; the crosshairs, so call EXNO to make the sound of
     13DC CB76     
4140 13DE 06A0  24        bl   @jsr                       ;
     13E0 FE1E     
4141                                                                          ; us making a laser strike on another ship
4142               
4143 13E2 D360  22        movb @INWK+35,ra                ; LDA INWK+35       ; Fetch the hit ship's energy from byte #35 and subtract
     13E4 0076     
4144                      .sec                            ; SEC               ; our current laser power, and if the result is greater
     **** ****     > SEC
0001 13E6 0A18  14        sla  rmone,1
                   < elite.a99
4145                      .sbc @LAS,ra                    ; SBC LAS           ; than zero, the other ship has survived the hit, so
     **** ****     > SBC
0001 13E8 1801  10        joc  !
0002 13EA 7347  14        sb   rone,ra
0003               !:
0004 13EC 7360  22        sb   @LAS,ra
     13EE 0051     
                   < elite.a99
4146 13F0 182D  10        joc  MA14                       ; BCS MA14          ; jump down to MA14 to make it angry
4147               
4148 13F2 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; Did we just hit the space station? If so, jump to
     13F4 009B     
4149 13F6 028D  14        ci   ra,(SST)*256               ; CMP #SST          ; MA14+2 to make the station hostile, skipping the
     13F8 0800     
4150 13FA 1329  10        jeq  MA14+2                     ; BEQ MA14+2        ; following as we can't destroy a space station
4151               
4152 13FC D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 7 of the enemy ship's byte #31, to indicate
     13FE 0072     
4153 1400 026D  14        ori  ra,>80*256                 ; ORA #%10000000    ; that it has been killed
     1402 8000     
4154 1404 D80D  22        movb ra,@INWK+31                ; STA INWK+31
     1406 0072     
4155               
4156 1408 1829  10        joc  MA8                        ; BCS MA8           ; If the enemy ship type is >= SST (i.e. missile,
4157                                                                          ; asteroid, canister, Thargon or escape pod) then
4158                                                                          ; jump down to MA8
4159               
4160 140A 0200  12        li   rtmp,DORND                 ; JSR DORND         ; Fetch a random number, and jump to oh if it is
     140C C07C     
4161 140E 06A0  24        bl   @jsr                       ;
     1410 FE1E     
4162 1412 1518  10        jgt  oh_                        ; BPL oh            ; positive (50% chance)
4163               
4164 1414 020F  12        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte of the hit ship's blueprint,
     1416 0000     
4165                      .and_ind_y_idx @XX0,ra          ; AND (XX0),Y       ; which determines the maximum number of bits of
     **** ****     > AND_IND_Y_IDX
0001 1418 D820  38        movb @XX0,@rtmplb
     141A 001E     
     141C 206D     
0002 141E D020  22        movb @XX0+1,rtmp
     1420 001F     
0003 1422 A00F  14        a    ry,rtmp
0004 1424 D010  22        movb *rtmp,rtmp
0005 1426 0540  10        inv  rtmp
0006 1428 5340  14        szcb rtmp,RA
                   < elite.a99
4166                                                                          ; debris shown when the ship is destroyed, and AND
4167                                                                          ; with the random number we just fetched
4168               
4169 142A D80D  22        movb ra,@CNT                    ; STA CNT           ; Store the result in CNT, so CNT contains a random
     142C 00A4     
4170                                                                          ; number between 0 and the maximum number of bits of
4171                                                                          ; debris that this ship will release when destroyed
4172               
4173               um_:
4174 142E 130A  10        jeq  oh_                        ; BEQ oh            ; We're going to go round a loop using CNT as a counter
4175                                                                          ; so this checks whether the counter is zero and jumps
4176                                                                          ; to oh when it gets there (which might be straight
4177                                                                          ; away)
4178               
4179 1430 020E  12        li   rx,(OIL)*256               ; LDX #OIL          ; Call SFS1 to spawn a cargo canister from the now
     1432 0B00     
4180 1434 020D  12        li   ra,>00*256                 ; LDA #0            ; deceased parent ship, giving the spawned canister an
     1436 0000     
4181 1438 0200  12        li   rtmp,SFS1                  ; JSR SFS1          ; AI flag of 0 (no AI, no E.C.M., non-hostile)
     143A 3D02     
4182 143C 06A0  24        bl   @jsr                       ;
     143E FE1E     
4183               
4184 1440 7347  14        sb   rone,ra                    ; DEC CNT           ; Decrease the loop counter
4185               
4186 1442 15F5  10        jgt  um_                        ; BPL um            ; Jump back up to um (this BPL is effectively a JMP as
4187                                                                          ; CNT will never be negative)
4188               
4189               oh_:
4190 1444 0200  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     1446 CB60     
4191 1448 06A0  24        bl   @jsr                       ;
     144A FE1E     
4192                                                                          ; ship (so increase the kill tally, make an explosion
4193                                                                          ; sound and so on)
4194               
4195               MA14:
4196 144C D80D  22        movb ra,@INWK+35                ; STA INWK+35       ; Store the hit ship's updated energy in ship byte #35
     144E 0076     
4197               
4198 1450 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; Call ANGRY to make this ship hostile, now that we
     1452 009B     
4199 1454 0200  12        li   rtmp,ANGRY                 ; JSR ANGRY         ; have hit it
     1456 3C66     
4200 1458 06A0  24        bl   @jsr                       ;
     145A FE1E     
4201               
4202               * ******************************************************************************
4203               *
4204               * Name: Main flight loop (Part 12 of 16)
4205               * Type: Subroutine
4206               * Category: Main loop
4207               * Summary: For each nearby ship: Draw the ship, remove if killed, loop back
4208               * Deep dive: Program flow of the main game loop
4209               * Drawing ships
4210               *
4211               * ------------------------------------------------------------------------------
4212               *
4213               * The main flight loop covers most of the flight-specific aspects of Elite. This
4214               * section covers the following:
4215               *
4216               * * Continue looping through all the ships in the local bubble, and for each
4217               * one:
4218               *
4219               * * Draw the ship
4220               *
4221               * * Process removal of killed ships
4222               *
4223               * * Loop back up to MAL1 to move onto the next ship in the local bubble
4224               *
4225               * ******************************************************************************
4226               
4227               MA8:
4228 145C 0200  12        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the ship we're processing on-screen
     145E D4B4     
4229 1460 06A0  24        bl   @jsr                       ;
     1462 FE1E     
4230               
4231               MA15:
4232 1464 020F  12        li   ry,>23*256                 ; LDY #35           ; Fetch the ship's energy from byte #35 and copy it to
     1466 2300     
4233 1468 D360  22        movb @INWK+35,ra                ; LDA INWK+35       ; byte #35 in INF (so the ship's data in K% gets
     146A 0076     
4234                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; updated)
     **** ****     > ST_IND_Y_IDX
0001 146C D820  38        movb @INF,@rtmplb
     146E 0020     
     1470 206D     
0002 1472 D020  22        movb @INF+1,rtmp
     1474 0021     
0003 1476 A00F  14        a    ry,rtmp
0004 1478 D40D  26        movb RA,*rtmp
                   < elite.a99
4235               
4236 147A D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 7 of the ship's byte #31 is clear, then the
     147C 0072     
4237 147E 1533  10        jgt  MAC1                       ; BPL MAC1          ; ship hasn't been killed by energy bomb, collision or
4238                                                                          ; laser fire, so jump to MAC1 to skip the following
4239               
4240 1480 024D  14        andi ra,>20*256                 ; AND #%00100000    ; If bit 5 of the ship's byte #31 is clear then the
     1482 2000     
4241 1484 1330  10        jeq  NBOUN                      ; BEQ NBOUN         ; ship is no longer exploding, so jump to NBOUN to skip
4242                                                                          ; the following
4243               
4244 1486 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we just destroyed was a cop, keep going,
     1488 009B     
4245 148A 028D  14        ci   ra,(COPS)*256              ; CMP #COPS         ; otherwise jump to q2 to skip the following
     148C 0200     
4246 148E 1606  10        jne  q2_                        ; BNE q2
4247               
4248 1490 D360  22        movb @FIST,ra                   ; LDA FIST          ; We shot the sheriff, so update our FIST flag
     1492 0334     
4249 1494 026D  14        ori  ra,>40*256                 ; ORA #64           ; ("fugitive/innocent status") to at least 64, which
     1496 4000     
4250 1498 D80D  22        movb ra,@FIST                   ; STA FIST          ; will instantly make us a fugitive
     149A 0334     
4251               
4252               q2_:
4253 149C D360  22        movb @DLY,ra                    ; LDA DLY           ; If we already have an in-flight message on-screen (in
     149E 0D64     
4254 14A0 F360  22        socb @MJ,ra                     ; ORA MJ            ; which case DLY > 0), or we are in witchspace (in
     14A2 0D5C     
4255 14A4 161E  10        jne  KS1S                       ; BNE KS1S          ; which case MJ > 0), jump to KS1S to skip showing an
4256                                                                          ; on-screen bounty for this kill
4257               
4258 14A6 020F  12        li   ry,>0a*256                 ; LDY #10           ; Fetch byte #10 of the ship's blueprint, which is the
     14A8 0A00     
4259                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the bounty awarded when this ship is
     **** ****     > LD_IND_Y_IDX
0001 14AA D820  38        movb @XX0,@rtmplb
     14AC 001E     
     14AE 206D     
0002 14B0 D020  22        movb @XX0+1,rtmp
     14B2 001F     
0003 14B4 A00F  14        a    ry,rtmp
0004 14B6 D350  22        movb *rtmp,RA
                   < elite.a99
4260 14B8 1314  10        jeq  KS1S                       ; BEQ KS1S          ; killed (in Cr * 10), and if it's zero jump to KS1S as
4261                                                                          ; there is no on-screen bounty to display
4262               
4263 14BA D38D  14        movb ra,rx                      ; TAX               ; Put the low byte of the bounty into X
4264               
4265 14BC B3C7  14        ab   rone,ry                    ; INY               ; Fetch byte #11 of the ship's blueprint, which is the
4266                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; high byte of the bounty awarded (in Cr * 10), and put
     **** ****     > LD_IND_Y_IDX
0001 14BE D820  38        movb @XX0,@rtmplb
     14C0 001E     
     14C2 206D     
0002 14C4 D020  22        movb @XX0+1,rtmp
     14C6 001F     
0003 14C8 A00F  14        a    ry,rtmp
0004 14CA D350  22        movb *rtmp,RA
                   < elite.a99
4267 14CC D3CD  14        movb ra,ry                      ; TAY               ; it into Y
4268               
4269 14CE 0200  12        li   rtmp,MCASH                 ; JSR MCASH         ; Call MCASH to add (Y X) to the cash pot
     14D0 A1BE     
4270 14D2 06A0  24        bl   @jsr                       ;
     14D4 FE1E     
4271               
4272 14D6 020D  12        li   ra,>00*256                 ; LDA #0            ; Print control code 0 (current cash, right-aligned to
     14D8 0000     
4273 14DA 0200  12        li   rtmp,MESS                  ; JSR MESS          ; width 9, then " CR", newline) as an in-flight message
     14DC CE5E     
4274 14DE 06A0  24        bl   @jsr                       ;
     14E0 FE1E     
4275               
4276               KS1S:
4277 14E2 0460  20        b    @KS1                       ; JMP KS1           ; Process the killing of this ship (which removes this
     14E4 BC54     
4278                                                                          ; ship from its slot and shuffles all the other ships
4279                                                                          ; down to close up the gap)
4280               
4281               NBOUN:
4282                      equ  $
4283               MAC1:
4284 14E6 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we are processing is a planet or sun,
     14E8 009B     
4285 14EA 1105  10        jlt  MA27                       ; BMI MA27          ; jump to MA27 to skip the following two instructions
4286               
4287 14EC 0200  12        li   rtmp,FAROF                 ; JSR FAROF         ; If the ship we are processing is a long way away (its
     14EE C456     
4288 14F0 06A0  24        bl   @jsr                       ;
     14F2 FE1E     
4289 14F4 17F6  10        jnc  KS1S                       ; BCC KS1S          ; distance in any one direction is > 224, jump to KS1S
4290                                                                          ; to remove the ship from our local bubble, as it's just
4291                                                                          ; left the building
4292               
4293               MA27:
4294 14F6 020F  12        li   ry,>1f*256                 ; LDY #31           ; Fetch the ship's explosion/killed state from byte #31
     14F8 1F00     
4295 14FA D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; and copy it to byte #31 in INF (so the ship's data in
     14FC 0072     
4296                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; K% gets updated)
     **** ****     > ST_IND_Y_IDX
0001 14FE D820  38        movb @INF,@rtmplb
     1500 0020     
     1502 206D     
0002 1504 D020  22        movb @INF+1,rtmp
     1506 0021     
0003 1508 A00F  14        a    ry,rtmp
0004 150A D40D  26        movb RA,*rtmp
                   < elite.a99
4297               
4298 150C D3A0  22        movb @XSAV,rx                   ; LDX XSAV          ; We're done processing this ship, so fetch the ship's
     150E 0093     
4299                                                                          ; slot number, which we saved in XSAV back at the start
4300                                                                          ; of the loop
4301               
4302 1510 B387  14        ab   rone,rx                    ; INX               ; Increment the slot number to move on to the next slot
4303               
4304 1512 0460  16        b    @MAL1                      ; JMP MAL1          ; And jump back up to the beginning of the loop to get
     1514 118C     
4305                                                                          ; the next ship in the local bubble for processing
4306               
4307               * ******************************************************************************
4308               *
4309               * Name: Main flight loop (Part 13 of 16)
4310               * Type: Subroutine
4311               * Category: Main loop
4312               * Summary: Show energy bomb effect, charge shields and energy banks
4313               * Deep dive: Program flow of the main game loop
4314               * Scheduling tasks with the main loop counter
4315               *
4316               * ------------------------------------------------------------------------------
4317               *
4318               * The main flight loop covers most of the flight-specific aspects of Elite. This
4319               * section covers the following:
4320               *
4321               * * Show energy bomb effect (if applicable)
4322               *
4323               * * Charge shields and energy banks (every 7 iterations of the main loop)
4324               *
4325               * ******************************************************************************
4326               
4327               MA18:
4328 1516 D360  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     1518 032A     
4329 151A 150F  10        jgt  MA77                       ; BPL MA77          ; BOMB is now negative, so this skips to MA21 if our
4330                                                                          ; energy bomb is not going off
4331               
4332                      .asl @BOMB                      ; ASL BOMB          ; We set off our energy bomb, so rotate BOMB to the
     **** ****     > ASL
0001 151C D020  22        movb @BOMB,rtmp
     151E 032A     
0002 1520 0240  14        andi rtmp,>ff00
     1522 FF00     
0003 1524 0A10  14        sla  rtmp,1
0004 1526 D800  22        movb rtmp,@BOMB
     1528 032A     
                   < elite.a99
4333                                                                          ; left by one place. BOMB was rotated left once already
4334                                                                          ; during this iteration of the main loop, back at MA24,
4335                                                                          ; so if this is the first pass it will already be
4336                                                                          ; %11111110, and this will shift it to %11111100 - so
4337                                                                          ; if we set off an energy bomb, it stays activated
4338                                                                          ; (BOMB > 0) for four iterations of the main loop
4339               
4340 152A 0200  12        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     152C 4DE2     
4341 152E 06A0  24        bl   @jsr                       ;
     1530 FE1E     
4342                                                                          ; screen gets drawn and the following palette change
4343                                                                          ; won't kick in while the screen is still refreshing
4344               
4345 1532 020D  12        li   ra,>30*256                 ; LDA #%00110000    ; Set the palette byte at SHEILA &21 to map logical
     1534 3000     
4346 1536 D80D  30        movb ra,@VIA+>21                ; STA VIA+&21       ; colour 0 to physical colour 7 (white), but with only
     1538 FE21     
4347                                                                          ; one mapping (rather than the 7 mappings required to
4348                                                                          ; do the mapping properly). This makes the space screen
4349                                                                          ; flash with black and white stripes. See p.382 of the
4350                                                                          ; Advanced User Guide for details of why this single
4351                                                                          ; palette change creates a special effect
4352               
4353               MA77:
4354 153A D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 7,
     153C 0099     
4355 153E 024D  14        andi ra,>07*256                 ; AND #7            ; jumping to MA22 if it is non-zero (so the following
     1540 0700     
4356 1542 1664  10        jne  MA22                       ; BNE MA22          ; code only runs every 8 iterations of the main loop)
4357               
4358 1544 D3A0  22        movb @ENERGY,rx                 ; LDX ENERGY        ; Fetch our ship's energy levels and skip to b if bit 7
     1546 0F13     
4359 1548 1510  10        jgt  b_                         ; BPL b             ; is not set, i.e. only charge the shields from the
4360                                                                          ; energy banks if they are at more than 50% charge
4361               
4362 154A D3A0  22        movb @ASH,rx                    ; LDX ASH           ; Call SHD to recharge our aft shield and update the
     154C 0F12     
4363 154E 0200  12        li   rtmp,SHD                   ; JSR SHD           ; shield status in ASH
     1550 ACDE     
4364 1552 06A0  24        bl   @jsr                       ;
     1554 FE1E     
4365 1556 D80E  22        movb rx,@ASH                    ; STX ASH
     1558 0F12     
4366               
4367 155A D3A0  22        movb @FSH,rx                    ; LDX FSH           ; Call SHD to recharge our forward shield and update
     155C 0F11     
4368 155E 0200  12        li   rtmp,SHD                   ; JSR SHD           ; the shield status in FSH
     1560 ACDE     
4369 1562 06A0  24        bl   @jsr                       ;
     1564 FE1E     
4370 1566 D80E  22        movb rx,@FSH                    ; STX FSH
     1568 0F11     
4371               
4372               b_:
4373                      .sec                            ; SEC               ; Set A = ENERGY + ENGY + 1, so our ship's energy
     **** ****     > SEC
0001 156A 0A18  14        sla  rmone,1
                   < elite.a99
4374 156C D360  22        movb @ENGY,ra                   ; LDA ENGY          ; level goes up by 2 if we have an energy unit fitted,
     156E 032B     
4375                      .adc @ENERGY,ra                 ; ADC ENERGY        ; otherwise it goes up by 1
     **** ****     > ADC
0001 1570 1701  10        jnc  !
0002 1572 B347  14        ab   rone,ra
0003               !:
0004 1574 B360  22        ab   @ENERGY,ra
     1576 0F13     
                   < elite.a99
4376               
4377 1578 1802  10        joc  B09                        ; BCS B09           ; If the value of A did not overflow (the maximum
4378 157A D80D  22        movb ra,@ENERGY                 ; STA ENERGY        ; energy level is &FF), then store A in ENERGY
     157C 0F13     
4379               
4380               * ******************************************************************************
4381               *
4382               * Name: Main flight loop (Part 14 of 16)
4383               * Type: Subroutine
4384               * Category: Main loop
4385               * Summary: Spawn a space station if we are close enough to the planet
4386               * Deep dive: Program flow of the main game loop
4387               * Scheduling tasks with the main loop counter
4388               * Ship data blocks
4389               * The space station safe zone
4390               *
4391               * ------------------------------------------------------------------------------
4392               *
4393               * The main flight loop covers most of the flight-specific aspects of Elite. This
4394               * section covers the following:
4395               *
4396               * * Spawn a space station if we are close enough to the planet (every 32
4397               * iterations of the main loop)
4398               *
4399               * ******************************************************************************
4400               
4401               B09:
4402 157E D360  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23S to skip
     1580 0D5C     
4403 1582 1642  10        jne  MA23S                      ; BNE MA23S         ; the following, as there are no space stations in
4404                                                                          ; witchspace
4405               
4406 1584 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     1586 0099     
4407 1588 024D  14        andi ra,>1f*256                 ; AND #31           ; jumping to MA93 if it is on-zero (so the following
     158A 1F00     
4408 158C 1646  10        jne  MA93                       ; BNE MA93          ; code only runs every 32 iterations of the main loop)
4409               
4410 158E D360  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     1590 0D55     
4411 1592 163A  10        jne  MA23S                      ; BNE MA23S         ; MA23S to skip the following, as we already have a
4412                                                                          ; space station and don't need another
4413               
4414 1594 D3CD  14        movb ra,ry                      ; TAY               ; Set Y = A = 0 (A is 0 as we didn't branch with the
4415                                                                          ; previous BNE instruction)
4416               
4417 1596 0200  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     1598 1786     
4418 159A 06A0  24        bl   @jsr                       ;
     159C FE1E     
4419 159E 1634  10        jne  MA23S                      ; BNE MA23S         ; planet in any of the three axes, and if it's
4420                                                                          ; non-zero, jump to MA23S to skip the following, as we
4421                                                                          ; are too far from the planet to bump into a space
4422                                                                          ; station
4423               
4424                                                                          ; We now want to spawn a space station, so first we
4425                                                                          ; need to set up a ship data block for the station in
4426                                                                          ; INWK that we can then pass to NWSPS to add a new
4427                                                                          ; station to our bubble of universe. We do this by
4428                                                                          ; copying the planet data block from K% to INWK so we
4429                                                                          ; can work on it, but we only need the first 29 bytes,
4430                                                                          ; as we don't need to worry about bytes #29 to #35
4431                                                                          ; for planets (as they don't have rotation counters,
4432                                                                          ; AI, explosions, missiles, a ship line heap or energy
4433                                                                          ; levels)
4434               
4435 15A0 020E  12        li   rx,>1c*256                 ; LDX #28           ; So we set a counter in X to copy 29 bytes from K%+0
     15A2 1C00     
4436                                                                          ; to K%+28
4437               
4438               MAL4:
4439 15A4 D36E  26        movb @K.(rx),ra                 ; LDA K%,X          ; Load the X-th byte of K% and store in the X-th byte
     15A6 0900     
4440 15A8 DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; of the INWK workspace
     15AA 0053     
4441               
4442 15AC 7387  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
4443               
4444 15AE 15FA  10        jgt  MAL4                       ; BPL MAL4          ; Loop back for the next byte until we have copied the
4445                                                                          ; first 28 bytes of K% to INWK
4446               
4447                                                                          ; We now check the distance from our ship (at the
4448                                                                          ; origin) towards the point where we will spawn the
4449                                                                          ; space station if we are close enough
4450                                                                          ;
4451                                                                          ; This point is calculated by starting at the planet's
4452                                                                          ; centre and adding 2 * nosev, which takes us to a point
4453                                                                          ; above the planet's surface, at an altitude that
4454                                                                          ; matches the planet's radius
4455                                                                          ;
4456                                                                          ; This point pitches and rolls around the planet as the
4457                                                                          ; nosev vector rotates with the planet, and if our ship
4458                                                                          ; is within a distance of (192 0) from this point in all
4459                                                                          ; three axes, then we spawn the space station at this
4460                                                                          ; point, with the station's slot facing towards the
4461                                                                          ; planet, along the nosev vector
4462                                                                          ;
4463                                                                          ; This works because in the following, we calculate the
4464                                                                          ; station's coordinates one axis at a time, and store
4465                                                                          ; the results in the INWK block, so by the time we have
4466                                                                          ; calculated and checked all three, the ship data block
4467                                                                          ; is set up with the correct spawning coordinates
4468               
4469 15B0 B387  14        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X as &FF)
4470               
4471 15B2 020F  12        li   ry,>09*256                 ; LDY #9            ; Call MAS1 with X = 0, Y = 9 to do the following:
     15B4 0900     
4472 15B6 0200  12        li   rtmp,MAS1                  ; JSR MAS1          ;
     15B8 1738     
4473 15BA 06A0  24        bl   @jsr                       ;
     15BC FE1E     
4474                                                                          ; (x_sign x_hi x_lo) += (nosev_x_hi nosev_x_lo) * 2
4475                                                                          ;
4476                                                                          ; A = |x_sign|
4477               
4478 15BE 1624  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4479                                                                          ; are too far from the planet in the x-direction to
4480                                                                          ; bump into a space station
4481               
4482 15C0 020E  12        li   rx,>03*256                 ; LDX #3            ; Call MAS1 with X = 3, Y = 11 to do the following:
     15C2 0300     
4483 15C4 020F  12        li   ry,>0b*256                 ; LDY #11           ;
     15C6 0B00     
4484 15C8 0200  12        li   rtmp,MAS1                  ; JSR MAS1          ; (y_sign y_hi y_lo) += (nosev_y_hi nosev_y_lo) * 2
     15CA 1738     
4485 15CC 06A0  24        bl   @jsr                       ;
     15CE FE1E     
4486                                                                          ;
4487                                                                          ; A = |y_sign|
4488               
4489 15D0 161B  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4490                                                                          ; are too far from the planet in the y-direction to
4491                                                                          ; bump into a space station
4492               
4493 15D2 020E  12        li   rx,>06*256                 ; LDX #6            ; Call MAS1 with X = 6, Y = 13 to do the following:
     15D4 0600     
4494 15D6 020F  12        li   ry,>0d*256                 ; LDY #13           ;
     15D8 0D00     
4495 15DA 0200  12        li   rtmp,MAS1                  ; JSR MAS1          ; (z_sign z_hi z_lo) += (nosev_z_hi nosev_z_lo) * 2
     15DC 1738     
4496 15DE 06A0  24        bl   @jsr                       ;
     15E0 FE1E     
4497                                                                          ;
4498                                                                          ; A = |z_sign|
4499               
4500 15E2 1612  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4501                                                                          ; are too far from the planet in the z-direction to
4502                                                                          ; bump into a space station
4503               
4504 15E4 020D  12        li   ra,>c0*256                 ; LDA #192          ; Call FAROF2 to compare x_hi, y_hi and z_hi with 192,
     15E6 C000     
4505 15E8 0200  12        li   rtmp,FAROF2                ; JSR FAROF2        ; which will set the C flag if all three are < 192, or
     15EA C45A     
4506 15EC 06A0  24        bl   @jsr                       ;
     15EE FE1E     
4507                                                                          ; clear the C flag if any of them are >= 192
4508               
4509 15F0 170B  10        jnc  MA23S                      ; BCC MA23S         ; Jump to MA23S if any one of x_hi, y_hi or z_hi are
4510                                                                          ; >= 192 (i.e. they must all be < 192 for us to be near
4511                                                                          ; enough to the planet to bump into a space station)
4512               
4513 15F2 D360  22        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, skip the
     15F4 0096     
4514 15F6 1604  10        jne  B10                        ; BNE B10           ; following instruction (so we only remove the sun from
4515                                                                          ; the screen if we are potentially looking at it)
4516               
4517 15F8 0200  12        li   rtmp,WPLS                  ; JSR WPLS          ; Call WPLS to remove the sun from the screen, as we
     15FA B97C     
4518 15FC 06A0  24        bl   @jsr                       ;
     15FE FE1E     
4519                                                                          ; can't have both the sun and the space station at the
4520                                                                          ; same time
4521               
4522               B10:
4523 1600 0200  12        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     1602 AF2A     
4524 1604 06A0  24        bl   @jsr                       ;
     1606 FE1E     
4525                                                                          ; universe
4526               
4527               MA23S:
4528 1608 0460  16        b    @MA23                      ; JMP MA23          ; Jump to MA23 to skip the following planet and sun
     160A 16EC     
4529                                                                          ; altitude checks
4530               
4531               * ******************************************************************************
4532               *
4533               * Name: Main flight loop (Part 15 of 16)
4534               * Type: Subroutine
4535               * Category: Main loop
4536               * Summary: Perform altitude checks with the planet and sun and process fuel
4537               * scooping if appropriate
4538               * Deep dive: Program flow of the main game loop
4539               * Scheduling tasks with the main loop counter
4540               *
4541               * ------------------------------------------------------------------------------
4542               *
4543               * The main flight loop covers most of the flight-specific aspects of Elite. This
4544               * section covers the following:
4545               *
4546               * * Perform an altitude check with the planet (every 32 iterations of the main
4547               * loop, on iteration 10 of each 32)
4548               *
4549               * * Perform an altitude check with the sun and process fuel scooping (every
4550               * 32 iterations of the main loop, on iteration 20 of each 32)
4551               *
4552               * ******************************************************************************
4553               
4554               MA22:
4555 160C D360  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23 to skip
     160E 0D5C     
4556 1610 166D  10        jne  MA23                       ; BNE MA23          ; the following, as there are no planets or suns to
4557                                                                          ; bump into in witchspace
4558               
4559 1612 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     1614 0099     
4560 1616 024D  14        andi ra,>1f*256                 ; AND #31           ; which tells us the position of this loop in each block
     1618 1F00     
4561                                                                          ; of 32 iterations
4562               
4563               MA93:
4564 161A 028D  14        ci   ra,>0a*256                 ; CMP #10           ; If this is the tenth iteration in this block of 32,
     161C 0A00     
4565 161E 162D  10        jne  MA29                       ; BNE MA29          ; do the following, otherwise jump to MA29 to skip the
4566                                                                          ; planet altitude check and move on to the sun distance
4567                                                                          ; check
4568               
4569 1620 020D  12        li   ra,>32*256                 ; LDA #50           ; If our energy bank status in ENERGY is >= 50, skip
     1622 3200     
4570 1624 9360  22        cb   @ENERGY,ra                 ; CMP ENERGY        ; printing the following message (so the message is
     1626 0F13     
4571 1628 1707  10        jnc  B11                        ; BCC B11           ; only shown if our energy is low)
4572               
4573                      .asla                           ; ASL A             ; Print recursive token 100 ("ENERGY LOW{beep}") as an
     **** ****     > ASLA
0001 162A 024D  14        andi ra,>ff00
     162C FF00     
0002 162E 0A1D  14        sla  ra,1
                   < elite.a99
4574 1630 0200  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     1632 CE5E     
4575 1634 06A0  24        bl   @jsr                       ;
     1636 FE1E     
4576               
4577               B11:
4578 1638 020F  12        li   ry,>ff*256                 ; LDY #&FF          ; Set our altitude in ALTIT to &FF, the maximum
     163A FF00     
4579 163C D80F  22        movb ry,@ALTIT                  ; STY ALTIT
     163E 0F21     
4580               
4581 1640 B3C7  14        ab   rone,ry                    ; INY               ; Set Y = 0
4582               
4583 1642 0200  12        li   rtmp,m_                    ; JSR m             ; Call m to calculate the maximum distance to the
     1644 1782     
4584 1646 06A0  24        bl   @jsr                       ;
     1648 FE1E     
4585                                                                          ; planet in any of the three axes, returned in A
4586               
4587 164A 1650  10        jne  MA23                       ; BNE MA23          ; If A > 0 then we are a fair distance away from the
4588                                                                          ; planet in at least one axis, so jump to MA23 to skip
4589                                                                          ; the rest of the altitude check
4590               
4591 164C 0200  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     164E 179A     
4592 1650 06A0  24        bl   @jsr                       ;
     1652 FE1E     
4593                                                                          ; we now know that A now contains the square of the
4594                                                                          ; distance between our ship (at the origin) and the
4595                                                                          ; centre of the planet at (x_hi, y_hi, z_hi)
4596               
4597 1654 184B  10        joc  MA23                       ; BCS MA23          ; If the C flag was set by MAS3, then the result
4598                                                                          ; overflowed (was greater than &FF) and we are still a
4599                                                                          ; fair distance from the planet, so jump to MA23 as we
4600                                                                          ; haven't crashed into the planet
4601               
4602                      .sbi (>24*256)                  ; SBC #36           ; Subtract 36 from x_hi^2 + y_hi^2 + z_hi^2
     **** ****     > SBI
0001 1656 1801  10        joc  !
0002 1658 7347  14        sb   rone,ra
0003               !:
0004 165A 022D  14        ai   ra,-(>24*256)
     165C DC00     
                   < elite.a99
4603                                                                          ;
4604                                                                          ; When we do the 3D Pythagoras calculation, we only use
4605                                                                          ; the high bytes of the coordinates, so that's x_hi,
4606                                                                          ; y_hi and z_hi and
4607                                                                          ;
4608                                                                          ; The planet radius is (0 96 0), as defined in the
4609                                                                          ; PLANET routine, so the high byte is 96
4610                                                                          ;
4611                                                                          ; When we square the coordinates above and add them,
4612                                                                          ; the result gets divided by 256 (otherwise the result
4613                                                                          ; wouldn't fit into one byte), so if we do the same for
4614                                                                          ; the planet's radius, we get:
4615                                                                          ;
4616                                                                          ; 96 * 96 / 256 = 36
4617                                                                          ;
4618                                                                          ; So for the planet, the equivalent figure to test the
4619                                                                          ; sum of the _hi bytes against is 36, so A now contains
4620                                                                          ; the high byte of our altitude above the planet
4621                                                                          ; surface, squared
4622               
4623 165E 170B  10        jnc  MA28                       ; BCC MA28          ; If A < 0 then jump to MA28 as we have crashed into
4624                                                                          ; the planet
4625               
4626 1660 D80D  22        movb ra,@R                      ; STA R             ; We are getting close to the planet, so we need to
     1662 0091     
4627 1664 0200  12        li   rtmp,LL5                   ; JSR LL5           ; work out how close. We know from the above that A
     1666 D2B6     
4628 1668 06A0  24        bl   @jsr                       ;
     166A FE1E     
4629                                                                          ; contains our altitude squared, so we store A in R
4630                                                                          ; and call LL5 to calculate:
4631                                                                          ;
4632                                                                          ; Q = SQRT(R Q) = SQRT(A Q)
4633                                                                          ;
4634                                                                          ; Interestingly, Q doesn't appear to be set to 0 for
4635                                                                          ; this calculation, so presumably this doesn't make a
4636                                                                          ; difference
4637               
4638 166C D360  22        movb @Q,ra                      ; LDA Q             ; Store the result in ALTIT, our altitude
     166E 0090     
4639 1670 D80D  22        movb ra,@ALTIT                  ; STA ALTIT
     1672 0F21     
4640               
4641 1674 163B  10        jne  MA23                       ; BNE MA23          ; If our altitude is non-zero then we haven't crashed,
4642                                                                          ; so jump to MA23 to skip to the next section
4643               
4644               MA28:
4645 1676 0460  20        b    @DEATH                     ; JMP DEATH         ; If we get here then we just crashed into the planet
     1678 C47E     
4646                                                                          ; or got too close to the sun, so jump to DEATH to start
4647                                                                          ; the funeral preparations and return from the main
4648                                                                          ; flight loop using a tail call
4649               
4650               MA29:
4651 167A 028D  14        ci   ra,>14*256                 ; CMP #20           ; If this is the 20th iteration in this block of 32,
     167C 1400     
4652 167E 1636  10        jne  MA23                       ; BNE MA23          ; do the following, otherwise jump to MA23 to skip the
4653                                                                          ; sun altitude check
4654               
4655 1680 020D  12        li   ra,>1e*256                 ; LDA #30           ; Set CABTMP to 30, the cabin temperature in deep space
     1682 1E00     
4656 1684 D80D  22        movb ra,@CABTMP                 ; STA CABTMP        ; (i.e. one notch on the dashboard bar)
     1686 0D4D     
4657               
4658 1688 D360  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     168A 0D55     
4659 168C 162F  10        jne  MA23                       ; BNE MA23          ; MA23 to skip the following, as we can't have both the
4660                                                                          ; sun and space station at the same time, so we clearly
4661                                                                          ; can't be flying near the sun
4662               
4663 168E 020F  12        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to NI%, which is the offset in K% for the sun's
     1690 2400     
4664                                                                          ; data block, as the second block at K% is reserved for
4665                                                                          ; the sun (or space station)
4666               
4667 1692 0200  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     1694 1786     
4668 1696 06A0  24        bl   @jsr                       ;
     1698 FE1E     
4669 169A 1628  10        jne  MA23                       ; BNE MA23          ; sun in any of the three axes, and if it's non-zero,
4670                                                                          ; jump to MA23 to skip the following, as we are too far
4671                                                                          ; from the sun for scooping or temperature changes
4672               
4673 169C 0200  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     169E 179A     
4674 16A0 06A0  24        bl   @jsr                       ;
     16A2 FE1E     
4675                                                                          ; we now know that A now contains the square of the
4676                                                                          ; distance between our ship (at the origin) and the
4677                                                                          ; heart of the sun at (x_hi, y_hi, z_hi)
4678               
4679                      .eoi (>ff*256)                  ; EOR #%11111111    ; Invert A, so A is now small if we are far from the
     **** ****     > EOI
0001 16A4 0200  12        li   rtmp,(>FF*256)
     16A6 FF00     
0002 16A8 2B40  14        xor  rtmp,ra
                   < elite.a99
4680                                                                          ; sun and large if we are close to the sun, in the
4681                                                                          ; range 0 = far away to &FF = extremely close, ouch,
4682                                                                          ; hot, hot, hot!
4683               
4684                      .adi (>1e*256)                  ; ADC #30           ; Add the minimum cabin temperature of 30, so we get
     **** ****     > ADI
0001 16AA 1701  10        jnc  !
0002 16AC B347  14        ab   rone,ra
0003               !:
0004 16AE 022D  14        ai   ra,(>1E*256)
     16B0 1E00     
                   < elite.a99
4685                                                                          ; one of the following:
4686                                                                          ;
4687                                                                          ; * If the C flag is clear, A contains the cabin
4688                                                                          ; temperature, ranging from 30 to 255, that's hotter
4689                                                                          ; the closer we are to the sun
4690                                                                          ;
4691                                                                          ; * If the C flag is set, the addition has rolled over
4692                                                                          ; and the cabin temperature is over 255
4693               
4694 16B2 D80D  22        movb ra,@CABTMP                 ; STA CABTMP        ; Store the updated cabin temperature
     16B4 0D4D     
4695               
4696 16B6 18DF  10        joc  MA28                       ; BCS MA28          ; If the C flag is set then jump to MA28 to die, as
4697                                                                          ; our temperature is off the scale
4698               
4699 16B8 028D  14        ci   ra,>e0*256                 ; CMP #224          ; If the cabin temperature < 224 then jump to MA23 to
     16BA E000     
4700 16BC 1717  10        jnc  MA23                       ; BCC MA23          ; skip fuel scooping, as we aren't close enough
4701               
4702 16BE D360  22        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, jump to BA23 to
     16C0 0329     
4703 16C2 1314  10        jeq  MA23                       ; BEQ MA23          ; skip fuel scooping, as we can't scoop without fuel
4704                                                                          ; scoops
4705               
4706 16C4 D360  22        movb @DELT4+1,ra                ; LDA DELT4+1       ; We are now successfully fuel scooping, so it's time
     16C6 008E     
4707 16C8 091D  14        srl  ra,1                       ; LSR A             ; to work out how much fuel we're scooping. Fetch the
4708                                                                          ; high byte of DELT4, which contains our current speed
4709                                                                          ; divided by 4, and halve it to get our current speed
4710                                                                          ; divided by 8 (so it's now a value between 1 and 5, as
4711                                                                          ; our speed is normally between 1 and 40). This gives
4712                                                                          ; us the amount of fuel that's being scooped in A, so
4713                                                                          ; the faster we go, the more fuel we scoop, and because
4714                                                                          ; the fuel levels are stored as 10 * the fuel in light
4715                                                                          ; years, that means we just scooped between 0.1 and 0.5
4716                                                                          ; light years of free fuel
4717               
4718                      .adc @QQ14,ra                   ; ADC QQ14          ; Set A = A + the current fuel level * 10 (from QQ14)
     **** ****     > ADC
0001 16CA 1701  10        jnc  !
0002 16CC B347  14        ab   rone,ra
0003               !:
0004 16CE B360  22        ab   @QQ14,ra
     16D0 030D     
                   < elite.a99
4719               
4720 16D2 028D  14        ci   ra,>46*256                 ; CMP #70           ; If A > 70 then set A = 70 (as 70 is the maximum fuel
     16D4 4600     
4721 16D6 1702  10        jnc  B12                        ; BCC B12           ; level, or 7.0 light years)
4722 16D8 020D  12        li   ra,>46*256                 ; LDA #70
     16DA 4600     
4723               
4724               B12:
4725 16DC D80D  22        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel level in QQ14
     16DE 030D     
4726               
4727 16E0 020D  12        li   ra,>a0*256                 ; LDA #160          ; Print recursive token 0 ("FUEL SCOOPS ON") as an
     16E2 A000     
4728 16E4 0200  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     16E6 CE5E     
4729 16E8 06A0  24        bl   @jsr                       ;
     16EA FE1E     
4730               
4731               * ******************************************************************************
4732               *
4733               * Name: Main flight loop (Part 16 of 16)
4734               * Type: Subroutine
4735               * Category: Main loop
4736               * Summary: Process laser pulsing, E.C.M. energy drain, call stardust routine
4737               * Deep dive: Program flow of the main game loop
4738               *
4739               * ------------------------------------------------------------------------------
4740               *
4741               * The main flight loop covers most of the flight-specific aspects of Elite. This
4742               * section covers the following:
4743               *
4744               * * Process laser pulsing
4745               *
4746               * * Process E.C.M. energy drain
4747               *
4748               * * Jump to the stardust routine if we are in a space view
4749               *
4750               * * Return from the main flight loop
4751               *
4752               * ******************************************************************************
4753               
4754               MA23:
4755 16EC D360  22        movb @LAS2,ra                   ; LDA LAS2          ; If the current view has no laser, jump to MA16 to skip
     16EE 0D5D     
4756 16F0 130D  10        jeq  MA16                       ; BEQ MA16          ; the following
4757               
4758 16F2 D360  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT >= 8, jump to MA16 to skip the following, so
     16F4 0D60     
4759 16F6 028D  14        ci   ra,>08*256                 ; CMP #8            ; for a pulse laser with a LASCT between 8 and 10, the
     16F8 0800     
4760 16FA 1808  10        joc  MA16                       ; BCS MA16          ; laser stays on, but for a LASCT of 7 or less it gets
4761                                                                          ; turned off and stays off until LASCT reaches zero and
4762                                                                          ; the next pulse can start (if the fire button is still
4763                                                                          ; being pressed)
4764                                                                          ;
4765                                                                          ; For pulse lasers, LASCT gets set to 10 in ma1 above,
4766                                                                          ; and it decrements every vertical sync (50 times a
4767                                                                          ; second), so this means it pulses five times a second,
4768                                                                          ; with the laser being on for the first 3/10 of each
4769                                                                          ; pulse and off for the rest of the pulse
4770                                                                          ;
4771                                                                          ; If this is a beam laser, LASCT is 0 so we always keep
4772                                                                          ; going here. This means the laser doesn't pulse, but it
4773                                                                          ; does get drawn and removed every cycle, in a slightly
4774                                                                          ; different place each time, so the beams still flicker
4775                                                                          ; around the screen
4776               
4777 16FC 0200  12        li   rtmp,LASLI2                ; JSR LASLI2        ; Redraw the existing laser lines, which has the effect
     16FE 4922     
4778 1700 06A0  24        bl   @jsr                       ;
     1702 FE1E     
4779                                                                          ; of removing them from the screen
4780               
4781 1704 020D  12        li   ra,>00*256                 ; LDA #0            ; Set LAS2 to 0 so if this is a pulse laser, it will
     1706 0000     
4782 1708 D80D  22        movb ra,@LAS2                   ; STA LAS2          ; skip over the above until the next pulse (this has no
     170A 0D5D     
4783                                                                          ; effect if this is a beam laser)
4784               
4785               MA16:
4786 170C D360  22        movb @ECMP,ra                   ; LDA ECMP          ; If our E.C.M is not on, skip to MA69, otherwise keep
     170E 0D5B     
4787 1710 1305  10        jeq  MA69                       ; BEQ MA69          ; going to drain some energy
4788               
4789 1712 0200  12        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     1714 ACE2     
4790 1716 06A0  24        bl   @jsr                       ;
     1718 FE1E     
4791               
4792 171A 1305  10        jeq  MA70                       ; BEQ MA70          ; If we have no energy left, jump to MA70 to turn our
4793                                                                          ; E.C.M. off
4794               
4795               MA69:
4796 171C D360  22        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M is going off (ours or an opponent's) then
     171E 0030     
4797 1720 1306  10        jeq  MA66                       ; BEQ MA66          ; keep going, otherwise skip to MA66
4798               
4799 1722 7347  14        sb   rone,ra                    ; DEC ECMA          ; Decrement the E.C.M. countdown timer, and if it has
4800 1724 1604  10        jne  MA66                       ; BNE MA66          ; reached zero, keep going, otherwise skip to MA66
4801               
4802               MA70:
4803 1726 0200  12        li   rtmp,ECMOF                 ; JSR ECMOF         ; If we get here then either we have either run out of
     1728 CB14     
4804 172A 06A0  24        bl   @jsr                       ;
     172C FE1E     
4805                                                                          ; energy, or the E.C.M. timer has run down, so switch
4806                                                                          ; off the E.C.M.
4807               
4808               MA66:
4809 172E D360  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     1730 0096     
4810 1732 1625  10        jne  MA9                        ; BNE MA9           ; then jump to MA9 to return from the main flight loop
4811                                                                          ; (as MA9 is an RTS)
4812               
4813 1734 0460  20        b    @STARS                     ; JMP STARS         ; This is a space view, so jump to the STARS routine to
     1736 299A     
4814                                                                          ; process the stardust, and return from the main flight
4815                                                                          ; loop using a tail call
4816               
4817               * ******************************************************************************
4818               *
4819               * Name: MAS1
4820               * Type: Subroutine
4821               * Category: Maths (Geometry)
4822               * Summary: Add an orientation vector coordinate to an INWK coordinate
4823               * Deep dive: The space station safe zone
4824               *
4825               * ------------------------------------------------------------------------------
4826               *
4827               * Add a doubled nosev vector coordinate, e.g. (nosev_y_hi nosev_y_lo) * 2, to
4828               * an INWK coordinate, e.g. (x_sign x_hi x_lo), storing the result in the INWK
4829               * coordinate. The axes used in each side of the addition are specified by the
4830               * arguments X and Y.
4831               *
4832               * In the comments below, we document the routine as if we are doing the
4833               * following, i.e. if X = 0 and Y = 11:
4834               *
4835               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (nosev_y_hi nosev_y_lo) * 2
4836               *
4837               * as that way the variable names in the comments contain "x" and "y" to match
4838               * the registers that specify the vector axis to use.
4839               *
4840               * ------------------------------------------------------------------------------
4841               *
4842               * Arguments:
4843               *
4844               * X                   The coordinate to add, as follows:
4845               *
4846               * * If X = 0, add (x_sign x_hi x_lo)
4847               * * If X = 3, add (y_sign y_hi y_lo)
4848               * * If X = 6, add (z_sign z_hi z_lo)
4849               *
4850               * Y                   The vector to add, as follows:
4851               *
4852               * * If Y = 9,  add (nosev_x_hi nosev_x_lo)
4853               * * If Y = 11, add (nosev_y_hi nosev_y_lo)
4854               * * If Y = 13, add (nosev_z_hi nosev_z_lo)
4855               *
4856               * ------------------------------------------------------------------------------
4857               *
4858               * Returns:
4859               *
4860               * A                   The highest byte of the result with the sign cleared
4861               * (e.g. |x_sign| when X = 0, etc.)
4862               *
4863               * ------------------------------------------------------------------------------
4864               *
4865               * Other entry points:
4866               *
4867               * MA9                 Contains an RTS
4868               *
4869               * ******************************************************************************
4870               
4871               MAS1:
4872 1738 D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set K(2 1) = (nosev_y_hi nosev_y_lo) * 2
     173A 0053     
4873                      .asla                           ; ASL A
     **** ****     > ASLA
0001 173C 024D  14        andi ra,>ff00
     173E FF00     
0002 1740 0A1D  14        sla  ra,1
                   < elite.a99
4874 1742 D80D  22        movb ra,@K+1                    ; STA K+1
     1744 003E     
4875 1746 D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y
     1748 0054     
4876 174A 06A0  24        bl   @rola                      ; ROL A
     174C FE34     
4877 174E D80D  22        movb ra,@K+2                    ; STA K+2
     1750 003F     
4878               
4879 1752 020D  12        li   ra,>00*256                 ; LDA #0            ; Set K+3 bit 7 to the C flag, so the sign bit of the
     1754 0000     
4880 1756 06A0  24        bl   @rora                      ; ROR A             ; above result goes into K+3
     1758 FE58     
4881 175A D80D  22        movb ra,@K+3                    ; STA K+3
     175C 0040     
4882               
4883 175E 0200  12        li   rtmp,MVT3                  ; JSR MVT3          ; Add (x_sign x_hi x_lo) to K(3 2 1)
     1760 1C88     
4884 1762 06A0  24        bl   @jsr                       ;
     1764 FE1E     
4885               
4886 1766 DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; Store the sign of the result in x_sign
     1768 0055     
4887               
4888 176A D3E0  22        movb @K+1,ry                    ; LDY K+1           ; Store K(2 1) in (x_hi x_lo)
     176C 003E     
4889 176E DB8F  30        movb ry,@INWK(rx)               ; STY INWK,X
     1770 0053     
4890 1772 D3E0  22        movb @K+2,ry                    ; LDY K+2
     1774 003F     
4891 1776 DB8F  30        movb ry,@INWK+1(rx)             ; STY INWK+1,X
     1778 0054     
4892               
4893 177A 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Set A to the sign byte with the sign cleared,
     177C 7F00     
4894                                                                          ; i.e. |x_sign| when X = 0
4895               
4896               MA9:
4897 177E 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1780 FE2A     
4898               
4899               * ******************************************************************************
4900               *
4901               * Name: MAS2
4902               * Type: Subroutine
4903               * Category: Maths (Geometry)
4904               * Summary: Calculate a cap on the maximum distance to the planet or sun
4905               *
4906               * ------------------------------------------------------------------------------
4907               *
4908               * Given a value in Y that points to the start of a ship data block as an offset
4909               * from K%, calculate the following:
4910               *
4911               * A = A OR x_sign OR y_sign OR z_sign
4912               *
4913               * and clear the sign bit of the result. The K% workspace contains the ship data
4914               * blocks, so the offset in Y must be 0 or a multiple of NI% (as each block in
4915               * K% contains NI% bytes).
4916               *
4917               * The result effectively contains a maximum cap of the three values (though it
4918               * might not be one of the three input values - it's just guaranteed to be
4919               * larger than all of them).
4920               *
4921               * If Y = 0 and A = 0, then this calculates the maximum cap of the highest byte
4922               * containing the distance to the planet, as K%+2 = x_sign, K%+5 = y_sign and
4923               * K%+8 = z_sign (the first slot in the K% workspace represents the planet).
4924               *
4925               * ------------------------------------------------------------------------------
4926               *
4927               * Arguments:
4928               *
4929               * Y                   The offset from K% for the start of the ship data block
4930               * to use
4931               *
4932               * ------------------------------------------------------------------------------
4933               *
4934               * Returns:
4935               *
4936               * A                   A OR K%+2+Y OR K%+5+Y OR K%+8+Y, with bit 7 cleared
4937               *
4938               * ------------------------------------------------------------------------------
4939               *
4940               * Other entry points:
4941               *
4942               * m                   Do not include A in the calculation
4943               *
4944               * ******************************************************************************
4945               
4946               m_:
4947 1782 020D  12        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and fall through into MAS2 to calculate the
     1784 0000     
4948                                                                          ; OR of the three bytes at K%+2+Y, K%+5+Y and K%+8+Y
4949               
4950               MAS2:
4951 1786 F36F  26        socb @K.+2(ry),ra               ; ORA K%+2,Y        ; Set A = A OR x_sign OR y_sign OR z_sign
     1788 0902     
4952 178A F36F  26        socb @K.+5(ry),ra               ; ORA K%+5,Y
     178C 0905     
4953 178E F36F  26        socb @K.+8(ry),ra               ; ORA K%+8,Y
     1790 0908     
4954               
4955 1792 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 in A
     1794 7F00     
4956               
4957 1796 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1798 FE2A     
4958               
4959               * ******************************************************************************
4960               *
4961               * Name: MAS3
4962               * Type: Subroutine
4963               * Category: Maths (Arithmetic)
4964               * Summary: Calculate A = x_hi^2 + y_hi^2 + z_hi^2 in the K% block
4965               *
4966               * ------------------------------------------------------------------------------
4967               *
4968               * Given a value in Y that points to the start of a ship data block as an offset
4969               * from K%, calculate the following:
4970               *
4971               * A = x_hi^2 + y_hi^2 + z_hi^2
4972               *
4973               * returning A = &FF if the calculation overflows a one-byte result. The K%
4974               * workspace contains the ship data blocks, so the offset in Y must be 0 or a
4975               * multiple of NI% (as each block in K% contains NI% bytes).
4976               *
4977               * ------------------------------------------------------------------------------
4978               *
4979               * Arguments:
4980               *
4981               * Y                   The offset from K% for the start of the ship data block
4982               * to use
4983               *
4984               * Returns
4985               *
4986               * A                   A = x_hi^2 + y_hi^2 + z_hi^2
4987               *
4988               * A = &FF if the calculation overflows a one-byte result
4989               *
4990               * ******************************************************************************
4991               
4992               MAS3:
4993 179A D36F  26        movb @K.+1(ry),ra               ; LDA K%+1,Y        ; Set (A P) = x_hi * x_hi
     179C 0901     
4994 179E 0200  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17A0 42BA     
4995 17A2 06A0  24        bl   @jsr                       ;
     17A4 FE1E     
4996               
4997 17A6 D80D  22        movb ra,@R                      ; STA R             ; Store A (high byte of result) in R
     17A8 0091     
4998               
4999 17AA D36F  26        movb @K.+4(ry),ra               ; LDA K%+4,Y        ; Set (A P) = y_hi * y_hi
     17AC 0904     
5000 17AE 0200  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17B0 42BA     
5001 17B2 06A0  24        bl   @jsr                       ;
     17B4 FE1E     
5002               
5003                      .adc @R,ra                      ; ADC R             ; Add A (high byte of second result) to R
     **** ****     > ADC
0001 17B6 1701  10        jnc  !
0002 17B8 B347  14        ab   rone,ra
0003               !:
0004 17BA B360  22        ab   @R,ra
     17BC 0091     
                   < elite.a99
5004               
5005 17BE 180D  10        joc  MA30                       ; BCS MA30          ; If the addition of the two high bytes caused a carry
5006                                                                          ; (i.e. they overflowed), jump to MA30 to return A = &FF
5007               
5008 17C0 D80D  22        movb ra,@R                      ; STA R             ; Store A (sum of the two high bytes) in R
     17C2 0091     
5009               
5010 17C4 D36F  26        movb @K.+7(ry),ra               ; LDA K%+7,Y        ; Set (A P) = z_hi * z_hi
     17C6 0907     
5011 17C8 0200  12        li   rtmp,SQUA2                 ; JSR SQUA2
     17CA 42BA     
5012 17CC 06A0  24        bl   @jsr                       ;
     17CE FE1E     
5013               
5014                      .adc @R,ra                      ; ADC R             ; Add A (high byte of third result) to R, so R now
     **** ****     > ADC
0001 17D0 1701  10        jnc  !
0002 17D2 B347  14        ab   rone,ra
0003               !:
0004 17D4 B360  22        ab   @R,ra
     17D6 0091     
                   < elite.a99
5015                                                                          ; contains the sum of x_hi^2 + y_hi^2 + z_hi^2
5016               
5017 17D8 1702  10        jnc  B13                        ; BCC B13           ; If there is no carry, skip the following instruction
5018                                                                          ; to return straight from the subroutine
5019               
5020               MA30:
5021 17DA 020D  12        li   ra,>ff*256                 ; LDA #&FF          ; The calculation has overflowed, so set A = &FF
     17DC FF00     
5022               
5023               B13:
5024 17DE 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     17E0 FE2A     
5025               
5026               * ******************************************************************************
5027               *
5028               * Name: MVEIT (Part 1 of 9)
5029               * Type: Subroutine
5030               * Category: Moving
5031               * Summary: Move current ship: Tidy the orientation vectors
5032               * Deep dive: Program flow of the ship-moving routine
5033               * Scheduling tasks with the main loop counter
5034               *
5035               * ------------------------------------------------------------------------------
5036               *
5037               * This routine has multiple stages. This stage does the following:
5038               *
5039               * * Tidy the orientation vectors for one of the ship slots
5040               *
5041               * ------------------------------------------------------------------------------
5042               *
5043               * Arguments:
5044               *
5045               * INWK                The current ship/planet/sun's data block
5046               *
5047               * XSAV                The slot number of the current ship/planet/sun
5048               *
5049               * TYPE                The type of the current ship/planet/sun
5050               *
5051               * ******************************************************************************
5052               
5053               MVEIT:
5054 17E2 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bits 5 or 7 of ship byte #31 are set, jump to MV30
     17E4 0072     
5055 17E6 024D  14        andi ra,>a0*256                 ; AND #%10100000    ; as the ship is either exploding or has been killed, so
     17E8 A000     
5056 17EA 1623  10        jne  MV30                       ; BNE MV30          ; we don't need to tidy its orientation vectors or apply
5057                                                                          ; tactics
5058               
5059 17EC D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     17EE 0099     
5060               
5061                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 17F0 D020  22        movb @XSAV,rtmp
     17F2 0093     
0002 17F4 2B40  14        xor  rtmp,ra
                   < elite.a99
5062 17F6 024D  14        andi ra,>0f*256                 ; AND #15           ; with the loop counter and apply mod 15 to the result.
     17F8 0F00     
5063 17FA 1604  10        jne  MV3                        ; BNE MV3           ; The result will be zero when "counter mod 15" matches
5064                                                                          ; the slot number, so this makes sure we call TIDY 12
5065                                                                          ; times every 16 main loop iterations, like this:
5066                                                                          ;
5067                                                                          ; Iteration 0, tidy the ship in slot 0
5068                                                                          ; Iteration 1, tidy the ship in slot 1
5069                                                                          ; Iteration 2, tidy the ship in slot 2
5070                                                                          ; ...
5071                                                                          ; Iteration 11, tidy the ship in slot 11
5072                                                                          ; Iteration 12, do nothing
5073                                                                          ; Iteration 13, do nothing
5074                                                                          ; Iteration 14, do nothing
5075                                                                          ; Iteration 15, do nothing
5076                                                                          ; Iteration 16, tidy the ship in slot 0
5077                                                                          ; ...
5078                                                                          ;
5079                                                                          ; and so on
5080               
5081 17FC 0200  12        li   rtmp,TIDY                  ; JSR TIDY          ; Call TIDY to tidy up the orientation vectors, to
     17FE CFA8     
5082 1800 06A0  24        bl   @jsr                       ;
     1802 FE1E     
5083                                                                          ; prevent the ship from getting elongated and out of
5084                                                                          ; shape due to the imprecise nature of trigonometry
5085                                                                          ; in assembly language
5086               
5087               * ******************************************************************************
5088               *
5089               * Name: MVEIT (Part 2 of 9)
5090               * Type: Subroutine
5091               * Category: Moving
5092               * Summary: Move current ship: Call tactics routine, remove ship from scanner
5093               * Deep dive: Scheduling tasks with the main loop counter
5094               *
5095               * ------------------------------------------------------------------------------
5096               *
5097               * This routine has multiple stages. This stage does the following:
5098               *
5099               * * Apply tactics to ships with AI enabled (by calling the TACTICS routine)
5100               *
5101               * * Remove the ship from the scanner, so we can move it
5102               *
5103               * ******************************************************************************
5104               
5105               MV3:
5106 1804 D3A0  22        movb @TYPE,rx                   ; LDX TYPE          ; If the type of the ship we are moving is positive,
     1806 009B     
5107 1808 1502  10        jgt  B14                        ; BPL B14           ; i.e. it is not a planet (types 128 and 130) or sun
5108                                                                          ; (type 129), then skip the following instruction
5109               
5110 180A 0460  20        b    @MV40                      ; JMP MV40          ; This item is the planet or sun, so jump to MV40 to
     180C 2002     
5111                                                                          ; move it, which ends by jumping back into this routine
5112                                                                          ; at MV45 (after all the rotation, tactics and scanner
5113                                                                          ; code, which we don't need to apply to planets or suns)
5114               
5115               B14:
5116 180E D360  22        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the ship's byte #32 (AI flag) into A
     1810 0073     
5117               
5118 1812 150F  10        jgt  MV30                       ; BPL MV30          ; If bit 7 of the AI flag is clear, then if this is a
5119                                                                          ; ship or missile it is dumb and has no AI, and if this
5120                                                                          ; is the space station it is not hostile, so in both
5121                                                                          ; cases skip the following as it has no tactics
5122               
5123 1814 028E  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If the ship is a missile, skip straight to MV26 to
     1816 0900     
5124 1818 1308  10        jeq  MV26                       ; BEQ MV26          ; call the TACTICS routine, as we do this every
5125                                                                          ; iteration of the main loop for missiles only
5126               
5127 181A D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     181C 0099     
5128               
5129                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 181E D020  22        movb @XSAV,rtmp
     1820 0093     
0002 1822 2B40  14        xor  rtmp,ra
                   < elite.a99
5130 1824 024D  14        andi ra,>07*256                 ; AND #7            ; with the loop counter and apply mod 8 to the result.
     1826 0700     
5131 1828 1604  10        jne  MV30                       ; BNE MV30          ; The result will be zero when "counter mod 8" matches
5132                                                                          ; the slot number mod 8, so this makes sure we call
5133                                                                          ; TACTICS 12 times every 8 main loop iterations, like
5134                                                                          ; this:
5135                                                                          ;
5136                                                                          ; Iteration 0, apply tactics to slots 0 and 8
5137                                                                          ; Iteration 1, apply tactics to slots 1 and 9
5138                                                                          ; Iteration 2, apply tactics to slots 2 and 10
5139                                                                          ; Iteration 3, apply tactics to slots 3 and 11
5140                                                                          ; Iteration 4, apply tactics to slot 4
5141                                                                          ; Iteration 5, apply tactics to slot 5
5142                                                                          ; Iteration 6, apply tactics to slot 6
5143                                                                          ; Iteration 7, apply tactics to slot 7
5144                                                                          ; Iteration 8, apply tactics to slots 0 and 8
5145                                                                          ; ...
5146                                                                          ;
5147                                                                          ; and so on
5148               
5149               MV26:
5150 182A 0200  12        li   rtmp,TACTICS               ; JSR TACTICS       ; Call TACTICS to apply AI tactics to this ship
     182C 37FC     
5151 182E 06A0  24        bl   @jsr                       ;
     1830 FE1E     
5152               
5153               MV30:
5154 1832 0200  12        li   rtmp,SCAN                  ; JSR SCAN          ; Draw the ship on the scanner, which has the effect of
     1834 4C86     
5155 1836 06A0  24        bl   @jsr                       ;
     1838 FE1E     
5156                                                                          ; removing it, as it's already at this point and hasn't
5157                                                                          ; yet moved
5158               
5159               * ******************************************************************************
5160               *
5161               * Name: MVEIT (Part 3 of 9)
5162               * Type: Subroutine
5163               * Category: Moving
5164               * Summary: Move current ship: Move ship forward according to its speed
5165               *
5166               * ------------------------------------------------------------------------------
5167               *
5168               * This routine has multiple stages. This stage does the following:
5169               *
5170               * * Move the ship forward (along the vector pointing in the direction of
5171               * travel) according to its speed:
5172               *
5173               * (x, y, z) += nosev_hi * speed / 64
5174               *
5175               * ******************************************************************************
5176               
5177 183A D360  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set Q = the ship's speed byte #27 * 4
     183C 006E     
5178                      .asla                           ; ASL A
     **** ****     > ASLA
0001 183E 024D  14        andi ra,>ff00
     1840 FF00     
0002 1842 0A1D  14        sla  ra,1
                   < elite.a99
5179                      .asla                           ; ASL A
     **** ****     > ASLA
0001 1844 024D  14        andi ra,>ff00
     1846 FF00     
0002 1848 0A1D  14        sla  ra,1
                   < elite.a99
5180 184A D80D  22        movb ra,@Q                      ; STA Q
     184C 0090     
5181               
5182 184E D360  22        movb @INWK+10,ra                ; LDA INWK+10       ; Set A = |nosev_x_hi|
     1850 005D     
5183 1852 024D  14        andi ra,>7f*256                 ; AND #%01111111
     1854 7F00     
5184               
5185 1856 0200  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     1858 4338     
5186 185A 06A0  24        bl   @jsr                       ;
     185C FE1E     
5187 185E D80D  22        movb ra,@R                      ; STA R             ; = |nosev_x_hi| * speed / 64
     1860 0091     
5188               
5189 1862 D360  22        movb @INWK+10,ra                ; LDA INWK+10       ; If nosev_x_hi is positive, then:
     1864 005D     
5190 1866 020E  12        li   rx,>00*256                 ; LDX #0            ;
     1868 0000     
5191 186A 0200  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + R
     186C 1BA8     
5192 186E 06A0  24        bl   @jsr                       ;
     1870 FE1E     
5193                                                                          ;
5194                                                                          ; If nosev_x_hi is negative, then:
5195                                                                          ;
5196                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - R
5197                                                                          ;
5198                                                                          ; So in effect, this does:
5199                                                                          ;
5200                                                                          ; (x_sign x_hi x_lo) += nosev_x_hi * speed / 64
5201               
5202 1872 D360  22        movb @INWK+12,ra                ; LDA INWK+12       ; Set A = |nosev_y_hi|
     1874 005F     
5203 1876 024D  14        andi ra,>7f*256                 ; AND #%01111111
     1878 7F00     
5204               
5205 187A 0200  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     187C 4338     
5206 187E 06A0  24        bl   @jsr                       ;
     1880 FE1E     
5207 1882 D80D  22        movb ra,@R                      ; STA R             ; = |nosev_y_hi| * speed / 64
     1884 0091     
5208               
5209 1886 D360  22        movb @INWK+12,ra                ; LDA INWK+12       ; If nosev_y_hi is positive, then:
     1888 005F     
5210 188A 020E  12        li   rx,>03*256                 ; LDX #3            ;
     188C 0300     
5211 188E 0200  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) + R
     1890 1BA8     
5212 1892 06A0  24        bl   @jsr                       ;
     1894 FE1E     
5213                                                                          ;
5214                                                                          ; If nosev_y_hi is negative, then:
5215                                                                          ;
5216                                                                          ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) - R
5217                                                                          ;
5218                                                                          ; So in effect, this does:
5219                                                                          ;
5220                                                                          ; (y_sign y_hi y_lo) += nosev_y_hi * speed / 64
5221               
5222 1896 D360  22        movb @INWK+14,ra                ; LDA INWK+14       ; Set A = |nosev_z_hi|
     1898 0061     
5223 189A 024D  14        andi ra,>7f*256                 ; AND #%01111111
     189C 7F00     
5224               
5225 189E 0200  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     18A0 4338     
5226 18A2 06A0  24        bl   @jsr                       ;
     18A4 FE1E     
5227 18A6 D80D  22        movb ra,@R                      ; STA R             ; = |nosev_z_hi| * speed / 64
     18A8 0091     
5228               
5229 18AA D360  22        movb @INWK+14,ra                ; LDA INWK+14       ; If nosev_y_hi is positive, then:
     18AC 0061     
5230 18AE 020E  12        li   rx,>06*256                 ; LDX #6            ;
     18B0 0600     
5231 18B2 0200  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + R
     18B4 1BA8     
5232 18B6 06A0  24        bl   @jsr                       ;
     18B8 FE1E     
5233                                                                          ;
5234                                                                          ; If nosev_z_hi is negative, then:
5235                                                                          ;
5236                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) - R
5237                                                                          ;
5238                                                                          ; So in effect, this does:
5239                                                                          ;
5240                                                                          ; (z_sign z_hi z_lo) += nosev_z_hi * speed / 64
5241               
5242               * ******************************************************************************
5243               *
5244               * Name: MVEIT (Part 4 of 9)
5245               * Type: Subroutine
5246               * Category: Moving
5247               * Summary: Move current ship: Apply acceleration to ship's speed as a one-off
5248               *
5249               * ------------------------------------------------------------------------------
5250               *
5251               * This routine has multiple stages. This stage does the following:
5252               *
5253               * * Apply acceleration to the ship's speed (if acceleration is non-zero),
5254               * and then zero the acceleration as it's a one-off change
5255               *
5256               * ******************************************************************************
5257               
5258 18BA D360  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set A = the ship's speed in byte #24 + the ship's
     18BC 006E     
5259                      .clc                            ; CLC               ; acceleration in byte #28
     **** ****     > CLC
0001 18BE 0A16  14        sla  rzero,1
                   < elite.a99
5260                      .adc @INWK+28,ra                ; ADC INWK+28
     **** ****     > ADC
0001 18C0 1701  10        jnc  !
0002 18C2 B347  14        ab   rone,ra
0003               !:
0004 18C4 B360  22        ab   @INWK+28,ra
     18C6 006F     
                   < elite.a99
5261               
5262 18C8 1502  10        jgt  B15                        ; BPL B15           ; If the result is positive, skip the following
5263                                                                          ; instruction
5264               
5265 18CA 020D  12        li   ra,>00*256                 ; LDA #0            ; Set A to 0 to stop the speed from going negative
     18CC 0000     
5266               
5267               B15:
5268 18CE 020F  12        li   ry,>0f*256                 ; LDY #15           ; We now fetch byte #15 from the ship's blueprint, which
     18D0 0F00     
5269                                                                          ; contains the ship's maximum speed, so set Y = 15 to
5270                                                                          ; use as an index
5271               
5272                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; If A < the ship's maximum speed, skip the following
     **** ****     > CMP_IND_Y_IDX
0001 18D2 D820  38        movb @XX0,@rtmplb
     18D4 001E     
     18D6 206D     
0002 18D8 D020  22        movb @XX0+1,rtmp
     18DA 001F     
0003 18DC A00F  14        a    ry,rtmp
0004 18DE D010  22        movb *rtmp,rtmp
0005 18E0 900D  14        cb   ra,rtmp
                   < elite.a99
5273 18E2 1707  10        jnc  B16                        ; BCC B16           ; instruction
5274               
5275                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Set A to the ship's maximum speed
     **** ****     > LD_IND_Y_IDX
0001 18E4 D820  38        movb @XX0,@rtmplb
     18E6 001E     
     18E8 206D     
0002 18EA D020  22        movb @XX0+1,rtmp
     18EC 001F     
0003 18EE A00F  14        a    ry,rtmp
0004 18F0 D350  22        movb *rtmp,RA
                   < elite.a99
5276               
5277               B16:
5278 18F2 D80D  22        movb ra,@INWK+27                ; STA INWK+27       ; We have now calculated the new ship's speed after
     18F4 006E     
5279                                                                          ; accelerating and keeping the speed within the ship's
5280                                                                          ; limits, so store the updated speed in byte #27
5281               
5282 18F6 020D  12        li   ra,>00*256                 ; LDA #0            ; We have added the ship's acceleration, so we now set
     18F8 0000     
5283 18FA D80D  22        movb ra,@INWK+28                ; STA INWK+28       ; it back to 0 in byte #28, as it's a one-off change
     18FC 006F     
5284               
5285               * ******************************************************************************
5286               *
5287               * Name: MVEIT (Part 5 of 9)
5288               * Type: Subroutine
5289               * Category: Moving
5290               * Summary: Move current ship: Rotate ship's location by our pitch and roll
5291               * Deep dive: Rotating the universe
5292               *
5293               * ------------------------------------------------------------------------------
5294               *
5295               * This routine has multiple stages. This stage does the following:
5296               *
5297               * * Rotate the ship's location in space by the amount of pitch and roll of
5298               * our ship. See below for a deeper explanation of this routine
5299               *
5300               * ******************************************************************************
5301               
5302 18FE D3A0  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1900 0087     
5303                                                                          ; if the roll angle is alpha, X contains |alpha|
5304               
5305 1902 D360  22        movb @INWK,ra                   ; LDA INWK          ; Set P = ~x_lo (i.e. with all its bits flipped) so that
     1904 0053     
5306                      .eoi (>ff*256)                  ; EOR #%11111111    ; we can pass x_lo to MLTU2 below)
     **** ****     > EOI
0001 1906 0200  12        li   rtmp,(>FF*256)
     1908 FF00     
0002 190A 2B40  14        xor  rtmp,ra
                   < elite.a99
5307 190C D80D  22        movb ra,@P                      ; STA P
     190E 001B     
5308               
5309 1910 D360  22        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     1912 0054     
5310               
5311 1914 0200  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     1916 437E     
5312 1918 06A0  24        bl   @jsr                       ;
     191A FE1E     
5313                                                                          ; = (x_hi x_lo) * alpha
5314               
5315 191C D80D  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     191E 001D     
5316                                                                          ; have:
5317                                                                          ;
5318                                                                          ; P(2 1 0) = (x_hi x_lo) * alpha
5319               
5320 1920 D360  22        movb @ALP2+1,ra                 ; LDA ALP2+1        ; Fetch the flipped sign of the current roll angle alpha
     1922 0089     
5321                      .eor @INWK+2                    ; EOR INWK+2        ; from ALP2+1 and EOR with byte #2 (x_sign), so if the
     **** ****     > EOR
0001 1924 D020  22        movb @INWK+2,rtmp
     1926 0055     
0002 1928 2B40  14        xor  rtmp,ra
                   < elite.a99
5322                                                                          ; flipped roll angle and x_sign have the same sign, A
5323                                                                          ; will be positive, else it will be negative. So A will
5324                                                                          ; contain the sign bit of x_sign * flipped alpha sign,
5325                                                                          ; which is the opposite to the sign of the above result,
5326                                                                          ; so we now have:
5327                                                                          ;
5328                                                                          ; (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256
5329               
5330 192A 020E  12        li   rx,>03*256                 ; LDX #3            ; Set (A P+2 P+1) = (y_sign y_hi y_lo) + (A P+2 P+1)
     192C 0300     
5331 192E 0200  12        li   rtmp,MVT6                  ; JSR MVT6          ; = y - x * alpha / 256
     1930 1F7A     
5332 1932 06A0  24        bl   @jsr                       ;
     1934 FE1E     
5333               
5334 1936 D80D  22        movb ra,@K2+3                   ; STA K2+3          ; Set K2(3) = A = the sign of the result
     1938 00AF     
5335               
5336 193A D360  22        movb @P+1,ra                    ; LDA P+1           ; Set K2(1) = P+1, the low byte of the result
     193C 001C     
5337 193E D80D  22        movb ra,@K2+1                   ; STA K2+1
     1940 00AD     
5338               
5339                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~K2+1 (i.e. with all its bits flipped) so
     **** ****     > EOI
0001 1942 0200  12        li   rtmp,(>FF*256)
     1944 FF00     
0002 1946 2B40  14        xor  rtmp,ra
                   < elite.a99
5340 1948 D80D  22        movb ra,@P                      ; STA P             ; that we can pass K2+1 to MLTU2 below)
     194A 001B     
5341               
5342 194C D360  22        movb @P+2,ra                    ; LDA P+2           ; Set K2(2) = A = P+2
     194E 001D     
5343 1950 D80D  22        movb ra,@K2+2                   ; STA K2+2
     1952 00AE     
5344               
5345                                                                          ; So we now have result 1 above:
5346                                                                          ;
5347                                                                          ; K2(3 2 1) = (A P+2 P+1)
5348                                                                          ; = y - x * alpha / 256
5349               
5350 1954 D3A0  22        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the current pitch into X, so
     1956 002B     
5351                                                                          ; if the pitch angle is beta, X contains |beta|
5352               
5353 1958 0200  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     195A 437E     
5354 195C 06A0  24        bl   @jsr                       ;
     195E FE1E     
5355                                                                          ; = K2(2 1) * beta
5356               
5357 1960 D80D  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1962 001D     
5358                                                                          ; have:
5359                                                                          ;
5360                                                                          ; P(2 1 0) = K2(2 1) * beta
5361               
5362 1964 D360  22        movb @K2+3,ra                   ; LDA K2+3          ; Fetch the sign of the above result in K(3 2 1) from
     1966 00AF     
5363                      .eor @BET2                      ; EOR BET2          ; K2+3 and EOR with BET2, the sign of the current pitch
     **** ****     > EOR
0001 1968 D020  22        movb @BET2,rtmp
     196A 008A     
0002 196C 2B40  14        xor  rtmp,ra
                   < elite.a99
5364                                                                          ; rate, so if the pitch and K(3 2 1) have the same sign,
5365                                                                          ; A will be positive, else it will be negative. So A
5366                                                                          ; will contain the sign bit of K(3 2 1) * beta, which is
5367                                                                          ; the same as the sign of the above result, so we now
5368                                                                          ; have:
5369                                                                          ;
5370                                                                          ; (A P+2 P+1) = K2(3 2 1) * beta / 256
5371               
5372 196E 020E  12        li   rx,>06*256                 ; LDX #6            ; Set (A P+2 P+1) = (z_sign z_hi z_lo) + (A P+2 P+1)
     1970 0600     
5373 1972 0200  12        li   rtmp,MVT6                  ; JSR MVT6          ; = z + K2 * beta / 256
     1974 1F7A     
5374 1976 06A0  24        bl   @jsr                       ;
     1978 FE1E     
5375               
5376 197A D80D  22        movb ra,@INWK+8                 ; STA INWK+8        ; Set z_sign = A = the sign of the result
     197C 005B     
5377               
5378 197E D360  22        movb @P+1,ra                    ; LDA P+1           ; Set z_lo = P+1, the low byte of the result
     1980 001C     
5379 1982 D80D  22        movb ra,@INWK+6                 ; STA INWK+6
     1984 0059     
5380               
5381                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~z_lo (i.e. with all its bits flipped) so that
     **** ****     > EOI
0001 1986 0200  12        li   rtmp,(>FF*256)
     1988 FF00     
0002 198A 2B40  14        xor  rtmp,ra
                   < elite.a99
5382 198C D80D  22        movb ra,@P                      ; STA P             ; we can pass z_lo to MLTU2 below)
     198E 001B     
5383               
5384 1990 D360  22        movb @P+2,ra                    ; LDA P+2           ; Set z_hi = P+2
     1992 001D     
5385 1994 D80D  22        movb ra,@INWK+7                 ; STA INWK+7
     1996 005A     
5386               
5387                                                                          ; So we now have result 2 above:
5388                                                                          ;
5389                                                                          ; (z_sign z_hi z_lo) = (A P+2 P+1)
5390                                                                          ; = z + K2 * beta / 256
5391               
5392 1998 0200  12        li   rtmp,MLTU2                 ; JSR MLTU2         ; MLTU2 doesn't change Q, and Q was set to beta in
     199A 4380     
5393 199C 06A0  24        bl   @jsr                       ;
     199E FE1E     
5394                                                                          ; the previous call to MLTU2, so this call does:
5395                                                                          ;
5396                                                                          ; (A P+1 P) = (A ~P) * Q
5397                                                                          ; = (z_hi z_lo) * beta
5398               
5399 19A0 D80D  22        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A = the high byte of the result, so we
     19A2 001D     
5400                                                                          ; now have:
5401                                                                          ;
5402                                                                          ; P(2 1 0) = (z_hi z_lo) * beta
5403               
5404 19A4 D360  22        movb @K2+3,ra                   ; LDA K2+3          ; Set y_sign = K2+3
     19A6 00AF     
5405 19A8 D80D  22        movb ra,@INWK+5                 ; STA INWK+5
     19AA 0058     
5406               
5407                      .eor @BET2                      ; EOR BET2          ; EOR y_sign with BET2, the sign of the current pitch
     **** ****     > EOR
0001 19AC D020  22        movb @BET2,rtmp
     19AE 008A     
0002 19B0 2B40  14        xor  rtmp,ra
                   < elite.a99
5408                      .eor @INWK+8                    ; EOR INWK+8        ; rate, and z_sign. If the result is positive jump to
     **** ****     > EOR
0001 19B2 D020  22        movb @INWK+8,rtmp
     19B4 005B     
0002 19B6 2B40  14        xor  rtmp,ra
                   < elite.a99
5409 19B8 1512  10        jgt  MV43                       ; BPL MV43          ; MV43, otherwise this means beta * z and y have
5410                                                                          ; different signs, i.e. P(2 1) and K2(3 2 1) have
5411                                                                          ; different signs, so we need to add them in order to
5412                                                                          ; calculate K2(2 1) - P(2 1)
5413               
5414 19BA D360  22        movb @P+1,ra                    ; LDA P+1           ; Set (y_hi y_lo) = K2(2 1) + P(2 1)
     19BC 001C     
5415                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 19BE 1701  10        jnc  !
0002 19C0 B347  14        ab   rone,ra
0003               !:
0004 19C2 B360  22        ab   @K2+1,ra
     19C4 00AD     
                   < elite.a99
5416 19C6 D80D  22        movb ra,@INWK+3                 ; STA INWK+3
     19C8 0056     
5417 19CA D360  22        movb @P+2,ra                    ; LDA P+2
     19CC 001D     
5418                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 19CE 1701  10        jnc  !
0002 19D0 B347  14        ab   rone,ra
0003               !:
0004 19D2 B360  22        ab   @K2+2,ra
     19D4 00AE     
                   < elite.a99
5419 19D6 D80D  22        movb ra,@INWK+4                 ; STA INWK+4
     19D8 0057     
5420               
5421 19DA 0460  16        b    @MV44                      ; JMP MV44          ; Jump to MV44 to continue the calculation
     19DC 1A2E     
5422               
5423               MV43:
5424 19DE D360  22        movb @K2+1,ra                   ; LDA K2+1          ; Reversing the logic above, we need to subtract P(2 1)
     19E0 00AD     
5425                      .sbc @P+1,ra                    ; SBC P+1           ; and K2(3 2 1) to calculate K2(2 1) - P(2 1), so this
     **** ****     > SBC
0001 19E2 1801  10        joc  !
0002 19E4 7347  14        sb   rone,ra
0003               !:
0004 19E6 7360  22        sb   @P+1,ra
     19E8 001C     
                   < elite.a99
5426 19EA D80D  22        movb ra,@INWK+3                 ; STA INWK+3        ; sets (y_hi y_lo) = K2(2 1) - P(2 1)
     19EC 0056     
5427 19EE D360  22        movb @K2+2,ra                   ; LDA K2+2
     19F0 00AE     
5428                      .sbc @P+2,ra                    ; SBC P+2
     **** ****     > SBC
0001 19F2 1801  10        joc  !
0002 19F4 7347  14        sb   rone,ra
0003               !:
0004 19F6 7360  22        sb   @P+2,ra
     19F8 001D     
                   < elite.a99
5429 19FA D80D  22        movb ra,@INWK+4                 ; STA INWK+4
     19FC 0057     
5430               
5431 19FE 1817  10        joc  MV44                       ; BCS MV44          ; If the above subtraction did not underflow, then
5432                                                                          ; jump to MV44, otherwise we need to negate the result
5433               
5434 1A00 020D  12        li   ra,>01*256                 ; LDA #1            ; Negate (y_sign y_hi y_lo) using two's complement,
     1A02 0100     
5435                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; first doing the low bytes:
     **** ****     > SBC
0001 1A04 1801  10        joc  !
0002 1A06 7347  14        sb   rone,ra
0003               !:
0004 1A08 7360  22        sb   @INWK+3,ra
     1A0A 0056     
                   < elite.a99
5436 1A0C D80D  22        movb ra,@INWK+3                 ; STA INWK+3        ;
     1A0E 0056     
5437                                                                          ; y_lo = 1 - y_lo
5438               
5439 1A10 020D  12        li   ra,>00*256                 ; LDA #0            ; Then the high bytes:
     1A12 0000     
5440                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 1A14 1801  10        joc  !
0002 1A16 7347  14        sb   rone,ra
0003               !:
0004 1A18 7360  22        sb   @INWK+4,ra
     1A1A 0057     
                   < elite.a99
5441 1A1C D80D  22        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     1A1E 0057     
5442               
5443 1A20 D360  22        movb @INWK+5,ra                 ; LDA INWK+5        ; And finally flip the sign in y_sign
     1A22 0058     
5444                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1A24 0200  12        li   rtmp,(>80*256)
     1A26 8000     
0002 1A28 2B40  14        xor  rtmp,ra
                   < elite.a99
5445 1A2A D80D  22        movb ra,@INWK+5                 ; STA INWK+5
     1A2C 0058     
5446               
5447               MV44:
5448                                                                          ; So we now have result 3 above:
5449                                                                          ;
5450                                                                          ; (y_sign y_hi y_lo) = K2(2 1) - P(2 1)
5451                                                                          ; = K2 - beta * z
5452 1A2E D3A0  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1A30 0087     
5453                                                                          ; if the roll angle is alpha, X contains |alpha|
5454               
5455 1A32 D360  22        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P = ~y_lo (i.e. with all its bits flipped) so that
     1A34 0056     
5456                      .eoi (>ff*256)                  ; EOR #&FF          ; we can pass y_lo to MLTU2 below)
     **** ****     > EOI
0001 1A36 0200  12        li   rtmp,(>FF*256)
     1A38 FF00     
0002 1A3A 2B40  14        xor  rtmp,ra
                   < elite.a99
5457 1A3C D80D  22        movb ra,@P                      ; STA P
     1A3E 001B     
5458               
5459 1A40 D360  22        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi
     1A42 0057     
5460               
5461 1A44 0200  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     1A46 437E     
5462 1A48 06A0  24        bl   @jsr                       ;
     1A4A FE1E     
5463                                                                          ; = (y_hi y_lo) * alpha
5464               
5465 1A4C D80D  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1A4E 001D     
5466                                                                          ; have:
5467                                                                          ;
5468                                                                          ; P(2 1 0) = (y_hi y_lo) * alpha
5469               
5470 1A50 D360  22        movb @ALP2,ra                   ; LDA ALP2          ; Fetch the correct sign of the current roll angle alpha
     1A52 0088     
5471                      .eor @INWK+5                    ; EOR INWK+5        ; from ALP2 and EOR with byte #5 (y_sign), so if the
     **** ****     > EOR
0001 1A54 D020  22        movb @INWK+5,rtmp
     1A56 0058     
0002 1A58 2B40  14        xor  rtmp,ra
                   < elite.a99
5472                                                                          ; correct roll angle and y_sign have the same sign, A
5473                                                                          ; will be positive, else it will be negative. So A will
5474                                                                          ; contain the sign bit of x_sign * correct alpha sign,
5475                                                                          ; which is the same as the sign of the above result,
5476                                                                          ; so we now have:
5477                                                                          ;
5478                                                                          ; (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256
5479               
5480 1A5A 020E  12        li   rx,>00*256                 ; LDX #0            ; Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
     1A5C 0000     
5481 1A5E 0200  12        li   rtmp,MVT6                  ; JSR MVT6          ; = x + y * alpha / 256
     1A60 1F7A     
5482 1A62 06A0  24        bl   @jsr                       ;
     1A64 FE1E     
5483               
5484 1A66 D80D  22        movb ra,@INWK+2                 ; STA INWK+2        ; Set x_sign = A = the sign of the result
     1A68 0055     
5485               
5486 1A6A D360  22        movb @P+2,ra                    ; LDA P+2           ; Set x_hi = P+2, the high byte of the result
     1A6C 001D     
5487 1A6E D80D  22        movb ra,@INWK+1                 ; STA INWK+1
     1A70 0054     
5488               
5489 1A72 D360  22        movb @P+1,ra                    ; LDA P+1           ; Set x_lo = P+1, the low byte of the result
     1A74 001C     
5490 1A76 D80D  22        movb ra,@INWK                   ; STA INWK
     1A78 0053     
5491               
5492                                                                          ; So we now have result 4 above:
5493                                                                          ;
5494                                                                          ; x = x + alpha * y
5495                                                                          ;
5496                                                                          ; and the rotation of (x, y, z) is done
5497               
5498               * ******************************************************************************
5499               *
5500               * Name: MVEIT (Part 6 of 9)
5501               * Type: Subroutine
5502               * Category: Moving
5503               * Summary: Move current ship: Move the ship in space according to our speed
5504               *
5505               * ------------------------------------------------------------------------------
5506               *
5507               * This routine has multiple stages. This stage does the following:
5508               *
5509               * * Move the ship in space according to our speed (we already moved it
5510               * according to its own speed in part 3).
5511               *
5512               * We do this by subtracting our speed (i.e. the distance we travel in this
5513               * iteration of the loop) from the other ship's z-coordinate. We subtract because
5514               * they appear to be "moving" in the opposite direction to us, and the whole
5515               * MVEIT routine is about moving the other ships rather than us (even though we
5516               * are the one doing the moving).
5517               *
5518               * ------------------------------------------------------------------------------
5519               *
5520               * Other entry points:
5521               *
5522               * MV45                Rejoin the MVEIT routine after the rotation, tactics and
5523               * scanner code
5524               *
5525               * ******************************************************************************
5526               
5527               MV45:
5528 1A7A D360  22        movb @DELTA,ra                  ; LDA DELTA         ; Set R to our speed in DELTA
     1A7C 008C     
5529 1A7E D80D  22        movb ra,@R                      ; STA R
     1A80 0091     
5530               
5531 1A82 020D  12        li   ra,>80*256                 ; LDA #%10000000    ; Set A to zeroes but with bit 7 set, so that (A R) is
     1A84 8000     
5532                                                                          ; a 16-bit number containing -R, or -speed
5533               
5534 1A86 020E  12        li   rx,>06*256                 ; LDX #6            ; Set X to the z-axis so the call to MVT1 does this:
     1A88 0600     
5535 1A8A 0200  12        li   rtmp,MVT1                  ; JSR MVT1          ;
     1A8C 1BAA     
5536 1A8E 06A0  24        bl   @jsr                       ;
     1A90 FE1E     
5537                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + (A R)
5538                                                                          ; = (z_sign z_hi z_lo) - speed
5539               
5540 1A92 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is not the sun (129) then skip the
     1A94 009B     
5541 1A96 024D  14        andi ra,>81*256                 ; AND #%10000001    ; next instruction, otherwise return from the subroutine
     1A98 8100     
5542 1A9A 028D  14        ci   ra,>81*256                 ; CMP #129          ; as we don't need to rotate the sun around its origin.
     1A9C 8100     
5543 1A9E 1602  10        jne  B17                        ; BNE B17           ; Having both the AND and the CMP is a little odd, as
5544                                                                          ; the sun is the only ship type with bits 0 and 7 set,
5545                                                                          ; so the AND has no effect and could be removed
5546               
5547 1AA0 0460  20        b    @rts                       ; RTS               ; Return from the subroutine, as the ship we are moving
     1AA2 FE2A     
5548                                                                          ; is the sun and doesn't need any of the following
5549               
5550               * ******************************************************************************
5551               *
5552               * Name: MVEIT (Part 7 of 9)
5553               * Type: Subroutine
5554               * Category: Moving
5555               * Summary: Move current ship: Rotate ship's orientation vectors by pitch/roll
5556               * Deep dive: Orientation vectors
5557               * Pitching and rolling
5558               *
5559               * ------------------------------------------------------------------------------
5560               *
5561               * This routine has multiple stages. This stage does the following:
5562               *
5563               * * Rotate the ship's orientation vectors according to our pitch and roll
5564               *
5565               * As with the previous step, this is all about moving the other ships rather
5566               * than us (even though we are the one doing the moving). So we rotate the
5567               * current ship's orientation vectors (which defines its orientation in space),
5568               * by the angles we are "moving" the rest of the sky through (alpha and beta, our
5569               * roll and pitch), so the ship appears to us to be stationary while we rotate.
5570               *
5571               * ******************************************************************************
5572               
5573               B17:
5574 1AA4 020F  12        li   ry,>09*256                 ; LDY #9            ; Apply our pitch and roll rotations to the current
     1AA6 0900     
5575 1AA8 0200  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's nosev vector
     1AAA 1D68     
5576 1AAC 06A0  24        bl   @jsr                       ;
     1AAE FE1E     
5577               
5578 1AB0 020F  12        li   ry,>0f*256                 ; LDY #15           ; Apply our pitch and roll rotations to the current
     1AB2 0F00     
5579 1AB4 0200  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's roofv vector
     1AB6 1D68     
5580 1AB8 06A0  24        bl   @jsr                       ;
     1ABA FE1E     
5581               
5582 1ABC 020F  12        li   ry,>15*256                 ; LDY #21           ; Apply our pitch and roll rotations to the current
     1ABE 1500     
5583 1AC0 0200  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's sidev vector
     1AC2 1D68     
5584 1AC4 06A0  24        bl   @jsr                       ;
     1AC6 FE1E     
5585               
5586               * ******************************************************************************
5587               *
5588               * Name: MVEIT (Part 8 of 9)
5589               * Type: Subroutine
5590               * Category: Moving
5591               * Summary: Move current ship: Rotate ship about itself by its own pitch/roll
5592               * Deep dive: Orientation vectors
5593               * Pitching and rolling by a fixed angle
5594               *
5595               * ------------------------------------------------------------------------------
5596               *
5597               * This routine has multiple stages. This stage does the following:
5598               *
5599               * * If the ship we are processing is rolling or pitching itself, rotate it and
5600               * apply damping if required
5601               *
5602               * ******************************************************************************
5603               
5604 1AC8 D360  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the sign
     1ACA 0071     
5605 1ACC 024D  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1ACE 8000     
5606 1AD0 D80D  22        movb ra,@RAT2                   ; STA RAT2
     1AD2 00AB     
5607               
5608 1AD4 D360  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the value
     1AD6 0071     
5609 1AD8 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1ADA 7F00     
5610               
5611 1ADC 1322  10        jeq  MV8                        ; BEQ MV8           ; If the pitch counter is 0, then jump to MV8 to skip
5612                                                                          ; the following, as the ship is not pitching
5613               
5614 1ADE 028D  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the pitch counter (i.e. the
     1AE0 7F00     
5615                                                                          ; ship's pitch is not damping down), then the C flag
5616                                                                          ; will be set by this instruction
5617               
5618                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1AE2 1801  10        joc  !
0002 1AE4 7347  14        sb   rone,ra
0003               !:
0004 1AE6 022D  14        ai   ra,-(>00*256)
     1AE8 0000     
                   < elite.a99
5619                                                                          ; reduce A by 1, otherwise it is unchanged
5620               
5621 1AEA F360  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1AEC 00AB     
5622                                                                          ; the updated pitch counter in A retains its sign
5623               
5624 1AEE D80D  22        movb ra,@INWK+30                ; STA INWK+30       ; Store the updated pitch counter in byte #30
     1AF0 0071     
5625               
5626 1AF2 020E  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, nosev_x) by a small angle (pitch)
     1AF4 0F00     
5627 1AF6 020F  12        li   ry,>09*256                 ; LDY #9
     1AF8 0900     
5628 1AFA 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1AFC 1E34     
5629 1AFE 06A0  24        bl   @jsr                       ;
     1B00 FE1E     
5630               
5631 1B02 020E  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, nosev_y) by a small angle (pitch)
     1B04 1100     
5632 1B06 020F  12        li   ry,>0b*256                 ; LDY #11
     1B08 0B00     
5633 1B0A 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B0C 1E34     
5634 1B0E 06A0  24        bl   @jsr                       ;
     1B10 FE1E     
5635               
5636 1B12 020E  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, nosev_z) by a small angle (pitch)
     1B14 1300     
5637 1B16 020F  12        li   ry,>0d*256                 ; LDY #13
     1B18 0D00     
5638 1B1A 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B1C 1E34     
5639 1B1E 06A0  24        bl   @jsr                       ;
     1B20 FE1E     
5640               
5641               MV8:
5642 1B22 D360  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the sign
     1B24 0070     
5643 1B26 024D  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1B28 8000     
5644 1B2A D80D  22        movb ra,@RAT2                   ; STA RAT2
     1B2C 00AB     
5645               
5646 1B2E D360  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the value
     1B30 0070     
5647 1B32 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1B34 7F00     
5648               
5649 1B36 1322  10        jeq  MV5                        ; BEQ MV5           ; If the roll counter is 0, then jump to MV5 to skip the
5650                                                                          ; following, as the ship is not rolling
5651               
5652 1B38 028D  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the roll counter (i.e. the
     1B3A 7F00     
5653                                                                          ; ship's roll is not damping down), then the C flag
5654                                                                          ; will be set by this instruction
5655               
5656                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1B3C 1801  10        joc  !
0002 1B3E 7347  14        sb   rone,ra
0003               !:
0004 1B40 022D  14        ai   ra,-(>00*256)
     1B42 0000     
                   < elite.a99
5657                                                                          ; reduce A by 1, otherwise it is unchanged
5658               
5659 1B44 F360  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1B46 00AB     
5660                                                                          ; the updated roll counter in A retains its sign
5661               
5662 1B48 D80D  22        movb ra,@INWK+29                ; STA INWK+29       ; Store the updated pitch counter in byte #29
     1B4A 0070     
5663               
5664 1B4C 020E  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, sidev_x) by a small angle (roll)
     1B4E 0F00     
5665 1B50 020F  12        li   ry,>15*256                 ; LDY #21
     1B52 1500     
5666 1B54 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B56 1E34     
5667 1B58 06A0  24        bl   @jsr                       ;
     1B5A FE1E     
5668               
5669 1B5C 020E  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, sidev_y) by a small angle (roll)
     1B5E 1100     
5670 1B60 020F  12        li   ry,>17*256                 ; LDY #23
     1B62 1700     
5671 1B64 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B66 1E34     
5672 1B68 06A0  24        bl   @jsr                       ;
     1B6A FE1E     
5673               
5674 1B6C 020E  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, sidev_z) by a small angle (roll)
     1B6E 1300     
5675 1B70 020F  12        li   ry,>19*256                 ; LDY #25
     1B72 1900     
5676 1B74 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B76 1E34     
5677 1B78 06A0  24        bl   @jsr                       ;
     1B7A FE1E     
5678               
5679               * ******************************************************************************
5680               *
5681               * Name: MVEIT (Part 9 of 9)
5682               * Type: Subroutine
5683               * Category: Moving
5684               * Summary: Move current ship: Redraw on scanner, if it hasn't been destroyed
5685               *
5686               * ------------------------------------------------------------------------------
5687               *
5688               * This routine has multiple stages. This stage does the following:
5689               *
5690               * * If the ship is exploding or being removed, hide it on the scanner
5691               *
5692               * * Otherwise redraw the ship on the scanner, now that it's been moved
5693               *
5694               * ******************************************************************************
5695               
5696               MV5:
5697 1B7C D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's exploding/killed state from byte #31
     1B7E 0072     
5698               
5699 1B80 024D  14        andi ra,>a0*256                 ; AND #%10100000    ; If we are exploding or removing this ship then jump to
     1B82 A000     
5700 1B84 1608  10        jne  MVD1                       ; BNE MVD1          ; MVD1 to remove it from the scanner permanently
5701               
5702 1B86 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 4 to keep the ship visible on the scanner
     1B88 0072     
5703 1B8A 026D  14        ori  ra,>10*256                 ; ORA #%00010000
     1B8C 1000     
5704 1B8E D80D  22        movb ra,@INWK+31                ; STA INWK+31
     1B90 0072     
5705               
5706 1B92 0460  20        b    @SCAN                      ; JMP SCAN          ; Display the ship on the scanner, returning from the
     1B94 4C86     
5707                                                                          ; subroutine using a tail call
5708               
5709               MVD1:
5710 1B96 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 4 to hide the ship on the scanner
     1B98 0072     
5711 1B9A 024D  14        andi ra,>ef*256                 ; AND #%11101111
     1B9C EF00     
5712 1B9E D80D  22        movb ra,@INWK+31                ; STA INWK+31
     1BA0 0072     
5713               
5714 1BA2 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1BA4 FE2A     
5715               
5716               * ******************************************************************************
5717               *
5718               * Name: MVT1
5719               * Type: Subroutine
5720               * Category: Moving
5721               * Summary: Calculate (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5722               *
5723               * ------------------------------------------------------------------------------
5724               *
5725               * Add the signed delta (A R) to a ship's coordinate, along the axis given in X.
5726               * Mathematically speaking, this routine translates the ship along a single axis
5727               * by a signed delta. Taking the example of X = 0, the x-axis, it does the
5728               * following:
5729               *
5730               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5731               *
5732               * (In practice, MVT1 is only ever called directly with A = 0 or 128, otherwise
5733               * it is always called via MVT-2, which clears A apart from the sign bit. The
5734               * routine is written to cope with a non-zero delta_hi, so it supports a full
5735               * 16-bit delta, but it appears that delta_hi is only ever used to hold the
5736               * sign of the delta.)
5737               *
5738               * The comments below assume we are adding delta to the x-axis, though the axis
5739               * is determined by the value of X.
5740               *
5741               * ------------------------------------------------------------------------------
5742               *
5743               * Arguments:
5744               *
5745               * (A R)               The signed delta, so A = delta_hi and R = delta_lo
5746               *
5747               * X                   Determines which coordinate axis of INWK to change:
5748               *
5749               * * X = 0 adds the delta to (x_lo, x_hi, x_sign)
5750               *
5751               * * X = 3 adds the delta to (y_lo, y_hi, y_sign)
5752               *
5753               * * X = 6 adds the delta to (z_lo, z_hi, z_sign)
5754               *
5755               * ------------------------------------------------------------------------------
5756               *
5757               * Other entry points:
5758               *
5759               * MVT1-2              Clear bits 0-6 of A before entering MVT1
5760               *
5761               * ******************************************************************************
5762               
5763 1BA6 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Clear bits 0-6 of A
     1BA8 8000     
5764               
5765               MVT1:
5766                      .asla                           ; ASL A             ; Set the C flag to the sign bit of the delta, leaving
     **** ****     > ASLA
0001 1BAA 024D  14        andi ra,>ff00
     1BAC FF00     
0002 1BAE 0A1D  14        sla  ra,1
                   < elite.a99
5767                                                                          ; delta_hi << 1 in A
5768               
5769 1BB0 D80D  22        movb ra,@S                      ; STA S             ; Set S = delta_hi << 1
     1BB2 0092     
5770                                                                          ;
5771                                                                          ; This also clears bit 0 of S
5772               
5773 1BB4 020D  12        li   ra,>00*256                 ; LDA #0            ; Set T = just the sign bit of delta (in bit 7)
     1BB6 0000     
5774 1BB8 06A0  24        bl   @rora                      ; ROR A
     1BBA FE58     
5775 1BBC D80D  22        movb ra,@T                      ; STA T
     1BBE 00D1     
5776               
5777                      .lsr @S                         ; LSR S             ; Set S = delta_hi >> 1
     **** ****     > LSR
0001 1BC0 D020  22        movb @S,rtmp
     1BC2 0092     
0002 1BC4 0910  14        srl  rtmp,1
0003 1BC6 D800  22        movb rtmp,@S
     1BC8 0092     
                   < elite.a99
5778                                                                          ; = |delta_hi|
5779                                                                          ;
5780                                                                          ; This also clear the C flag, as we know that bit 0 of
5781                                                                          ; S was clear before the LSR
5782               
5783                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If T EOR x_sign has bit 7 set, then x_sign and delta
     **** ****     > EOR
0001 1BCA D02E  26        movb @INWK+2(RX),rtmp
     1BCC 0055     
0002 1BCE 2B40  14        xor  rtmp,ra
                   < elite.a99
5784 1BD0 111C  10        jlt  MV10                       ; BMI MV10          ; have different signs, so jump to MV10
5785               
5786                                                                          ; At this point, we know x_sign and delta have the same
5787                                                                          ; sign, that sign is in T, and S contains |delta_hi|,
5788                                                                          ; so now we want to do:
5789                                                                          ;
5790                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (S R)
5791                                                                          ;
5792                                                                          ; and then set the sign of the result to the same sign
5793                                                                          ; as x_sign and delta
5794               
5795 1BD2 D360  22        movb @R,ra                      ; LDA R             ; First we add the low bytes, so:
     1BD4 0091     
5796                      .adc @INWK(rx),ra               ; ADC INWK,X        ;
     **** ****     > ADC
0001 1BD6 1701  10        jnc  !
0002 1BD8 B347  14        ab   rone,ra
0003               !:
0004 1BDA B36E  26        ab   @INWK(RX),ra
     1BDC 0053     
                   < elite.a99
5797 1BDE DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = x_lo + R
     1BE0 0053     
5798               
5799 1BE2 D360  22        movb @S,ra                      ; LDA S             ; Then we add the high bytes:
     1BE4 0092     
5800                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 1BE6 1701  10        jnc  !
0002 1BE8 B347  14        ab   rone,ra
0003               !:
0004 1BEA B36E  26        ab   @INWK+1(RX),ra
     1BEC 0054     
                   < elite.a99
5801 1BEE DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi + S
     1BF0 0054     
5802               
5803 1BF2 D36E  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we add any carry into x_sign, and if the
     1BF4 0055     
5804                      .adi (>00*256)                  ; ADC #0            ; sign of x_sign and delta in T is negative, make sure
     **** ****     > ADI
0001 1BF6 1701  10        jnc  !
0002 1BF8 B347  14        ab   rone,ra
0003               !:
0004 1BFA 022D  14        ai   ra,(>00*256)
     1BFC 0000     
                   < elite.a99
5805 1BFE F360  22        socb @T,ra                      ; ORA T             ; the result is negative (by OR'ing with T)
     1C00 00D1     
5806 1C02 DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1C04 0055     
5807               
5808 1C06 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1C08 FE2A     
5809               
5810               MV10:
5811                                                                          ; If we get here, we know x_sign and delta have
5812                                                                          ; different signs, with delta's sign in T, and
5813                                                                          ; |delta_hi| in S, so now we want to do:
5814                                                                          ;
5815                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - (S R)
5816                                                                          ;
5817                                                                          ; and then set the sign of the result according to
5818                                                                          ; the signs of x_sign and delta
5819 1C0A D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes, so:
     1C0C 0053     
5820                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1C0E 0A18  14        sla  rmone,1
                   < elite.a99
5821                      .sbc @R,ra                      ; SBC R             ; x_lo = x_lo - R
     **** ****     > SBC
0001 1C10 1801  10        joc  !
0002 1C12 7347  14        sb   rone,ra
0003               !:
0004 1C14 7360  22        sb   @R,ra
     1C16 0091     
                   < elite.a99
5822 1C18 DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X
     1C1A 0053     
5823               
5824 1C1C D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then we subtract the high bytes:
     1C1E 0054     
5825                      .sbc @S,ra                      ; SBC S             ;
     **** ****     > SBC
0001 1C20 1801  10        joc  !
0002 1C22 7347  14        sb   rone,ra
0003               !:
0004 1C24 7360  22        sb   @S,ra
     1C26 0092     
                   < elite.a99
5826 1C28 DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi - S
     1C2A 0054     
5827               
5828 1C2C D36E  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we subtract any borrow from bits 0-6 of
     1C2E 0055     
5829 1C30 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; x_sign, and give the result the opposite sign bit to T
     1C32 7F00     
5830                      .sbi (>00*256)                  ; SBC #0            ; (i.e. give it the sign of the original x_sign)
     **** ****     > SBI
0001 1C34 1801  10        joc  !
0002 1C36 7347  14        sb   rone,ra
0003               !:
0004 1C38 022D  14        ai   ra,-(>00*256)
     1C3A 0000     
                   < elite.a99
5831 1C3C 026D  14        ori  ra,>80*256                 ; ORA #%10000000
     1C3E 8000     
5832                      .eor @T                         ; EOR T
     **** ****     > EOR
0001 1C40 D020  22        movb @T,rtmp
     1C42 00D1     
0002 1C44 2B40  14        xor  rtmp,ra
                   < elite.a99
5833 1C46 DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1C48 0055     
5834               
5835 1C4A 181C  10        joc  MV11                       ; BCS MV11          ; If the C flag is set by the above SBC, then our sum
5836                                                                          ; above didn't underflow and is correct - to put it
5837                                                                          ; another way, (x_sign x_hi x_lo) >= (S R) so the result
5838                                                                          ; should indeed have the same sign as x_sign, so jump to
5839                                                                          ; MV11 to return from the subroutine
5840               
5841                                                                          ; Otherwise our subtraction underflowed because
5842                                                                          ; (x_sign x_hi x_lo) < (S R), so we now need to flip the
5843                                                                          ; subtraction around by using two's complement to this:
5844                                                                          ;
5845                                                                          ; (S R) - (x_sign x_hi x_lo)
5846                                                                          ;
5847                                                                          ; and then we need to give the result the same sign as
5848                                                                          ; (S R), the delta, as that's the dominant figure in the
5849                                                                          ; sum
5850               
5851 1C4C 020D  12        li   ra,>01*256                 ; LDA #1            ; First we subtract the low bytes, so:
     1C4E 0100     
5852                      .sbc @INWK(rx),ra               ; SBC INWK,X        ;
     **** ****     > SBC
0001 1C50 1801  10        joc  !
0002 1C52 7347  14        sb   rone,ra
0003               !:
0004 1C54 736E  26        sb   @INWK(RX),ra
     1C56 0053     
                   < elite.a99
5853 1C58 DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = 1 - x_lo
     1C5A 0053     
5854               
5855 1C5C 020D  12        li   ra,>00*256                 ; LDA #0            ; Then we subtract the high bytes:
     1C5E 0000     
5856                      .sbc @INWK+1(rx),ra             ; SBC INWK+1,X      ;
     **** ****     > SBC
0001 1C60 1801  10        joc  !
0002 1C62 7347  14        sb   rone,ra
0003               !:
0004 1C64 736E  26        sb   @INWK+1(RX),ra
     1C66 0054     
                   < elite.a99
5857 1C68 DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = 0 - x_hi
     1C6A 0054     
5858               
5859 1C6C 020D  12        li   ra,>00*256                 ; LDA #0            ; And then we subtract the sign bytes:
     1C6E 0000     
5860                      .sbc @INWK+2(rx),ra             ; SBC INWK+2,X      ;
     **** ****     > SBC
0001 1C70 1801  10        joc  !
0002 1C72 7347  14        sb   rone,ra
0003               !:
0004 1C74 736E  26        sb   @INWK+2(RX),ra
     1C76 0055     
                   < elite.a99
5861                                                                          ; x_sign = 0 - x_sign
5862               
5863 1C78 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Finally, we set the sign bit to the sign in T, the
     1C7A 7F00     
5864 1C7C F360  22        socb @T,ra                      ; ORA T             ; sign of the original delta, as the delta is the
     1C7E 00D1     
5865 1C80 DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; dominant figure in the sum
     1C82 0055     
5866               
5867               MV11:
5868 1C84 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1C86 FE2A     
5869               
5870               * ******************************************************************************
5871               *
5872               * Name: MVT3
5873               * Type: Subroutine
5874               * Category: Moving
5875               * Summary: Calculate K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5876               *
5877               * ------------------------------------------------------------------------------
5878               *
5879               * Add an INWK position coordinate - i.e. x, y or z - to K(3 2 1), like this:
5880               *
5881               * K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5882               *
5883               * The INWK coordinate to add to K(3 2 1) is specified by X.
5884               *
5885               * ------------------------------------------------------------------------------
5886               *
5887               * Arguments:
5888               *
5889               * X                   The coordinate to add to K(3 2 1), as follows:
5890               *
5891               * * If X = 0, add (x_sign x_hi x_lo)
5892               *
5893               * * If X = 3, add (y_sign y_hi y_lo)
5894               *
5895               * * If X = 6, add (z_sign z_hi z_lo)
5896               *
5897               * ------------------------------------------------------------------------------
5898               *
5899               * Returns:
5900               *
5901               * A                   Contains a copy of the high byte of the result, K+3
5902               *
5903               * X                   X is preserved
5904               *
5905               * ******************************************************************************
5906               
5907               MVT3:
5908 1C88 D360  22        movb @K+3,ra                    ; LDA K+3           ; Set S = K+3
     1C8A 0040     
5909 1C8C D80D  22        movb ra,@S                      ; STA S
     1C8E 0092     
5910               
5911 1C90 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Set T = sign bit of K(3 2 1)
     1C92 8000     
5912 1C94 D80D  22        movb ra,@T                      ; STA T
     1C96 00D1     
5913               
5914                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If x_sign has a different sign to K(3 2 1), jump to
     **** ****     > EOR
0001 1C98 D02E  26        movb @INWK+2(RX),rtmp
     1C9A 0055     
0002 1C9C 2B40  14        xor  rtmp,ra
                   < elite.a99
5915 1C9E 111F  10        jlt  MV13                       ; BMI MV13          ; MV13 to process the addition as a subtraction
5916               
5917 1CA0 D360  22        movb @K+1,ra                    ; LDA K+1           ; Set K(3 2 1) = K(3 2 1) + (x_sign x_hi x_lo)
     1CA2 003E     
5918                      .clc                            ; CLC               ; starting with the low bytes
     **** ****     > CLC
0001 1CA4 0A16  14        sla  rzero,1
                   < elite.a99
5919                      .adc @INWK(rx),ra               ; ADC INWK,X
     **** ****     > ADC
0001 1CA6 1701  10        jnc  !
0002 1CA8 B347  14        ab   rone,ra
0003               !:
0004 1CAA B36E  26        ab   @INWK(RX),ra
     1CAC 0053     
                   < elite.a99
5920 1CAE D80D  22        movb ra,@K+1                    ; STA K+1
     1CB0 003E     
5921               
5922 1CB2 D360  22        movb @K+2,ra                    ; LDA K+2           ; Then the middle bytes
     1CB4 003F     
5923                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X
     **** ****     > ADC
0001 1CB6 1701  10        jnc  !
0002 1CB8 B347  14        ab   rone,ra
0003               !:
0004 1CBA B36E  26        ab   @INWK+1(RX),ra
     1CBC 0054     
                   < elite.a99
5924 1CBE D80D  22        movb ra,@K+2                    ; STA K+2
     1CC0 003F     
5925               
5926 1CC2 D360  22        movb @K+3,ra                    ; LDA K+3           ; And finally the high bytes
     1CC4 0040     
5927                      .adc @INWK+2(rx),ra             ; ADC INWK+2,X
     **** ****     > ADC
0001 1CC6 1701  10        jnc  !
0002 1CC8 B347  14        ab   rone,ra
0003               !:
0004 1CCA B36E  26        ab   @INWK+2(RX),ra
     1CCC 0055     
                   < elite.a99
5928               
5929 1CCE 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Setting the sign bit of K+3 to T, the original sign
     1CD0 7F00     
5930 1CD2 F360  22        socb @T,ra                      ; ORA T             ; of K(3 2 1)
     1CD4 00D1     
5931 1CD6 D80D  22        movb ra,@K+3                    ; STA K+3
     1CD8 0040     
5932               
5933 1CDA 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1CDC FE2A     
5934               
5935               MV13:
5936 1CDE D360  22        movb @S,ra                      ; LDA S             ; Set S = |K+3| (i.e. K+3 with the sign bit cleared)
     1CE0 0092     
5937 1CE2 024D  14        andi ra,>7f*256                 ; AND #%01111111
     1CE4 7F00     
5938 1CE6 D80D  22        movb ra,@S                      ; STA S
     1CE8 0092     
5939               
5940 1CEA D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Set K(3 2 1) = (x_sign x_hi x_lo) - K(3 2 1)
     1CEC 0053     
5941                      .sec                            ; SEC               ; starting with the low bytes
     **** ****     > SEC
0001 1CEE 0A18  14        sla  rmone,1
                   < elite.a99
5942                      .sbc @K+1,ra                    ; SBC K+1
     **** ****     > SBC
0001 1CF0 1801  10        joc  !
0002 1CF2 7347  14        sb   rone,ra
0003               !:
0004 1CF4 7360  22        sb   @K+1,ra
     1CF6 003E     
                   < elite.a99
5943 1CF8 D80D  22        movb ra,@K+1                    ; STA K+1
     1CFA 003E     
5944               
5945 1CFC D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then the middle bytes
     1CFE 0054     
5946                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1D00 1801  10        joc  !
0002 1D02 7347  14        sb   rone,ra
0003               !:
0004 1D04 7360  22        sb   @K+2,ra
     1D06 003F     
                   < elite.a99
5947 1D08 D80D  22        movb ra,@K+2                    ; STA K+2
     1D0A 003F     
5948               
5949 1D0C D36E  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally the high bytes, doing A = |x_sign| - |K+3|
     1D0E 0055     
5950 1D10 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; and setting the C flag for testing below
     1D12 7F00     
5951                      .sbc @S,ra                      ; SBC S
     **** ****     > SBC
0001 1D14 1801  10        joc  !
0002 1D16 7347  14        sb   rone,ra
0003               !:
0004 1D18 7360  22        sb   @S,ra
     1D1A 0092     
                   < elite.a99
5952               
5953 1D1C 026D  14        ori  ra,>80*256                 ; ORA #%10000000    ; Set the sign bit of K+3 to the opposite sign of T,
     1D1E 8000     
5954                      .eor @T                         ; EOR T             ; i.e. the opposite sign to the original K(3 2 1)
     **** ****     > EOR
0001 1D20 D020  22        movb @T,rtmp
     1D22 00D1     
0002 1D24 2B40  14        xor  rtmp,ra
                   < elite.a99
5955 1D26 D80D  22        movb ra,@K+3                    ; STA K+3
     1D28 0040     
5956               
5957 1D2A 181C  10        joc  MV14                       ; BCS MV14          ; If the C flag is set, i.e. |x_sign| >= |K+3|, then
5958                                                                          ; the sign of K(3 2 1). In this case, we want the
5959                                                                          ; result to have the same sign as the largest argument,
5960                                                                          ; which is (x_sign x_hi x_lo), which we know has the
5961                                                                          ; opposite sign to K(3 2 1), and that's what we just set
5962                                                                          ; the sign of K(3 2 1) to... so we can jump to MV14 to
5963                                                                          ; return from the subroutine
5964               
5965 1D2C 020D  12        li   ra,>01*256                 ; LDA #1            ; We need to swap the sign of the result in K(3 2 1),
     1D2E 0100     
5966                      .sbc @K+1,ra                    ; SBC K+1           ; which we do by calculating 0 - K(3 2 1), which we can
     **** ****     > SBC
0001 1D30 1801  10        joc  !
0002 1D32 7347  14        sb   rone,ra
0003               !:
0004 1D34 7360  22        sb   @K+1,ra
     1D36 003E     
                   < elite.a99
5967 1D38 D80D  22        movb ra,@K+1                    ; STA K+1           ; do with 1 - C - K(3 2 1), as we know the C flag is
     1D3A 003E     
5968                                                                          ; clear. We start with the low bytes
5969               
5970 1D3C 020D  12        li   ra,>00*256                 ; LDA #0            ; Then the middle bytes
     1D3E 0000     
5971                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1D40 1801  10        joc  !
0002 1D42 7347  14        sb   rone,ra
0003               !:
0004 1D44 7360  22        sb   @K+2,ra
     1D46 003F     
                   < elite.a99
5972 1D48 D80D  22        movb ra,@K+2                    ; STA K+2
     1D4A 003F     
5973               
5974 1D4C 020D  12        li   ra,>00*256                 ; LDA #0            ; And finally the high bytes
     1D4E 0000     
5975                      .sbc @K+3,ra                    ; SBC K+3
     **** ****     > SBC
0001 1D50 1801  10        joc  !
0002 1D52 7347  14        sb   rone,ra
0003               !:
0004 1D54 7360  22        sb   @K+3,ra
     1D56 0040     
                   < elite.a99
5976               
5977 1D58 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Set the sign bit of K+3 to the same sign as T,
     1D5A 7F00     
5978 1D5C F360  22        socb @T,ra                      ; ORA T             ; i.e. the same sign as the original K(3 2 1), as
     1D5E 00D1     
5979 1D60 D80D  22        movb ra,@K+3                    ; STA K+3           ; that's the largest argument
     1D62 0040     
5980               
5981               MV14:
5982 1D64 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1D66 FE2A     
5983               
5984               * ******************************************************************************
5985               *
5986               * Name: MVS4
5987               * Type: Subroutine
5988               * Category: Moving
5989               * Summary: Apply pitch and roll to an orientation vector
5990               * Deep dive: Orientation vectors
5991               * Pitching and rolling
5992               *
5993               * ------------------------------------------------------------------------------
5994               *
5995               * Apply pitch and roll angles alpha and beta to the orientation vector in Y.
5996               *
5997               * Specifically, this routine rotates a point (x, y, z) around the origin by
5998               * pitch alpha and roll beta, using the small angle approximation to make the
5999               * maths easier, and incorporating the Minsky circle algorithm to make the
6000               * rotation more stable (though more elliptic).
6001               *
6002               * If that paragraph makes sense to you, then you should probably be writing
6003               * this commentary! For the rest of us, there's a detailed explanation of all
6004               * this in the deep dive on "Pitching and rolling".
6005               *
6006               * ------------------------------------------------------------------------------
6007               *
6008               * Arguments:
6009               *
6010               * Y                   Determines which of the INWK orientation vectors to
6011               * transform:
6012               *
6013               * * Y = 9 rotates nosev: (nosev_x, nosev_y, nosev_z)
6014               *
6015               * * Y = 15 rotates roofv: (roofv_x, roofv_y, roofv_z)
6016               *
6017               * * Y = 21 rotates sidev: (sidev_x, sidev_y, sidev_z)
6018               *
6019               * ******************************************************************************
6020               
6021               MVS4:
6022 1D68 D360  22        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = alpha (the roll angle to rotate through)
     1D6A 009E     
6023 1D6C D80D  22        movb ra,@Q                      ; STA Q
     1D6E 0090     
6024               
6025 1D70 D3AF  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1D72 0055     
6026 1D74 D80E  22        movb rx,@R                      ; STX R
     1D76 0091     
6027 1D78 D3AF  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1D7A 0056     
6028 1D7C D80E  22        movb rx,@S                      ; STX S
     1D7E 0092     
6029               
6030 1D80 D3AF  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; These instructions have no effect as MAD overwrites
     1D82 0053     
6031 1D84 D80E  22        movb rx,@P                      ; STX P             ; X and P when called, but they set X = P = nosev_x_lo
     1D86 001B     
6032               
6033 1D88 D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Set A = -nosev_x_hi
     1D8A 0054     
6034                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1D8C 0200  12        li   rtmp,(>80*256)
     1D8E 8000     
0002 1D90 2B40  14        xor  rtmp,ra
                   < elite.a99
6035               
6036 1D92 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1D94 44B2     
6037 1D96 06A0  24        bl   @jsr                       ;
     1D98 FE1E     
6038 1D9A DBCD  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = alpha * -nosev_x_hi + nosev_y
     1D9C 0056     
6039 1D9E DBCE  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1DA0 0055     
6040                                                                          ; and store (A X) in nosev_y, so this does:
6041                                                                          ;
6042                                                                          ; nosev_y = nosev_y - alpha * nosev_x_hi
6043               
6044 1DA2 D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DA4 001B     
6045                                                                          ; but it sets P = nosev_y_lo
6046               
6047 1DA6 D3AF  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set (S R) = nosev_x
     1DA8 0053     
6048 1DAA D80E  22        movb rx,@R                      ; STX R
     1DAC 0091     
6049 1DAE D3AF  26        movb @INWK+1(ry),rx             ; LDX INWK+1,Y
     1DB0 0054     
6050 1DB2 D80E  22        movb rx,@S                      ; STX S
     1DB4 0092     
6051               
6052 1DB6 D36F  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1DB8 0056     
6053               
6054 1DBA 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1DBC 44B2     
6055 1DBE 06A0  24        bl   @jsr                       ;
     1DC0 FE1E     
6056 1DC2 DBCD  30        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; = alpha * nosev_y_hi + nosev_x
     1DC4 0054     
6057 1DC6 DBCE  30        movb rx,@INWK(ry)               ; STX INWK,Y        ;
     1DC8 0053     
6058                                                                          ; and store (A X) in nosev_x, so this does:
6059                                                                          ;
6060                                                                          ; nosev_x = nosev_x + alpha * nosev_y_hi
6061               
6062 1DCA D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DCC 001B     
6063                                                                          ; but it sets P = nosev_x_lo
6064               
6065 1DCE D360  22        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta (the pitch angle to rotate through)
     1DD0 002A     
6066 1DD2 D80D  22        movb ra,@Q                      ; STA Q
     1DD4 0090     
6067               
6068 1DD6 D3AF  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1DD8 0055     
6069 1DDA D80E  22        movb rx,@R                      ; STX R
     1DDC 0091     
6070 1DDE D3AF  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1DE0 0056     
6071 1DE2 D80E  22        movb rx,@S                      ; STX S
     1DE4 0092     
6072 1DE6 D3AF  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y
     1DE8 0057     
6073               
6074 1DEA D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1DEC 001B     
6075                                                                          ; but it sets P = nosev_y
6076               
6077 1DEE D36F  26        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; Set A = -nosev_z_hi
     1DF0 0058     
6078                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1DF2 0200  12        li   rtmp,(>80*256)
     1DF4 8000     
0002 1DF6 2B40  14        xor  rtmp,ra
                   < elite.a99
6079               
6080 1DF8 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1DFA 44B2     
6081 1DFC 06A0  24        bl   @jsr                       ;
     1DFE FE1E     
6082 1E00 DBCD  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = beta * -nosev_z_hi + nosev_y
     1E02 0056     
6083 1E04 DBCE  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1E06 0055     
6084                                                                          ; and store (A X) in nosev_y, so this does:
6085                                                                          ;
6086                                                                          ; nosev_y = nosev_y - beta * nosev_z_hi
6087               
6088 1E08 D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1E0A 001B     
6089                                                                          ; but it sets P = nosev_y_lo
6090               
6091 1E0C D3AF  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set (S R) = nosev_z
     1E0E 0057     
6092 1E10 D80E  22        movb rx,@R                      ; STX R
     1E12 0091     
6093 1E14 D3AF  26        movb @INWK+5(ry),rx             ; LDX INWK+5,Y
     1E16 0058     
6094 1E18 D80E  22        movb rx,@S                      ; STX S
     1E1A 0092     
6095               
6096 1E1C D36F  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1E1E 0056     
6097               
6098 1E20 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1E22 44B2     
6099 1E24 06A0  24        bl   @jsr                       ;
     1E26 FE1E     
6100 1E28 DBCD  30        movb ra,@INWK+5(ry)             ; STA INWK+5,Y      ; = beta * nosev_y_hi + nosev_z
     1E2A 0058     
6101 1E2C DBCE  30        movb rx,@INWK+4(ry)             ; STX INWK+4,Y      ;
     1E2E 0057     
6102                                                                          ; and store (A X) in nosev_z, so this does:
6103                                                                          ;
6104                                                                          ; nosev_z = nosev_z + beta * nosev_y_hi
6105               
6106 1E30 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1E32 FE2A     
6107               
6108               * ******************************************************************************
6109               *
6110               * Name: MVS5
6111               * Type: Subroutine
6112               * Category: Moving
6113               * Summary: Apply a 3.6 degree pitch or roll to an orientation vector
6114               * Deep dive: Orientation vectors
6115               * Pitching and rolling by a fixed angle
6116               *
6117               * ------------------------------------------------------------------------------
6118               *
6119               * Pitch or roll a ship by a small, fixed amount (1/16 radians, or 3.6 degrees),
6120               * in a specified direction, by rotating the orientation vectors. The vectors to
6121               * rotate are given in X and Y, and the direction of the rotation is given in
6122               * RAT2. The calculation is as follows:
6123               *
6124               * * If the direction is positive:
6125               *
6126               * X = X * (1 - 1/512) + Y / 16
6127               * Y = Y * (1 - 1/512) - X / 16
6128               *
6129               * * If the direction is negative:
6130               *
6131               * X = X * (1 - 1/512) - Y / 16
6132               * Y = Y * (1 - 1/512) + X / 16
6133               *
6134               * So if X = 15 (roofv_x), Y = 21 (sidev_x) and RAT2 is positive, it does this:
6135               *
6136               * roofv_x = roofv_x * (1 - 1/512)  + sidev_x / 16
6137               * sidev_x = sidev_x * (1 - 1/512)  - roofv_x / 16
6138               *
6139               * ------------------------------------------------------------------------------
6140               *
6141               * Arguments:
6142               *
6143               * X                   The first vector to rotate:
6144               *
6145               * * If X = 15, rotate roofv_x
6146               *
6147               * * If X = 17, rotate roofv_y
6148               *
6149               * * If X = 19, rotate roofv_z
6150               *
6151               * * If X = 21, rotate sidev_x
6152               *
6153               * * If X = 23, rotate sidev_y
6154               *
6155               * * If X = 25, rotate sidev_z
6156               *
6157               * Y                   The second vector to rotate:
6158               *
6159               * * If Y = 9,  rotate nosev_x
6160               *
6161               * * If Y = 11, rotate nosev_y
6162               *
6163               * * If Y = 13, rotate nosev_z
6164               *
6165               * * If Y = 21, rotate sidev_x
6166               *
6167               * * If Y = 23, rotate sidev_y
6168               *
6169               * * If Y = 25, rotate sidev_z
6170               *
6171               * RAT2                The direction of the pitch or roll to perform, positive
6172               * or negative (i.e. the sign of the roll or pitch counter
6173               * in bit 7)
6174               *
6175               * ******************************************************************************
6176               
6177               MVS5:
6178 1E34 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi, clear the sign bit, divide by 2 and
     1E36 0054     
6179 1E38 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     1E3A 7F00     
6180 1E3C 091D  14        srl  ra,1                       ; LSR A             ;
6181 1E3E D80D  22        movb ra,@T                      ; STA T             ; T = |roofv_x_hi| / 2
     1E40 00D1     
6182                                                                          ; = |roofv_x| / 512
6183                                                                          ;
6184                                                                          ; The above is true because:
6185                                                                          ;
6186                                                                          ; |roofv_x| = |roofv_x_hi| * 256 + roofv_x_lo
6187                                                                          ;
6188                                                                          ; so:
6189                                                                          ;
6190                                                                          ; |roofv_x| / 512 = |roofv_x_hi| * 256 / 512
6191                                                                          ; + roofv_x_lo / 512
6192                                                                          ; = |roofv_x_hi| / 2
6193               
6194 1E42 D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Now we do the following subtraction:
     1E44 0053     
6195                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1E46 0A18  14        sla  rmone,1
                   < elite.a99
6196                      .sbc @T,ra                      ; SBC T             ; (S R) = (roofv_x_hi roofv_x_lo) - |roofv_x| / 512
     **** ****     > SBC
0001 1E48 1801  10        joc  !
0002 1E4A 7347  14        sb   rone,ra
0003               !:
0004 1E4C 7360  22        sb   @T,ra
     1E4E 00D1     
                   < elite.a99
6197 1E50 D80D  22        movb ra,@R                      ; STA R             ; = (1 - 1/512) * roofv_x
     1E52 0091     
6198                                                                          ;
6199                                                                          ; by doing the low bytes first
6200               
6201 1E54 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes (the high byte of the right
     1E56 0054     
6202                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 1E58 1801  10        joc  !
0002 1E5A 7347  14        sb   rone,ra
0003               !:
0004 1E5C 022D  14        ai   ra,-(>00*256)
     1E5E 0000     
                   < elite.a99
6203 1E60 D80D  22        movb ra,@S                      ; STA S
     1E62 0092     
6204               
6205 1E64 D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set P = nosev_x_lo
     1E66 0053     
6206 1E68 D80D  22        movb ra,@P                      ; STA P
     1E6A 001B     
6207               
6208 1E6C D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch the sign of nosev_x_hi (bit 7) and store in T
     1E6E 0054     
6209 1E70 024D  14        andi ra,>80*256                 ; AND #%10000000
     1E72 8000     
6210 1E74 D80D  22        movb ra,@T                      ; STA T
     1E76 00D1     
6211               
6212 1E78 D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi into A and clear the sign bit, so
     1E7A 0054     
6213 1E7C 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; A = |nosev_x_hi|
     1E7E 7F00     
6214               
6215 1E80 091D  14        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6216 1E82 0204  12        li   rarg1,P                    ; ROR P             ; = |nosev_x_hi nosev_x_lo| / 16
     1E84 001B     
6217 1E86 06A0  24        bl   @ror                       ;
     1E88 FE70     
6218 1E8A 091D  14        srl  ra,1                       ; LSR A             ; = |nosev_x| / 16
6219 1E8C 0204  12        li   rarg1,P                    ; ROR P
     1E8E 001B     
6220 1E90 06A0  24        bl   @ror                       ;
     1E92 FE70     
6221 1E94 091D  14        srl  ra,1                       ; LSR A
6222 1E96 0204  12        li   rarg1,P                    ; ROR P
     1E98 001B     
6223 1E9A 06A0  24        bl   @ror                       ;
     1E9C FE70     
6224 1E9E 091D  14        srl  ra,1                       ; LSR A
6225 1EA0 0204  12        li   rarg1,P                    ; ROR P
     1EA2 001B     
6226 1EA4 06A0  24        bl   @ror                       ;
     1EA6 FE70     
6227               
6228 1EA8 F360  22        socb @T,ra                      ; ORA T             ; Set the sign of A to the sign in T (i.e. the sign of
     1EAA 00D1     
6229                                                                          ; the original nosev_x), so now:
6230                                                                          ;
6231                                                                          ; (A P) = nosev_x / 16
6232               
6233                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 1EAC D020  22        movb @RAT2,rtmp
     1EAE 00AB     
0002 1EB0 2B40  14        xor  rtmp,ra
                   < elite.a99
6234                                                                          ; by the pitch or roll direction
6235               
6236 1EB2 D80E  22        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     1EB4 0090     
6237                                                                          ; call to ADD
6238               
6239 1EB6 0200  12        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     1EB8 44BA     
6240 1EBA 06A0  24        bl   @jsr                       ;
     1EBC FE1E     
6241                                                                          ; = +/-nosev_x / 16 + (1 - 1/512) * roofv_x
6242               
6243 1EBE D80D  22        movb ra,@K+1                    ; STA K+1           ; Set K(1 0) = (1 - 1/512) * roofv_x +/- nosev_x / 16
     1EC0 003E     
6244 1EC2 D80E  22        movb rx,@K                      ; STX K
     1EC4 003D     
6245               
6246 1EC6 D3A0  22        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     1EC8 0090     
6247               
6248 1ECA D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi, clear the sign bit, divide by 2 and
     1ECC 0054     
6249 1ECE 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     1ED0 7F00     
6250 1ED2 091D  14        srl  ra,1                       ; LSR A             ;
6251 1ED4 D80D  22        movb ra,@T                      ; STA T             ; T = |nosev_x_hi| / 2
     1ED6 00D1     
6252                                                                          ; = |nosev_x| / 512
6253               
6254 1ED8 D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Now we do the following subtraction:
     1EDA 0053     
6255                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1EDC 0A18  14        sla  rmone,1
                   < elite.a99
6256                      .sbc @T,ra                      ; SBC T             ; (S R) = (nosev_x_hi nosev_x_lo) - |nosev_x| / 512
     **** ****     > SBC
0001 1EDE 1801  10        joc  !
0002 1EE0 7347  14        sb   rone,ra
0003               !:
0004 1EE2 7360  22        sb   @T,ra
     1EE4 00D1     
                   < elite.a99
6257 1EE6 D80D  22        movb ra,@R                      ; STA R             ; = (1 - 1/512) * nosev_x
     1EE8 0091     
6258                                                                          ;
6259                                                                          ; by doing the low bytes first
6260               
6261 1EEA D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; And then the high bytes (the high byte of the right
     1EEC 0054     
6262                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 1EEE 1801  10        joc  !
0002 1EF0 7347  14        sb   rone,ra
0003               !:
0004 1EF2 022D  14        ai   ra,-(>00*256)
     1EF4 0000     
                   < elite.a99
6263 1EF6 D80D  22        movb ra,@S                      ; STA S
     1EF8 0092     
6264               
6265 1EFA D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = roofv_x_lo
     1EFC 0053     
6266 1EFE D80D  22        movb ra,@P                      ; STA P
     1F00 001B     
6267               
6268 1F02 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch the sign of roofv_x_hi (bit 7) and store in T
     1F04 0054     
6269 1F06 024D  14        andi ra,>80*256                 ; AND #%10000000
     1F08 8000     
6270 1F0A D80D  22        movb ra,@T                      ; STA T
     1F0C 00D1     
6271               
6272 1F0E D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi into A and clear the sign bit, so
     1F10 0054     
6273 1F12 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; A = |roofv_x_hi|
     1F14 7F00     
6274               
6275 1F16 091D  14        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6276 1F18 0204  12        li   rarg1,P                    ; ROR P             ; = |roofv_x_hi roofv_x_lo| / 16
     1F1A 001B     
6277 1F1C 06A0  24        bl   @ror                       ;
     1F1E FE70     
6278 1F20 091D  14        srl  ra,1                       ; LSR A             ; = |roofv_x| / 16
6279 1F22 0204  12        li   rarg1,P                    ; ROR P
     1F24 001B     
6280 1F26 06A0  24        bl   @ror                       ;
     1F28 FE70     
6281 1F2A 091D  14        srl  ra,1                       ; LSR A
6282 1F2C 0204  12        li   rarg1,P                    ; ROR P
     1F2E 001B     
6283 1F30 06A0  24        bl   @ror                       ;
     1F32 FE70     
6284 1F34 091D  14        srl  ra,1                       ; LSR A
6285 1F36 0204  12        li   rarg1,P                    ; ROR P
     1F38 001B     
6286 1F3A 06A0  24        bl   @ror                       ;
     1F3C FE70     
6287               
6288 1F3E F360  22        socb @T,ra                      ; ORA T             ; Set the sign of A to the opposite sign to T (i.e. the
     1F40 00D1     
6289                      .eoi (>80*256)                  ; EOR #%10000000    ; sign of the original -roofv_x), so now:
     **** ****     > EOI
0001 1F42 0200  12        li   rtmp,(>80*256)
     1F44 8000     
0002 1F46 2B40  14        xor  rtmp,ra
                   < elite.a99
6290                                                                          ;
6291                                                                          ; (A P) = -roofv_x / 16
6292               
6293                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 1F48 D020  22        movb @RAT2,rtmp
     1F4A 00AB     
0002 1F4C 2B40  14        xor  rtmp,ra
                   < elite.a99
6294                                                                          ; by the pitch or roll direction
6295               
6296 1F4E D80E  22        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     1F50 0090     
6297                                                                          ; call to ADD
6298               
6299 1F52 0200  12        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     1F54 44BA     
6300 1F56 06A0  24        bl   @jsr                       ;
     1F58 FE1E     
6301                                                                          ; = -/+roofv_x / 16 + (1 - 1/512) * nosev_x
6302               
6303 1F5A DBCD  30        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; Set nosev_x = (1-1/512) * nosev_x -/+ roofv_x / 16
     1F5C 0054     
6304 1F5E DBCE  30        movb rx,@INWK(ry)               ; STX INWK,Y
     1F60 0053     
6305               
6306 1F62 D3A0  22        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     1F64 0090     
6307               
6308 1F66 D360  22        movb @K,ra                      ; LDA K             ; Set roofv_x = K(1 0)
     1F68 003D     
6309 1F6A DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; = (1-1/512) * roofv_x +/- nosev_x / 16
     1F6C 0053     
6310 1F6E D360  22        movb @K+1,ra                    ; LDA K+1
     1F70 003E     
6311 1F72 DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X
     1F74 0054     
6312               
6313 1F76 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1F78 FE2A     
6314               
6315               * ******************************************************************************
6316               *
6317               * Name: MVT6
6318               * Type: Subroutine
6319               * Category: Moving
6320               * Summary: Calculate (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6321               *
6322               * ------------------------------------------------------------------------------
6323               *
6324               * Do the following calculation, for the coordinate given by X (so this is what
6325               * it does for the x-coordinate):
6326               *
6327               * (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6328               *
6329               * A is a sign bit and is not included in the calculation, but bits 0-6 of A are
6330               * preserved. Bit 7 is set to the sign of the result.
6331               *
6332               * ------------------------------------------------------------------------------
6333               *
6334               * Arguments:
6335               *
6336               * A                   The sign of P(2 1) in bit 7
6337               *
6338               * P(2 1)              The 16-bit value we want to add the coordinate to
6339               *
6340               * X                   The coordinate to add, as follows:
6341               *
6342               * * If X = 0, add to (x_sign x_hi x_lo)
6343               *
6344               * * If X = 3, add to (y_sign y_hi y_lo)
6345               *
6346               * * If X = 6, add to (z_sign z_hi z_lo)
6347               *
6348               * ------------------------------------------------------------------------------
6349               *
6350               * Returns:
6351               *
6352               * A                   The sign of the result (in bit 7)
6353               *
6354               * ******************************************************************************
6355               
6356               MVT6:
6357 1F7A D3CD  14        movb ra,ry                      ; TAY               ; Store argument A into Y, for later use
6358               
6359                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; Set A = A EOR x_sign
     **** ****     > EOR
0001 1F7C D02E  26        movb @INWK+2(RX),rtmp
     1F7E 0055     
0002 1F80 2B40  14        xor  rtmp,ra
                   < elite.a99
6360               
6361 1F82 1114  10        jlt  MV50                       ; BMI MV50          ; If the sign is negative, i.e. A and x_sign have
6362                                                                          ; different signs, jump to MV50
6363               
6364                                                                          ; The signs are the same, so we can add the two
6365                                                                          ; arguments and keep the sign to get the result
6366               
6367 1F84 D360  22        movb @P+1,ra                    ; LDA P+1           ; First we add the low bytes:
     1F86 001C     
6368                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 1F88 0A16  14        sla  rzero,1
                   < elite.a99
6369                      .adc @INWK(rx),ra               ; ADC INWK,X        ; P+1 = P+1 + x_lo
     **** ****     > ADC
0001 1F8A 1701  10        jnc  !
0002 1F8C B347  14        ab   rone,ra
0003               !:
0004 1F8E B36E  26        ab   @INWK(RX),ra
     1F90 0053     
                   < elite.a99
6370 1F92 D80D  22        movb ra,@P+1                    ; STA P+1
     1F94 001C     
6371               
6372 1F96 D360  22        movb @P+2,ra                    ; LDA P+2           ; And then the high bytes:
     1F98 001D     
6373                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 1F9A 1701  10        jnc  !
0002 1F9C B347  14        ab   rone,ra
0003               !:
0004 1F9E B36E  26        ab   @INWK+1(RX),ra
     1FA0 0054     
                   < elite.a99
6374 1FA2 D80D  22        movb ra,@P+2                    ; STA P+2           ; P+2 = P+2 + x_hi
     1FA4 001D     
6375               
6376 1FA6 D34F  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6377                                                                          ; so that we keep the original sign
6378               
6379 1FA8 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1FAA FE2A     
6380               
6381               MV50:
6382 1FAC D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes:
     1FAE 0053     
6383                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1FB0 0A18  14        sla  rmone,1
                   < elite.a99
6384                      .sbc @P+1,ra                    ; SBC P+1           ; P+1 = x_lo - P+1
     **** ****     > SBC
0001 1FB2 1801  10        joc  !
0002 1FB4 7347  14        sb   rone,ra
0003               !:
0004 1FB6 7360  22        sb   @P+1,ra
     1FB8 001C     
                   < elite.a99
6385 1FBA D80D  22        movb ra,@P+1                    ; STA P+1
     1FBC 001C     
6386               
6387 1FBE D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes:
     1FC0 0054     
6388                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 1FC2 1801  10        joc  !
0002 1FC4 7347  14        sb   rone,ra
0003               !:
0004 1FC6 7360  22        sb   @P+2,ra
     1FC8 001D     
                   < elite.a99
6389 1FCA D80D  22        movb ra,@P+2                    ; STA P+2           ; P+2 = x_hi - P+2
     1FCC 001D     
6390               
6391 1FCE 1706  10        jnc  MV51                       ; BCC MV51          ; If the last subtraction underflowed, then the C flag
6392                                                                          ; will be clear and x_hi < P+2, so jump to MV51 to
6393                                                                          ; negate the result
6394               
6395 1FD0 D34F  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6396                      .eoi (>80*256)                  ; EOR #%10000000    ; but flip bit 7, which flips the sign. We do this
     **** ****     > EOI
0001 1FD2 0200  12        li   rtmp,(>80*256)
     1FD4 8000     
0002 1FD6 2B40  14        xor  rtmp,ra
                   < elite.a99
6397                                                                          ; because x_hi >= P+2 so we want the result to have the
6398                                                                          ; same sign as x_hi (as it's the dominant side in this
6399                                                                          ; calculation). The sign of x_hi is x_sign, and x_sign
6400                                                                          ; has the opposite sign to A, so we flip the sign in A
6401                                                                          ; to return the correct result
6402               
6403 1FD8 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1FDA FE2A     
6404               
6405               MV51:
6406 1FDC 020D  12        li   ra,>01*256                 ; LDA #1            ; Our subtraction underflowed, so we negate the result
     1FDE 0100     
6407                      .sbc @P+1,ra                    ; SBC P+1           ; using two's complement, first with the low byte:
     **** ****     > SBC
0001 1FE0 1801  10        joc  !
0002 1FE2 7347  14        sb   rone,ra
0003               !:
0004 1FE4 7360  22        sb   @P+1,ra
     1FE6 001C     
                   < elite.a99
6408 1FE8 D80D  22        movb ra,@P+1                    ; STA P+1           ;
     1FEA 001C     
6409                                                                          ; P+1 = 1 - P+1
6410               
6411 1FEC 020D  12        li   ra,>00*256                 ; LDA #0            ; And then the high byte:
     1FEE 0000     
6412                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 1FF0 1801  10        joc  !
0002 1FF2 7347  14        sb   rone,ra
0003               !:
0004 1FF4 7360  22        sb   @P+2,ra
     1FF6 001D     
                   < elite.a99
6413 1FF8 D80D  22        movb ra,@P+2                    ; STA P+2           ; P+2 = 0 - P+2
     1FFA 001D     
6414               
6415 1FFC D34F  14        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6416                                                                          ; as this is the correct sign for the result. This is
6417                                                                          ; because x_hi < P+2, so we want to return the same sign
6418                                                                          ; as P+2, the dominant side
6419               
6420 1FFE 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     2000 FE2A     
6421               
6422               * ******************************************************************************
6423               *
6424               * Name: MV40
6425               * Type: Subroutine
6426               * Category: Moving
6427               * Summary: Rotate the planet or sun's location in space by the amount of
6428               * pitch and roll of our ship
6429               * Deep dive: Rotating the universe
6430               *
6431               * ------------------------------------------------------------------------------
6432               *
6433               * We implement this using the same equations as in part 5 of MVEIT, where we
6434               * rotated the current ship's location by our pitch and roll. Specifically, the
6435               * calculation is as follows:
6436               *
6437               * 1. K2 = y - alpha * x
6438               * 2. z = z + beta * K2
6439               * 3. y = K2 - beta * z
6440               * 4. x = x + alpha * y
6441               *
6442               * See the deep dive on "Rotating the universe" for more details on the above.
6443               *
6444               * ******************************************************************************
6445               
6446               MV40:
6447 2002 D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = -ALPHA, so Q contains the angle we want to
     2004 009E     
6448                      .eoi (>80*256)                  ; EOR #%10000000    ; roll the planet through (i.e. in the opposite
     **** ****     > EOI
0001 2006 0200  20        li   rtmp,(>80*256)
     2008 8000     
0002 200A 2B40  18        xor  rtmp,ra
                   < elite.a99
6449 200C D80D  30        movb ra,@Q                      ; STA Q             ; direction to our ship's roll angle alpha)
     200E 0090     
6450               
6451 2010 D360  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     2012 0053     
6452 2014 D80D  30        movb ra,@P                      ; STA P
     2016 001B     
6453 2018 D360  30        movb @INWK+1,ra                 ; LDA INWK+1
     201A 0054     
6454 201C D80D  30        movb ra,@P+1                    ; STA P+1
     201E 001C     
6455               
6456 2020 D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     2022 0055     
6457               
6458 2024 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     2026 4148     
6459 2028 06A0  32        bl   @jsr                       ;
     202A FE1E     
6460                                                                          ;
6461                                                                          ; which also means:
6462                                                                          ;
6463                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6464                                                                          ; = x * -alpha / 256
6465                                                                          ; = - alpha * x / 256
6466               
6467 202C 020E  20        li   rx,>03*256                 ; LDX #3            ; Set K(3 2 1) = (y_sign y_hi y_lo) + K(3 2 1)
     202E 0300     
6468 2030 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; = y - alpha * x / 256
     2032 1C88     
6469 2034 06A0  32        bl   @jsr                       ;
     2036 FE1E     
6470               
6471 2038 D360  30        movb @K+1,ra                    ; LDA K+1           ; Set K2(2 1) = P(1 0) = K(2 1)
     203A 003E     
6472 203C D80D  30        movb ra,@K2+1                   ; STA K2+1
     203E 00AD     
6473 2040 D80D  30        movb ra,@P                      ; STA P
     2042 001B     
6474               
6475 2044 D360  30        movb @K+2,ra                    ; LDA K+2           ; Set K2+2 = K+2
     2046 003F     
6476 2048 D80D  30        movb ra,@K2+2                   ; STA K2+2
     204A 00AE     
6477               
6478 204C D80D  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = K+2
     204E 001C     
6479               
6480 2050 D360  30        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta, the pitch angle of our ship
     2052 002A     
6481 2054 D80D  30        movb ra,@Q                      ; STA Q
     2056 0090     
6482               
6483 2058 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to K2+3, so now we have result 1 above:
     205A 0040     
6484 205C D80D  30        movb ra,@K2+3                   ; STA K2+3          ;
     205E 00AF     
6485                                                                          ; K2(3 2 1) = K(3 2 1)
6486                                                                          ; = y - alpha * x / 256
6487               
6488                                                                          ; We also have:
6489                                                                          ;
6490                                                                          ; A = K+3
6491                                                                          ;
6492                                                                          ; P(1 0) = K(2 1)
6493                                                                          ;
6494                                                                          ; so combined, these mean:
6495                                                                          ;
6496                                                                          ; (A P+1 P) = K(3 2 1)
6497                                                                          ; = K2(3 2 1)
6498               
6499 2060 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     2062 4148     
6500 2064 06A0  32        bl   @jsr                       ;
     2066 FE1E     
6501                                                                          ;
6502                                                                          ; which also means:
6503                                                                          ;
6504                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6505                                                                          ; = K2(3 2 1) * beta / 256
6506                                                                          ; = beta * K2 / 256
6507               
6508 2068 020E  20        li   rx,>06*256                 ; LDX #6            ; K(3 2 1) = (z_sign z_hi z_lo) + K(3 2 1)
     206A 0600     
6509 206C 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; = z + beta * K2 / 256
     206E 1C88     
6510 2070 06A0  32        bl   @jsr                       ;
     2072 FE1E     
6511               
6512 2074 D360  30        movb @K+1,ra                    ; LDA K+1           ; Set P = K+1
     2076 003E     
6513 2078 D80D  30        movb ra,@P                      ; STA P
     207A 001B     
6514               
6515 207C D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; Set z_lo = K+1
     207E 0059     
6516               
6517 2080 D360  30        movb @K+2,ra                    ; LDA K+2           ; Set P+1 = K+2
     2082 003F     
6518 2084 D80D  30        movb ra,@P+1                    ; STA P+1
     2086 001C     
6519               
6520 2088 D80D  30        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi = K+2
     208A 005A     
6521               
6522 208C D360  30        movb @K+3,ra                    ; LDA K+3           ; Set A = z_sign = K+3, so now we have:
     208E 0040     
6523 2090 D80D  30        movb ra,@INWK+8                 ; STA INWK+8        ;
     2092 005B     
6524                                                                          ; (z_sign z_hi z_lo) = K(3 2 1)
6525                                                                          ; = z + beta * K2 / 256
6526               
6527                                                                          ; So we now have result 2 above:
6528                                                                          ;
6529                                                                          ; z = z + beta * K2
6530               
6531                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit of A to give A = -z_sign
     **** ****     > EOI
0001 2094 0200  20        li   rtmp,(>80*256)
     2096 8000     
0002 2098 2B40  18        xor  rtmp,ra
                   < elite.a99
6532               
6533 209A 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     209C 4148     
6534 209E 06A0  32        bl   @jsr                       ;
     20A0 FE1E     
6535                                                                          ; = (-z_sign z_hi z_lo) * beta
6536                                                                          ; = -z * beta
6537               
6538 20A2 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set T to the sign bit of K(3 2 1 0), i.e. to the sign
     20A4 0040     
6539 20A6 024D  22        andi ra,>80*256                 ; AND #%10000000    ; bit of -z * beta
     20A8 8000     
6540 20AA D80D  30        movb ra,@T                      ; STA T
     20AC 00D1     
6541               
6542                      .eor @K2+3                      ; EOR K2+3          ; If K2(3 2 1 0) has a different sign to K(3 2 1 0),
     **** ****     > EOR
0001 20AE D020  30        movb @K2+3,rtmp
     20B0 00AF     
0002 20B2 2B40  18        xor  rtmp,ra
                   < elite.a99
6543 20B4 111E  14        jlt  MV1                        ; BMI MV1           ; then EOR'ing them will produce a 1 in bit 7, so jump
6544                                                                          ; to MV1 to take this into account
6545               
6546                                                                          ; If we get here, K and K2 have the same sign, so we can
6547                                                                          ; add them together to get the result we're after, and
6548                                                                          ; then set the sign afterwards
6549               
6550 20B6 D360  30        movb @K,ra                      ; LDA K             ; We now do the following sum:
     20B8 003D     
6551               * CLC                    \
6552                      .adc @K2,ra                     ; ADC K2            ; (A y_hi y_lo -) = K(3 2 1 0) + K2(3 2 1 0)
     **** ****     > ADC
0001 20BA 1701  14        jnc  !
0002 20BC B347  18        ab   rone,ra
0003               !:
0004 20BE B360  30        ab   @K2,ra
     20C0 00AC     
                   < elite.a99
6553                                                                          ;
6554                                                                          ; starting with the low bytes (which we don't keep)
6555                                                                          ;
6556                                                                          ; The CLC instruction is commented out in the original
6557                                                                          ; source. It isn't needed because MULT3 clears the C
6558                                                                          ; flag, so this is an example of the authors finding
6559                                                                          ; one more precious byte to save
6560               
6561 20C2 D360  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     20C4 003E     
6562                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 20C6 1701  14        jnc  !
0002 20C8 B347  18        ab   rone,ra
0003               !:
0004 20CA B360  30        ab   @K2+1,ra
     20CC 00AD     
                   < elite.a99
6563 20CE D80D  30        movb ra,@INWK+3                 ; STA INWK+3
     20D0 0056     
6564               
6565 20D2 D360  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     20D4 003F     
6566                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 20D6 1701  14        jnc  !
0002 20D8 B347  18        ab   rone,ra
0003               !:
0004 20DA B360  30        ab   @K2+2,ra
     20DC 00AE     
                   < elite.a99
6567 20DE D80D  30        movb ra,@INWK+4                 ; STA INWK+4
     20E0 0057     
6568               
6569 20E2 D360  30        movb @K+3,ra                    ; LDA K+3           ; And then the sign bytes into A, so overall we have the
     20E4 0040     
6570                      .adc @K2+3,ra                   ; ADC K2+3          ; following, if we drop the low bytes from the result:
     **** ****     > ADC
0001 20E6 1701  14        jnc  !
0002 20E8 B347  18        ab   rone,ra
0003               !:
0004 20EA B360  30        ab   @K2+3,ra
     20EC 00AF     
                   < elite.a99
6571                                                                          ;
6572                                                                          ; (A y_hi y_lo) = (K + K2) / 256
6573               
6574 20EE 0460  28        b    @MV2                       ; JMP MV2           ; Jump to MV2 to skip the calculation for when K and K2
     20F0 2172     
6575                                                                          ; have different signs
6576               
6577               MV1:
6578 20F2 D360  30        movb @K,ra                      ; LDA K             ; If we get here then K2 and K have different signs, so
     20F4 003D     
6579                      .sec                            ; SEC               ; instead of adding, we need to subtract to get the
     **** ****     > SEC
0001 20F6 0A18  18        sla  rmone,1
                   < elite.a99
6580                      .sbc @K2,ra                     ; SBC K2            ; result we want, like this:
     **** ****     > SBC
0001 20F8 1801  14        joc  !
0002 20FA 7347  18        sb   rone,ra
0003               !:
0004 20FC 7360  30        sb   @K2,ra
     20FE 00AC     
                   < elite.a99
6581                                                                          ;
6582                                                                          ; (A y_hi y_lo -) = K(3 2 1 0) - K2(3 2 1 0)
6583                                                                          ;
6584                                                                          ; starting with the low bytes (which we don't keep)
6585               
6586 2100 D360  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     2102 003E     
6587                      .sbc @K2+1,ra                   ; SBC K2+1
     **** ****     > SBC
0001 2104 1801  14        joc  !
0002 2106 7347  18        sb   rone,ra
0003               !:
0004 2108 7360  30        sb   @K2+1,ra
     210A 00AD     
                   < elite.a99
6588 210C D80D  30        movb ra,@INWK+3                 ; STA INWK+3
     210E 0056     
6589               
6590 2110 D360  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     2112 003F     
6591                      .sbc @K2+2,ra                   ; SBC K2+2
     **** ****     > SBC
0001 2114 1801  14        joc  !
0002 2116 7347  18        sb   rone,ra
0003               !:
0004 2118 7360  30        sb   @K2+2,ra
     211A 00AE     
                   < elite.a99
6592 211C D80D  30        movb ra,@INWK+4                 ; STA INWK+4
     211E 0057     
6593               
6594 2120 D360  30        movb @K2+3,ra                   ; LDA K2+3          ; Now for the sign bytes, so first we extract the sign
     2122 00AF     
6595 2124 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; byte from K2 without the sign bit, so P = |K2+3|
     2126 7F00     
6596 2128 D80D  30        movb ra,@P                      ; STA P
     212A 001B     
6597               
6598 212C D360  30        movb @K+3,ra                    ; LDA K+3           ; And then we extract the sign byte from K without the
     212E 0040     
6599 2130 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |K+3|
     2132 7F00     
6600               
6601                      .sbc @P,ra                      ; SBC P             ; And finally we subtract the sign bytes, so P = A - P
     **** ****     > SBC
0001 2134 1801  14        joc  !
0002 2136 7347  18        sb   rone,ra
0003               !:
0004 2138 7360  30        sb   @P,ra
     213A 001B     
                   < elite.a99
6602 213C D80D  30        movb ra,@P                      ; STA P
     213E 001B     
6603               
6604                                                                          ; By now we have the following, if we drop the low bytes
6605                                                                          ; from the result:
6606                                                                          ;
6607                                                                          ; (A y_hi y_lo) = (K - K2) / 256
6608                                                                          ;
6609                                                                          ; so now we just need to make sure the sign of the
6610                                                                          ; result is correct
6611               
6612 2140 1818  14        joc  MV2                        ; BCS MV2           ; If the C flag is set, then the last subtraction above
6613                                                                          ; didn't underflow and the result is correct, so jump to
6614                                                                          ; MV2 as we are done with this particular stage
6615               
6616 2142 020D  20        li   ra,>01*256                 ; LDA #1            ; Otherwise the subtraction above underflowed, as K2 is
     2144 0100     
6617                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; the dominant part of the subtraction, so we need to
     **** ****     > SBC
0001 2146 1801  14        joc  !
0002 2148 7347  18        sb   rone,ra
0003               !:
0004 214A 7360  30        sb   @INWK+3,ra
     214C 0056     
                   < elite.a99
6618 214E D80D  30        movb ra,@INWK+3                 ; STA INWK+3        ; negate the result using two's complement, starting
     2150 0056     
6619                                                                          ; with the low bytes:
6620                                                                          ;
6621                                                                          ; y_lo = 1 - y_lo
6622               
6623 2152 020D  20        li   ra,>00*256                 ; LDA #0            ; And then the high bytes:
     2154 0000     
6624                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 2156 1801  14        joc  !
0002 2158 7347  18        sb   rone,ra
0003               !:
0004 215A 7360  30        sb   @INWK+4,ra
     215C 0057     
                   < elite.a99
6625 215E D80D  30        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     2160 0057     
6626               
6627 2162 020D  20        li   ra,>00*256                 ; LDA #0            ; And finally the sign bytes:
     2164 0000     
6628                      .sbc @P,ra                      ; SBC P             ;
     **** ****     > SBC
0001 2166 1801  14        joc  !
0002 2168 7347  18        sb   rone,ra
0003               !:
0004 216A 7360  30        sb   @P,ra
     216C 001B     
                   < elite.a99
6629                                                                          ; A = 0 - P
6630               
6631 216E 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now force the sign bit to be negative, so that the
     2170 8000     
6632                                                                          ; final result below gets the opposite sign to K, which
6633                                                                          ; we want as K2 is the dominant part of the sum
6634               
6635               MV2:
6636                      .eor @T                         ; EOR T             ; T contains the sign bit of K, so if K is negative,
     **** ****     > EOR
0001 2172 D020  30        movb @T,rtmp
     2174 00D1     
0002 2176 2B40  18        xor  rtmp,ra
                   < elite.a99
6637                                                                          ; this flips the sign of A
6638               
6639 2178 D80D  30        movb ra,@INWK+5                 ; STA INWK+5        ; Store A in y_sign
     217A 0058     
6640               
6641                                                                          ; So we now have result 3 above:
6642                                                                          ;
6643                                                                          ; y = K2 + K
6644                                                                          ; = K2 - beta * z
6645               
6646 217C D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha
     217E 009E     
6647 2180 D80D  30        movb ra,@Q                      ; STA Q
     2182 0090     
6648               
6649 2184 D360  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     2186 0056     
6650 2188 D80D  30        movb ra,@P                      ; STA P
     218A 001B     
6651 218C D360  30        movb @INWK+4,ra                 ; LDA INWK+4
     218E 0057     
6652 2190 D80D  30        movb ra,@P+1                    ; STA P+1
     2192 001C     
6653               
6654 2194 D360  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = y_sign
     2196 0058     
6655               
6656 2198 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     219A 4148     
6657 219C 06A0  32        bl   @jsr                       ;
     219E FE1E     
6658                                                                          ; = (y_sign y_hi y_lo) * alpha
6659                                                                          ; = y * alpha
6660               
6661 21A0 020E  20        li   rx,>00*256                 ; LDX #0            ; Set K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
     21A2 0000     
6662 21A4 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; = x + y * alpha / 256
     21A6 1C88     
6663 21A8 06A0  32        bl   @jsr                       ;
     21AA FE1E     
6664               
6665 21AC D360  30        movb @K+1,ra                    ; LDA K+1           ; Set (x_sign x_hi x_lo) = K(3 2 1)
     21AE 003E     
6666 21B0 D80D  30        movb ra,@INWK                   ; STA INWK          ; = x + y * alpha / 256
     21B2 0053     
6667 21B4 D360  30        movb @K+2,ra                    ; LDA K+2
     21B6 003F     
6668 21B8 D80D  30        movb ra,@INWK+1                 ; STA INWK+1
     21BA 0054     
6669 21BC D360  30        movb @K+3,ra                    ; LDA K+3
     21BE 0040     
6670 21C0 D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     21C2 0055     
6671               
6672                                                                          ; So we now have result 4 above:
6673                                                                          ;
6674                                                                          ; x = x + y * alpha
6675               
6676 21C4 0460  24        b    @MV45                      ; JMP MV45          ; We have now finished rotating the planet or sun by
     21C6 1A7A     
6677                                                                          ; our pitch and roll, so jump back into the MVEIT
6678                                                                          ; routine at MV45 to apply all the other movements
6679               
6680               * ******************************************************************************
6681               *
6682               * Save ELTA.bin
6683               *
6684               * ******************************************************************************
6685               
6686                      ; PRINT "ELITE A"
6687                      ; PRINT "Assembled at ", ~CODE%
6688                      ; PRINT "Ends at ", ~P%
6689                      ; PRINT "Code size is ", ~(P% - CODE%)
6690                      ; PRINT "Execute at ", ~LOAD%
6691                      ; PRINT "Reload at ", ~LOAD_A%
6692               
6693                      ; PRINT "S.ELTA ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_A%
6694                      ; SAVE "3-assembled-output/ELTA.bin", CODE%, P%, LOAD%
6695               
6696               * ******************************************************************************
6697               *
6698               * ELITE B FILE
6699               *
6700               * Produces the binary file ELTB.bin that gets loaded by elite-bcfs.asm.
6701               *
6702               * ******************************************************************************
6703               
6704               CODE_B.:
6705                      equ $
6706               
6707               LOAD_B.:
6708                      equ LOAD. + $ - CODE.
6709               
6710               * ******************************************************************************
6711               *
6712               * Name: NA%
6713               * Type: Variable
6714               * Category: Save and load
6715               * Summary: The data block for the last saved commander
6716               * Deep dive: Commander save files
6717               * The competition code
6718               *
6719               * ------------------------------------------------------------------------------
6720               *
6721               * Contains the last saved commander data, with the name at NA% and the data at
6722               * NA%+8 onwards. The size of the data block is given in NT% (which also includes
6723               * the two checksum bytes that follow this block). This block is initially set up
6724               * with the default commander, which can be maxed out for testing purposes by
6725               * setting Q% to TRUE.
6726               *
6727               * The commander's name is stored at NA%, and can be up to 7 characters long
6728               * (the DFS filename limit). It is terminated with a carriage return character,
6729               * ASCII 13.
6730               *
6731               * The offset of each byte within a saved commander file is also shown as #0, #1
6732               * and so on, so the kill tally, for example, is in bytes #71 and #72 of the
6733               * saved file. The related variable name from the current commander block is
6734               * also shown.
6735               *
6736               * ******************************************************************************
6737               
6738               NA.:
6739 21C8 4A41            text 'JAMESON'                                      ; The current commander name, which defaults to JAMESON
     21CA 4D45     
     21CC 534F     
     21CE 4E       
6740 21CF   0D            byte >0d                                            ;
6741                                                                          ; The commander name can be up to 7 characters (the DFS
6742                                                                          ; limit for filenames), and is terminated by a carriage
6743                                                                          ; return
6744               
6745                                                                          ; NA%+8 is the start of the commander data block
6746                                                                          ;
6747                                                                          ; This block contains the last saved commander data
6748                                                                          ; block. As the game is played it uses an identical
6749                                                                          ; block at location TP to store the current commander
6750                                                                          ; state, and that block is copied here when the game is
6751                                                                          ; saved. Conversely, when the game starts up, the block
6752                                                                          ; here is copied to TP, which restores the last saved
6753                                                                          ; commander when we die
6754                                                                          ;
6755                                                                          ; The initial state of this block defines the default
6756                                                                          ; commander. Q% can be set to TRUE to give the default
6757                                                                          ; commander lots of credits and equipment
6758               
6759 21D0 00              byte >00                                            ; TP = Mission status, #0
6760               
6761 21D1   14            byte >14                                            ; QQ0 = Current system X-coordinate (Lave), #1
6762 21D2 AD              byte >ad                                            ; QQ1 = Current system Y-coordinate (Lave), #2
6763               
6764 21D4 4A5A            data >4a5a                                          ; QQ21 = Seed s0 for system 0, galaxy 0 (Tibedied), #3-4
6765 21D6 4802            data >4802                                          ; QQ21 = Seed s1 for system 0, galaxy 0 (Tibedied), #5-6
6766 21D8 53B7            data >53b7                                          ; QQ21 = Seed s2 for system 0, galaxy 0 (Tibedied), #7-8
6767               
6771 21DA 0000            data >0000, >0000                                   ; CASH = Amount of cash (100 Cr), #9-12
     21DC 0000     
6773               
6774 21DE 46              byte >46                                            ; QQ14 = Fuel level, #13
6775               
6776 21DF   00            byte >00                                            ; COK = Competition flags, #14
6777               
6778 21E0 00              byte >00                                            ; GCNT = Galaxy number, 0-7, #15
6779               
6780 21E1   0F            byte POW+(128 & Q.)                                 ; LASER = Front laser, #16
6781               
6782 21E2 00              byte (POW+128) & Q.                                 ; LASER+1 = Rear laser, #17
6783               
6784 21E3   00            byte >00                                            ; LASER+2 = Left laser, #18
6785               
6786 21E4 00              byte >00                                            ; LASER+3 = Right laser, #19
6787               
6788 21E6 0000            data >0000                                          ; These bytes appear to be unused (they were originally
6789                                                                          ; used for up/down lasers, but they were dropped),
6790                                                                          ; #20-21
6791               
6792 21E8 16              byte 22 + (15 & Q.)                                 ; CRGO = Cargo capacity, #22
6793               
6794 21E9   00            byte >00                                            ; QQ20+0  = Amount of food in cargo hold, #23
6795 21EA 00              byte >00                                            ; QQ20+1  = Amount of textiles in cargo hold, #24
6796 21EB   00            byte >00                                            ; QQ20+2  = Amount of radioactives in cargo hold, #25
6797 21EC 00              byte >00                                            ; QQ20+3  = Amount of slaves in cargo hold, #26
6798 21ED   00            byte >00                                            ; QQ20+4  = Amount of liquor/Wines in cargo hold, #27
6799 21EE 00              byte >00                                            ; QQ20+5  = Amount of luxuries in cargo hold, #28
6800 21EF   00            byte >00                                            ; QQ20+6  = Amount of narcotics in cargo hold, #29
6801 21F0 00              byte >00                                            ; QQ20+7  = Amount of computers in cargo hold, #30
6802 21F1   00            byte >00                                            ; QQ20+8  = Amount of machinery in cargo hold, #31
6803 21F2 00              byte >00                                            ; QQ20+9  = Amount of alloys in cargo hold, #32
6804 21F3   00            byte >00                                            ; QQ20+10 = Amount of firearms in cargo hold, #33
6805 21F4 00              byte >00                                            ; QQ20+11 = Amount of furs in cargo hold, #34
6806 21F5   00            byte >00                                            ; QQ20+12 = Amount of minerals in cargo hold, #35
6807 21F6 00              byte >00                                            ; QQ20+13 = Amount of gold in cargo hold, #36
6808 21F7   00            byte >00                                            ; QQ20+14 = Amount of platinum in cargo hold, #37
6809 21F8 00              byte >00                                            ; QQ20+15 = Amount of gem-stones in cargo hold, #38
6810 21F9   00            byte >00                                            ; QQ20+16 = Amount of alien items in cargo hold, #39
6811               
6812 21FA 00              byte Q.                                             ; ECM = E.C.M. system, #40
6813               
6814 21FB   00            byte Q.                                             ; BST = Fuel scoops ("barrel status"), #41
6815               
6816 21FC 00              byte Q. & 127                                       ; BOMB = Energy bomb, #42
6817               
6818 21FD   00            byte Q. & 1                                         ; ENGY = Energy/shield level, #43
6819               
6820 21FE 00              byte Q.                                             ; DKCMP = Docking computer, #44
6821               
6822 21FF   00            byte Q.                                             ; GHYP = Galactic hyperdrive, #45
6823               
6824 2200 00              byte Q.                                             ; ESCP = Escape pod, #46
6825               
6826 2202 0000            data >0000, >0000                                   ; These four bytes appear to be unused, #47-50
     2204 0000     
6827               
6828 2206 03              byte 3 + (Q. & 1)                                   ; NOMSL = Number of missiles, #51
6829               
6830 2207   00            byte >00                                            ; FIST = Legal status ("fugitive/innocent status"), #52
6831               
6832 2208 10              byte >10                                            ; AVL+0  = Market availability of food, #53
6833 2209   0F            byte >0f                                            ; AVL+1  = Market availability of textiles, #54
6834 220A 11              byte >11                                            ; AVL+2  = Market availability of radioactives, #55
6835 220B   00            byte >00                                            ; AVL+3  = Market availability of slaves, #56
6836 220C 03              byte >03                                            ; AVL+4  = Market availability of liquor/Wines, #57
6837 220D   1C            byte >1c                                            ; AVL+5  = Market availability of luxuries, #58
6838 220E 0E              byte >0e                                            ; AVL+6  = Market availability of narcotics, #59
6839 220F   00            byte >00                                            ; AVL+7  = Market availability of computers, #60
6840 2210 00              byte >00                                            ; AVL+8  = Market availability of machinery, #61
6841 2211   0A            byte >0a                                            ; AVL+9  = Market availability of alloys, #62
6842 2212 00              byte >00                                            ; AVL+10 = Market availability of firearms, #63
6843 2213   11            byte >11                                            ; AVL+11 = Market availability of furs, #64
6844 2214 3A              byte >3a                                            ; AVL+12 = Market availability of minerals, #65
6845 2215   07            byte >07                                            ; AVL+13 = Market availability of gold, #66
6846 2216 09              byte >09                                            ; AVL+14 = Market availability of platinum, #67
6847 2217   08            byte >08                                            ; AVL+15 = Market availability of gem-stones, #68
6848 2218 00              byte >00                                            ; AVL+16 = Market availability of alien items, #69
6849               
6850 2219   00            byte >00                                            ; QQ26 = Random byte that changes for each visit to a
6851                                                                          ; system, for randomising market prices, #70
6852               
6853 221A 0000            data >0000                                          ; TALLY = Number of kills, #71-72
6854               
6855 221C 80              byte >80                                            ; SVC = Save count, #73
6856               
6857               * ******************************************************************************
6858               *
6859               * Name: CHK2
6860               * Type: Variable
6861               * Category: Save and load
6862               * Summary: Second checksum byte for the saved commander data file
6863               * Deep dive: Commander save files
6864               * The competition code
6865               *
6866               * ------------------------------------------------------------------------------
6867               *
6868               * Second commander checksum byte. If the default commander is changed, a new
6869               * checksum will be calculated and inserted by the elite-checksum.py script.
6870               *
6871               * The offset of this byte within a saved commander file is also shown (it's at
6872               * byte #74).
6873               *
6874               * ******************************************************************************
6875               
6876               CHK2:
6877 221D   AA            byte >03 ^ >A9                                      ; The checksum value for the default commander, EOR'd
6878                                                                          ; with &A9 to make it harder to tamper with the checksum
6879                                                                          ; byte, #74
6880               
6881               * ******************************************************************************
6882               *
6883               * Name: CHK
6884               * Type: Variable
6885               * Category: Save and load
6886               * Summary: First checksum byte for the saved commander data file
6887               * Deep dive: Commander save files
6888               * The competition code
6889               *
6890               * ------------------------------------------------------------------------------
6891               *
6892               * Commander checksum byte. If the default commander is changed, a new checksum
6893               * will be calculated and inserted by the elite-checksum.py script.
6894               *
6895               * The offset of this byte within a saved commander file is also shown (it's at
6896               * byte #75).
6897               *
6898               * ******************************************************************************
6899               
6900               CHK:
6901 221E 03              byte >03                                            ; The checksum value for the default commander, #75
6902               
6903               * ******************************************************************************
6904               *
6905               * Name: UNIV
6906               * Type: Variable
6907               * Category: Universe
6908               * Summary: Table of pointers to the local universe's ship data blocks
6909               * Deep dive: The local bubble of universe
6910               *
6911               * ------------------------------------------------------------------------------
6912               *
6913               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
6914               * the deep dive on "The local bubble of universe" for details of how Elite
6915               * stores the local universe in K%, FRIN and UNIV.
6916               *
6917               * ******************************************************************************
6918               
6919               UNIV:
6920                      ; FOR I%, 0, NOSH
6921               
6922                      ; EQUW K% + I% * NI%            ;                   ; Address of block no. I%, of size NI%, in workspace K%
6923               
6924                      ; NEXT
6925               
6926 221F   00            byte (K. + 0 * NI.) % 256, (K. + 0 * NI.) / 256
     2220 44       
6927 2221   24            byte (K. + 1 * NI.) % 256, (K. + 1 * NI.) / 256
     2222 44       
6928 2223   48            byte (K. + 2 * NI.) % 256, (K. + 2 * NI.) / 256
     2224 44       
6929 2225   6C            byte (K. + 3 * NI.) % 256, (K. + 3 * NI.) / 256
     2226 44       
6930 2227   90            byte (K. + 4 * NI.) % 256, (K. + 4 * NI.) / 256
     2228 44       
6931 2229   B4            byte (K. + 5 * NI.) % 256, (K. + 5 * NI.) / 256
     222A 44       
6932 222B   D8            byte (K. + 6 * NI.) % 256, (K. + 6 * NI.) / 256
     222C 44       
6933 222D   FC            byte (K. + 7 * NI.) % 256, (K. + 7 * NI.) / 256
     222E 44       
6934 222F   20            byte (K. + 8 * NI.) % 256, (K. + 8 * NI.) / 256
     2230 45       
6935 2231   44            byte (K. + 9 * NI.) % 256, (K. + 9 * NI.) / 256
     2232 45       
6936 2233   68            byte (K. + 10 * NI.) % 256, (K. + 10 * NI.) / 256
     2234 45       
6937 2235   8C            byte (K. + 11 * NI.) % 256, (K. + 11 * NI.) / 256
     2236 45       
6938 2237   B0            byte (K. + 12 * NI.) % 256, (K. + 12 * NI.) / 256
     2238 45       
6939               
6940               * ******************************************************************************
6941               *
6942               * Name: TWOS
6943               * Type: Variable
6944               * Category: Drawing pixels
6945               * Summary: Ready-made single-pixel character row bytes for mode 4
6946               * Deep dive: Drawing monochrome pixels in mode 4
6947               *
6948               * ------------------------------------------------------------------------------
6949               *
6950               * Ready-made bytes for plotting one-pixel points in mode 4 (the top part of the
6951               * split screen). See the PIXEL routine for details.
6952               *
6953               * ******************************************************************************
6954               
6955               TWOS:
6956 2239   80            byte >80
6957 223A 40              byte >40
6958 223B   20            byte >20
6959 223C 10              byte >10
6960 223D   08            byte >08
6961 223E 04              byte >04
6962 223F   02            byte >02
6963 2240 01              byte >01
6964               
6965               * ******************************************************************************
6966               *
6967               * Name: TWOS2
6968               * Type: Variable
6969               * Category: Drawing pixels
6970               * Summary: Ready-made double-pixel character row bytes for mode 4
6971               * Deep dive: Drawing monochrome pixels in mode 4
6972               *
6973               * ------------------------------------------------------------------------------
6974               *
6975               * Ready-made bytes for plotting two-pixel dashes in mode 4 (the top part of the
6976               * split screen). See the PIXEL routine for details.
6977               *
6978               * ******************************************************************************
6979               
6980               TWOS2:
6981 2241   C0            byte >c0
6982 2242 60              byte >60
6983 2243   30            byte >30
6984 2244 18              byte >18
6985 2245   0C            byte >0c
6986 2246 06              byte >06
6987 2247   03            byte >03
6988 2248 03              byte >03
6989               
6990               * ******************************************************************************
6991               *
6992               * Name: CTWOS
6993               * Type: Variable
6994               * Category: Drawing pixels
6995               * Summary: Ready-made single-pixel character row bytes for mode 5
6996               * Deep dive: Drawing colour pixels in mode 5
6997               *
6998               * ------------------------------------------------------------------------------
6999               *
7000               * Ready-made bytes for plotting one-pixel points in mode 5 (the bottom part of
7001               * the split screen). See the dashboard routines SCAN, DIL2 and CPIX2 for
7002               * details.
7003               *
7004               * There is one extra row to support the use of CTWOS+1,X indexing in the CPIX2
7005               * routine. The extra row is a repeat of the first row, and saves us from having
7006               * to work out whether CTWOS+1+X needs to be wrapped around when drawing a
7007               * two-pixel dash that crosses from one character block into another. See CPIX2
7008               * for more details.
7009               *
7010               * ******************************************************************************
7011               
7012               CTWOS:
7013 2249   88            byte >88
7014 224A 44              byte >44
7015 224B   22            byte >22
7016 224C 11              byte >11
7017 224D   88            byte >88
7018               
7019               * ******************************************************************************
7020               *
7021               * Name: LOIN (Part 1 of 7)
7022               * Type: Subroutine
7023               * Category: Drawing lines
7024               * Summary: Draw a line: Calculate the line gradient in the form of deltas
7025               * Deep dive: Bresenham's line algorithm
7026               *
7027               * ------------------------------------------------------------------------------
7028               *
7029               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7030               * This stage calculates the line deltas.
7031               *
7032               * ------------------------------------------------------------------------------
7033               *
7034               * Arguments:
7035               *
7036               * X1                  The screen x-coordinate of the start of the line
7037               *
7038               * Y1                  The screen y-coordinate of the start of the line
7039               *
7040               * X2                  The screen x-coordinate of the end of the line
7041               *
7042               * Y2                  The screen y-coordinate of the end of the line
7043               *
7044               * ------------------------------------------------------------------------------
7045               *
7046               * Returns:
7047               *
7048               * Y                   Y is preserved
7049               *
7050               * ------------------------------------------------------------------------------
7051               *
7052               * Other entry points:
7053               *
7054               * LL30                LL30 is a synonym for LOIN and draws a line from
7055               * (X1, Y1) to (X2, Y2)
7056               *
7057               * ******************************************************************************
7058               
7059               LL30:
7060 224E                 bss 0                                               ; LL30 is a synonym for LOIN
7061                                                                          ;
7062                                                                          ; In the cassette and disc versions of Elite, LL30 and
7063                                                                          ; LOIN are synonyms for the same routine, presumably
7064                                                                          ; because the two developers each had their own line
7065                                                                          ; routines to start with, and then chose one of them for
7066                                                                          ; the final game
7067               
7068               LOIN:
7069 224E D80F  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     2250 0094     
7070                                                                          ; call to this subroutine
7071               
7072 2252 020D  20        li   ra,>80*256                 ; LDA #128          ; Set S = 128, which is the starting point for the
     2254 8000     
7073 2256 D80D  30        movb ra,@S                      ; STA S             ; slope error (representing half a pixel)
     2258 0092     
7074               
7075                      .asla                           ; ASL A             ; Set SWAP = 0, as %10000000 << 1 = 0
     **** ****     > ASLA
0001 225A 024D  22        andi ra,>ff00
     225C FF00     
0002 225E 0A1D  18        sla  ra,1
                   < elite.a99
7076 2260 D80D  30        movb ra,@SWAP                   ; STA SWAP
     2262 00A1     
7077               
7078 2264 D360  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1
     2266 0033     
7079                      .sbc @X1,ra                     ; SBC X1            ; = delta_x
     **** ****     > SBC
0001 2268 1801  14        joc  !
0002 226A 7347  18        sb   rone,ra
0003               !:
0004 226C 7360  30        sb   @X1,ra
     226E 0031     
                   < elite.a99
7080                                                                          ;
7081                                                                          ; This subtraction works as the ASL A above sets the C
7082                                                                          ; flag
7083               
7084 2270 1808  14        joc  LI1                        ; BCS LI1           ; If X2 > X1 then A is already positive and we can skip
7085                                                                          ; the next three instructions
7086               
7087                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 2272 0200  20        li   rtmp,(>FF*256)
     2274 FF00     
0002 2276 2B40  18        xor  rtmp,ra
                   < elite.a99
7088                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 2278 1701  14        jnc  !
0002 227A B347  18        ab   rone,ra
0003               !:
0004 227C 022D  22        ai   ra,(>01*256)
     227E 0100     
                   < elite.a99
7089                                                                          ; positive
7090               
7091                      .sec                            ; SEC               ; Set the C flag, ready for the subtraction below
     **** ****     > SEC
0001 2280 0A18  18        sla  rmone,1
                   < elite.a99
7092               
7093               LI1:
7094 2282 D80D  30        movb ra,@P                      ; STA P             ; Store A in P, so P = |X2 - X1|, or |delta_x|
     2284 001B     
7095               
7096 2286 D360  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1
     2288 0034     
7097                      .sbc @Y1,ra                     ; SBC Y1            ; = delta_y
     **** ****     > SBC
0001 228A 1801  14        joc  !
0002 228C 7347  18        sb   rone,ra
0003               !:
0004 228E 7360  30        sb   @Y1,ra
     2290 0032     
                   < elite.a99
7098                                                                          ;
7099                                                                          ; This subtraction works as we either set the C flag
7100                                                                          ; above, or we skipped that SEC instruction with a BCS
7101               
7102 2292 1807  14        joc  LI2                        ; BCS LI2           ; If Y2 > Y1 then A is already positive and we can skip
7103                                                                          ; the next two instructions
7104               
7105                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 2294 0200  20        li   rtmp,(>FF*256)
     2296 FF00     
0002 2298 2B40  18        xor  rtmp,ra
                   < elite.a99
7106                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 229A 1701  14        jnc  !
0002 229C B347  18        ab   rone,ra
0003               !:
0004 229E 022D  22        ai   ra,(>01*256)
     22A0 0100     
                   < elite.a99
7107                                                                          ; positive
7108               
7109               LI2:
7110 22A2 D80D  30        movb ra,@Q                      ; STA Q             ; Store A in Q, so Q = |Y2 - Y1|, or |delta_y|
     22A4 0090     
7111               
7112 22A6 9360  30        cb   @P,ra                      ; CMP P             ; If Q < P, jump to STPX to step along the x-axis, as
     22A8 001B     
7113 22AA 1702  14        jnc  STPX                       ; BCC STPX          ; the line is closer to being horizontal than vertical
7114               
7115 22AC 0460  28        b    @STPY                      ; JMP STPY          ; Otherwise Q >= P so jump to STPY to step along the
     22AE 242E     
7116                                                                          ; y-axis, as the line is closer to being vertical than
7117                                                                          ; horizontal
7118               
7119               * ******************************************************************************
7120               *
7121               * Name: LOIN (Part 2 of 7)
7122               * Type: Subroutine
7123               * Category: Drawing lines
7124               * Summary: Draw a line: Line has a shallow gradient, step right along x-axis
7125               * Deep dive: Bresenham's line algorithm
7126               *
7127               * ------------------------------------------------------------------------------
7128               *
7129               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7130               * If we get here, then:
7131               *
7132               * * |delta_y| < |delta_x|
7133               *
7134               * * The line is closer to being horizontal than vertical
7135               *
7136               * * We are going to step right along the x-axis
7137               *
7138               * * We potentially swap coordinates to make sure X1 < X2
7139               *
7140               * ******************************************************************************
7141               
7142               STPX:
7143 22B0 D3A0  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     22B2 0031     
7144               
7145 22B4 93A0  30        cb   @X2,rx                     ; CPX X2            ; If X1 < X2, jump down to LI3, as the coordinates are
     22B6 0033     
7146 22B8 1710  14        jnc  LI3                        ; BCC LI3           ; already in the order that we want
7147               
7148 22BA 7347  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7149                                                                          ; we are swapping the coordinates around
7150               
7151 22BC D360  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     22BE 0033     
7152 22C0 D80D  30        movb ra,@X1                     ; STA X1
     22C2 0031     
7153 22C4 D80E  30        movb rx,@X2                     ; STX X2
     22C6 0033     
7154               
7155 22C8 D38D  18        movb ra,rx                      ; TAX               ; Set X = X1
7156               
7157 22CA D360  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     22CC 0034     
7158 22CE D3E0  30        movb @Y1,ry                     ; LDY Y1
     22D0 0032     
7159 22D2 D80D  30        movb ra,@Y1                     ; STA Y1
     22D4 0032     
7160 22D6 D80F  30        movb ry,@Y2                     ; STY Y2
     22D8 0034     
7161               
7162               LI3:
7163                                                                          ; By this point we know the line is horizontal-ish and
7164                                                                          ; X1 < X2, so we're going from left to right as we go
7165                                                                          ; from X1 to X2
7166 22DA D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     22DC 0032     
7167 22DE 091D  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7168 22E0 091D  18        srl  ra,1                       ; LSR A
7169 22E2 091D  18        srl  ra,1                       ; LSR A
7170               
7171 22E4 026D  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     22E6 6000     
7172                                                                          ; us the screen address of the character row (as each
7173                                                                          ; character row takes up 256 bytes, and the first
7174                                                                          ; character row is at screen address &6000, or page &60)
7175               
7176 22E8 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     22EA 0008     
7177                                                                          ; the high byte of SC is set correctly for drawing the
7178                                                                          ; start of our line
7179               
7180 22EC D360  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     22EE 0032     
7181 22F0 024D  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     22F2 0700     
7182 22F4 D3CD  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7183               
7184 22F6 D34E  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7185 22F8 024D  22        andi ra,>f8*256                 ; AND #%11111000
     22FA F800     
7186               
7187 22FC D80D  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     22FE 0007     
7188                                                                          ; screen address of the far left end (x-coordinate = 0)
7189                                                                          ; of the horizontal pixel row that we want to draw the
7190                                                                          ; start of our line on
7191               
7192 2300 D34E  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7193 2302 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2304 0700     
7194 2306 D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7195                                                                          ; wide)
7196               
7197 2308 D36E  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     230A 2239     
7198 230C D80D  30        movb ra,@R                      ; STA R             ; and store it in R
     230E 0091     
7199               
7200                                                                          ; The following calculates:
7201                                                                          ;
7202                                                                          ; Q = Q / P
7203                                                                          ; = |delta_y| / |delta_x|
7204                                                                          ;
7205                                                                          ; using the same shift-and-subtract algorithm that's
7206                                                                          ; documented in TIS2
7207               
7208 2310 D360  30        movb @Q,ra                      ; LDA Q             ; Set A = |delta_y|
     2312 0090     
7209               
7210 2314 020E  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set Q to have bits 1-7 set, so we can rotate through 7
     2316 FE00     
7211 2318 D80E  30        movb rx,@Q                      ; STX Q             ; loop iterations, getting a 1 each time, and then
     231A 0090     
7212                                                                          ; getting a 0 on the 8th iteration... and we can also
7213                                                                          ; use Q to catch our result bits into bit 0 each time
7214               
7215               LIL1:
7216                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 231C 024D  22        andi ra,>ff00
     231E FF00     
0002 2320 0A1D  18        sla  ra,1
                   < elite.a99
7217               
7218 2322 1803  14        joc  LI4                        ; BCS LI4           ; If bit 7 of A was set, then jump straight to the
7219                                                                          ; subtraction
7220               
7221 2324 9360  30        cb   @P,ra                      ; CMP P             ; If A < P, skip the following subtraction
     2326 001B     
7222 2328 1705  14        jnc  LI5                        ; BCC LI5
7223               
7224               LI4:
7225                      .sbc @P,ra                      ; SBC P             ; A >= P, so set A = A - P
     **** ****     > SBC
0001 232A 1801  14        joc  !
0002 232C 7347  18        sb   rone,ra
0003               !:
0004 232E 7360  30        sb   @P,ra
     2330 001B     
                   < elite.a99
7226               
7227                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 2332 0A18  18        sla  rmone,1
                   < elite.a99
7228               
7229               LI5:
7230 2334 0204  20        li   rarg1,Q                    ; ROL Q             ; Rotate the counter in Q to the left, and catch the
     2336 0090     
7231 2338 06A0  32        bl   @rol                       ;
     233A FE44     
7232                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7233                                                                          ; do the subtraction, or 1 if we did)
7234               
7235 233C 18EF  14        joc  LIL1                       ; BCS LIL1          ; If we still have set bits in Q, loop back to TIL2 to
7236                                                                          ; do the next iteration of 7
7237               
7238                                                                          ; We now have:
7239                                                                          ;
7240                                                                          ; Q = A / P
7241                                                                          ; = |delta_y| / |delta_x|
7242                                                                          ;
7243                                                                          ; and the C flag is clear
7244               
7245 233E D3A0  30        movb @P,rx                      ; LDX P             ; Set X = P + 1
     2340 001B     
7246 2342 B387  18        ab   rone,rx                    ; INX               ; = |delta_x| + 1
7247                                                                          ;
7248                                                                          ; We add 1 so we can skip the first pixel plot if the
7249                                                                          ; line is being drawn with swapped coordinates
7250               
7251 2344 D360  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1 - 1 (as the C flag is clear following
     2346 0034     
7252                      .sbc @Y1,ra                     ; SBC Y1            ; the above division)
     **** ****     > SBC
0001 2348 1801  14        joc  !
0002 234A 7347  18        sb   rone,ra
0003               !:
0004 234C 7360  30        sb   @Y1,ra
     234E 0032     
                   < elite.a99
7253               
7254 2350 1836  14        joc  DOWN                       ; BCS DOWN          ; If Y2 >= Y1 - 1 then jump to DOWN, as we need to draw
7255                                                                          ; the line to the right and down
7256               
7257               * ******************************************************************************
7258               *
7259               * Name: LOIN (Part 3 of 7)
7260               * Type: Subroutine
7261               * Category: Drawing lines
7262               * Summary: Draw a shallow line going right and up or left and down
7263               * Deep dive: Bresenham's line algorithm
7264               *
7265               * ------------------------------------------------------------------------------
7266               *
7267               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7268               * If we get here, then:
7269               *
7270               * * The line is going right and up (no swap) or left and down (swap)
7271               *
7272               * * X1 < X2 and Y1-1 > Y2
7273               *
7274               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7275               * first pixel
7276               *
7277               * ******************************************************************************
7278               
7279 2352 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP > 0 then we swapped the coordinates above, so
     2354 00A1     
7280 2356 160D  14        jne  LI6                        ; BNE LI6           ; jump down to LI6 to skip plotting the first pixel
7281                                                                          ;
7282                                                                          ; This appears to be a bug that omits the last pixel
7283                                                                          ; of this type of shallow line, rather than the first
7284                                                                          ; pixel, which makes the treatment of this kind of line
7285                                                                          ; different to the other kinds of slope (they all have a
7286                                                                          ; BEQ instruction at this point, rather than a BNE)
7287                                                                          ;
7288                                                                          ; The result is a rather messy line join when a shallow
7289                                                                          ; line that goes right and up or left and down joins a
7290                                                                          ; line with any of the other three types of slope
7291                                                                          ;
7292                                                                          ; This bug was fixed in the advanced versions of Elite,
7293                                                                          ; where the BNE is replaced by a BEQ to bring it in line
7294                                                                          ; with the other three slopes
7295               
7296 2358 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7297                                                                          ; the first pixel
7298               
7299               LIL2:
7300                                                                          ; We now loop along the line from left to right, using X
7301                                                                          ; as a decreasing counter, and at each count we plot a
7302                                                                          ; single pixel using the pixel mask in R
7303 235A D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     235C 0091     
7304               
7305                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 235E D020  30        movb @SC,rtmp
     2360 0007     
0002 2362 2B40  18        xor  rtmp,ra
                   < elite.a99
7306                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2364 D820  50        movb @SC,@rtmplb
     2366 0007     
     2368 206D     
0002 236A D020  30        movb @SC+1,rtmp
     236C 0008     
0003 236E A00F  18        a    ry,rtmp
0004 2370 D40D  30        movb RA,*rtmp
                   < elite.a99
7307               
7308               LI6:
7309                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 2372 D020  30        movb @R,rtmp
     2374 0091     
0002 2376 0910  18        srl  rtmp,1
0003 2378 D800  30        movb rtmp,@R
     237A 0091     
                   < elite.a99
7310                                                                          ; the x-axis, so the next pixel we plot will be at the
7311                                                                          ; next x-coordinate along
7312               
7313 237C 170C  14        jnc  LI7                        ; BCC LI7           ; If the pixel didn't fall out of the right end of R
7314                                                                          ; into the C flag, then jump to LI7
7315               
7316 237E 0204  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     2380 0091     
7317 2382 06A0  32        bl   @ror                       ;
     2384 FE70     
7318                                                                          ; block, so first rotate R right so the set C flag goes
7319                                                                          ; back into the left end, giving %10000000
7320               
7321 2386 D360  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2388 0007     
7322                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 238A 1701  14        jnc  !
0002 238C B347  18        ab   rone,ra
0003               !:
0004 238E 022D  22        ai   ra,(>08*256)
     2390 0800     
                   < elite.a99
7323 2392 D80D  30        movb ra,@SC                     ; STA SC
     2394 0007     
7324               
7325               LI7:
7326 2396 D360  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     2398 0092     
7327                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 239A 1701  14        jnc  !
0002 239C B347  18        ab   rone,ra
0003               !:
0004 239E B360  30        ab   @Q,ra
     23A0 0090     
                   < elite.a99
7328 23A2 D80D  30        movb ra,@S                      ; STA S
     23A4 0092     
7329               
7330 23A6 1705  14        jnc  LIC2                       ; BCC LIC2          ; If the addition didn't overflow, jump to LIC2
7331               
7332 23A8 73C7  18        sb   rone,ry                    ; DEY               ; Otherwise we just overflowed, so decrement Y to move
7333                                                                          ; to the pixel line above
7334               
7335 23AA 1503  14        jgt  LIC2                       ; BPL LIC2          ; If Y is positive we are still within the same
7336                                                                          ; character block, so skip to LIC2
7337               
7338 23AC 7347  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7339 23AE 020F  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     23B0 0700     
7340                                                                          ; address and set the pixel line to the last line in
7341                                                                          ; that character block
7342               
7343               LIC2:
7344 23B2 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7345               
7346 23B4 16D2  14        jne  LIL2                       ; BNE LIL2          ; If we haven't yet reached the right end of the line,
7347                                                                          ; loop back to LIL2 to plot the next pixel along
7348               
7349 23B6 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     23B8 0094     
7350               
7351 23BA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     23BC FE2A     
7352               
7353               * ******************************************************************************
7354               *
7355               * Name: LOIN (Part 4 of 7)
7356               * Type: Subroutine
7357               * Category: Drawing lines
7358               * Summary: Draw a shallow line going right and down or left and up
7359               * Deep dive: Bresenham's line algorithm
7360               *
7361               * ------------------------------------------------------------------------------
7362               *
7363               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7364               * If we get here, then:
7365               *
7366               * * The line is going right and down (no swap) or left and up (swap)
7367               *
7368               * * X1 < X2 and Y1-1 <= Y2
7369               *
7370               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7371               * first pixel
7372               *
7373               * ******************************************************************************
7374               
7375               DOWN:
7376 23BE D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     23C0 00A1     
7377 23C2 130D  14        jeq  LI9                        ; BEQ LI9           ; so jump down to LI9 to skip plotting the first pixel
7378               
7379 23C4 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7380                                                                          ; the first pixel
7381               
7382               LIL3:
7383                                                                          ; We now loop along the line from left to right, using X
7384                                                                          ; as a decreasing counter, and at each count we plot a
7385                                                                          ; single pixel using the pixel mask in R
7386 23C6 D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     23C8 0091     
7387               
7388                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 23CA D020  30        movb @SC,rtmp
     23CC 0007     
0002 23CE 2B40  18        xor  rtmp,ra
                   < elite.a99
7389                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 23D0 D820  50        movb @SC,@rtmplb
     23D2 0007     
     23D4 206D     
0002 23D6 D020  30        movb @SC+1,rtmp
     23D8 0008     
0003 23DA A00F  18        a    ry,rtmp
0004 23DC D40D  30        movb RA,*rtmp
                   < elite.a99
7390               
7391               LI9:
7392                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 23DE D020  30        movb @R,rtmp
     23E0 0091     
0002 23E2 0910  18        srl  rtmp,1
0003 23E4 D800  30        movb rtmp,@R
     23E6 0091     
                   < elite.a99
7393                                                                          ; the x-axis, so the next pixel we plot will be at the
7394                                                                          ; next x-coordinate along
7395               
7396 23E8 170C  14        jnc  LI10                       ; BCC LI10          ; If the pixel didn't fall out of the right end of R
7397                                                                          ; into the C flag, then jump to LI10
7398               
7399 23EA 0204  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     23EC 0091     
7400 23EE 06A0  32        bl   @ror                       ;
     23F0 FE70     
7401                                                                          ; block, so first rotate R right so the set C flag goes
7402                                                                          ; back into the left end, giving %10000000
7403               
7404 23F2 D360  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     23F4 0007     
7405                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 23F6 1701  14        jnc  !
0002 23F8 B347  18        ab   rone,ra
0003               !:
0004 23FA 022D  22        ai   ra,(>08*256)
     23FC 0800     
                   < elite.a99
7406 23FE D80D  30        movb ra,@SC                     ; STA SC
     2400 0007     
7407               
7408               LI10:
7409 2402 D360  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     2404 0092     
7410                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 2406 1701  14        jnc  !
0002 2408 B347  18        ab   rone,ra
0003               !:
0004 240A B360  30        ab   @Q,ra
     240C 0090     
                   < elite.a99
7411 240E D80D  30        movb ra,@S                      ; STA S
     2410 0092     
7412               
7413 2412 1707  14        jnc  LIC3                       ; BCC LIC3          ; If the addition didn't overflow, jump to LIC3
7414               
7415 2414 B3C7  18        ab   rone,ry                    ; INY               ; Otherwise we just overflowed, so increment Y to move
7416                                                                          ; to the pixel line below
7417               
7418 2416 028F  22        ci   ry,>08*256                 ; CPY #8            ; If Y < 8 we are still within the same character block,
     2418 0800     
7419 241A 1603  14        jne  LIC3                       ; BNE LIC3          ; so skip to LIC3
7420               
7421 241C B347  18        ab   rone,ra                    ; INC SCH           ; Otherwise we need to move down into the character
7422 241E 020F  20        li   ry,>00*256                 ; LDY #0            ; block below, so increment the high byte of the screen
     2420 0000     
7423                                                                          ; address and set the pixel line to the first line in
7424                                                                          ; that character block
7425               
7426               LIC3:
7427 2422 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7428               
7429 2424 16D0  14        jne  LIL3                       ; BNE LIL3          ; If we haven't yet reached the right end of the line,
7430                                                                          ; loop back to LIL3 to plot the next pixel along
7431               
7432 2426 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2428 0094     
7433               
7434 242A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     242C FE2A     
7435               
7436               * ******************************************************************************
7437               *
7438               * Name: LOIN (Part 5 of 7)
7439               * Type: Subroutine
7440               * Category: Drawing lines
7441               * Summary: Draw a line: Line has a steep gradient, step up along y-axis
7442               * Deep dive: Bresenham's line algorithm
7443               *
7444               * ------------------------------------------------------------------------------
7445               *
7446               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7447               * If we get here, then:
7448               *
7449               * * |delta_y| >= |delta_x|
7450               *
7451               * * The line is closer to being vertical than horizontal
7452               *
7453               * * We are going to step up along the y-axis
7454               *
7455               * * We potentially swap coordinates to make sure Y1 >= Y2
7456               *
7457               * ******************************************************************************
7458               
7459               STPY:
7460 242E D3E0  30        movb @Y1,ry                     ; LDY Y1            ; Set A = Y = Y1
     2430 0032     
7461 2432 D34F  18        movb ry,ra                      ; TYA
7462               
7463 2434 D3A0  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     2436 0031     
7464               
7465 2438 93E0  30        cb   @Y2,ry                     ; CPY Y2            ; If Y1 >= Y2, jump down to LI15, as the coordinates are
     243A 0034     
7466 243C 180F  14        joc  LI15                       ; BCS LI15          ; already in the order that we want
7467               
7468 243E 7347  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7469                                                                          ; we are swapping the coordinates around
7470               
7471 2440 D360  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     2442 0033     
7472 2444 D80D  30        movb ra,@X1                     ; STA X1
     2446 0031     
7473 2448 D80E  30        movb rx,@X2                     ; STX X2
     244A 0033     
7474               
7475 244C D38D  18        movb ra,rx                      ; TAX               ; Set X = X1
7476               
7477 244E D360  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     2450 0034     
7478 2452 D80D  30        movb ra,@Y1                     ; STA Y1
     2454 0032     
7479 2456 D80F  30        movb ry,@Y2                     ; STY Y2
     2458 0034     
7480               
7481 245A D3CD  18        movb ra,ry                      ; TAY               ; Set Y = A = Y1
7482               
7483               LI15:
7484                                                                          ; By this point we know the line is vertical-ish and
7485                                                                          ; Y1 >= Y2, so we're going from top to bottom as we go
7486                                                                          ; from Y1 to Y2
7487 245C 091D  18        srl  ra,1                       ; LSR A             ; Set A = Y1 / 8, so A now contains the character row
7488 245E 091D  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7489 2460 091D  18        srl  ra,1                       ; LSR A
7490               
7491 2462 026D  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     2464 6000     
7492                                                                          ; us the screen address of the character row (as each
7493                                                                          ; character row takes up 256 bytes, and the first
7494                                                                          ; character row is at screen address &6000, or page &60)
7495               
7496 2466 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     2468 0008     
7497                                                                          ; the high byte of SC is set correctly for drawing the
7498                                                                          ; start of our line
7499               
7500 246A D34E  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7501 246C 024D  22        andi ra,>f8*256                 ; AND #%11111000
     246E F800     
7502               
7503 2470 D80D  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     2472 0007     
7504                                                                          ; screen address of the far left end (x-coordinate = 0)
7505                                                                          ; of the horizontal pixel row that we want to draw the
7506                                                                          ; start of our line on
7507               
7508 2474 D34E  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7509 2476 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2478 0700     
7510 247A D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7511                                                                          ; wide)
7512               
7513 247C D36E  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     247E 2239     
7514 2480 D80D  30        movb ra,@R                      ; STA R             ; and store it in R
     2482 0091     
7515               
7516 2484 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     2486 0032     
7517 2488 024D  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     248A 0700     
7518 248C D3CD  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7519               
7520                                                                          ; The following calculates:
7521                                                                          ;
7522                                                                          ; P = P / Q
7523                                                                          ; = |delta_x| / |delta_y|
7524                                                                          ;
7525                                                                          ; using the same shift-and-subtract algorithm
7526                                                                          ; documented in TIS2
7527               
7528 248E D360  30        movb @P,ra                      ; LDA P             ; Set A = |delta_x|
     2490 001B     
7529               
7530 2492 020E  20        li   rx,>01*256                 ; LDX #1            ; Set Q to have bits 1-7 clear, so we can rotate through
     2494 0100     
7531 2496 D80E  30        movb rx,@P                      ; STX P             ; 7 loop iterations, getting a 1 each time, and then
     2498 001B     
7532                                                                          ; getting a 1 on the 8th iteration... and we can also
7533                                                                          ; use P to catch our result bits into bit 0 each time
7534               
7535               LIL4:
7536                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 249A 024D  22        andi ra,>ff00
     249C FF00     
0002 249E 0A1D  18        sla  ra,1
                   < elite.a99
7537               
7538 24A0 1803  14        joc  LI13                       ; BCS LI13          ; If bit 7 of A was set, then jump straight to the
7539                                                                          ; subtraction
7540               
7541 24A2 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     24A4 0090     
7542 24A6 1705  14        jnc  LI14                       ; BCC LI14
7543               
7544               LI13:
7545                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 24A8 1801  14        joc  !
0002 24AA 7347  18        sb   rone,ra
0003               !:
0004 24AC 7360  30        sb   @Q,ra
     24AE 0090     
                   < elite.a99
7546               
7547                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 24B0 0A18  18        sla  rmone,1
                   < elite.a99
7548               
7549               LI14:
7550 24B2 0204  20        li   rarg1,P                    ; ROL P             ; Rotate the counter in P to the left, and catch the
     24B4 001B     
7551 24B6 06A0  32        bl   @rol                       ;
     24B8 FE44     
7552                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7553                                                                          ; do the subtraction, or 1 if we did)
7554               
7555 24BA 17EF  14        jnc  LIL4                       ; BCC LIL4          ; If we still have set bits in P, loop back to TIL2 to
7556                                                                          ; do the next iteration of 7
7557               
7558                                                                          ; We now have:
7559                                                                          ;
7560                                                                          ; P = A / Q
7561                                                                          ; = |delta_x| / |delta_y|
7562                                                                          ;
7563                                                                          ; and the C flag is set
7564               
7565 24BC D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X = Q + 1
     24BE 0090     
7566 24C0 B387  18        ab   rone,rx                    ; INX               ; = |delta_y| + 1
7567                                                                          ;
7568                                                                          ; We add 1 so we can skip the first pixel plot if the
7569                                                                          ; line is being drawn with swapped coordinates
7570               
7571 24C2 D360  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1 (the C flag is set as we didn't take
     24C4 0033     
7572                      .sbc @X1,ra                     ; SBC X1            ; the above BCC)
     **** ****     > SBC
0001 24C6 1801  14        joc  !
0002 24C8 7347  18        sb   rone,ra
0003               !:
0004 24CA 7360  30        sb   @X1,ra
     24CC 0031     
                   < elite.a99
7573               
7574 24CE 1737  14        jnc  LFT                        ; BCC LFT           ; If X2 < X1 then jump to LFT, as we need to draw the
7575                                                                          ; line to the left and down
7576               
7577               * ******************************************************************************
7578               *
7579               * Name: LOIN (Part 6 of 7)
7580               * Type: Subroutine
7581               * Category: Drawing lines
7582               * Summary: Draw a steep line going up and left or down and right
7583               * Deep dive: Bresenham's line algorithm
7584               *
7585               * ------------------------------------------------------------------------------
7586               *
7587               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7588               * If we get here, then:
7589               *
7590               * * The line is going up and left (no swap) or down and right (swap)
7591               *
7592               * * X1 < X2 and Y1 >= Y2
7593               *
7594               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7595               * first pixel
7596               *
7597               * ******************************************************************************
7598               
7599                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 24D0 0A16  18        sla  rzero,1
                   < elite.a99
7600               
7601 24D2 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     24D4 00A1     
7602 24D6 130D  14        jeq  LI17                       ; BEQ LI17          ; so jump down to LI17 to skip plotting the first pixel
7603               
7604 24D8 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7605                                                                          ; the first pixel
7606               
7607               LIL5:
7608                                                                          ; We now loop along the line from left to right, using X
7609                                                                          ; as a decreasing counter, and at each count we plot a
7610                                                                          ; single pixel using the pixel mask in R
7611 24DA D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     24DC 0091     
7612               
7613                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 24DE D020  30        movb @SC,rtmp
     24E0 0007     
0002 24E2 2B40  18        xor  rtmp,ra
                   < elite.a99
7614                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 24E4 D820  50        movb @SC,@rtmplb
     24E6 0007     
     24E8 206D     
0002 24EA D020  30        movb @SC+1,rtmp
     24EC 0008     
0003 24EE A00F  18        a    ry,rtmp
0004 24F0 D40D  30        movb RA,*rtmp
                   < elite.a99
7615               
7616               LI17:
7617 24F2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7618               
7619 24F4 1503  14        jgt  LI16                       ; BPL LI16          ; If Y is positive we are still within the same
7620                                                                          ; character block, so skip to LI16
7621               
7622 24F6 7347  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7623 24F8 020F  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     24FA 0700     
7624                                                                          ; address and set the pixel line to the last line in
7625                                                                          ; that character block
7626               
7627               LI16:
7628 24FC D360  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     24FE 0092     
7629                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 2500 1701  14        jnc  !
0002 2502 B347  18        ab   rone,ra
0003               !:
0004 2504 B360  30        ab   @P,ra
     2506 001B     
                   < elite.a99
7630 2508 D80D  30        movb ra,@S                      ; STA S
     250A 0092     
7631               
7632 250C 1712  14        jnc  LIC5                       ; BCC LIC5          ; If the addition didn't overflow, jump to LIC5
7633               
7634                      .lsr @R                         ; LSR R             ; Otherwise we just overflowed, so shift the single
     **** ****     > LSR
0001 250E D020  30        movb @R,rtmp
     2510 0091     
0002 2512 0910  18        srl  rtmp,1
0003 2514 D800  30        movb rtmp,@R
     2516 0091     
                   < elite.a99
7635                                                                          ; pixel in R to the right, so the next pixel we plot
7636                                                                          ; will be at the next x-coordinate along
7637               
7638 2518 170C  14        jnc  LIC5                       ; BCC LIC5          ; If the pixel didn't fall out of the right end of R
7639                                                                          ; into the C flag, then jump to LIC5
7640               
7641 251A 0204  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     251C 0091     
7642 251E 06A0  32        bl   @ror                       ;
     2520 FE70     
7643                                                                          ; block, so first rotate R right so the set C flag goes
7644                                                                          ; back into the left end, giving %10000000
7645               
7646 2522 D360  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2524 0007     
7647                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 2526 1701  14        jnc  !
0002 2528 B347  18        ab   rone,ra
0003               !:
0004 252A 022D  22        ai   ra,(>08*256)
     252C 0800     
                   < elite.a99
7648 252E D80D  30        movb ra,@SC                     ; STA SC
     2530 0007     
7649               
7650               LIC5:
7651 2532 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7652               
7653 2534 16D2  14        jne  LIL5                       ; BNE LIL5          ; If we haven't yet reached the right end of the line,
7654                                                                          ; loop back to LIL5 to plot the next pixel along
7655               
7656 2536 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2538 0094     
7657               
7658 253A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     253C FE2A     
7659               
7660               * ******************************************************************************
7661               *
7662               * Name: LOIN (Part 7 of 7)
7663               * Type: Subroutine
7664               * Category: Drawing lines
7665               * Summary: Draw a steep line going up and right or down and left
7666               * Deep dive: Bresenham's line algorithm
7667               *
7668               * ------------------------------------------------------------------------------
7669               *
7670               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7671               * If we get here, then:
7672               *
7673               * * The line is going up and right (no swap) or down and left (swap)
7674               *
7675               * * X1 >= X2 and Y1 >= Y2
7676               *
7677               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7678               * first pixel
7679               *
7680               * ------------------------------------------------------------------------------
7681               *
7682               * Other entry points:
7683               *
7684               * HL6                 Contains an RTS
7685               *
7686               * ******************************************************************************
7687               
7688               LFT:
7689 253E D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     2540 00A1     
7690 2542 130D  14        jeq  LI18                       ; BEQ LI18          ; so jump down to LI18 to skip plotting the first pixel
7691               
7692 2544 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7693                                                                          ; the first pixel
7694               
7695               LIL6:
7696 2546 D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     2548 0091     
7697               
7698                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 254A D020  30        movb @SC,rtmp
     254C 0007     
0002 254E 2B40  18        xor  rtmp,ra
                   < elite.a99
7699                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2550 D820  50        movb @SC,@rtmplb
     2552 0007     
     2554 206D     
0002 2556 D020  30        movb @SC+1,rtmp
     2558 0008     
0003 255A A00F  18        a    ry,rtmp
0004 255C D40D  30        movb RA,*rtmp
                   < elite.a99
7700               
7701               LI18:
7702 255E 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7703               
7704 2560 1503  14        jgt  LI19                       ; BPL LI19          ; If Y is positive we are still within the same
7705                                                                          ; character block, so skip to LI19
7706               
7707 2562 7347  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7708 2564 020F  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     2566 0700     
7709                                                                          ; address and set the pixel line to the last line in
7710                                                                          ; that character block
7711               
7712               LI19:
7713 2568 D360  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     256A 0092     
7714                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 256C 1701  14        jnc  !
0002 256E B347  18        ab   rone,ra
0003               !:
0004 2570 B360  30        ab   @P,ra
     2572 001B     
                   < elite.a99
7715 2574 D80D  30        movb ra,@S                      ; STA S
     2576 0092     
7716               
7717 2578 1715  14        jnc  LIC6                       ; BCC LIC6          ; If the addition didn't overflow, jump to LIC6
7718               
7719                      .asl @R                         ; ASL R             ; Otherwise we just overflowed, so shift the single
     **** ****     > ASL
0001 257A D020  30        movb @R,rtmp
     257C 0091     
0002 257E 0240  22        andi rtmp,>ff00
     2580 FF00     
0003 2582 0A10  18        sla  rtmp,1
0004 2584 D800  30        movb rtmp,@R
     2586 0091     
                   < elite.a99
7720                                                                          ; pixel in R to the left, so the next pixel we plot
7721                                                                          ; will be at the previous x-coordinate
7722               
7723 2588 170D  14        jnc  LIC6                       ; BCC LIC6          ; If the pixel didn't fall out of the left end of R
7724                                                                          ; into the C flag, then jump to LIC6
7725               
7726 258A 0204  20        li   rarg1,R                    ; ROL R             ; Otherwise we need to move over to the next character
     258C 0091     
7727 258E 06A0  32        bl   @rol                       ;
     2590 FE44     
7728                                                                          ; block, so first rotate R left so the set C flag goes
7729                                                                          ; back into the right end, giving %0000001
7730               
7731 2592 D360  30        movb @SC,ra                     ; LDA SC            ; Subtract 7 from SC, so SC(1 0) now points to the
     2594 0007     
7732                      .sbi (>07*256)                  ; SBC #7            ; previous character along to the left
     **** ****     > SBI
0001 2596 1801  14        joc  !
0002 2598 7347  18        sb   rone,ra
0003               !:
0004 259A 022D  22        ai   ra,-(>07*256)
     259C F900     
                   < elite.a99
7733 259E D80D  30        movb ra,@SC                     ; STA SC
     25A0 0007     
7734               
7735                      .clc                            ; CLC               ; Clear the C flag so it doesn't affect the additions
     **** ****     > CLC
0001 25A2 0A16  18        sla  rzero,1
                   < elite.a99
7736                                                                          ; below
7737               
7738               LIC6:
7739 25A4 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7740               
7741 25A6 16CF  14        jne  LIL6                       ; BNE LIL6          ; If we haven't yet reached the left end of the line,
7742                                                                          ; loop back to LIL6 to plot the next pixel along
7743               
7744 25A8 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     25AA 0094     
7745               
7746               HL6:
7747 25AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     25AE FE2A     
7748               
7749               * ******************************************************************************
7750               *
7751               * Name: NLIN3
7752               * Type: Subroutine
7753               * Category: Drawing lines
7754               * Summary: Print a title and draw a horizontal line at row 19 to box it in
7755               *
7756               * ------------------------------------------------------------------------------
7757               *
7758               * This routine print a text token at the cursor position and draws a horizontal
7759               * line at pixel row 19. It is used for the Status Mode screen, the Short-range
7760               * Chart, the Market Price screen and the Equip Ship screen.
7761               *
7762               * ******************************************************************************
7763               
7764               NLIN3:
7765 25B0 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     25B2 A6E8     
7766 25B4 06A0  32        bl   @jsr                       ;
     25B6 FE1E     
7767               
7768                                                                          ; Fall through into NLIN4 to draw a horizontal line at
7769                                                                          ; pixel row 19
7770               
7771               * ******************************************************************************
7772               *
7773               * Name: NLIN4
7774               * Type: Subroutine
7775               * Category: Drawing lines
7776               * Summary: Draw a horizontal line at pixel row 19 to box in a title
7777               *
7778               * ------------------------------------------------------------------------------
7779               *
7780               * This routine is used on the Inventory screen to draw a horizontal line at
7781               * pixel row 19 to box in the title.
7782               *
7783               * ******************************************************************************
7784               
7785               NLIN4:
7786 25B8 020D  20        li   ra,>13*256                 ; LDA #19           ; Jump to NLIN2 to draw a horizontal line at pixel row
     25BA 1300     
7787 25BC 1603  14        jne  NLIN2                      ; BNE NLIN2         ; 19, returning from the subroutine with using a tail
7788                                                                          ; call (this BNE is effectively a JMP as A will never
7789                                                                          ; be zero)
7790               
7791               * ******************************************************************************
7792               *
7793               * Name: NLIN
7794               * Type: Subroutine
7795               * Category: Drawing lines
7796               * Summary: Draw a horizontal line at pixel row 23 to box in a title
7797               *
7798               * ------------------------------------------------------------------------------
7799               *
7800               * Draw a horizontal line at pixel row 23 and move the text cursor down one
7801               * line.
7802               *
7803               * ******************************************************************************
7804               
7805               NLIN:
7806 25BE 020D  20        li   ra,>17*256                 ; LDA #23           ; Set A = 23 so NLIN2 below draws a horizontal line at
     25C0 1700     
7807                                                                          ; pixel row 23
7808               
7809 25C2 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
7810               
7811                                                                          ; Fall through into NLIN2 to draw the horizontal line
7812                                                                          ; at row 23
7813               
7814               * ******************************************************************************
7815               *
7816               * Name: NLIN2
7817               * Type: Subroutine
7818               * Category: Drawing lines
7819               * Summary: Draw a screen-wide horizontal line at the pixel row in A
7820               *
7821               * ------------------------------------------------------------------------------
7822               *
7823               * This draws a line from (2, A) to (254, A), which is almost screen-wide and
7824               * fits in nicely between the white borders without clashing with it.
7825               *
7826               * ------------------------------------------------------------------------------
7827               *
7828               * Arguments:
7829               *
7830               * A                   The pixel row on which to draw the horizontal line
7831               *
7832               * ******************************************************************************
7833               
7834               NLIN2:
7835 25C4 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A
     25C6 0032     
7836               
7837 25C8 020E  20        li   rx,>02*256                 ; LDX #2            ; Set X1 = 2, so (X1, Y1) = (2, A)
     25CA 0200     
7838 25CC D80E  30        movb rx,@X1                     ; STX X1
     25CE 0031     
7839               
7840 25D0 020E  20        li   rx,>fe*256                 ; LDX #254          ; Set X2 = 254, so (X2, Y2) = (254, A)
     25D2 FE00     
7841 25D4 D80E  30        movb rx,@X2                     ; STX X2
     25D6 0033     
7842               
7843 25D8 160A  14        jne  HLOIN                      ; BNE HLOIN         ; Call HLOIN to draw a horizontal line from (2, A) to
7844                                                                          ; (254, A) and return from the subroutine (this BNE is
7845                                                                          ; effectively a JMP as A will never be zero)
7846               
7847               * ******************************************************************************
7848               *
7849               * Name: HLOIN2
7850               * Type: Subroutine
7851               * Category: Drawing lines
7852               * Summary: Remove a line from the sun line heap and draw it on-screen
7853               *
7854               * ------------------------------------------------------------------------------
7855               *
7856               * Specifically, this does the following:
7857               *
7858               * * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
7859               * centre YY(1 0) and length A to the left and right
7860               *
7861               * * Set the Y-th byte of the LSO block to 0 (i.e. remove this line from the
7862               * sun line heap)
7863               *
7864               * * Draw a horizontal line from (X1, Y) to (X2, Y)
7865               *
7866               * ------------------------------------------------------------------------------
7867               *
7868               * Arguments:
7869               *
7870               * YY(1 0)             The x-coordinate of the centre point of the line
7871               *
7872               * A                   The half-width of the line, i.e. the contents of the
7873               * Y-th byte of the sun line heap
7874               *
7875               * Y                   The number of the entry in the sun line heap (which is
7876               * also the y-coordinate of the line)
7877               *
7878               * ------------------------------------------------------------------------------
7879               *
7880               * Returns:
7881               *
7882               * Y                   Y is preserved
7883               *
7884               * ******************************************************************************
7885               
7886               HLOIN2:
7887 25DA 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     25DC B9B2     
7888 25DE 06A0  32        bl   @jsr                       ;
     25E0 FE1E     
7889                                                                          ; line centred on YY(1 0) and with half-width A
7890               
7891 25E2 D80F  30        movb ry,@Y1                     ; STY Y1            ; Set Y1 = Y
     25E4 0032     
7892               
7893 25E6 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     25E8 0000     
7894 25EA DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y
     25EC 0D66     
7895               
7896                                                                          ; Fall through into HLOIN to draw a horizontal line from
7897                                                                          ; (X1, Y) to (X2, Y)
7898               
7899               * ******************************************************************************
7900               *
7901               * Name: HLOIN
7902               * Type: Subroutine
7903               * Category: Drawing lines
7904               * Summary: Draw a horizontal line from (X1, Y1) to (X2, Y1)
7905               * Deep dive: Drawing monochrome pixels in mode 4
7906               *
7907               * ------------------------------------------------------------------------------
7908               *
7909               * We do not draw a pixel at the right end of the line.
7910               *
7911               * To understand how this routine works, you might find it helpful to read the
7912               * deep dive on "Drawing monochrome pixels in mode 4".
7913               *
7914               * ------------------------------------------------------------------------------
7915               *
7916               * Returns:
7917               *
7918               * Y                   Y is preserved
7919               *
7920               * ******************************************************************************
7921               
7922               HLOIN:
7923 25EE D80F  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     25F0 0094     
7924                                                                          ; call to this subroutine
7925               
7926 25F2 D3A0  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     25F4 0031     
7927               
7928 25F6 93A0  30        cb   @X2,rx                     ; CPX X2            ; If X1 = X2 then the start and end points are the same,
     25F8 0033     
7929 25FA 13D8  14        jeq  HL6                        ; BEQ HL6           ; so return from the subroutine (as HL6 contains an RTS)
7930               
7931 25FC 1707  14        jnc  HL5                        ; BCC HL5           ; If X1 < X2, jump to HL5 to skip the following code, as
7932                                                                          ; (X1, Y1) is already the left point
7933               
7934 25FE D360  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2, so we know that (X1, Y1)
     2600 0033     
7935 2602 D80D  30        movb ra,@X1                     ; STA X1            ; is on the left and (X2, Y1) is on the right
     2604 0031     
7936 2606 D80E  30        movb rx,@X2                     ; STX X2
     2608 0033     
7937               
7938 260A D38D  18        movb ra,rx                      ; TAX               ; Set X = X1
7939               
7940               HL5:
7941 260C 7347  18        sb   rone,ra                    ; DEC X2            ; Decrement X2 so we do not draw a pixel at the end
7942                                                                          ; point
7943               
7944 260E D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     2610 0032     
7945 2612 091D  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7946 2614 091D  18        srl  ra,1                       ; LSR A
7947 2616 091D  18        srl  ra,1                       ; LSR A
7948               
7949 2618 026D  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     261A 6000     
7950                                                                          ; us the screen address of the character row (as each
7951                                                                          ; character row takes up 256 bytes, and the first
7952                                                                          ; character row is at screen address &6000, or page &60)
7953               
7954 261C D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     261E 0008     
7955                                                                          ; the high byte of SC is set correctly for drawing our
7956                                                                          ; line
7957               
7958 2620 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 mod 8, which is the pixel row within the
     2622 0032     
7959 2624 024D  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw our line (as
     2626 0700     
7960                                                                          ; each character block has 8 rows)
7961               
7962 2628 D80D  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     262A 0007     
7963                                                                          ; screen address of the far left end (x-coordinate = 0)
7964                                                                          ; of the horizontal pixel row that we want to draw our
7965                                                                          ; horizontal line on
7966               
7967 262C D34E  18        movb rx,ra                      ; TXA               ; Set Y = bits 3-7 of X1
7968 262E 024D  22        andi ra,>f8*256                 ; AND #%11111000
     2630 F800     
7969 2632 D3CD  18        movb ra,ry                      ; TAY
7970               
7971               HL1:
7972 2634 D34E  18        movb rx,ra                      ; TXA               ; Set T = bits 3-7 of X1, which will contain the
7973 2636 024D  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the start of the line * 8
     2638 F800     
7974 263A D80D  30        movb ra,@T                      ; STA T
     263C 00D1     
7975               
7976 263E D360  30        movb @X2,ra                     ; LDA X2            ; Set A = bits 3-7 of X2, which will contain the
     2640 0033     
7977 2642 024D  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the end of the line * 8
     2644 F800     
7978               
7979                      .sec                            ; SEC               ; Set A = A - T, which will contain the number of
     **** ****     > SEC
0001 2646 0A18  18        sla  rmone,1
                   < elite.a99
7980                      .sbc @T,ra                      ; SBC T             ; character blocks we need to fill - 1 * 8
     **** ****     > SBC
0001 2648 1801  14        joc  !
0002 264A 7347  18        sb   rone,ra
0003               !:
0004 264C 7360  30        sb   @T,ra
     264E 00D1     
                   < elite.a99
7981               
7982 2650 134A  14        jeq  HL2                        ; BEQ HL2           ; If A = 0 then the start and end character blocks are
7983                                                                          ; the same, so the whole line fits within one block, so
7984                                                                          ; jump down to HL2 to draw the line
7985               
7986                                                                          ; Otherwise the line spans multiple characters, so we
7987                                                                          ; start with the left character, then do any characters
7988                                                                          ; in the middle, and finish with the right character
7989               
7990 2652 091D  18        srl  ra,1                       ; LSR A             ; Set R = A / 8, so R now contains the number of
7991 2654 091D  18        srl  ra,1                       ; LSR A             ; character blocks we need to fill - 1
7992 2656 091D  18        srl  ra,1                       ; LSR A
7993 2658 D80D  30        movb ra,@R                      ; STA R
     265A 0091     
7994               
7995 265C D360  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     265E 0031     
7996 2660 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2662 0700     
7997 2664 D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7998                                                                          ; wide)
7999               
8000 2666 D36E  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     2668 2731     
8001                                                                          ; right end of the byte (so the filled pixels start at
8002                                                                          ; point X and go all the way to the end of the byte),
8003                                                                          ; which is the shape we want for the left end of the
8004                                                                          ; line
8005               
8006                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 266A D020  30        movb @SC,rtmp
     266C 0007     
0002 266E 2B40  18        xor  rtmp,ra
                   < elite.a99
8007                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 2670 D820  50        movb @SC,@rtmplb
     2672 0007     
     2674 206D     
0002 2676 D020  30        movb @SC+1,rtmp
     2678 0008     
0003 267A A00F  18        a    ry,rtmp
0004 267C D40D  30        movb RA,*rtmp
                   < elite.a99
8008                                                                          ; so we have now drawn the line's left cap
8009               
8010 267E D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8011                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 2680 1701  14        jnc  !
0002 2682 B347  18        ab   rone,ra
0003               !:
0004 2684 022D  22        ai   ra,(>08*256)
     2686 0800     
                   < elite.a99
8012 2688 D3CD  18        movb ra,ry                      ; TAY
8013               
8014 268A D3A0  30        movb @R,rx                      ; LDX R             ; Fetch the number of character blocks we need to fill
     268C 0091     
8015                                                                          ; from R
8016               
8017 268E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8018               
8019 2690 1315  14        jeq  HL3                        ; BEQ HL3           ; If X = 0 then we only have the last block to do (i.e.
8020                                                                          ; the right cap), so jump down to HL3 to draw it
8021               
8022                      .clc                            ; CLC               ; Otherwise clear the C flag so we can do some additions
     **** ****     > CLC
0001 2692 0A16  18        sla  rzero,1
                   < elite.a99
8023                                                                          ; while we draw the character blocks with full-width
8024                                                                          ; lines in them
8025               
8026               HLL1:
8027 2694 020D  20        li   ra,>ff*256                 ; LDA #%11111111    ; Store a full-width 8-pixel horizontal line in SC(1 0)
     2696 FF00     
8028                      .eor @SC                        ; EOR (SC),Y        ; so that it draws the line on-screen, using EOR logic
     **** ****     > EOR
0001 2698 D020  30        movb @SC,rtmp
     269A 0007     
0002 269C 2B40  18        xor  rtmp,ra
                   < elite.a99
8029                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 269E D820  50        movb @SC,@rtmplb
     26A0 0007     
     26A2 206D     
0002 26A4 D020  30        movb @SC+1,rtmp
     26A6 0008     
0003 26A8 A00F  18        a    ry,rtmp
0004 26AA D40D  30        movb RA,*rtmp
                   < elite.a99
8030               
8031 26AC D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8032                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 26AE 1701  14        jnc  !
0002 26B0 B347  18        ab   rone,ra
0003               !:
0004 26B2 022D  22        ai   ra,(>08*256)
     26B4 0800     
                   < elite.a99
8033 26B6 D3CD  18        movb ra,ry                      ; TAY
8034               
8035 26B8 7387  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8036               
8037 26BA 16EC  14        jne  HLL1                       ; BNE HLL1          ; Loop back to draw more full-width lines, if we have
8038                                                                          ; any more to draw
8039               
8040               HL3:
8041 26BC D360  30        movb @X2,ra                     ; LDA X2            ; Now to draw the last character block at the right end
     26BE 0033     
8042 26C0 024D  22        andi ra,>07*256                 ; AND #7            ; of the line, so set X = X2 mod 8, which is the
     26C2 0700     
8043 26C4 D38D  18        movb ra,rx                      ; TAX               ; horizontal pixel number where the line ends
8044               
8045 26C6 D36E  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     26C8 272A     
8046                                                                          ; left end of the byte (so the filled pixels start at
8047                                                                          ; the left edge and go up to point X), which is the
8048                                                                          ; shape we want for the right end of the line
8049               
8050                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 26CA D020  30        movb @SC,rtmp
     26CC 0007     
0002 26CE 2B40  18        xor  rtmp,ra
                   < elite.a99
8051                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 26D0 D820  50        movb @SC,@rtmplb
     26D2 0007     
     26D4 206D     
0002 26D6 D020  30        movb @SC+1,rtmp
     26D8 0008     
0003 26DA A00F  18        a    ry,rtmp
0004 26DC D40D  30        movb RA,*rtmp
                   < elite.a99
8052                                                                          ; so we have now drawn the line's right cap
8053               
8054 26DE D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved across the
     26E0 0094     
8055                                                                          ; call to this subroutine
8056               
8057 26E2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     26E4 FE2A     
8058               
8059               HL2:
8060                                                                          ; If we get here then the entire horizontal line fits
8061                                                                          ; into one character block
8062 26E6 D360  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     26E8 0031     
8063 26EA 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     26EC 0700     
8064 26EE D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
8065                                                                          ; wide)
8066               
8067 26F0 D36E  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     26F2 2731     
8068 26F4 D80D  30        movb ra,@T                      ; STA T             ; right end of the byte (so the filled pixels start at
     26F6 00D1     
8069                                                                          ; point X and go all the way to the end of the byte)
8070               
8071 26F8 D360  30        movb @X2,ra                     ; LDA X2            ; Set X = X2 mod 8, which is the horizontal pixel number
     26FA 0033     
8072 26FC 024D  22        andi ra,>07*256                 ; AND #7            ; where the line ends
     26FE 0700     
8073 2700 D38D  18        movb ra,rx                      ; TAX
8074               
8075 2702 D36E  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     2704 272A     
8076                                                                          ; left end of the byte (so the filled pixels start at
8077                                                                          ; the left edge and go up to point X)
8078               
8079                      .and @T                         ; AND T             ; We now have two bytes, one (T) containing pixels from
     **** ****     > AND
0001 2706 D020  30        movb @T,rtmp
     2708 00D1     
0002 270A 0540  14        inv  rtmp
0003 270C 5340  18        szcb rtmp,ra
                   < elite.a99
8080                                                                          ; the starting point X1 onwards, and the other (A)
8081                                                                          ; containing pixels up to the end point at X2, so we can
8082                                                                          ; get the actual line we want to draw by AND'ing them
8083                                                                          ; together. For example, if we want to draw a line from
8084                                                                          ; point 2 to point 5 (within the row of 8 pixels
8085                                                                          ; numbered from 0 to 7), we would have this:
8086                                                                          ;
8087                                                                          ; T       = %00111111
8088                                                                          ; A       = %11111100
8089                                                                          ; T AND A = %00111100
8090                                                                          ;
8091                                                                          ; So we can stick T AND A in screen memory to get the
8092                                                                          ; line we want, which is what we do here by setting
8093                                                                          ; A = A AND T
8094               
8095                      .eor @SC                        ; EOR (SC),Y        ; Store our horizontal line byte into screen memory at
     **** ****     > EOR
0001 270E D020  30        movb @SC,rtmp
     2710 0007     
0002 2712 2B40  18        xor  rtmp,ra
                   < elite.a99
8096                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; SC(1 0), using EOR logic so it merges with whatever is
     **** ****     > ST_IND_Y_IDX
0001 2714 D820  50        movb @SC,@rtmplb
     2716 0007     
     2718 206D     
0002 271A D020  30        movb @SC+1,rtmp
     271C 0008     
0003 271E A00F  18        a    ry,rtmp
0004 2720 D40D  30        movb RA,*rtmp
                   < elite.a99
8097                                                                          ; already on-screen
8098               
8099 2722 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2724 0094     
8100               
8101 2726 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2728 FE2A     
8102               
8103               * ******************************************************************************
8104               *
8105               * Name: TWFL
8106               * Type: Variable
8107               * Category: Drawing lines
8108               * Summary: Ready-made character rows for the left end of a horizontal line in
8109               * mode 4
8110               *
8111               * ------------------------------------------------------------------------------
8112               *
8113               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8114               * of the split screen). This table provides a byte with pixels at the left end,
8115               * which is used for the right end of the line.
8116               *
8117               * See the HLOIN routine for details.
8118               *
8119               * ******************************************************************************
8120               
8121               TWFL:
8122 272A 80              byte >80
8123 272B   C0            byte >c0
8124 272C E0              byte >e0
8125 272D   F0            byte >f0
8126 272E F8              byte >f8
8127 272F   FC            byte >fc
8128 2730 FE              byte >fe
8129               
8130               * ******************************************************************************
8131               *
8132               * Name: TWFR
8133               * Type: Variable
8134               * Category: Drawing lines
8135               * Summary: Ready-made character rows for the right end of a horizontal line
8136               * in mode 4
8137               *
8138               * ------------------------------------------------------------------------------
8139               *
8140               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8141               * of the split screen). This table provides a byte with pixels at the right end,
8142               * which is used for the left end of the line.
8143               *
8144               * See the HLOIN routine for details.
8145               *
8146               * ******************************************************************************
8147               
8148               TWFR:
8149 2731   FF            byte >ff
8150 2732 7F              byte >7f
8151 2733   3F            byte >3f
8152 2734 1F              byte >1f
8153 2735   0F            byte >0f
8154 2736 07              byte >07
8155 2737   03            byte >03
8156 2738 01              byte >01
8157               
8158               * ******************************************************************************
8159               *
8160               * Name: PX3
8161               * Type: Subroutine
8162               * Category: Drawing pixels
8163               * Summary: Plot a single pixel at (X, Y) within a character block
8164               *
8165               * ------------------------------------------------------------------------------
8166               *
8167               * This routine is called from PIXEL to set 1 pixel within a character block for
8168               * a distant point (i.e. where the distance ZZ >= &90). See the PIXEL routine for
8169               * details, as this routine is effectively part of PIXEL.
8170               *
8171               * ------------------------------------------------------------------------------
8172               *
8173               * Arguments:
8174               *
8175               * X                   The x-coordinate of the pixel within the character block
8176               *
8177               * Y                   The y-coordinate of the pixel within the character block
8178               *
8179               * SC(1 0)             The screen address of the character block
8180               *
8181               * T1                  The value of Y to restore on exit, so Y is preserved by
8182               * the call to PIXEL
8183               *
8184               * ******************************************************************************
8185               
8186               PX3:
8187 273A D36E  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS and EOR it into SC+Y
     273C 2239     
8188                      .eor @SC                        ; EOR (SC),Y
     **** ****     > EOR
0001 273E D020  30        movb @SC,rtmp
     2740 0007     
0002 2742 2B40  18        xor  rtmp,ra
                   < elite.a99
8189                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 2744 D820  50        movb @SC,@rtmplb
     2746 0007     
     2748 206D     
0002 274A D020  30        movb @SC+1,rtmp
     274C 0008     
0003 274E A00F  18        a    ry,rtmp
0004 2750 D40D  30        movb RA,*rtmp
                   < elite.a99
8190               
8191 2752 D3E0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     2754 0006     
8192               
8193 2756 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2758 FE2A     
8194               
8195               * ******************************************************************************
8196               *
8197               * Name: PIX1
8198               * Type: Subroutine
8199               * Category: Maths (Arithmetic)
8200               * Summary: Calculate (YY+1 SYL+Y) = (A P) + (S R) and draw stardust particle
8201               *
8202               * ------------------------------------------------------------------------------
8203               *
8204               * Calculate the following:
8205               *
8206               * (YY+1 SYL+Y) = (A P) + (S R)
8207               *
8208               * and draw a stardust particle at (X1,Y1) with distance ZZ.
8209               *
8210               * ------------------------------------------------------------------------------
8211               *
8212               * Arguments:
8213               *
8214               * (A P)               A is the angle ALPHA or BETA, P is always 0
8215               *
8216               * (S R)               YY(1 0) or YY(1 0) + Q * A
8217               *
8218               * Y                   Stardust particle number
8219               *
8220               * X1                  The x-coordinate offset
8221               *
8222               * Y1                  The y-coordinate offset
8223               *
8224               * ZZ                  The distance of the point (further away = smaller point)
8225               *
8226               * ******************************************************************************
8227               
8228               PIX1:
8229 275A 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     275C 44BA     
8230 275E 06A0  32        bl   @jsr                       ;
     2760 FE1E     
8231               
8232 2762 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY+1 to A, the high byte of the result
     2764 0027     
8233               
8234 2766 D34E  18        movb rx,ra                      ; TXA               ; Set SYL+Y to X, the low byte of the result
8235 2768 DBCD  38        movb ra,@SYL(ry)                ; STA SYL,Y
     276A 0ED5     
8236               
8237                                                                          ; Fall through into PIX1 to draw the stardust particle
8238                                                                          ; at (X1,Y1)
8239               
8240               * ******************************************************************************
8241               *
8242               * Name: PIXEL2
8243               * Type: Subroutine
8244               * Category: Drawing pixels
8245               * Summary: Draw a stardust particle relative to the screen centre
8246               *
8247               * ------------------------------------------------------------------------------
8248               *
8249               * Draw a point (X1, Y1) from the middle of the screen with a size determined by
8250               * a distance value. Used to draw stardust particles.
8251               *
8252               * ------------------------------------------------------------------------------
8253               *
8254               * Arguments:
8255               *
8256               * X1                  The x-coordinate offset
8257               *
8258               * Y1                  The y-coordinate offset (positive means up the screen
8259               * from the centre, negative means down the screen)
8260               *
8261               * ZZ                  The distance of the point (further away = smaller point)
8262               *
8263               * ******************************************************************************
8264               
8265               PIXEL2:
8266 276C D360  30        movb @X1,ra                     ; LDA X1            ; Fetch the x-coordinate offset into A
     276E 0031     
8267               
8268 2770 1508  14        jgt  PX1                        ; BPL PX1           ; If the x-coordinate offset is positive, jump to PX1
8269                                                                          ; to skip the following negation
8270               
8271                      .eoi (>7f*256)                  ; EOR #%01111111    ; The x-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 2772 0200  20        li   rtmp,(>7F*256)
     2774 7F00     
0002 2776 2B40  18        xor  rtmp,ra
                   < elite.a99
8272                      .clc                            ; CLC               ; bits apart from the sign bit and add 1, to convert it
     **** ****     > CLC
0001 2778 0A16  18        sla  rzero,1
                   < elite.a99
8273                      .adi (>01*256)                  ; ADC #1            ; from a sign-magnitude number to a signed number
     **** ****     > ADI
0001 277A 1701  14        jnc  !
0002 277C B347  18        ab   rone,ra
0003               !:
0004 277E 022D  22        ai   ra,(>01*256)
     2780 0100     
                   < elite.a99
8274               
8275               PX1:
8276                      .eoi (>80*256)                  ; EOR #%10000000    ; Set X = X1 + 128
     **** ****     > EOI
0001 2782 0200  20        li   rtmp,(>80*256)
     2784 8000     
0002 2786 2B40  18        xor  rtmp,ra
                   < elite.a99
8277 2788 D38D  18        movb ra,rx                      ; TAX               ;
8278                                                                          ; So X is now the offset converted to an x-coordinate,
8279                                                                          ; centred on x-coordinate 128
8280               
8281 278A D360  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A and clear the
     278C 0032     
8282 278E 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |Y1|
     2790 7F00     
8283               
8284 2792 028D  22        ci   ra,>60*256                 ; CMP #96           ; If |Y1| >= 96 then it's off the screen (as 96 is half
     2794 6000     
8285 2796 1851  14        joc  PX4                        ; BCS PX4           ; the screen height), so return from the subroutine (as
8286                                                                          ; PX4 contains an RTS)
8287               
8288 2798 D360  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A
     279A 0032     
8289               
8290 279C 1507  14        jgt  PX2                        ; BPL PX2           ; If the y-coordinate offset is positive, jump to PX2
8291                                                                          ; to skip the following negation
8292               
8293                      .eoi (>7f*256)                  ; EOR #%01111111    ; The y-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 279E 0200  20        li   rtmp,(>7F*256)
     27A0 7F00     
0002 27A2 2B40  18        xor  rtmp,ra
                   < elite.a99
8294                      .adi (>01*256)                  ; ADC #1            ; bits apart from the sign bit and subtract 1, to negate
     **** ****     > ADI
0001 27A4 1701  14        jnc  !
0002 27A6 B347  18        ab   rone,ra
0003               !:
0004 27A8 022D  22        ai   ra,(>01*256)
     27AA 0100     
                   < elite.a99
8295                                                                          ; it to a positive number, i.e. A is now |Y1|
8296               
8297               PX2:
8298 27AC D80D  30        movb ra,@T                      ; STA T             ; Set A = 97 - Y1
     27AE 00D1     
8299 27B0 020D  20        li   ra,>61*256                 ; LDA #97           ;
     27B2 6100     
8300                      .sbc @T,ra                      ; SBC T             ; So if Y is positive we display the point up from the
     **** ****     > SBC
0001 27B4 1801  14        joc  !
0002 27B6 7347  18        sb   rone,ra
0003               !:
0004 27B8 7360  30        sb   @T,ra
     27BA 00D1     
                   < elite.a99
8301                                                                          ; centre at y-coordinate 97, while a negative Y means
8302                                                                          ; down from the centre
8303               
8304                                                                          ; Fall through into PIXEL to draw the stardust at the
8305                                                                          ; screen coordinates in (X, A)
8306               
8307               * ******************************************************************************
8308               *
8309               * Name: PIXEL
8310               * Type: Subroutine
8311               * Category: Drawing pixels
8312               * Summary: Draw a 1-pixel dot, 2-pixel dash or 4-pixel square
8313               * Deep dive: Drawing monochrome pixels in mode 4
8314               *
8315               * ------------------------------------------------------------------------------
8316               *
8317               * Draw a point at screen coordinate (X, A) with the point size determined by the
8318               * distance in ZZ. This applies to the top part of the screen (the monochrome
8319               * mode 4 portion).
8320               *
8321               * ------------------------------------------------------------------------------
8322               *
8323               * Arguments:
8324               *
8325               * X                   The screen x-coordinate of the point to draw
8326               *
8327               * A                   The screen y-coordinate of the point to draw
8328               *
8329               * ZZ                  The distance of the point (further away = smaller point)
8330               *
8331               * ------------------------------------------------------------------------------
8332               *
8333               * Returns:
8334               *
8335               * Y                   Y is preserved
8336               *
8337               * ------------------------------------------------------------------------------
8338               *
8339               * Other entry points:
8340               *
8341               * PX4                 Contains an RTS
8342               *
8343               * ******************************************************************************
8344               
8345               PIXEL:
8346 27BC D80F  30        movb ry,@T1                     ; STY T1            ; Store Y in T1
     27BE 0006     
8347               
8348 27C0 D3CD  18        movb ra,ry                      ; TAY               ; Copy A into Y, for use later
8349               
8350 27C2 091D  18        srl  ra,1                       ; LSR A             ; Set SCH = &60 + A >> 3
8351 27C4 091D  18        srl  ra,1                       ; LSR A
8352 27C6 091D  18        srl  ra,1                       ; LSR A
8353 27C8 026D  22        ori  ra,>60*256                 ; ORA #&60
     27CA 6000     
8354 27CC D80D  30        movb ra,@SCH                    ; STA SCH
     27CE 0008     
8355               
8356 27D0 D34E  18        movb rx,ra                      ; TXA               ; Set SC = (X >> 3) * 8
8357 27D2 024D  22        andi ra,>f8*256                 ; AND #%11111000
     27D4 F800     
8358 27D6 D80D  30        movb ra,@SC                     ; STA SC
     27D8 0007     
8359               
8360 27DA D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y AND %111
8361 27DC 024D  22        andi ra,>07*256                 ; AND #%00000111
     27DE 0700     
8362 27E0 D3CD  18        movb ra,ry                      ; TAY
8363               
8364 27E2 D34E  18        movb rx,ra                      ; TXA               ; Set X = X AND %111
8365 27E4 024D  22        andi ra,>07*256                 ; AND #%00000111
     27E6 0700     
8366 27E8 D38D  18        movb ra,rx                      ; TAX
8367               
8368 27EA D360  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 144, then this point is a very
     27EC 0097     
8369 27EE 028D  22        ci   ra,>90*256                 ; CMP #144          ; long way away, so jump to PX3 to fetch a 1-pixel point
     27F0 9000     
8370 27F2 18A3  14        joc  PX3                        ; BCS PX3           ; from TWOS and EOR it into SC+Y
8371               
8372 27F4 D36E  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Otherwise fetch a 2-pixel dash from TWOS2 and EOR it
     27F6 2241     
8373                      .eor @SC                        ; EOR (SC),Y        ; into SC+Y
     **** ****     > EOR
0001 27F8 D020  30        movb @SC,rtmp
     27FA 0007     
0002 27FC 2B40  18        xor  rtmp,ra
                   < elite.a99
8374                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 27FE D820  50        movb @SC,@rtmplb
     2800 0007     
     2802 206D     
0002 2804 D020  30        movb @SC+1,rtmp
     2806 0008     
0003 2808 A00F  18        a    ry,rtmp
0004 280A D40D  30        movb RA,*rtmp
                   < elite.a99
8375               
8376 280C D360  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 80, then this point is a medium
     280E 0097     
8377 2810 028D  22        ci   ra,>50*256                 ; CMP #80           ; distance away, so jump to PX13 to stop drawing, as a
     2812 5000     
8378 2814 1810  14        joc  PX13                       ; BCS PX13          ; 2-pixel dash is enough
8379               
8380                                                                          ; Otherwise we keep going to draw another 2 pixel point
8381                                                                          ; either above or below the one we just drew, to make a
8382                                                                          ; 4-pixel square
8383               
8384 2816 73C7  18        sb   rone,ry                    ; DEY               ; Reduce Y by 1 to point to the pixel row above the one
8385 2818 1502  14        jgt  PX14                       ; BPL PX14          ; we just plotted, and if it is still positive, jump to
8386                                                                          ; PX14 to draw our second 2-pixel dash
8387               
8388 281A 020F  20        li   ry,>01*256                 ; LDY #1            ; Reducing Y by 1 made it negative, which means Y was
     281C 0100     
8389                                                                          ; 0 before we did the DEY above, so set Y to 1 to point
8390                                                                          ; to the pixel row after the one we just plotted
8391               
8392               PX14:
8393 281E D36E  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Fetch a 2-pixel dash from TWOS2 and EOR it into this
     2820 2241     
8394                      .eor @SC                        ; EOR (SC),Y        ; second row to make a 4-pixel square
     **** ****     > EOR
0001 2822 D020  30        movb @SC,rtmp
     2824 0007     
0002 2826 2B40  18        xor  rtmp,ra
                   < elite.a99
8395                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 2828 D820  50        movb @SC,@rtmplb
     282A 0007     
     282C 206D     
0002 282E D020  30        movb @SC+1,rtmp
     2830 0008     
0003 2832 A00F  18        a    ry,rtmp
0004 2834 D40D  30        movb RA,*rtmp
                   < elite.a99
8396               
8397               PX13:
8398 2836 D3E0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     2838 0006     
8399               
8400               PX4:
8401 283A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     283C FE2A     
8402               
8403               * ******************************************************************************
8404               *
8405               * Name: BLINE
8406               * Type: Subroutine
8407               * Category: Drawing circles
8408               * Summary: Draw a circle segment and add it to the ball line heap
8409               * Deep dive: The ball line heap
8410               * Drawing circles
8411               *
8412               * ------------------------------------------------------------------------------
8413               *
8414               * Draw a single segment of a circle, adding the point to the ball line heap.
8415               *
8416               * ------------------------------------------------------------------------------
8417               *
8418               * Arguments:
8419               *
8420               * CNT                 The number of this segment
8421               *
8422               * STP                 The step size for the circle
8423               *
8424               * K6(1 0)             The x-coordinate of the new point on the circle, as
8425               * a screen coordinate
8426               *
8427               * (T X)               The y-coordinate of the new point on the circle, as
8428               * an offset from the centre of the circle
8429               *
8430               * FLAG                Set to &FF for the first call, so it sets up the first
8431               * point in the heap but waits until the second call before
8432               * drawing anything (as we need two points, i.e. two calls,
8433               * before we can draw a line)
8434               *
8435               * K4(1 0)             Pixel y-coordinate of the centre of the circle
8436               *
8437               * K5(1 0)             Screen x-coordinate of the previous point added to the
8438               * ball line heap (if this is not the first point)
8439               *
8440               * K5(3 2)             Screen y-coordinate of the previous point added to the
8441               * ball line heap (if this is not the first point)
8442               *
8443               * ------------------------------------------------------------------------------
8444               *
8445               * Returns:
8446               *
8447               * CNT                 CNT is updated to CNT + STP
8448               *
8449               * A                   The new value of CNT
8450               *
8451               * K5(1 0)             Screen x-coordinate of the point that we just added to
8452               * the ball line heap
8453               *
8454               * K5(3 2)             Screen y-coordinate of the point that we just added to
8455               * the ball line heap
8456               *
8457               * FLAG                Set to 0
8458               *
8459               * ******************************************************************************
8460               
8461               BLINE:
8462 283E D34E  18        movb rx,ra                      ; TXA               ; Set K6(3 2) = (T X) + K4(1 0)
8463                      .adc @K4,ra                     ; ADC K4            ; = y-coord of centre + y-coord of new point
     **** ****     > ADC
0001 2840 1701  14        jnc  !
0002 2842 B347  18        ab   rone,ra
0003               !:
0004 2844 B360  30        ab   @K4,ra
     2846 00E0     
                   < elite.a99
8464 2848 D80D  30        movb ra,@K6+2                   ; STA K6+2          ;
     284A 0084     
8465 284C D360  30        movb @K4+1,ra                   ; LDA K4+1          ; so K6(3 2) now contains the y-coordinate of the new
     284E 00E1     
8466                      .adc @T,ra                      ; ADC T             ; point on the circle but as a screen coordinate, to go
     **** ****     > ADC
0001 2850 1701  14        jnc  !
0002 2852 B347  18        ab   rone,ra
0003               !:
0004 2854 B360  30        ab   @T,ra
     2856 00D1     
                   < elite.a99
8467 2858 D80D  30        movb ra,@K6+3                   ; STA K6+3          ; along with the screen x-coordinate in K6(1 0)
     285A 0085     
8468               
8469 285C D360  30        movb @FLAG,ra                   ; LDA FLAG          ; If FLAG = 0, jump down to BL1
     285E 00A3     
8470 2860 130C  14        jeq  BL1                        ; BEQ BL1
8471               
8472 2862 B347  18        ab   rone,ra                    ; INC FLAG          ; Flag is &FF so this is the first call to BLINE, so
8473                                                                          ; increment FLAG to set it to 0, as then the next time
8474                                                                          ; we call BLINE it can draw the first line, from this
8475                                                                          ; point to the next
8476               
8477               BL5:
8478                                                                          ; The following inserts a &FF marker into the LSY2 line
8479                                                                          ; heap to indicate that the next call to BLINE should
8480                                                                          ; store both the (X1, Y1) and (X2, Y2) points. We do
8481                                                                          ; this on the very first call to BLINE (when FLAG is
8482                                                                          ; &FF), and on subsequent calls if the segment does not
8483                                                                          ; fit on-screen, in which case we don't draw or store
8484                                                                          ; that segment, and we start a new segment with the next
8485                                                                          ; call to BLINE that does fit on-screen
8486 2864 D3E0  30        movb @LSP,ry                    ; LDY LSP           ; If byte LSP-1 of LSY2 = &FF, jump to BL7 to tidy up
     2866 0077     
8487 2868 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; and return from the subroutine, as the point that has
     286A FF00     
8488 286C 936F  34        cb   @LSY2-1(ry),ra             ; CMP LSY2-1,Y      ; been passed to BLINE is the start of a segment, so all
     286E 0E73     
8489 2870 135E  14        jeq  BL7                        ; BEQ BL7           ; we need to do is save the coordinate in K5, without
8490                                                                          ; moving the pointer in LSP
8491               
8492 2872 DBCD  38        movb ra,@LSY2(ry)               ; STA LSY2,Y        ; Otherwise we just tried to plot a segment but it
     2874 0E74     
8493                                                                          ; didn't fit on-screen, so put the &FF marker into the
8494                                                                          ; heap for this point, so the next call to BLINE starts
8495                                                                          ; a new segment
8496               
8497 2876 B347  18        ab   rone,ra                    ; INC LSP           ; Increment LSP to point to the next point in the heap
8498               
8499 2878 165A  14        jne  BL7                        ; BNE BL7           ; Jump to BL7 to tidy up and return from the subroutine
8500                                                                          ; (this BNE is effectively a JMP, as LSP will never be
8501                                                                          ; zero)
8502               
8503               BL1:
8504 287A D360  30        movb @K5,ra                     ; LDA K5            ; Set XX15 = K5 = x_lo of previous point
     287C 007E     
8505 287E D80D  30        movb ra,@XX15                   ; STA XX15
     2880 0031     
8506               
8507 2882 D360  30        movb @K5+1,ra                   ; LDA K5+1          ; Set XX15+1 = K5+1 = x_hi of previous point
     2884 007F     
8508 2886 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     2888 0032     
8509               
8510 288A D360  30        movb @K5+2,ra                   ; LDA K5+2          ; Set XX15+2 = K5+2 = y_lo of previous point
     288C 0080     
8511 288E D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     2890 0033     
8512               
8513 2892 D360  30        movb @K5+3,ra                   ; LDA K5+3          ; Set XX15+3 = K5+3 = y_hi of previous point
     2894 0081     
8514 2896 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     2898 0034     
8515               
8516 289A D360  30        movb @K6,ra                     ; LDA K6            ; Set XX15+4 = x_lo of new point
     289C 0082     
8517 289E D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     28A0 0035     
8518               
8519 28A2 D360  30        movb @K6+1,ra                   ; LDA K6+1          ; Set XX15+5 = x_hi of new point
     28A4 0083     
8520 28A6 D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     28A8 0036     
8521               
8522 28AA D360  30        movb @K6+2,ra                   ; LDA K6+2          ; Set XX12 = y_lo of new point
     28AC 0084     
8523 28AE D80D  30        movb ra,@XX12                   ; STA XX12
     28B0 0037     
8524               
8525 28B2 D360  30        movb @K6+3,ra                   ; LDA K6+3          ; Set XX12+1 = y_hi of new point
     28B4 0085     
8526 28B6 D80D  30        movb ra,@XX12+1                 ; STA XX12+1
     28B8 0038     
8527               
8528 28BA 0200  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the new line segment needs to be
     28BC E56C     
8529 28BE 06A0  32        bl   @jsr                       ;
     28C0 FE1E     
8530                                                                          ; clipped to fit on-screen, returning the clipped line's
8531                                                                          ; end-points in (X1, Y1) and (X2, Y2)
8532               
8533 28C2 18D0  14        joc  BL5                        ; BCS BL5           ; If the C flag is set then the line is not visible on
8534                                                                          ; screen anyway, so jump to BL5, to avoid drawing and
8535                                                                          ; storing this line
8536               
8537 28C4 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0, then we didn't have to swap the line
     28C6 00A1     
8538 28C8 1310  14        jeq  BL9                        ; BEQ BL9           ; coordinates around during the clipping process, so
8539                                                                          ; jump to BL9 to skip the following swap
8540               
8541 28CA D360  30        movb @X1,ra                     ; LDA X1            ; Otherwise the coordinates were swapped by the call to
     28CC 0031     
8542 28CE D3E0  30        movb @X2,ry                     ; LDY X2            ; LL145 above, so we swap (X1, Y1) and (X2, Y2) back
     28D0 0033     
8543 28D2 D80D  30        movb ra,@X2                     ; STA X2            ; again
     28D4 0033     
8544 28D6 D80F  30        movb ry,@X1                     ; STY X1
     28D8 0031     
8545 28DA D360  30        movb @Y1,ra                     ; LDA Y1
     28DC 0032     
8546 28DE D3E0  30        movb @Y2,ry                     ; LDY Y2
     28E0 0034     
8547 28E2 D80D  30        movb ra,@Y2                     ; STA Y2
     28E4 0034     
8548 28E6 D80F  30        movb ry,@Y1                     ; STY Y1
     28E8 0032     
8549               
8550               BL9:
8551 28EA D3E0  30        movb @LSP,ry                    ; LDY LSP           ; Set Y = LSP
     28EC 0077     
8552               
8553 28EE D36F  34        movb @LSY2-1(ry),ra             ; LDA LSY2-1,Y      ; If byte LSP-1 of LSY2 is not &FF, jump down to BL8
     28F0 0E73     
8554 28F2 028D  22        ci   ra,>ff*256                 ; CMP #&FF          ; to skip the following (X1, Y1) code
     28F4 FF00     
8555 28F6 1609  14        jne  BL8                        ; BNE BL8
8556               
8557                                                                          ; Byte LSP-1 of LSY2 is &FF, which indicates that we
8558                                                                          ; need to store (X1, Y1) in the heap
8559               
8560 28F8 D360  30        movb @X1,ra                     ; LDA X1            ; Store X1 in the LSP-th byte of LSX2
     28FA 0031     
8561 28FC DBCD  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     28FE 0E26     
8562               
8563 2900 D360  30        movb @Y1,ra                     ; LDA Y1            ; Store Y1 in the LSP-th byte of LSY2
     2902 0032     
8564 2904 DBCD  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2906 0E74     
8565               
8566 2908 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8567               
8568               BL8:
8569 290A D360  30        movb @X2,ra                     ; LDA X2            ; Store X2 in the LSP-th byte of LSX2
     290C 0033     
8570 290E DBCD  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     2910 0E26     
8571               
8572 2912 D360  30        movb @Y2,ra                     ; LDA Y2            ; Store Y2 in the LSP-th byte of LSX2
     2914 0034     
8573 2916 DBCD  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2918 0E74     
8574               
8575 291A B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8576               
8577 291C D80F  30        movb ry,@LSP                    ; STY LSP           ; Update LSP to point to the same as Y
     291E 0077     
8578               
8579 2920 0200  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     2922 224E     
8580 2924 06A0  32        bl   @jsr                       ;
     2926 FE1E     
8581               
8582 2928 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, jump up to BL5 to add a &FF
     292A 0098     
8583 292C 169B  14        jne  BL5                        ; BNE BL5           ; marker to the end of the line heap. XX13 is non-zero
8584                                                                          ; after the call to the clipping routine LL145 above if
8585                                                                          ; the end of the line was clipped, meaning the next line
8586                                                                          ; sent to BLINE can't join onto the end but has to start
8587                                                                          ; a new segment, and that's what inserting the &FF
8588                                                                          ; marker does
8589               
8590               BL7:
8591 292E D360  30        movb @K6,ra                     ; LDA K6            ; Copy the data for this step point from K6(3 2 1 0)
     2930 0082     
8592 2932 D80D  30        movb ra,@K5                     ; STA K5            ; into K5(3 2 1 0), for use in the next call to BLINE:
     2934 007E     
8593 2936 D360  30        movb @K6+1,ra                   ; LDA K6+1          ;
     2938 0083     
8594 293A D80D  30        movb ra,@K5+1                   ; STA K5+1          ; * K5(1 0) = screen x-coordinate of this point
     293C 007F     
8595 293E D360  30        movb @K6+2,ra                   ; LDA K6+2          ;
     2940 0084     
8596 2942 D80D  30        movb ra,@K5+2                   ; STA K5+2          ; * K5(3 2) = screen y-coordinate of this point
     2944 0080     
8597 2946 D360  30        movb @K6+3,ra                   ; LDA K6+3          ;
     2948 0085     
8598 294A D80D  30        movb ra,@K5+3                   ; STA K5+3          ; They now become the "previous point" in the next call
     294C 0081     
8599               
8600 294E D360  30        movb @CNT,ra                    ; LDA CNT           ; Set CNT = CNT + STP
     2950 00A4     
8601                      .clc                            ; CLC
     **** ****     > CLC
0001 2952 0A16  18        sla  rzero,1
                   < elite.a99
8602                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 2954 1701  14        jnc  !
0002 2956 B347  18        ab   rone,ra
0003               !:
0004 2958 B360  30        ab   @STP,ra
     295A 00A6     
                   < elite.a99
8603 295C D80D  30        movb ra,@CNT                    ; STA CNT
     295E 00A4     
8604               
8605 2960 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2962 FE2A     
8606               
8607               * ******************************************************************************
8608               *
8609               * Name: FLIP
8610               * Type: Subroutine
8611               * Category: Stardust
8612               * Summary: Reflect the stardust particles in the screen diagonal and redraw
8613               * the stardust field
8614               *
8615               * ------------------------------------------------------------------------------
8616               *
8617               * Swap the x- and y-coordinates of all the stardust particles and draw the new
8618               * set of particles. Called by LOOK1 when we switch views.
8619               *
8620               * This is a quick way of making the stardust field in the new view feel
8621               * different without having to generate a whole new field. If you look carefully
8622               * at the stardust field when you switch views, you can just about see that the
8623               * new field is a reflection of the previous field in the screen diagonal, i.e.
8624               * in the line from bottom left to top right. This is the line where x = y when
8625               * the origin is in the middle of the screen, and positive x and y are right and
8626               * up, which is the coordinate system we use for stardust).
8627               *
8628               * ******************************************************************************
8629               
8630               FLIP:
8631               * LDA MJ                 \ These instructions are commented out in the original
8632               * BNE FLIP-1             \ source. They would have the effect of not swapping the
8633                                                                          ; stardust if we had mis-jumped into witchspace
8634 2964 D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2966 0F33     
8635                                                                          ; we can use it as a counter through all the stardust
8636               
8637               FLL1:
8638 2968 D3AF  34        movb @SY(ry),rx                 ; LDX SY,Y          ; Copy the Y-th particle's y-coordinate from SY+Y into X
     296A 0EC2     
8639               
8640 296C D36F  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Copy the Y-th particle's x-coordinate from SX+Y into
     296E 034C     
8641 2970 D80D  30        movb ra,@Y1                     ; STA Y1            ; both Y1 and the particle's y-coordinate
     2972 0032     
8642 2974 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y
     2976 0EC2     
8643               
8644 2978 D34E  18        movb rx,ra                      ; TXA               ; Copy the Y-th particle's original y-coordinate into
8645 297A D80D  30        movb ra,@X1                     ; STA X1            ; both X1 and the particle's x-coordinate, so the x- and
     297C 0031     
8646 297E DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; y-coordinates are now swapped and (X1, Y1) contains
     2980 034C     
8647                                                                          ; the particle's new coordinates
8648               
8649 2982 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th particle's distance from SZ+Y into ZZ
     2984 0EE8     
8650 2986 D80D  30        movb ra,@ZZ                     ; STA ZZ
     2988 0097     
8651               
8652 298A 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     298C 276C     
8653 298E 06A0  32        bl   @jsr                       ;
     2990 FE1E     
8654               
8655 2992 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
8656                                                                          ; stardust
8657               
8658 2994 16E9  14        jne  FLL1                       ; BNE FLL1          ; Loop back to FLL1 until we have moved all the stardust
8659                                                                          ; particles
8660               
8661 2996 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2998 FE2A     
8662               
8663               * ******************************************************************************
8664               *
8665               * Name: STARS
8666               * Type: Subroutine
8667               * Category: Stardust
8668               * Summary: The main routine for processing the stardust
8669               *
8670               * ------------------------------------------------------------------------------
8671               *
8672               * Called at the very end of the main flight loop.
8673               *
8674               * ******************************************************************************
8675               
8676               STARS:
8677               * LDA #&FF               \ These instructions are commented out in the original
8678               * STA COL                \ source, but they would set the stardust colour to
8679                                                                          ; white. That said, COL is only used when updating the
8680                                                                          ; dashboard, so this would have no effect - perhaps it's
8681                                                                          ; left over from experiments with a colour top part of
8682                                                                          ; the screen? Who knows...
8683 299A D3A0  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     299C 0D5F     
8684                                                                          ;
8685                                                                          ; 0 = front
8686                                                                          ; 1 = rear
8687                                                                          ; 2 = left
8688                                                                          ; 3 = right
8689               
8690 299E 1306  14        jeq  STARS1                     ; BEQ STARS1        ; If this 0, jump to STARS1 to process the stardust for
8691                                                                          ; the front view
8692               
8693 29A0 7387  18        sb   rone,rx                    ; DEX               ; If this is view 2 or 3, jump to STARS2 (via ST11) to
8694 29A2 1602  14        jne  ST11                       ; BNE ST11          ; process the stardust for the left or right views
8695               
8696 29A4 0460  28        b    @STARS6                    ; JMP STARS6        ; Otherwise this is the rear view, so jump to STARS6 to
     29A6 2BBA     
8697                                                                          ; process the stardust for the rear view
8698               
8699               ST11:
8700 29A8 0460  28        b    @STARS2                    ; JMP STARS2        ; Jump to STARS2 for the left or right views, as it's
     29AA 3F04     
8701                                                                          ; too far for the branch instruction above
8702               
8703               * ******************************************************************************
8704               *
8705               * Name: STARS1
8706               * Type: Subroutine
8707               * Category: Stardust
8708               * Summary: Process the stardust for the front view
8709               * Deep dive: Stardust in the front view
8710               *
8711               * ------------------------------------------------------------------------------
8712               *
8713               * This moves the stardust towards us according to our speed (so the dust rushes
8714               * past us), and applies our current pitch and roll to each particle of dust, so
8715               * the stardust moves correctly when we steer our ship.
8716               *
8717               * When a stardust particle rushes past us and falls off the side of the screen,
8718               * its memory is recycled as a new particle that's positioned randomly on-screen.
8719               *
8720               * These are the calculations referred to in the commentary:
8721               *
8722               * 1. q = 64 * speed / z_hi
8723               * 2. z = z - speed * 64
8724               * 3. y = y + |y_hi| * q
8725               * 4. x = x + |x_hi| * q
8726               *
8727               * 5. y = y + alpha * x / 256
8728               * 6. x = x - alpha * y / 256
8729               *
8730               * 7. x = x + 2 * (beta * y / 256) ^ 2
8731               * 8. y = y - beta * 256
8732               *
8733               * For more information see the deep dive on "Stardust in the front view".
8734               *
8735               * ******************************************************************************
8736               
8737               STARS1:
8738 29AC D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     29AE 0F33     
8739                                                                          ; we can use it as a counter through all the stardust
8740               
8741                                                                          ; In the following, we're going to refer to the 16-bit
8742                                                                          ; space coordinates of the current particle of stardust
8743                                                                          ; (i.e. the Y-th particle) like this:
8744                                                                          ;
8745                                                                          ; x = (x_hi x_lo)
8746                                                                          ; y = (y_hi y_lo)
8747                                                                          ; z = (z_hi z_lo)
8748                                                                          ;
8749                                                                          ; These values are stored in (SX+Y SXL+Y), (SY+Y SYL+Y)
8750                                                                          ; and (SZ+Y SZL+Y) respectively
8751               
8752               STL1:
8753 29B0 0200  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     29B2 45A4     
8754 29B4 06A0  32        bl   @jsr                       ;
     29B6 FE1E     
8755                                                                          ;
8756                                                                          ; (P R) = 256 * DELTA / z_hi
8757                                                                          ; = 256 * speed / z_hi
8758                                                                          ;
8759                                                                          ; The maximum value returned is P = 2 and R = 128 (see
8760                                                                          ; DV42 for an explanation)
8761               
8762 29B8 D360  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     29BA 0091     
8763                                                                          ;
8764                                                                          ; (P A) = 256 * speed / z_hi
8765               
8766                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 29BC D020  30        movb @P,rtmp
     29BE 001B     
0002 29C0 0910  18        srl  rtmp,1
0003 29C2 D800  30        movb rtmp,@P
     29C4 001B     
                   < elite.a99
8767 29C6 06A0  32        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     29C8 FE58     
8768                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 29CA D020  30        movb @P,rtmp
     29CC 001B     
0002 29CE 0910  18        srl  rtmp,1
0003 29D0 D800  30        movb rtmp,@P
     29D2 001B     
                   < elite.a99
8769 29D4 06A0  32        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     29D6 FE58     
8770               
8771 29D8 026D  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     29DA 0100     
8772 29DC D80D  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     29DE 0090     
8773                                                                          ;
8774                                                                          ; Q = 64 * speed / z_hi
8775               
8776 29E0 D36F  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     29E2 0EFB     
8777                      .sbc @DELT4,ra                  ; SBC DELT4         ;
     **** ****     > SBC
0001 29E4 1801  14        joc  !
0002 29E6 7347  18        sb   rone,ra
0003               !:
0004 29E8 7360  30        sb   @DELT4,ra
     29EA 008D     
                   < elite.a99
8778 29EC DBCD  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) - DELT4(1 0)
     29EE 0EFB     
8779                                                                          ;
8780                                                                          ; starting with the low bytes
8781               
8782 29F0 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     29F2 0EE8     
8783 29F4 D80D  30        movb ra,@ZZ                     ; STA ZZ            ;
     29F6 0097     
8784                      .sbc @DELT4+1,ra                ; SBC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > SBC
0001 29F8 1801  14        joc  !
0002 29FA 7347  18        sb   rone,ra
0003               !:
0004 29FC 7360  30        sb   @DELT4+1,ra
     29FE 008E     
                   < elite.a99
8785 2A00 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2A02 0EE8     
8786                                                                          ;
8787                                                                          ; So now we have result 2 above:
8788                                                                          ;
8789                                                                          ; z = z - DELT4(1 0)
8790                                                                          ; = z - speed * 64
8791               
8792 2A04 0200  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2A06 42CE     
8793 2A08 06A0  32        bl   @jsr                       ;
     2A0A FE1E     
8794                                                                          ;
8795                                                                          ; Y1 = y_hi
8796                                                                          ;
8797                                                                          ; (A P) = |y_hi| * Q
8798                                                                          ;
8799                                                                          ; So Y1 contains the original value of y_hi, which we
8800                                                                          ; use below to remove the existing particle
8801               
8802                                                                          ; We now calculate:
8803                                                                          ;
8804                                                                          ; (S R) = YY(1 0) = (A P) + y
8805               
8806 2A0C D80D  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2A0E 0027     
8807 2A10 D360  30        movb @P,ra                      ; LDA P             ;
     2A12 001B     
8808                      .adc @SYL(ry),ra                ; ADC SYL,Y         ; YY+1 = A
     **** ****     > ADC
0001 2A14 1701  14        jnc  !
0002 2A16 B347  18        ab   rone,ra
0003               !:
0004 2A18 B36F  34        ab   @SYL(RY),ra
     2A1A 0ED5     
                   < elite.a99
8809 2A1C D80D  30        movb ra,@YY                     ; STA YY            ; R = YY = P + y_lo
     2A1E 0026     
8810 2A20 D80D  30        movb ra,@R                      ; STA R             ;
     2A22 0091     
8811                                                                          ; so we get this:
8812                                                                          ;
8813                                                                          ; (? R) = YY(1 0) = (A P) + y_lo
8814               
8815 2A24 D360  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2A26 0032     
8816                      .adc @YY+1,ra                   ; ADC YY+1          ;
     **** ****     > ADC
0001 2A28 1701  14        jnc  !
0002 2A2A B347  18        ab   rone,ra
0003               !:
0004 2A2C B360  30        ab   @YY+1,ra
     2A2E 0027     
                   < elite.a99
8817 2A30 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi + YY+1
     2A32 0027     
8818 2A34 D80D  30        movb ra,@S                      ; STA S             ;
     2A36 0092     
8819                                                                          ; so we get our result:
8820                                                                          ;
8821                                                                          ; (S R) = YY(1 0) = (A P) + (y_hi y_lo)
8822                                                                          ; = |y_hi| * Q + y
8823                                                                          ;
8824                                                                          ; which is result 3 above, and (S R) is set to the new
8825                                                                          ; value of y
8826               
8827 2A38 D36F  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2A3A 034C     
8828 2A3C D80D  30        movb ra,@X1                     ; STA X1            ;
     2A3E 0031     
8829                                                                          ; So X1 contains the original value of x_hi, which we
8830                                                                          ; use below to remove the existing particle
8831               
8832 2A40 0200  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2A42 42D6     
8833 2A44 06A0  32        bl   @jsr                       ;
     2A46 FE1E     
8834               
8835                                                                          ; We now calculate:
8836                                                                          ;
8837                                                                          ; XX(1 0) = (A P) + x
8838               
8839 2A48 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2A4A 0025     
8840 2A4C D360  30        movb @P,ra                      ; LDA P             ;
     2A4E 001B     
8841                      .adc @SXL(ry),ra                ; ADC SXL,Y         ; XX(1 0) = (A P) + x_lo
     **** ****     > ADC
0001 2A50 1701  14        jnc  !
0002 2A52 B347  18        ab   rone,ra
0003               !:
0004 2A54 B36F  34        ab   @SXL(RY),ra
     2A56 035F     
                   < elite.a99
8842 2A58 D80D  30        movb ra,@XX                     ; STA XX
     2A5A 0024     
8843               
8844 2A5C D360  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2A5E 0031     
8845                      .adc @XX+1,ra                   ; ADC XX+1          ;
     **** ****     > ADC
0001 2A60 1701  14        jnc  !
0002 2A62 B347  18        ab   rone,ra
0003               !:
0004 2A64 B360  30        ab   @XX+1,ra
     2A66 0025     
                   < elite.a99
8846 2A68 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = XX(1 0) + (x_hi 0)
     2A6A 0025     
8847                                                                          ;
8848                                                                          ; so we get our result:
8849                                                                          ;
8850                                                                          ; XX(1 0) = (A P) + x
8851                                                                          ; = |x_hi| * Q + x
8852                                                                          ;
8853                                                                          ; which is result 4 above, and we also have:
8854                                                                          ;
8855                                                                          ; A = XX+1 = (|x_hi| * Q + x) / 256
8856                                                                          ;
8857                                                                          ; i.e. A is the new value of x, divided by 256
8858               
8859                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2A6C D020  30        movb @ALP2+1,rtmp
     2A6E 0089     
0002 2A70 2B40  18        xor  rtmp,ra
                   < elite.a99
8860                                                                          ; A has the opposite sign to the flipped roll angle
8861                                                                          ; alpha, i.e. it gets the same sign as alpha
8862               
8863 2A72 0200  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2A74 41EE     
8864 2A76 06A0  32        bl   @jsr                       ;
     2A78 FE1E     
8865                                                                          ;
8866                                                                          ; (A P) = A * ALP1
8867                                                                          ; = (x / 256) * alpha
8868               
8869 2A7A 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2A7C 44BA     
8870 2A7E 06A0  32        bl   @jsr                       ;
     2A80 FE1E     
8871                                                                          ;
8872                                                                          ; (A X) = (A P) + (S R)
8873                                                                          ; = (x / 256) * alpha + y
8874                                                                          ; = y + alpha * x / 256
8875               
8876 2A82 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2A84 0027     
8877 2A86 D80E  30        movb rx,@YY                     ; STX YY            ;
     2A88 0026     
8878                                                                          ; YY(1 0) = y + alpha * x / 256
8879                                                                          ;
8880                                                                          ; which is result 5 above, and we also have:
8881                                                                          ;
8882                                                                          ; A = YY+1 = y + alpha * x / 256
8883                                                                          ;
8884                                                                          ; i.e. A is the new value of y, divided by 256
8885               
8886                      .eor @ALP2                      ; EOR ALP2          ; EOR A with the correct sign of the roll angle alpha,
     **** ****     > EOR
0001 2A8A D020  30        movb @ALP2,rtmp
     2A8C 0088     
0002 2A8E 2B40  18        xor  rtmp,ra
                   < elite.a99
8887                                                                          ; so A has the opposite sign to the roll angle alpha
8888               
8889 2A90 0200  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2A92 41DE     
8890 2A94 06A0  32        bl   @jsr                       ;
     2A96 FE1E     
8891                                                                          ;
8892                                                                          ; (S R) = XX(1 0)
8893                                                                          ; = x
8894                                                                          ;
8895                                                                          ; (A P) = A * ALP1
8896                                                                          ; = -y / 256 * alpha
8897               
8898 2A98 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2A9A 44BA     
8899 2A9C 06A0  32        bl   @jsr                       ;
     2A9E FE1E     
8900                                                                          ;
8901                                                                          ; (A X) = (A P) + (S R)
8902                                                                          ; = -y / 256 * alpha + x
8903               
8904 2AA0 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2AA2 0025     
8905 2AA4 D80E  30        movb rx,@XX                     ; STX XX            ;
     2AA6 0024     
8906                                                                          ; x = x - alpha * y / 256
8907               
8908 2AA8 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2AAA 002B     
8909               
8910 2AAC D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2AAE 0027     
8911                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2AB0 D020  30        movb @BET2+1,rtmp
     2AB2 008B     
0002 2AB4 2B40  18        xor  rtmp,ra
                   < elite.a99
8912               
8913 2AB6 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2AB8 41F4     
8914 2ABA 06A0  32        bl   @jsr                       ;
     2ABC FE1E     
8915                                                                          ;
8916                                                                          ; (A P) = X * A
8917                                                                          ; = -beta * y_hi
8918               
8919 2ABE D80D  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2AC0 0090     
8920                                                                          ;
8921                                                                          ; Q = -beta * y_hi / 256
8922               
8923 2AC2 0200  20        li   rtmp,MUT2                  ; JSR MUT2          ; Call MUT2 to calculate:
     2AC4 43E4     
8924 2AC6 06A0  32        bl   @jsr                       ;
     2AC8 FE1E     
8925                                                                          ;
8926                                                                          ; (S R) = XX(1 0) = x
8927                                                                          ;
8928                                                                          ; (A P) = Q * A
8929                                                                          ; = (-beta * y_hi / 256) * (-beta * y_hi / 256)
8930                                                                          ; = (beta * y / 256) ^ 2
8931               
8932                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2ACA D020  30        movb @P,rtmp
     2ACC 001B     
0002 2ACE 0240  22        andi rtmp,>ff00
     2AD0 FF00     
0003 2AD2 0A10  18        sla  rtmp,1
0004 2AD4 D800  30        movb rtmp,@P
     2AD6 001B     
                   < elite.a99
8933 2AD8 06A0  32        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2ADA FE34     
8934 2ADC D80D  30        movb ra,@T                      ; STA T             ;
     2ADE 00D1     
8935                                                                          ; (T P) = (A P) << 1
8936                                                                          ; = 2 * (beta * y / 256) ^ 2
8937               
8938 2AE0 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2AE2 0000     
8939 2AE4 06A0  32        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2AE6 FE58     
8940 2AE8 F360  30        socb @T,ra                      ; ORA T             ;
     2AEA 00D1     
8941                                                                          ; (A P) = (A P) * 2
8942                                                                          ; = 2 * (beta * y / 256) ^ 2
8943                                                                          ;
8944                                                                          ; with the doubling retaining the sign of (A P)
8945               
8946 2AEC 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2AEE 44BA     
8947 2AF0 06A0  32        bl   @jsr                       ;
     2AF2 FE1E     
8948                                                                          ;
8949                                                                          ; (A X) = (A P) + (S R)
8950                                                                          ; = 2 * (beta * y / 256) ^ 2 + x
8951               
8952 2AF4 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2AF6 0025     
8953               
8954 2AF8 D34E  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
8955 2AFA DBCD  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2AFC 035F     
8956               
8957                                                                          ; So (XX+1 x_lo) now contains:
8958                                                                          ;
8959                                                                          ; x = x + 2 * (beta * y / 256) ^ 2
8960                                                                          ;
8961                                                                          ; which is result 7 above
8962               
8963 2AFE D360  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2B00 0026     
8964 2B02 D80D  30        movb ra,@R                      ; STA R
     2B04 0091     
8965 2B06 D360  30        movb @YY+1,ra                   ; LDA YY+1
     2B08 0027     
8966               * JSR MAD                \ These instructions are commented out in the original
8967               * STA S                  \ source
8968               * STX R
8969 2B0A D80D  30        movb ra,@S                      ; STA S
     2B0C 0092     
8970               
8971 2B0E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2B10 0000     
8972 2B12 D80D  30        movb ra,@P                      ; STA P
     2B14 001B     
8973               
8974 2B16 D360  30        movb @BETA,ra                   ; LDA BETA          ; Set A = -beta, so:
     2B18 002A     
8975                      .eoi (>80*256)                  ; EOR #%10000000    ;
     **** ****     > EOI
0001 2B1A 0200  20        li   rtmp,(>80*256)
     2B1C 8000     
0002 2B1E 2B40  18        xor  rtmp,ra
                   < elite.a99
8976                                                                          ; (A P) = (-beta 0)
8977                                                                          ; = -beta * 256
8978               
8979 2B20 0200  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2B22 275A     
8980 2B24 06A0  32        bl   @jsr                       ;
     2B26 FE1E     
8981                                                                          ;
8982                                                                          ; (YY+1 y_lo) = (A P) + (S R)
8983                                                                          ; = -beta * 256 + y
8984                                                                          ;
8985                                                                          ; i.e. y = y - beta * 256, which is result 8 above
8986                                                                          ;
8987                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
8988                                                                          ; ZZ, which will remove the old stardust particle, as we
8989                                                                          ; set X1, Y1 and ZZ to the original values for this
8990                                                                          ; particle during the calculations above
8991               
8992                                                                          ; We now have our newly moved stardust particle at
8993                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
8994                                                                          ; and distance z_hi, so we draw it if it's still on
8995                                                                          ; screen, otherwise we recycle it as a new bit of
8996                                                                          ; stardust and draw that
8997               
8998 2B28 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2B2A 0025     
8999 2B2C D80D  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2B2E 0031     
9000 2B30 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2B32 034C     
9001               
9002 2B34 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 120 then jump to KILL1 to recycle this
     2B36 7F00     
9003 2B38 028D  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the side of the screen,
     2B3A 7800     
9004 2B3C 181C  14        joc  KILL1                      ; BCS KILL1         ; and rejoin at STC1 with the new particle
9005               
9006 2B3E D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2B40 0027     
9007 2B42 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2B44 0EC2     
9008 2B46 D80D  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2B48 0032     
9009               
9010 2B4A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 120 then jump to KILL1 to recycle this
     2B4C 7F00     
9011 2B4E 028D  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the top or bottom of the
     2B50 7800     
9012 2B52 1811  14        joc  KILL1                      ; BCS KILL1         ; screen, and rejoin at STC1 with the new particle
9013               
9014 2B54 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi < 16 then jump to KILL1 to recycle this
     2B56 0EE8     
9015 2B58 028D  22        ci   ra,>10*256                 ; CMP #16           ; particle, as it's so close that it's effectively gone
     2B5A 1000     
9016 2B5C 170C  14        jnc  KILL1                      ; BCC KILL1         ; past us, and rejoin at STC1 with the new particle
9017               
9018 2B5E D80D  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2B60 0097     
9019               
9020               STC1:
9021 2B62 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2B64 276C     
9022 2B66 06A0  32        bl   @jsr                       ;
     2B68 FE1E     
9023                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9024                                                                          ; with distance z_hi
9025               
9026 2B6A 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9027                                                                          ; stardust particle
9028               
9029 2B6C 1302  14        jeq  B18                        ; BEQ B18           ; If we have just done the last particle, skip the next
9030                                                                          ; instruction to return from the subroutine
9031               
9032 2B6E 0460  28        b    @STL1                      ; JMP STL1          ; We have more stardust to process, so jump back up to
     2B70 29B0     
9033                                                                          ; STL1 for the next particle
9034               
9035               B18:
9036 2B72 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2B74 FE2A     
9037               
9038               KILL1:
9039                                                                          ; Our particle of stardust just flew past us, so let's
9040                                                                          ; recycle that particle, starting it at a random
9041                                                                          ; position that isn't too close to the centre point
9042 2B76 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2B78 C07C     
9043 2B7A 06A0  32        bl   @jsr                       ;
     2B7C FE1E     
9044               
9045 2B7E 026D  22        ori  ra,>04*256                 ; ORA #4            ; Make sure A is at least 4 and store it in Y1 and y_hi,
     2B80 0400     
9046 2B82 D80D  30        movb ra,@Y1                     ; STA Y1            ; so the new particle starts at least 4 pixels above or
     2B84 0032     
9047 2B86 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; below the centre of the screen
     2B88 0EC2     
9048               
9049 2B8A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2B8C C07C     
9050 2B8E 06A0  32        bl   @jsr                       ;
     2B90 FE1E     
9051               
9052 2B92 026D  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in X1 and x_hi,
     2B94 0800     
9053 2B96 D80D  30        movb ra,@X1                     ; STA X1            ; so the new particle starts at least 8 pixels either
     2B98 0031     
9054 2B9A DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; side of the centre of the screen
     2B9C 034C     
9055               
9056 2B9E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2BA0 C07C     
9057 2BA2 06A0  32        bl   @jsr                       ;
     2BA4 FE1E     
9058               
9059 2BA6 026D  22        ori  ra,>90*256                 ; ORA #144          ; Make sure A is at least 144 and store it in ZZ and
     2BA8 9000     
9060 2BAA DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; z_hi so the new particle starts in the far distance
     2BAC 0EE8     
9061 2BAE D80D  30        movb ra,@ZZ                     ; STA ZZ
     2BB0 0097     
9062               
9063 2BB2 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A to the new value of y_hi. This has no effect as
     2BB4 0032     
9064                                                                          ; STC1 starts with a jump to PIXEL2, which starts with a
9065                                                                          ; LDA instruction
9066               
9067 2BB6 0460  28        b    @STC1                      ; JMP STC1          ; Jump up to STC1 to draw this new particle
     2BB8 2B62     
9068               
9069               * ******************************************************************************
9070               *
9071               * Name: STARS6
9072               * Type: Subroutine
9073               * Category: Stardust
9074               * Summary: Process the stardust for the rear view
9075               *
9076               * ------------------------------------------------------------------------------
9077               *
9078               * This routine is very similar to STARS1, which processes stardust for the front
9079               * view. The main difference is that the direction of travel is reversed, so the
9080               * signs in the calculations are different, as well as the order of the first
9081               * batch of calculations.
9082               *
9083               * When a stardust particle falls away into the far distance, it is removed from
9084               * the screen and its memory is recycled as a new particle, positioned randomly
9085               * along one of the four edges of the screen.
9086               *
9087               * These are the calculations referred to in the commentary:
9088               *
9089               * 1. q = 64 * speed / z_hi
9090               * 2. z = z - speed * 64
9091               * 3. y = y + |y_hi| * q
9092               * 4. x = x + |x_hi| * q
9093               *
9094               * 5. y = y + alpha * x / 256
9095               * 6. x = x - alpha * y / 256
9096               *
9097               * 7. x = x + 2 * (beta * y / 256) ^ 2
9098               * 8. y = y - beta * 256
9099               *
9100               * For more information see the deep dive on "Stardust in the front view".
9101               *
9102               * ******************************************************************************
9103               
9104               STARS6:
9105 2BBA D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2BBC 0F33     
9106                                                                          ; we can use it as a counter through all the stardust
9107               
9108               STL6:
9109 2BBE 0200  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     2BC0 45A4     
9110 2BC2 06A0  32        bl   @jsr                       ;
     2BC4 FE1E     
9111                                                                          ;
9112                                                                          ; (P R) = 256 * DELTA / z_hi
9113                                                                          ; = 256 * speed / z_hi
9114                                                                          ;
9115                                                                          ; The maximum value returned is P = 2 and R = 128 (see
9116                                                                          ; DV42 for an explanation)
9117               
9118 2BC6 D360  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     2BC8 0091     
9119                                                                          ;
9120                                                                          ; (P A) = 256 * speed / z_hi
9121               
9122                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 2BCA D020  30        movb @P,rtmp
     2BCC 001B     
0002 2BCE 0910  18        srl  rtmp,1
0003 2BD0 D800  30        movb rtmp,@P
     2BD2 001B     
                   < elite.a99
9123 2BD4 06A0  32        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     2BD6 FE58     
9124                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 2BD8 D020  30        movb @P,rtmp
     2BDA 001B     
0002 2BDC 0910  18        srl  rtmp,1
0003 2BDE D800  30        movb rtmp,@P
     2BE0 001B     
                   < elite.a99
9125 2BE2 06A0  32        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     2BE4 FE58     
9126               
9127 2BE6 026D  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     2BE8 0100     
9128 2BEA D80D  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     2BEC 0090     
9129                                                                          ;
9130                                                                          ; Q = 64 * speed / z_hi
9131               
9132 2BEE D36F  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2BF0 034C     
9133 2BF2 D80D  30        movb ra,@X1                     ; STA X1            ;
     2BF4 0031     
9134                                                                          ; So X1 contains the original value of x_hi, which we
9135                                                                          ; use below to remove the existing particle
9136               
9137 2BF6 0200  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2BF8 42D6     
9138 2BFA 06A0  32        bl   @jsr                       ;
     2BFC FE1E     
9139               
9140                                                                          ; We now calculate:
9141                                                                          ;
9142                                                                          ; XX(1 0) = x - (A P)
9143               
9144 2BFE D80D  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2C00 0025     
9145 2C02 D36F  34        movb @SXL(ry),ra                ; LDA SXL,Y         ;
     2C04 035F     
9146                      .sbc @P,ra                      ; SBC P             ; XX(1 0) = x_lo - (A P)
     **** ****     > SBC
0001 2C06 1801  14        joc  !
0002 2C08 7347  18        sb   rone,ra
0003               !:
0004 2C0A 7360  30        sb   @P,ra
     2C0C 001B     
                   < elite.a99
9147 2C0E D80D  30        movb ra,@XX                     ; STA XX
     2C10 0024     
9148               
9149 2C12 D360  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2C14 0031     
9150                      .sbc @XX+1,ra                   ; SBC XX+1          ;
     **** ****     > SBC
0001 2C16 1801  14        joc  !
0002 2C18 7347  18        sb   rone,ra
0003               !:
0004 2C1A 7360  30        sb   @XX+1,ra
     2C1C 0025     
                   < elite.a99
9151 2C1E D80D  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = (x_hi 0) - XX(1 0)
     2C20 0025     
9152                                                                          ;
9153                                                                          ; so we get our result:
9154                                                                          ;
9155                                                                          ; XX(1 0) = x - (A P)
9156                                                                          ; = x - |x_hi| * Q
9157                                                                          ;
9158                                                                          ; which is result 2 above, and we also have:
9159               
9160 2C22 0200  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2C24 42CE     
9161 2C26 06A0  32        bl   @jsr                       ;
     2C28 FE1E     
9162                                                                          ;
9163                                                                          ; Y1 = y_hi
9164                                                                          ;
9165                                                                          ; (A P) = |y_hi| * Q
9166                                                                          ;
9167                                                                          ; So Y1 contains the original value of y_hi, which we
9168                                                                          ; use below to remove the existing particle
9169               
9170                                                                          ; We now calculate:
9171                                                                          ;
9172                                                                          ; (S R) = YY(1 0) = y - (A P)
9173               
9174 2C2A D80D  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2C2C 0027     
9175 2C2E D36F  34        movb @SYL(ry),ra                ; LDA SYL,Y         ;
     2C30 0ED5     
9176                      .sbc @P,ra                      ; SBC P             ; YY+1 = A
     **** ****     > SBC
0001 2C32 1801  14        joc  !
0002 2C34 7347  18        sb   rone,ra
0003               !:
0004 2C36 7360  30        sb   @P,ra
     2C38 001B     
                   < elite.a99
9177 2C3A D80D  30        movb ra,@YY                     ; STA YY            ; R = YY = y_lo - P
     2C3C 0026     
9178 2C3E D80D  30        movb ra,@R                      ; STA R             ;
     2C40 0091     
9179                                                                          ; so we get this:
9180                                                                          ;
9181                                                                          ; (? R) = YY(1 0) = y_lo - (A P)
9182               
9183 2C42 D360  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2C44 0032     
9184                      .sbc @YY+1,ra                   ; SBC YY+1          ;
     **** ****     > SBC
0001 2C46 1801  14        joc  !
0002 2C48 7347  18        sb   rone,ra
0003               !:
0004 2C4A 7360  30        sb   @YY+1,ra
     2C4C 0027     
                   < elite.a99
9185 2C4E D80D  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi - YY+1
     2C50 0027     
9186 2C52 D80D  30        movb ra,@S                      ; STA S             ;
     2C54 0092     
9187                                                                          ; so we get our result:
9188                                                                          ;
9189                                                                          ; (S R) = YY(1 0) = (y_hi y_lo) - (A P)
9190                                                                          ; = y - |y_hi| * Q
9191                                                                          ;
9192                                                                          ; which is result 3 above, and (S R) is set to the new
9193                                                                          ; value of y
9194               
9195 2C56 D36F  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     2C58 0EFB     
9196                      .adc @DELT4,ra                  ; ADC DELT4         ;
     **** ****     > ADC
0001 2C5A 1701  14        jnc  !
0002 2C5C B347  18        ab   rone,ra
0003               !:
0004 2C5E B360  30        ab   @DELT4,ra
     2C60 008D     
                   < elite.a99
9197 2C62 DBCD  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) + DELT4(1 0)
     2C64 0EFB     
9198                                                                          ;
9199                                                                          ; starting with the low bytes
9200               
9201 2C66 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     2C68 0EE8     
9202 2C6A D80D  30        movb ra,@ZZ                     ; STA ZZ            ;
     2C6C 0097     
9203                      .adc @DELT4+1,ra                ; ADC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > ADC
0001 2C6E 1701  14        jnc  !
0002 2C70 B347  18        ab   rone,ra
0003               !:
0004 2C72 B360  30        ab   @DELT4+1,ra
     2C74 008E     
                   < elite.a99
9204 2C76 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2C78 0EE8     
9205                                                                          ;
9206                                                                          ; So now we have result 4 above:
9207                                                                          ;
9208                                                                          ; z = z + DELT4(1 0)
9209                                                                          ; = z + speed * 64
9210               
9211 2C7A D360  30        movb @XX+1,ra                   ; LDA XX+1          ; EOR x with the correct sign of the roll angle alpha,
     2C7C 0025     
9212                      .eor @ALP2                      ; EOR ALP2          ; so A has the opposite sign to the roll angle alpha
     **** ****     > EOR
0001 2C7E D020  30        movb @ALP2,rtmp
     2C80 0088     
0002 2C82 2B40  18        xor  rtmp,ra
                   < elite.a99
9213               
9214 2C84 0200  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2C86 41EE     
9215 2C88 06A0  32        bl   @jsr                       ;
     2C8A FE1E     
9216                                                                          ;
9217                                                                          ; (A P) = A * ALP1
9218                                                                          ; = (-x / 256) * alpha
9219               
9220 2C8C 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2C8E 44BA     
9221 2C90 06A0  32        bl   @jsr                       ;
     2C92 FE1E     
9222                                                                          ;
9223                                                                          ; (A X) = (A P) + (S R)
9224                                                                          ; = (-x / 256) * alpha + y
9225                                                                          ; = y - alpha * x / 256
9226               
9227 2C94 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2C96 0027     
9228 2C98 D80E  30        movb rx,@YY                     ; STX YY            ;
     2C9A 0026     
9229                                                                          ; YY(1 0) = y - alpha * x / 256
9230                                                                          ;
9231                                                                          ; which is result 5 above, and we also have:
9232                                                                          ;
9233                                                                          ; A = YY+1 = y - alpha * x / 256
9234                                                                          ;
9235                                                                          ; i.e. A is the new value of y, divided by 256
9236               
9237                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2C9C D020  30        movb @ALP2+1,rtmp
     2C9E 0089     
0002 2CA0 2B40  18        xor  rtmp,ra
                   < elite.a99
9238                                                                          ; A has the opposite sign to the flipped roll angle
9239                                                                          ; alpha, i.e. it gets the same sign as alpha
9240               
9241 2CA2 0200  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2CA4 41DE     
9242 2CA6 06A0  32        bl   @jsr                       ;
     2CA8 FE1E     
9243                                                                          ;
9244                                                                          ; (S R) = XX(1 0)
9245                                                                          ; = x
9246                                                                          ;
9247                                                                          ; (A P) = A * ALP1
9248                                                                          ; = y / 256 * alpha
9249               
9250 2CAA 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2CAC 44BA     
9251 2CAE 06A0  32        bl   @jsr                       ;
     2CB0 FE1E     
9252                                                                          ;
9253                                                                          ; (A X) = (A P) + (S R)
9254                                                                          ; = y / 256 * alpha + x
9255               
9256 2CB2 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2CB4 0025     
9257 2CB6 D80E  30        movb rx,@XX                     ; STX XX            ;
     2CB8 0024     
9258                                                                          ; x = x + alpha * y / 256
9259               
9260 2CBA D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2CBC 0027     
9261                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2CBE D020  30        movb @BET2+1,rtmp
     2CC0 008B     
0002 2CC2 2B40  18        xor  rtmp,ra
                   < elite.a99
9262               
9263 2CC4 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2CC6 002B     
9264               
9265 2CC8 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2CCA 41F4     
9266 2CCC 06A0  32        bl   @jsr                       ;
     2CCE FE1E     
9267                                                                          ;
9268                                                                          ; (A P) = X * A
9269                                                                          ; = beta * y_hi
9270               
9271 2CD0 D80D  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2CD2 0090     
9272                                                                          ;
9273                                                                          ; Q = beta * y_hi / 256
9274               
9275 2CD4 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set S = x_hi
     2CD6 0025     
9276 2CD8 D80D  30        movb ra,@S                      ; STA S
     2CDA 0092     
9277               
9278                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A, so A now contains -x
     **** ****     > EOI
0001 2CDC 0200  20        li   rtmp,(>80*256)
     2CDE 8000     
0002 2CE0 2B40  18        xor  rtmp,ra
                   < elite.a99
9279               
9280 2CE2 0200  20        li   rtmp,MUT1                  ; JSR MUT1          ; Call MUT1 to calculate:
     2CE4 43EC     
9281 2CE6 06A0  32        bl   @jsr                       ;
     2CE8 FE1E     
9282                                                                          ;
9283                                                                          ; R = XX = x_lo
9284                                                                          ;
9285                                                                          ; (A P) = Q * A
9286                                                                          ; = (beta * y_hi / 256) * (-beta * y_hi / 256)
9287                                                                          ; = (-beta * y / 256) ^ 2
9288               
9289                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2CEA D020  30        movb @P,rtmp
     2CEC 001B     
0002 2CEE 0240  22        andi rtmp,>ff00
     2CF0 FF00     
0003 2CF2 0A10  18        sla  rtmp,1
0004 2CF4 D800  30        movb rtmp,@P
     2CF6 001B     
                   < elite.a99
9290 2CF8 06A0  32        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2CFA FE34     
9291 2CFC D80D  30        movb ra,@T                      ; STA T             ;
     2CFE 00D1     
9292                                                                          ; (T P) = (A P) << 1
9293                                                                          ; = 2 * (-beta * y / 256) ^ 2
9294               
9295 2D00 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2D02 0000     
9296 2D04 06A0  32        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2D06 FE58     
9297 2D08 F360  30        socb @T,ra                      ; ORA T             ;
     2D0A 00D1     
9298                                                                          ; (A P) = -2 * (beta * y / 256) ^ 2
9299                                                                          ;
9300                                                                          ; with the doubling retaining the sign of (A P)
9301               
9302 2D0C 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2D0E 44BA     
9303 2D10 06A0  32        bl   @jsr                       ;
     2D12 FE1E     
9304                                                                          ;
9305                                                                          ; (A X) = (A P) + (S R)
9306                                                                          ; = -2 * (beta * y / 256) ^ 2 + x
9307               
9308 2D14 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2D16 0025     
9309               
9310 2D18 D34E  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
9311 2D1A DBCD  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2D1C 035F     
9312               
9313                                                                          ; So (XX+1 x_lo) now contains:
9314                                                                          ;
9315                                                                          ; x = x - 2 * (beta * y / 256) ^ 2
9316                                                                          ;
9317                                                                          ; which is result 7 above
9318               
9319 2D1E D360  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2D20 0026     
9320 2D22 D80D  30        movb ra,@R                      ; STA R
     2D24 0091     
9321 2D26 D360  30        movb @YY+1,ra                   ; LDA YY+1
     2D28 0027     
9322 2D2A D80D  30        movb ra,@S                      ; STA S
     2D2C 0092     
9323               
9324               * EOR #128               \ These instructions are commented out in the original
9325               * JSR MAD                \ source
9326               * STA S
9327               * STX R
9328               
9329 2D2E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2D30 0000     
9330 2D32 D80D  30        movb ra,@P                      ; STA P
     2D34 001B     
9331               
9332 2D36 D360  30        movb @BETA,ra                   ; LDA BETA          ; Set A = beta, so (A P) = (beta 0) = beta * 256
     2D38 002A     
9333               
9334 2D3A 0200  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2D3C 275A     
9335 2D3E 06A0  32        bl   @jsr                       ;
     2D40 FE1E     
9336                                                                          ;
9337                                                                          ; (YY+1 y_lo) = (A P) + (S R)
9338                                                                          ; = beta * 256 + y
9339                                                                          ;
9340                                                                          ; i.e. y = y + beta * 256, which is result 8 above
9341                                                                          ;
9342                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
9343                                                                          ; ZZ, which will remove the old stardust particle, as we
9344                                                                          ; set X1, Y1 and ZZ to the original values for this
9345                                                                          ; particle during the calculations above
9346               
9347                                                                          ; We now have our newly moved stardust particle at
9348                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
9349                                                                          ; and distance z_hi, so we draw it if it's still on
9350                                                                          ; screen, otherwise we recycle it as a new bit of
9351                                                                          ; stardust and draw that
9352               
9353 2D42 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2D44 0025     
9354 2D46 D80D  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2D48 0031     
9355 2D4A DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2D4C 034C     
9356               
9357 2D4E D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2D50 0027     
9358 2D52 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2D54 0EC2     
9359 2D56 D80D  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2D58 0032     
9360               
9361 2D5A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 110 then jump to KILL6 to recycle this
     2D5C 7F00     
9362 2D5E 028D  22        ci   ra,>6e*256                 ; CMP #110          ; particle, as it's gone off the top or bottom of the
     2D60 6E00     
9363 2D62 1811  14        joc  KILL6                      ; BCS KILL6         ; screen, and rejoin at STC6 with the new particle
9364               
9365 2D64 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi >= 160 then jump to KILL6 to recycle this
     2D66 0EE8     
9366 2D68 028D  22        ci   ra,>a0*256                 ; CMP #160          ; particle, as it's so far away that it's too far to
     2D6A A000     
9367 2D6C 180C  14        joc  KILL6                      ; BCS KILL6         ; see, and rejoin at STC1 with the new particle
9368               
9369 2D6E D80D  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2D70 0097     
9370               
9371               STC6:
9372 2D72 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2D74 276C     
9373 2D76 06A0  32        bl   @jsr                       ;
     2D78 FE1E     
9374                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9375                                                                          ; with distance z_hi
9376               
9377 2D7A 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9378                                                                          ; stardust particle
9379               
9380 2D7C 1302  14        jeq  ST3                        ; BEQ ST3           ; If we have just done the last particle, skip the next
9381                                                                          ; instruction to return from the subroutine
9382               
9383 2D7E 0460  28        b    @STL6                      ; JMP STL6          ; We have more stardust to process, so jump back up to
     2D80 2BBE     
9384                                                                          ; STL6 for the next particle
9385               
9386               ST3:
9387 2D82 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2D84 FE2A     
9388               
9389               KILL6:
9390 2D86 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2D88 C07C     
9391 2D8A 06A0  32        bl   @jsr                       ;
     2D8C FE1E     
9392               
9393 2D8E 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of A to get |A|
     2D90 7F00     
9394               
9395                      .adi (>0a*256)                  ; ADC #10           ; Make sure A is at least 10 and store it in z_hi and
     **** ****     > ADI
0001 2D92 1701  14        jnc  !
0002 2D94 B347  18        ab   rone,ra
0003               !:
0004 2D96 022D  22        ai   ra,(>0A*256)
     2D98 0A00     
                   < elite.a99
9396 2D9A DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; ZZ, so the new particle starts close to us
     2D9C 0EE8     
9397 2D9E D80D  30        movb ra,@ZZ                     ; STA ZZ
     2DA0 0097     
9398               
9399 2DA2 091D  18        srl  ra,1                       ; LSR A             ; Divide A by 2 and randomly set the C flag
9400               
9401 2DA4 1813  14        joc  ST4                        ; BCS ST4           ; Jump to ST4 half the time
9402               
9403 2DA6 091D  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag again
9404               
9405 2DA8 020D  20        li   ra,>fc*256                 ; LDA #252          ; Set A to either +126 or -126 (252 >> 1) depending on
     2DAA FC00     
9406 2DAC 06A0  32        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     2DAE FE58     
9407                                                                          ; the C flag rotated into its sign bit
9408               
9409 2DB0 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on
     2DB2 0031     
9410 2DB4 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; either the left or right edge of the screen
     2DB6 034C     
9411               
9412 2DB8 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2DBA C07C     
9413 2DBC 06A0  32        bl   @jsr                       ;
     2DBE FE1E     
9414               
9415 2DC0 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     2DC2 0032     
9416 2DC4 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along either the left or right edge
     2DC6 0EC2     
9417               
9418 2DC8 0460  28        b    @STC6                      ; JMP STC6          ; Jump up to STC6 to draw this new particle
     2DCA 2D72     
9419               
9420               ST4:
9421 2DCC 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2DCE C07C     
9422 2DD0 06A0  32        bl   @jsr                       ;
     2DD2 FE1E     
9423               
9424 2DD4 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     2DD6 0031     
9425 2DD8 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     2DDA 034C     
9426               
9427 2DDC 091D  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag
9428               
9429 2DDE 020D  20        li   ra,>e6*256                 ; LDA #230          ; Set A to either +115 or -115 (230 >> 1) depending on
     2DE0 E600     
9430 2DE2 06A0  32        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     2DE4 FE58     
9431                                                                          ; the C flag rotated into its sign bit
9432               
9433 2DE6 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts anywhere
     2DE8 0032     
9434 2DEA DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; along either the top or bottom edge of the screen
     2DEC 0EC2     
9435               
9436 2DEE 16C1  14        jne  STC6                       ; BNE STC6          ; Jump up to STC6 to draw this new particle (this BNE is
9437                                                                          ; effectively a JMP as A will never be zero)
9438               
9439               * ******************************************************************************
9440               *
9441               * Name: PRXS
9442               * Type: Variable
9443               * Category: Equipment
9444               * Summary: Equipment prices
9445               *
9446               * ------------------------------------------------------------------------------
9447               *
9448               * Equipment prices are stored as 10 * the actual value, so we can support prices
9449               * with fractions of credits (0.1 Cr). This is used for the price of fuel only.
9450               *
9451               * ******************************************************************************
9452               
9453               PRXS:
9454 2DF0 0100            data >0100                                          ; 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)
9455 2DF2 2C01            data >2c01                                          ; 1  Missile                     30.0 Cr
9456 2DF4 A00F            data >a00f                                          ; 2  Large Cargo Bay            400.0 Cr
9457 2DF6 7017            data >7017                                          ; 3  E.C.M. System              600.0 Cr
9458 2DF8 A00F            data >a00f                                          ; 4  Extra Pulse Lasers         400.0 Cr
9459 2DFA 1027            data >1027                                          ; 5  Extra Beam Lasers         1000.0 Cr
9460 2DFC 8214            data >8214                                          ; 6  Fuel Scoops                525.0 Cr
9461 2DFE 1027            data >1027                                          ; 7  Escape Pod                1000.0 Cr
9462 2E00 2823            data >2823                                          ; 8  Energy Bomb                900.0 Cr
9463 2E02 983A            data >983a                                          ; 9  Energy Unit               1500.0 Cr
9464 2E04 1027            data >1027                                          ; 10 Docking Computer          1000.0 Cr
9465 2E06 50C3            data >50c3                                          ; 11 Galactic Hyperspace       5000.0 Cr
9466               
9467               * ******************************************************************************
9468               *
9469               * Name: STATUS
9470               * Type: Subroutine
9471               * Category: Status
9472               * Summary: Show the Status Mode screen (red key f8)
9473               * Deep dive: Combat rank
9474               *
9475               * ******************************************************************************
9476               
9477               st4_:
9478                                                                          ; We call this from st5 below with the high byte of the
9479                                                                          ; kill tally in A, which is non-zero, and want to return
9480                                                                          ; with the following in X, depending on our rating:
9481                                                                          ;
9482                                                                          ; Competent = 6
9483                                                                          ; Dangerous = 7
9484                                                                          ; Deadly    = 8
9485                                                                          ; Elite     = 9
9486                                                                          ;
9487                                                                          ; The high bytes of the top tier ratings are as follows,
9488                                                                          ; so this a relatively simple calculation:
9489                                                                          ;
9490                                                                          ; Competent       = 1 to 2
9491                                                                          ; Dangerous       = 2 to 9
9492                                                                          ; Deadly          = 10 to 24
9493                                                                          ; Elite           = 25 and up
9494 2E08 020E  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 for an Elite rating
     2E0A 0900     
9495               
9496 2E0C 028D  22        ci   ra,>19*256                 ; CMP #25           ; If A >= 25, jump to st3 to print out our rating, as we
     2E0E 1900     
9497 2E10 185C  14        joc  st3_                       ; BCS st3           ; are Elite
9498               
9499 2E12 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to 8 for a Deadly rating
9500               
9501 2E14 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to st3 to print out our rating, as we
     2E16 0A00     
9502 2E18 1858  14        joc  st3_                       ; BCS st3           ; are Deadly
9503               
9504 2E1A 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to 7 for a Dangerous rating
9505               
9506 2E1C 028D  22        ci   ra,>02*256                 ; CMP #2            ; If A >= 2, jump to st3 to print out our rating, as we
     2E1E 0200     
9507 2E20 1854  14        joc  st3_                       ; BCS st3           ; are Dangerous
9508               
9509 2E22 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to 6 for a Competent rating
9510               
9511 2E24 1652  14        jne  st3_                       ; BNE st3           ; Jump to st3 to print out our rating, as we are
9512                                                                          ; Competent (this BNE is effectively a JMP as A will
9513                                                                          ; never be zero)
9514               
9515               STATUS:
9516 2E26 020D  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     2E28 0800     
9517 2E2A 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Status
     2E2C 4B2A     
9518 2E2E 06A0  32        bl   @jsr                       ;
     2E30 FE1E     
9519                                                                          ; Mode screen)
9520               
9521 2E32 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     2E34 5AB8     
9522 2E36 06A0  32        bl   @jsr                       ;
     2E38 FE1E     
9523                                                                          ; (QQ9, QQ10)
9524               
9525 2E3A 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     2E3C 0700     
9526 2E3E D80D  30        movb ra,@XC                     ; STA XC
     2E40 002C     
9527               
9528 2E42 020D  20        li   ra,>7e*256                 ; LDA #126          ; Print recursive token 126, which prints the top
     2E44 7E00     
9529 2E46 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; four lines of the Status Mode screen:
     2E48 25B0     
9530 2E4A 06A0  32        bl   @jsr                       ;
     2E4C FE1E     
9531                                                                          ;
9532                                                                          ; COMMANDER {commander name}
9533                                                                          ;
9534                                                                          ;
9535                                                                          ; Present System      : {current system name}
9536                                                                          ; Hyperspace System   : {selected system name}
9537                                                                          ; Condition           :
9538                                                                          ;
9539                                                                          ; and draw a horizontal line at pixel row 19 to box
9540                                                                          ; in the title
9541               
9542 2E4E 020D  20        li   ra,>0f*256                 ; LDA #15           ; Set A to token 129 ("{sentence case}DOCKED")
     2E50 0F00     
9543               
9544 2E52 D3E0  30        movb @QQ12,ry                   ; LDY QQ12          ; Fetch the docked status from QQ12, and if we are
     2E54 009F     
9545 2E56 160F  14        jne  st6_                       ; BNE st6           ; docked, jump to st6 to print "Docked" for our
9546                                                                          ; ship's condition
9547               
9548 2E58 020D  20        li   ra,>e6*256                 ; LDA #230          ; Otherwise we are in space, so start off by setting A
     2E5A E600     
9549                                                                          ; to token 70 ("GREEN")
9550               
9551 2E5C D3E0  30        movb @MANY+AST,ry               ; LDY MANY+AST      ; Set Y to the number of asteroids in our local bubble
     2E5E 0D57     
9552                                                                          ; of universe
9553               
9554 2E60 D3AF  34        movb @FRIN+2(ry),rx             ; LDX FRIN+2,Y      ; The ship slots at FRIN are ordered with the first two
     2E62 0D42     
9555                                                                          ; slots reserved for the planet and sun/space station,
9556                                                                          ; and then any ships, so if the slot at FRIN+2+Y is not
9557                                                                          ; empty (i.e. is non-zero), then that means the number
9558                                                                          ; of non-asteroids in the vicinity is at least 1
9559               
9560 2E64 1308  14        jeq  st6_                       ; BEQ st6           ; So if X = 0, there are no ships in the vicinity, so
9561                                                                          ; jump to st6 to print "Green" for our ship's condition
9562               
9563 2E66 D3E0  30        movb @ENERGY,ry                 ; LDY ENERGY        ; Otherwise we have ships in the vicinity, so we load
     2E68 0F13     
9564                                                                          ; our energy levels into Y
9565               
9566 2E6A 028F  22        ci   ry,>80*256                 ; CPY #128          ; Set the C flag if Y >= 128, so C is set if we have
     2E6C 8000     
9567                                                                          ; more than half of our energy banks charged
9568               
9569                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have low
     **** ****     > ADI
0001 2E6E 1701  14        jnc  !
0002 2E70 B347  18        ab   rone,ra
0003               !:
0004 2E72 022D  22        ai   ra,(>01*256)
     2E74 0100     
                   < elite.a99
9570                                                                          ; energy levels) then A is set to token 231 ("RED"),
9571                                                                          ; and if C is set (i.e. we have healthy energy levels)
9572                                                                          ; then A is set to token 232 ("YELLOW")
9573               
9574               st6_:
9575 2E76 0200  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our ship's
     2E78 A6D0     
9576 2E7A 06A0  32        bl   @jsr                       ;
     2E7C FE1E     
9577                                                                          ; condition) followed by a newline
9578               
9579 2E7E 020D  20        li   ra,>7d*256                 ; LDA #125          ; Print recursive token 125, which prints the next
     2E80 7D00     
9580 2E82 0200  20        li   rtmp,spc_                  ; JSR spc           ; three lines of the Status Mode screen:
     2E84 4EFE     
9581 2E86 06A0  32        bl   @jsr                       ;
     2E88 FE1E     
9582                                                                          ;
9583                                                                          ; Fuel: {fuel level} Light Years
9584                                                                          ; Cash: {cash} Cr
9585                                                                          ; Legal Status:
9586                                                                          ;
9587                                                                          ; followed by a space
9588               
9589 2E8A 020D  20        li   ra,>13*256                 ; LDA #19           ; Set A to token 133 ("CLEAN")
     2E8C 1300     
9590               
9591 2E8E D3E0  30        movb @FIST,ry                   ; LDY FIST          ; Fetch our legal status, and if it is 0, we are clean,
     2E90 0334     
9592 2E92 1306  14        jeq  st5_                       ; BEQ st5           ; so jump to st5 to print "Clean"
9593               
9594 2E94 028F  22        ci   ry,>32*256                 ; CPY #50           ; Set the C flag if Y >= 50, so C is set if we have
     2E96 3200     
9595                                                                          ; a legal status of 50+ (i.e. we are a fugitive)
9596               
9597                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have a
     **** ****     > ADI
0001 2E98 1701  14        jnc  !
0002 2E9A B347  18        ab   rone,ra
0003               !:
0004 2E9C 022D  22        ai   ra,(>01*256)
     2E9E 0100     
                   < elite.a99
9598                                                                          ; legal status between 1 and 49) then A is set to token
9599                                                                          ; 134 ("OFFENDER"), and if C is set (i.e. we have a
9600                                                                          ; legal status of 50+) then A is set to token 135
9601                                                                          ; ("FUGITIVE")
9602               
9603               st5_:
9604 2EA0 0200  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our legal
     2EA2 A6D0     
9605 2EA4 06A0  32        bl   @jsr                       ;
     2EA6 FE1E     
9606                                                                          ; status) followed by a newline
9607               
9608 2EA8 020D  20        li   ra,>10*256                 ; LDA #16           ; Print recursive token 130 ("RATING:") followed by a
     2EAA 1000     
9609 2EAC 0200  20        li   rtmp,spc_                  ; JSR spc           ; space
     2EAE 4EFE     
9610 2EB0 06A0  32        bl   @jsr                       ;
     2EB2 FE1E     
9611               
9612 2EB4 D360  30        movb @TALLY+1,ra                ; LDA TALLY+1       ; Fetch the high byte of the kill tally, and if it is
     2EB6 0348     
9613 2EB8 16A7  14        jne  st4_                       ; BNE st4           ; not zero, then we have more than 256 kills, so jump
9614                                                                          ; to st4 to work out whether we are Competent,
9615                                                                          ; Dangerous, Deadly or Elite
9616               
9617                                                                          ; Otherwise we have fewer than 256 kills, so we are one
9618                                                                          ; of Harmless, Mostly Harmless, Poor, Average or Above
9619                                                                          ; Average
9620               
9621 2EBA D38D  18        movb ra,rx                      ; TAX               ; Set X to 0 (as A is 0)
9622               
9623 2EBC D360  30        movb @TALLY,ra                  ; LDA TALLY         ; Set A = lower byte of tally / 4
     2EBE 0347     
9624 2EC0 091D  18        srl  ra,1                       ; LSR A
9625 2EC2 091D  18        srl  ra,1                       ; LSR A
9626               
9627               st5L:
9628                                                                          ; We now loop through bits 2 to 7, shifting each of them
9629                                                                          ; off the end of A until there are no set bits left, and
9630                                                                          ; incrementing X for each shift, so at the end of the
9631                                                                          ; process, X contains the position of the leftmost 1 in
9632                                                                          ; A. Looking at the rank values in TALLY:
9633                                                                          ;
9634                                                                          ; Harmless        = %00000000 to %00000011
9635                                                                          ; Mostly Harmless = %00000100 to %00000111
9636                                                                          ; Poor            = %00001000 to %00001111
9637                                                                          ; Average         = %00010000 to %00011111
9638                                                                          ; Above Average   = %00100000 to %11111111
9639                                                                          ;
9640                                                                          ; we can see that the values returned by this process
9641                                                                          ; are:
9642                                                                          ;
9643                                                                          ; Harmless        = 1
9644                                                                          ; Mostly Harmless = 2
9645                                                                          ; Poor            = 3
9646                                                                          ; Average         = 4
9647                                                                          ; Above Average   = 5
9648 2EC4 B387  18        ab   rone,rx                    ; INX               ; Increment X for each shift
9649               
9650 2EC6 091D  18        srl  ra,1                       ; LSR A             ; Shift A to the right
9651               
9652 2EC8 16FD  14        jne  st5L                       ; BNE st5L          ; Keep looping around until A = 0, which means there are
9653                                                                          ; no set bits left in A
9654               
9655               st3_:
9656 2ECA D34E  18        movb rx,ra                      ; TXA               ; A now contains our rating as a value of 1 to 9, so
9657                                                                          ; transfer X to A, so we can print it out
9658               
9659                      .clc                            ; CLC               ; Print recursive token 135 + A, which will be in the
     **** ****     > CLC
0001 2ECC 0A16  18        sla  rzero,1
                   < elite.a99
9660                      .adi (>15*256)                  ; ADC #21           ; range 136 ("HARMLESS") to 144 ("---- E L I T E ----")
     **** ****     > ADI
0001 2ECE 1701  14        jnc  !
0002 2ED0 B347  18        ab   rone,ra
0003               !:
0004 2ED2 022D  22        ai   ra,(>15*256)
     2ED4 1500     
                   < elite.a99
9661 2ED6 0200  20        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     2ED8 A6D0     
9662 2EDA 06A0  32        bl   @jsr                       ;
     2EDC FE1E     
9663               
9664 2EDE 020D  20        li   ra,>12*256                 ; LDA #18           ; Print recursive token 132, which prints the next bit
     2EE0 1200     
9665 2EE2 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; of the Status Mode screen:
     2EE4 2F94     
9666 2EE6 06A0  32        bl   @jsr                       ;
     2EE8 FE1E     
9667                                                                          ;
9668                                                                          ; EQUIPMENT:
9669                                                                          ;
9670                                                                          ; followed by a newline and an indent of 6 characters
9671               
9672 2EEA D360  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     2EEC 0316     
9673 2EEE 028D  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     2EF0 1A00     
9674 2EF2 1706  14        jnc  B19                        ; BCC B19           ; instructions
9675               
9676 2EF4 020D  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     2EF6 6B00     
9677 2EF8 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; token 107 ("LARGE CARGO{sentence case} BAY"), followed
     2EFA 2F94     
9678 2EFC 06A0  32        bl   @jsr                       ;
     2EFE FE1E     
9679                                                                          ; by a newline and an indent of 6 characters
9680               
9681               B19:
9682 2F00 D360  30        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, skip the
     2F02 0329     
9683 2F04 1306  14        jeq  B20                        ; BEQ B20           ; following two instructions
9684               
9685 2F06 020D  20        li   ra,>6f*256                 ; LDA #111          ; We do have fuel scoops fitted, so print recursive
     2F08 6F00     
9686 2F0A 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; token 111 ("FUEL SCOOPS"), followed by a newline and
     2F0C 2F94     
9687 2F0E 06A0  32        bl   @jsr                       ;
     2F10 FE1E     
9688                                                                          ; an indent of 6 characters
9689               
9690               B20:
9691 2F12 D360  30        movb @ECM,ra                    ; LDA ECM           ; If we don't have an E.C.M. fitted, skip the following
     2F14 0328     
9692 2F16 1306  14        jeq  B21                        ; BEQ B21           ; two instructions
9693               
9694 2F18 020D  20        li   ra,>6c*256                 ; LDA #108          ; We do have an E.C.M. fitted, so print recursive token
     2F1A 6C00     
9695 2F1C 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; 108 ("E.C.M.SYSTEM"), followed by a newline and an
     2F1E 2F94     
9696 2F20 06A0  32        bl   @jsr                       ;
     2F22 FE1E     
9697                                                                          ; indent of 6 characters
9698               
9699               B21:
9700 2F24 020D  20        li   ra,>71*256                 ; LDA #113          ; We now cover the four pieces of equipment whose flags
     2F26 7100     
9701 2F28 D80D  30        movb ra,@XX4                    ; STA XX4           ; are stored in BOMB through BOMB+3, and whose names
     2F2A 00A7     
9702                                                                          ; correspond with text tokens 113 through 116:
9703                                                                          ;
9704                                                                          ; BOMB+0 = BOMB  = token 113 = Energy bomb
9705                                                                          ; BOMB+1 = ENGY  = token 114 = Energy unit
9706                                                                          ; BOMB+2 = DKCMP = token 115 = Docking computer
9707                                                                          ; BOMB+3 = GHYP  = token 116 = Galactic hyperdrive
9708                                                                          ;
9709                                                                          ; We can print these out using a loop, so we set XX4 to
9710                                                                          ; 113 as a counter (and we also set A as well, to pass
9711                                                                          ; through to plf2)
9712               
9713               stqv_:
9714 2F2C D3CD  18        movb ra,ry                      ; TAY               ; Fetch byte BOMB+0 through BOMB+4 for values of XX4
9715 2F2E D3AF  34        movb @BOMB-113(ry),rx           ; LDX BOMB-113,Y    ; from 113 through 117
     2F30 02B9     
9716               
9717 2F32 1304  14        jeq  B22                        ; BEQ B22           ; If it is zero then we do not own that piece of
9718                                                                          ; equipment, so skip the next instruction
9719               
9720 2F34 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the recursive token in A from 113 ("ENERGY
     2F36 2F94     
9721 2F38 06A0  32        bl   @jsr                       ;
     2F3A FE1E     
9722                                                                          ; BOMB") through 116 ("GALACTIC HYPERSPACE "), followed
9723                                                                          ; by a newline and an indent of 6 characters
9724               
9725               B22:
9726 2F3C B347  18        ab   rone,ra                    ; INC XX4           ; Increment the counter (and A as well)
9727 2F3E D360  30        movb @XX4,ra                    ; LDA XX4
     2F40 00A7     
9728               
9729 2F42 028D  22        ci   ra,>75*256                 ; CMP #117          ; If A < 117, loop back up to stqv to print the next
     2F44 7500     
9730 2F46 17F2  14        jnc  stqv_                      ; BCC stqv          ; piece of equipment
9731               
9732 2F48 020E  20        li   rx,>00*256                 ; LDX #0            ; Now to print our ship's lasers, so set a counter in X
     2F4A 0000     
9733                                                                          ; to count through the four views (0 = front, 1 = rear,
9734                                                                          ; 2 = left, 3 = right)
9735               
9736               st_:
9737 2F4C D80E  30        movb rx,@CNT                    ; STX CNT           ; Store the view number in CNT
     2F4E 00A4     
9738               
9739 2F50 D3EE  34        movb @LASER(rx),ry              ; LDY LASER,X       ; Fetch the laser power for view X, and if we do not
     2F52 0310     
9740 2F54 1317  14        jeq  st1_                       ; BEQ st1           ; have a laser fitted to that view, jump to st1 to move
9741                                                                          ; on to the next one
9742               
9743 2F56 D34E  18        movb rx,ra                      ; TXA               ; Print recursive token 96 + X, which will print from 96
9744                      .clc                            ; CLC               ; ("FRONT") through to 99 ("RIGHT"), followed by a space
     **** ****     > CLC
0001 2F58 0A16  18        sla  rzero,1
                   < elite.a99
9745                      .adi (>60*256)                  ; ADC #96
     **** ****     > ADI
0001 2F5A 1701  14        jnc  !
0002 2F5C B347  18        ab   rone,ra
0003               !:
0004 2F5E 022D  22        ai   ra,(>60*256)
     2F60 6000     
                   < elite.a99
9746 2F62 0200  20        li   rtmp,spc_                  ; JSR spc
     2F64 4EFE     
9747 2F66 06A0  32        bl   @jsr                       ;
     2F68 FE1E     
9748               
9749 2F6A 020D  20        li   ra,>67*256                 ; LDA #103          ; Set A to token 103 ("PULSE LASER")
     2F6C 6700     
9750               
9751 2F6E D3A0  30        movb @CNT,rx                    ; LDX CNT           ; If the laser power for view X has bit 7 clear, then it
     2F70 00A4     
9752 2F72 D3EE  34        movb @LASER(rx),ry              ; LDY LASER,X       ; is a pulse laser, so skip the following instruction
     2F74 0310     
9753 2F76 1502  14        jgt  B23                        ; BPL B23
9754               
9755 2F78 020D  20        li   ra,>68*256                 ; LDA #104          ; Set A to token 104 ("BEAM LASER")
     2F7A 6800     
9756               
9757               B23:
9758 2F7C 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the text token in A (which contains the laser
     2F7E 2F94     
9759 2F80 06A0  32        bl   @jsr                       ;
     2F82 FE1E     
9760                                                                          ; type) followed by a newline and an indent of 6
9761                                                                          ; characters
9762               
9763               st1_:
9764 2F84 D3A0  30        movb @CNT,rx                    ; LDX CNT           ; Increment the counter in X and CNT to point to the
     2F86 00A4     
9765 2F88 B387  18        ab   rone,rx                    ; INX               ; next view
9766               
9767 2F8A 028E  22        ci   rx,>04*256                 ; CPX #4            ; If this isn't the last of the four views, jump back up
     2F8C 0400     
9768 2F8E 17DE  14        jnc  st_                        ; BCC st            ; to st to print out the next one
9769               
9770 2F90 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2F92 FE2A     
9771               
9772               * ******************************************************************************
9773               *
9774               * Name: plf2
9775               * Type: Subroutine
9776               * Category: Text
9777               * Summary: Print text followed by a newline and indent of 6 characters
9778               *
9779               * ------------------------------------------------------------------------------
9780               *
9781               * Print a text token followed by a newline, and indent the next line to text
9782               * column 6.
9783               *
9784               * ------------------------------------------------------------------------------
9785               *
9786               * Arguments:
9787               *
9788               * A                   The text token to be printed
9789               *
9790               * ******************************************************************************
9791               
9792               plf2_:
9793 2F94 0200  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A followed by a newline
     2F96 A6D0     
9794 2F98 06A0  32        bl   @jsr                       ;
     2F9A FE1E     
9795               
9796 2F9C 020E  20        li   rx,>06*256                 ; LDX #6            ; Move the text cursor to column 6
     2F9E 0600     
9797 2FA0 D80E  30        movb rx,@XC                     ; STX XC
     2FA2 002C     
9798               
9799 2FA4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2FA6 FE2A     
9800               
9801               * ******************************************************************************
9802               *
9803               * Name: TENS
9804               * Type: Variable
9805               * Category: Text
9806               * Summary: A constant used when printing large numbers in BPRNT
9807               * Deep dive: Printing decimal numbers
9808               *
9809               * ------------------------------------------------------------------------------
9810               *
9811               * Contains the four low bytes of the value 100,000,000,000 (100 billion).
9812               *
9813               * The maximum number of digits that we can print with the BPRNT routine is 11,
9814               * so the biggest number we can print is 99,999,999,999. This maximum number
9815               * plus 1 is 100,000,000,000, which in hexadecimal is:
9816               *
9817               * & 17 48 76 E8 00
9818               *
9819               * The TENS variable contains the lowest four bytes in this number, with the
9820               * most significant byte first, i.e. 48 76 E8 00. This value is used in the
9821               * BPRNT routine when working out which decimal digits to print when printing a
9822               * number.
9823               *
9824               * ******************************************************************************
9825               
9826               TENS:
9827 2FA8 0000            data >0000, >0000
     2FAA 0000     
9828               
9829               * ******************************************************************************
9830               *
9831               * Name: pr2
9832               * Type: Subroutine
9833               * Category: Text
9834               * Summary: Print an 8-bit number, left-padded to 3 digits, and optional point
9835               *
9836               * ------------------------------------------------------------------------------
9837               *
9838               * Print the 8-bit number in X to 3 digits, left-padding with spaces for numbers
9839               * with fewer than 3 digits (so numbers < 100 are right-aligned). Optionally
9840               * include a decimal point.
9841               *
9842               * ------------------------------------------------------------------------------
9843               *
9844               * Arguments:
9845               *
9846               * X                   The number to print
9847               *
9848               * C flag              If set, include a decimal point
9849               *
9850               * ------------------------------------------------------------------------------
9851               *
9852               * Other entry points:
9853               *
9854               * pr2+2               Print the 8-bit number in X to the number of digits in A
9855               *
9856               * ******************************************************************************
9857               
9858               pr2_:
9859 2FAC 020D  20        li   ra,>03*256                 ; LDA #3            ; Set A to the number of digits (3)
     2FAE 0300     
9860               
9861 2FB0 020F  20        li   ry,>00*256                 ; LDY #0            ; Zero the Y register, so we can fall through into TT11
     2FB2 0000     
9862                                                                          ; to print the 16-bit number (Y X) to 3 digits, which
9863                                                                          ; effectively prints X to 3 digits as the high byte is
9864                                                                          ; zero
9865               
9866               * ******************************************************************************
9867               *
9868               * Name: TT11
9869               * Type: Subroutine
9870               * Category: Text
9871               * Summary: Print a 16-bit number, left-padded to n digits, and optional point
9872               *
9873               * ------------------------------------------------------------------------------
9874               *
9875               * Print the 16-bit number in (Y X) to a specific number of digits, left-padding
9876               * with spaces for numbers with fewer digits (so lower numbers will be right-
9877               * aligned). Optionally include a decimal point.
9878               *
9879               * ------------------------------------------------------------------------------
9880               *
9881               * Arguments:
9882               *
9883               * X                   The low byte of the number to print
9884               *
9885               * Y                   The high byte of the number to print
9886               *
9887               * A                   The number of digits
9888               *
9889               * C flag              If set, include a decimal point
9890               *
9891               * ******************************************************************************
9892               
9893               TT11:
9894 2FB4 D80D  30        movb ra,@U                      ; STA U             ; We are going to use the BPRNT routine (below) to
     2FB6 008F     
9895                                                                          ; print this number, so we store the number of digits
9896                                                                          ; in U, as that's what BPRNT takes as an argument
9897               
9898 2FB8 020D  20        li   ra,>00*256                 ; LDA #0            ; BPRNT takes a 32-bit number in K to K+3, with the
     2FBA 0000     
9899 2FBC D80D  30        movb ra,@K                      ; STA K             ; most significant byte first (big-endian), so we set
     2FBE 003D     
9900 2FC0 D80D  30        movb ra,@K+1                    ; STA K+1           ; the two most significant bytes to zero (K and K+1)
     2FC2 003E     
9901 2FC4 D80F  30        movb ry,@K+2                    ; STY K+2           ; and store (Y X) in the least two significant bytes
     2FC6 003F     
9902 2FC8 D80E  30        movb rx,@K+3                    ; STX K+3           ; (K+2 and K+3), so we are going to print the 32-bit
     2FCA 0040     
9903                                                                          ; number (0 0 Y X)
9904               
9905                                                                          ; Finally we fall through into BPRNT to print out the
9906                                                                          ; number in K to K+3, which now contains (Y X), to 3
9907                                                                          ; digits (as U = 3), using the same C flag as when pr2
9908                                                                          ; was called to control the decimal point
9909               
9910               * ******************************************************************************
9911               *
9912               * Name: BPRNT
9913               * Type: Subroutine
9914               * Category: Text
9915               * Summary: Print a 32-bit number, left-padded to a specific number of digits,
9916               * with an optional decimal point
9917               * Deep dive: Printing decimal numbers
9918               *
9919               * ------------------------------------------------------------------------------
9920               *
9921               * Print the 32-bit number stored in K(0 1 2 3) to a specific number of digits,
9922               * left-padding with spaces for numbers with fewer digits (so lower numbers are
9923               * right-aligned). Optionally include a decimal point.
9924               *
9925               * See the deep dive on "Printing decimal numbers" for details of the algorithm
9926               * used in this routine.
9927               *
9928               * ------------------------------------------------------------------------------
9929               *
9930               * Arguments:
9931               *
9932               * K(0 1 2 3)          The number to print, stored with the most significant
9933               * byte in K and the least significant in K+3 (i.e. as a
9934               * big-endian number, which is the opposite way to how the
9935               * 6502 assembler stores addresses, for example)
9936               *
9937               * U                   The maximum number of digits to print, including the
9938               * decimal point (spaces will be used on the left to pad
9939               * out the result to this width, so the number is right-
9940               * aligned to this width). U must be 11 or less
9941               *
9942               * C flag              If set, include a decimal point followed by one
9943               * fractional digit (i.e. show the number to 1 decimal
9944               * place). In this case, the number in K(0 1 2 3) contains
9945               * 10 * the number we end up printing, so to print 123.4,
9946               * we would pass 1234 in K(0 1 2 3) and would set the C
9947               * flag to include the decimal point
9948               *
9949               * ******************************************************************************
9950               
9951               BPRNT:
9952 2FCC 020E  20        li   rx,>0b*256                 ; LDX #11           ; Set T to the maximum number of digits allowed (11
     2FCE 0B00     
9953 2FD0 D80E  30        movb rx,@T                      ; STX T             ; characters, which is the number of digits in 10
     2FD2 00D1     
9954                                                                          ; billion). We will use this as a flag when printing
9955                                                                          ; characters in TT37 below
9956               
9957                      .php                            ; PHP               ; Make a copy of the status register (in particular
     **** ****     > PHP
0001 2FD4 02C0  12        stst rtmp
0002 2FD6 D680  30        movb rtmp,*rsp
0003 2FD8 060A  14        dec  rsp
                   < elite.a99
9958                                                                          ; the C flag) so we can retrieve it later
9959               
9960 2FDA 1702  14        jnc  TT30                       ; BCC TT30          ; If the C flag is clear, we do not want to print a
9961                                                                          ; decimal point, so skip the next two instructions
9962               
9963 2FDC 7347  18        sb   rone,ra                    ; DEC T             ; As we are going to show a decimal point, decrement
9964 2FDE 7347  18        sb   rone,ra                    ; DEC U             ; both the number of characters and the number of
9965                                                                          ; digits (as one of them is now a decimal point)
9966               
9967               TT30:
9968 2FE0 020D  20        li   ra,>0b*256                 ; LDA #11           ; Set A to 11, the maximum number of digits allowed
     2FE2 0B00     
9969               
9970                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 2FE4 0A18  18        sla  rmone,1
                   < elite.a99
9971                                                                          ; C flag affecting the result
9972               
9973 2FE6 D80D  30        movb ra,@XX17                   ; STA XX17          ; Store the maximum number of digits allowed (11) in
     2FE8 0095     
9974                                                                          ; XX17
9975               
9976                      .sbc @U,ra                      ; SBC U             ; Set U = 11 - U + 1, so U now contains the maximum
     **** ****     > SBC
0001 2FEA 1801  14        joc  !
0002 2FEC 7347  18        sb   rone,ra
0003               !:
0004 2FEE 7360  30        sb   @U,ra
     2FF0 008F     
                   < elite.a99
9977 2FF2 D80D  30        movb ra,@U                      ; STA U             ; number of digits minus the number of digits we want
     2FF4 008F     
9978 2FF6 B347  18        ab   rone,ra                    ; INC U             ; to display, plus 1 (so this is the number of digits
9979                                                                          ; we should skip before starting to print the number
9980                                                                          ; itself, and the plus 1 is there to ensure we print at
9981                                                                          ; least one digit)
9982               
9983 2FF8 020F  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     2FFA 0000     
9984                                                                          ; of times we subtract 10 billion to get the leftmost
9985                                                                          ; digit, so set this to zero
9986               
9987 2FFC D80F  30        movb ry,@S                      ; STY S             ; In the main loop below, we use location S as an
     2FFE 0092     
9988                                                                          ; 8-bit overflow for the 32-bit calculations, so
9989                                                                          ; we need to set this to 0 before joining the loop
9990               
9991 3000 0460  28        b    @TT36                      ; JMP TT36          ; Jump to TT36 to start the process of printing this
     3002 30D4     
9992                                                                          ; number's digits
9993               
9994               TT35:
9995                                                                          ; This subroutine multiplies K(S 0 1 2 3) by 10 and
9996                                                                          ; stores the result back in K(S 0 1 2 3), using the fact
9997                                                                          ; that K * 10 = (K * 2) + (K * 2 * 2 * 2)
9998                      .asl @K+3                       ; ASL K+3           ; Set K(S 0 1 2 3) = K(S 0 1 2 3) * 2 by rotating left
     **** ****     > ASL
0001 3004 D020  30        movb @K+3,rtmp
     3006 0040     
0002 3008 0240  22        andi rtmp,>ff00
     300A FF00     
0003 300C 0A10  18        sla  rtmp,1
0004 300E D800  30        movb rtmp,@K+3
     3010 0040     
                   < elite.a99
9999 3012 0204  20        li   rarg1,K+2                  ; ROL K+2
     3014 003F     
10000 3016 06A0  32        bl   @rol                       ;
     3018 FE44     
10001 301A 0204  20        li   rarg1,K+1                  ; ROL K+1
     301C 003E     
10002 301E 06A0  32        bl   @rol                       ;
     3020 FE44     
10003 3022 0204  20        li   rarg1,K                    ; ROL K
     3024 003D     
10004 3026 06A0  32        bl   @rol                       ;
     3028 FE44     
10005 302A 0204  20        li   rarg1,S                    ; ROL S
     302C 0092     
10006 302E 06A0  32        bl   @rol                       ;
     3030 FE44     
10007               
10008 3032 020E  20        li   rx,>03*256                 ; LDX #3            ; Now we want to make a copy of the newly doubled K in
     3034 0300     
10009                                                                          ; XX15, so we can use it for the first (K * 2) in the
10010                                                                          ; equation above, so set up a counter in X for copying
10011                                                                          ; four bytes, starting with the last byte in memory
10012                                                                          ; (i.e. the least significant)
10013               
10014               tt35_:
10015 3036 D36E  34        movb @K(rx),ra                  ; LDA K,X           ; Copy the X-th byte of K(0 1 2 3) to the X-th byte of
     3038 003D     
10016 303A DB8D  38        movb ra,@XX15(rx)               ; STA XX15,X        ; XX15(0 1 2 3), so that XX15 will contain a copy of
     303C 0031     
10017                                                                          ; K(0 1 2 3) once we've copied all four bytes
10018               
10019 303E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10020               
10021 3040 15FA  14        jgt  tt35_                      ; BPL tt35          ; Loop back to copy the next byte until we have copied
10022                                                                          ; all four
10023               
10024 3042 D360  30        movb @S,ra                      ; LDA S             ; Store the value of location S, our overflow byte, in
     3044 0092     
10025 3046 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; XX15+4, so now XX15(4 0 1 2 3) contains a copy of
     3048 0035     
10026                                                                          ; K(S 0 1 2 3), which is the value of (K * 2) that we
10027                                                                          ; want to use in our calculation
10028               
10029                      .asl @K+3                       ; ASL K+3           ; Now to calculate the (K * 2 * 2 * 2) part. We still
     **** ****     > ASL
0001 304A D020  30        movb @K+3,rtmp
     304C 0040     
0002 304E 0240  22        andi rtmp,>ff00
     3050 FF00     
0003 3052 0A10  18        sla  rtmp,1
0004 3054 D800  30        movb rtmp,@K+3
     3056 0040     
                   < elite.a99
10030 3058 0204  20        li   rarg1,K+2                  ; ROL K+2           ; have (K * 2) in K(S 0 1 2 3), so we just need to shift
     305A 003F     
10031 305C 06A0  32        bl   @rol                       ;
     305E FE44     
10032 3060 0204  20        li   rarg1,K+1                  ; ROL K+1           ; it twice. This is the first one, so we do this:
     3062 003E     
10033 3064 06A0  32        bl   @rol                       ;
     3066 FE44     
10034 3068 0204  20        li   rarg1,K                    ; ROL K             ;
     306A 003D     
10035 306C 06A0  32        bl   @rol                       ;
     306E FE44     
10036 3070 0204  20        li   rarg1,S                    ; ROL S             ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 4
     3072 0092     
10037 3074 06A0  32        bl   @rol                       ;
     3076 FE44     
10038               
10039                      .asl @K+3                       ; ASL K+3           ; And then we do it again, so that means:
     **** ****     > ASL
0001 3078 D020  30        movb @K+3,rtmp
     307A 0040     
0002 307C 0240  22        andi rtmp,>ff00
     307E FF00     
0003 3080 0A10  18        sla  rtmp,1
0004 3082 D800  30        movb rtmp,@K+3
     3084 0040     
                   < elite.a99
10040 3086 0204  20        li   rarg1,K+2                  ; ROL K+2           ;
     3088 003F     
10041 308A 06A0  32        bl   @rol                       ;
     308C FE44     
10042 308E 0204  20        li   rarg1,K+1                  ; ROL K+1           ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 8
     3090 003E     
10043 3092 06A0  32        bl   @rol                       ;
     3094 FE44     
10044 3096 0204  20        li   rarg1,K                    ; ROL K
     3098 003D     
10045 309A 06A0  32        bl   @rol                       ;
     309C FE44     
10046 309E 0204  20        li   rarg1,S                    ; ROL S
     30A0 0092     
10047 30A2 06A0  32        bl   @rol                       ;
     30A4 FE44     
10048               
10049                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 30A6 0A16  18        sla  rzero,1
                   < elite.a99
10050                                                                          ; C flag affecting the result
10051               
10052 30A8 020E  20        li   rx,>03*256                 ; LDX #3            ; By now we've got (K * 2) in XX15(4 0 1 2 3) and
     30AA 0300     
10053                                                                          ; (K * 8) in K(S 0 1 2 3), so the final step is to add
10054                                                                          ; these two 32-bit numbers together to get K * 10.
10055                                                                          ; So we set a counter in X for four bytes, starting
10056                                                                          ; with the last byte in memory (i.e. the least
10057                                                                          ; significant)
10058               
10059               tt36_:
10060 30AC D36E  34        movb @K(rx),ra                  ; LDA K,X           ; Fetch the X-th byte of K into A
     30AE 003D     
10061               
10062                      .adc @XX15(rx),ra               ; ADC XX15,X        ; Add the X-th byte of XX15 to A, with carry
     **** ****     > ADC
0001 30B0 1701  14        jnc  !
0002 30B2 B347  18        ab   rone,ra
0003               !:
0004 30B4 B36E  34        ab   @XX15(RX),ra
     30B6 0031     
                   < elite.a99
10063               
10064 30B8 DB8D  38        movb ra,@K(rx)                  ; STA K,X           ; Store the result in the X-th byte of K
     30BA 003D     
10065               
10066 30BC 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10067               
10068 30BE 15F6  14        jgt  tt36_                      ; BPL tt36          ; Loop back to add the next byte, moving from the least
10069                                                                          ; significant byte to the most significant, until we
10070                                                                          ; have added all four
10071               
10072 30C0 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Finally, fetch the overflow byte from XX15(4 0 1 2 3)
     30C2 0035     
10073               
10074                      .adc @S,ra                      ; ADC S             ; And add it to the overflow byte from K(S 0 1 2 3),
     **** ****     > ADC
0001 30C4 1701  14        jnc  !
0002 30C6 B347  18        ab   rone,ra
0003               !:
0004 30C8 B360  30        ab   @S,ra
     30CA 0092     
                   < elite.a99
10075                                                                          ; with carry
10076               
10077 30CC D80D  30        movb ra,@S                      ; STA S             ; And store the result in the overflow byte from
     30CE 0092     
10078                                                                          ; K(S 0 1 2 3), so now we have our desired result, i.e.
10079                                                                          ;
10080                                                                          ; K(S 0 1 2 3) = K(S 0 1 2 3) * 10
10081               
10082 30D0 020F  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     30D2 0000     
10083                                                                          ; of times we subtract 10 billion to get the leftmost
10084                                                                          ; digit, so set this to zero so we can rejoin the main
10085                                                                          ; loop for another subtraction process
10086               
10087               TT36:
10088                                                                          ; This is the main loop of our digit-printing routine.
10089                                                                          ; In the following loop, we are going to count the
10090                                                                          ; number of times that we can subtract 10 million and
10091                                                                          ; store that count in Y, which we have already set to 0
10092 30D4 020E  20        li   rx,>03*256                 ; LDX #3            ; Our first calculation concerns 32-bit numbers, so
     30D6 0300     
10093                                                                          ; set up a counter for a four-byte loop
10094               
10095                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 30D8 0A18  18        sla  rmone,1
                   < elite.a99
10096                                                                          ; C flag affecting the result
10097               
10098               tt37_:
10099                                                                          ; We now loop through each byte in turn to do this:
10100                                                                          ;
10101                                                                          ; XX15(4 0 1 2 3) = K(S 0 1 2 3) - 100,000,000,000
10102 30DA D36E  34        movb @K(rx),ra                  ; LDA K,X           ; Subtract the X-th byte of TENS (i.e. 10 billion) from
     30DC 003D     
10103                      .sbc @TENS(rx),ra               ; SBC TENS,X        ; the X-th byte of K
     **** ****     > SBC
0001 30DE 1801  14        joc  !
0002 30E0 7347  18        sb   rone,ra
0003               !:
0004 30E2 736E  34        sb   @TENS(RX),ra
     30E4 2FA8     
                   < elite.a99
10104               
10105 30E6 DB8D  38        movb ra,@XX15(rx)               ; STA XX15,X        ; Store the result in the X-th byte of XX15
     30E8 0031     
10106               
10107 30EA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10108               
10109 30EC 15F6  14        jgt  tt37_                      ; BPL tt37          ; Loop back to subtract the next byte, moving from the
10110                                                                          ; least significant byte to the most significant, until
10111                                                                          ; we have subtracted all four
10112               
10113 30EE D360  30        movb @S,ra                      ; LDA S             ; Subtract the fifth byte of 10 billion (i.e. &17) from
     30F0 0092     
10114                      .sbi (>17*256)                  ; SBC #&17          ; the fifth (overflow) byte of K, which is S
     **** ****     > SBI
0001 30F2 1801  14        joc  !
0002 30F4 7347  18        sb   rone,ra
0003               !:
0004 30F6 022D  22        ai   ra,-(>17*256)
     30F8 E900     
                   < elite.a99
10115               
10116 30FA D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; Store the result in the overflow byte of XX15
     30FC 0035     
10117               
10118 30FE 170F  14        jnc  TT37                       ; BCC TT37          ; If subtracting 10 billion took us below zero, jump to
10119                                                                          ; TT37 to print out this digit, which is now in Y
10120               
10121 3100 020E  20        li   rx,>03*256                 ; LDX #3            ; We now want to copy XX15(4 0 1 2 3) back into
     3102 0300     
10122                                                                          ; K(S 0 1 2 3), so we can loop back up to do the next
10123                                                                          ; subtraction, so set up a counter for a four-byte loop
10124               
10125               tt38_:
10126 3104 D36E  34        movb @XX15(rx),ra               ; LDA XX15,X        ; Copy the X-th byte of XX15(0 1 2 3) to the X-th byte
     3106 0031     
10127 3108 DB8D  38        movb ra,@K(rx)                  ; STA K,X           ; of K(0 1 2 3), so that K(0 1 2 3) will contain a copy
     310A 003D     
10128                                                                          ; of XX15(0 1 2 3) once we've copied all four bytes
10129               
10130 310C 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10131               
10132 310E 15FA  14        jgt  tt38_                      ; BPL tt38          ; Loop back to copy the next byte, until we have copied
10133                                                                          ; all four
10134               
10135 3110 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Store the value of location XX15+4, our overflow
     3112 0035     
10136 3114 D80D  30        movb ra,@S                      ; STA S             ; byte in S, so now K(S 0 1 2 3) contains a copy of
     3116 0092     
10137                                                                          ; XX15(4 0 1 2 3)
10138               
10139 3118 B3C7  18        ab   rone,ry                    ; INY               ; We have now managed to subtract 10 billion from our
10140                                                                          ; number, so increment Y, which is where we are keeping
10141                                                                          ; a count of the number of subtractions so far
10142               
10143 311A 0460  28        b    @TT36                      ; JMP TT36          ; Jump back to TT36 to subtract the next 10 billion
     311C 30D4     
10144               
10145               TT37:
10146 311E D34F  18        movb ry,ra                      ; TYA               ; If we get here then Y contains the digit that we want
10147                                                                          ; to print (as Y has now counted the total number of
10148                                                                          ; subtractions of 10 billion), so transfer Y into A
10149               
10150 3120 1608  14        jne  TT32                       ; BNE TT32          ; If the digit is non-zero, jump to TT32 to print it
10151               
10152 3122 D360  30        movb @T,ra                      ; LDA T             ; Otherwise the digit is zero. If we are already
     3124 00D1     
10153                                                                          ; printing the number then we will want to print a 0,
10154                                                                          ; but if we haven't started printing the number yet,
10155                                                                          ; then we probably don't, as we don't want to print
10156                                                                          ; leading zeroes unless this is the only digit before
10157                                                                          ; the decimal point
10158                                                                          ;
10159                                                                          ; To help with this, we are going to use T as a flag
10160                                                                          ; that tells us whether we have already started
10161                                                                          ; printing digits:
10162                                                                          ;
10163                                                                          ; * If T <> 0 we haven't printed anything yet
10164                                                                          ;
10165                                                                          ; * If T = 0 then we have started printing digits
10166                                                                          ;
10167                                                                          ; We initially set T above to the maximum number of
10168                                                                          ; characters allowed, less 1 if we are printing a
10169                                                                          ; decimal point, so the first time we enter the digit
10170                                                                          ; printing routine at TT37, it is definitely non-zero
10171               
10172 3126 1305  14        jeq  TT32                       ; BEQ TT32          ; If T = 0, jump straight to the print routine at TT32,
10173                                                                          ; as we have already started printing the number, so we
10174                                                                          ; definitely want to print this digit too
10175               
10176 3128 7347  18        sb   rone,ra                    ; DEC U             ; We initially set U to the number of digits we want to
10177 312A 1510  14        jgt  TT34                       ; BPL TT34          ; skip before starting to print the number. If we get
10178                                                                          ; here then we haven't printed any digits yet, so
10179                                                                          ; decrement U to see if we have reached the point where
10180                                                                          ; we should start printing the number, and if not, jump
10181                                                                          ; to TT34 to set up things for the next digit
10182               
10183 312C 020D  20        li   ra,(' ')*256               ; LDA #' '          ; We haven't started printing any digits yet, but we
     312E 2000     
10184 3130 1609  14        jne  tt34_                      ; BNE tt34          ; have reached the point where we should start printing
10185                                                                          ; our number, so call TT26 (via tt34) to print a space
10186                                                                          ; so that the number is left-padded with spaces (this
10187                                                                          ; BNE is effectively a JMP as A will never be zero)
10188               
10189               TT32:
10190 3132 020F  20        li   ry,>00*256                 ; LDY #0            ; We are printing an actual digit, so first set T to 0,
     3134 0000     
10191 3136 D80F  30        movb ry,@T                      ; STY T             ; to denote that we have now started printing digits as
     3138 00D1     
10192                                                                          ; opposed to spaces
10193               
10194                      .clc                            ; CLC               ; The digit value is in A, so add ASCII "0" to get the
     **** ****     > CLC
0001 313A 0A16  18        sla  rzero,1
                   < elite.a99
10195                      .adi (('0')*256)                ; ADC #'0'          ; ASCII character number to print
     **** ****     > ADI
0001 313C 1701  14        jnc  !
0002 313E B347  18        ab   rone,ra
0003               !:
0004 3140 022D  22        ai   ra,(('0')*256)
     3142 3000     
                   < elite.a99
10196               
10197               tt34_:
10198 3144 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Call TT26 to print the character in A and fall through
     3146 3172     
10199 3148 06A0  32        bl   @jsr                       ;
     314A FE1E     
10200                                                                          ; into TT34 to get things ready for the next digit
10201               
10202               TT34:
10203 314C 7347  18        sb   rone,ra                    ; DEC T             ; Decrement T but keep T >= 0 (by incrementing it
10204 314E 1501  14        jgt  B24                        ; BPL B24           ; again if the above decrement made T negative)
10205 3150 B347  18        ab   rone,ra                    ; INC T
10206               
10207               B24:
10208 3152 7347  18        sb   rone,ra                    ; DEC XX17          ; Decrement the total number of characters left to
10209                                                                          ; print, which we stored in XX17
10210               
10211 3154 1166  14        jlt  RR3+1                      ; BMI RR3+1         ; If the result is negative, we have printed all the
10212                                                                          ; characters, so return from the subroutine (as RR3
10213                                                                          ; contains an ORA #&60 instruction, so RR3+1 is &60,
10214                                                                          ; which is the opcode for an RTS)
10215               
10216 3156 1609  14        jne  B25                        ; BNE B25           ; If the result is positive (> 0) then we still have
10217                                                                          ; characters left to print, so loop back to TT35 (via
10218                                                                          ; the JMP TT35 instruction below) to print the next
10219                                                                          ; digit
10220               
10221                      .plp                            ; PLP               ; If we get here then we have printed the exact number
     **** ****     > PLP
0001 3158 058A  14        INC  rsp
0002 315A D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
10222                                                                          ; of digits that we wanted to, so restore the C flag
10223                                                                          ; that we stored at the start of the routine
10224               
10225 315C 1706  14        jnc  B25                        ; BCC B25           ; If the C flag is clear, we don't want a decimal point,
10226                                                                          ; so loop back to TT35 (via the JMP TT35 instruction
10227                                                                          ; below) to print the next digit
10228               
10229 315E 020D  20        li   ra,('.')*256               ; LDA #'.'          ; Otherwise the C flag is set, so print the decimal
     3160 2E00     
10230 3162 0200  20        li   rtmp,TT26                  ; JSR TT26          ; point
     3164 3172     
10231 3166 06A0  32        bl   @jsr                       ;
     3168 FE1E     
10232               
10233               B25:
10234 316A 0460  28        b    @TT35                      ; JMP TT35          ; Loop back to TT35 to print the next digit
     316C 3004     
10235               
10236               * ******************************************************************************
10237               *
10238               * Name: BELL
10239               * Type: Subroutine
10240               * Category: Sound
10241               * Summary: Make a standard system beep
10242               *
10243               * ------------------------------------------------------------------------------
10244               *
10245               * This is the standard system beep, as made by the ASCII 7 "BELL" control code.
10246               *
10247               * ******************************************************************************
10248               
10249               BELL:
10250 316E 020D  20        li   ra,>07*256                 ; LDA #7            ; Control code 7 makes a beep, so load this into A
     3170 0700     
10251               
10252                                                                          ; Fall through into the TT26 print routine to
10253                                                                          ; actually make the sound
10254               
10255               * ******************************************************************************
10256               *
10257               * Name: TT26
10258               * Type: Subroutine
10259               * Category: Text
10260               * Summary: Print a character at the text cursor by poking into screen memory
10261               * Deep dive: Drawing text
10262               *
10263               * ------------------------------------------------------------------------------
10264               *
10265               * Print a character at the text cursor (XC, YC), do a beep, print a newline,
10266               * or delete left (backspace).
10267               *
10268               * WRCHV is set to point here by the loading process.
10269               *
10270               * ------------------------------------------------------------------------------
10271               *
10272               * Arguments:
10273               *
10274               * A                   The character to be printed. Can be one of the
10275               * following:
10276               *
10277               * * 7 (beep)
10278               *
10279               * * 10-13 (line feeds and carriage returns)
10280               *
10281               * * 32-95 (ASCII capital letters, numbers and
10282               * punctuation)
10283               *
10284               * * 127 (delete the character to the left of the text
10285               * cursor and move the cursor to the left)
10286               *
10287               * XC                  Contains the text column to print at (the x-coordinate)
10288               *
10289               * YC                  Contains the line number to print on (the y-coordinate)
10290               *
10291               * ------------------------------------------------------------------------------
10292               *
10293               * Returns:
10294               *
10295               * A                   A is preserved
10296               *
10297               * X                   X is preserved
10298               *
10299               * Y                   Y is preserved
10300               *
10301               * C flag              The C flag is cleared
10302               *
10303               * ------------------------------------------------------------------------------
10304               *
10305               * Other entry points:
10306               *
10307               * RR3+1               Contains an RTS
10308               *
10309               * RREN                Prints the character definition pointed to by P(2 1) at
10310               * the screen address pointed to by (A SC). Used by the
10311               * BULB routine
10312               *
10313               * rT9                 Contains an RTS
10314               *
10315               * ******************************************************************************
10316               
10317               TT26:
10318 3172 D80D  30        movb ra,@K3                     ; STA K3            ; Store the A, X and Y registers, so we can restore
     3174 00D2     
10319 3176 D80F  30        movb ry,@YSAV2                  ; STY YSAV2         ; them at the end (so they don't get changed by this
     3178 0F0F     
10320 317A D80E  30        movb rx,@XSAV2                  ; STX XSAV2         ; routine)
     317C 0F0E     
10321               
10322 317E D3E0  30        movb @QQ17,ry                   ; LDY QQ17          ; Load the QQ17 flag, which contains the text printing
     3180 007E     
10323                                                                          ; flags
10324               
10325 3182 028F  22        ci   ry,>ff*256                 ; CPY #255          ; If QQ17 = 255 then printing is disabled, so jump to
     3184 FF00     
10326 3186 1366  14        jeq  RR4                        ; BEQ RR4           ; RR4, which doesn't print anything, it just restores
10327                                                                          ; the registers and returns from the subroutine
10328               
10329 3188 028D  22        ci   ra,>07*256                 ; CMP #7            ; If this is a beep character (A = 7), jump to R5,
     318A 0700     
10330 318C 136C  14        jeq  R5_                        ; BEQ R5_           ; which will emit the beep, restore the registers and
10331                                                                          ; return from the subroutine
10332               
10333 318E 028D  22        ci   ra,>20*256                 ; CMP #32           ; If this is an ASCII character (A >= 32), jump to RR1
     3190 2000     
10334 3192 1809  14        joc  RR1                        ; BCS RR1           ; below, which will print the character, restore the
10335                                                                          ; registers and return from the subroutine
10336               
10337 3194 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If this is control code 10 (line feed) then jump to
     3196 0A00     
10338 3198 1304  14        jeq  RRX1                       ; BEQ RRX1          ; RRX1, which will move down a line, restore the
10339                                                                          ; registers and return from the subroutine
10340               
10341 319A 020E  20        li   rx,>01*256                 ; LDX #1            ; If we get here, then this is control code 11-13, of
     319C 0100     
10342 319E D80E  30        movb rx,@XC                     ; STX XC            ; which only 13 is used. This code prints a newline,
     31A0 002C     
10343                                                                          ; which we can achieve by moving the text cursor
10344                                                                          ; to the start of the line (carriage return) and down
10345                                                                          ; one line (line feed). These two lines do the first
10346                                                                          ; bit by setting XC = 1, and we then fall through into
10347                                                                          ; the line feed routine that's used by control code 10
10348               
10349               RRX1:
10350 31A2 B347  18        ab   rone,ra                    ; INC YC            ; Print a line feed, simply by incrementing the row
10351                                                                          ; number (y-coordinate) of the text cursor, which is
10352                                                                          ; stored in YC
10353               
10354 31A4 1657  14        jne  RR4                        ; BNE RR4           ; Jump to RR4 to restore the registers and return from
10355                                                                          ; the subroutine (this BNE is effectively a JMP as Y
10356                                                                          ; will never be zero)
10357               
10358               RR1:
10359                                                                          ; If we get here, then the character to print is an
10360                                                                          ; ASCII character in the range 32-95. The quickest way
10361                                                                          ; to display text on-screen is to poke the character
10362                                                                          ; pixel by pixel, directly into screen memory, so
10363                                                                          ; that's what the rest of this routine does
10364                                                                          ;
10365                                                                          ; The first step, then, is to get hold of the bitmap
10366                                                                          ; definition for the character we want to draw on the
10367                                                                          ; screen (i.e. we need the pixel shape of this
10368                                                                          ; character). The MOS ROM contains bitmap definitions
10369                                                                          ; of the system's ASCII characters, starting from &C000
10370                                                                          ; for space (ASCII 32) and ending with the  symbol
10371                                                                          ; (ASCII 126)
10372                                                                          ;
10373                                                                          ; There are definitions for 32 characters in each of the
10374                                                                          ; three pages of MOS memory, as each definition takes up
10375                                                                          ; 8 bytes (8 rows of 8 pixels) and 32 * 8 = 256 bytes =
10376                                                                          ; 1 page. So:
10377                                                                          ;
10378                                                                          ; ASCII 32-63  are defined in &C000-&C0FF (page 0)
10379                                                                          ; ASCII 64-95  are defined in &C100-&C1FF (page 1)
10380                                                                          ; ASCII 96-126 are defined in &C200-&C2F0 (page 2)
10381                                                                          ;
10382                                                                          ; The following code reads the relevant character
10383                                                                          ; bitmap from the above locations in ROM and pokes
10384                                                                          ; those values into the correct position in screen
10385                                                                          ; memory, thus printing the character on-screen
10386                                                                          ;
10387                                                                          ; It's a long way from 10 PRINT "Hello world!":GOTO 10
10388               * LDX #LO(K3)            \ These instructions are commented out in the original
10389               * INX                    \ source, but they call OSWORD 10, which reads the
10390               * STX P+1                \ character bitmap for the character number in K3 and
10391               * DEX                    \ stores it in the block at K3+1, while also setting
10392               * LDY #HI(K3)            \ P+1 to point to the character definition. This is
10393               * STY P+2                \ exactly what the following uncommented code does,
10394               * LDA #10                \ just without calling OSWORD. Presumably the code
10395               * JSR OSWORD             \ below is faster than using the system call, as this
10396                                                                          ; version takes up 15 bytes, while the version below
10397                                                                          ; (which ends with STA P+1 and SYX P+2) is 17 bytes.
10398                                                                          ; Every efficiency saving helps, especially as this
10399                                                                          ; routine is run each time the game prints a character
10400                                                                          ;
10401                                                                          ; If you want to switch this code back on, uncomment
10402                                                                          ; the above block, and comment out the code below from
10403                                                                          ; TAY to STX P+2. You will also need to uncomment the
10404                                                                          ; LDA YC instruction a few lines down (in RR2), just to
10405                                                                          ; make sure the rest of the code doesn't shift in
10406                                                                          ; memory. To be honest I can't see a massive difference
10407                                                                          ; in speed, but there you go
10408 31A6 D3CD  18        movb ra,ry                      ; TAY               ; Copy the character number from A to Y, as we are
10409                                                                          ; about to pull A apart to work out where this
10410                                                                          ; character definition lives in memory
10411               
10412                                                                          ; Now we want to set X to point to the relevant page
10413                                                                          ; number for this character - i.e. &C0, &C1 or &C2.
10414               
10415                                                                          ; The following logic is easier to follow if we look
10416                                                                          ; at the three character number ranges in binary:
10417                                                                          ;
10418                                                                          ; Bit #  76543210
10419                                                                          ;
10420                                                                          ; 32  = %00100000     Page 0 of bitmap definitions
10421                                                                          ; 63  = %00111111
10422                                                                          ;
10423                                                                          ; 64  = %01000000     Page 1 of bitmap definitions
10424                                                                          ; 95  = %01011111
10425                                                                          ;
10426                                                                          ; 96  = %01100000     Page 2 of bitmap definitions
10427                                                                          ; 125 = %01111101
10428                                                                          ;
10429                                                                          ; We'll refer to this below
10430               
10431 31A8 020E  20        li   rx,>bf*256                 ; LDX #&BF          ; Set X to point to the first font page in ROM minus 1,
     31AA BF00     
10432                                                                          ; which is &C0 - 1, or &BF
10433               
10434                      .asla                           ; ASL A             ; If bit 6 of the character is clear (A is 32-63)
     **** ****     > ASLA
0001 31AC 024D  22        andi ra,>ff00
     31AE FF00     
0002 31B0 0A1D  18        sla  ra,1
                   < elite.a99
10435                      .asla                           ; ASL A             ; then skip the following instruction
     **** ****     > ASLA
0001 31B2 024D  22        andi ra,>ff00
     31B4 FF00     
0002 31B6 0A1D  18        sla  ra,1
                   < elite.a99
10436 31B8 1702  14        jnc  B26                        ; BCC B26
10437               
10438 31BA 020E  20        li   rx,>c1*256                 ; LDX #&C1          ; A is 64-126, so set X to point to page &C1
     31BC C100     
10439               
10440               B26:
10441                      .asla                           ; ASL A             ; If bit 5 of the character is clear (A is 64-95)
     **** ****     > ASLA
0001 31BE 024D  22        andi ra,>ff00
     31C0 FF00     
0002 31C2 0A1D  18        sla  ra,1
                   < elite.a99
10442 31C4 1701  14        jnc  B27                        ; BCC B27           ; then skip the following instruction
10443               
10444 31C6 B387  18        ab   rone,rx                    ; INX               ; Increment X
10445                                                                          ;
10446                                                                          ; By this point, we started with X = &BF, and then
10447                                                                          ; we did the following:
10448                                                                          ;
10449                                                                          ; If A = 32-63:   skip    then INX  so X = &C0
10450                                                                          ; If A = 64-95:   X = &C1 then skip so X = &C1
10451                                                                          ; If A = 96-126:  X = &C1 then INX  so X = &C2
10452                                                                          ;
10453                                                                          ; In other words, X points to the relevant page. But
10454                                                                          ; what about the value of A? That gets shifted to the
10455                                                                          ; left three times during the above code, which
10456                                                                          ; multiplies the number by 8 but also drops bits 7, 6
10457                                                                          ; and 5 in the process. Look at the above binary
10458                                                                          ; figures and you can see that if we cleared bits 5-7,
10459                                                                          ; then that would change 32-53 to 0-31... but it would
10460                                                                          ; do exactly the same to 64-95 and 96-125. And because
10461                                                                          ; we also multiply this figure by 8, A now points to
10462                                                                          ; the start of the character's definition within its
10463                                                                          ; page (because there are 8 bytes per character
10464                                                                          ; definition)
10465                                                                          ;
10466                                                                          ; Or, to put it another way, X contains the high byte
10467                                                                          ; (the page) of the address of the definition that we
10468                                                                          ; want, while A contains the low byte (the offset into
10469                                                                          ; the page) of the address
10470               
10471               B27:
10472 31C8 D80D  30        movb ra,@P+1                    ; STA P+1           ; Store the address of this character's definition in
     31CA 001C     
10473 31CC D80E  30        movb rx,@P+2                    ; STX P+2           ; P(2 1)
     31CE 001D     
10474               
10475 31D0 D360  30        movb @XC,ra                     ; LDA XC            ; Fetch XC, the x-coordinate (column) of the text cursor
     31D2 002C     
10476                                                                          ; into A
10477               
10478                      .asla                           ; ASL A             ; Multiply A by 8, and store in SC. As each character is
     **** ****     > ASLA
0001 31D4 024D  22        andi ra,>ff00
     31D6 FF00     
0002 31D8 0A1D  18        sla  ra,1
                   < elite.a99
10479                      .asla                           ; ASL A             ; 8 pixels wide, and the special screen mode Elite uses
     **** ****     > ASLA
0001 31DA 024D  22        andi ra,>ff00
     31DC FF00     
0002 31DE 0A1D  18        sla  ra,1
                   < elite.a99
10480                      .asla                           ; ASL A             ; for the top part of the screen is 256 pixels across
     **** ****     > ASLA
0001 31E0 024D  22        andi ra,>ff00
     31E2 FF00     
0002 31E4 0A1D  18        sla  ra,1
                   < elite.a99
10481 31E6 D80D  30        movb ra,@SC                     ; STA SC            ; with one bit per pixel, this value is not only the
     31E8 0007     
10482                                                                          ; screen address offset of the text cursor from the left
10483                                                                          ; side of the screen, it's also the least significant
10484                                                                          ; byte of the screen address where we want to print this
10485                                                                          ; character, as each row of on-screen pixels corresponds
10486                                                                          ; to one page. To put this more explicitly, the screen
10487                                                                          ; starts at &6000, so the text rows are stored in screen
10488                                                                          ; memory like this:
10489                                                                          ;
10490                                                                          ; Row 1: &6000 - &60FF    YC = 1, XC = 0 to 31
10491                                                                          ; Row 2: &6100 - &61FF    YC = 2, XC = 0 to 31
10492                                                                          ; Row 3: &6200 - &62FF    YC = 3, XC = 0 to 31
10493                                                                          ;
10494                                                                          ; and so on
10495               
10496 31EA D360  30        movb @YC,ra                     ; LDA YC            ; Fetch YC, the y-coordinate (row) of the text cursor
     31EC 002D     
10497               
10498 31EE 028F  22        ci   ry,>7f*256                 ; CPY #127          ; If the character number (which is in Y) <> 127, then
     31F0 7F00     
10499 31F2 160D  14        jne  RR2                        ; BNE RR2           ; skip to RR2 to print that character, otherwise this is
10500                                                                          ; the delete character, so continue on
10501               
10502 31F4 7347  18        sb   rone,ra                    ; DEC XC            ; We want to delete the character to the left of the
10503                                                                          ; text cursor and move the cursor back one, so let's
10504                                                                          ; do that by decrementing YC. Note that this doesn't
10505                                                                          ; have anything to do with the actual deletion below,
10506                                                                          ; we're just updating the cursor so it's in the right
10507                                                                          ; position following the deletion
10508               
10509                      .adi (>5e*256)                  ; ADC #&5E          ; A contains YC (from above) and the C flag is set (from
     **** ****     > ADI
0001 31F6 1701  14        jnc  !
0002 31F8 B347  18        ab   rone,ra
0003               !:
0004 31FA 022D  22        ai   ra,(>5E*256)
     31FC 5E00     
                   < elite.a99
10510 31FE D38D  18        movb ra,rx                      ; TAX               ; the CPY #127 above), so these instructions do this:
10511                                                                          ;
10512                                                                          ; X = YC + &5E + 1
10513                                                                          ; = YC + &5F
10514               
10515                                                                          ; Because YC starts at 0 for the first text row, this
10516                                                                          ; means that X will be &5F for row 0, &60 for row 1 and
10517                                                                          ; so on. In other words, X is now set to the page number
10518                                                                          ; for the row before the one containing the text cursor,
10519                                                                          ; and given that we set SC above to point to the offset
10520                                                                          ; in memory of the text cursor within the row's page,
10521                                                                          ; this means that (X SC) now points to the character
10522                                                                          ; above the text cursor
10523               
10524 3200 020F  20        li   ry,>f8*256                 ; LDY #&F8          ; Set Y = &F8, so the following call to ZES2 will count
     3202 F800     
10525                                                                          ; Y upwards from &F8 to &FF
10526               
10527 3204 0200  20        li   rtmp,ZES2                  ; JSR ZES2          ; Call ZES2, which zero-fills from address (X SC) + Y to
     3206 C826     
10528 3208 06A0  32        bl   @jsr                       ;
     320A FE1E     
10529                                                                          ; (X SC) + &FF. (X SC) points to the character above the
10530                                                                          ; text cursor, and adding &FF to this would point to the
10531                                                                          ; cursor, so adding &F8 points to the character before
10532                                                                          ; the cursor, which is the one we want to delete. So
10533                                                                          ; this call zero-fills the character to the left of the
10534                                                                          ; cursor, which erases it from the screen
10535               
10536 320C 1323  14        jeq  RR4                        ; BEQ RR4           ; We are done deleting, so restore the registers and
10537                                                                          ; return from the subroutine (this BNE is effectively
10538                                                                          ; a JMP as ZES2 always returns with the Z flag set)
10539               
10540               RR2:
10541                                                                          ; Now to actually print the character
10542 320E B347  18        ab   rone,ra                    ; INC XC            ; Once we print the character, we want to move the text
10543                                                                          ; cursor to the right, so we do this by incrementing
10544                                                                          ; XC. Note that this doesn't have anything to do
10545                                                                          ; with the actual printing below, we're just updating
10546                                                                          ; the cursor so it's in the right position following
10547                                                                          ; the print
10548               
10549               * LDA YC                 \ This instruction is commented out in the original
10550                                                                          ; source. It isn't required because we only just did a
10551                                                                          ; LDA YC before jumping to RR2, so this is presumably
10552                                                                          ; an example of the authors squeezing the code to save
10553                                                                          ; 2 bytes and 3 cycles
10554                                                                          ;
10555                                                                          ; If you want to re-enable the commented block near the
10556                                                                          ; start of this routine, you should uncomment this
10557                                                                          ; instruction as well
10558               
10559 3210 028D  22        ci   ra,>18*256                 ; CMP #24           ; If the text cursor is on the screen (i.e. YC < 24, so
     3212 1800     
10560 3214 1706  14        jnc  RR3                        ; BCC RR3           ; we are on rows 0-23), then jump to RR3 to print the
10561                                                                          ; character
10562               
10563 3216 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise we are off the bottom of the screen, so
     3218 4B2E     
10564 321A 06A0  32        bl   @jsr                       ;
     321C FE1E     
10565                                                                          ; clear the screen and draw a white border
10566               
10567 321E 0460  28        b    @RR4                       ; JMP RR4           ; And restore the registers and return from the
     3220 3254     
10568                                                                          ; subroutine
10569               
10570               RR3:
10571                                                                          ; A contains the value of YC - the screen row where we
10572                                                                          ; want to print this character - so now we need to
10573                                                                          ; convert this into a screen address, so we can poke
10574                                                                          ; the character data to the right place in screen
10575                                                                          ; memory
10576 3222 026D  22        ori  ra,>60*256                 ; ORA #&60          ; We already stored the least significant byte
     3224 6000     
10577                                                                          ; of this screen address in SC above (see the STA SC
10578                                                                          ; instruction above), so all we need is the most
10579                                                                          ; significant byte. As mentioned above, in Elite's
10580                                                                          ; square mode 4 screen, each row of text on-screen
10581                                                                          ; takes up exactly one page, so the first row is page
10582                                                                          ; &60xx, the second row is page &61xx, so we can get
10583                                                                          ; the page for character (XC, YC) by OR'ing with &60.
10584                                                                          ; To see this in action, consider that our two values
10585                                                                          ; are, in binary:
10586                                                                          ;
10587                                                                          ; YC is between:  %00000000
10588                                                                          ; and:  %00010111
10589                                                                          ; &60 is:  %01100000
10590                                                                          ;
10591                                                                          ; so YC OR &60 effectively adds &60 to YC, giving us
10592                                                                          ; the page number that we want
10593               
10594               RREN:
10595 3226 D80D  30        movb ra,@SC+1                   ; STA SC+1          ; Store the page number of the destination screen
     3228 0008     
10596                                                                          ; location in SC+1, so SC now points to the full screen
10597                                                                          ; location where this character should go
10598               
10599 322A 020F  20        li   ry,>07*256                 ; LDY #7            ; We want to print the 8 bytes of character data to the
     322C 0700     
10600                                                                          ; screen (one byte per row), so set up a counter in Y
10601                                                                          ; to count these bytes
10602               
10603               RRL1:
10604                      .ld_ind_y_idx @P+1,ra           ; LDA (P+1),Y       ; The character definition is at P(2 1) - we set this up
     **** ****     > LD_IND_Y_IDX
0001 322E D820  50        movb @P+1,@rtmplb
     3230 001C     
     3232 206D     
0002 3234 D020  30        movb @P+1+1,rtmp
     3236 001D     
0003 3238 A00F  18        a    ry,rtmp
0004 323A D350  26        movb *rtmp,RA
                   < elite.a99
10605                                                                          ; above - so load the Y-th byte from P(2 1), which will
10606                                                                          ; contain the bitmap for the Y-th row of the character
10607               
10608                      .eor @SC                        ; EOR (SC),Y        ; If we EOR this value with the existing screen
     **** ****     > EOR
0001 323C D020  30        movb @SC,rtmp
     323E 0007     
0002 3240 2B40  18        xor  rtmp,ra
                   < elite.a99
10609                                                                          ; contents, then it's reversible (so reprinting the
10610                                                                          ; same character in the same place will revert the
10611                                                                          ; screen to what it looked like before we printed
10612                                                                          ; anything); this means that printing a white pixel
10613                                                                          ; onto a white background results in a black pixel, but
10614                                                                          ; that's a small price to pay for easily erasable text
10615               
10616                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store the Y-th byte at the screen address for this
     **** ****     > ST_IND_Y_IDX
0001 3242 D820  50        movb @SC,@rtmplb
     3244 0007     
     3246 206D     
0002 3248 D020  30        movb @SC+1,rtmp
     324A 0008     
0003 324C A00F  18        a    ry,rtmp
0004 324E D40D  30        movb RA,*rtmp
                   < elite.a99
10617                                                                          ; character location
10618               
10619 3250 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
10620               
10621 3252 15ED  14        jgt  RRL1                       ; BPL RRL1          ; Loop back for the next byte to print to the screen
10622               
10623               RR4:
10624 3254 D3E0  30        movb @YSAV2,ry                  ; LDY YSAV2         ; We're done printing, so restore the values of the
     3256 0F0F     
10625 3258 D3A0  30        movb @XSAV2,rx                  ; LDX XSAV2         ; A, X and Y registers that we saved above and clear
     325A 0F0E     
10626 325C D360  30        movb @K3,ra                     ; LDA K3            ; the C flag, so everything is back to how it was
     325E 00D2     
10627                      .clc                            ; CLC
     **** ****     > CLC
0001 3260 0A16  18        sla  rzero,1
                   < elite.a99
10628               
10629               rT9:
10630 3262 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3264 FE2A     
10631               
10632               R5_:
10633 3266 0200  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     3268 CBAC     
10634 326A 06A0  32        bl   @jsr                       ;
     326C FE1E     
10635               
10636 326E 0460  28        b    @RR4                       ; JMP RR4           ; Jump to RR4 to restore the registers and return from
     3270 3254     
10637                                                                          ; the subroutine using a tail call
10638               
10639               * ******************************************************************************
10640               *
10641               * Name: DIALS (Part 1 of 4)
10642               * Type: Subroutine
10643               * Category: Dashboard
10644               * Summary: Update the dashboard: speed indicator
10645               * Deep dive: The dashboard indicators
10646               *
10647               * ------------------------------------------------------------------------------
10648               *
10649               * This routine updates the dashboard. First we draw all the indicators in the
10650               * right part of the dashboard, from top (speed) to bottom (energy banks), and
10651               * then we move on to the left part, again drawing from top (forward shield) to
10652               * bottom (altitude).
10653               *
10654               * This first section starts us off with the speedometer in the top right.
10655               *
10656               * ******************************************************************************
10657               
10658               DIALS:
10659 3272 020D  20        li   ra,>d0*256                 ; LDA #&D0          ; Set SC(1 0) = &78D0, which is the screen address for
     3274 D000     
10660 3276 D80D  30        movb ra,@SC                     ; STA SC            ; the character block containing the left end of the
     3278 0007     
10661 327A 020D  20        li   ra,>78*256                 ; LDA #&78          ; top indicator in the right part of the dashboard, the
     327C 7800     
10662 327E D80D  30        movb ra,@SC+1                   ; STA SC+1          ; one showing our speed
     3280 0008     
10663               
10664 3282 0200  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     3284 3402     
10665 3286 06A0  32        bl   @jsr                       ;
     3288 FE1E     
10666                                                                          ; and X to the colour for safe values
10667               
10668 328A D80E  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     328C 003E     
10669                                                                          ; X (the colour to use for safe values)
10670               
10671 328E D80D  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     3290 003D     
10672                                                                          ; A (the colour to use for dangerous values)
10673               
10674                                                                          ; The above sets the following indicators to show red
10675                                                                          ; for high values and yellow/white for low values
10676               
10677 3292 020D  20        li   ra,>0e*256                 ; LDA #14           ; Set T1 to 14, the threshold at which we change the
     3294 0E00     
10678 3296 D80D  30        movb ra,@T1                     ; STA T1            ; indicator's colour
     3298 0006     
10679               
10680 329A D360  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch our ship's speed into A, in the range 0-40
     329C 008C     
10681               
10682               * LSR A                  \ Draw the speed indicator using a range of 0-31, and
10683 329E 0200  20        li   rtmp,DIL-1                 ; JSR DIL-1         ; increment SC to point to the next indicator (the roll
     32A0 342B     
10684 32A2 06A0  32        bl   @jsr                       ;
     32A4 FE1E     
10685                                                                          ; indicator). The LSR is commented out as it isn't
10686                                                                          ; required with a call to DIL-1, so perhaps this was
10687                                                                          ; originally a call to DIL that got optimised
10688               
10689               * ******************************************************************************
10690               *
10691               * Name: DIALS (Part 2 of 4)
10692               * Type: Subroutine
10693               * Category: Dashboard
10694               * Summary: Update the dashboard: pitch and roll indicators
10695               * Deep dive: The dashboard indicators
10696               *
10697               * ******************************************************************************
10698               
10699 32A6 020D  20        li   ra,>00*256                 ; LDA #0            ; Set R = P = 0 for the low bytes in the call to the ADD
     32A8 0000     
10700 32AA D80D  30        movb ra,@R                      ; STA R             ; routine below
     32AC 0091     
10701 32AE D80D  30        movb ra,@P                      ; STA P
     32B0 001B     
10702               
10703 32B2 020D  20        li   ra,>08*256                 ; LDA #8            ; Set S = 8, which is the value of the centre of the
     32B4 0800     
10704 32B6 D80D  30        movb ra,@S                      ; STA S             ; roll indicator
     32B8 0092     
10705               
10706 32BA D360  30        movb @ALP1,ra                   ; LDA ALP1          ; Fetch the roll angle alpha as a value between 0 and
     32BC 0087     
10707 32BE 091D  18        srl  ra,1                       ; LSR A             ; 31, and divide by 4 to get a value of 0 to 7
10708 32C0 091D  18        srl  ra,1                       ; LSR A
10709               
10710 32C2 F360  30        socb @ALP2,ra                   ; ORA ALP2          ; Apply the roll sign to the value, and flip the sign,
     32C4 0088     
10711                      .eoi (>80*256)                  ; EOR #%10000000    ; so it's now in the range -7 to +7, with a positive
     **** ****     > EOI
0001 32C6 0200  20        li   rtmp,(>80*256)
     32C8 8000     
0002 32CA 2B40  18        xor  rtmp,ra
                   < elite.a99
10712                                                                          ; roll angle alpha giving a negative value in A
10713               
10714 32CC 0200  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     32CE 44BA     
10715 32D0 06A0  32        bl   @jsr                       ;
     32D2 FE1E     
10716                                                                          ; 15, which we can pass to DIL2 to draw the vertical
10717                                                                          ; bar on the indicator at this position. We use the ADD
10718                                                                          ; routine like this:
10719                                                                          ;
10720                                                                          ; (A X) = (A 0) + (S 0)
10721                                                                          ;
10722                                                                          ; and just take the high byte of the result. We use ADD
10723                                                                          ; rather than a normal ADC because ADD separates out the
10724                                                                          ; sign bit and does the arithmetic using absolute values
10725                                                                          ; and separate sign bits, which we want here rather than
10726                                                                          ; the two's complement that ADC uses
10727               
10728 32D4 0200  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the roll indicator at offset A
     32D6 34F6     
10729 32D8 06A0  32        bl   @jsr                       ;
     32DA FE1E     
10730                                                                          ; and increment SC to point to the next indicator (the
10731                                                                          ; pitch indicator)
10732               
10733 32DC D360  30        movb @BETA,ra                   ; LDA BETA          ; Fetch the pitch angle beta as a value between -8 and
     32DE 002A     
10734                                                                          ; +8
10735               
10736 32E0 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the pitch angle beta, and if it
     32E2 002B     
10737 32E4 1304  14        jeq  B28                        ; BEQ B28           ; is 0 (i.e. we are not pitching), skip the next
10738                                                                          ; instruction
10739               
10740                      .sbi (>01*256)                  ; SBC #1            ; The pitch angle beta is non-zero, so set A = A - 1
     **** ****     > SBI
0001 32E6 1801  14        joc  !
0002 32E8 7347  18        sb   rone,ra
0003               !:
0004 32EA 022D  22        ai   ra,-(>01*256)
     32EC FF00     
                   < elite.a99
10741                                                                          ; (the C flag is set by the call to DIL2 above, so we
10742                                                                          ; don't need to do a SEC). This gives us a value of A
10743                                                                          ; from -7 to +7 because these are magnitude-based
10744                                                                          ; numbers with sign bits, rather than two's complement
10745                                                                          ; numbers
10746               
10747               B28:
10748 32EE 0200  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     32F0 44BA     
10749 32F2 06A0  32        bl   @jsr                       ;
     32F4 FE1E     
10750                                                                          ; 15, which we can pass to DIL2 to draw the vertical
10751                                                                          ; bar on the indicator at this position (see the JSR ADD
10752                                                                          ; above for more on this)
10753               
10754 32F6 0200  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the pitch indicator at offset A
     32F8 34F6     
10755 32FA 06A0  32        bl   @jsr                       ;
     32FC FE1E     
10756                                                                          ; and increment SC to point to the next indicator (the
10757                                                                          ; four energy banks)
10758               
10759               * ******************************************************************************
10760               *
10761               * Name: DIALS (Part 3 of 4)
10762               * Type: Subroutine
10763               * Category: Dashboard
10764               * Summary: Update the dashboard: four energy banks
10765               * Deep dive: The dashboard indicators
10766               *
10767               * ------------------------------------------------------------------------------
10768               *
10769               * This and the next section only run once every four iterations of the main
10770               * loop, so while the speed, pitch and roll indicators update every iteration,
10771               * the other indicators update less often.
10772               *
10773               * ******************************************************************************
10774               
10775 32FE D360  30        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 4,
     3300 0099     
10776 3302 024D  22        andi ra,>03*256                 ; AND #3            ; jumping to rT9 if it is non-zero. rT9 contains an RTS,
     3304 0300     
10777 3306 16AD  14        jne  rT9                        ; BNE rT9           ; so the following code only runs every 4 iterations of
10778                                                                          ; the main loop, otherwise we return from the subroutine
10779               
10780 3308 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, for use in various places below
     330A 0000     
10781               
10782 330C 0200  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     330E 3402     
10783 3310 06A0  32        bl   @jsr                       ;
     3312 FE1E     
10784                                                                          ; and X to the colour for safe values
10785               
10786 3314 D80E  30        movb rx,@K                      ; STX K             ; Set K (the colour we should show for high values) to X
     3316 003D     
10787                                                                          ; (the colour to use for safe values)
10788               
10789 3318 D80D  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     331A 003E     
10790                                                                          ; A (the colour to use for dangerous values)
10791               
10792                                                                          ; The above sets the following indicators to show red
10793                                                                          ; for low values and yellow/white for high values, which
10794                                                                          ; we use not only for the energy banks, but also for the
10795                                                                          ; shield levels and current fuel
10796               
10797 331C 020E  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X so we can zero the four bytes at
     331E 0300     
10798                                                                          ; XX12, so we can then calculate each of the four energy
10799                                                                          ; banks' values before drawing them later
10800               
10801 3320 D80E  30        movb rx,@T1                     ; STX T1            ; Set T1 to 3, the threshold at which we change the
     3322 0006     
10802                                                                          ; indicator's colour
10803               
10804               DLL23:
10805 3324 DB8F  38        movb ry,@XX12(rx)               ; STY XX12,X        ; Set the X-th byte of XX12 to 0
     3326 0037     
10806               
10807 3328 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
10808               
10809 332A 15FC  14        jgt  DLL23                      ; BPL DLL23         ; Loop back for the next byte until the four bytes at
10810                                                                          ; XX12 are all zeroed
10811               
10812 332C 020E  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X to loop through the 4 energy
     332E 0300     
10813                                                                          ; bank indicators, so we can calculate each of the four
10814                                                                          ; energy banks' values and store them in XX12
10815               
10816 3330 D360  30        movb @ENERGY,ra                 ; LDA ENERGY        ; Set A = Q = ENERGY / 4, so they are both now in the
     3332 0F13     
10817 3334 091D  18        srl  ra,1                       ; LSR A             ; range 0-63 (so that's a maximum of 16 in each of the
10818 3336 091D  18        srl  ra,1                       ; LSR A             ; banks, and a maximum of 15 in the top bank)
10819               
10820 3338 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q to A, so we can use Q to hold the remaining
     333A 0090     
10821                                                                          ; energy as we work our way through each bank, from the
10822                                                                          ; full ones at the bottom to the empty ones at the top
10823               
10824               DLL24:
10825                      .sec                            ; SEC               ; Set A = A - 16 to reduce the energy count by a full
     **** ****     > SEC
0001 333C 0A18  18        sla  rmone,1
                   < elite.a99
10826                      .sbi (>10*256)                  ; SBC #16           ; bank
     **** ****     > SBI
0001 333E 1801  14        joc  !
0002 3340 7347  18        sb   rone,ra
0003               !:
0004 3342 022D  22        ai   ra,-(>10*256)
     3344 F000     
                   < elite.a99
10827               
10828 3346 170B  14        jnc  DLL26                      ; BCC DLL26         ; If the C flag is clear then A < 16, so this bank is
10829                                                                          ; not full to the brim, and is therefore the last one
10830                                                                          ; with any energy in it, so jump to DLL26
10831               
10832 3348 D80D  30        movb ra,@Q                      ; STA Q             ; This bank is full, so update Q with the energy of the
     334A 0090     
10833                                                                          ; remaining banks
10834               
10835 334C 020D  20        li   ra,>10*256                 ; LDA #16           ; Store this bank's level in XX12 as 16, as it is full,
     334E 1000     
10836 3350 DB8D  38        movb ra,@XX12(rx)               ; STA XX12,X        ; with XX12+3 for the bottom bank and XX12+0 for the top
     3352 0037     
10837               
10838 3354 D360  30        movb @Q,ra                      ; LDA Q             ; Set A to the remaining energy level again
     3356 0090     
10839               
10840 3358 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to point to the next bank, i.e. the one
10841                                                                          ; above the bank we just processed
10842               
10843 335A 15F0  14        jgt  DLL24                      ; BPL DLL24         ; Loop back to DLL24 until we have either processed all
10844                                                                          ; four banks, or jumped out early to DLL26 if the top
10845                                                                          ; banks have no charge
10846               
10847 335C 1104  14        jlt  DLL9                       ; BMI DLL9          ; Jump to DLL9 as we have processed all four banks (this
10848                                                                          ; BMI is effectively a JMP as A will never be positive)
10849               
10850               DLL26:
10851 335E D360  30        movb @Q,ra                      ; LDA Q             ; If we get here then the bank we just checked is not
     3360 0090     
10852 3362 DB8D  38        movb ra,@XX12(rx)               ; STA XX12,X        ; fully charged, so store its value in XX12 (using Q,
     3364 0037     
10853                                                                          ; which contains the energy of the remaining banks -
10854                                                                          ; i.e. this one)
10855               
10856                                                                          ; Now that we have the four energy bank values in XX12,
10857                                                                          ; we can draw them, starting with the top bank in XX12
10858                                                                          ; and looping down to the bottom bank in XX12+3, using Y
10859                                                                          ; as a loop counter, which was set to 0 above
10860               
10861               DLL9:
10862 3366 D36F  34        movb @XX12(ry),ra               ; LDA XX12,Y        ; Fetch the value of the Y-th indicator, starting from
     3368 0037     
10863                                                                          ; the top
10864               
10865 336A D80F  30        movb ry,@P                      ; STY P             ; Store the indicator number in P for retrieval later
     336C 001B     
10866               
10867 336E 0200  20        li   rtmp,DIL                   ; JSR DIL           ; Draw the energy bank using a range of 0-15, and
     3370 342C     
10868 3372 06A0  32        bl   @jsr                       ;
     3374 FE1E     
10869                                                                          ; increment SC to point to the next indicator (the
10870                                                                          ; next energy bank down)
10871               
10872 3376 D3E0  30        movb @P,ry                      ; LDY P             ; Restore the indicator number into Y
     3378 001B     
10873               
10874 337A B3C7  18        ab   rone,ry                    ; INY               ; Increment the indicator number
10875               
10876 337C 028F  22        ci   ry,>04*256                 ; CPY #4            ; Check to see if we have drawn the last energy bank
     337E 0400     
10877               
10878 3380 16F2  14        jne  DLL9                       ; BNE DLL9          ; Loop back to DLL9 if we have more banks to draw,
10879                                                                          ; otherwise we are done
10880               
10881               * ******************************************************************************
10882               *
10883               * Name: DIALS (Part 4 of 4)
10884               * Type: Subroutine
10885               * Category: Dashboard
10886               * Summary: Update the dashboard: shields, fuel, laser & cabin temp, altitude
10887               * Deep dive: The dashboard indicators
10888               *
10889               * ******************************************************************************
10890               
10891 3382 020D  20        li   ra,>78*256                 ; LDA #&78          ; Set SC(1 0) = &7810, which is the screen address for
     3384 7800     
10892 3386 D80D  30        movb ra,@SC+1                   ; STA SC+1          ; the character block containing the left end of the
     3388 0008     
10893 338A 020D  20        li   ra,>10*256                 ; LDA #&10          ; top indicator in the left part of the dashboard, the
     338C 1000     
10894 338E D80D  30        movb ra,@SC                     ; STA SC            ; one showing the forward shield
     3390 0007     
10895               
10896 3392 D360  30        movb @FSH,ra                    ; LDA FSH           ; Draw the forward shield indicator using a range of
     3394 0F11     
10897 3396 0200  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     3398 3424     
10898 339A 06A0  32        bl   @jsr                       ;
     339C FE1E     
10899                                                                          ; (the aft shield)
10900               
10901 339E D360  30        movb @ASH,ra                    ; LDA ASH           ; Draw the aft shield indicator using a range of 0-255,
     33A0 0F12     
10902 33A2 0200  20        li   rtmp,DILX                  ; JSR DILX          ; and increment SC to point to the next indicator (the
     33A4 3424     
10903 33A6 06A0  32        bl   @jsr                       ;
     33A8 FE1E     
10904                                                                          ; fuel level)
10905               
10906 33AA D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Draw the fuel level indicator using a range of 0-63,
     33AC 030D     
10907 33AE 0200  20        li   rtmp,DILX+2                ; JSR DILX+2        ; and increment SC to point to the next indicator (the
     33B0 3426     
10908 33B2 06A0  32        bl   @jsr                       ;
     33B4 FE1E     
10909                                                                          ; cabin temperature)
10910               
10911 33B6 0200  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     33B8 3402     
10912 33BA 06A0  32        bl   @jsr                       ;
     33BC FE1E     
10913                                                                          ; and X to the colour for safe values
10914               
10915 33BE D80E  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     33C0 003E     
10916                                                                          ; X (the colour to use for safe values)
10917               
10918 33C2 D80D  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     33C4 003D     
10919                                                                          ; A (the colour to use for dangerous values)
10920               
10921                                                                          ; The above sets the following indicators to show red
10922                                                                          ; for high values and yellow/white for low values, which
10923                                                                          ; we use for the cabin and laser temperature bars
10924               
10925 33C6 020E  20        li   rx,>0b*256                 ; LDX #11           ; Set T1 to 11, the threshold at which we change the
     33C8 0B00     
10926 33CA D80E  30        movb rx,@T1                     ; STX T1            ; cabin and laser temperature indicators' colours
     33CC 0006     
10927               
10928 33CE D360  30        movb @CABTMP,ra                 ; LDA CABTMP        ; Draw the cabin temperature indicator using a range of
     33D0 0D4D     
10929 33D2 0200  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     33D4 3424     
10930 33D6 06A0  32        bl   @jsr                       ;
     33D8 FE1E     
10931                                                                          ; (the laser temperature)
10932               
10933 33DA D360  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Draw the laser temperature indicator using a range of
     33DC 0D61     
10934 33DE 0200  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     33E0 3424     
10935 33E2 06A0  32        bl   @jsr                       ;
     33E4 FE1E     
10936                                                                          ; (the altitude)
10937               
10938 33E6 020D  20        li   ra,>f0*256                 ; LDA #240          ; Set T1 to 240, the threshold at which we change the
     33E8 F000     
10939 33EA D80D  30        movb ra,@T1                     ; STA T1            ; altitude indicator's colour. As the altitude has a
     33EC 0006     
10940                                                                          ; range of 0-255, pixel 16 will not be filled in, and
10941                                                                          ; 240 would change the colour when moving between pixels
10942                                                                          ; 15 and 16, so this effectively switches off the colour
10943                                                                          ; change for the altitude indicator
10944               
10945 33EE D80D  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     33F0 003E     
10946                                                                          ; 240, or &F0 (dashboard colour 2, yellow/white), so the
10947                                                                          ; altitude indicator always shows in this colour
10948               
10949 33F2 D360  30        movb @ALTIT,ra                  ; LDA ALTIT         ; Draw the altitude indicator using a range of 0-255
     33F4 0F21     
10950 33F6 0200  20        li   rtmp,DILX                  ; JSR DILX
     33F8 3424     
10951 33FA 06A0  32        bl   @jsr                       ;
     33FC FE1E     
10952               
10953 33FE 0460  28        b    @COMPAS                    ; JMP COMPAS        ; We have now drawn all the indicators, so jump to
     3400 ACF6     
10954                                                                          ; COMPAS to draw the compass, returning from the
10955                                                                          ; subroutine using a tail call
10956               
10957               * ******************************************************************************
10958               *
10959               * Name: PZW
10960               * Type: Subroutine
10961               * Category: Dashboard
10962               * Summary: Fetch the current dashboard colours, to support flashing
10963               *
10964               * ------------------------------------------------------------------------------
10965               *
10966               * Set A and X to the colours we should use for indicators showing dangerous and
10967               * safe values respectively. This enables us to implement flashing indicators,
10968               * which is one of the game's configurable options.
10969               *
10970               * If flashing is enabled, the colour returned in A (dangerous values) will be
10971               * red for 8 iterations of the main loop, and yellow/white for the next 8, before
10972               * going back to red. If we always use PZW to decide which colours we should use
10973               * when updating indicators, flashing colours will be automatically taken care of
10974               * for us.
10975               *
10976               * The values returned are &F0 for yellow/white and &0F for red. These are mode 5
10977               * bytes that contain 4 pixels, with the colour of each pixel given in two bits,
10978               * the high bit from the first nibble (bits 4-7) and the low bit from the second
10979               * nibble (bits 0-3). So in &F0 each pixel is %10, or colour 2 (yellow or white,
10980               * depending on the dashboard palette), while in &0F each pixel is %01, or colour
10981               * 1 (red).
10982               *
10983               * ------------------------------------------------------------------------------
10984               *
10985               * Returns:
10986               *
10987               * A                   The colour to use for indicators with dangerous values
10988               *
10989               * X                   The colour to use for indicators with safe values
10990               *
10991               * ******************************************************************************
10992               
10993               PZW:
10994 3402 020E  20        li   rx,>f0*256                 ; LDX #&F0          ; Set X to dashboard colour 2 (yellow/white)
     3404 F000     
10995               
10996 3406 D360  30        movb @MCNT,ra                   ; LDA MCNT          ; A will be non-zero for 8 out of every 16 main loop
     3408 0099     
10997 340A 024D  22        andi ra,>08*256                 ; AND #%00001000    ; counts, when bit 4 is set, so this is what we use to
     340C 0800     
10998                                                                          ; flash the "danger" colour
10999               
11000                      .and @FLH                       ; AND FLH           ; A will be zeroed if flashing colours are disabled
     **** ****     > AND
0001 340E D020  30        movb @FLH,rtmp
     3410 0F4D     
0002 3412 0540  14        inv  rtmp
0003 3414 5340  18        szcb rtmp,ra
                   < elite.a99
11001               
11002 3416 1302  14        jeq  B29                        ; BEQ B29           ; If A is zero, skip to the LDA instruction below
11003               
11004 3418 D34E  18        movb rx,ra                      ; TXA               ; Otherwise flashing colours are enabled and it's the
11005                                                                          ; main loop iteration where we flash them, so set A to
11006                                                                          ; colour 2 (yellow/white) and use the BIT trick below to
11007                                                                          ; return from the subroutine
11008               
11009 341A 2C              byte >2c                                            ; Skip the next instruction by turning it into
11010                                                                          ; &2C &A9 &0F, or BIT &0FA9, which does nothing apart
11011                                                                          ; from affect the flags
11012               
11013               B29:
11014 341C 020D  20        li   ra,>0f*256                 ; LDA #&0F          ; Set A to dashboard colour 1 (red)
     341E 0F00     
11015               
11016 3420 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3422 FE2A     
11017               
11018               * ******************************************************************************
11019               *
11020               * Name: DILX
11021               * Type: Subroutine
11022               * Category: Dashboard
11023               * Summary: Update a bar-based indicator on the dashboard
11024               * Deep dive: The dashboard indicators
11025               *
11026               * ------------------------------------------------------------------------------
11027               *
11028               * The range of values shown on the indicator depends on which entry point is
11029               * called. For the default entry point of DILX, the range is 0-255 (as the value
11030               * passed in A is one byte). The other entry points are shown below.
11031               *
11032               * ------------------------------------------------------------------------------
11033               *
11034               * Arguments:
11035               *
11036               * A                   The value to be shown on the indicator (so the larger
11037               * the value, the longer the bar)
11038               *
11039               * T1                  The threshold at which we change the indicator's colour
11040               * from the low value colour to the high value colour. The
11041               * threshold is in pixels, so it should have a value from
11042               * 0-16, as each bar indicator is 16 pixels wide
11043               *
11044               * K                   The colour to use when A is a high value, as a 4-pixel
11045               * mode 5 character row byte
11046               *
11047               * K+1                 The colour to use when A is a low value, as a 4-pixel
11048               * mode 5 character row byte
11049               *
11050               * SC(1 0)             The screen address of the first character block in the
11051               * indicator
11052               *
11053               * ------------------------------------------------------------------------------
11054               *
11055               * Other entry points:
11056               *
11057               * DILX+2              The range of the indicator is 0-64 (for the fuel
11058               * indicator)
11059               *
11060               * DIL-1               The range of the indicator is 0-32 (for the speed
11061               * indicator)
11062               *
11063               * DIL                 The range of the indicator is 0-16 (for the energy
11064               * banks)
11065               *
11066               * ******************************************************************************
11067               
11068               DILX:
11069 3424 091D  18        srl  ra,1                       ; LSR A             ; If we call DILX, we set A = A / 16, so A is 0-15
11070 3426 091D  18        srl  ra,1                       ; LSR A
11071               
11072 3428 091D  18        srl  ra,1                       ; LSR A             ; If we call DILX+2, we set A = A / 4, so A is 0-15
11073               
11074 342A 091D  18        srl  ra,1                       ; LSR A             ; If we call DIL-1, we set A = A / 2, so A is 0-15
11075               
11076               DIL:
11077                                                                          ; If we call DIL, we leave A alone, so A is 0-15
11078 342C D80D  30        movb ra,@Q                      ; STA Q             ; Store the indicator value in Q, now reduced to 0-15,
     342E 0090     
11079                                                                          ; which is the length of the indicator to draw in pixels
11080               
11081 3430 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set R = &FF, to use as a mask for drawing each row of
     3432 FF00     
11082 3434 D80E  30        movb rx,@R                      ; STX R             ; each character block of the bar, starting with a full
     3436 0091     
11083                                                                          ; character's width of 4 pixels
11084               
11085 3438 9360  30        cb   @T1,ra                     ; CMP T1            ; If A >= T1 then we have passed the threshold where we
     343A 0006     
11086 343C 1803  14        joc  DL30                       ; BCS DL30          ; change bar colour, so jump to DL30 to set A to the
11087                                                                          ; "high value" colour
11088               
11089 343E D360  30        movb @K+1,ra                    ; LDA K+1           ; Set A to K+1, the "low value" colour to use
     3440 003E     
11090               
11091 3442 1602  14        jne  DL31                       ; BNE DL31          ; Jump down to DL31 (this BNE is effectively a JMP as A
11092                                                                          ; will never be zero)
11093               
11094               DL30:
11095 3444 D360  30        movb @K,ra                      ; LDA K             ; Set A to K, the "high value" colour to use
     3446 003D     
11096               
11097               DL31:
11098 3448 D80D  30        movb ra,@COL                    ; STA COL           ; Store the colour of the indicator in COL
     344A 00A2     
11099               
11100 344C 020F  20        li   ry,>02*256                 ; LDY #2            ; We want to start drawing the indicator on the third
     344E 0200     
11101                                                                          ; line in this character row, so set Y to point to that
11102                                                                          ; row's offset
11103               
11104 3450 020E  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X for the width of the indicator,
     3452 0300     
11105                                                                          ; which is 4 characters (each of which is 4 pixels wide,
11106                                                                          ; to give a total width of 16 pixels)
11107               
11108               DL1:
11109 3454 D360  30        movb @Q,ra                      ; LDA Q             ; Fetch the indicator value (0-15) from Q into A
     3456 0090     
11110               
11111 3458 028D  22        ci   ra,>04*256                 ; CMP #4            ; If Q < 4, then we need to draw the end cap of the
     345A 0400     
11112 345C 172D  14        jnc  DL2                        ; BCC DL2           ; indicator, which is less than a full character's
11113                                                                          ; width, so jump down to DL2 to do this
11114               
11115                      .sbi (>04*256)                  ; SBC #4            ; Otherwise we can draw a 4-pixel wide block, so
     **** ****     > SBI
0001 345E 1801  14        joc  !
0002 3460 7347  18        sb   rone,ra
0003               !:
0004 3462 022D  22        ai   ra,-(>04*256)
     3464 FC00     
                   < elite.a99
11116 3466 D80D  30        movb ra,@Q                      ; STA Q             ; subtract 4 from Q so it contains the amount of the
     3468 0090     
11117                                                                          ; indicator that's left to draw after this character
11118               
11119 346A D360  30        movb @R,ra                      ; LDA R             ; Fetch the shape of the indicator row that we need to
     346C 0091     
11120                                                                          ; display from R, so we can use it as a mask when
11121                                                                          ; painting the indicator. It will be &FF at this point
11122                                                                          ; (i.e. a full 4-pixel row)
11123               
11124               DL5:
11125                      .and @COL                       ; AND COL           ; Fetch the 4-pixel mode 5 colour byte from COL, and
     **** ****     > AND
0001 346E D020  30        movb @COL,rtmp
     3470 00A2     
0002 3472 0540  14        inv  rtmp
0003 3474 5340  18        szcb rtmp,ra
                   < elite.a99
11126                                                                          ; only keep pixels that have their equivalent bits set
11127                                                                          ; in the mask byte in A
11128               
11129                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 3476 D820  50        movb @SC,@rtmplb
     3478 0007     
     347A 206D     
0002 347C D020  30        movb @SC+1,rtmp
     347E 0008     
0003 3480 A00F  18        a    ry,rtmp
0004 3482 D40D  30        movb RA,*rtmp
                   < elite.a99
11130                                                                          ; character block we are processing
11131               
11132 3484 B3C7  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11133                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 3486 D820  50        movb @SC,@rtmplb
     3488 0007     
     348A 206D     
0002 348C D020  30        movb @SC+1,rtmp
     348E 0008     
0003 3490 A00F  18        a    ry,rtmp
0004 3492 D40D  30        movb RA,*rtmp
                   < elite.a99
11134               
11135 3494 B3C7  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11136                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 3496 D820  50        movb @SC,@rtmplb
     3498 0007     
     349A 206D     
0002 349C D020  30        movb @SC+1,rtmp
     349E 0008     
0003 34A0 A00F  18        a    ry,rtmp
0004 34A2 D40D  30        movb RA,*rtmp
                   < elite.a99
11137               
11138 34A4 D34F  18        movb ry,ra                      ; TYA               ; Add 6 to Y, so Y is now 8 more than when we started
11139                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 34A6 0A16  18        sla  rzero,1
                   < elite.a99
11140                      .adi (>06*256)                  ; ADC #6            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 34A8 1701  14        jnc  !
0002 34AA B347  18        ab   rone,ra
0003               !:
0004 34AC 022D  22        ai   ra,(>06*256)
     34AE 0600     
                   < elite.a99
11141 34B0 D3CD  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11142                                                                          ; screen memory)
11143               
11144 34B2 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter for the next character
11145                                                                          ; block along in the indicator
11146               
11147 34B4 111D  14        jlt  DL6                        ; BMI DL6           ; If we just drew the last character block then we are
11148                                                                          ; done drawing, so jump down to DL6 to finish off
11149               
11150 34B6 15CE  14        jgt  DL1                        ; BPL DL1           ; Loop back to DL1 to draw the next character block of
11151                                                                          ; the indicator (this BPL is effectively a JMP as A will
11152                                                                          ; never be negative following the previous BMI)
11153               
11154               DL2:
11155                      .eoi (>03*256)                  ; EOR #3            ; If we get here then we are drawing the indicator's
     **** ****     > EOI
0001 34B8 0200  20        li   rtmp,(>03*256)
     34BA 0300     
0002 34BC 2B40  18        xor  rtmp,ra
                   < elite.a99
11156 34BE D80D  30        movb ra,@Q                      ; STA Q             ; end cap, so Q is < 4, and this EOR flips the bits, so
     34C0 0090     
11157                                                                          ; instead of containing the number of indicator columns
11158                                                                          ; we need to fill in on the left side of the cap's
11159                                                                          ; character block, Q now contains the number of blank
11160                                                                          ; columns there should be on the right side of the cap's
11161                                                                          ; character block
11162               
11163 34C2 D360  30        movb @R,ra                      ; LDA R             ; Fetch the current mask from R, which will be &FF at
     34C4 0091     
11164                                                                          ; this point, so we need to turn Q of the columns on the
11165                                                                          ; right side of the mask to black to get the correct end
11166                                                                          ; cap shape for the indicator
11167               
11168               DL3:
11169                      .asla                           ; ASL A             ; Shift the mask left so bit 0 is cleared, and then
     **** ****     > ASLA
0001 34C6 024D  22        andi ra,>ff00
     34C8 FF00     
0002 34CA 0A1D  18        sla  ra,1
                   < elite.a99
11170 34CC 024D  22        andi ra,>ef*256                 ; AND #%11101111    ; clear bit 4, which has the effect of shifting zeroes
     34CE EF00     
11171                                                                          ; from the left into each nibble (i.e. xxxx xxxx becomes
11172                                                                          ; xxx0 xxx0, which blanks out the last column in the
11173                                                                          ; 4-pixel mode 5 character block)
11174               
11175 34D0 7347  18        sb   rone,ra                    ; DEC Q             ; Decrement the counter for the number of columns to
11176                                                                          ; blank out
11177               
11178 34D2 15F9  14        jgt  DL3                        ; BPL DL3           ; If we still have columns to blank out in the mask,
11179                                                                          ; loop back to DL3 until the mask is correct for the
11180                                                                          ; end cap
11181               
11182                      .pha                            ; PHA               ; Store the mask byte on the stack while we use the
     **** ****     > PHA
0001 34D4 D68D  30        movb ra,*rsp
0002 34D6 060A  14        dec  rsp
                   < elite.a99
11183                                                                          ; accumulator for a bit
11184               
11185 34D8 020D  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so the characters
     34DA 0000     
11186 34DC D80D  30        movb ra,@R                      ; STA R             ; after the one we're about to draw will be all blank
     34DE 0091     
11187               
11188 34E0 020D  20        li   ra,>63*256                 ; LDA #99           ; Set Q to a high number (99, why not) so we will keep
     34E2 6300     
11189 34E4 D80D  30        movb ra,@Q                      ; STA Q             ; drawing blank characters until we reach the end of
     34E6 0090     
11190                                                                          ; the indicator row
11191               
11192                      .pla                            ; PLA               ; Restore the mask byte from the stack so we can use it
     **** ****     > PLA
0001 34E8 058A  14        inc  rsp
0002 34EA D35A  26        movb *rsp,ra
                   < elite.a99
11193                                                                          ; to draw the end cap of the indicator
11194               
11195 34EC 0460  28        b    @DL5                       ; JMP DL5           ; Jump back up to DL5 to draw the mask byte on-screen
     34EE 346E     
11196               
11197               DL6:
11198 34F0 B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11199                                                                          ; character row on-screen (as each row takes up exactly
11200                                                                          ; one page of 256 bytes) - so this sets up SC to point
11201                                                                          ; to the next indicator, i.e. the one below the one we
11202                                                                          ; just drew
11203               
11204               DL9:
11205 34F2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     34F4 FE2A     
11206               
11207               * ******************************************************************************
11208               *
11209               * Name: DIL2
11210               * Type: Subroutine
11211               * Category: Dashboard
11212               * Summary: Update the roll or pitch indicator on the dashboard
11213               * Deep dive: The dashboard indicators
11214               *
11215               * ------------------------------------------------------------------------------
11216               *
11217               * The indicator can show a vertical bar in 16 positions, with a value of 8
11218               * showing the bar in the middle of the indicator.
11219               *
11220               * In practice this routine is only ever called with A in the range 1 to 15, so
11221               * the vertical bar never appears in the leftmost position (though it does appear
11222               * in the rightmost).
11223               *
11224               * ------------------------------------------------------------------------------
11225               *
11226               * Arguments:
11227               *
11228               * A                   The offset of the vertical bar to show in the indicator,
11229               * from 0 at the far left, to 8 in the middle, and 15 at
11230               * the far right
11231               *
11232               * ------------------------------------------------------------------------------
11233               *
11234               * Returns:
11235               *
11236               * C flag              The C flag is set
11237               *
11238               * ******************************************************************************
11239               
11240               DIL2:
11241 34F6 020F  20        li   ry,>01*256                 ; LDY #1            ; We want to start drawing the vertical indicator bar on
     34F8 0100     
11242                                                                          ; the second line in the indicator's character block, so
11243                                                                          ; set Y to point to that row's offset
11244               
11245 34FA D80D  30        movb ra,@Q                      ; STA Q             ; Store the offset of the vertical bar to draw in Q
     34FC 0090     
11246               
11247                                                                          ; We are now going to work our way along the indicator
11248                                                                          ; on the dashboard, from left to right, working our way
11249                                                                          ; along one character block at a time. Y will be used as
11250                                                                          ; a pixel row counter to work our way through the
11251                                                                          ; character blocks, so each time we draw a character
11252                                                                          ; block, we will increment Y by 8 to move on to the next
11253                                                                          ; block (as each character block contains 8 rows)
11254               
11255               DLL10:
11256                      .sec                            ; SEC               ; Set A = Q - 4, so that A contains the offset of the
     **** ****     > SEC
0001 34FE 0A18  18        sla  rmone,1
                   < elite.a99
11257 3500 D360  30        movb @Q,ra                      ; LDA Q             ; vertical bar from the start of this character block
     3502 0090     
11258                      .sbi (>04*256)                  ; SBC #4
     **** ****     > SBI
0001 3504 1801  14        joc  !
0002 3506 7347  18        sb   rone,ra
0003               !:
0004 3508 022D  22        ai   ra,-(>04*256)
     350A FC00     
                   < elite.a99
11259               
11260 350C 180B  14        joc  DLL11                      ; BCS DLL11         ; If Q >= 4 then the character block we are drawing does
11261                                                                          ; not contain the vertical indicator bar, so jump to
11262                                                                          ; DLL11 to draw a blank character block
11263               
11264 350E 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to a high number (and &FF is as high as they go)
     3510 FF00     
11265               
11266 3512 D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X to the offset of the vertical bar, which we know
     3514 0090     
11267                                                                          ; is within this character block
11268               
11269 3516 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q to a high number (&FF, why not) so we will keep
     3518 0090     
11270                                                                          ; drawing blank characters after this one until we reach
11271                                                                          ; the end of the indicator row
11272               
11273 351A D36E  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; CTWOS is a table of ready-made 1-pixel mode 5 bytes,
     351C 2249     
11274                                                                          ; just like the TWOS and TWOS2 tables for mode 4 (see
11275                                                                          ; the PIXEL routine for details of how they work). This
11276                                                                          ; fetches a mode 5 1-pixel byte with the pixel position
11277                                                                          ; at X, so the pixel is at the offset that we want for
11278                                                                          ; our vertical bar
11279               
11280 351E 024D  22        andi ra,>f0*256                 ; AND #&F0          ; The 4-pixel mode 5 colour byte &F0 represents four
     3520 F000     
11281                                                                          ; pixels of colour %10 (3), which is yellow in the
11282                                                                          ; normal dashboard palette and white if we have an
11283                                                                          ; escape pod fitted. We AND this with A so that we only
11284                                                                          ; keep the pixel that matches the position of the
11285                                                                          ; vertical bar (i.e. A is acting as a mask on the
11286                                                                          ; 4-pixel colour byte)
11287               
11288 3522 1604  14        jne  DLL12                      ; BNE DLL12         ; Jump to DLL12 to skip the code for drawing a blank,
11289                                                                          ; and move on to drawing the indicator (this BNE is
11290                                                                          ; effectively a JMP as A is always non-zero)
11291               
11292               DLL11:
11293                                                                          ; If we get here then we want to draw a blank for this
11294                                                                          ; character block
11295 3524 D80D  30        movb ra,@Q                      ; STA Q             ; Update Q with the new offset of the vertical bar, so
     3526 0090     
11296                                                                          ; it becomes the offset after the character block we
11297                                                                          ; are about to draw
11298               
11299 3528 020D  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so all of the
     352A 0000     
11300                                                                          ; character blocks we display from now on will be blank
11301               DLL12:
11302                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 352C D820  50        movb @SC,@rtmplb
     352E 0007     
     3530 206D     
0002 3532 D020  30        movb @SC+1,rtmp
     3534 0008     
0003 3536 A00F  18        a    ry,rtmp
0004 3538 D40D  30        movb RA,*rtmp
                   < elite.a99
11303                                                                          ; character block we are processing
11304               
11305 353A B3C7  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11306                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 353C D820  50        movb @SC,@rtmplb
     353E 0007     
     3540 206D     
0002 3542 D020  30        movb @SC+1,rtmp
     3544 0008     
0003 3546 A00F  18        a    ry,rtmp
0004 3548 D40D  30        movb RA,*rtmp
                   < elite.a99
11307               
11308 354A B3C7  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11309                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 354C D820  50        movb @SC,@rtmplb
     354E 0007     
     3550 206D     
0002 3552 D020  30        movb @SC+1,rtmp
     3554 0008     
0003 3556 A00F  18        a    ry,rtmp
0004 3558 D40D  30        movb RA,*rtmp
                   < elite.a99
11310               
11311 355A B3C7  18        ab   rone,ry                    ; INY               ; And draw the fourth pixel row, incrementing Y
11312                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 355C D820  50        movb @SC,@rtmplb
     355E 0007     
     3560 206D     
0002 3562 D020  30        movb @SC+1,rtmp
     3564 0008     
0003 3566 A00F  18        a    ry,rtmp
0004 3568 D40D  30        movb RA,*rtmp
                   < elite.a99
11313               
11314 356A D34F  18        movb ry,ra                      ; TYA               ; Add 5 to Y, so Y is now 8 more than when we started
11315                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 356C 0A16  18        sla  rzero,1
                   < elite.a99
11316                      .adi (>05*256)                  ; ADC #5            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 356E 1701  14        jnc  !
0002 3570 B347  18        ab   rone,ra
0003               !:
0004 3572 022D  22        ai   ra,(>05*256)
     3574 0500     
                   < elite.a99
11317 3576 D3CD  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11318                                                                          ; screen memory)
11319               
11320 3578 028F  22        ci   ry,>1e*256                 ; CPY #30           ; If Y < 30 then we still have some more character
     357A 1E00     
11321 357C 17C0  14        jnc  DLL10                      ; BCC DLL10         ; blocks to draw, so loop back to DLL10 to display the
11322                                                                          ; next one along
11323               
11324 357E B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11325                                                                          ; character row on-screen (as each row takes up exactly
11326                                                                          ; one page of 256 bytes) - so this sets up SC to point
11327                                                                          ; to the next indicator, i.e. the one below the one we
11328                                                                          ; just drew
11329               
11330 3580 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3582 FE2A     
11331               
11332               * ******************************************************************************
11333               *
11334               * Name: TVT1
11335               * Type: Variable
11336               * Category: Drawing the screen
11337               * Summary: Palette data for space and the two dashboard colour schemes
11338               *
11339               * ------------------------------------------------------------------------------
11340               *
11341               * Palette bytes for use with the split-screen mode (see IRQ1 below for more
11342               * details).
11343               *
11344               * Palette data is given as a set of bytes, with each byte mapping a logical
11345               * colour to a physical one. In each byte, the logical colour is given in bits
11346               * 4-7 and the physical colour in bits 0-3. See p.379 of the Advanced User Guide
11347               * for details of how palette mapping works, as in modes 4 and 5 we have to do
11348               * multiple palette commands to change the colours correctly, and the physical
11349               * colour value is EOR'd with 7, just to make things even more confusing.
11350               *
11351               * Similarly, the palette at TVT1+16 is for the monochrome space view, where
11352               * logical colour 1 is mapped to physical colour 0 EOR 7 = 7 (white), and
11353               * logical colour 0 is mapped to physical colour 7 EOR 7 = 0 (black). Each of
11354               * these mappings requires six calls to SHEILA &21 - see p.379 of the Advanced
11355               * User Guide for an explanation.
11356               *
11357               * The mode 5 palette table has two blocks which overlap. The block used depends
11358               * on whether or not we have an escape pod fitted. The block at TVT1 is used for
11359               * the standard dashboard colours, while TVT1+8 is used for the dashboard when an
11360               * escape pod is fitted. The colours are as follows:
11361               *
11362               * Normal (TVT1)     Escape pod (TVT1+8)
11363               *
11364               * Colour 0      Black             Black
11365               * Colour 1      Red               Red
11366               * Colour 2      Yellow            White
11367               * Colour 3      Green             Cyan
11368               *
11369               * ******************************************************************************
11370               
11371               TVT1:
11372 3584 D4C4            byte >d4,>c4                                        ; This block of palette data is used to create two
11373 3586 9484            byte >94,>84                                        ; palettes used in three different places, all of them
11374 3588 F5E5            byte >f5,>e5                                        ; redefining four colours in mode 5:
11375 358A B5A5            byte >b5,>a5                                        ;
11376                                                                          ; 12 bytes from TVT1 (i.e. the first 6 rows): applied
11377 358C 7666            byte >76,>66                                        ; when the T1 timer runs down at the switch from the
11378 358E 3626            byte >36,>26                                        ; space view to the dashboard, so this is the standard
11379                                                                          ; dashboard palette
11380 3590 E1F1            byte >e1,>f1                                        ;
11381 3592 B1A1            byte >b1,>a1                                        ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11382                                                                          ; when the T1 timer runs down at the switch from the
11383                                                                          ; space view to the dashboard, and we have an escape
11384                                                                          ; pod fitted, so this is the escape pod dashboard
11385                                                                          ; palette
11386                                                                          ;
11387                                                                          ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11388                                                                          ; at vertical sync in LINSCN when HFX is non-zero, to
11389                                                                          ; create the hyperspace effect in LINSCN (where the
11390                                                                          ; whole screen is switched to mode 5 at vertical sync)
11391               
11392 3594 F0E0            byte >f0,>e0                                        ; 12 bytes of palette data at TVT1+16, used to set the
11393 3596 B0A0            byte >b0,>a0                                        ; mode 4 palette in LINSCN when we hit vertical sync,
11394 3598 D0C0            byte >d0,>c0                                        ; so the palette is set to monochrome when we start to
11395 359A 9080            byte >90,>80                                        ; draw the first row of the screen
11396 359C 7767            byte >77,>67
11397 359E 3727            byte >37,>27
11398               
11399               * ******************************************************************************
11400               *
11401               * Name: IRQ1
11402               * Type: Subroutine
11403               * Category: Drawing the screen
11404               * Summary: The main screen-mode interrupt handler (IRQ1V points here)
11405               * Deep dive: The split-screen mode in BBC Micro Elite
11406               *
11407               * ------------------------------------------------------------------------------
11408               *
11409               * The main interrupt handler, which implements Elite's split-screen mode (see
11410               * the deep dive on "The split-screen mode in BBC Micro Elite" for details).
11411               *
11412               * IRQ1V is set to point to IRQ1 by the loading process.
11413               *
11414               * ******************************************************************************
11415               
11416               LINSCN:
11417                                                                          ; This is called from the interrupt handler below, at
11418                                                                          ; the start of each vertical sync (i.e. when the screen
11419                                                                          ; refresh starts)
11420 35A0 020D  20        li   ra,>1e*256                 ; LDA #30           ; Set the line scan counter to a non-zero value, so
     35A2 1E00     
11421 35A4 D80D  30        movb ra,@DL                     ; STA DL            ; routines like WSCAN can set DL to 0 and then wait for
     35A6 009A     
11422                                                                          ; it to change to non-zero to catch the vertical sync
11423               
11424 35A8 D80D  38        movb ra,@VIA+>44                ; STA VIA+&44       ; Set 6522 System VIA T1C-L timer 1 low-order counter
     35AA FE44     
11425                                                                          ; (SHEILA &44) to 30
11426               
11427 35AC 020D  20        li   ra,(VSCAN)*256             ; LDA #VSCAN        ; Set 6522 System VIA T1C-L timer 1 high-order counter
     35AE 3900     
11428 35B0 D80D  38        movb ra,@VIA+>45                ; STA VIA+&45       ; (SHEILA &45) to VSCAN (57) to start the T1 counter
     35B2 FE45     
11429                                                                          ; counting down from 14622 at a rate of 1 MHz
11430               
11431 35B4 D360  30        movb @HFX,ra                    ; LDA HFX           ; If HFX is non-zero, jump to VNT1 to set the mode 5
     35B6 0D62     
11432 35B8 163D  14        jne  VNT1                       ; BNE VNT1          ; palette instead of switching to mode 4, which will
11433                                                                          ; have the effect of blurring and colouring the top
11434                                                                          ; screen. This is how the white hyperspace rings turn
11435                                                                          ; to colour when we do a hyperspace jump, and is
11436                                                                          ; triggered by setting HFX to 1 in routine LL164
11437               
11438 35BA 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; Set the Video ULA control register (SHEILA &20) to
     35BC 0800     
11439 35BE D80D  38        movb ra,@VIA+>20                ; STA VIA+&20       ; %00001000, which is the same as switching to mode 4
     35C0 FE20     
11440                                                                          ; (i.e. the top part of the screen) but with no cursor
11441               
11442               VNT3:
11443 35C2 D36F  34        movb @TVT1+16(ry),ra            ; LDA TVT1+16,Y     ; Copy the Y-th palette byte from TVT1+16 to SHEILA &21
     35C4 3594     
11444 35C6 D80D  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     35C8 FE21     
11445                                                                          ; of the screen (i.e. the dashboard)
11446               
11447 35CA 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11448               
11449 35CC 15FA  14        jgt  VNT3                       ; BPL VNT3          ; Loop back to VNT3 until we have copied all the
11450                                                                          ; palette bytes
11451               
11452 35CE D360  30        movb @LASCT,ra                  ; LDA LASCT         ; Decrement the value of LASCT, but if we go too far
     35D0 0D60     
11453 35D2 1301  14        jeq  B30                        ; BEQ B30           ; and it becomes negative, bump it back up again (this
11454 35D4 7347  18        sb   rone,ra                    ; DEC LASCT         ; controls the pulsing of pulse lasers)
11455               
11456               B30:
11457 35D6 D360  34        movb @SVN,ra                    ; LDA SVN           ; If SVN is non-zero, we are in the process of saving
     35D8 F2BD     
11458 35DA 1623  14        jne  jvec_                      ; BNE jvec          ; the commander file, so jump to jvec to pass control
11459                                                                          ; to the next interrupt handler, so we don't break file
11460                                                                          ; saving by blocking the interrupt chain
11461               
11462                      .pla                            ; PLA               ; Otherwise restore Y from the stack
     **** ****     > PLA
0001 35DC 058A  14        inc  rsp
0002 35DE D35A  26        movb *rsp,ra
                   < elite.a99
11463 35E0 D3CD  18        movb ra,ry                      ; TAY
11464               
11465 35E2 D360  34        movb @VIA+>41,ra                ; LDA VIA+&41       ; Read 6522 System VIA input register IRA (SHEILA &41)
     35E4 FE41     
11466               
11467 35E6 D360  30        movb @>FC,ra                    ; LDA &FC           ; Set A to the interrupt accumulator save register,
     35E8 00FC     
11468                                                                          ; which restores A to the value it had on entering the
11469                                                                          ; interrupt
11470               
11471                      ; RTI                           ; RTI               ; Return from interrupts, so this interrupt is not
11472                                                                          ; passed on to the next interrupt handler, but instead
11473                                                                          ; the interrupt terminates here
11474               
11475               IRQ1:
11476 35EA D34F  18        movb ry,ra                      ; TYA               ; Store Y on the stack
11477                      .pha                            ; PHA
     **** ****     > PHA
0001 35EC D68D  30        movb ra,*rsp
0002 35EE 060A  14        dec  rsp
                   < elite.a99
11478               
11479 35F0 020F  20        li   ry,>0b*256                 ; LDY #11           ; Set Y as a counter for 12 bytes, to use when setting
     35F2 0B00     
11480                                                                          ; the dashboard palette below
11481               
11482 35F4 020D  20        li   ra,>02*256                 ; LDA #%00000010    ; Read the 6522 System VIA status byte bit 1 (SHEILA
     35F6 0200     
11483                      .bit @VIA+>4D                   ; BIT VIA+&4D       ; &4D), which is set if vertical sync has occurred on
     **** ****     > BIT
0001 35F8 D020  34        movb @VIA+>4D,rtmp
     35FA FE4D     
0002 35FC 0540  14        inv  rtmp
0003 35FE D047  18        movb rone,rtmp2
0004 3600 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
11484                                                                          ; the video system
11485               
11486 3602 16CE  14        jne  LINSCN                     ; BNE LINSCN        ; If we are on the vertical sync pulse, jump to LINSCN
11487                                                                          ; to set up the timers to enable us to switch the
11488                                                                          ; screen mode between the space view and dashboard
11489               
11490 3604 190E  14        jno  jvec_                      ; BVC jvec          ; Read the 6522 System VIA status byte bit 6, which is
11491                                                                          ; set if timer 1 has timed out. We set the timer in
11492                                                                          ; LINSCN above, so this means we only run the next bit
11493                                                                          ; if the screen redraw has reached the boundary between
11494                                                                          ; the space view and the dashboard. Otherwise bit 6 is
11495                                                                          ; clear and we aren't at the boundary, so we jump to
11496                                                                          ; jvec to pass control to the next interrupt handler
11497               
11498                      .asla                           ; ASL A             ; Double the value in A to 4
     **** ****     > ASLA
0001 3606 024D  22        andi ra,>ff00
     3608 FF00     
0002 360A 0A1D  18        sla  ra,1
                   < elite.a99
11499               
11500 360C D80D  38        movb ra,@VIA+>20                ; STA VIA+&20       ; Set the Video ULA control register (SHEILA &20) to
     360E FE20     
11501                                                                          ; %00000100, which is the same as switching to mode 5,
11502                                                                          ; (i.e. the bottom part of the screen) but with no
11503                                                                          ; cursor
11504               
11505 3610 D360  30        movb @ESCP,ra                   ; LDA ESCP          ; If an escape pod is fitted, jump to VNT1 to set the
     3612 032E     
11506 3614 160F  14        jne  VNT1                       ; BNE VNT1          ; mode 5 palette differently (so the dashboard is a
11507                                                                          ; different colour if we have an escape pod)
11508               
11509               B31:
11510 3616 D36F  34        movb @TVT1(ry),ra               ; LDA TVT1,Y        ; Copy the Y-th palette byte from TVT1 to SHEILA &21
     3618 3584     
11511 361A D80D  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     361C FE21     
11512                                                                          ; of the screen (i.e. the dashboard)
11513               
11514 361E 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11515               
11516 3620 15FA  14        jgt  B31                        ; BPL B31           ; Loop back to the LDA TVT1,Y instruction until we have
11517                                                                          ; copied all the palette bytes
11518               
11519               jvec_:
11520                      .pla                            ; PLA               ; Restore Y from the stack
     **** ****     > PLA
0001 3622 058A  14        inc  rsp
0002 3624 D35A  26        movb *rsp,ra
                   < elite.a99
11521 3626 D3CD  18        movb ra,ry                      ; TAY
11522               
11523                      .jmpi @VEC                      ; JMP (VEC)         ; Jump to the address in VEC, which was set to the
     **** ****     > JMPI
0001 3628 D82E  54        movb @VEC(rx),@rtmplb
     362A F2BE     
     362C 206D     
0002 362E D02E  34        movb @VEC+1(rx),rtmp
     3630 F2BF     
0003 3632 0450  20        b    *rtmp
                   < elite.a99
11524                                                                          ; original IRQ1V vector by the loading process, so this
11525                                                                          ; instruction passes control to the next interrupt
11526                                                                          ; handler
11527               
11528               VNT1:
11529 3634 020F  20        li   ry,>07*256                 ; LDY #7            ; Set Y as a counter for 8 bytes
     3636 0700     
11530               
11531 3638 D36F  34        movb @TVT1+8(ry),ra             ; LDA TVT1+8,Y      ; Copy the Y-th palette byte from TVT1+8 to SHEILA &21
     363A 358C     
11532 363C D80D  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     363E FE21     
11533                                                                          ; of the screen (i.e. the dashboard)
11534               
11535 3640 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11536               
11537 3642 15F9  14        jgt  VNT1+2                     ; BPL VNT1+2        ; Loop back to the LDA TVT1+8,Y instruction until we
11538                                                                          ; have copied all the palette bytes
11539               
11540 3644 11EE  14        jlt  jvec_                      ; BMI jvec          ; Jump up to jvec to pass control to the next interrupt
11541                                                                          ; handler (this BMI is effectively a JMP as we didn't
11542                                                                          ; loop back with the BPL above, so BMI is always true)
11543               
11544               * ******************************************************************************
11545               *
11546               * Name: ESCAPE
11547               * Type: Subroutine
11548               * Category: Flight
11549               * Summary: Launch our escape pod
11550               *
11551               * ------------------------------------------------------------------------------
11552               *
11553               * This routine displays our doomed Cobra Mk III disappearing off into the ether
11554               * before arranging our replacement ship. Called when we press ESCAPE during
11555               * flight and have an escape pod fitted.
11556               *
11557               * ******************************************************************************
11558               
11559               ESCAPE:
11560 3646 D360  30        movb @MJ,ra                     ; LDA MJ            ; Store the value of MJ on the stack (the "are we in
     3648 0D5C     
11561                      .pha                            ; PHA               ; witchspace?" flag)
     **** ****     > PHA
0001 364A D68D  30        movb ra,*rsp
0002 364C 060A  14        dec  rsp
                   < elite.a99
11562               
11563 364E 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     3650 BF32     
11564 3652 06A0  32        bl   @jsr                       ;
     3654 FE1E     
11565               
11566 3656 020E  20        li   rx,(CYL)*256               ; LDX #CYL          ; Set the current ship type to a Cobra Mk III, so we
     3658 0700     
11567 365A D80E  30        movb rx,@TYPE                   ; STX TYPE          ; can show our ship disappear into the distance when we
     365C 009B     
11568                                                                          ; eject in our pod
11569               
11570 365E 0200  20        li   rtmp,FRS1                  ; JSR FRS1          ; Call FRS1 to launch the Cobra Mk III straight ahead,
     3660 3BD8     
11571 3662 06A0  32        bl   @jsr                       ;
     3664 FE1E     
11572                                                                          ; like a missile launch, but with our ship instead
11573               
11574 3666 020D  20        li   ra,>08*256                 ; LDA #8            ; Set the Cobra's byte #27 (speed) to 8
     3668 0800     
11575 366A D80D  30        movb ra,@INWK+27                ; STA INWK+27
     366C 006E     
11576               
11577 366E 020D  20        li   ra,>c2*256                 ; LDA #194          ; Set the Cobra's byte #30 (pitch counter) to 194, so it
     3670 C200     
11578 3672 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; pitches up as we pull away
     3674 0071     
11579               
11580 3676 091D  18        srl  ra,1                       ; LSR A             ; Set the Cobra's byte #32 (AI flag) to %01100001, so it
11581 3678 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; has no AI, and we can use this value as a counter to
     367A 0073     
11582                                                                          ; do the following loop 97 times
11583               
11584               ESL1:
11585 367C 0200  20        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the Cobra in space
     367E 17E2     
11586 3680 06A0  32        bl   @jsr                       ;
     3682 FE1E     
11587               
11588 3684 0200  20        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the Cobra on-screen
     3686 D4B4     
11589 3688 06A0  32        bl   @jsr                       ;
     368A FE1E     
11590               
11591 368C 7347  18        sb   rone,ra                    ; DEC INWK+32       ; Decrement the counter in byte #32
11592               
11593 368E 16F6  14        jne  ESL1                       ; BNE ESL1          ; Loop back to keep moving the Cobra until the AI flag
11594                                                                          ; is 0, which gives it time to drift away from our pod
11595               
11596 3690 0200  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to remove the Cobra from the scanner (by
     3692 4C86     
11597 3694 06A0  32        bl   @jsr                       ;
     3696 FE1E     
11598                                                                          ; redrawing it)
11599               
11600 3698 0200  20        li   rtmp,RESET                 ; JSR RESET         ; Call RESET to reset our ship and various controls
     369A BF0A     
11601 369C 06A0  32        bl   @jsr                       ;
     369E FE1E     
11602               
11603                      .pla                            ; PLA               ; Restore the witchspace flag from before the escape pod
     **** ****     > PLA
0001 36A0 058A  14        inc  rsp
0002 36A2 D35A  26        movb *rsp,ra
                   < elite.a99
11604 36A4 1302  14        jeq  B32                        ; BEQ B32           ; launch, and if we were in normal space, skip the
11605                                                                          ; following instruction
11606               
11607 36A6 0460  28        b    @DEATH                     ; JMP DEATH         ; Launching an escape pod in witchspace is fatal, so
     36A8 C47E     
11608                                                                          ; jump to DEATH to begin the funeral and return from the
11609                                                                          ; subroutine using a tail call
11610               
11611               B32:
11612 36AA 020E  20        li   rx,>10*256                 ; LDX #16           ; We lose all our cargo when using our escape pod, so
     36AC 1000     
11613                                                                          ; up a counter in X so we can zero the 17 cargo slots
11614                                                                          ; in QQ20
11615               
11616               ESL2:
11617 36AE DB8D  38        movb ra,@QQ20(rx)               ; STA QQ20,X        ; Set the X-th byte of QQ20 to zero (as we know A = 0
     36B0 0317     
11618                                                                          ; from the BEQ above), so we no longer have any of item
11619                                                                          ; type X in the cargo hold
11620               
11621 36B2 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11622               
11623 36B4 15FC  14        jgt  ESL2                       ; BPL ESL2          ; Loop back to ESL2 until we have emptied the entire
11624                                                                          ; cargo hold
11625               
11626 36B6 D80D  30        movb ra,@FIST                   ; STA FIST          ; Launching an escape pod also clears our criminal
     36B8 0334     
11627                                                                          ; record, so set our legal status in FIST to 0 ("clean")
11628               
11629 36BA D80D  30        movb ra,@ESCP                   ; STA ESCP          ; The escape pod is a one-use item, so set ESCP to 0 so
     36BC 032E     
11630                                                                          ; we no longer have one fitted
11631               
11632 36BE 020D  20        li   ra,>46*256                 ; LDA #70           ; Our replacement ship is delivered with a full tank of
     36C0 4600     
11633 36C2 D80D  30        movb ra,@QQ14                   ; STA QQ14          ; fuel, so set the current fuel level in QQ14 to 70, or
     36C4 030D     
11634                                                                          ; 7.0 light years
11635               
11636 36C6 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     36C8 C65C     
11637                                                                          ; screen) and return from the subroutine with a tail
11638                                                                          ; call
11639               
11640               * ******************************************************************************
11641               *
11642               * Save ELTB.bin
11643               *
11644               * ******************************************************************************
11645               
11646                      ; PRINT "ELITE B"
11647                      ; PRINT "Assembled at ", ~CODE_B%
11648                      ; PRINT "Ends at ", ~P%
11649                      ; PRINT "Code size is ", ~(P% - CODE_B%)
11650                      ; PRINT "Execute at ", ~LOAD%
11651                      ; PRINT "Reload at ", ~LOAD_B%
11652               
11653                      ; PRINT "S.ELTB ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_B%
11654                      ; SAVE "3-assembled-output/ELTB.bin", CODE_B%, P%, LOAD%
11655               
11656               * ******************************************************************************
11657               *
11658               * ELITE C FILE
11659               *
11660               * Produces the binary file ELTC.bin that gets loaded by elite-bcfs.asm.
11661               *
11662               * ******************************************************************************
11663               
11664               CODE_C.:
11665                      equ $
11666               
11667               LOAD_C.:
11668                      equ LOAD. + $ - CODE.
11669               
11670               * ******************************************************************************
11671               *
11672               * Name: TACTICS (Part 1 of 7)
11673               * Type: Subroutine
11674               * Category: Tactics
11675               * Summary: Apply tactics: Process missiles, both enemy missiles and our own
11676               * Deep dive: Program flow of the tactics routine
11677               *
11678               * ------------------------------------------------------------------------------
11679               *
11680               * This section implements missile tactics and is entered at TA18 from the main
11681               * entry point below, if the current ship is a missile. Specifically:
11682               *
11683               * * If E.C.M. is active, destroy the missile
11684               *
11685               * * If the missile is hostile towards us, then check how close it is. If it
11686               * hasn't reached us, jump to part 3 so it can streak towards us, otherwise
11687               * we've been hit, so process a large amount of damage to our ship
11688               *
11689               * * Otherwise see how close the missile is to its target. If it has not yet
11690               * reached its target, give the target a chance to activate its E.C.M. if it
11691               * has one, otherwise jump to TA19 with K3 set to the vector from the target
11692               * to the missile
11693               *
11694               * * If it has reached its target and the target is the space station, destroy
11695               * the missile, potentially damaging us if we are nearby
11696               *
11697               * * If it has reached its target and the target is a ship, destroy the missile
11698               * and the ship, potentially damaging us if we are nearby
11699               *
11700               * ******************************************************************************
11701               
11702               TA34:
11703                                                                          ; If we get here, the missile is hostile
11704 36CA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     36CC 0000     
11705 36CE 0200  20        li   rtmp,MAS4                  ; JSR MAS4
     36D0 C46E     
11706 36D2 06A0  32        bl   @jsr                       ;
     36D4 FE1E     
11707               
11708 36D6 1300  14        jeq  B33                        ; BEQ B33           ; If A = 0 then the missile is very close to our ship,
11709                                                                          ; so skip the following instruction
11710               
11711               B33:
11712 36D8 0460  28        b    @TA21                      ; JMP TA21          ; Jump down to part 3 to set up the vectors and skip
     36DA 38AE     
11713                                                                          ; straight to aggressive manoeuvring
11714               
11715 36DC 0200  20        li   rtmp,TA87+3                ; JSR TA87+3        ; The missile has hit our ship, so call TA87+3 to set
     36DE 37B3     
11716 36E0 06A0  32        bl   @jsr                       ;
     36E2 FE1E     
11717                                                                          ; bit 7 of the missile's byte #31, which marks the
11718                                                                          ; missile as being killed
11719               
11720 36E4 0200  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the missile exploding
     36E6 CB2E     
11721 36E8 06A0  32        bl   @jsr                       ;
     36EA FE1E     
11722               
11723 36EC 020D  20        li   ra,>fa*256                 ; LDA #250          ; Call OOPS to damage the ship by 250, which is a pretty
     36EE FA00     
11724 36F0 0460  28        b    @OOPS                      ; JMP OOPS          ; big hit, and return from the subroutine using a tail
     36F2 AE76     
11725                                                                          ; call
11726               
11727               TA18:
11728                                                                          ; This is the entry point for missile tactics and is
11729                                                                          ; called from the main TACTICS routine below
11730 36F4 D360  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     36F6 0030     
11731 36F8 164E  14        jne  TA35                       ; BNE TA35          ; opponent's), jump to TA35 to destroy this missile
11732               
11733 36FA D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if bit 6 is set
     36FC 0073     
11734                      .asla                           ; ASL A             ; (i.e. missile is hostile), jump up to TA34 to check
     **** ****     > ASLA
0001 36FE 024D  22        andi ra,>ff00
     3700 FF00     
0002 3702 0A1D  18        sla  ra,1
                   < elite.a99
11735 3704 11E2  14        jlt  TA34                       ; BMI TA34          ; whether the missile has hit us
11736               
11737 3706 091D  18        srl  ra,1                       ; LSR A             ; Otherwise shift A right again. We know bits 6 and 7
11738                                                                          ; are now clear, so this leaves bits 0-5. Bits 1-5
11739                                                                          ; contain the target's slot number, and bit 0 is cleared
11740                                                                          ; in FRMIS when a missile is launched, so A contains
11741                                                                          ; the slot number shifted left by 1 (i.e. doubled) so we
11742                                                                          ; can use it as an index for the two-byte address table
11743                                                                          ; at UNIV
11744               
11745 3708 D38D  18        movb ra,rx                      ; TAX               ; Copy the address of the target ship's data block from
11746 370A D36E  34        movb @UNIV(rx),ra               ; LDA UNIV,X        ; UNIV(X+1 X) to V(1 0)
     370C 221F     
11747 370E D80D  30        movb ra,@V                      ; STA V
     3710 0022     
11748 3712 D36E  34        movb @UNIV+1(rx),ra             ; LDA UNIV+1,X
     3714 2220     
11749 3716 D80D  30        movb ra,@V+1                    ; STA V+1
     3718 0023     
11750               
11751 371A 020F  20        li   ry,>02*256                 ; LDY #2            ; K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of
     371C 0200     
11752 371E 0200  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3720 3AD2     
11753 3722 06A0  32        bl   @jsr                       ;
     3724 FE1E     
11754               
11755 3726 020F  20        li   ry,>05*256                 ; LDY #5            ; K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of
     3728 0500     
11756 372A 0200  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     372C 3AD2     
11757 372E 06A0  32        bl   @jsr                       ;
     3730 FE1E     
11758               
11759 3732 020F  20        li   ry,>08*256                 ; LDY #8            ; K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of
     3734 0800     
11760 3736 0200  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3738 3AD2     
11761 373A 06A0  32        bl   @jsr                       ;
     373C FE1E     
11762               
11763                                                                          ; So K3 now contains the vector from the target ship to
11764                                                                          ; the missile
11765               
11766 373E D360  30        movb @K3+2,ra                   ; LDA K3+2          ; Set A = OR of all the sign and high bytes of the
     3740 00D4     
11767 3742 F360  30        socb @K3+5,ra                   ; ORA K3+5          ; above, clearing bit 7 (i.e. ignore the signs)
     3744 00D7     
11768 3746 F360  30        socb @K3+8,ra                   ; ORA K3+8
     3748 00DA     
11769 374A 024D  22        andi ra,>7f*256                 ; AND #%01111111
     374C 7F00     
11770 374E F360  30        socb @K3+1,ra                   ; ORA K3+1
     3750 00D3     
11771 3752 F360  30        socb @K3+4,ra                   ; ORA K3+4
     3754 00D6     
11772 3756 F360  30        socb @K3+7,ra                   ; ORA K3+7
     3758 00D9     
11773               
11774 375A 163C  14        jne  TA64                       ; BNE TA64          ; If the result is non-zero, then the missile is some
11775                                                                          ; distance from the target, so jump down to TA64 see if
11776                                                                          ; the target activates its E.C.M.
11777               
11778 375C D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if only bits 7 and
     375E 0073     
11779 3760 028D  22        ci   ra,>82*256                 ; CMP #%10000010    ; 1 are set (AI is enabled and the target is slot 1, the
     3762 8200     
11780 3764 1318  14        jeq  TA35                       ; BEQ TA35          ; space station), jump to TA35 to destroy this missile,
11781                                                                          ; as the space station ain't kidding around
11782               
11783 3766 020F  20        li   ry,>1f*256                 ; LDY #31           ; Fetch byte #31 (the exploding flag) of the target ship
     3768 1F00     
11784                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into A
     **** ****     > LD_IND_Y_IDX
0001 376A D820  50        movb @V,@rtmplb
     376C 0022     
     376E 206D     
0002 3770 D020  30        movb @V+1,rtmp
     3772 0023     
0003 3774 A00F  18        a    ry,rtmp
0004 3776 D350  26        movb *rtmp,RA
                   < elite.a99
11785               
11786                      .bit @M32+1                     ; BIT M32+1         ; M32 contains an LDY #32 instruction, so M32+1 contains
     **** ****     > BIT
0001 3778 D020  34        movb @M32+1,rtmp
     377A 37E3     
0002 377C 0540  14        inv  rtmp
0003 377E D047  18        movb rone,rtmp2
0004 3780 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
11787                                                                          ; 32, so this instruction tests A with %00100000, which
11788                                                                          ; checks bit 5 of A (the "already exploding?" bit)
11789               
11790 3782 1609  14        jne  TA35                       ; BNE TA35          ; If the target ship is already exploding, jump to TA35
11791                                                                          ; to destroy this missile
11792               
11793 3784 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 of the target's byte #31 to mark
     3786 8000     
11794                      .st_ind_y_idx @V,ra             ; STA (V),Y         ; the ship as having been killed, so it explodes
     **** ****     > ST_IND_Y_IDX
0001 3788 D820  50        movb @V,@rtmplb
     378A 0022     
     378C 206D     
0002 378E D020  30        movb @V+1,rtmp
     3790 0023     
0003 3792 A00F  18        a    ry,rtmp
0004 3794 D40D  30        movb RA,*rtmp
                   < elite.a99
11795               
11796               TA35:
11797 3796 D360  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo OR y_lo OR z_lo of the missile
     3798 0053     
11798 379A F360  30        socb @INWK+3,ra                 ; ORA INWK+3
     379C 0056     
11799 379E F360  30        socb @INWK+6,ra                 ; ORA INWK+6
     37A0 0059     
11800               
11801 37A2 1606  14        jne  TA87                       ; BNE TA87          ; If A is non-zero then the missile is not near our
11802                                                                          ; ship, so jump to TA87 to skip damaging our ship
11803               
11804 37A4 020D  20        li   ra,>50*256                 ; LDA #80           ; Otherwise the missile just got destroyed near us, so
     37A6 5000     
11805 37A8 0200  20        li   rtmp,OOPS                  ; JSR OOPS          ; call OOPS to damage the ship by 80, which is nowhere
     37AA AE76     
11806 37AC 06A0  32        bl   @jsr                       ;
     37AE FE1E     
11807                                                                          ; near as bad as the 250 damage from a missile slamming
11808                                                                          ; straight into us, but it's still pretty nasty
11809               
11810               TA87:
11811 37B0 0200  20        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     37B2 CB60     
11812 37B4 06A0  32        bl   @jsr                       ;
     37B6 FE1E     
11813                                                                          ; missile (so increase the kill tally, make an explosion
11814                                                                          ; sound and so on)
11815               
11816                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the missile's byte #31 flag to mark it as
     **** ****     > ASL
0001 37B8 D020  30        movb @INWK+31,rtmp
     37BA 0072     
0002 37BC 0240  22        andi rtmp,>ff00
     37BE FF00     
0003 37C0 0A10  18        sla  rtmp,1
0004 37C2 D800  30        movb rtmp,@INWK+31
     37C4 0072     
                   < elite.a99
11817                      .sec                            ; SEC               ; having been killed, so it explodes
     **** ****     > SEC
0001 37C6 0A18  18        sla  rmone,1
                   < elite.a99
11818 37C8 0204  20        li   rarg1,INWK+31              ; ROR INWK+31
     37CA 0072     
11819 37CC 06A0  32        bl   @ror                       ;
     37CE FE70     
11820               
11821               TA1:
11822 37D0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     37D2 FE2A     
11823               
11824               TA64:
11825                                                                          ; If we get here then the missile has not reached the
11826                                                                          ; target
11827 37D4 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     37D6 C07C     
11828 37D8 06A0  32        bl   @jsr                       ;
     37DA FE1E     
11829               
11830 37DC 028D  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 (94% chance), jump down to TA19 with the
     37DE 1000     
11831 37E0 186E  14        joc  TA19                       ; BCS TA19          ; vector from the target to the missile in K3
11832               
11833               M32:
11834 37E2 020F  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 for the target and shift bit 0 (E.C.M.)
     37E4 2000     
11835                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into the C flag
     **** ****     > LD_IND_Y_IDX
0001 37E6 D820  50        movb @V,@rtmplb
     37E8 0022     
     37EA 206D     
0002 37EC D020  30        movb @V+1,rtmp
     37EE 0023     
0003 37F0 A00F  18        a    ry,rtmp
0004 37F2 D350  26        movb *rtmp,RA
                   < elite.a99
11836 37F4 091D  18        srl  ra,1                       ; LSR A
11837               
11838 37F6 1763  14        jnc  TA19                       ; BCC TA19          ; If the C flag is clear then the target does not have
11839                                                                          ; E.C.M. fitted, so jump down to TA19 with the vector
11840                                                                          ; from the target to the missile in K3
11841               
11842 37F8 0460  28        b    @ECBLB2                    ; JMP ECBLB2        ; The target has E.C.M., so jump to ECBLB2 to set it
     37FA B0BE     
11843                                                                          ; off, returning from the subroutine using a tail call
11844               
11845               * ******************************************************************************
11846               *
11847               * Name: TACTICS (Part 2 of 7)
11848               * Type: Subroutine
11849               * Category: Tactics
11850               * Summary: Apply tactics: Escape pod, station, lone Thargon, safe-zone pirate
11851               * Deep dive: Program flow of the tactics routine
11852               *
11853               * ------------------------------------------------------------------------------
11854               *
11855               * This section contains the main entry point at TACTICS, which is called from
11856               * part 2 of MVEIT for ships that have the AI flag set (i.e. bit 7 of byte #32).
11857               * This part does the following:
11858               *
11859               * * If this is a missile, jump up to the missile code in part 1
11860               *
11861               * * If this is an escape pod, point it at the planet and jump to the
11862               * manoeuvring code in part 7
11863               *
11864               * * If this is the space station and it is hostile, consider spawning a cop
11865               * (45% chance, up to a maximum of four) and we're done
11866               *
11867               * * If this is a lone Thargon without a mothership, set it adrift aimlessly
11868               * and we're done
11869               *
11870               * * If this is a pirate and we are within the space station safe zone, stop
11871               * the pirate from attacking by removing all its aggression
11872               *
11873               * * Recharge the ship's energy banks by 1
11874               *
11875               * ------------------------------------------------------------------------------
11876               *
11877               * Arguments:
11878               *
11879               * X                   The ship type
11880               *
11881               * ******************************************************************************
11882               
11883               TACTICS:
11884 37FC 028E  22        ci   rx,(MSL)*256               ; CPX #MSL          ; If this is a missile, jump up to TA18 to implement
     37FE 0900     
11885 3800 1602  14        jne  FIX001                     ; BNE FIX001        ; missile tactics
11886 3802 0460  28        b    @TA18                      ; JMP TA18
     3804 36F4     
11887               FIX001:
11888 3806 028E  22        ci   rx,(ESC)*256               ; CPX #ESC          ; If this is not an escape pod, skip the following two
     3808 0D00     
11889 380A 1606  14        jne  B34                        ; BNE B34           ; instructions
11890               
11891 380C 0200  20        li   rtmp,SPS1                  ; JSR SPS1          ; This is an escape pod, so call SPS1 to calculate the
     380E C97A     
11892 3810 06A0  32        bl   @jsr                       ;
     3812 FE1E     
11893                                                                          ; vector to the planet and store it in XX15
11894               
11895 3814 0460  28        b    @TA15                      ; JMP TA15          ; Jump down to TA15
     3816 3A48     
11896               
11897               B34:
11898 3818 028E  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is not the space station, jump down to TA13
     381A 0800     
11899 381C 1612  14        jne  TA13                       ; BNE TA13
11900               
11901                                                                          ; We only call the tactics routine for the space station
11902                                                                          ; when it is hostile, so if we get here then this is the
11903                                                                          ; station, and we already know it's hostile, so we need
11904                                                                          ; to spawn some cops
11905               
11906 381E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3820 C07C     
11907 3822 06A0  32        bl   @jsr                       ;
     3824 FE1E     
11908               
11909 3826 028D  22        ci   ra,>8c*256                 ; CMP #140          ; If A < 140 (55% chance) then return from the
     3828 8C00     
11910 382A 1723  14        jnc  TA14-1                     ; BCC TA14-1        ; subroutine (as TA14-1 contains an RTS)
11911               
11912 382C D360  30        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; We only call the tactics routine for the space station
     382E 0D4F     
11913 3830 028D  22        ci   ra,>04*256                 ; CMP #4            ; when it is hostile, so first check the number of cops
     3832 0400     
11914 3834 181E  14        joc  TA14-1                     ; BCS TA14-1        ; in the vicinity, and if we already have 4 or more, we
11915                                                                          ; don't need to spawn any more, so return from the
11916                                                                          ; subroutine (as TA14-1 contains an RTS)
11917               
11918 3836 020E  20        li   rx,(COPS)*256              ; LDX #COPS         ; Set X to the ship type for a cop
     3838 0200     
11919               
11920 383A 020D  20        li   ra,>f1*256                 ; LDA #%11110001    ; Set the AI flag to give the ship E.C.M., enable AI and
     383C F100     
11921                                                                          ; make it very aggressive (60 out of 63)
11922               
11923 383E 0460  28        b    @SFS1                      ; JMP SFS1          ; Jump to SFS1 to spawn the ship, returning from the
     3840 3D02     
11924                                                                          ; subroutine using a tail call
11925               
11926               TA13:
11927 3842 028E  22        ci   rx,(TGL)*256               ; CPX #TGL          ; If this is not a Thargon, jump down to TA14
     3844 0C00     
11928 3846 1616  14        jne  TA14                       ; BNE TA14
11929               
11930 3848 D360  30        movb @MANY+THG,ra               ; LDA MANY+THG      ; If there is at least one Thargoid in the vicinity,
     384A 0D53     
11931 384C 1613  14        jne  TA14                       ; BNE TA14          ; jump down to TA14
11932               
11933                      .lsr @INWK+32                   ; LSR INWK+32       ; This is a Thargon but there is no Thargoid mothership,
     **** ****     > LSR
0001 384E D020  30        movb @INWK+32,rtmp
     3850 0073     
0002 3852 0910  18        srl  rtmp,1
0003 3854 D800  30        movb rtmp,@INWK+32
     3856 0073     
                   < elite.a99
11934                      .asl @INWK+32                   ; ASL INWK+32       ; so clear bit 0 of the AI flag to disable its E.C.M.
     **** ****     > ASL
0001 3858 D020  30        movb @INWK+32,rtmp
     385A 0073     
0002 385C 0240  22        andi rtmp,>ff00
     385E FF00     
0003 3860 0A10  18        sla  rtmp,1
0004 3862 D800  30        movb rtmp,@INWK+32
     3864 0073     
                   < elite.a99
11935               
11936                      .lsr @INWK+27                   ; LSR INWK+27       ; And halve the Thargon's speed
     **** ****     > LSR
0001 3866 D020  30        movb @INWK+27,rtmp
     3868 006E     
0002 386A 0910  18        srl  rtmp,1
0003 386C D800  30        movb rtmp,@INWK+27
     386E 006E     
                   < elite.a99
11937               
11938 3870 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3872 FE2A     
11939               
11940               TA14:
11941 3874 028E  22        ci   rx,(CYL)*256               ; CPX #CYL          ; If A >= #CYL, i.e. this is a Cobra Mk III trader (as
     3876 0700     
11942 3878 180C  14        joc  TA62                       ; BCS TA62          ; asteroids and cargo canisters never have AI), jump
11943                                                                          ; down to TA62
11944               
11945 387A 028E  22        ci   rx,(COPS)*256              ; CPX #COPS         ; If this is a cop, jump down to TA62
     387C 0200     
11946 387E 1309  14        jeq  TA62                       ; BEQ TA62
11947               
11948 3880 D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we aren't within range of the space station, jump
     3882 0D55     
11949 3884 1306  14        jeq  TA62                       ; BEQ TA62          ; down to TA62
11950               
11951 3886 D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; This is a pirate or bounty hunter, but we are inside
     3888 0073     
11952 388A 024D  22        andi ra,>81*256                 ; AND #%10000001    ; the space station's safe zone, so clear bits 1-6 of
     388C 8100     
11953 388E D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; the AI flag to stop it being hostile, because even
     3890 0073     
11954                                                                          ; pirates aren't crazy enough to breach the station's
11955                                                                          ; no-fire zone
11956               
11957               TA62:
11958 3892 020F  20        li   ry,>0e*256                 ; LDY #14           ; If the ship's energy is greater or equal to the
     3894 0E00     
11959 3896 D360  30        movb @INWK+35,ra                ; LDA INWK+35       ; maximum value from the ship's blueprint pointed to by
     3898 0076     
11960                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; XX0, then skip the next instruction
     **** ****     > CMP_IND_Y_IDX
0001 389A D820  50        movb @XX0,@rtmplb
     389C 001E     
     389E 206D     
0002 38A0 D020  30        movb @XX0+1,rtmp
     38A2 001F     
0003 38A4 A00F  18        a    ry,rtmp
0004 38A6 D010  26        movb *rtmp,rtmp
0005 38A8 900D  18        cb   ra,rtmp
                   < elite.a99
11961 38AA 1801  14        joc  TA21                       ; BCS TA21
11962               
11963 38AC B347  18        ab   rone,ra                    ; INC INWK+35       ; The ship's energy is not at maximum, so recharge the
11964                                                                          ; energy banks by 1
11965               
11966               * ******************************************************************************
11967               *
11968               * Name: TACTICS (Part 3 of 7)
11969               * Type: Subroutine
11970               * Category: Tactics
11971               * Summary: Apply tactics: Calculate dot product to determine ship's aim
11972               * Deep dive: Program flow of the tactics routine
11973               *
11974               * ------------------------------------------------------------------------------
11975               *
11976               * This section sets up some vectors and calculates dot products. Specifically:
11977               *
11978               * * Calculate the dot product of the ship's nose vector (i.e. the direction it
11979               * is pointing) with the vector between us and the ship. This value will help
11980               * us work out later on whether the enemy ship is pointing towards us, and
11981               * therefore whether it can hit us with its lasers.
11982               *
11983               * ******************************************************************************
11984               
11985               TA21:
11986 38AE 020E  20        li   rx,>08*256                 ; LDX #8            ; We now want to copy the ship's x, y and z coordinates
     38B0 0800     
11987                                                                          ; from INWK to K3, so set up a counter for 9 bytes
11988               
11989               TAL1:
11990 38B2 D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte from INWK to the X-th byte of K3
     38B4 0053     
11991 38B6 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X
     38B8 00D2     
11992               
11993 38BA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11994               
11995 38BC 15FA  14        jgt  TAL1                       ; BPL TAL1          ; Loop back until we have copied all 9 bytes
11996               
11997               TA19:
11998                                                                          ; If this is a missile that's heading for its target
11999                                                                          ; (not us, one of the other ships), then the missile
12000                                                                          ; routine at TA18 above jumps here after setting K3 to
12001                                                                          ; the vector from the target to the missile
12002 38BE 0200  20        li   rtmp,TAS2                  ; JSR TAS2          ; Normalise the vector in K3 and store the normalised
     38C0 C99E     
12003 38C2 06A0  32        bl   @jsr                       ;
     38C4 FE1E     
12004                                                                          ; version in XX15, so XX15 contains the normalised
12005                                                                          ; vector from our ship to the ship we are applying AI
12006                                                                          ; tactics to (or the normalised vector from the target
12007                                                                          ; to the missile - in both cases it's the vector from
12008                                                                          ; the potential victim to the attacker)
12009               
12010 38C6 020F  20        li   ry,>0a*256                 ; LDY #10           ; Set (A X) = nosev . XX15
     38C8 0A00     
12011 38CA 0200  20        li   rtmp,TAS3                  ; JSR TAS3
     38CC 4476     
12012 38CE 06A0  32        bl   @jsr                       ;
     38D0 FE1E     
12013               
12014 38D2 D80D  30        movb ra,@CNT                    ; STA CNT           ; Store the high byte of the dot product in CNT. The
     38D4 00A4     
12015                                                                          ; bigger the value, the more aligned the two ships are,
12016                                                                          ; with a maximum magnitude of 36 (96 * 96 >> 8). If CNT
12017                                                                          ; is positive, the ships are facing in a similar
12018                                                                          ; direction, if it's negative they are facing in
12019                                                                          ; opposite directions
12020               
12021               * ******************************************************************************
12022               *
12023               * Name: TACTICS (Part 4 of 7)
12024               * Type: Subroutine
12025               * Category: Tactics
12026               * Summary: Apply tactics: Check energy levels, maybe launch escape pod if low
12027               * Deep dive: Program flow of the tactics routine
12028               *
12029               * ------------------------------------------------------------------------------
12030               *
12031               * This section works out what kind of condition the ship is in. Specifically:
12032               *
12033               * * Rarely (2.5% chance) roll the ship by a noticeable amount
12034               *
12035               * * If the ship has at least half its energy banks full, jump to part 6 to
12036               * consider firing the lasers
12037               *
12038               * * If the ship is not into the last 1/8th of its energy, jump to part 5 to
12039               * consider firing a missile
12040               *
12041               * * If the ship is into the last 1/8th of its energy, then rarely (10% chance)
12042               * the ship launches an escape pod and is left drifting in space
12043               *
12044               * ******************************************************************************
12045               
12046 38D6 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is not a missile, skip the following
     38D8 009B     
12047 38DA 028D  22        ci   ra,(MSL)*256               ; CMP #MSL          ; instruction
     38DC 0900     
12048 38DE 1602  14        jne  B35                        ; BNE B35
12049               
12050 38E0 0460  28        b    @TA20                      ; JMP TA20          ; This is a missile, so jump down to TA20 to get
     38E2 3A10     
12051                                                                          ; straight into some aggressive manoeuvring
12052               
12053               B35:
12054 38E4 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     38E6 C07C     
12055 38E8 06A0  32        bl   @jsr                       ;
     38EA FE1E     
12056               
12057 38EC 028D  22        ci   ra,>fa*256                 ; CMP #250          ; If A < 250 (97.5% chance), jump down to TA7 to skip
     38EE FA00     
12058 38F0 1708  14        jnc  TA7                        ; BCC TA7           ; the following
12059               
12060 38F2 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     38F4 C07C     
12061 38F6 06A0  32        bl   @jsr                       ;
     38F8 FE1E     
12062               
12063 38FA 026D  22        ori  ra,>68*256                 ; ORA #104          ; Bump A up to at least 104 and store in the roll
     38FC 6800     
12064 38FE D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; counter, to gives the ship a noticeable roll
     3900 0070     
12065               
12066               TA7:
12067 3902 020F  20        li   ry,>0e*256                 ; LDY #14           ; Set A = the ship's maximum energy / 2
     3904 0E00     
12068                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 3906 D820  50        movb @XX0,@rtmplb
     3908 001E     
     390A 206D     
0002 390C D020  30        movb @XX0+1,rtmp
     390E 001F     
0003 3910 A00F  18        a    ry,rtmp
0004 3912 D350  26        movb *rtmp,RA
                   < elite.a99
12069 3914 091D  18        srl  ra,1                       ; LSR A
12070               
12071 3916 9360  30        cb   @INWK+35,ra                ; CMP INWK+35       ; If the ship's current energy in byte #35 > A, i.e. the
     3918 0076     
12072 391A 1738  14        jnc  TA3                        ; BCC TA3           ; ship has at least half of its energy banks charged,
12073                                                                          ; jump down to TA3
12074               
12075 391C 091D  18        srl  ra,1                       ; LSR A             ; If the ship's current energy in byte #35 > A / 4, i.e.
12076 391E 091D  18        srl  ra,1                       ; LSR A             ; the ship is not into the last 1/8th of its energy,
12077 3920 9360  30        cb   @INWK+35,ra                ; CMP INWK+35       ; jump down to ta3 to consider firing a missile
     3922 0076     
12078 3924 1712  14        jnc  ta3_                       ; BCC ta3
12079               
12080 3926 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3928 C07C     
12081 392A 06A0  32        bl   @jsr                       ;
     392C FE1E     
12082               
12083 392E 028D  22        ci   ra,>e6*256                 ; CMP #230          ; If A < 230 (90% chance), jump down to ta3 to consider
     3930 E600     
12084 3932 170B  14        jnc  ta3_                       ; BCC ta3           ; firing a missile
12085               
12086 3934 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is a Thargoid, jump down to ta3 to consider
     3936 009B     
12087 3938 028D  22        ci   ra,(THG)*256               ; CMP #THG          ; launching a Thargon
     393A 0600     
12088 393C 1306  14        jeq  ta3_                       ; BEQ ta3
12089               
12090                                                                          ; By this point, the ship has run out of both energy and
12091                                                                          ; luck, so it's time to bail
12092               
12093 393E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the AI flag to 0 to disable AI, hostility and
     3940 0000     
12094 3942 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; E.C.M., so the ship's a sitting duck
     3944 0073     
12095               
12096 3946 0460  28        b    @SESCP                     ; JMP SESCP         ; Jump to SESCP to spawn an escape pod from the ship,
     3948 3CFA     
12097                                                                          ; returning from the subroutine using a tail call
12098               
12099               * ******************************************************************************
12100               *
12101               * Name: TACTICS (Part 5 of 7)
12102               * Type: Subroutine
12103               * Category: Tactics
12104               * Summary: Apply tactics: Consider whether to launch a missile at us
12105               * Deep dive: Program flow of the tactics routine
12106               *
12107               * ------------------------------------------------------------------------------
12108               *
12109               * This section considers whether to launch a missile. Specifically:
12110               *
12111               * * If the ship doesn't have any missiles, skip to the next part
12112               *
12113               * * If an E.C.M. is firing, skip to the next part
12114               *
12115               * * Randomly decide whether to fire a missile (or, in the case of Thargoids,
12116               * release a Thargon), and if we do, we're done
12117               *
12118               * ******************************************************************************
12119               
12120               ta3_:
12121                                                                          ; If we get here then the ship has less than half energy
12122                                                                          ; so there may not be enough juice for lasers, but let's
12123                                                                          ; see if we can fire a missile
12124 394A D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set A = bits 0-2 of byte #31, the number of missiles
     394C 0072     
12125 394E 024D  22        andi ra,>07*256                 ; AND #%00000111    ; the ship has left
     3950 0700     
12126               
12127 3952 131C  14        jeq  TA3                        ; BEQ TA3           ; If it doesn't have any missiles, jump to TA3
12128               
12129 3954 D80D  30        movb ra,@T                      ; STA T             ; Store the number of missiles in T
     3956 00D1     
12130               
12131 3958 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     395A C07C     
12132 395C 06A0  32        bl   @jsr                       ;
     395E FE1E     
12133               
12134 3960 024D  22        andi ra,>1f*256                 ; AND #31           ; Restrict A to a random number in the range 0-31
     3962 1F00     
12135               
12136 3964 9360  30        cb   @T,ra                      ; CMP T             ; If A >= T, which is quite likely, though less likely
     3966 00D1     
12137 3968 1811  14        joc  TA3                        ; BCS TA3           ; with higher numbers of missiles, jump to TA3 to skip
12138                                                                          ; firing a missile
12139               
12140 396A D360  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     396C 0030     
12141 396E 160E  14        jne  TA3                        ; BNE TA3           ; opponent's), jump to TA3 to skip firing a missile
12142               
12143 3970 7347  18        sb   rone,ra                    ; DEC INWK+31       ; We're done with the checks, so it's time to fire off a
12144                                                                          ; missile, so reduce the missile count in byte #31 by 1
12145               
12146 3972 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type into A
     3974 009B     
12147               
12148 3976 028D  22        ci   ra,(THG)*256               ; CMP #THG          ; If this is not a Thargoid, jump down to TA16 to launch
     3978 0600     
12149 397A 1606  14        jne  TA16                       ; BNE TA16          ; a missile
12150               
12151 397C 020E  20        li   rx,(TGL)*256               ; LDX #TGL          ; This is a Thargoid, so instead of launching a missile,
     397E 0C00     
12152 3980 D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; the mothership launches a Thargon, so call SFS1 to
     3982 0073     
12153 3984 0460  28        b    @SFS1                      ; JMP SFS1          ; spawn a Thargon from the parent ship, and return from
     3986 3D02     
12154                                                                          ; the subroutine using a tail call
12155               
12156               TA16:
12157 3988 0460  28        b    @SFRMIS                    ; JMP SFRMIS        ; Jump to SFRMIS to spawn a missile as a child of the
     398A CB40     
12158                                                                          ; current ship, make a noise and print a message warning
12159                                                                          ; of incoming missiles, and return from the subroutine
12160                                                                          ; using a tail call
12161               
12162               * ******************************************************************************
12163               *
12164               * Name: TACTICS (Part 6 of 7)
12165               * Type: Subroutine
12166               * Category: Tactics
12167               * Summary: Apply tactics: Consider firing a laser at us, if aim is true
12168               * Deep dive: Program flow of the tactics routine
12169               *
12170               * ------------------------------------------------------------------------------
12171               *
12172               * This section looks at potentially firing the ship's laser at us. Specifically:
12173               *
12174               * * If the ship is not pointing at us, skip to the next part
12175               *
12176               * * If the ship is pointing at us but not accurately, fire its laser at us and
12177               * skip to the next part
12178               *
12179               * * If we are in the ship's crosshairs, register some damage to our ship, slow
12180               * down the attacking ship, make the noise of us being hit by laser fire, and
12181               * we're done
12182               *
12183               * ******************************************************************************
12184               
12185               TA3:
12186                                                                          ; If we get here then the ship either has plenty of
12187                                                                          ; energy, or levels are low but it couldn't manage to
12188                                                                          ; launch a missile, so maybe we can fire the laser?
12189 398C 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     398E 0000     
12190 3990 0200  20        li   rtmp,MAS4                  ; JSR MAS4
     3992 C46E     
12191 3994 06A0  32        bl   @jsr                       ;
     3996 FE1E     
12192               
12193 3998 024D  22        andi ra,>e0*256                 ; AND #%11100000    ; If any of the hi bytes have any of bits 5-7 set, then
     399A E000     
12194 399C 1624  14        jne  TA4                        ; BNE TA4           ; jump to TA4 to skip the laser checks, as the ship is
12195                                                                          ; too far away from us to hit us with a laser
12196               
12197 399E D3A0  30        movb @CNT,rx                    ; LDX CNT           ; Set X = the dot product set above in CNT. If this is
     39A0 00A4     
12198                                                                          ; positive, this ship and our ship are facing in similar
12199                                                                          ; directions, but if it's negative then we are facing
12200                                                                          ; each other, so for us to be in the enemy ship's line
12201                                                                          ; of fire, X needs to be negative. The value in X can
12202                                                                          ; have a maximum magnitude of 36, which would mean we
12203                                                                          ; were facing each other square on, so in the following
12204                                                                          ; code we check X like this:
12205                                                                          ;
12206                                                                          ; X = 0 to -31, we are not in the enemy ship's line
12207                                                                          ; of fire, so they can't shoot at us
12208                                                                          ;
12209                                                                          ; X = -32 to -34, we are in the enemy ship's line
12210                                                                          ; of fire, so they can shoot at us, but they can't
12211                                                                          ; hit us as we're not dead in their crosshairs
12212                                                                          ;
12213                                                                          ; X = -35 to -36, we are bang in the middle of the
12214                                                                          ; enemy ship's crosshairs, so they can not only
12215                                                                          ; shoot us, they can hit us
12216               
12217 39A2 028E  22        ci   rx,>a0*256                 ; CPX #160          ; If X < 160, i.e. X > -32, then we are not in the enemy
     39A4 A000     
12218 39A6 171F  14        jnc  TA4                        ; BCC TA4           ; ship's line of fire, so jump to TA4 to skip the laser
12219                                                                          ; checks
12220               
12221 39A8 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 in byte #31 to denote that the ship is
     39AA 0072     
12222 39AC 026D  22        ori  ra,>40*256                 ; ORA #%01000000    ; firing its laser at us
     39AE 4000     
12223 39B0 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     39B2 0072     
12224               
12225 39B4 028E  22        ci   rx,>a3*256                 ; CPX #163          ; If X < 163, i.e. X > -35, then we are not in the enemy
     39B6 A300     
12226 39B8 1716  14        jnc  TA4                        ; BCC TA4           ; ship's crosshairs, so jump to TA4 to skip the laser
12227                                                                          ; checks
12228               
12229               HIT:
12230 39BA 020F  20        li   ry,>13*256                 ; LDY #19           ; We are being hit by enemy laser fire, so fetch the
     39BC 1300     
12231                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; enemy ship's byte #19 from their ship's blueprint
     **** ****     > LD_IND_Y_IDX
0001 39BE D820  50        movb @XX0,@rtmplb
     39C0 001E     
     39C2 206D     
0002 39C4 D020  30        movb @XX0+1,rtmp
     39C6 001F     
0003 39C8 A00F  18        a    ry,rtmp
0004 39CA D350  26        movb *rtmp,RA
                   < elite.a99
12232                                                                          ; into A
12233               
12234 39CC 091D  18        srl  ra,1                       ; LSR A             ; Halve the enemy ship's byte #19 (which contains both
12235                                                                          ; the laser power and number of missiles) to get the
12236                                                                          ; amount of damage we should take
12237               
12238 39CE 0200  20        li   rtmp,OOPS                  ; JSR OOPS          ; Call OOPS to take some damage, which could do anything
     39D0 AE76     
12239 39D2 06A0  32        bl   @jsr                       ;
     39D4 FE1E     
12240                                                                          ; from reducing the shields and energy, all the way to
12241                                                                          ; losing cargo or dying (if the latter, we don't come
12242                                                                          ; back from this subroutine)
12243               
12244 39D6 7347  18        sb   rone,ra                    ; DEC INWK+28       ; Halve the attacking ship's acceleration in byte #28
12245               
12246 39D8 D360  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     39DA 0030     
12247 39DC 1678  14        jne  TA10                       ; BNE TA10          ; opponent's), return from the subroutine without making
12248                                                                          ; the laser-strike sound (as TA10 contains an RTS)
12249               
12250 39DE 020D  20        li   ra,>08*256                 ; LDA #8            ; Call the NOISE routine with A = 8 to make the sound
     39E0 0800     
12251 39E2 0460  28        b    @NOISE                     ; JMP NOISE         ; of us being hit by lasers, returning from the
     39E4 CBB0     
12252                                                                          ; subroutine using a tail call
12253               
12254               * ******************************************************************************
12255               *
12256               * Name: TACTICS (Part 7 of 7)
12257               * Type: Subroutine
12258               * Category: Tactics
12259               * Summary: Apply tactics: Set pitch, roll, and acceleration
12260               * Deep dive: Program flow of the tactics routine
12261               *
12262               * ------------------------------------------------------------------------------
12263               *
12264               * This section looks at manoeuvring the ship. Specifically:
12265               *
12266               * * Work out which direction the ship should be moving, depending on whether
12267               * it's an escape pod, where it is, which direction it is pointing, and how
12268               * aggressive it is
12269               *
12270               * * Set the pitch and roll counters to head in that direction
12271               *
12272               * * Speed up or slow down, depending on where the ship is in relation to us
12273               *
12274               * ******************************************************************************
12275               
12276               TA4:
12277 39E6 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi >= 3 then the ship is quite far away, so jump
     39E8 005A     
12278 39EA 028D  22        ci   ra,>03*256                 ; CMP #3            ; down to TA5
     39EC 0300     
12279 39EE 1807  14        joc  TA5                        ; BCS TA5
12280               
12281 39F0 D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Otherwise set A = x_hi OR y_hi and extract bits 1-7
     39F2 0054     
12282 39F4 F360  30        socb @INWK+4,ra                 ; ORA INWK+4
     39F6 0057     
12283 39F8 024D  22        andi ra,>fe*256                 ; AND #%11111110
     39FA FE00     
12284               
12285 39FC 1325  14        jeq  TA15                       ; BEQ TA15          ; If A = 0 then the ship is pretty close to us, so jump
12286                                                                          ; to TA15 so it heads away from us
12287               
12288               TA5:
12289                                                                          ; If we get here then the ship is quite far away
12290 39FE 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3A00 C07C     
12291 3A02 06A0  32        bl   @jsr                       ;
     3A04 FE1E     
12292               
12293 3A06 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A, so A is at least 128
     3A08 8000     
12294               
12295 3A0A 9360  30        cb   @INWK+32,ra                ; CMP INWK+32       ; If A >= byte #32 (the ship's AI flag) then jump down
     3A0C 0073     
12296 3A0E 181C  14        joc  TA15                       ; BCS TA15          ; to TA15 so it heads away from us
12297               
12298                                                                          ; We get here if A < byte #32, and the chances of this
12299                                                                          ; being true are greater with high values of byte #32,
12300                                                                          ; as long as they are at least 128
12301                                                                          ;
12302                                                                          ; In other words, higher byte #32 values increase the
12303                                                                          ; chances of a ship changing direction to head towards
12304                                                                          ; us - or, to put it another way, ships with higher
12305                                                                          ; byte #32 values of 128 or more are spoiling for a
12306                                                                          ; fight
12307                                                                          ;
12308                                                                          ; Thargoids have byte #32 set to 255, which explains
12309                                                                          ; an awful lot
12310               
12311               TA20:
12312                                                                          ; If this is a missile we will have jumped straight
12313                                                                          ; here, but we also get here if the ship is either far
12314                                                                          ; away and aggressive, or not too close
12315 3A10 D360  30        movb @XX15,ra                   ; LDA XX15          ; Reverse the signs of XX15 and the dot product in CNT,
     3A12 0031     
12316                      .eoi (>80*256)                  ; EOR #%10000000    ; starting with the x-coordinate
     **** ****     > EOI
0001 3A14 0200  20        li   rtmp,(>80*256)
     3A16 8000     
0002 3A18 2B40  18        xor  rtmp,ra
                   < elite.a99
12317 3A1A D80D  30        movb ra,@XX15                   ; STA XX15
     3A1C 0031     
12318               
12319 3A1E D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Then reverse the sign of the y-coordinate
     3A20 0032     
12320                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 3A22 0200  20        li   rtmp,(>80*256)
     3A24 8000     
0002 3A26 2B40  18        xor  rtmp,ra
                   < elite.a99
12321 3A28 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     3A2A 0032     
12322               
12323 3A2C D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And then the z-coordinate, so now the XX15 vector goes
     3A2E 0033     
12324                      .eoi (>80*256)                  ; EOR #%10000000    ; from the enemy ship to our ship (it was previously the
     **** ****     > EOI
0001 3A30 0200  20        li   rtmp,(>80*256)
     3A32 8000     
0002 3A34 2B40  18        xor  rtmp,ra
                   < elite.a99
12325 3A36 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; other way round)
     3A38 0033     
12326               
12327 3A3A D360  30        movb @CNT,ra                    ; LDA CNT           ; And finally change the sign of the dot product in CNT,
     3A3C 00A4     
12328                      .eoi (>80*256)                  ; EOR #%10000000    ; so now it's positive if the ships are facing each
     **** ****     > EOI
0001 3A3E 0200  20        li   rtmp,(>80*256)
     3A40 8000     
0002 3A42 2B40  18        xor  rtmp,ra
                   < elite.a99
12329 3A44 D80D  30        movb ra,@CNT                    ; STA CNT           ; other, and negative if they are facing the same way
     3A46 00A4     
12330               
12331               TA15:
12332                                                                          ; If we get here, then one of the following is true:
12333                                                                          ;
12334                                                                          ; * This is an escape pod and XX15 is pointing towards
12335                                                                          ; the planet
12336                                                                          ;
12337                                                                          ; * The ship is pretty close to us, or it's just not
12338                                                                          ; very aggressive (though there is a random factor
12339                                                                          ; at play here too). XX15 is still pointing from our
12340                                                                          ; ship towards the enemy ship
12341                                                                          ;
12342                                                                          ; * The ship is aggressive (though again, there's an
12343                                                                          ; element of randomness here). XX15 is pointing from
12344                                                                          ; the enemy ship towards our ship
12345                                                                          ;
12346                                                                          ; * This is a missile heading for a target. XX15 is
12347                                                                          ; pointing from the missile towards the target
12348                                                                          ;
12349                                                                          ; We now want to move the ship in the direction of XX15,
12350                                                                          ; which will make aggressive ships head towards us, and
12351                                                                          ; ships that are too close turn away. Escape pods,
12352                                                                          ; meanwhile, head off towards the planet in search of a
12353                                                                          ; space station, and missiles home in on their targets
12354 3A48 020F  20        li   ry,>10*256                 ; LDY #16           ; Set (A X) = roofv . XX15
     3A4A 1000     
12355 3A4C 0200  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3A4E 4476     
12356 3A50 06A0  32        bl   @jsr                       ;
     3A52 FE1E     
12357                                                                          ; This will be positive if XX15 is pointing in the same
12358                                                                          ; direction as an arrow out of the top of the ship, in
12359                                                                          ; other words if the ship should pull up to head in the
12360                                                                          ; direction of XX15
12361               
12362                      .eoi (>80*256)                  ; EOR #%10000000    ; Set the ship's pitch counter to 3, with the opposite
     **** ****     > EOI
0001 3A54 0200  20        li   rtmp,(>80*256)
     3A56 8000     
0002 3A58 2B40  18        xor  rtmp,ra
                   < elite.a99
12363 3A5A 024D  22        andi ra,>80*256                 ; AND #%10000000    ; sign to the dot product result, which gently pitches
     3A5C 8000     
12364 3A5E 026D  22        ori  ra,>03*256                 ; ORA #%00000011    ; the ship towards the direction of the XX15 vector
     3A60 0300     
12365 3A62 D80D  30        movb ra,@INWK+30                ; STA INWK+30
     3A64 0071     
12366               
12367 3A66 D360  30        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the roll counter from byte #29 into A and clear
     3A68 0070     
12368 3A6A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; the sign bit (to give an endless clockwise roll)
     3A6C 7F00     
12369               
12370 3A6E 028D  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 then jump to TA6, as the ship is already
     3A70 1000     
12371 3A72 1810  14        joc  TA6                        ; BCS TA6           ; in the process of rolling
12372               
12373 3A74 020F  20        li   ry,>16*256                 ; LDY #22           ; Set (A X) = sidev . XX15
     3A76 1600     
12374 3A78 0200  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3A7A 4476     
12375 3A7C 06A0  32        bl   @jsr                       ;
     3A7E FE1E     
12376                                                                          ; This will be positive if XX15 is pointing in the same
12377                                                                          ; direction as an arrow out of the right side of the
12378                                                                          ; ship, in other words if the ship should roll right to
12379                                                                          ; head in the direction of XX15
12380               
12381                      .eor @INWK+30                   ; EOR INWK+30       ; Set the ship's roll counter to 5, with the sign set to
     **** ****     > EOR
0001 3A80 D020  30        movb @INWK+30,rtmp
     3A82 0071     
0002 3A84 2B40  18        xor  rtmp,ra
                   < elite.a99
12382 3A86 024D  22        andi ra,>80*256                 ; AND #%10000000    ; positive (clockwise roll) if the pitch counter and dot
     3A88 8000     
12383                      .eoi (>85*256)                  ; EOR #%10000101    ; product have different signs, negative (anti-clockwise
     **** ****     > EOI
0001 3A8A 0200  20        li   rtmp,(>85*256)
     3A8C 8500     
0002 3A8E 2B40  18        xor  rtmp,ra
                   < elite.a99
12384 3A90 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; roll) if they have the same sign
     3A92 0070     
12385               
12386               TA6:
12387 3A94 D360  30        movb @CNT,ra                    ; LDA CNT           ; Fetch the dot product, and if it's negative jump to
     3A96 00A4     
12388 3A98 1109  14        jlt  TA9                        ; BMI TA9           ; TA9, as the ships are facing away from each other and
12389                                                                          ; the ship might want to slow down to take another shot
12390               
12391 3A9A 028D  22        ci   ra,>16*256                 ; CMP #22           ; The dot product is positive, so the ships are facing
     3A9C 1600     
12392 3A9E 1706  14        jnc  TA9                        ; BCC TA9           ; each other. If A < 22 then the ships are not heading
12393                                                                          ; directly towards each other, so jump to TA9 to slow
12394                                                                          ; down
12395               
12396 3AA0 020D  20        li   ra,>03*256                 ; LDA #3            ; Otherwise set the acceleration in byte #28 to 3
     3AA2 0300     
12397 3AA4 D80D  30        movb ra,@INWK+28                ; STA INWK+28
     3AA6 006F     
12398               
12399 3AA8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3AAA FE2A     
12400               
12401               TA9:
12402 3AAC 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of the dot product in A
     3AAE 7F00     
12403               
12404 3AB0 028D  22        ci   ra,>12*256                 ; CMP #18           ; If A < 18 then the ship is way off the XX15 vector, so
     3AB2 1200     
12405 3AB4 170C  14        jnc  TA10                       ; BCC TA10          ; return from the subroutine (TA10 contains an RTS)
12406                                                                          ; without slowing down, as it still has quite a bit of
12407                                                                          ; turning to do to get on course
12408               
12409 3AB6 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Otherwise set A = -1
     3AB8 FF00     
12410               
12411 3ABA D3A0  30        movb @TYPE,rx                   ; LDX TYPE          ; If this is not a missile then skip the ASL instruction
     3ABC 009B     
12412 3ABE 028E  22        ci   rx,(MSL)*256               ; CPX #MSL
     3AC0 0900     
12413 3AC2 1603  14        jne  B36                        ; BNE B36
12414               
12415                      .asla                           ; ASL A             ; This is a missile, so set A = -2, as missiles are more
     **** ****     > ASLA
0001 3AC4 024D  22        andi ra,>ff00
     3AC6 FF00     
0002 3AC8 0A1D  18        sla  ra,1
                   < elite.a99
12416                                                                          ; nimble and can brake more quickly
12417               
12418               B36:
12419 3ACA D80D  30        movb ra,@INWK+28                ; STA INWK+28       ; Set the ship's acceleration to A
     3ACC 006F     
12420               
12421               TA10:
12422 3ACE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3AD0 FE2A     
12423               
12424               * ******************************************************************************
12425               *
12426               * Name: TAS1
12427               * Type: Subroutine
12428               * Category: Maths (Arithmetic)
12429               * Summary: Calculate K3 = (x_sign x_hi x_lo) - V(1 0)
12430               *
12431               * ------------------------------------------------------------------------------
12432               *
12433               * Calculate one of the following, depending on the value in Y:
12434               *
12435               * K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in V(1 0)
12436               *
12437               * K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in V(1 0)
12438               *
12439               * K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in V(1 0)
12440               *
12441               * where the first coordinate is from the ship data block in INWK, and the second
12442               * coordinate is from the ship data block pointed to by V(1 0).
12443               *
12444               * ------------------------------------------------------------------------------
12445               *
12446               * Arguments:
12447               *
12448               * V(1 0)              The address of the ship data block to subtract
12449               *
12450               * Y                   The coordinate in the V(1 0) block to subtract:
12451               *
12452               * * If Y = 2, subtract the x-coordinate and store the
12453               * result in K3(2 1 0)
12454               *
12455               * * If Y = 5, subtract the y-coordinate and store the
12456               * result in K3(5 4 3)
12457               *
12458               * * If Y = 8, subtract the z-coordinate and store the
12459               * result in K3(8 7 6)
12460               *
12461               * ******************************************************************************
12462               
12463               TAS1:
12464                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Copy the sign byte of the V(1 0) coordinate into K+3,
     **** ****     > LD_IND_Y_IDX
0001 3AD2 D820  50        movb @V,@rtmplb
     3AD4 0022     
     3AD6 206D     
0002 3AD8 D020  30        movb @V+1,rtmp
     3ADA 0023     
0003 3ADC A00F  18        a    ry,rtmp
0004 3ADE D350  26        movb *rtmp,RA
                   < elite.a99
12465                      .eoi (>80*256)                  ; EOR #%10000000    ; flipping it in the process
     **** ****     > EOI
0001 3AE0 0200  20        li   rtmp,(>80*256)
     3AE2 8000     
0002 3AE4 2B40  18        xor  rtmp,ra
                   < elite.a99
12466 3AE6 D80D  30        movb ra,@K+3                    ; STA K+3
     3AE8 0040     
12467               
12468 3AEA 73C7  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+2
12469                      .ld_ind_y_idx @V,ra             ; LDA (V),Y
     **** ****     > LD_IND_Y_IDX
0001 3AEC D820  50        movb @V,@rtmplb
     3AEE 0022     
     3AF0 206D     
0002 3AF2 D020  30        movb @V+1,rtmp
     3AF4 0023     
0003 3AF6 A00F  18        a    ry,rtmp
0004 3AF8 D350  26        movb *rtmp,RA
                   < elite.a99
12470 3AFA D80D  30        movb ra,@K+2                    ; STA K+2
     3AFC 003F     
12471               
12472 3AFE 73C7  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+1,
12473                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; so now:
     **** ****     > LD_IND_Y_IDX
0001 3B00 D820  50        movb @V,@rtmplb
     3B02 0022     
     3B04 206D     
0002 3B06 D020  30        movb @V+1,rtmp
     3B08 0023     
0003 3B0A A00F  18        a    ry,rtmp
0004 3B0C D350  26        movb *rtmp,RA
                   < elite.a99
12474 3B0E D80D  30        movb ra,@K+1                    ; STA K+1           ;
     3B10 003E     
12475                                                                          ; K(3 2 1) = - coordinate in V(1 0)
12476               
12477 3B12 D80F  30        movb ry,@U                      ; STY U             ; Copy the index (now 0, 3 or 6) into U and X
     3B14 008F     
12478 3B16 D3A0  30        movb @U,rx                      ; LDX U
     3B18 008F     
12479               
12480 3B1A 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; Call MVT3 to add the same coordinates, but this time
     3B1C 1C88     
12481 3B1E 06A0  32        bl   @jsr                       ;
     3B20 FE1E     
12482                                                                          ; from INWK, so this would look like this for the
12483                                                                          ; x-axis:
12484                                                                          ;
12485                                                                          ; K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
12486                                                                          ; = (x_sign x_hi x_lo) - coordinate in V(1 0)
12487               
12488 3B22 D3E0  30        movb @U,ry                      ; LDY U             ; Restore the index into Y, though this instruction has
     3B24 008F     
12489                                                                          ; no effect, as Y is not used again, either here or
12490                                                                          ; following calls to this routine
12491               
12492 3B26 DB8D  38        movb ra,@K3+2(rx)               ; STA K3+2,X        ; Store K(3 2 1) in K3+X(2 1 0), starting with the sign
     3B28 00D4     
12493                                                                          ; byte
12494               
12495 3B2A D360  30        movb @K+2,ra                    ; LDA K+2           ; And then doing the high byte
     3B2C 003F     
12496 3B2E DB8D  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     3B30 00D3     
12497               
12498 3B32 D360  30        movb @K+1,ra                    ; LDA K+1           ; And finally the low byte
     3B34 003E     
12499 3B36 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X
     3B38 00D2     
12500               
12501 3B3A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3B3C FE2A     
12502               
12503               * ******************************************************************************
12504               *
12505               * Name: HITCH
12506               * Type: Subroutine
12507               * Category: Tactics
12508               * Summary: Work out if the ship in INWK is in our crosshairs
12509               * Deep dive: In the crosshairs
12510               *
12511               * ------------------------------------------------------------------------------
12512               *
12513               * This is called by the main flight loop to see if we have laser or missile lock
12514               * on an enemy ship.
12515               *
12516               * ------------------------------------------------------------------------------
12517               *
12518               * Returns:
12519               *
12520               * C flag              Set if the ship is in our crosshairs, clear if it isn't
12521               *
12522               * ------------------------------------------------------------------------------
12523               *
12524               * Other entry points:
12525               *
12526               * HI1                 Contains an RTS
12527               *
12528               * ******************************************************************************
12529               
12530               HITCH:
12531                      .clc                            ; CLC               ; Clear the C flag so we can return with it cleared if
     **** ****     > CLC
0001 3B3E 0A16  18        sla  rzero,1
                   < elite.a99
12532                                                                          ; our checks fail
12533               
12534 3B40 D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign
     3B42 005B     
12535               
12536 3B44 1647  14        jne  HI1                        ; BNE HI1           ; If A is non-zero then the ship is behind us and can't
12537                                                                          ; be in our crosshairs, so return from the subroutine
12538                                                                          ; with the C flag clear (as HI1 contains an RTS)
12539               
12540 3B46 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type has bit 7 set then it is the planet
     3B48 009B     
12541 3B4A 1144  14        jlt  HI1                        ; BMI HI1           ; or sun, which we can't target or hit with lasers, so
12542                                                                          ; return from the subroutine with the C flag clear (as
12543                                                                          ; HI1 contains an RTS)
12544               
12545 3B4C D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch bit 5 of byte #31 (the exploding flag) and OR
     3B4E 0072     
12546 3B50 024D  22        andi ra,>20*256                 ; AND #%00100000    ; with x_hi and y_hi
     3B52 2000     
12547 3B54 F360  30        socb @INWK+1,ra                 ; ORA INWK+1
     3B56 0054     
12548 3B58 F360  30        socb @INWK+4,ra                 ; ORA INWK+4
     3B5A 0057     
12549               
12550 3B5C 163B  14        jne  HI1                        ; BNE HI1           ; If this value is non-zero then either the ship is
12551                                                                          ; exploding (so we can't target it), or the ship is too
12552                                                                          ; far away from our line of fire to be targeted, so
12553                                                                          ; return from the subroutine with the C flag clear (as
12554                                                                          ; HI1 contains an RTS)
12555               
12556 3B5E D360  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo
     3B60 0053     
12557               
12558 3B62 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = x_lo^2
     3B64 42BA     
12559 3B66 06A0  32        bl   @jsr                       ;
     3B68 FE1E     
12560               
12561 3B6A D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2
     3B6C 0092     
12562 3B6E D360  30        movb @P,ra                      ; LDA P
     3B70 001B     
12563 3B72 D80D  30        movb ra,@R                      ; STA R
     3B74 0091     
12564               
12565 3B76 D360  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set A = y_lo
     3B78 0056     
12566               
12567 3B7A 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = y_lo^2
     3B7C 42BA     
12568 3B7E 06A0  32        bl   @jsr                       ;
     3B80 FE1E     
12569               
12570 3B82 D38D  18        movb ra,rx                      ; TAX               ; Store the high byte in X
12571               
12572 3B84 D360  30        movb @P,ra                      ; LDA P             ; Add the two low bytes, so:
     3B86 001B     
12573                      .adc @R,ra                      ; ADC R             ;
     **** ****     > ADC
0001 3B88 1701  14        jnc  !
0002 3B8A B347  18        ab   rone,ra
0003               !:
0004 3B8C B360  30        ab   @R,ra
     3B8E 0091     
                   < elite.a99
12574 3B90 D80D  30        movb ra,@R                      ; STA R             ; R = P + R
     3B92 0091     
12575               
12576 3B94 D34E  18        movb rx,ra                      ; TXA               ; Restore the high byte into A and add S to give the
12577                      .adc @S,ra                      ; ADC S             ; following:
     **** ****     > ADC
0001 3B96 1701  14        jnc  !
0002 3B98 B347  18        ab   rone,ra
0003               !:
0004 3B9A B360  30        ab   @S,ra
     3B9C 0092     
                   < elite.a99
12578                                                                          ;
12579                                                                          ; (A R) = (S R) + (A P) = x_lo^2 + y_lo^2
12580               
12581 3B9E 1702  14        jnc  FIX002                     ; BCC FIX002        ; If the addition just overflowed then there is no way
12582                                                                          ; our crosshairs are within the ship's targetable area,
12583                                                                          ; so return from the subroutine with the C flag clear
12584                                                                          ; (as FR1-2 contains a CLC then an RTS)
12585 3BA0 0460  28        b    @FR1-2                     ; JMP FR1-2
     3BA2 3CF0     
12586               FIX002:
12587 3BA4 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2 + y_lo^2
     3BA6 0092     
12588               
12589 3BA8 020F  20        li   ry,>02*256                 ; LDY #2            ; Fetch the ship's blueprint and set A to the high byte
     3BAA 0200     
12590                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; of the targetable area of the ship
     **** ****     > LD_IND_Y_IDX
0001 3BAC D820  50        movb @XX0,@rtmplb
     3BAE 001E     
     3BB0 206D     
0002 3BB2 D020  30        movb @XX0+1,rtmp
     3BB4 001F     
0003 3BB6 A00F  18        a    ry,rtmp
0004 3BB8 D350  26        movb *rtmp,RA
                   < elite.a99
12591               
12592 3BBA 9360  30        cb   @S,ra                      ; CMP S             ; We now compare the high bytes of the targetable area
     3BBC 0092     
12593                                                                          ; and the calculation in (S R):
12594                                                                          ;
12595                                                                          ; * If A >= S then then the C flag will be set
12596                                                                          ;
12597                                                                          ; * If A < S then the C flag will be C clear
12598               
12599 3BBE 160A  14        jne  HI1                        ; BNE HI1           ; If A <> S we have just set the C flag correctly, so
12600                                                                          ; return from the subroutine (as HI1 contains an RTS)
12601               
12602 3BC0 73C7  18        sb   rone,ry                    ; DEY               ; The high bytes were identical, so now we fetch the
12603                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the targetable area into A
     **** ****     > LD_IND_Y_IDX
0001 3BC2 D820  50        movb @XX0,@rtmplb
     3BC4 001E     
     3BC6 206D     
0002 3BC8 D020  30        movb @XX0+1,rtmp
     3BCA 001F     
0003 3BCC A00F  18        a    ry,rtmp
0004 3BCE D350  26        movb *rtmp,RA
                   < elite.a99
12604               
12605 3BD0 9360  30        cb   @R,ra                      ; CMP R             ; We now compare the low bytes of the targetable area
     3BD2 0091     
12606                                                                          ; and the calculation in (S R):
12607                                                                          ;
12608                                                                          ; * If A >= R then the C flag will be set
12609                                                                          ;
12610                                                                          ; * If A < R then the C flag will be C clear
12611               
12612               HI1:
12613 3BD4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3BD6 FE2A     
12614               
12615               * ******************************************************************************
12616               *
12617               * Name: FRS1
12618               * Type: Subroutine
12619               * Category: Tactics
12620               * Summary: Launch a ship straight ahead of us, below the laser sights
12621               *
12622               * ------------------------------------------------------------------------------
12623               *
12624               * This is used in two places:
12625               *
12626               * * When we launch a missile, in which case the missile is the ship that is
12627               * launched ahead of us
12628               *
12629               * * When we launch our escape pod, in which case it's our abandoned Cobra Mk
12630               * III that is launched ahead of us
12631               *
12632               * * The fq1 entry point is used to launch a bunch of cargo canisters ahead of
12633               * us as part of the death screen
12634               *
12635               * ------------------------------------------------------------------------------
12636               *
12637               * Arguments:
12638               *
12639               * X                   The type of ship to launch ahead of us
12640               *
12641               * ------------------------------------------------------------------------------
12642               *
12643               * Returns:
12644               *
12645               * C flag              Set if the ship was successfully launched, clear if it
12646               * wasn't (as there wasn't enough free memory)
12647               *
12648               * ------------------------------------------------------------------------------
12649               *
12650               * Other entry points:
12651               *
12652               * fq1                 Used to add a cargo canister to the universe
12653               *
12654               * ******************************************************************************
12655               
12656               FRS1:
12657 3BD8 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     3BDA BFC0     
12658 3BDC 06A0  32        bl   @jsr                       ;
     3BDE FE1E     
12659               
12660 3BE0 020D  20        li   ra,>1c*256                 ; LDA #28           ; Set y_lo = 28
     3BE2 1C00     
12661 3BE4 D80D  30        movb ra,@INWK+3                 ; STA INWK+3
     3BE6 0056     
12662               
12663 3BE8 091D  18        srl  ra,1                       ; LSR A             ; Set z_lo = 14, so the launched ship starts out
12664 3BEA D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; ahead of us
     3BEC 0059     
12665               
12666 3BEE 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set y_sign to be negative, so the launched ship is
     3BF0 8000     
12667 3BF2 D80D  30        movb ra,@INWK+5                 ; STA INWK+5        ; launched just below our line of sight
     3BF4 0058     
12668               
12669 3BF6 D360  30        movb @MSTG,ra                   ; LDA MSTG          ; Set A to the missile lock target, shifted left so the
     3BF8 0052     
12670                      .asla                           ; ASL A             ; slot number is in bits 1-5
     **** ****     > ASLA
0001 3BFA 024D  22        andi ra,>ff00
     3BFC FF00     
0002 3BFE 0A1D  18        sla  ra,1
                   < elite.a99
12671               
12672 3C00 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 and store the result in byte #32, the AI
     3C02 8000     
12673 3C04 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; flag launched ship for the launched ship. For missiles
     3C06 0073     
12674                                                                          ; this enables AI (bit 7), makes it friendly towards us
12675                                                                          ; (bit 6), sets the target to the value of MSTG (bits
12676                                                                          ; 1-5), and sets its lock status as launched (bit 0).
12677                                                                          ; It doesn't matter what it does for our abandoned
12678                                                                          ; Cobra, as the AI flag gets overwritten once we return
12679                                                                          ; from the subroutine back to the ESCAPE routine that
12680                                                                          ; called FRS1 in the first place
12681               
12682               fq1_:
12683 3C08 020D  20        li   ra,>60*256                 ; LDA #&60          ; Set byte #14 (nosev_z_hi) to 1 (&60), so the launched
     3C0A 6000     
12684 3C0C D80D  30        movb ra,@INWK+14                ; STA INWK+14       ; ship is pointing away from us
     3C0E 0061     
12685               
12686 3C10 026D  22        ori  ra,>80*256                 ; ORA #128          ; Set byte #22 (sidev_x_hi) to -1 (&D0), so the launched
     3C12 8000     
12687 3C14 D80D  30        movb ra,@INWK+22                ; STA INWK+22       ; ship has the same orientation as spawned ships, just
     3C16 0069     
12688                                                                          ; pointing away from us (if we set sidev to +1 instead,
12689                                                                          ; this ship would be a mirror image of all the other
12690                                                                          ; ships, which are spawned with -1 in nosev and +1 in
12691                                                                          ; sidev)
12692               
12693 3C18 D360  30        movb @DELTA,ra                  ; LDA DELTA         ; Set byte #27 (speed) to 2 * DELTA, so the launched
     3C1A 008C     
12694 3C1C 06A0  32        bl   @rola                      ; ROL A             ; ship flies off at twice our speed
     3C1E FE34     
12695 3C20 D80D  30        movb ra,@INWK+27                ; STA INWK+27
     3C22 006E     
12696               
12697 3C24 D34E  18        movb rx,ra                      ; TXA               ; Add a new ship of type X to our local bubble of
12698 3C26 0460  28        b    @NWSHP                     ; JMP NWSHP         ; universe and return from the subroutine using a tail
     3C28 AF7A     
12699                                                                          ; call
12700               
12701               * ******************************************************************************
12702               *
12703               * Name: FRMIS
12704               * Type: Subroutine
12705               * Category: Tactics
12706               * Summary: Fire a missile from our ship
12707               *
12708               * ------------------------------------------------------------------------------
12709               *
12710               * We fired a missile, so send it streaking away from us to unleash mayhem and
12711               * destruction on our sworn enemies.
12712               *
12713               * ******************************************************************************
12714               
12715               FRMIS:
12716 3C2A 020E  20        li   rx,(MSL)*256               ; LDX #MSL          ; Call FRS1 to launch a missile straight ahead of us
     3C2C 0900     
12717 3C2E 0200  20        li   rtmp,FRS1                  ; JSR FRS1
     3C30 3BD8     
12718 3C32 06A0  32        bl   @jsr                       ;
     3C34 FE1E     
12719               
12720 3C36 175D  14        jnc  FR1                        ; BCC FR1           ; If FRS1 returns with the C flag clear, then there
12721                                                                          ; isn't room in the universe for our missile, so jump
12722                                                                          ; down to FR1 to display a "missile jammed" message
12723               
12724 3C38 D3A0  30        movb @MSTG,rx                   ; LDX MSTG          ; Fetch the slot number of the missile's target
     3C3A 0052     
12725               
12726 3C3C 0200  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for the target ship
     3C3E AF0C     
12727 3C40 06A0  32        bl   @jsr                       ;
     3C42 FE1E     
12728                                                                          ; and store it in INF
12729               
12730 3C44 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type of the missile's target into A
     3C46 0D40     
12731               
12732 3C48 0200  20        li   rtmp,ANGRY                 ; JSR ANGRY         ; Call ANGRY to make the target ship hostile
     3C4A 3C66     
12733 3C4C 06A0  32        bl   @jsr                       ;
     3C4E FE1E     
12734               
12735 3C50 020F  20        li   ry,>00*256                 ; LDY #0            ; We have just launched a missile, so we need to remove
     3C52 0000     
12736 3C54 0200  20        li   rtmp,ABORT                 ; JSR ABORT         ; missile lock and hide the leftmost indicator on the
     3C56 B0A2     
12737 3C58 06A0  32        bl   @jsr                       ;
     3C5A FE1E     
12738                                                                          ; dashboard by setting it to black (Y = 0)
12739               
12740 3C5C 7347  18        sb   rone,ra                    ; DEC NOMSL         ; Reduce the number of missiles we have by 1
12741               
12742 3C5E 020D  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     3C60 3000     
12743 3C62 0460  28        b    @NOISE                     ; JMP NOISE         ; of a missile launch, returning from the subroutine
     3C64 CBB0     
12744                                                                          ; using a tail call
12745               
12746               * ******************************************************************************
12747               *
12748               * Name: ANGRY
12749               * Type: Subroutine
12750               * Category: Tactics
12751               * Summary: Make a ship hostile
12752               *
12753               * ------------------------------------------------------------------------------
12754               *
12755               * All this routine does is set the ship's hostile flag, start it turning and
12756               * give it a kick of acceleration - later calls to TACTICS will make the ship
12757               * start to attack us.
12758               *
12759               * ------------------------------------------------------------------------------
12760               *
12761               * Arguments:
12762               *
12763               * A                   The type of ship we're going to irritate
12764               *
12765               * INF                 The address of the data block for the ship we're going
12766               * to infuriate
12767               *
12768               * ******************************************************************************
12769               
12770               ANGRY:
12771 3C66 028D  22        ci   ra,(SST)*256               ; CMP #SST          ; If this is the space station, jump to AN2 to make the
     3C68 0800     
12772 3C6A 1334  14        jeq  AN2                        ; BEQ AN2           ; space station hostile
12773               
12774 3C6C 18B3  14        joc  HI1                        ; BCS HI1           ; If A >= #SST then this is a missile, asteroid, cargo
12775                                                                          ; canister, Thargon or escape pod, and they can't get
12776                                                                          ; hostile, so return from the subroutine (as HI1
12777                                                                          ; contains an RTS)
12778               
12779 3C6E 028D  22        ci   ra,(CYL)*256               ; CMP #CYL          ; If this is not a Cobra Mk III trader, skip the
     3C70 0700     
12780 3C72 1604  14        jne  B37                        ; BNE B37           ; following instruction
12781               
12782 3C74 0200  20        li   rtmp,AN2                   ; JSR AN2           ; Call AN2 to make the space station hostile
     3C76 3CD4     
12783 3C78 06A0  32        bl   @jsr                       ;
     3C7A FE1E     
12784               
12785               B37:
12786 3C7C 020F  20        li   ry,>20*256                 ; LDY #32           ; Fetch the ship's byte #32 (AI flag)
     3C7E 2000     
12787                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 3C80 D820  50        movb @INF,@rtmplb
     3C82 0020     
     3C84 206D     
0002 3C86 D020  30        movb @INF+1,rtmp
     3C88 0021     
0003 3C8A A00F  18        a    ry,rtmp
0004 3C8C D350  26        movb *rtmp,RA
                   < elite.a99
12788               
12789 3C8E 13A2  14        jeq  HI1                        ; BEQ HI1           ; If the AI flag is zero then this ship has no AI and
12790                                                                          ; it can't get hostile, so return from the subroutine
12791                                                                          ; (as HI1 contains an RTS)
12792               
12793 3C90 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 (AI enabled) to ensure AI is
     3C92 8000     
12794                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; definitely enabled
     **** ****     > ST_IND_Y_IDX
0001 3C94 D820  50        movb @INF,@rtmplb
     3C96 0020     
     3C98 206D     
0002 3C9A D020  30        movb @INF+1,rtmp
     3C9C 0021     
0003 3C9E A00F  18        a    ry,rtmp
0004 3CA0 D40D  30        movb RA,*rtmp
                   < elite.a99
12795               
12796 3CA2 020F  20        li   ry,>1c*256                 ; LDY #28           ; Set the ship's byte #28 (acceleration) to 2, so it
     3CA4 1C00     
12797 3CA6 020D  20        li   ra,>02*256                 ; LDA #2            ; speeds up
     3CA8 0200     
12798                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 3CAA D820  50        movb @INF,@rtmplb
     3CAC 0020     
     3CAE 206D     
0002 3CB0 D020  30        movb @INF+1,rtmp
     3CB2 0021     
0003 3CB4 A00F  18        a    ry,rtmp
0004 3CB6 D40D  30        movb RA,*rtmp
                   < elite.a99
12799               
12800                      .asla                           ; ASL A             ; Set the ship's byte #30 (pitch counter) to 4, so it
     **** ****     > ASLA
0001 3CB8 024D  22        andi ra,>ff00
     3CBA FF00     
0002 3CBC 0A1D  18        sla  ra,1
                   < elite.a99
12801 3CBE 020F  20        li   ry,>1e*256                 ; LDY #30           ; starts diving
     3CC0 1E00     
12802                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 3CC2 D820  50        movb @INF,@rtmplb
     3CC4 0020     
     3CC6 206D     
0002 3CC8 D020  30        movb @INF+1,rtmp
     3CCA 0021     
0003 3CCC A00F  18        a    ry,rtmp
0004 3CCE D40D  30        movb RA,*rtmp
                   < elite.a99
12803               
12804 3CD0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3CD2 FE2A     
12805               
12806               AN2:
12807                      .asl @K.+NI.+32                 ; ASL K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     **** ****     > ASL
0001 3CD4 D020  30        movb @K.+NI.+32,rtmp
     3CD6 0944     
0002 3CD8 0240  22        andi rtmp,>ff00
     3CDA FF00     
0003 3CDC 0A10  18        sla  rtmp,1
0004 3CDE D800  30        movb rtmp,@K.+NI.+32
     3CE0 0944     
                   < elite.a99
12808                      .sec                            ; SEC               ; in the ship data workspace at K%, which is reserved
     **** ****     > SEC
0001 3CE2 0A18  18        sla  rmone,1
                   < elite.a99
12809 3CE4 0204  20        li   rarg1,K.+NI.+32            ; ROR K%+NI%+32     ; for the sun or the space station (in this case it's
     3CE6 0944     
12810 3CE8 06A0  32        bl   @ror                       ;
     3CEA FE70     
12811                                                                          ; the latter), and set bit 7 to make it hostile
12812               
12813                      .clc                            ; CLC               ; Clear the C flag, which isn't used by calls to this
     **** ****     > CLC
0001 3CEC 0A16  18        sla  rzero,1
                   < elite.a99
12814                                                                          ; routine, but it does set up the entry point FR1-2
12815                                                                          ; so that it clears the C flag and does an RTS
12816               
12817 3CEE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3CF0 FE2A     
12818               
12819               * ******************************************************************************
12820               *
12821               * Name: FR1
12822               * Type: Subroutine
12823               * Category: Tactics
12824               * Summary: Display the "missile jammed" message
12825               *
12826               * ------------------------------------------------------------------------------
12827               *
12828               * This is shown if there isn't room in the local bubble of universe for a new
12829               * missile.
12830               *
12831               * ------------------------------------------------------------------------------
12832               *
12833               * Other entry points:
12834               *
12835               * FR1-2               Clear the C flag and return from the subroutine
12836               *
12837               * ******************************************************************************
12838               
12839               FR1:
12840 3CF2 020D  20        li   ra,>c9*256                 ; LDA #201          ; Print recursive token 41 ("MISSILE JAMMED") as an
     3CF4 C900     
12841 3CF6 0460  28        b    @MESS                      ; JMP MESS          ; in-flight message and return from the subroutine using
     3CF8 CE5E     
12842                                                                          ; a tail call
12843               
12844               * ******************************************************************************
12845               *
12846               * Name: SESCP
12847               * Type: Subroutine
12848               * Category: Flight
12849               * Summary: Spawn an escape pod from the current (parent) ship
12850               *
12851               * ------------------------------------------------------------------------------
12852               *
12853               * This is called when an enemy ship has run out of both energy and luck, so it's
12854               * time to bail.
12855               *
12856               * ******************************************************************************
12857               
12858               SESCP:
12859 3CFA 020E  20        li   rx,(ESC)*256               ; LDX #ESC          ; Set X to the ship type for an escape pod
     3CFC 0D00     
12860               
12861 3CFE 020D  20        li   ra,>fe*256                 ; LDA #%11111110    ; Set A to an AI flag that has AI enabled, is hostile,
     3D00 FE00     
12862                                                                          ; but has no E.C.M.
12863               
12864                                                                          ; Fall through into SFS1 to spawn the escape pod
12865               
12866               * ******************************************************************************
12867               *
12868               * Name: SFS1
12869               * Type: Subroutine
12870               * Category: Universe
12871               * Summary: Spawn a child ship from the current (parent) ship
12872               *
12873               * ------------------------------------------------------------------------------
12874               *
12875               * If the parent is a space station then the child ship is spawned coming out of
12876               * the slot, and if the child is a cargo canister, it is sent tumbling through
12877               * space. Otherwise the child ship is spawned with the same ship data as the
12878               * parent, just with damping disabled and the ship type and AI flag that are
12879               * passed in A and X.
12880               *
12881               * ------------------------------------------------------------------------------
12882               *
12883               * Arguments:
12884               *
12885               * A                   AI flag for the new ship (see the documentation on ship
12886               * data byte #32 for details)
12887               *
12888               * X                   The ship type of the child to spawn
12889               *
12890               * INF                 Address of the parent's ship data block
12891               *
12892               * TYPE                The type of the parent ship
12893               *
12894               * ------------------------------------------------------------------------------
12895               *
12896               * Returns:
12897               *
12898               * C flag              Set if ship successfully added, clear if it failed
12899               *
12900               * INF                 INF is preserved
12901               *
12902               * XX0                 XX0 is preserved
12903               *
12904               * INWK                The whole INWK workspace is preserved
12905               *
12906               * ------------------------------------------------------------------------------
12907               *
12908               * Other entry points:
12909               *
12910               * SFS1-2              Add a missile to the local bubble that has AI enabled,
12911               * is hostile, but has no E.C.M.
12912               *
12913               * ******************************************************************************
12914               
12915               SFS1:
12916 3D02 D80D  30        movb ra,@T1                     ; STA T1            ; Store the child ship's AI flag in T1
     3D04 0006     
12917               
12918                                                                          ; Before spawning our child ship, we need to save the
12919                                                                          ; INF and XX00 variables and the whole INWK workspace,
12920                                                                          ; so we can restore them later when returning from the
12921                                                                          ; subroutine
12922               
12923 3D06 D360  30        movb @XX0,ra                    ; LDA XX0           ; Store XX0(1 0) on the stack, so we can restore it
     3D08 001E     
12924                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 3D0A D68D  30        movb ra,*rsp
0002 3D0C 060A  14        dec  rsp
                   < elite.a99
12925 3D0E D360  30        movb @XX0+1,ra                  ; LDA XX0+1
     3D10 001F     
12926                      .pha                            ; PHA
     **** ****     > PHA
0001 3D12 D68D  30        movb ra,*rsp
0002 3D14 060A  14        dec  rsp
                   < elite.a99
12927               
12928 3D16 D360  30        movb @INF,ra                    ; LDA INF           ; Store INF(1 0) on the stack, so we can restore it
     3D18 0020     
12929                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 3D1A D68D  30        movb ra,*rsp
0002 3D1C 060A  14        dec  rsp
                   < elite.a99
12930 3D1E D360  30        movb @INF+1,ra                  ; LDA INF+1
     3D20 0021     
12931                      .pha                            ; PHA
     **** ****     > PHA
0001 3D22 D68D  30        movb ra,*rsp
0002 3D24 060A  14        dec  rsp
                   < elite.a99
12932               
12933 3D26 020F  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Now we want to store the current INWK data block in
     3D28 2300     
12934                                                                          ; temporary memory so we can restore it when we are
12935                                                                          ; done, and we also want to copy the parent's ship data
12936                                                                          ; into INWK, which we can do at the same time, so set up
12937                                                                          ; a counter in Y for NI% bytes
12938               
12939               FRL2:
12940 3D2A D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Copy the Y-th byte of INWK to the Y-th byte of
     3D2C 0053     
12941 3D2E DBCD  38        movb ra,@XX3(ry)                ; STA XX3,Y         ; temporary memory in XX3, so we can restore it later
     3D30 0100     
12942                                                                          ; when returning from the subroutine
12943               
12944                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte of the parent ship's data block to
     **** ****     > LD_IND_Y_IDX
0001 3D32 D820  50        movb @INF,@rtmplb
     3D34 0020     
     3D36 206D     
0002 3D38 D020  30        movb @INF+1,rtmp
     3D3A 0021     
0003 3D3C A00F  18        a    ry,rtmp
0004 3D3E D350  26        movb *rtmp,RA
                   < elite.a99
12945 3D40 DBCD  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; the Y-th byte of INWK
     3D42 0053     
12946               
12947 3D44 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
12948               
12949 3D46 15F1  14        jgt  FRL2                       ; BPL FRL2          ; Loop back to copy the next byte until we have done
12950                                                                          ; them all
12951               
12952                                                                          ; INWK now contains the ship data for the parent ship,
12953                                                                          ; so now we need to tweak the data before creating the
12954                                                                          ; new child ship (in this way, the child inherits things
12955                                                                          ; like location from the parent)
12956               
12957 3D48 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type of the parent into A
     3D4A 009B     
12958               
12959 3D4C 028D  22        ci   ra,(SST)*256               ; CMP #SST          ; If the parent is not a space station, jump to rx to
     3D4E 0800     
12960 3D50 1622  14        jne  rx_                        ; BNE rx            ; skip the following
12961               
12962                                                                          ; The parent is a space station, so the child needs to
12963                                                                          ; launch out of the space station's slot. The space
12964                                                                          ; station's nosev vector points out of the station's
12965                                                                          ; slot, so we want to move the ship along this vector.
12966                                                                          ; We do this by taking the unit vector in nosev and
12967                                                                          ; doubling it, so we spawn our ship 2 units along the
12968                                                                          ; vector from the space station's centre
12969               
12970 3D52 D34E  18        movb rx,ra                      ; TXA               ; Store the child's ship type in X on the stack
12971                      .pha                            ; PHA
     **** ****     > PHA
0001 3D54 D68D  30        movb ra,*rsp
0002 3D56 060A  14        dec  rsp
                   < elite.a99
12972               
12973 3D58 020D  20        li   ra,>20*256                 ; LDA #32           ; Set the child's byte #27 (speed) to 32
     3D5A 2000     
12974 3D5C D80D  30        movb ra,@INWK+27                ; STA INWK+27
     3D5E 006E     
12975               
12976 3D60 020E  20        li   rx,>00*256                 ; LDX #0            ; Add 2 * nosev_x_hi to (x_lo, x_hi, x_sign) to get the
     3D62 0000     
12977 3D64 D360  30        movb @INWK+10,ra                ; LDA INWK+10       ; child's x-coordinate
     3D66 005D     
12978 3D68 0200  20        li   rtmp,SFS2                  ; JSR SFS2
     3D6A 3E26     
12979 3D6C 06A0  32        bl   @jsr                       ;
     3D6E FE1E     
12980               
12981 3D70 020E  20        li   rx,>03*256                 ; LDX #3            ; Add 2 * nosev_y_hi to (y_lo, y_hi, y_sign) to get the
     3D72 0300     
12982 3D74 D360  30        movb @INWK+12,ra                ; LDA INWK+12       ; child's y-coordinate
     3D76 005F     
12983 3D78 0200  20        li   rtmp,SFS2                  ; JSR SFS2
     3D7A 3E26     
12984 3D7C 06A0  32        bl   @jsr                       ;
     3D7E FE1E     
12985               
12986 3D80 020E  20        li   rx,>06*256                 ; LDX #6            ; Add 2 * nosev_z_hi to (z_lo, z_hi, z_sign) to get the
     3D82 0600     
12987 3D84 D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; child's z-coordinate
     3D86 0061     
12988 3D88 0200  20        li   rtmp,SFS2                  ; JSR SFS2
     3D8A 3E26     
12989 3D8C 06A0  32        bl   @jsr                       ;
     3D8E FE1E     
12990               
12991                      .pla                            ; PLA               ; Restore the child's ship type from the stack into X
     **** ****     > PLA
0001 3D90 058A  14        inc  rsp
0002 3D92 D35A  26        movb *rsp,ra
                   < elite.a99
12992 3D94 D38D  18        movb ra,rx                      ; TAX
12993               
12994               rx_:
12995 3D96 D360  30        movb @T1,ra                     ; LDA T1            ; Restore the child ship's AI flag from T1 and store it
     3D98 0006     
12996 3D9A D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; in the child's byte #32 (AI)
     3D9C 0073     
12997               
12998                      .lsr @INWK+29                   ; LSR INWK+29       ; Clear bit 0 of the child's byte #29 (roll counter) so
     **** ****     > LSR
0001 3D9E D020  30        movb @INWK+29,rtmp
     3DA0 0070     
0002 3DA2 0910  18        srl  rtmp,1
0003 3DA4 D800  30        movb rtmp,@INWK+29
     3DA6 0070     
                   < elite.a99
12999                      .asl @INWK+29                   ; ASL INWK+29       ; that its roll dampens (so if we are spawning from a
     **** ****     > ASL
0001 3DA8 D020  30        movb @INWK+29,rtmp
     3DAA 0070     
0002 3DAC 0240  22        andi rtmp,>ff00
     3DAE FF00     
0003 3DB0 0A10  18        sla  rtmp,1
0004 3DB2 D800  30        movb rtmp,@INWK+29
     3DB4 0070     
                   < elite.a99
13000                                                                          ; space station, for example, the spawned ship won't
13001                                                                          ; keep rolling forever)
13002               
13003 3DB6 D34E  18        movb rx,ra                      ; TXA               ; Copy the child's ship type from X into A
13004               
13005 3DB8 028D  22        ci   ra,(OIL)*256               ; CMP #OIL          ; If the child we are spawning is not a cargo canister,
     3DBA 0B00     
13006 3DBC 1616  14        jne  NOIL                       ; BNE NOIL          ; jump to NOIL to skip us setting up the pitch and roll
13007                                                                          ; for the canister
13008               
13009 3DBE 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3DC0 C07C     
13010 3DC2 06A0  32        bl   @jsr                       ;
     3DC4 FE1E     
13011               
13012                      .asla                           ; ASL A             ; Set the child's byte #30 (pitch counter) to a random
     **** ****     > ASLA
0001 3DC6 024D  22        andi ra,>ff00
     3DC8 FF00     
0002 3DCA 0A1D  18        sla  ra,1
                   < elite.a99
13013 3DCC D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; value, and at the same time set the C flag randomly
     3DCE 0071     
13014               
13015 3DD0 D34E  18        movb rx,ra                      ; TXA               ; Set the child's byte #27 (speed) to a random value
13016 3DD2 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; between 0 and 15
     3DD4 0F00     
13017 3DD6 D80D  30        movb ra,@INWK+27                ; STA INWK+27
     3DD8 006E     
13018               
13019 3DDA 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set the child's byte #29 (roll counter) to a full
     3DDC FF00     
13020 3DDE 06A0  32        bl   @rora                      ; ROR A             ; roll with no damping (as bits 0 to 6 are set), so the
     3DE0 FE58     
13021 3DE2 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; canister tumbles through space, with the direction in
     3DE4 0070     
13022                                                                          ; bit 7 set randomly, depending on the C flag from above
13023               
13024 3DE6 020D  20        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship type of a cargo canister
     3DE8 0B00     
13025               
13026               NOIL:
13027 3DEA 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add a new ship of type A to the local bubble
     3DEC AF7A     
13028 3DEE 06A0  32        bl   @jsr                       ;
     3DF0 FE1E     
13029               
13030                                                                          ; We have now created our child ship, so we need to
13031                                                                          ; restore all the variables we saved at the start of
13032                                                                          ; the routine, so they are preserved when we return
13033                                                                          ; from the subroutine
13034               
13035                      .pla                            ; PLA               ; Restore INF(1 0) from the stack
     **** ****     > PLA
0001 3DF2 058A  14        inc  rsp
0002 3DF4 D35A  26        movb *rsp,ra
                   < elite.a99
13036 3DF6 D80D  30        movb ra,@INF+1                  ; STA INF+1
     3DF8 0021     
13037                      .pla                            ; PLA
     **** ****     > PLA
0001 3DFA 058A  14        inc  rsp
0002 3DFC D35A  26        movb *rsp,ra
                   < elite.a99
13038 3DFE D80D  30        movb ra,@INF                    ; STA INF
     3E00 0020     
13039               
13040 3E02 020E  20        li   rx,(NI.-1)*256             ; LDX #NI%-1        ; Now to restore the INWK workspace that we saved into
     3E04 2300     
13041                                                                          ; XX3 above, so set a counter in X for NI% bytes
13042               
13043               FRL3:
13044 3E06 D36E  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Copy the Y-th byte of XX3 to the Y-th byte of INWK
     3E08 0100     
13045 3E0A DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X
     3E0C 0053     
13046               
13047 3E0E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
13048               
13049 3E10 15FA  14        jgt  FRL3                       ; BPL FRL3          ; Loop back to copy the next byte until we have done
13050                                                                          ; them all
13051               
13052                      .pla                            ; PLA               ; Restore XX0(1 0) from the stack
     **** ****     > PLA
0001 3E12 058A  14        inc  rsp
0002 3E14 D35A  26        movb *rsp,ra
                   < elite.a99
13053 3E16 D80D  30        movb ra,@XX0+1                  ; STA XX0+1
     3E18 001F     
13054                      .pla                            ; PLA
     **** ****     > PLA
0001 3E1A 058A  14        inc  rsp
0002 3E1C D35A  26        movb *rsp,ra
                   < elite.a99
13055 3E1E D80D  30        movb ra,@XX0                    ; STA XX0
     3E20 001E     
13056               
13057 3E22 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3E24 FE2A     
13058               
13059               * ******************************************************************************
13060               *
13061               * Name: SFS2
13062               * Type: Subroutine
13063               * Category: Moving
13064               * Summary: Move a ship in space along one of the coordinate axes
13065               *
13066               * ------------------------------------------------------------------------------
13067               *
13068               * Move a ship's coordinates by a certain amount in the direction of one of the
13069               * axes, where X determines the axis. Mathematically speaking, this routine
13070               * translates the ship along a single axis by a signed delta.
13071               *
13072               * ------------------------------------------------------------------------------
13073               *
13074               * Arguments:
13075               *
13076               * A                   The amount of movement, i.e. the signed delta
13077               *
13078               * X                   Determines which coordinate axis of INWK to move:
13079               *
13080               * * X = 0 moves the ship along the x-axis
13081               *
13082               * * X = 3 moves the ship along the y-axis
13083               *
13084               * * X = 6 moves the ship along the z-axis
13085               *
13086               * ******************************************************************************
13087               
13088               SFS2:
13089                      .asla                           ; ASL A             ; Set R = |A * 2|, with the C flag set to bit 7 of A
     **** ****     > ASLA
0001 3E26 024D  22        andi ra,>ff00
     3E28 FF00     
0002 3E2A 0A1D  18        sla  ra,1
                   < elite.a99
13090 3E2C D80D  30        movb ra,@R                      ; STA R
     3E2E 0091     
13091               
13092 3E30 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to the C flag, i.e. the sign bit from
     3E32 0000     
13093 3E34 06A0  32        bl   @rora                      ; ROR A             ; the original argument in A
     3E36 FE58     
13094               
13095 3E38 0460  24        b    @MVT1                      ; JMP MVT1          ; Add the delta R with sign A to (x_lo, x_hi, x_sign)
     3E3A 1BAA     
13096                                                                          ; (or y or z, depending on the value in X) and return
13097                                                                          ; from the subroutine using a tail call
13098               
13099               * ******************************************************************************
13100               *
13101               * Name: LL164
13102               * Type: Subroutine
13103               * Category: Drawing circles
13104               * Summary: Make the hyperspace sound and draw the hyperspace tunnel
13105               *
13106               * ------------------------------------------------------------------------------
13107               *
13108               * See the IRQ1 routine for details on the multi-coloured effect that's used.
13109               *
13110               * ******************************************************************************
13111               
13112               LL164:
13113 3E3C 020D  20        li   ra,>38*256                 ; LDA #56           ; Call the NOISE routine with A = 56 to make the sound
     3E3E 3800     
13114 3E40 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the hyperspace drive being engaged
     3E42 CBB0     
13115 3E44 06A0  32        bl   @jsr                       ;
     3E46 FE1E     
13116               
13117 3E48 020D  20        li   ra,>01*256                 ; LDA #1            ; Set HFX to 1, which switches the screen mode to a full
     3E4A 0100     
13118 3E4C D80D  30        movb ra,@HFX                    ; STA HFX           ; mode 5 screen, therefore making the hyperspace rings
     3E4E 0D62     
13119                                                                          ; multi-coloured and all zig-zaggy (see the IRQ1 routine
13120                                                                          ; for details)
13121               
13122 3E50 020D  20        li   ra,>04*256                 ; LDA #4            ; Set the step size for the hyperspace rings to 4, so
     3E52 0400     
13123                                                                          ; there are more sections in the rings and they are
13124                                                                          ; quite round (compared to the step size of 8 used in
13125                                                                          ; the much more polygonal launch rings)
13126               
13127 3E54 0200  20        li   rtmp,HFS2                  ; JSR HFS2          ; Call HFS2 to draw the hyperspace tunnel rings
     3E56 3E72     
13128 3E58 06A0  32        bl   @jsr                       ;
     3E5A FE1E     
13129               
13130 3E5C 7347  18        sb   rone,ra                    ; DEC HFX           ; Set HFX back to 0, so we switch back to the normal
13131                                                                          ; split-screen mode
13132               
13133 3E5E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3E60 FE2A     
13134               
13135               * ******************************************************************************
13136               *
13137               * Name: LAUN
13138               * Type: Subroutine
13139               * Category: Drawing circles
13140               * Summary: Make the launch sound and draw the launch tunnel
13141               *
13142               * ------------------------------------------------------------------------------
13143               *
13144               * This is shown when launching from or docking with the space station.
13145               *
13146               * ******************************************************************************
13147               
13148               LAUN:
13149 3E62 020D  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     3E64 3000     
13150 3E66 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the ship launching from the station
     3E68 CBB0     
13151 3E6A 06A0  32        bl   @jsr                       ;
     3E6C FE1E     
13152               
13153 3E6E 020D  20        li   ra,>08*256                 ; LDA #8            ; Set the step size for the launch tunnel rings to 8, so
     3E70 0800     
13154                                                                          ; there are fewer sections in the rings and they are
13155                                                                          ; quite polygonal (compared to the step size of 4 used
13156                                                                          ; in the much rounder hyperspace rings)
13157               
13158                                                                          ; Fall through into HFS2 to draw the launch tunnel rings
13159               
13160               * ******************************************************************************
13161               *
13162               * Name: HFS2
13163               * Type: Subroutine
13164               * Category: Drawing circles
13165               * Summary: Draw the launch or hyperspace tunnel
13166               *
13167               * ------------------------------------------------------------------------------
13168               *
13169               * The animation gets drawn like this. First, we draw a circle of radius 8 at the
13170               * centre, and then double the radius, draw another circle, double the radius
13171               * again and draw a circle, and we keep doing this until the radius is bigger
13172               * than 160 (which goes beyond the edge of the screen, which is 256 pixels wide,
13173               * equivalent to a radius of 128). We then repeat this whole process for an
13174               * initial circle of radius 9, then radius 10, all the way up to radius 15.
13175               *
13176               * This has the effect of making the tunnel appear to be racing towards us as we
13177               * hurtle out into hyperspace or through the space station's docking tunnel.
13178               *
13179               * The hyperspace effect is done in a full mode 5 screen, which makes the rings
13180               * all coloured and zig-zaggy, while the launch screen is in the normal
13181               * monochrome mode 4 screen.
13182               *
13183               * ------------------------------------------------------------------------------
13184               *
13185               * Arguments:
13186               *
13187               * A                   The step size of the straight lines making up the rings
13188               * (4 for launch, 8 for hyperspace)
13189               *
13190               * ******************************************************************************
13191               
13192               HFS2:
13193 3E72 D80D  30        movb ra,@STP                    ; STA STP           ; Store the step size in A
     3E74 00A6     
13194               
13195 3E76 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; Clear the screen and draw a white border
     3E78 4B2E     
13196 3E7A 06A0  32        bl   @jsr                       ;
     3E7C FE1E     
13197               
13198 3E7E 0200  20        li   rtmp,HFS1                  ; JSR HFS1          ; Call HFS1 below and then fall through into the same
     3E80 3E86     
13199 3E82 06A0  32        bl   @jsr                       ;
     3E84 FE1E     
13200                                                                          ; routine, so this effectively runs HFS1 twice, and as
13201                                                                          ; HFS1 draws 8 concentric rings, this means we draw 16
13202                                                                          ; of them in all
13203               
13204               HFS1:
13205 3E86 020D  20        li   ra,>80*256                 ; LDA #128          ; Set K3 = 128 (the x-coordinate of the centre of the
     3E88 8000     
13206 3E8A D80D  30        movb ra,@K3                     ; STA K3            ; screen)
     3E8C 00D2     
13207               
13208 3E8E 020E  20        li   rx,(Y)*256                 ; LDX #Y            ; Set K4 = #Y (the y-coordinate of the centre of the
     3E90 6000     
13209 3E92 D80E  30        movb rx,@K4                     ; STX K4            ; screen)
     3E94 00E0     
13210               
13211                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 3E96 024D  22        andi ra,>ff00
     3E98 FF00     
0002 3E9A 0A1D  18        sla  ra,1
                   < elite.a99
13212               
13213 3E9C D80D  30        movb ra,@XX4                    ; STA XX4           ; Set XX4 = 0, which we will use as a counter for
     3E9E 00A7     
13214                                                                          ; drawing eight concentric rings
13215               
13216 3EA0 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     3EA2 00D3     
13217 3EA4 D80D  30        movb ra,@K4+1                   ; STA K4+1
     3EA6 00E1     
13218               
13219               HFL5:
13220 3EA8 0200  20        li   rtmp,HFL1                  ; JSR HFL1          ; Call HFL1 below to draw a set of rings, with each one
     3EAA 3EC0     
13221 3EAC 06A0  32        bl   @jsr                       ;
     3EAE FE1E     
13222                                                                          ; twice the radius of the previous one, until they won't
13223                                                                          ; fit on-screen
13224               
13225 3EB0 B347  18        ab   rone,ra                    ; INC XX4           ; Increment the counter and fetch it into X
13226 3EB2 D3A0  30        movb @XX4,rx                    ; LDX XX4
     3EB4 00A7     
13227               
13228 3EB6 028E  22        ci   rx,>08*256                 ; CPX #8            ; If we haven't drawn 8 sets of rings yet, loop back to
     3EB8 0800     
13229 3EBA 16F6  14        jne  HFL5                       ; BNE HFL5          ; HFL5 to draw the next ring
13230               
13231 3EBC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3EBE FE2A     
13232               
13233               HFL1:
13234 3EC0 D360  30        movb @XX4,ra                    ; LDA XX4           ; Set K to the ring number in XX4 (0-7) + 8, so K has
     3EC2 00A7     
13235 3EC4 024D  22        andi ra,>07*256                 ; AND #7            ; a value of 8 to 15, which we will use as the starting
     3EC6 0700     
13236                      .clc                            ; CLC               ; radius for our next set of rings
     **** ****     > CLC
0001 3EC8 0A16  18        sla  rzero,1
                   < elite.a99
13237                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 3ECA 1701  14        jnc  !
0002 3ECC B347  18        ab   rone,ra
0003               !:
0004 3ECE 022D  22        ai   ra,(>08*256)
     3ED0 0800     
                   < elite.a99
13238 3ED2 D80D  30        movb ra,@K                      ; STA K
     3ED4 003D     
13239               
13240               HFL2:
13241 3ED6 020D  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap
     3ED8 0100     
13242 3EDA D80D  30        movb ra,@LSP                    ; STA LSP
     3EDC 0077     
13243               
13244 3EDE 0200  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     3EE0 B82C     
13245 3EE2 06A0  32        bl   @jsr                       ;
     3EE4 FE1E     
13246                                                                          ; (K3(1 0), K4(1 0)) and radius K
13247               
13248                      .asl @K                         ; ASL K             ; Double the radius in K
     **** ****     > ASL
0001 3EE6 D020  30        movb @K,rtmp
     3EE8 003D     
0002 3EEA 0240  22        andi rtmp,>ff00
     3EEC FF00     
0003 3EEE 0A10  18        sla  rtmp,1
0004 3EF0 D800  30        movb rtmp,@K
     3EF2 003D     
                   < elite.a99
13249               
13250 3EF4 1805  14        joc  HF8                        ; BCS HF8           ; If the radius had a 1 in bit 7 before the above shift,
13251                                                                          ; then doubling K will means the circle will no longer
13252                                                                          ; fit on the screen (which is width 256), so jump to
13253                                                                          ; HF8 to stop drawing circles
13254               
13255 3EF6 D360  30        movb @K,ra                      ; LDA K             ; If the radius in K <= 160, loop back to HFL2 to draw
     3EF8 003D     
13256 3EFA 028D  22        ci   ra,>a0*256                 ; CMP #160          ; another one
     3EFC A000     
13257 3EFE 17EB  14        jnc  HFL2                       ; BCC HFL2
13258               
13259               HF8:
13260 3F00 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3F02 FE2A     
13261               
13262               * ******************************************************************************
13263               *
13264               * Name: STARS2
13265               * Type: Subroutine
13266               * Category: Stardust
13267               * Summary: Process the stardust for the left or right view
13268               * Deep dive: Stardust in the side views
13269               *
13270               * ------------------------------------------------------------------------------
13271               *
13272               * This moves the stardust sideways according to our speed and which side we are
13273               * looking out of, and applies our current pitch and roll to each particle of
13274               * dust, so the stardust moves correctly when we steer our ship.
13275               *
13276               * These are the calculations referred to in the commentary:
13277               *
13278               * 1. delta_x = 8 * 256 * speed / z_hi
13279               * 2. x = x + delta_x
13280               *
13281               * 3. x = x + beta * y
13282               * 4. y = y - beta * x
13283               *
13284               * 5. x = x - alpha * x * y
13285               * 6. y = y + alpha * y * y + alpha
13286               *
13287               * For more information see the deep dive on "Stardust in the side views".
13288               *
13289               * ------------------------------------------------------------------------------
13290               *
13291               * Arguments:
13292               *
13293               * X                   The view to process:
13294               *
13295               * * X = 1 for left view
13296               *
13297               * * X = 2 for right view
13298               *
13299               * ******************************************************************************
13300               
13301               STARS2:
13302 3F04 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can use it to capture a sign bit
     3F06 0000     
13303               
13304 3F08 028E  22        ci   rx,>02*256                 ; CPX #2            ; If X >= 2 then the C flag is set
     3F0A 0200     
13305               
13306 3F0C 06A0  32        bl   @rora                      ; ROR A             ; Roll the C flag into the sign bit of A and store in
     3F0E FE58     
13307 3F10 D80D  30        movb ra,@RAT                    ; STA RAT           ; RAT, so:
     3F12 00AA     
13308                                                                          ;
13309                                                                          ; * Left view, C is clear so RAT = 0 (positive)
13310                                                                          ;
13311                                                                          ; * Right view, C is set so RAT = 128 (negative)
13312                                                                          ;
13313                                                                          ; RAT represents the end of the x-axis where we want new
13314                                                                          ; stardust particles to come from: positive for the left
13315                                                                          ; view where new particles come in from the right,
13316                                                                          ; negative for the right view where new particles come
13317                                                                          ; in from the left
13318               
13319                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT2 to the opposite sign, so:
     **** ****     > EOI
0001 3F14 0200  20        li   rtmp,(>80*256)
     3F16 8000     
0002 3F18 2B40  18        xor  rtmp,ra
                   < elite.a99
13320 3F1A D80D  30        movb ra,@RAT2                   ; STA RAT2          ;
     3F1C 00AB     
13321                                                                          ; * Left view, RAT2 = 128 (negative)
13322                                                                          ;
13323                                                                          ; * Right view, RAT2 = 0 (positive)
13324                                                                          ;
13325                                                                          ; RAT2 represents the direction in which stardust
13326                                                                          ; particles should move along the x-axis: negative for
13327                                                                          ; the left view where particles go from right to left,
13328                                                                          ; positive for the right view where particles go from
13329                                                                          ; left to right
13330               
13331 3F1E 0200  20        li   rtmp,ST2                   ; JSR ST2           ; Call ST2 to flip the signs of the following if this is
     3F20 4078     
13332 3F22 06A0  32        bl   @jsr                       ;
     3F24 FE1E     
13333                                                                          ; the right view: ALPHA, ALP2, ALP2+1, BET2 and BET2+1
13334               
13335 3F26 D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     3F28 0F33     
13336                                                                          ; we can use it as a counter through all the stardust
13337               
13338               STL2:
13339 3F2A D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Set A = ZZ = z_hi
     3F2C 0EE8     
13340               
13341 3F2E D80D  30        movb ra,@ZZ                     ; STA ZZ            ; We also set ZZ to the original value of z_hi, which we
     3F30 0097     
13342                                                                          ; use below to remove the existing particle
13343               
13344 3F32 091D  18        srl  ra,1                       ; LSR A             ; Set A = z_hi / 8
13345 3F34 091D  18        srl  ra,1                       ; LSR A
13346 3F36 091D  18        srl  ra,1                       ; LSR A
13347               
13348 3F38 0200  20        li   rtmp,DV41                  ; JSR DV41          ; Call DV41 to set the following:
     3F3A 45A8     
13349 3F3C 06A0  32        bl   @jsr                       ;
     3F3E FE1E     
13350                                                                          ;
13351                                                                          ; (P R) = 256 * DELTA / A
13352                                                                          ; = 256 * speed / (z_hi / 8)
13353                                                                          ; = 8 * 256 * speed / z_hi
13354                                                                          ;
13355                                                                          ; This represents the distance we should move this
13356                                                                          ; particle along the x-axis, let's call it delta_x
13357               
13358 3F40 D360  30        movb @P,ra                      ; LDA P             ; Set S = P but with the sign from RAT2, so we now have
     3F42 001B     
13359                      .eor @RAT2                      ; EOR RAT2          ; the distance delta_x with the correct sign in (S R):
     **** ****     > EOR
0001 3F44 D020  30        movb @RAT2,rtmp
     3F46 00AB     
0002 3F48 2B40  18        xor  rtmp,ra
                   < elite.a99
13360 3F4A D80D  30        movb ra,@S                      ; STA S             ;
     3F4C 0092     
13361                                                                          ; (S R) = delta_x
13362                                                                          ; = 8 * 256 * speed / z_hi
13363                                                                          ;
13364                                                                          ; So (S R) is the delta, signed to match the direction
13365                                                                          ; the stardust should move in, which is result 1 above
13366               
13367 3F4E D36F  34        movb @SXL(ry),ra                ; LDA SXL,Y         ; Set (A P) = (x_hi x_lo)
     3F50 035F     
13368 3F52 D80D  30        movb ra,@P                      ; STA P             ; = x
     3F54 001B     
13369 3F56 D36F  34        movb @SX(ry),ra                 ; LDA SX,Y
     3F58 034C     
13370               
13371 3F5A D80D  30        movb ra,@X1                     ; STA X1            ; Set X1 = A, so X1 contains the original value of x_hi,
     3F5C 0031     
13372                                                                          ; which we use below to remove the existing particle
13373               
13374 3F5E 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     3F60 44BA     
13375 3F62 06A0  32        bl   @jsr                       ;
     3F64 FE1E     
13376                                                                          ;
13377                                                                          ; (A X) = (A P) + (S R)
13378                                                                          ; = x + delta_x
13379               
13380 3F66 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     3F68 0092     
13381 3F6A D80E  30        movb rx,@R                      ; STX R             ; = x + delta_x
     3F6C 0091     
13382               
13383 3F6E D36F  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set A = y_hi
     3F70 0EC2     
13384               
13385 3F72 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A, so Y1 contains the original value of y_hi,
     3F74 0032     
13386                                                                          ; which we use below to remove the existing particle
13387               
13388                      .eor @BET2                      ; EOR BET2          ; Give A the correct sign of A * beta, i.e. y_hi * beta
     **** ****     > EOR
0001 3F76 D020  30        movb @BET2,rtmp
     3F78 008A     
0002 3F7A 2B40  18        xor  rtmp,ra
                   < elite.a99
13389               
13390 3F7C D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     3F7E 002B     
13391               
13392 3F80 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     3F82 41F4     
13393 3F84 06A0  32        bl   @jsr                       ;
     3F86 FE1E     
13394                                                                          ;
13395                                                                          ; (A P) = X * A
13396                                                                          ; = beta * y_hi
13397               
13398 3F88 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     3F8A 44BA     
13399 3F8C 06A0  32        bl   @jsr                       ;
     3F8E FE1E     
13400                                                                          ;
13401                                                                          ; (A X) = (A P) + (S R)
13402                                                                          ; = beta * y + x + delta_x
13403               
13404 3F90 D80E  30        movb rx,@XX                     ; STX XX            ; Set XX(1 0) = (A X), which gives us results 2 and 3
     3F92 0024     
13405 3F94 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; above, done at the same time:
     3F96 0025     
13406                                                                          ;
13407                                                                          ; x = x + delta_x + beta * y
13408               
13409 3F98 D3AF  34        movb @SYL(ry),rx                ; LDX SYL,Y         ; Set (S R) = (y_hi y_lo)
     3F9A 0ED5     
13410 3F9C D80E  30        movb rx,@R                      ; STX R             ; = y
     3F9E 0091     
13411 3FA0 D3A0  30        movb @Y1,rx                     ; LDX Y1
     3FA2 0032     
13412 3FA4 D80E  30        movb rx,@S                      ; STX S
     3FA6 0092     
13413               
13414 3FA8 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     3FAA 002B     
13415               
13416                      .eor @BET2+1                    ; EOR BET2+1        ; Give A the opposite sign to x * beta
     **** ****     > EOR
0001 3FAC D020  30        movb @BET2+1,rtmp
     3FAE 008B     
0002 3FB0 2B40  18        xor  rtmp,ra
                   < elite.a99
13417               
13418 3FB2 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     3FB4 41F4     
13419 3FB6 06A0  32        bl   @jsr                       ;
     3FB8 FE1E     
13420                                                                          ;
13421                                                                          ; (A P) = X * A
13422                                                                          ; = -beta * x
13423               
13424 3FBA 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     3FBC 44BA     
13425 3FBE 06A0  32        bl   @jsr                       ;
     3FC0 FE1E     
13426                                                                          ;
13427                                                                          ; (A X) = (A P) + (S R)
13428                                                                          ; = -beta * x + y
13429               
13430 3FC2 D80E  30        movb rx,@YY                     ; STX YY            ; Set YY(1 0) = (A X), which gives us result 4 above:
     3FC4 0026     
13431 3FC6 D80D  30        movb ra,@YY+1                   ; STA YY+1          ;
     3FC8 0027     
13432                                                                          ; y = y - beta * x
13433               
13434 3FCA D3A0  30        movb @ALP1,rx                   ; LDX ALP1          ; Set X = |alpha| from ALP2, the roll angle
     3FCC 0087     
13435               
13436                      .eor @ALP2                      ; EOR ALP2          ; Give A the correct sign of A * alpha, i.e. y_hi *
     **** ****     > EOR
0001 3FCE D020  30        movb @ALP2,rtmp
     3FD0 0088     
0002 3FD2 2B40  18        xor  rtmp,ra
                   < elite.a99
13437                                                                          ; alpha
13438               
13439 3FD4 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     3FD6 41F4     
13440 3FD8 06A0  32        bl   @jsr                       ;
     3FDA FE1E     
13441                                                                          ;
13442                                                                          ; (A P) = X * A
13443                                                                          ; = alpha * y
13444               
13445 3FDC D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = high byte of alpha * y
     3FDE 0090     
13446               
13447 3FE0 D360  30        movb @XX,ra                     ; LDA XX            ; Set (S R) = XX(1 0)
     3FE2 0024     
13448 3FE4 D80D  30        movb ra,@R                      ; STA R             ; = x
     3FE6 0091     
13449 3FE8 D360  30        movb @XX+1,ra                   ; LDA XX+1          ;
     3FEA 0025     
13450 3FEC D80D  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     3FEE 0092     
13451               
13452                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A = -x_hi
     **** ****     > EOI
0001 3FF0 0200  20        li   rtmp,(>80*256)
     3FF2 8000     
0002 3FF4 2B40  18        xor  rtmp,ra
                   < elite.a99
13453               
13454 3FF6 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     3FF8 44B2     
13455 3FFA 06A0  32        bl   @jsr                       ;
     3FFC FE1E     
13456                                                                          ;
13457                                                                          ; (A X) = Q * A + (S R)
13458                                                                          ; = alpha * y * -x + x
13459               
13460 3FFE D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     4000 0025     
13461               
13462 4002 D34E  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
13463 4004 DBCD  38        movb ra,@SXL(ry)                ; STA SXL,Y
     4006 035F     
13464               
13465                                                                          ; So (XX+1 x_lo) now contains result 5 above:
13466                                                                          ;
13467                                                                          ; x = x - alpha * x * y
13468               
13469 4008 D360  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0)
     400A 0026     
13470 400C D80D  30        movb ra,@R                      ; STA R             ; = y
     400E 0091     
13471 4010 D360  30        movb @YY+1,ra                   ; LDA YY+1          ;
     4012 0027     
13472 4014 D80D  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     4016 0092     
13473               
13474 4018 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     401A 44B2     
13475 401C 06A0  32        bl   @jsr                       ;
     401E FE1E     
13476                                                                          ;
13477                                                                          ; (A X) = Q * A + (S R)
13478                                                                          ; = alpha * y * y_hi + y
13479               
13480 4020 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     4022 0092     
13481 4024 D80E  30        movb rx,@R                      ; STX R             ; = y + alpha * y * y
     4026 0091     
13482               
13483 4028 020D  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     402A 0000     
13484 402C D80D  30        movb ra,@P                      ; STA P
     402E 001B     
13485               
13486 4030 D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha, so:
     4032 009E     
13487                                                                          ;
13488                                                                          ; (A P) = (alpha 0)
13489                                                                          ; = alpha / 256
13490               
13491 4034 0200  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     4036 275A     
13492 4038 06A0  32        bl   @jsr                       ;
     403A FE1E     
13493                                                                          ;
13494                                                                          ; (YY+1 y_lo) = (A P) + (S R)
13495                                                                          ; = alpha * 256 + y + alpha * y * y
13496                                                                          ;
13497                                                                          ; i.e. y = y + alpha / 256 + alpha * y^2, which is
13498                                                                          ; result 6 above
13499                                                                          ;
13500                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
13501                                                                          ; ZZ, which will remove the old stardust particle, as we
13502                                                                          ; set X1, Y1 and ZZ to the original values for this
13503                                                                          ; particle during the calculations above
13504               
13505                                                                          ; We now have our newly moved stardust particle at
13506                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
13507                                                                          ; and distance z_hi, so we draw it if it's still on
13508                                                                          ; screen, otherwise we recycle it as a new bit of
13509                                                                          ; stardust and draw that
13510               
13511 403C D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     403E 0025     
13512 4040 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; the new x-coordinate is in (x_hi x_lo) and the high
     4042 034C     
13513 4044 D80D  30        movb ra,@X1                     ; STA X1            ; byte is in X1
     4046 0031     
13514               
13515 4048 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 116 then jump to KILL2 to recycle this
     404A 7F00     
13516 404C 028D  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the side of the screen,
     404E 7400     
13517 4050 1834  14        joc  KILL2                      ; BCS KILL2         ; and rejoin at STC2 with the new particle
13518               
13519 4052 D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     4054 0027     
13520 4056 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     4058 0EC2     
13521 405A D80D  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     405C 0032     
13522               
13523 405E 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 116 then jump to ST5 to recycle this
     4060 7F00     
13524 4062 028D  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the top or bottom of the
     4064 7400     
13525 4066 183A  14        joc  ST5                        ; BCS ST5           ; screen, and rejoin at STC2 with the new particle
13526               
13527               STC2:
13528 4068 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     406A 276C     
13529 406C 06A0  32        bl   @jsr                       ;
     406E FE1E     
13530                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
13531                                                                          ; with distance z_hi
13532               
13533 4070 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
13534                                                                          ; stardust particle
13535               
13536 4072 1302  14        jeq  ST2                        ; BEQ ST2           ; If we have just done the last particle, skip the next
13537                                                                          ; instruction to return from the subroutine
13538               
13539 4074 0460  28        b    @STL2                      ; JMP STL2          ; We have more stardust to process, so jump back up to
     4076 3F2A     
13540                                                                          ; STL2 for the next particle
13541               
13542                                                                          ; Fall through into ST2 to restore the signs of the
13543                                                                          ; following if this is the right view: ALPHA, ALP2,
13544                                                                          ; ALP2+1, BET2 and BET2+1
13545               
13546               ST2:
13547 4078 D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; If this is the right view, flip the sign of ALPHA
     407A 009E     
13548                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 407C D020  30        movb @RAT,rtmp
     407E 00AA     
0002 4080 2B40  18        xor  rtmp,ra
                   < elite.a99
13549 4082 D80D  30        movb ra,@ALPHA                  ; STA ALPHA
     4084 009E     
13550               
13551 4086 D360  30        movb @ALP2,ra                   ; LDA ALP2          ; If this is the right view, flip the sign of ALP2
     4088 0088     
13552                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 408A D020  30        movb @RAT,rtmp
     408C 00AA     
0002 408E 2B40  18        xor  rtmp,ra
                   < elite.a99
13553 4090 D80D  30        movb ra,@ALP2                   ; STA ALP2
     4092 0088     
13554               
13555                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of ALP2+1
     **** ****     > EOI
0001 4094 0200  20        li   rtmp,(>80*256)
     4096 8000     
0002 4098 2B40  18        xor  rtmp,ra
                   < elite.a99
13556 409A D80D  30        movb ra,@ALP2+1                 ; STA ALP2+1
     409C 0089     
13557               
13558 409E D360  30        movb @BET2,ra                   ; LDA BET2          ; If this is the right view, flip the sign of BET2
     40A0 008A     
13559                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 40A2 D020  30        movb @RAT,rtmp
     40A4 00AA     
0002 40A6 2B40  18        xor  rtmp,ra
                   < elite.a99
13560 40A8 D80D  30        movb ra,@BET2                   ; STA BET2
     40AA 008A     
13561               
13562                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of BET2+1
     **** ****     > EOI
0001 40AC 0200  20        li   rtmp,(>80*256)
     40AE 8000     
0002 40B0 2B40  18        xor  rtmp,ra
                   < elite.a99
13563 40B2 D80D  30        movb ra,@BET2+1                 ; STA BET2+1
     40B4 008B     
13564               
13565 40B6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     40B8 FE2A     
13566               
13567               KILL2:
13568 40BA 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     40BC C07C     
13569 40BE 06A0  32        bl   @jsr                       ;
     40C0 FE1E     
13570               
13571 40C2 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     40C4 0032     
13572 40C6 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along the y-axis
     40C8 0EC2     
13573               
13574 40CA 020D  20        li   ra,>73*256                 ; LDA #115          ; Make sure A is at least 115 and has the sign in RAT
     40CC 7300     
13575 40CE F360  30        socb @RAT,ra                    ; ORA RAT
     40D0 00AA     
13576               
13577 40D2 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on the
     40D4 0031     
13578 40D6 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; correct edge of the screen for new particles
     40D8 034C     
13579               
13580 40DA 1610  14        jne  STF1                       ; BNE STF1          ; Jump down to STF1 to set the z-coordinate (this BNE is
13581                                                                          ; effectively a JMP as A will never be zero)
13582               
13583               ST5:
13584 40DC 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     40DE C07C     
13585 40E0 06A0  32        bl   @jsr                       ;
     40E2 FE1E     
13586               
13587 40E4 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     40E6 0031     
13588 40E8 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     40EA 034C     
13589               
13590 40EC 020D  20        li   ra,>6e*256                 ; LDA #110          ; Make sure A is at least 110 and has the sign in AL2+1,
     40EE 6E00     
13591 40F0 F360  30        socb @ALP2+1,ra                 ; ORA ALP2+1        ; the flipped sign of the roll angle alpha
     40F2 0089     
13592               
13593 40F4 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts at the
     40F6 0032     
13594 40F8 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; top or bottom edge, depending on the current roll
     40FA 0EC2     
13595                                                                          ; angle alpha
13596               
13597               STF1:
13598 40FC 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     40FE C07C     
13599 4100 06A0  32        bl   @jsr                       ;
     4102 FE1E     
13600               
13601 4104 026D  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in z_hi and
     4106 0800     
13602 4108 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; ZZ, so the new particle starts at any distance from
     410A 0097     
13603 410C DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; us, but not too close
     410E 0EE8     
13604               
13605 4110 16AB  14        jne  STC2                       ; BNE STC2          ; Jump up to STC2 to draw this new particle (this BNE is
13606                                                                          ; effectively a JMP as A will never be zero)
13607               
13608               * ******************************************************************************
13609               *
13610               * Name: SNE
13611               * Type: Variable
13612               * Category: Maths (Geometry)
13613               * Summary: Sine/cosine table
13614               * Deep dive: The sine, cosine and arctan tables
13615               * Drawing circles
13616               * Drawing ellipses
13617               *
13618               * ------------------------------------------------------------------------------
13619               *
13620               * This lookup table contains sine values for the first half of a circle, from 0
13621               * to 180 degrees (0 to PI radians). In terms of circle or ellipse line segments,
13622               * there are 64 segments in a circle, so this contains sine values for segments
13623               * 0 to 31.
13624               *
13625               * In terms of segments, to calculate the sine of the angle at segment x, we look
13626               * up the value in SNE + x, and to calculate the cosine of the angle we look up
13627               * the value in SNE + ((x + 16) mod 32).
13628               *
13629               * In terms of radians, to calculate the following:
13630               *
13631               * sin(theta) * 256
13632               *
13633               * where theta is in radians, we look up the value in:
13634               *
13635               * SNE + (theta * 10)
13636               *
13637               * To calculate the following:
13638               *
13639               * cos(theta) * 256
13640               *
13641               * where theta is in radians, look up the value in:
13642               *
13643               * SNE + ((theta * 10) + 16) mod 32
13644               *
13645               * Theta must be between 0 and 3.1 radians, so theta * 10 is between 0 and 31.
13646               *
13647               * ******************************************************************************
13648               
13649               SNE:
13650                      ; FOR I%, 0, 31
13651               
13652                      ; N = ABS(SIN((I% / 64) * 2 * PI)) ;
13653               
13654                      ; IF N >= 1                     ;
13655                      ; B% = 255                      ;
13656                      ; ELSE                          ;
13657                      ; B% = INT(256 * N + 0.5)       ;
13658                      ; ENDIF                         ;
13659               
13660                      ; EQUB B%                       ;
13661               
13662                      ; NEXT
13663               
13664 4112 00              byte >00
13665 4113   19            byte >19
13666 4114 32              byte >32
13667 4115   4A            byte >4a
13668 4116 62              byte >62
13669 4117   79            byte >79
13670 4118 8E              byte >8e
13671 4119   A2            byte >a2
13672 411A B5              byte >b5
13673 411B   C6            byte >c6
13674 411C D5              byte >d5
13675 411D   E2            byte >e2
13676 411E ED              byte >ed
13677 411F   F5            byte >f5
13678 4120 FB              byte >fb
13679 4121   FF            byte >ff
13680 4122 FF              byte >ff
13681 4123   FF            byte >ff
13682 4124 FB              byte >fb
13683 4125   F5            byte >f5
13684 4126 ED              byte >ed
13685 4127   E2            byte >e2
13686 4128 D5              byte >d5
13687 4129   C6            byte >c6
13688 412A B5              byte >b5
13689 412B   A2            byte >a2
13690 412C 8E              byte >8e
13691 412D   79            byte >79
13692 412E 62              byte >62
13693 412F   4A            byte >4a
13694 4130 32              byte >32
13695 4131   19            byte >19
13696               
13697               * ******************************************************************************
13698               *
13699               * Name: MU5
13700               * Type: Subroutine
13701               * Category: Maths (Arithmetic)
13702               * Summary: Set K(3 2 1 0) = (A A A A) and clear the C flag
13703               *
13704               * ------------------------------------------------------------------------------
13705               *
13706               * In practice this is only called via a BEQ following an AND instruction, in
13707               * which case A = 0, so this routine effectively does this:
13708               *
13709               * K(3 2 1 0) = 0
13710               *
13711               * ******************************************************************************
13712               
13713               MU5:
13714 4132 D80D  30        movb ra,@K                      ; STA K             ; Set K(3 2 1 0) to (A A A A)
     4134 003D     
13715 4136 D80D  30        movb ra,@K+1                    ; STA K+1
     4138 003E     
13716 413A D80D  30        movb ra,@K+2                    ; STA K+2
     413C 003F     
13717 413E D80D  30        movb ra,@K+3                    ; STA K+3
     4140 0040     
13718               
13719                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 4142 0A16  18        sla  rzero,1
                   < elite.a99
13720               
13721 4144 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4146 FE2A     
13722               
13723               * ******************************************************************************
13724               *
13725               * Name: MULT3
13726               * Type: Subroutine
13727               * Category: Maths (Arithmetic)
13728               * Summary: Calculate K(3 2 1 0) = (A P+1 P) * Q
13729               * Deep dive: Shift-and-add multiplication
13730               *
13731               * ------------------------------------------------------------------------------
13732               *
13733               * Calculate the following multiplication between a signed 24-bit number and a
13734               * signed 8-bit number, returning the result as a signed 32-bit number:
13735               *
13736               * K(3 2 1 0) = (A P+1 P) * Q
13737               *
13738               * The algorithm is the same shift-and-add algorithm as in routine MULT1, but
13739               * extended to cope with more bits.
13740               *
13741               * ------------------------------------------------------------------------------
13742               *
13743               * Returns:
13744               *
13745               * C flag              The C flag is cleared
13746               *
13747               * ******************************************************************************
13748               
13749               MULT3:
13750 4148 D80D  30        movb ra,@R                      ; STA R             ; Store the high byte of (A P+1 P) in R
     414A 0091     
13751               
13752 414C 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K+2 to |A|, the high byte of K(2 1 0)
     414E 7F00     
13753 4150 D80D  30        movb ra,@K+2                    ; STA K+2
     4152 003F     
13754               
13755 4154 D360  30        movb @Q,ra                      ; LDA Q             ; Set A to bits 0-6 of Q, so A = |Q|
     4156 0090     
13756 4158 024D  22        andi ra,>7f*256                 ; AND #%01111111
     415A 7F00     
13757               
13758 415C 13EA  14        jeq  MU5                        ; BEQ MU5           ; If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
13759                                                                          ; returning from the subroutine using a tail call
13760               
13761                      .sec                            ; SEC               ; Set T = |Q| - 1
     **** ****     > SEC
0001 415E 0A18  18        sla  rmone,1
                   < elite.a99
13762                      .sbi (>01*256)                  ; SBC #1
     **** ****     > SBI
0001 4160 1801  14        joc  !
0002 4162 7347  18        sb   rone,ra
0003               !:
0004 4164 022D  22        ai   ra,-(>01*256)
     4166 FF00     
                   < elite.a99
13763 4168 D80D  30        movb ra,@T                      ; STA T
     416A 00D1     
13764               
13765                                                                          ; We now use the same shift-and-add algorithm as MULT1
13766                                                                          ; to calculate the following:
13767                                                                          ;
13768                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
13769                                                                          ;
13770                                                                          ; so we start with the first shift right, in which we
13771                                                                          ; take (K+2 P+1 P) and shift it right, storing the
13772                                                                          ; result in K(2 1 0), ready for the multiplication loop
13773                                                                          ; (so the multiplication loop actually calculates
13774                                                                          ; (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
13775                                                                          ; (|A| P+1 P) shifted right)
13776               
13777 416C D360  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1
     416E 001C     
13778               
13779                      .lsr @K+2                       ; LSR K+2           ; Shift the high byte in K+2 to the right
     **** ****     > LSR
0001 4170 D020  30        movb @K+2,rtmp
     4172 003F     
0002 4174 0910  18        srl  rtmp,1
0003 4176 D800  30        movb rtmp,@K+2
     4178 003F     
                   < elite.a99
13780               
13781 417A 06A0  32        bl   @rora                      ; ROR A             ; Shift the middle byte in A to the right and store in
     417C FE58     
13782 417E D80D  30        movb ra,@K+1                    ; STA K+1           ; K+1 (so K+1 contains P+1 shifted right)
     4180 003E     
13783               
13784 4182 D360  30        movb @P,ra                      ; LDA P             ; Shift the middle byte in P to the right and store in
     4184 001B     
13785 4186 06A0  32        bl   @rora                      ; ROR A             ; K, so K(2 1 0) now contains (|A| P+1 P) shifted right
     4188 FE58     
13786 418A D80D  30        movb ra,@K                      ; STA K
     418C 003D     
13787               
13788                                                                          ; We now use the same shift-and-add algorithm as MULT1
13789                                                                          ; to calculate the following:
13790                                                                          ;
13791                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
13792               
13793 418E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4190 0000     
13794               
13795 4192 020E  20        li   rx,>18*256                 ; LDX #24           ; Set up a counter in X to count the 24 bits in K(2 1 0)
     4194 1800     
13796               
13797               MUL2:
13798 4196 1704  14        jnc  B38                        ; BCC B38           ; If C (i.e. the next bit from K) is set, do the
13799                      .adc @T,ra                      ; ADC T             ; addition for this bit of K:
     **** ****     > ADC
0001 4198 1701  14        jnc  !
0002 419A B347  18        ab   rone,ra
0003               !:
0004 419C B360  30        ab   @T,ra
     419E 00D1     
                   < elite.a99
13800                                                                          ;
13801                                                                          ; A = A + T + C
13802                                                                          ; = A + |Q| - 1 + 1
13803                                                                          ; = A + |Q|
13804               
13805               B38:
13806 41A0 06A0  32        bl   @rora                      ; ROR A             ; Shift A right by one place to catch the next digit
     41A2 FE58     
13807 41A4 0204  20        li   rarg1,K+2                  ; ROR K+2           ; next digit of our result in the left end of K(2 1 0),
     41A6 003F     
13808 41A8 06A0  32        bl   @ror                       ;
     41AA FE70     
13809 41AC 0204  20        li   rarg1,K+1                  ; ROR K+1           ; while also shifting K(2 1 0) right to fetch the next
     41AE 003E     
13810 41B0 06A0  32        bl   @ror                       ;
     41B2 FE70     
13811 41B4 0204  20        li   rarg1,K                    ; ROR K             ; bit for the calculation into the C flag
     41B6 003D     
13812 41B8 06A0  32        bl   @ror                       ;
     41BA FE70     
13813                                                                          ;
13814                                                                          ; On the last iteration of this loop, the bit falling
13815                                                                          ; off the end of K will be bit 0 of the original A, as
13816                                                                          ; we did one shift before the loop and we are doing 24
13817                                                                          ; iterations. We set A to 0 before looping, so this
13818                                                                          ; means the loop exits with the C flag clear
13819               
13820 41BC 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
13821               
13822 41BE 16EB  14        jne  MUL2                       ; BNE MUL2          ; Loop back for the next bit until K(2 1 0) has been
13823                                                                          ; rotated all the way
13824               
13825                                                                          ; The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
13826                                                                          ; but it is positive and doesn't have the correct sign
13827                                                                          ; of the final result yet
13828               
13829 41C0 D80D  30        movb ra,@T                      ; STA T             ; Save the high byte of the result into T
     41C2 00D1     
13830               
13831 41C4 D360  30        movb @R,ra                      ; LDA R             ; Fetch the sign byte from the original (A P+1 P)
     41C6 0091     
13832                                                                          ; argument that we stored in R
13833               
13834                      .eor @Q                         ; EOR Q             ; EOR with Q so the sign bit is the same as that of
     **** ****     > EOR
0001 41C8 D020  30        movb @Q,rtmp
     41CA 0090     
0002 41CC 2B40  18        xor  rtmp,ra
                   < elite.a99
13835                                                                          ; (A P+1 P) * Q
13836               
13837 41CE 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign bit
     41D0 8000     
13838               
13839 41D2 F360  30        socb @T,ra                      ; ORA T             ; Apply this to the high byte of the result in T, so
     41D4 00D1     
13840                                                                          ; that A now has the correct sign for the result, and
13841                                                                          ; (A K+2 K+1 K) therefore contains the correctly signed
13842                                                                          ; result
13843               
13844 41D6 D80D  30        movb ra,@K+3                    ; STA K+3           ; Store A in K+3, so K(3 2 1 0) now contains the result
     41D8 0040     
13845               
13846 41DA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     41DC FE2A     
13847               
13848               * ******************************************************************************
13849               *
13850               * Name: MLS2
13851               * Type: Subroutine
13852               * Category: Maths (Arithmetic)
13853               * Summary: Calculate (S R) = XX(1 0) and (A P) = A * ALP1
13854               *
13855               * ------------------------------------------------------------------------------
13856               *
13857               * Calculate the following:
13858               *
13859               * (S R) = XX(1 0)
13860               *
13861               * (A P) = A * ALP1
13862               *
13863               * where ALP1 is the magnitude of the current roll angle alpha, in the range
13864               * 0-31.
13865               *
13866               * ******************************************************************************
13867               
13868               MLS2:
13869 41DE D3A0  30        movb @XX,rx                     ; LDX XX            ; Set (S R) = XX(1 0), starting with the low bytes
     41E0 0024     
13870 41E2 D80E  30        movb rx,@R                      ; STX R
     41E4 0091     
13871               
13872 41E6 D3A0  30        movb @XX+1,rx                   ; LDX XX+1          ; And then doing the high bytes
     41E8 0025     
13873 41EA D80E  30        movb rx,@S                      ; STX S
     41EC 0092     
13874               
13875                                                                          ; Fall through into MLS1 to calculate (A P) = A * ALP1
13876               
13877               * ******************************************************************************
13878               *
13879               * Name: MLS1
13880               * Type: Subroutine
13881               * Category: Maths (Arithmetic)
13882               * Summary: Calculate (A P) = ALP1 * A
13883               *
13884               * ------------------------------------------------------------------------------
13885               *
13886               * Calculate the following:
13887               *
13888               * (A P) = ALP1 * A
13889               *
13890               * where ALP1 is the magnitude of the current roll angle alpha, in the range
13891               * 0-31.
13892               *
13893               * This routine uses an unrolled version of MU11. MU11 calculates P * X, so we
13894               * use the same algorithm but with P set to ALP1 and X set to A. The unrolled
13895               * version here can skip the bit tests for bits 5-7 of P as we know P < 32, so
13896               * only 5 shifts with bit tests are needed (for bits 0-4), while the other 3
13897               * shifts can be done without a test (for bits 5-7).
13898               *
13899               * ------------------------------------------------------------------------------
13900               *
13901               * Other entry points:
13902               *
13903               * MULTS-2             Calculate (A P) = X * A
13904               *
13905               * ******************************************************************************
13906               
13907               MLS1:
13908 41EE D3A0  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P to the roll angle alpha magnitude in ALP1
     41F0 0087     
13909 41F2 D80E  30        movb rx,@P                      ; STX P             ; (0-31), so now we calculate P * A
     41F4 001B     
13910               
13911               MULTS:
13912 41F6 D38D  18        movb ra,rx                      ; TAX               ; Set X = A, so now we can calculate P * X instead of
13913                                                                          ; P * A to get our result, and we can use the algorithm
13914                                                                          ; from MU11 to do that, just unrolled (as MU11 returns
13915                                                                          ; P * X)
13916               
13917 41F8 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Set T to the sign bit of A
     41FA 8000     
13918 41FC D80D  30        movb ra,@T                      ; STA T
     41FE 00D1     
13919               
13920 4200 D34E  18        movb rx,ra                      ; TXA               ; Set A = |A|
13921 4202 024D  22        andi ra,>7f*256                 ; AND #127
     4204 7F00     
13922               
13923 4206 1602  14        jne  FIX003                     ; BNE FIX003        ; If A = 0, jump to MU6 to set P(1 0) = 0 and return
13924                                                                          ; from the subroutine using a tail call
13925 4208 0460  28        b    @MU6                       ; JMP MU6
     420A 431A     
13926               FIX003:
13927 420C D38D  18        movb ra,rx                      ; TAX               ; Set T1 = X - 1
13928 420E 7387  18        sb   rone,rx                    ; DEX               ;
13929 4210 D80E  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     4212 0006     
13930                                                                          ; to do an addition in the loop below
13931               
13932 4214 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4216 0000     
13933               
13934                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 4218 D020  30        movb @P,rtmp
     421A 001B     
0002 421C 0910  18        srl  rtmp,1
0003 421E D800  30        movb rtmp,@P
     4220 001B     
                   < elite.a99
13935                                                                          ; and C flag = bit 0 of P
13936               
13937                                                                          ; We are now going to work our way through the bits of
13938                                                                          ; P, and do a shift-add for any bits that are set,
13939                                                                          ; keeping the running total in A, but instead of using a
13940                                                                          ; loop like MU11, we just unroll it, starting with bit 0
13941               
13942 4222 1704  14        jnc  B39                        ; BCC B39           ; If C (i.e. the next bit from P) is set, do the
13943                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 4224 1701  14        jnc  !
0002 4226 B347  18        ab   rone,ra
0003               !:
0004 4228 B360  30        ab   @T1,ra
     422A 0006     
                   < elite.a99
13944                                                                          ;
13945                                                                          ; A = A + T1 + C
13946                                                                          ; = A + X - 1 + 1
13947                                                                          ; = A + X
13948               
13949               B39:
13950 422C 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     422E FE58     
13951                                                                          ; which the next ROR sticks into the left end of P while
13952                                                                          ; also extracting the next bit of P
13953               
13954 4230 0204  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     4232 001B     
13955 4234 06A0  32        bl   @ror                       ;
     4236 FE70     
13956                                                                          ; the start of P, and shift P right to fetch the next
13957                                                                          ; bit for the calculation into the C flag
13958               
13959 4238 1704  14        jnc  B40                        ; BCC B40           ; Repeat the shift-and-add loop for bit 1
13960                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 423A 1701  14        jnc  !
0002 423C B347  18        ab   rone,ra
0003               !:
0004 423E B360  30        ab   @T1,ra
     4240 0006     
                   < elite.a99
13961               B40:
13962 4242 06A0  32        bl   @rora                      ; ROR A
     4244 FE58     
13963 4246 0204  20        li   rarg1,P                    ; ROR P
     4248 001B     
13964 424A 06A0  32        bl   @ror                       ;
     424C FE70     
13965               
13966 424E 1704  14        jnc  B41                        ; BCC B41           ; Repeat the shift-and-add loop for bit 2
13967                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 4250 1701  14        jnc  !
0002 4252 B347  18        ab   rone,ra
0003               !:
0004 4254 B360  30        ab   @T1,ra
     4256 0006     
                   < elite.a99
13968               B41:
13969 4258 06A0  32        bl   @rora                      ; ROR A
     425A FE58     
13970 425C 0204  20        li   rarg1,P                    ; ROR P
     425E 001B     
13971 4260 06A0  32        bl   @ror                       ;
     4262 FE70     
13972               
13973 4264 1704  14        jnc  B42                        ; BCC B42           ; Repeat the shift-and-add loop for bit 3
13974                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 4266 1701  14        jnc  !
0002 4268 B347  18        ab   rone,ra
0003               !:
0004 426A B360  30        ab   @T1,ra
     426C 0006     
                   < elite.a99
13975               B42:
13976 426E 06A0  32        bl   @rora                      ; ROR A
     4270 FE58     
13977 4272 0204  20        li   rarg1,P                    ; ROR P
     4274 001B     
13978 4276 06A0  32        bl   @ror                       ;
     4278 FE70     
13979               
13980 427A 1704  14        jnc  B43                        ; BCC B43           ; Repeat the shift-and-add loop for bit 4
13981                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 427C 1701  14        jnc  !
0002 427E B347  18        ab   rone,ra
0003               !:
0004 4280 B360  30        ab   @T1,ra
     4282 0006     
                   < elite.a99
13982               B43:
13983 4284 06A0  32        bl   @rora                      ; ROR A
     4286 FE58     
13984 4288 0204  20        li   rarg1,P                    ; ROR P
     428A 001B     
13985 428C 06A0  32        bl   @ror                       ;
     428E FE70     
13986               
13987 4290 091D  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 5
13988 4292 0204  20        li   rarg1,P                    ; ROR P
     4294 001B     
13989 4296 06A0  32        bl   @ror                       ;
     4298 FE70     
13990               
13991 429A 091D  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 6
13992 429C 0204  20        li   rarg1,P                    ; ROR P
     429E 001B     
13993 42A0 06A0  32        bl   @ror                       ;
     42A2 FE70     
13994               
13995 42A4 091D  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 7
13996 42A6 0204  20        li   rarg1,P                    ; ROR P
     42A8 001B     
13997 42AA 06A0  32        bl   @ror                       ;
     42AC FE70     
13998               
13999 42AE F360  30        socb @T,ra                      ; ORA T             ; Give A the sign bit of the original argument A that
     42B0 00D1     
14000                                                                          ; we put into T above
14001               
14002 42B2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     42B4 FE2A     
14003               
14004               * ******************************************************************************
14005               *
14006               * Name: SQUA
14007               * Type: Subroutine
14008               * Category: Maths (Arithmetic)
14009               * Summary: Clear bit 7 of A and calculate (A P) = A * A
14010               *
14011               * ------------------------------------------------------------------------------
14012               *
14013               * Do the following multiplication of unsigned 8-bit numbers, after first
14014               * clearing bit 7 of A:
14015               *
14016               * (A P) = A * A
14017               *
14018               * ******************************************************************************
14019               
14020               SQUA:
14021 42B6 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 of A and fall through into SQUA2 to set
     42B8 7F00     
14022                                                                          ; (A P) = A * A
14023               
14024               * ******************************************************************************
14025               *
14026               * Name: SQUA2
14027               * Type: Subroutine
14028               * Category: Maths (Arithmetic)
14029               * Summary: Calculate (A P) = A * A
14030               *
14031               * ------------------------------------------------------------------------------
14032               *
14033               * Do the following multiplication of unsigned 8-bit numbers:
14034               *
14035               * (A P) = A * A
14036               *
14037               * ******************************************************************************
14038               
14039               SQUA2:
14040 42BA D80D  30        movb ra,@P                      ; STA P             ; Copy A into P and X
     42BC 001B     
14041 42BE D38D  18        movb ra,rx                      ; TAX
14042               
14043 42C0 1611  14        jne  MU11                       ; BNE MU11          ; If X = 0 fall through into MU1 to return a 0,
14044                                                                          ; otherwise jump to MU11 to return P * X
14045               
14046               * ******************************************************************************
14047               *
14048               * Name: MU1
14049               * Type: Subroutine
14050               * Category: Maths (Arithmetic)
14051               * Summary: Copy X into P and A, and clear the C flag
14052               *
14053               * ------------------------------------------------------------------------------
14054               *
14055               * Used to return a 0 result quickly from MULTU below.
14056               *
14057               * ******************************************************************************
14058               
14059               MU1:
14060                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 42C2 0A16  18        sla  rzero,1
                   < elite.a99
14061               
14062 42C4 D80E  30        movb rx,@P                      ; STX P             ; Copy X into P and A
     42C6 001B     
14063 42C8 D34E  18        movb rx,ra                      ; TXA
14064               
14065 42CA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     42CC FE2A     
14066               
14067               * ******************************************************************************
14068               *
14069               * Name: MLU1
14070               * Type: Subroutine
14071               * Category: Maths (Arithmetic)
14072               * Summary: Calculate Y1 = y_hi and (A P) = |y_hi| * Q for Y-th stardust
14073               *
14074               * ------------------------------------------------------------------------------
14075               *
14076               * Do the following assignment, and multiply the Y-th stardust particle's
14077               * y-coordinate with an unsigned number Q:
14078               *
14079               * Y1 = y_hi
14080               *
14081               * (A P) = |y_hi| * Q
14082               *
14083               * ******************************************************************************
14084               
14085               MLU1:
14086 42CE D36F  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set Y1 the Y-th byte of SY
     42D0 0EC2     
14087 42D2 D80D  30        movb ra,@Y1                     ; STA Y1
     42D4 0032     
14088               
14089                                                                          ; Fall through into MLU2 to calculate:
14090                                                                          ;
14091                                                                          ; (A P) = |A| * Q
14092               
14093               * ******************************************************************************
14094               *
14095               * Name: MLU2
14096               * Type: Subroutine
14097               * Category: Maths (Arithmetic)
14098               * Summary: Calculate (A P) = |A| * Q
14099               *
14100               * ------------------------------------------------------------------------------
14101               *
14102               * Do the following multiplication of a sign-magnitude 8-bit number P with an
14103               * unsigned number Q:
14104               *
14105               * (A P) = |A| * Q
14106               *
14107               * ******************************************************************************
14108               
14109               MLU2:
14110 42D6 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit in P, so P = |A|
     42D8 7F00     
14111 42DA D80D  30        movb ra,@P                      ; STA P
     42DC 001B     
14112               
14113                                                                          ; Fall through into MULTU to calculate:
14114                                                                          ;
14115                                                                          ; (A P) = P * Q
14116                                                                          ; = |A| * Q
14117               
14118               * ******************************************************************************
14119               *
14120               * Name: MULTU
14121               * Type: Subroutine
14122               * Category: Maths (Arithmetic)
14123               * Summary: Calculate (A P) = P * Q
14124               *
14125               * ------------------------------------------------------------------------------
14126               *
14127               * Do the following multiplication of unsigned 8-bit numbers:
14128               *
14129               * (A P) = P * Q
14130               *
14131               * ******************************************************************************
14132               
14133               MULTU:
14134 42DE D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X = Q
     42E0 0090     
14135               
14136 42E2 13EF  14        jeq  MU1                        ; BEQ MU1           ; If X = Q = 0, jump to MU1 to copy X into P and A,
14137                                                                          ; clear the C flag and return from the subroutine using
14138                                                                          ; a tail call
14139               
14140                                                                          ; Otherwise fall through into MU11 to set (A P) = P * X
14141               
14142               * ******************************************************************************
14143               *
14144               * Name: MU11
14145               * Type: Subroutine
14146               * Category: Maths (Arithmetic)
14147               * Summary: Calculate (A P) = P * X
14148               * Deep dive: Shift-and-add multiplication
14149               *
14150               * ------------------------------------------------------------------------------
14151               *
14152               * Do the following multiplication of two unsigned 8-bit numbers:
14153               *
14154               * (A P) = P * X
14155               *
14156               * This uses the same shift-and-add approach as MULT1, but it's simpler as we
14157               * are dealing with unsigned numbers in P and X. See the deep dive on
14158               * "Shift-and-add multiplication" for a discussion of how this algorithm works.
14159               *
14160               * ******************************************************************************
14161               
14162               MU11:
14163 42E4 7387  18        sb   rone,rx                    ; DEX               ; Set T = X - 1
14164 42E6 D80E  30        movb rx,@T                      ; STX T             ;
     42E8 00D1     
14165                                                                          ; We subtract 1 as the C flag will be set when we want
14166                                                                          ; to do an addition in the loop below
14167               
14168 42EA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     42EC 0000     
14169               
14170 42EE 020E  20        li   rx,>08*256                 ; LDX #8            ; Set up a counter in X to count the 8 bits in P
     42F0 0800     
14171               
14172                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 42F2 D020  30        movb @P,rtmp
     42F4 001B     
0002 42F6 0910  18        srl  rtmp,1
0003 42F8 D800  30        movb rtmp,@P
     42FA 001B     
                   < elite.a99
14173                                                                          ; and C flag = bit 0 of P
14174               
14175                                                                          ; We are now going to work our way through the bits of
14176                                                                          ; P, and do a shift-add for any bits that are set,
14177                                                                          ; keeping the running total in A. We just did the first
14178                                                                          ; shift right, so we now need to do the first add and
14179                                                                          ; loop through the other bits in P
14180               
14181               MUL6:
14182 42FC 1704  14        jnc  B44                        ; BCC B44           ; If C (i.e. the next bit from P) is set, do the
14183                      .adc @T,ra                      ; ADC T             ; addition for this bit of P:
     **** ****     > ADC
0001 42FE 1701  14        jnc  !
0002 4300 B347  18        ab   rone,ra
0003               !:
0004 4302 B360  30        ab   @T,ra
     4304 00D1     
                   < elite.a99
14184                                                                          ;
14185                                                                          ; A = A + T + C
14186                                                                          ; = A + X - 1 + 1
14187                                                                          ; = A + X
14188               
14189               B44:
14190 4306 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     4308 FE58     
14191                                                                          ; which the next ROR sticks into the left end of P while
14192                                                                          ; also extracting the next bit of P
14193               
14194 430A 0204  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     430C 001B     
14195 430E 06A0  32        bl   @ror                       ;
     4310 FE70     
14196                                                                          ; the start of P, and shift P right to fetch the next
14197                                                                          ; bit for the calculation into the C flag
14198               
14199 4312 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14200               
14201 4314 16F3  14        jne  MUL6                       ; BNE MUL6          ; Loop back for the next bit until P has been rotated
14202                                                                          ; all the way
14203               
14204 4316 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4318 FE2A     
14205               
14206               * ******************************************************************************
14207               *
14208               * Name: MU6
14209               * Type: Subroutine
14210               * Category: Maths (Arithmetic)
14211               * Summary: Set P(1 0) = (A A)
14212               *
14213               * ------------------------------------------------------------------------------
14214               *
14215               * In practice this is only called via a BEQ following an AND instruction, in
14216               * which case A = 0, so this routine effectively does this:
14217               *
14218               * P(1 0) = 0
14219               *
14220               * ******************************************************************************
14221               
14222               MU6:
14223 431A D80D  30        movb ra,@P+1                    ; STA P+1           ; Set P(1 0) = (A A)
     431C 001C     
14224 431E D80D  30        movb ra,@P                      ; STA P
     4320 001B     
14225               
14226 4322 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4324 FE2A     
14227               
14228               * ******************************************************************************
14229               *
14230               * Name: FMLTU2
14231               * Type: Subroutine
14232               * Category: Maths (Arithmetic)
14233               * Summary: Calculate A = K * sin(A)
14234               * Deep dive: The sine, cosine and arctan tables
14235               *
14236               * ------------------------------------------------------------------------------
14237               *
14238               * Calculate the following:
14239               *
14240               * A = K * sin(A)
14241               *
14242               * Because this routine uses the sine lookup table SNE, we can also call this
14243               * routine to calculate cosine multiplication. To calculate the following:
14244               *
14245               * A = K * cos(B)
14246               *
14247               * call this routine with B + 16 in the accumulator, as sin(B + 16) = cos(B).
14248               *
14249               * ******************************************************************************
14250               
14251               FMLTU2:
14252 4326 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; Restrict A to bits 0-5 (so it's in the range 0-31)
     4328 1F00     
14253               
14254 432A D38D  18        movb ra,rx                      ; TAX               ; Set Q = sin(A) * 256
14255 432C D36E  34        movb @SNE(rx),ra                ; LDA SNE,X
     432E 4112     
14256 4330 D80D  30        movb ra,@Q                      ; STA Q
     4332 0090     
14257               
14258 4334 D360  30        movb @K,ra                      ; LDA K             ; Set A to the radius in K
     4336 003D     
14259               
14260                                                                          ; Fall through into FMLTU to do the following:
14261                                                                          ;
14262                                                                          ; (A ?) = A * Q
14263                                                                          ; = K * sin(A) * 256
14264                                                                          ;
14265                                                                          ; which is equivalent to:
14266                                                                          ;
14267                                                                          ; A = K * sin(A)
14268               
14269               * ******************************************************************************
14270               *
14271               * Name: FMLTU
14272               * Type: Subroutine
14273               * Category: Maths (Arithmetic)
14274               * Summary: Calculate A = A * Q / 256
14275               *
14276               * ------------------------------------------------------------------------------
14277               *
14278               * Do the following multiplication of two unsigned 8-bit numbers, returning only
14279               * the high byte of the result:
14280               *
14281               * (A ?) = A * Q
14282               *
14283               * or, to put it another way:
14284               *
14285               * A = A * Q / 256
14286               *
14287               * ------------------------------------------------------------------------------
14288               *
14289               * Returns:
14290               *
14291               * C flag              The C flag is set
14292               *
14293               * ******************************************************************************
14294               
14295               FMLTU:
14296                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A, set the C flag and rotate right,
     **** ****     > EOI
0001 4338 0200  20        li   rtmp,(>FF*256)
     433A FF00     
0002 433C 2B40  18        xor  rtmp,ra
                   < elite.a99
14297                      .sec                            ; SEC               ; so the C flag now contains bit 0 of A inverted, and P
     **** ****     > SEC
0001 433E 0A18  18        sla  rmone,1
                   < elite.a99
14298 4340 06A0  32        bl   @rora                      ; ROR A             ; contains A inverted and shifted right by one, with bit
     4342 FE58     
14299 4344 D80D  30        movb ra,@P                      ; STA P             ; 7 set to a 1. We can now use P as our source of bits
     4346 001B     
14300                                                                          ; to shift right, just as in MU11, just with the logic
14301                                                                          ; reversed
14302               
14303 4348 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     434A 0000     
14304               
14305               MUL3:
14306 434C 180E  14        joc  MU7                        ; BCS MU7           ; If C (i.e. the next bit from P) is set, do not do the
14307                                                                          ; addition for this bit of P, and instead skip to MU7
14308                                                                          ; to just do the shifts
14309               
14310                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 434E 1701  14        jnc  !
0002 4350 B347  18        ab   rone,ra
0003               !:
0004 4352 B360  30        ab   @Q,ra
     4354 0090     
                   < elite.a99
14311                                                                          ;
14312                                                                          ; A = A + Q + C
14313                                                                          ; = A + Q
14314               
14315 4356 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result.
     4358 FE58     
14316                                                                          ; If we were interested in the low byte of the result we
14317                                                                          ; would want to save the bit that falls off the end, but
14318                                                                          ; we aren't, so we can ignore it
14319               
14320                      .lsr @P                         ; LSR P             ; Shift P right to fetch the next bit for the
     **** ****     > LSR
0001 435A D020  30        movb @P,rtmp
     435C 001B     
0002 435E 0910  18        srl  rtmp,1
0003 4360 D800  30        movb rtmp,@P
     4362 001B     
                   < elite.a99
14321                                                                          ; calculation into the C flag
14322               
14323 4364 16F3  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14324                                                                          ; (so we loop through the bits of P until we get to the
14325                                                                          ; 1 we inserted before the loop, and then we stop)
14326               
14327                                                                          ; If we get here then the C flag is set as we just
14328                                                                          ; rotated a 1 out of the right end of P
14329               
14330 4366 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4368 FE2A     
14331               
14332               MU7:
14333 436A 091D  18        srl  ra,1                       ; LSR A             ; Shift A right to catch the next digit of our result,
14334                                                                          ; pushing a 0 into bit 7 as we aren't adding anything
14335                                                                          ; here (we can't use a ROR here as the C flag is set, so
14336                                                                          ; a ROR would push a 1 into bit 7)
14337               
14338                      .lsr @P                         ; LSR P             ; Fetch the next bit from P into the C flag
     **** ****     > LSR
0001 436C D020  30        movb @P,rtmp
     436E 001B     
0002 4370 0910  18        srl  rtmp,1
0003 4372 D800  30        movb rtmp,@P
     4374 001B     
                   < elite.a99
14339               
14340 4376 16EA  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14341                                                                          ; (so we loop through the bits of P until we get to the
14342                                                                          ; 1 we inserted before the loop, and then we stop)
14343               
14344                                                                          ; If we get here then the C flag is set as we just
14345                                                                          ; rotated a 1 out of the right end of P
14346               
14347 4378 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     437A FE2A     
14348               
14349               * ******************************************************************************
14350               *
14351               * Name: Unused duplicate of MULTU
14352               * Type: Subroutine
14353               * Category: Maths (Arithmetic)
14354               * Summary: An unused duplicate of the MULTU routine
14355               *
14356               * ------------------------------------------------------------------------------
14357               *
14358               * This is a duplicate of the MULTU routine, but with no entry label, so it can't
14359               * be called by name. It is unused, and could have been culled to save a few
14360               * bytes (24 to be precise), but it's still here, unnamed, unloved and unvisited,
14361               * through no fault of its own.
14362               *
14363               * ******************************************************************************
14364               
14365               * {
14366               * LDX Q
14367               * BEQ MU1
14368               * DEX
14369               * STX T
14370               * LDA #0
14371               * LDX #8
14372               * LSR P
14373               *
14374               * .MUL6
14375               *
14376               * BCC B45
14377               * ADC T
14378               * .B45
14379               * ROR A
14380               * ROR P
14381               * DEX
14382               * BNE MUL6
14383               * RTS
14384               * }
14385               
14386               * ******************************************************************************
14387               *
14388               * Name: MLTU2
14389               * Type: Subroutine
14390               * Category: Maths (Arithmetic)
14391               * Summary: Calculate (A P+1 P) = (A ~P) * Q
14392               * Deep dive: Shift-and-add multiplication
14393               *
14394               * ------------------------------------------------------------------------------
14395               *
14396               * Do the following multiplication of an unsigned 16-bit number and an unsigned
14397               * 8-bit number:
14398               *
14399               * (A P+1 P) = (A ~P) * Q
14400               *
14401               * where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
14402               * words, if you wanted to calculate &1234 * &56, you would:
14403               *
14404               * * Set A to &12
14405               * * Set P to &34 EOR %11111111 = &CB
14406               * * Set Q to &56
14407               *
14408               * before calling MLTU2.
14409               *
14410               * This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
14411               * inverted argument trick to work out whether or not to do an addition, and like
14412               * MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
14413               * extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
14414               * the algorithm is still the shift-and-add approach explained in MULT1, just
14415               * with more bits.
14416               *
14417               * ------------------------------------------------------------------------------
14418               *
14419               * Returns:
14420               *
14421               * Q                   Q is preserved
14422               *
14423               * ------------------------------------------------------------------------------
14424               *
14425               * Other entry points:
14426               *
14427               * MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
14428               *
14429               * ******************************************************************************
14430               
14431 437C D80E  30        movb rx,@Q                      ; STX Q             ; Store X in Q
     437E 0090     
14432               
14433               MLTU2:
14434                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A and rotate right, storing the
     **** ****     > EOI
0001 4380 0200  20        li   rtmp,(>FF*256)
     4382 FF00     
0002 4384 2B40  18        xor  rtmp,ra
                   < elite.a99
14435 4386 091D  18        srl  ra,1                       ; LSR A             ; result in P+1, so we now calculate (P+1 P) * Q
14436 4388 D80D  30        movb ra,@P+1                    ; STA P+1
     438A 001C     
14437               
14438 438C 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     438E 0000     
14439               
14440 4390 020E  20        li   rx,>10*256                 ; LDX #16           ; Set up a counter in X to count the 16 bits in (P+1 P)
     4392 1000     
14441               
14442 4394 0204  20        li   rarg1,P                    ; ROR P             ; Set P = P >> 1 with bit 7 = bit 0 of A
     4396 001B     
14443 4398 06A0  32        bl   @ror                       ;
     439A FE70     
14444                                                                          ; and C flag = bit 0 of P
14445               
14446               MUL7:
14447 439C 1812  14        joc  MU21                       ; BCS MU21          ; If C (i.e. the next bit from P) is set, do not do the
14448                                                                          ; addition for this bit of P, and instead skip to MU21
14449                                                                          ; to just do the shifts
14450               
14451                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 439E 1701  14        jnc  !
0002 43A0 B347  18        ab   rone,ra
0003               !:
0004 43A2 B360  30        ab   @Q,ra
     43A4 0090     
                   < elite.a99
14452                                                                          ;
14453                                                                          ; A = A + Q + C
14454                                                                          ; = A + Q
14455               
14456 43A6 06A0  32        bl   @rora                      ; ROR A             ; Rotate (A P+1 P) to the right, so we capture the next
     43A8 FE58     
14457 43AA 0204  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     43AC 001C     
14458 43AE 06A0  32        bl   @ror                       ;
     43B0 FE70     
14459 43B2 0204  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     43B4 001B     
14460 43B6 06A0  32        bl   @ror                       ;
     43B8 FE70     
14461               
14462 43BA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14463               
14464 43BC 16EF  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14465                                                                          ; all the way
14466               
14467 43BE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     43C0 FE2A     
14468               
14469               MU21:
14470 43C2 091D  18        srl  ra,1                       ; LSR A             ; Shift (A P+1 P) to the right, so we capture the next
14471 43C4 0204  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     43C6 001C     
14472 43C8 06A0  32        bl   @ror                       ;
     43CA FE70     
14473 43CC 0204  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     43CE 001B     
14474 43D0 06A0  32        bl   @ror                       ;
     43D2 FE70     
14475               
14476 43D4 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14477               
14478 43D6 16E2  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14479                                                                          ; all the way
14480               
14481 43D8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     43DA FE2A     
14482               
14483               * ******************************************************************************
14484               *
14485               * Name: MUT3
14486               * Type: Subroutine
14487               * Category: Maths (Arithmetic)
14488               * Summary: An unused routine that does the same as MUT2
14489               *
14490               * ------------------------------------------------------------------------------
14491               *
14492               * This routine is never actually called, but it is identical to MUT2, as the
14493               * extra instructions have no effect.
14494               *
14495               * ******************************************************************************
14496               
14497               MUT3:
14498 43DC D3A0  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P = ALP1, though this gets overwritten by the
     43DE 0087     
14499 43E0 D80E  30        movb rx,@P                      ; STX P             ; following, so this has no effect
     43E2 001B     
14500               
14501                                                                          ; Fall through into MUT2 to do the following:
14502                                                                          ;
14503                                                                          ; (S R) = XX(1 0)
14504                                                                          ; (A P) = Q * A
14505               
14506               * ******************************************************************************
14507               *
14508               * Name: MUT2
14509               * Type: Subroutine
14510               * Category: Maths (Arithmetic)
14511               * Summary: Calculate (S R) = XX(1 0) and (A P) = Q * A
14512               *
14513               * ------------------------------------------------------------------------------
14514               *
14515               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14516               *
14517               * (S R) = XX(1 0)
14518               * (A P) = Q * A
14519               *
14520               * ******************************************************************************
14521               
14522               MUT2:
14523 43E4 D3A0  30        movb @XX+1,rx                   ; LDX XX+1          ; Set S = XX+1
     43E6 0025     
14524 43E8 D80E  30        movb rx,@S                      ; STX S
     43EA 0092     
14525               
14526                                                                          ; Fall through into MUT1 to do the following:
14527                                                                          ;
14528                                                                          ; R = XX
14529                                                                          ; (A P) = Q * A
14530               
14531               * ******************************************************************************
14532               *
14533               * Name: MUT1
14534               * Type: Subroutine
14535               * Category: Maths (Arithmetic)
14536               * Summary: Calculate R = XX and (A P) = Q * A
14537               *
14538               * ------------------------------------------------------------------------------
14539               *
14540               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14541               *
14542               * R = XX
14543               * (A P) = Q * A
14544               *
14545               * ******************************************************************************
14546               
14547               MUT1:
14548 43EC D3A0  30        movb @XX,rx                     ; LDX XX            ; Set R = XX
     43EE 0024     
14549 43F0 D80E  30        movb rx,@R                      ; STX R
     43F2 0091     
14550               
14551                                                                          ; Fall through into MULT1 to do the following:
14552                                                                          ;
14553                                                                          ; (A P) = Q * A
14554               
14555               * ******************************************************************************
14556               *
14557               * Name: MULT1
14558               * Type: Subroutine
14559               * Category: Maths (Arithmetic)
14560               * Summary: Calculate (A P) = Q * A
14561               * Deep dive: Shift-and-add multiplication
14562               *
14563               * ------------------------------------------------------------------------------
14564               *
14565               * Do the following multiplication of two 8-bit sign-magnitude numbers:
14566               *
14567               * (A P) = Q * A
14568               *
14569               * ******************************************************************************
14570               
14571               MULT1:
14572 43F4 D38D  18        movb ra,rx                      ; TAX               ; Store A in X
14573               
14574 43F6 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Set P = |A| >> 1
     43F8 7F00     
14575 43FA 091D  18        srl  ra,1                       ; LSR A             ; and C flag = bit 0 of A
14576 43FC D80D  30        movb ra,@P                      ; STA P
     43FE 001B     
14577               
14578 4400 D34E  18        movb rx,ra                      ; TXA               ; Restore argument A
14579               
14580                      .eor @Q                         ; EOR Q             ; Set bit 7 of A and T if Q and A have different signs,
     **** ****     > EOR
0001 4402 D020  30        movb @Q,rtmp
     4404 0090     
0002 4406 2B40  18        xor  rtmp,ra
                   < elite.a99
14581 4408 024D  22        andi ra,>80*256                 ; AND #%10000000    ; clear bit 7 if they have the same signs, 0 all other
     440A 8000     
14582 440C D80D  30        movb ra,@T                      ; STA T             ; bits, i.e. T contains the sign bit of Q * A
     440E 00D1     
14583               
14584 4410 D360  30        movb @Q,ra                      ; LDA Q             ; Set A = |Q|
     4412 0090     
14585 4414 024D  22        andi ra,>7f*256                 ; AND #%01111111
     4416 7F00     
14586               
14587 4418 131E  14        jeq  mu10_                      ; BEQ mu10          ; If |Q| = 0 jump to mu10 (with A set to 0)
14588               
14589 441A D38D  18        movb ra,rx                      ; TAX               ; Set T1 = |Q| - 1
14590 441C 7387  18        sb   rone,rx                    ; DEX               ;
14591 441E D80E  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     4420 0006     
14592                                                                          ; to do an addition in the loop below
14593               
14594                                                                          ; We are now going to work our way through the bits of
14595                                                                          ; P, and do a shift-add for any bits that are set,
14596                                                                          ; keeping the running total in A. We already set up
14597                                                                          ; the first shift at the start of this routine, as
14598                                                                          ; P = |A| >> 1 and C = bit 0 of A, so we now need to set
14599                                                                          ; up a loop to sift through the other 7 bits in P
14600               
14601 4422 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4424 0000     
14602               
14603 4426 020E  20        li   rx,>07*256                 ; LDX #7            ; Set up a counter in X to count the 7 bits remaining
     4428 0700     
14604                                                                          ; in P
14605               
14606               MUL4:
14607 442A 1704  14        jnc  B46                        ; BCC B46           ; If C (i.e. the next bit from P) is set, do the
14608                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 442C 1701  14        jnc  !
0002 442E B347  18        ab   rone,ra
0003               !:
0004 4430 B360  30        ab   @T1,ra
     4432 0006     
                   < elite.a99
14609                                                                          ;
14610                                                                          ; A = A + T1 + C
14611                                                                          ; = A + |Q| - 1 + 1
14612                                                                          ; = A + |Q|
14613               
14614               B46:
14615 4434 06A0  32        bl   @rora                      ; ROR A             ; As mentioned above, this ROR shifts A right and
     4436 FE58     
14616                                                                          ; catches bit 0 in C - giving another digit for our
14617                                                                          ; result - and the next ROR sticks that bit into the
14618                                                                          ; left end of P while also extracting the next bit of P
14619                                                                          ; for the next addition
14620               
14621 4438 0204  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     443A 001B     
14622 443C 06A0  32        bl   @ror                       ;
     443E FE70     
14623                                                                          ; the start of P, and shift P right to fetch the next
14624                                                                          ; bit for the calculation
14625               
14626 4440 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14627               
14628 4442 16F3  14        jne  MUL4                       ; BNE MUL4          ; Loop back for the next bit until P has been rotated
14629                                                                          ; all the way
14630               
14631 4444 091D  18        srl  ra,1                       ; LSR A             ; Rotate (A P) once more to get the final result, as
14632 4446 0204  20        li   rarg1,P                    ; ROR P             ; we only pushed 7 bits through the above process
     4448 001B     
14633 444A 06A0  32        bl   @ror                       ;
     444C FE70     
14634               
14635 444E F360  30        socb @T,ra                      ; ORA T             ; Set the sign bit of the result that we stored in T
     4450 00D1     
14636               
14637 4452 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4454 FE2A     
14638               
14639               mu10_:
14640 4456 D80D  30        movb ra,@P                      ; STA P             ; If we get here, the result is 0 and A = 0, so set
     4458 001B     
14641                                                                          ; P = 0 so (A P) = 0
14642               
14643 445A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     445C FE2A     
14644               
14645               * ******************************************************************************
14646               *
14647               * Name: MULT12
14648               * Type: Subroutine
14649               * Category: Maths (Arithmetic)
14650               * Summary: Calculate (S R) = Q * A
14651               *
14652               * ------------------------------------------------------------------------------
14653               *
14654               * Calculate:
14655               *
14656               * (S R) = Q * A
14657               *
14658               * ******************************************************************************
14659               
14660               MULT12:
14661 445E 0200  20        li   rtmp,MULT1                 ; JSR MULT1         ; Set (A P) = Q * A
     4460 43F4     
14662 4462 06A0  32        bl   @jsr                       ;
     4464 FE1E     
14663               
14664 4466 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P)
     4468 0092     
14665 446A D360  30        movb @P,ra                      ; LDA P             ; = Q * A
     446C 001B     
14666 446E D80D  30        movb ra,@R                      ; STA R
     4470 0091     
14667               
14668 4472 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4474 FE2A     
14669               
14670               * ******************************************************************************
14671               *
14672               * Name: TAS3
14673               * Type: Subroutine
14674               * Category: Maths (Geometry)
14675               * Summary: Calculate the dot product of XX15 and an orientation vector
14676               *
14677               * ------------------------------------------------------------------------------
14678               *
14679               * Calculate the dot product of the vector in XX15 and one of the orientation
14680               * vectors, as determined by the value of Y. If vect is the orientation vector,
14681               * we calculate this:
14682               *
14683               * (A X) = vect . XX15
14684               * = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
14685               *
14686               * ------------------------------------------------------------------------------
14687               *
14688               * Arguments:
14689               *
14690               * Y                   The orientation vector:
14691               *
14692               * * If Y = 10, calculate nosev . XX15
14693               *
14694               * * If Y = 16, calculate roofv . XX15
14695               *
14696               * * If Y = 22, calculate sidev . XX15
14697               *
14698               * ------------------------------------------------------------------------------
14699               *
14700               * Returns:
14701               *
14702               * (A X)               The result of the dot product
14703               *
14704               * ******************************************************************************
14705               
14706               TAS3:
14707 4476 D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set Q = the Y-th byte of INWK, i.e. vect_x
     4478 0053     
14708 447A D80E  30        movb rx,@Q                      ; STX Q
     447C 0090     
14709               
14710 447E D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     4480 0031     
14711               
14712 4482 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     4484 445E     
14713 4486 06A0  32        bl   @jsr                       ;
     4488 FE1E     
14714                                                                          ; = vect_x * XX15
14715               
14716 448A D3AF  34        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_y
     448C 0055     
14717 448E D80E  30        movb rx,@Q                      ; STX Q
     4490 0090     
14718               
14719 4492 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = XX15+1
     4494 0032     
14720               
14721 4496 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     4498 44B2     
14722 449A 06A0  32        bl   @jsr                       ;
     449C FE1E     
14723                                                                          ; = vect_y * XX15+1 + vect_x * XX15
14724               
14725 449E D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     44A0 0092     
14726 44A2 D80E  30        movb rx,@R                      ; STX R
     44A4 0091     
14727               
14728 44A6 D3AF  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_z
     44A8 0057     
14729 44AA D80E  30        movb rx,@Q                      ; STX Q
     44AC 0090     
14730               
14731 44AE D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     44B0 0033     
14732               
14733                                                                          ; Fall through into MAD to set:
14734                                                                          ;
14735                                                                          ; (A X) = Q * A + (S R)
14736                                                                          ; = vect_z * XX15+2 + vect_y * XX15+1 +
14737                                                                          ; vect_x * XX15
14738               
14739               * ******************************************************************************
14740               *
14741               * Name: MAD
14742               * Type: Subroutine
14743               * Category: Maths (Arithmetic)
14744               * Summary: Calculate (A X) = Q * A + (S R)
14745               *
14746               * ------------------------------------------------------------------------------
14747               *
14748               * Calculate
14749               *
14750               * (A X) = Q * A + (S R)
14751               *
14752               * ******************************************************************************
14753               
14754               MAD:
14755 44B2 0200  20        li   rtmp,MULT1                 ; JSR MULT1         ; Call MULT1 to set (A P) = Q * A
     44B4 43F4     
14756 44B6 06A0  32        bl   @jsr                       ;
     44B8 FE1E     
14757               
14758                                                                          ; Fall through into ADD to do:
14759                                                                          ;
14760                                                                          ; (A X) = (A P) + (S R)
14761                                                                          ; = Q * A + (S R)
14762               
14763               * ******************************************************************************
14764               *
14765               * Name: ADD
14766               * Type: Subroutine
14767               * Category: Maths (Arithmetic)
14768               * Summary: Calculate (A X) = (A P) + (S R)
14769               * Deep dive: Adding sign-magnitude numbers
14770               *
14771               * ------------------------------------------------------------------------------
14772               *
14773               * Add two 16-bit sign-magnitude numbers together, calculating:
14774               *
14775               * (A X) = (A P) + (S R)
14776               *
14777               * ******************************************************************************
14778               
14779               ADD:
14780 44BA D80D  30        movb ra,@T1                     ; STA T1            ; Store argument A in T1
     44BC 0006     
14781               
14782 44BE 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign (bit 7) of A and store it in T
     44C0 8000     
14783 44C2 D80D  30        movb ra,@T                      ; STA T
     44C4 00D1     
14784               
14785                      .eor @S                         ; EOR S             ; EOR bit 7 of A with S. If they have different bit 7s
     **** ****     > EOR
0001 44C6 D020  30        movb @S,rtmp
     44C8 0092     
0002 44CA 2B40  18        xor  rtmp,ra
                   < elite.a99
14786 44CC 1112  14        jlt  MU8                        ; BMI MU8           ; (i.e. they have different signs) then bit 7 in the
14787                                                                          ; EOR result will be 1, which means the EOR result is
14788                                                                          ; negative. So the AND, EOR and BMI together mean "jump
14789                                                                          ; to MU8 if A and S have different signs"
14790               
14791                                                                          ; If we reach here, then A and S have the same sign, so
14792                                                                          ; we can add them and set the sign to get the result
14793               
14794 44CE D360  30        movb @R,ra                      ; LDA R             ; Add the least significant bytes together into X:
     44D0 0091     
14795                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 44D2 0A16  18        sla  rzero,1
                   < elite.a99
14796                      .adc @P,ra                      ; ADC P             ; X = P + R
     **** ****     > ADC
0001 44D4 1701  14        jnc  !
0002 44D6 B347  18        ab   rone,ra
0003               !:
0004 44D8 B360  30        ab   @P,ra
     44DA 001B     
                   < elite.a99
14797 44DC D38D  18        movb ra,rx                      ; TAX
14798               
14799 44DE D360  30        movb @S,ra                      ; LDA S             ; Add the most significant bytes together into A. We
     44E0 0092     
14800                      .adc @T1,ra                     ; ADC T1            ; stored the original argument A in T1 earlier, so we
     **** ****     > ADC
0001 44E2 1701  14        jnc  !
0002 44E4 B347  18        ab   rone,ra
0003               !:
0004 44E6 B360  30        ab   @T1,ra
     44E8 0006     
                   < elite.a99
14801                                                                          ; can do this with:
14802                                                                          ;
14803                                                                          ; A = A  + S + C
14804                                                                          ; = T1 + S + C
14805               
14806 44EA F360  30        socb @T,ra                      ; ORA T             ; If argument A was negative (and therefore S was also
     44EC 00D1     
14807                                                                          ; negative) then make sure result A is negative by
14808                                                                          ; OR'ing the result with the sign bit from argument A
14809                                                                          ; (which we stored in T)
14810               
14811 44EE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     44F0 FE2A     
14812               
14813               MU8:
14814                                                                          ; If we reach here, then A and S have different signs,
14815                                                                          ; so we can subtract their absolute values and set the
14816                                                                          ; sign to get the result
14817 44F2 D360  30        movb @S,ra                      ; LDA S             ; Clear the sign (bit 7) in S and store the result in
     44F4 0092     
14818 44F6 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; U, so U now contains |S|
     44F8 7F00     
14819 44FA D80D  30        movb ra,@U                      ; STA U
     44FC 008F     
14820               
14821 44FE D360  30        movb @P,ra                      ; LDA P             ; Subtract the least significant bytes into X:
     4500 001B     
14822                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 4502 0A18  18        sla  rmone,1
                   < elite.a99
14823                      .sbc @R,ra                      ; SBC R             ; X = P - R
     **** ****     > SBC
0001 4504 1801  14        joc  !
0002 4506 7347  18        sb   rone,ra
0003               !:
0004 4508 7360  30        sb   @R,ra
     450A 0091     
                   < elite.a99
14824 450C D38D  18        movb ra,rx                      ; TAX
14825               
14826 450E D360  30        movb @T1,ra                     ; LDA T1            ; Restore the A of the argument (A P) from T1 and
     4510 0006     
14827 4512 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; clear the sign (bit 7), so A now contains |A|
     4514 7F00     
14828               
14829                      .sbc @U,ra                      ; SBC U             ; Set A = |A| - |S|
     **** ****     > SBC
0001 4516 1801  14        joc  !
0002 4518 7347  18        sb   rone,ra
0003               !:
0004 451A 7360  30        sb   @U,ra
     451C 008F     
                   < elite.a99
14830               
14831                                                                          ; At this point we have |A P| - |S R| in (A X), so we
14832                                                                          ; need to check whether the subtraction above was the
14833                                                                          ; right way round (i.e. that we subtracted the smaller
14834                                                                          ; absolute value from the larger absolute value)
14835               
14836 451E 1813  14        joc  MU9                        ; BCS MU9           ; If |A| >= |S|, our subtraction was the right way
14837                                                                          ; round, so jump to MU9 to set the sign
14838               
14839                                                                          ; If we get here, then |A| < |S|, so our subtraction
14840                                                                          ; above was the wrong way round (we actually subtracted
14841                                                                          ; the larger absolute value from the smaller absolute
14842                                                                          ; value). So let's subtract the result we have in (A X)
14843                                                                          ; from zero, so that the subtraction is the right way
14844                                                                          ; round
14845               
14846 4520 D80D  30        movb ra,@U                      ; STA U             ; Store A in U
     4522 008F     
14847               
14848 4524 D34E  18        movb rx,ra                      ; TXA               ; Set X = 0 - X using two's complement (to negate a
14849                      .eoi (>ff*256)                  ; EOR #&FF          ; number in two's complement, you can invert the bits
     **** ****     > EOI
0001 4526 0200  20        li   rtmp,(>FF*256)
     4528 FF00     
0002 452A 2B40  18        xor  rtmp,ra
                   < elite.a99
14850                      .adi (>01*256)                  ; ADC #1            ; and add one - and we know the C flag is clear as we
     **** ****     > ADI
0001 452C 1701  14        jnc  !
0002 452E B347  18        ab   rone,ra
0003               !:
0004 4530 022D  22        ai   ra,(>01*256)
     4532 0100     
                   < elite.a99
14851 4534 D38D  18        movb ra,rx                      ; TAX               ; didn't take the BCS branch above, so the ADC will do
14852                                                                          ; the correct addition)
14853               
14854 4536 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 - A, which we can do this time using a
     4538 0000     
14855                      .sbc @U,ra                      ; SBC U             ; subtraction with the C flag clear
     **** ****     > SBC
0001 453A 1801  14        joc  !
0002 453C 7347  18        sb   rone,ra
0003               !:
0004 453E 7360  30        sb   @U,ra
     4540 008F     
                   < elite.a99
14856               
14857 4542 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now set the sign bit of A, so that the EOR on the
     4544 8000     
14858                                                                          ; next line will give the result the opposite sign to
14859                                                                          ; argument A (as T contains the sign bit of argument
14860                                                                          ; A). This is the same as giving the result the same
14861                                                                          ; sign as argument S (as A and S have different signs),
14862                                                                          ; which is what we want, as S has the larger absolute
14863                                                                          ; value
14864               
14865               MU9:
14866                      .eor @T                         ; EOR T             ; If we get here from the BCS above, then |A| >= |S|,
     **** ****     > EOR
0001 4546 D020  30        movb @T,rtmp
     4548 00D1     
0002 454A 2B40  18        xor  rtmp,ra
                   < elite.a99
14867                                                                          ; so we want to give the result the same sign as
14868                                                                          ; argument A, so if argument A was negative, we flip
14869                                                                          ; the sign of the result with an EOR (to make it
14870                                                                          ; negative)
14871               
14872 454C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     454E FE2A     
14873               
14874               * ******************************************************************************
14875               *
14876               * Name: TIS1
14877               * Type: Subroutine
14878               * Category: Maths (Arithmetic)
14879               * Summary: Calculate (A ?) = (-X * A + (S R)) / 96
14880               * Deep dive: Shift-and-subtract division
14881               *
14882               * ------------------------------------------------------------------------------
14883               *
14884               * Calculate the following expression between sign-magnitude numbers, ignoring
14885               * the low byte of the result:
14886               *
14887               * (A ?) = (-X * A + (S R)) / 96
14888               *
14889               * This uses the same shift-and-subtract algorithm as TIS2, just with the
14890               * quotient A hard-coded to 96.
14891               *
14892               * ------------------------------------------------------------------------------
14893               *
14894               * Returns:
14895               *
14896               * Q                   Gets set to the value of argument X
14897               *
14898               * ******************************************************************************
14899               
14900               TIS1:
14901 4550 D80E  30        movb rx,@Q                      ; STX Q             ; Set Q = X
     4552 0090     
14902               
14903                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit in A
     **** ****     > EOI
0001 4554 0200  20        li   rtmp,(>80*256)
     4556 8000     
0002 4558 2B40  18        xor  rtmp,ra
                   < elite.a99
14904               
14905 455A 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     455C 44B2     
14906 455E 06A0  32        bl   @jsr                       ;
     4560 FE1E     
14907                                                                          ; = X * -A + (S R)
14908               
14909               DVID96:
14910 4562 D38D  18        movb ra,rx                      ; TAX               ; Set T to the sign bit of the result
14911 4564 024D  22        andi ra,>80*256                 ; AND #%10000000
     4566 8000     
14912 4568 D80D  30        movb ra,@T                      ; STA T
     456A 00D1     
14913               
14914 456C D34E  18        movb rx,ra                      ; TXA               ; Set A to the high byte of the result with the sign bit
14915 456E 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; cleared, so (A ?) = |X * A + (S R)|
     4570 7F00     
14916               
14917                                                                          ; The following is identical to TIS2, except Q is
14918                                                                          ; hard-coded to 96, so this does A = A / 96
14919               
14920 4572 020E  20        li   rx,>fe*256                 ; LDX #254          ; Set T1 to have bits 1-7 set, so we can rotate through
     4574 FE00     
14921 4576 D80E  30        movb rx,@T1                     ; STX T1            ; 7 loop iterations, getting a 1 each time, and then
     4578 0006     
14922                                                                          ; getting a 0 on the 8th iteration... and we can also
14923                                                                          ; use T1 to catch our result bits into bit 0 each time
14924               
14925               DVL3:
14926                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 457A 024D  22        andi ra,>ff00
     457C FF00     
0002 457E 0A1D  18        sla  ra,1
                   < elite.a99
14927               
14928 4580 028D  22        ci   ra,>60*256                 ; CMP #96           ; If A < 96 skip the following subtraction
     4582 6000     
14929 4584 1704  14        jnc  DV4                        ; BCC DV4
14930               
14931                      .sbi (>60*256)                  ; SBC #96           ; Set A = A - 96
     **** ****     > SBI
0001 4586 1801  14        joc  !
0002 4588 7347  18        sb   rone,ra
0003               !:
0004 458A 022D  22        ai   ra,-(>60*256)
     458C A000     
                   < elite.a99
14932                                                                          ;
14933                                                                          ; Going into this subtraction we know the C flag is
14934                                                                          ; set as we passed through the BCC above, and we also
14935                                                                          ; know that A >= 96, so the C flag will still be set
14936                                                                          ; once we are done
14937               
14938               DV4:
14939 458E 0204  20        li   rarg1,T1                   ; ROL T1            ; Rotate the counter in T1 to the left, and catch the
     4590 0006     
14940 4592 06A0  32        bl   @rol                       ;
     4594 FE44     
14941                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
14942                                                                          ; do the subtraction, or 1 if we did)
14943               
14944 4596 18F1  14        joc  DVL3                       ; BCS DVL3          ; If we still have set bits in T1, loop back to DVL3 to
14945                                                                          ; do the next iteration of 7
14946               
14947 4598 D360  30        movb @T1,ra                     ; LDA T1            ; Fetch the result from T1 into A
     459A 0006     
14948               
14949 459C F360  30        socb @T,ra                      ; ORA T             ; Give A the sign of the result that we stored above
     459E 00D1     
14950               
14951 45A0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     45A2 FE2A     
14952               
14953               * ******************************************************************************
14954               *
14955               * Name: DV42
14956               * Type: Subroutine
14957               * Category: Maths (Arithmetic)
14958               * Summary: Calculate (P R) = 256 * DELTA / z_hi
14959               *
14960               * ------------------------------------------------------------------------------
14961               *
14962               * Calculate the following division and remainder:
14963               *
14964               * P = DELTA / (the Y-th stardust particle's z_hi coordinate)
14965               *
14966               * R = remainder as a fraction of A, where 1.0 = 255
14967               *
14968               * Another way of saying the above is this:
14969               *
14970               * (P R) = 256 * DELTA / z_hi
14971               *
14972               * DELTA is a value between 1 and 40, and the minimum z_hi is 16 (dust particles
14973               * are removed at lower values than this), so this means P is between 0 and 2
14974               * (as 40 / 16 = 2.5, so the maximum result is P = 2 and R = 128.
14975               *
14976               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
14977               * keep the remainder.
14978               *
14979               * ------------------------------------------------------------------------------
14980               *
14981               * Arguments:
14982               *
14983               * Y                   The number of the stardust particle to process
14984               *
14985               * ------------------------------------------------------------------------------
14986               *
14987               * Returns:
14988               *
14989               * C flag              The C flag is cleared
14990               *
14991               * ******************************************************************************
14992               
14993               DV42:
14994 45A4 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th dust particle's z_hi coordinate into A
     45A6 0EE8     
14995               
14996                                                                          ; Fall through into DV41 to do:
14997                                                                          ;
14998                                                                          ; (P R) = 256 * DELTA / A
14999                                                                          ; = 256 * DELTA / Y-th stardust particle's z_hi
15000               
15001               * ******************************************************************************
15002               *
15003               * Name: DV41
15004               * Type: Subroutine
15005               * Category: Maths (Arithmetic)
15006               * Summary: Calculate (P R) = 256 * DELTA / A
15007               *
15008               * ------------------------------------------------------------------------------
15009               *
15010               * Calculate the following division and remainder:
15011               *
15012               * P = DELTA / A
15013               *
15014               * R = remainder as a fraction of A, where 1.0 = 255
15015               *
15016               * Another way of saying the above is this:
15017               *
15018               * (P R) = 256 * DELTA / A
15019               *
15020               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15021               * keep the remainder.
15022               *
15023               * ------------------------------------------------------------------------------
15024               *
15025               * Returns:
15026               *
15027               * C flag              The C flag is cleared
15028               *
15029               * ******************************************************************************
15030               
15031               DV41:
15032 45A8 D80D  30        movb ra,@Q                      ; STA Q             ; Store A in Q
     45AA 0090     
15033               
15034 45AC D360  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch the speed from DELTA into A
     45AE 008C     
15035               
15036                                                                          ; Fall through into DVID4 to do:
15037                                                                          ;
15038                                                                          ; (P R) = 256 * A / Q
15039                                                                          ; = 256 * DELTA / A
15040               
15041               * ******************************************************************************
15042               *
15043               * Name: DVID4
15044               * Type: Subroutine
15045               * Category: Maths (Arithmetic)
15046               * Summary: Calculate (P R) = 256 * A / Q
15047               * Deep dive: Shift-and-subtract division
15048               *
15049               * ------------------------------------------------------------------------------
15050               *
15051               * Calculate the following division and remainder:
15052               *
15053               * P = A / Q
15054               *
15055               * R = remainder as a fraction of Q, where 1.0 = 255
15056               *
15057               * Another way of saying the above is this:
15058               *
15059               * (P R) = 256 * A / Q
15060               *
15061               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15062               * keep the remainder.
15063               *
15064               * ------------------------------------------------------------------------------
15065               *
15066               * Returns:
15067               *
15068               * C flag              The C flag is cleared
15069               *
15070               * ******************************************************************************
15071               
15072               DVID4:
15073 45B0 020E  20        li   rx,>08*256                 ; LDX #8            ; Set a counter in X to count the 8 bits in A
     45B2 0800     
15074               
15075                      .asla                           ; ASL A             ; Shift A left and store in P (we will build the result
     **** ****     > ASLA
0001 45B4 024D  22        andi ra,>ff00
     45B6 FF00     
0002 45B8 0A1D  18        sla  ra,1
                   < elite.a99
15076 45BA D80D  30        movb ra,@P                      ; STA P             ; in P)
     45BC 001B     
15077               
15078 45BE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a remainder
     45C0 0000     
15079               
15080               DVL4:
15081 45C2 06A0  32        bl   @rola                      ; ROL A             ; Shift A to the left
     45C4 FE34     
15082               
15083 45C6 1803  14        joc  DV8                        ; BCS DV8           ; If the C flag is set (i.e. bit 7 of A was set) then
15084                                                                          ; skip straight to the subtraction
15085               
15086 45C8 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     45CA 0090     
15087 45CC 1705  14        jnc  DV5                        ; BCC DV5
15088               
15089               DV8:
15090                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 45CE 1801  14        joc  !
0002 45D0 7347  18        sb   rone,ra
0003               !:
0004 45D2 7360  30        sb   @Q,ra
     45D4 0090     
                   < elite.a99
15091               
15092                      .sec                            ; SEC               ; Set the C flag, so that P gets a 1 shifted into bit 0
     **** ****     > SEC
0001 45D6 0A18  18        sla  rmone,1
                   < elite.a99
15093               
15094               DV5:
15095 45D8 0204  20        li   rarg1,P                    ; ROL P             ; Shift P to the left, pulling the C flag into bit 0
     45DA 001B     
15096 45DC 06A0  32        bl   @rol                       ;
     45DE FE44     
15097               
15098 45E0 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
15099               
15100 45E2 16EF  14        jne  DVL4                       ; BNE DVL4          ; Loop back for the next bit until we have done all 8
15101                                                                          ; bits of P
15102               
15103 45E4 0460  28        b    @LL28+4                    ; JMP LL28+4        ; Jump to LL28+4 to convert the remainder in A into an
     45E6 D348     
15104                                                                          ; integer representation of the fractional value A / Q,
15105                                                                          ; in R, where 1.0 = 255. LL28+4 always returns with the
15106                                                                          ; C flag cleared, and we return from the subroutine
15107                                                                          ; using a tail call
15108               
15109               * ******************************************************************************
15110               *
15111               * Name: DVID3B2
15112               * Type: Subroutine
15113               * Category: Maths (Arithmetic)
15114               * Summary: Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15115               * Deep dive: Shift-and-subtract division
15116               *
15117               * ------------------------------------------------------------------------------
15118               *
15119               * Calculate the following:
15120               *
15121               * K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15122               *
15123               * The actual division here is done as an 8-bit calculation using LL31, but this
15124               * routine shifts both the numerator (the top part of the division) and the
15125               * denominator (the bottom part of the division) around to get the multi-byte
15126               * result we want.
15127               *
15128               * Specifically, it shifts both of them to the left as far as possible, keeping a
15129               * tally of how many shifts get done in each one - and specifically, the
15130               * difference in the number of shifts between the top and bottom (as shifting
15131               * both of them once in the same direction won't change the result). It then
15132               * divides the two highest bytes with the simple 8-bit routine in LL31, and
15133               * shifts the result by the difference in the number of shifts, which acts as a
15134               * scale factor to get the correct result.
15135               *
15136               * ------------------------------------------------------------------------------
15137               *
15138               * Returns:
15139               *
15140               * K(3 2 1 0)          The result of the division
15141               *
15142               * X                   X is preserved
15143               *
15144               * ******************************************************************************
15145               
15146               DVID3B2:
15147 45E8 D80D  30        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A
     45EA 001D     
15148               
15149 45EC D360  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set Q = z_lo
     45EE 0059     
15150 45F0 D80D  30        movb ra,@Q                      ; STA Q
     45F2 0090     
15151               
15152 45F4 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set R = z_hi
     45F6 005A     
15153 45F8 D80D  30        movb ra,@R                      ; STA R
     45FA 0091     
15154               
15155 45FC D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set S = z_sign
     45FE 005B     
15156 4600 D80D  30        movb ra,@S                      ; STA S
     4602 0092     
15157               
15158               DVID3B:
15159                                                                          ; Given the above assignments, we now want to calculate
15160                                                                          ; the following to get the result we want:
15161                                                                          ;
15162                                                                          ; K(3 2 1 0) = P(2 1 0) / (S R Q)
15163 4604 D360  30        movb @P,ra                      ; LDA P             ; Make sure P(2 1 0) is at least 1
     4606 001B     
15164 4608 026D  22        ori  ra,>01*256                 ; ORA #1
     460A 0100     
15165 460C D80D  30        movb ra,@P                      ; STA P
     460E 001B     
15166               
15167 4610 D360  30        movb @P+2,ra                    ; LDA P+2           ; Set T to the sign of P+2 * S (i.e. the sign of the
     4612 001D     
15168                      .eor @S                         ; EOR S             ; result) and store it in T
     **** ****     > EOR
0001 4614 D020  30        movb @S,rtmp
     4616 0092     
0002 4618 2B40  18        xor  rtmp,ra
                   < elite.a99
15169 461A 024D  22        andi ra,>80*256                 ; AND #%10000000
     461C 8000     
15170 461E D80D  30        movb ra,@T                      ; STA T
     4620 00D1     
15171               
15172 4622 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to store the scale factor
     4624 0000     
15173               
15174 4626 D360  30        movb @P+2,ra                    ; LDA P+2           ; Clear the sign bit of P+2, so the division can be done
     4628 001D     
15175 462A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; with positive numbers and we'll set the correct sign
     462C 7F00     
15176                                                                          ; below, once all the maths is done
15177                                                                          ;
15178                                                                          ; This also leaves A = P+2, which we use below
15179               
15180               DVL9:
15181                                                                          ; We now shift (A P+1 P) left until A >= 64, counting
15182                                                                          ; the number of shifts in Y. This makes the top part of
15183                                                                          ; the division as large as possible, thus retaining as
15184                                                                          ; much accuracy as we can.  When we come to return the
15185                                                                          ; final result, we shift the result by the number of
15186                                                                          ; places in Y, and in the correct direction
15187 462E 028D  22        ci   ra,>40*256                 ; CMP #64           ; If A >= 64, jump down to DV14
     4630 4000     
15188 4632 180F  14        joc  DV14                       ; BCS DV14
15189               
15190                      .asl @P                         ; ASL P             ; Shift (A P+1 P) to the left
     **** ****     > ASL
0001 4634 D020  30        movb @P,rtmp
     4636 001B     
0002 4638 0240  22        andi rtmp,>ff00
     463A FF00     
0003 463C 0A10  18        sla  rtmp,1
0004 463E D800  30        movb rtmp,@P
     4640 001B     
                   < elite.a99
15191 4642 0204  20        li   rarg1,P+1                  ; ROL P+1
     4644 001C     
15192 4646 06A0  32        bl   @rol                       ;
     4648 FE44     
15193 464A 06A0  32        bl   @rola                      ; ROL A
     464C FE34     
15194               
15195 464E B3C7  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15196               
15197 4650 16EE  14        jne  DVL9                       ; BNE DVL9          ; Loop up to DVL9 (this BNE is effectively a JMP, as Y
15198                                                                          ; will never be zero)
15199               
15200               DV14:
15201                                                                          ; If we get here, A >= 64 and contains the highest byte
15202                                                                          ; of the numerator, scaled up by the number of left
15203                                                                          ; shifts in Y
15204 4652 D80D  30        movb ra,@P+2                    ; STA P+2           ; Store A in P+2, so we now have the scaled value of
     4654 001D     
15205                                                                          ; the numerator in P(2 1 0)
15206               
15207 4656 D360  30        movb @S,ra                      ; LDA S             ; Set A = |S|
     4658 0092     
15208 465A 024D  22        andi ra,>7f*256                 ; AND #%01111111
     465C 7F00     
15209               
15210 465E 110F  14        jlt  DV9                        ; BMI DV9           ; If bit 7 of A is set, jump down to DV9 to skip the
15211                                                                          ; left-shifting of the denominator (though this branch
15212                                                                          ; instruction has no effect as bit 7 of the above AND
15213                                                                          ; can never be set, which is why this instruction was
15214                                                                          ; removed from later versions)
15215               
15216               DVL6:
15217                                                                          ; We now shift (S R Q) left until bit 7 of S is set,
15218                                                                          ; reducing Y by the number of shifts. This makes the
15219                                                                          ; bottom part of the division as large as possible, thus
15220                                                                          ; retaining as much accuracy as we can. When we come to
15221                                                                          ; return the final result, we shift the result by the
15222                                                                          ; total number of places in Y, and in the correct
15223                                                                          ; direction, to give us the correct result
15224                                                                          ;
15225                                                                          ; We set A to |S| above, so the following actually
15226                                                                          ; shifts (A R Q)
15227 4660 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15228               
15229                      .asl @Q                         ; ASL Q             ; Shift (A R Q) to the left
     **** ****     > ASL
0001 4662 D020  30        movb @Q,rtmp
     4664 0090     
0002 4666 0240  22        andi rtmp,>ff00
     4668 FF00     
0003 466A 0A10  18        sla  rtmp,1
0004 466C D800  30        movb rtmp,@Q
     466E 0090     
                   < elite.a99
15230 4670 0204  20        li   rarg1,R                    ; ROL R
     4672 0091     
15231 4674 06A0  32        bl   @rol                       ;
     4676 FE44     
15232 4678 06A0  32        bl   @rola                      ; ROL A
     467A FE34     
15233               
15234 467C 15F1  14        jgt  DVL6                       ; BPL DVL6          ; Loop up to DVL6 to do another shift, until bit 7 of A
15235                                                                          ; is set and we can't shift left any further
15236               
15237               DV9:
15238                                                                          ; We have now shifted both the numerator and denominator
15239                                                                          ; left as far as they will go, keeping a tally of the
15240                                                                          ; overall scale factor of the various shifts in Y. We
15241                                                                          ; can now divide just the two highest bytes to get our
15242                                                                          ; result
15243 467E D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = A, the highest byte of the denominator
     4680 0090     
15244               
15245 4682 020D  20        li   ra,>fe*256                 ; LDA #254          ; Set R to have bits 1-7 set, so we can pass this to
     4684 FE00     
15246 4686 D80D  30        movb ra,@R                      ; STA R             ; LL31 to act as the bit counter in the division
     4688 0091     
15247               
15248 468A D360  30        movb @P+2,ra                    ; LDA P+2           ; Set A to the highest byte of the numerator
     468C 001D     
15249               
15250 468E 0200  20        li   rtmp,LL31                  ; JSR LL31          ; Call LL31 to calculate:
     4690 D352     
15251 4692 06A0  32        bl   @jsr                       ;
     4694 FE1E     
15252                                                                          ;
15253                                                                          ; R = 256 * A / Q
15254                                                                          ; = 256 * numerator / denominator
15255               
15256                                                                          ; The result of our division is now in R, so we just
15257                                                                          ; need to shift it back by the scale factor in Y
15258               
15259 4696 020D  20        li   ra,>00*256                 ; LDA #0            ; Set K(3 2 1) = 0 to hold the result (we populate K
     4698 0000     
15260 469A D80D  30        movb ra,@K+1                    ; STA K+1           ; next)
     469C 003E     
15261 469E D80D  30        movb ra,@K+2                    ; STA K+2
     46A0 003F     
15262 46A2 D80D  30        movb ra,@K+3                    ; STA K+3
     46A4 0040     
15263               
15264 46A6 D34F  18        movb ry,ra                      ; TYA               ; If Y is positive, jump to DV12
15265 46A8 1527  14        jgt  DV12                       ; BPL DV12
15266               
15267                                                                          ; If we get here then Y is negative, so we need to shift
15268                                                                          ; the result R to the left by Y places, and then set the
15269                                                                          ; correct sign for the result
15270               
15271 46AA D360  30        movb @R,ra                      ; LDA R             ; Set A = R
     46AC 0091     
15272               
15273               DVL8:
15274                      .asla                           ; ASL A             ; Shift (K+3 K+2 K+1 A) left
     **** ****     > ASLA
0001 46AE 024D  22        andi ra,>ff00
     46B0 FF00     
0002 46B2 0A1D  18        sla  ra,1
                   < elite.a99
15275 46B4 0204  20        li   rarg1,K+1                  ; ROL K+1
     46B6 003E     
15276 46B8 06A0  32        bl   @rol                       ;
     46BA FE44     
15277 46BC 0204  20        li   rarg1,K+2                  ; ROL K+2
     46BE 003F     
15278 46C0 06A0  32        bl   @rol                       ;
     46C2 FE44     
15279 46C4 0204  20        li   rarg1,K+3                  ; ROL K+3
     46C6 0040     
15280 46C8 06A0  32        bl   @rol                       ;
     46CA FE44     
15281               
15282 46CC B3C7  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15283               
15284 46CE 16EF  14        jne  DVL8                       ; BNE DVL8          ; Loop back to DVL8 until we have shifted left by Y
15285                                                                          ; places
15286               
15287 46D0 D80D  30        movb ra,@K                      ; STA K             ; Store A in K so the result is now in K(3 2 1 0)
     46D2 003D     
15288               
15289 46D4 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to the sign in T, which we set above to the
     46D6 0040     
15290 46D8 F360  30        socb @T,ra                      ; ORA T             ; correct sign for the result
     46DA 00D1     
15291 46DC D80D  30        movb ra,@K+3                    ; STA K+3
     46DE 0040     
15292               
15293 46E0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     46E2 FE2A     
15294               
15295               DV13:
15296                                                                          ; If we get here then Y is zero, so we don't need to
15297                                                                          ; shift the result R, we just need to set the correct
15298                                                                          ; sign for the result
15299 46E4 D360  30        movb @R,ra                      ; LDA R             ; Store R in K so the result is now in K(3 2 1 0)
     46E6 0091     
15300 46E8 D80D  30        movb ra,@K                      ; STA K
     46EA 003D     
15301               
15302 46EC D360  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     46EE 00D1     
15303 46F0 D80D  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     46F2 0040     
15304               
15305 46F4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     46F6 FE2A     
15306               
15307               DV12:
15308 46F8 13F5  14        jeq  DV13                       ; BEQ DV13          ; We jumped here having set A to the scale factor in Y,
15309                                                                          ; so this jumps up to DV13 if Y = 0
15310               
15311                                                                          ; If we get here then Y is positive and non-zero, so we
15312                                                                          ; need to shift the result R to the right by Y places
15313                                                                          ; and then set the correct sign for the result. We also
15314                                                                          ; know that K(3 2 1) will stay 0, as we are shifting the
15315                                                                          ; lowest byte to the right, so no set bits will make
15316                                                                          ; their way into the top three bytes
15317               
15318 46FA D360  30        movb @R,ra                      ; LDA R             ; Set A = R
     46FC 0091     
15319               
15320               DVL10:
15321 46FE 091D  18        srl  ra,1                       ; LSR A             ; Shift A right
15322               
15323 4700 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15324               
15325 4702 16FD  14        jne  DVL10                      ; BNE DVL10         ; Loop back to DVL10 until we have shifted right by Y
15326                                                                          ; places
15327               
15328 4704 D80D  30        movb ra,@K                      ; STA K             ; Store the shifted A in K so the result is now in
     4706 003D     
15329                                                                          ; K(3 2 1 0)
15330               
15331 4708 D360  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     470A 00D1     
15332 470C D80D  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     470E 0040     
15333               
15334 4710 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4712 FE2A     
15335               
15336               * ******************************************************************************
15337               *
15338               * Name: cntr
15339               * Type: Subroutine
15340               * Category: Dashboard
15341               * Summary: Apply damping to the pitch or roll dashboard indicator
15342               *
15343               * ------------------------------------------------------------------------------
15344               *
15345               * Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
15346               * centre point (so X represents a position on a centre-based dashboard slider,
15347               * such as pitch or roll). If the value is in the left-hand side of the slider
15348               * (1-127) then it bumps the value up by 1 so it moves towards the centre, and
15349               * if it's in the right-hand side, it reduces it by 1, also moving it towards the
15350               * centre.
15351               *
15352               * ******************************************************************************
15353               
15354               cntr_:
15355 4714 D360  30        movb @DAMP,ra                   ; LDA DAMP          ; If DAMP is non-zero, then keyboard damping is not
     4716 0F4A     
15356 4718 1608  14        jne  RE1                        ; BNE RE1           ; enabled, so jump to RE1 to return from the subroutine
15357               
15358 471A D34E  18        movb rx,ra                      ; TXA               ; If X < 128, then it's in the left-hand side of the
15359 471C 1502  14        jgt  BUMP                       ; BPL BUMP          ; dashboard slider, so jump to BUMP to bump it up by 1,
15360                                                                          ; to move it closer to the centre
15361               
15362 471E 7387  18        sb   rone,rx                    ; DEX               ; Otherwise X >= 128, so it's in the right-hand side
15363 4720 1104  14        jlt  RE1                        ; BMI RE1           ; of the dashboard slider, so decrement X by 1, and if
15364                                                                          ; it's still >= 128, jump to RE1 to return from the
15365                                                                          ; subroutine, otherwise fall through to BUMP to undo
15366                                                                          ; the bump and then return
15367               
15368               BUMP:
15369 4722 B387  18        ab   rone,rx                    ; INX               ; Bump X up by 1, and if it hasn't overshot the end of
15370 4724 1602  14        jne  RE1                        ; BNE RE1           ; the dashboard slider, jump to RE1 to return from the
15371                                                                          ; subroutine, otherwise fall through to REDU to drop
15372                                                                          ; it down by 1 again
15373               
15374               REDU:
15375 4726 7387  18        sb   rone,rx                    ; DEX               ; Reduce X by 1, and if we have reached 0 jump up to
15376 4728 13FC  14        jeq  BUMP                       ; BEQ BUMP          ; BUMP to add 1, because we need the value to be in the
15377                                                                          ; range 1 to 255
15378               
15379               RE1:
15380 472A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     472C FE2A     
15381               
15382               * ******************************************************************************
15383               *
15384               * Name: BUMP2
15385               * Type: Subroutine
15386               * Category: Dashboard
15387               * Summary: Bump up the value of the pitch or roll dashboard indicator
15388               *
15389               * ------------------------------------------------------------------------------
15390               *
15391               * Increase ("bump up") X by A, where X is either the current rate of pitch or
15392               * the current rate of roll.
15393               *
15394               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15395               * This is the amount by which the pitch or roll is currently changing, so 1
15396               * means it is decreasing at the maximum rate, 128 means it is not changing,
15397               * and 255 means it is increasing at the maximum rate. These values correspond
15398               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15399               * left, 128 meaning the middle, and 255 meaning full right.
15400               *
15401               * If bumping up X would push it past 255, then X is set to 255.
15402               *
15403               * If keyboard auto-recentre is configured and the result is less than 128, we
15404               * bump X up to the mid-point, 128. This is the equivalent of having a roll or
15405               * pitch in the left half of the indicator, when increasing the roll or pitch
15406               * should jump us straight to the mid-point.
15407               *
15408               * ------------------------------------------------------------------------------
15409               *
15410               * Other entry points:
15411               *
15412               * RE2+2               Restore A from T and return from the subroutine
15413               *
15414               * ******************************************************************************
15415               
15416               BUMP2:
15417 472E D80D  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     4730 00D1     
15418               
15419 4732 D34E  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15420               
15421                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 4734 0A16  18        sla  rzero,1
                   < elite.a99
15422                                                                          ; C flag affecting the result
15423               
15424                      .adc @T,ra                      ; ADC T             ; Set X = A = argument X + argument A
     **** ****     > ADC
0001 4736 1701  14        jnc  !
0002 4738 B347  18        ab   rone,ra
0003               !:
0004 473A B360  30        ab   @T,ra
     473C 00D1     
                   < elite.a99
15425 473E D38D  18        movb ra,rx                      ; TAX
15426               
15427 4740 1702  14        jnc  RE2                        ; BCC RE2           ; If the C flag is clear, then we didn't overflow, so
15428                                                                          ; jump to RE2 to auto-recentre and return the result
15429               
15430 4742 020E  20        li   rx,>ff*256                 ; LDX #255          ; We have an overflow, so set X to the maximum possible
     4744 FF00     
15431                                                                          ; value of 255
15432               
15433               RE2:
15434 4746 1511  14        jgt  RE3+2                      ; BPL RE3+2         ; If X has bit 7 clear (i.e. the result < 128), then
15435                                                                          ; jump to RE3+2 in routine REDU2 to do an auto-recentre,
15436                                                                          ; if configured, because the result is on the left side
15437                                                                          ; of the centre point of 128
15438               
15439                                                                          ; Jumps to RE2+2 end up here
15440               
15441 4748 D360  30        movb @T,ra                      ; LDA T             ; Restore the original argument A from T into A
     474A 00D1     
15442               
15443 474C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     474E FE2A     
15444               
15445               * ******************************************************************************
15446               *
15447               * Name: REDU2
15448               * Type: Subroutine
15449               * Category: Dashboard
15450               * Summary: Reduce the value of the pitch or roll dashboard indicator
15451               *
15452               * ------------------------------------------------------------------------------
15453               *
15454               * Reduce X by A, where X is either the current rate of pitch or the current
15455               * rate of roll.
15456               *
15457               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15458               * This is the amount by which the pitch or roll is currently changing, so 1
15459               * means it is decreasing at the maximum rate, 128 means it is not changing,
15460               * and 255 means it is increasing at the maximum rate. These values correspond
15461               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15462               * left, 128 meaning the middle, and 255 meaning full right.
15463               *
15464               * If reducing X would bring it below 1, then X is set to 1.
15465               *
15466               * If keyboard auto-recentre is configured and the result is greater than 128, we
15467               * reduce X down to the mid-point, 128. This is the equivalent of having a roll
15468               * or pitch in the right half of the indicator, when decreasing the roll or pitch
15469               * should jump us straight to the mid-point.
15470               *
15471               * ------------------------------------------------------------------------------
15472               *
15473               * Other entry points:
15474               *
15475               * RE3+2               Auto-recentre the value in X, if keyboard auto-recentre
15476               * is configured
15477               *
15478               * ******************************************************************************
15479               
15480               REDU2:
15481 4750 D80D  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     4752 00D1     
15482               
15483 4754 D34E  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15484               
15485                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 4756 0A18  18        sla  rmone,1
                   < elite.a99
15486                                                                          ; C flag affecting the result
15487               
15488                      .sbc @T,ra                      ; SBC T             ; Set X = A = argument X - argument A
     **** ****     > SBC
0001 4758 1801  14        joc  !
0002 475A 7347  18        sb   rone,ra
0003               !:
0004 475C 7360  30        sb   @T,ra
     475E 00D1     
                   < elite.a99
15489 4760 D38D  18        movb ra,rx                      ; TAX
15490               
15491 4762 1802  14        joc  RE3                        ; BCS RE3           ; If the C flag is set, then we didn't underflow, so
15492                                                                          ; jump to RE3 to auto-recentre and return the result
15493               
15494 4764 020E  20        li   rx,>01*256                 ; LDX #1            ; We have an underflow, so set X to the minimum possible
     4766 0100     
15495                                                                          ; value, 1
15496               
15497               RE3:
15498 4768 15EF  14        jgt  RE2+2                      ; BPL RE2+2         ; If X has bit 7 clear (i.e. the result < 128), then
15499                                                                          ; jump to RE2+2 above to return the result as is,
15500                                                                          ; because the result is on the left side of the centre
15501                                                                          ; point of 128, so we don't need to auto-centre
15502               
15503                                                                          ; Jumps to RE3+2 end up here
15504               
15505                                                                          ; If we get here, then we need to apply auto-recentre,
15506                                                                          ; if it is configured
15507               
15508 476A D360  30        movb @DJD,ra                    ; LDA DJD           ; If keyboard auto-recentre is disabled, then
     476C 0F4B     
15509 476E 16EC  14        jne  RE2+2                      ; BNE RE2+2         ; jump to RE2+2 to restore A and return
15510               
15511 4770 020E  20        li   rx,>80*256                 ; LDX #128          ; If we get here then keyboard auto-recentre is enabled,
     4772 8000     
15512 4774 11E9  14        jlt  RE2+2                      ; BMI RE2+2         ; so set X to 128 (the middle of our range) and jump to
15513                                                                          ; RE2+2 to restore A and return from the subroutine
15514                                                                          ; (this BMI is effectively a JMP as bit 7 of X is always
15515                                                                          ; set)
15516               
15517               * ******************************************************************************
15518               *
15519               * Name: ARCTAN
15520               * Type: Subroutine
15521               * Category: Maths (Geometry)
15522               * Summary: Calculate A = arctan(P / Q)
15523               * Deep dive: The sine, cosine and arctan tables
15524               *
15525               * ------------------------------------------------------------------------------
15526               *
15527               * Calculate the following:
15528               *
15529               * A = arctan(P / Q)
15530               *
15531               * In other words, this finds the angle in the right-angled triangle where the
15532               * opposite side to angle A is length P and the adjacent side to angle A has
15533               * length Q, so:
15534               *
15535               * tan(A) = P / Q
15536               *
15537               * The result in A is an integer representing the angle in radians. The routine
15538               * returns values in the range 0 to 128, which covers 0 to 180 degrees (or 0 to
15539               * PI radians).
15540               *
15541               * ******************************************************************************
15542               
15543               ARCTAN:
15544 4776 D360  30        movb @P,ra                      ; LDA P             ; Set T1 = P EOR Q, which will have the sign of P * Q
     4778 001B     
15545                      .eor @Q                         ; EOR Q             ;
     **** ****     > EOR
0001 477A D020  30        movb @Q,rtmp
     477C 0090     
0002 477E 2B40  18        xor  rtmp,ra
                   < elite.a99
15546               * AND #%10000000         \ The AND is commented out in the original source
15547 4780 D80D  30        movb ra,@T1                     ; STA T1
     4782 0006     
15548               
15549 4784 D360  30        movb @Q,ra                      ; LDA Q             ; If Q = 0, jump to AR2 to return a right angle
     4786 0090     
15550 4788 132B  14        jeq  AR2                        ; BEQ AR2
15551               
15552                      .asla                           ; ASL A             ; Set Q = |Q| * 2 (this is a quick way of clearing the
     **** ****     > ASLA
0001 478A 024D  22        andi ra,>ff00
     478C FF00     
0002 478E 0A1D  18        sla  ra,1
                   < elite.a99
15553 4790 D80D  30        movb ra,@Q                      ; STA Q             ; sign bit, and we don't need to shift right again as we
     4792 0090     
15554                                                                          ; only ever use this value in the division with |P| * 2,
15555                                                                          ; which we set next)
15556               
15557 4794 D360  30        movb @P,ra                      ; LDA P             ; Set A = |P| * 2
     4796 001B     
15558                      .asla                           ; ASL A
     **** ****     > ASLA
0001 4798 024D  22        andi ra,>ff00
     479A FF00     
0002 479C 0A1D  18        sla  ra,1
                   < elite.a99
15559               
15560 479E 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
     47A0 0090     
15561 47A2 180A  14        joc  AR1                        ; BCS AR1           ; and Q around, so we can still use the lookup table
15562               
15563 47A4 0200  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     47A6 47FC     
15564 47A8 06A0  32        bl   @jsr                       ;
     47AA FE1E     
15565                                                                          ;
15566                                                                          ; A = arctan(A / Q)
15567                                                                          ; = arctan(|P / Q|)
15568               
15569                      .sec                            ; SEC               ; Set the C flag so the SBC instruction in AR3 will be
     **** ****     > SEC
0001 47AC 0A18  18        sla  rmone,1
                   < elite.a99
15570                                                                          ; correct, should we jump there
15571               
15572               AR4:
15573 47AE D3A0  30        movb @T1,rx                     ; LDX T1            ; If T1 is negative, i.e. P and Q have different signs,
     47B0 0006     
15574 47B2 111A  14        jlt  AR3                        ; BMI AR3           ; jump down to AR3 to return arctan(-|P / Q|)
15575               
15576 47B4 0460  28        b    @rts                       ; RTS               ; Otherwise P and Q have the same sign, so our result is
     47B6 FE2A     
15577                                                                          ; correct and we can return from the subroutine
15578               
15579               AR1:
15580                                                                          ; We want to calculate arctan(t) where |t| > 1, so we
15581                                                                          ; can use the calculation described in the documentation
15582                                                                          ; for the ACT table, i.e. 64 - arctan(1 / t)
15583 47B8 D3A0  30        movb @Q,rx                      ; LDX Q             ; Swap the values in Q and P, using the fact that we
     47BA 0090     
15584 47BC D80D  30        movb ra,@Q                      ; STA Q             ; called AR1 with A = P
     47BE 0090     
15585 47C0 D80E  30        movb rx,@P                      ; STX P             ;
     47C2 001B     
15586 47C4 D34E  18        movb rx,ra                      ; TXA               ; This also sets A = P (which now contains the original
15587                                                                          ; argument |Q|)
15588               
15589 47C6 0200  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     47C8 47FC     
15590 47CA 06A0  32        bl   @jsr                       ;
     47CC FE1E     
15591                                                                          ;
15592                                                                          ; A = arctan(A / Q)
15593                                                                          ; = arctan(|Q / P|)
15594                                                                          ; = arctan(1 / |P / Q|)
15595               
15596 47CE D80D  30        movb ra,@T                      ; STA T             ; Set T = 64 - T
     47D0 00D1     
15597 47D2 020D  20        li   ra,>40*256                 ; LDA #64
     47D4 4000     
15598                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 47D6 1801  14        joc  !
0002 47D8 7347  18        sb   rone,ra
0003               !:
0004 47DA 7360  30        sb   @T,ra
     47DC 00D1     
                   < elite.a99
15599               
15600 47DE 18E7  14        joc  AR4                        ; BCS AR4           ; Jump to AR4 to continue the calculation (this BCS is
15601                                                                          ; effectively a JMP as the subtraction will never
15602                                                                          ; underflow, as ARS1 returns values in the range 0-31)
15603               
15604               AR2:
15605                                                                          ; If we get here then Q = 0, so tan(A) = infinity and
15606                                                                          ; A is a right angle, or 0.25 of a circle. We allocate
15607                                                                          ; 255 to a full circle, so we should return 63 for a
15608                                                                          ; right angle
15609 47E0 020D  20        li   ra,>3f*256                 ; LDA #63           ; Set A to 63, to represent a right angle
     47E2 3F00     
15610               
15611 47E4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     47E6 FE2A     
15612               
15613               AR3:
15614                                                                          ; A contains arctan(|P / Q|) but P and Q have different
15615                                                                          ; signs, so we need to return arctan(-|P / Q|), using
15616                                                                          ; the calculation described in the documentation for the
15617                                                                          ; ACT table, i.e. 128 - A
15618 47E8 D80D  30        movb ra,@T                      ; STA T             ; Set A = 128 - A
     47EA 00D1     
15619 47EC 020D  20        li   ra,>80*256                 ; LDA #128          ;
     47EE 8000     
15620               * SEC                    \ The SEC instruction is commented out in the original
15621                      .sbc @T,ra                      ; SBC T             ; source, and isn't required as we did a SEC before
     **** ****     > SBC
0001 47F0 1801  14        joc  !
0002 47F2 7347  18        sb   rone,ra
0003               !:
0004 47F4 7360  30        sb   @T,ra
     47F6 00D1     
                   < elite.a99
15622                                                                          ; calling AR3
15623               
15624 47F8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     47FA FE2A     
15625               
15626               ARS1:
15627                                                                          ; This routine fetches arctan(A / Q) from the ACT table,
15628                                                                          ; so A will be set to an integer in the range 0 to 31
15629                                                                          ; that represents an angle from 0 to 45 degrees (or 0 to
15630                                                                          ; PI / 4 radians)
15631 47FC 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     47FE D344     
15632 4800 06A0  32        bl   @jsr                       ;
     4802 FE1E     
15633                                                                          ;
15634                                                                          ; R = 256 * A / Q
15635               
15636 4804 D360  30        movb @R,ra                      ; LDA R             ; Set X = R / 8
     4806 0091     
15637 4808 091D  18        srl  ra,1                       ; LSR A             ; = 32 * A / Q
15638 480A 091D  18        srl  ra,1                       ; LSR A             ;
15639 480C 091D  18        srl  ra,1                       ; LSR A             ; so X has the value t * 32 where t = A / Q, which is
15640 480E D38D  18        movb ra,rx                      ; TAX               ; what we need to look up values in the ACT table
15641               
15642 4810 D36E  34        movb @ACT(rx),ra                ; LDA ACT,X         ; Fetch ACT+X from the ACT table into A, so now:
     4812 4818     
15643                                                                          ;
15644                                                                          ; A = value in ACT + X
15645                                                                          ; = value in ACT + (32 * A / Q)
15646                                                                          ; = arctan(A / Q)
15647               
15648 4814 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4816 FE2A     
15649               
15650               * ******************************************************************************
15651               *
15652               * Name: ACT
15653               * Type: Variable
15654               * Category: Maths (Geometry)
15655               * Summary: Arctan table
15656               * Deep dive: The sine, cosine and arctan tables
15657               *
15658               * ------------------------------------------------------------------------------
15659               *
15660               * This table contains lookup values for arctangent calculations involving angles
15661               * in the range 0 to 45 degrees (or 0 to PI / 4 radians).
15662               *
15663               * To calculate the value of theta in the following:
15664               *
15665               * theta = arctan(t)
15666               *
15667               * where 0 <= t < 1, we look up the value in:
15668               *
15669               * ACT + (t * 32)
15670               *
15671               * The result will be an integer representing the angle in radians, where 256
15672               * represents a full circle of 360 degrees (2 * PI radians). The result of the
15673               * lookup will therefore be an integer in the range 0 to 31, as this represents
15674               * 0 to 45 degrees (0 to PI / 4 radians).
15675               *
15676               * The table does not support values of t >= 1 or t < 0 directly, so if we need
15677               * to calculate the arctangent for an angle greater than 45 degrees, we can apply
15678               * the following calculation to the result from the table:
15679               *
15680               * * For t > 1, arctan(t) = 64 - arctan(1 / t)
15681               *
15682               * For negative values of t where -1 < t < 0, we can apply the following
15683               * calculation to the result from the table:
15684               *
15685               * * For t < 0, arctan(-t) = 128 - arctan(t)
15686               *
15687               * Finally, if t < -1, we can do the first calculation to get arctan(|t|), and
15688               * the second to get arctan(-|t|).
15689               *
15690               * ******************************************************************************
15691               
15692               ACT:
15693                      ; FOR I%, 0, 31
15694               
15695                      ; EQUB INT((128 / PI) * ATN(I% / 32) + 0.5) ;
15696               
15697                      ; NEXT
15698               
15699 4818 12              byte >12
15700 4819   13            byte >13
15701 481A 14              byte >14
15702 481B   15            byte >15
15703 481C 16              byte >16
15704 481D   17            byte >17
15705 481E 18              byte >18
15706 481F   19            byte >19
15707 4820 1A              byte >1a
15708 4821   1B            byte >1b
15709 4822 1B              byte >1b
15710 4823   1C            byte >1c
15711 4824 1D              byte >1d
15712 4825   1D            byte >1d
15713 4826 1E              byte >1e
15714 4827   1F            byte >1f
15715 4828 20              byte >20
15716 4829   20            byte >20
15717 482A 21              byte >21
15718 482B   21            byte >21
15719 482C 22              byte >22
15720 482D   22            byte >22
15721 482E 23              byte >23
15722 482F   24            byte >24
15723 4830 24              byte >24
15724 4831   24            byte >24
15725 4832 25              byte >25
15726 4833   25            byte >25
15727 4834 26              byte >26
15728 4835   26            byte >26
15729 4836 27              byte >27
15730 4837   27            byte >27
15731               
15732               * ******************************************************************************
15733               *
15734               * Name: WARP
15735               * Type: Subroutine
15736               * Category: Flight
15737               * Summary: Perform an in-system jump
15738               *
15739               * ------------------------------------------------------------------------------
15740               *
15741               * This is called when we press "J" during flight. The following checks are
15742               * performed:
15743               *
15744               * * Make sure we don't have any ships or space stations in the vicinity
15745               *
15746               * * Make sure we are not in witchspace
15747               *
15748               * * If we are facing the planet, make sure we aren't too close
15749               *
15750               * * If we are facing the sun, make sure we aren't too close
15751               *
15752               * If the above checks are passed, then we perform an in-system jump by moving
15753               * the sun and planet in the opposite direction to travel, so we appear to jump
15754               * in space. This means that any asteroids, cargo canisters or escape pods get
15755               * dragged along for the ride.
15756               *
15757               * ******************************************************************************
15758               
15759               WARP:
15770               
15771 4838 D360  30        movb @MANY+AST,ra               ; LDA MANY+AST      ; Set X to the total number of asteroids, escape pods
     483A 0D57     
15772                      .clc                            ; CLC               ; and cargo canisters in the vicinity
     **** ****     > CLC
0001 483C 0A16  18        sla  rzero,1
                   < elite.a99
15773                      .adc @MANY+ESC,ra               ; ADC MANY+ESC      ;
     **** ****     > ADC
0001 483E 1701  14        jnc  !
0002 4840 B347  18        ab   rone,ra
0003               !:
0004 4842 B360  30        ab   @MANY+ESC,ra
     4844 0D5A     
                   < elite.a99
15774                      .adc @MANY+OIL,ra               ; ADC MANY+OIL      ; This code saves one byte of memory over the code in
     **** ****     > ADC
0001 4846 1701  14        jnc  !
0002 4848 B347  18        ab   rone,ra
0003               !:
0004 484A B360  30        ab   @MANY+OIL,ra
     484C 0D58     
                   < elite.a99
15775 484E D38D  18        movb ra,rx                      ; TAX               ; the source disc version. The second CLC is not needed
15776                                                                          ; as there is no way that adding the number of asteroids
15777                                                                          ; and the number of escape pods will cause a carry
15778               
15780               
15781 4850 D36E  34        movb @FRIN+2(rx),ra             ; LDA FRIN+2,X      ; If the slot at FRIN+2+X is non-zero, then we have
     4852 0D42     
15782                                                                          ; something else in the vicinity besides asteroids,
15783                                                                          ; escape pods and cargo canisters, so to check whether
15784                                                                          ; we can jump, we first grab the slot contents into A
15785               
15786 4854 F360  30        socb @SSPR,ra                   ; ORA SSPR          ; If there is a space station nearby, then SSPR will
     4856 0D55     
15787                                                                          ; be non-zero, so OR'ing with SSPR will produce a
15788                                                                          ; non-zero result if either A or SSPR are non-zero
15789               
15790 4858 F360  30        socb @MJ,ra                     ; ORA MJ            ; If we are in witchspace, then MJ will be non-zero, so
     485A 0D5C     
15791                                                                          ; OR'ing with MJ will produce a non-zero result if
15792                                                                          ; either A or SSPR or MJ are non-zero
15793               
15794 485C 163A  14        jne  WA1                        ; BNE WA1           ; A is non-zero if we have either a ship or a space
15795                                                                          ; station in the vicinity, or we are in witchspace, in
15796                                                                          ; which case jump to WA1 to make a low beep to show that
15797                                                                          ; we can't do an in-system jump
15798               
15799 485E D3E0  30        movb @K.+8,ry                   ; LDY K%+8          ; Otherwise we can do an in-system jump, so now we fetch
     4860 0908     
15800                                                                          ; the byte at K%+8, which contains the z_sign for the
15801                                                                          ; first ship slot, i.e. the distance of the planet
15802               
15803 4862 1107  14        jlt  WA3                        ; BMI WA3           ; If the planet's z_sign is negative, then the planet
15804                                                                          ; is behind us, so jump to WA3 to skip the following
15805               
15806 4864 D3CD  18        movb ra,ry                      ; TAY               ; Set A = Y = 0 (as we didn't BNE above) so the call
15807                                                                          ; to MAS2 measures the distance to the planet
15808               
15809 4866 0200  20        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to set A to the largest distance to the
     4868 1786     
15810 486A 06A0  32        bl   @jsr                       ;
     486C FE1E     
15811                                                                          ; planet in any of the three axes (we could also call
15812                                                                          ; routine m to do the same thing, as A = 0)
15813               
15821               
15822 486E 091D  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
15823 4870 1330  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
15824                                                                          ; too close to jump in that direction
15825                                                                          ;
15826                                                                          ; These instructions between them save one byte of
15827                                                                          ; memory over the CMP-based code in the source disc
15828                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
15829                                                                          ; takes up two bytes (though the code does exactly the
15830                                                                          ; same thing)
15831               
15833               
15834               WA3:
15835 4872 D3E0  30        movb @K.+NI.+8,ry               ; LDY K%+NI%+8      ; Fetch the z_sign (byte #8) of the second ship in the
     4874 092C     
15836                                                                          ; ship data workspace at K%, which is reserved for the
15837                                                                          ; sun or the space station (in this case it's the
15838                                                                          ; former, as we already confirmed there isn't a space
15839                                                                          ; station in the vicinity)
15840               
15841 4876 1108  14        jlt  WA2                        ; BMI WA2           ; If the sun's z_sign is negative, then the sun is
15842                                                                          ; behind us, so jump to WA2 to skip the following
15843               
15844 4878 020F  20        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to point to the offset of the ship data block
     487A 2400     
15845                                                                          ; for the sun, which is NI% (as each block is NI% bytes
15846                                                                          ; long, and the sun is the second block)
15847               
15848 487C 0200  20        li   rtmp,m_                    ; JSR m             ; Call m to set A to the largest distance to the sun
     487E 1782     
15849 4880 06A0  32        bl   @jsr                       ;
     4882 FE1E     
15850                                                                          ; in any of the three axes
15851               
15859               
15860 4884 091D  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
15861 4886 1325  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
15862                                                                          ; too close to jump in that direction
15863                                                                          ;
15864                                                                          ; These instructions between them save one byte of
15865                                                                          ; memory over the CMP-based code in the source disc
15866                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
15867                                                                          ; takes up two bytes (though the code does exactly the
15868                                                                          ; same thing)
15869               
15871               
15872               WA2:
15873                                                                          ; If we get here, then we can do an in-system jump, as
15874                                                                          ; we don't have any ships or space stations in the
15875                                                                          ; vicinity, we are not in witchspace, and if we are
15876                                                                          ; facing the planet or the sun, we aren't too close to
15877                                                                          ; jump towards it
15878                                                                          ;
15879                                                                          ; We do an in-system jump by moving the sun and planet,
15880                                                                          ; rather than moving our own local bubble (this is why
15881                                                                          ; in-system jumps drag asteroids, cargo canisters and
15882                                                                          ; escape pods along for the ride). Specifically, we move
15883                                                                          ; them in the z-axis by a fixed amount in the opposite
15884                                                                          ; direction to travel, thus performing a jump towards
15885                                                                          ; our destination
15886 4888 020D  20        li   ra,>81*256                 ; LDA #&81          ; Set R = R = P = &81
     488A 8100     
15887 488C D80D  30        movb ra,@S                      ; STA S
     488E 0092     
15888 4890 D80D  30        movb ra,@R                      ; STA R
     4892 0091     
15889 4894 D80D  30        movb ra,@P                      ; STA P
     4896 001B     
15890               
15891 4898 D360  30        movb @K.+8,ra                   ; LDA K%+8          ; Set A = z_sign for the planet
     489A 0908     
15892               
15893 489C 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     489E 44BA     
15894 48A0 06A0  32        bl   @jsr                       ;
     48A2 FE1E     
15895                                                                          ; = (z_sign &81) + &8181
15896                                                                          ; = (z_sign &81) - &0181
15897                                                                          ;
15898                                                                          ; This moves the planet against the direction of travel
15899                                                                          ; by reducing z_sign by 1, as the above maths is:
15900                                                                          ;
15901                                                                          ; z_sign 00000000
15902                                                                          ; +   00000000 10000001
15903                                                                          ; -   00000001 10000001
15904                                                                          ;
15905                                                                          ; or:
15906                                                                          ;
15907                                                                          ; z_sign 00000000
15908                                                                          ; +   00000000 00000000
15909                                                                          ; -   00000001 00000000
15910                                                                          ;
15911                                                                          ; i.e. the high byte is z_sign - 1, making sure the sign
15912                                                                          ; is preserved
15913               
15914 48A4 D80D  30        movb ra,@K.+8                   ; STA K%+8          ; Set the planet's z_sign to the high byte of the result
     48A6 0908     
15915               
15916 48A8 D360  30        movb @K.+NI.+8,ra               ; LDA K%+NI%+8      ; Set A = z_sign for the sun
     48AA 092C     
15917               
15918 48AC 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     48AE 44BA     
15919 48B0 06A0  32        bl   @jsr                       ;
     48B2 FE1E     
15920                                                                          ; = (z_sign &81) + &8181
15921                                                                          ; = (z_sign &81) - &0181
15922                                                                          ;
15923                                                                          ; which moves the sun against the direction of travel
15924                                                                          ; by reducing z_sign by 1
15925               
15926 48B4 D80D  30        movb ra,@K.+NI.+8               ; STA K%+NI%+8      ; Set the planet's z_sign to the high byte of the result
     48B6 092C     
15927               
15928 48B8 020D  20        li   ra,>01*256                 ; LDA #1            ; Temporarily set the view type to a non-zero value, so
     48BA 0100     
15929 48BC D80D  30        movb ra,@QQ11                   ; STA QQ11          ; the call to LOOK1 below clears the screen before
     48BE 0096     
15930                                                                          ; switching to the space view
15931               
15932 48C0 D80D  30        movb ra,@MCNT                   ; STA MCNT          ; Set the main loop counter to 1, so the next iteration
     48C2 0099     
15933                                                                          ; through the main loop will potentially spawn ships
15934                                                                          ; (see part 2 of the main game loop at me3)
15935               
15936 48C4 091D  18        srl  ra,1                       ; LSR A             ; Set EV, the extra vessels spawning counter, to 0
15937 48C6 D80D  30        movb ra,@EV                     ; STA EV            ; (the LSR produces a 0 as A was previously 1)
     48C8 0D63     
15938               
15939 48CA D3A0  30        movb @VIEW,rx                   ; LDX VIEW          ; Set X to the current view (front, rear, left or right)
     48CC 0D5F     
15940 48CE 0460  28        b    @LOOK1                     ; JMP LOOK1         ; and jump to LOOK1 to initialise that view, returning
     48D0 4AC4     
15941                                                                          ; from the subroutine using a tail call
15942               
15943               WA1:
15944 48D2 020D  20        li   ra,>28*256                 ; LDA #40           ; If we get here then we can't do an in-system jump, so
     48D4 2800     
15945 48D6 0460  28        b    @NOISE                     ; JMP NOISE         ; call the NOISE routine with A = 40 to make a long, low
     48D8 CBB0     
15946                                                                          ; beep and return from the subroutine using a tail call
15947               
15948               * ******************************************************************************
15949               *
15950               * Name: LASLI
15951               * Type: Subroutine
15952               * Category: Drawing lines
15953               * Summary: Draw the laser lines for when we fire our lasers
15954               *
15955               * ------------------------------------------------------------------------------
15956               *
15957               * Draw the laser lines, aiming them to slightly different place each time so
15958               * they appear to flicker and dance. Also heat up the laser temperature and drain
15959               * some energy.
15960               *
15961               * ------------------------------------------------------------------------------
15962               *
15963               * Other entry points:
15964               *
15965               * LASLI2              Just draw the current laser lines without moving the
15966               * centre point, draining energy or heating up. This has
15967               * the effect of removing the lines from the screen
15968               *
15969               * LASLI-1             Contains an RTS
15970               *
15971               * ******************************************************************************
15972               
15973               LASLI:
15974 48DA 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     48DC C07C     
15975 48DE 06A0  32        bl   @jsr                       ;
     48E0 FE1E     
15976               
15977 48E2 024D  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     48E4 0700     
15978               
15979                      .adi ((Y-4)*256)                ; ADC #Y-4          ; Set LASY to four pixels above the centre of the
     **** ****     > ADI
0001 48E6 1701  14        jnc  !
0002 48E8 B347  18        ab   rone,ra
0003               !:
0004 48EA 022D  22        ai   ra,((Y-4)*256)
     48EC 5C00     
                   < elite.a99
15980 48EE D80D  30        movb ra,@LASY                   ; STA LASY          ; screen (#Y), plus our random number, so the laser
     48F0 0F15     
15981                                                                          ; dances above and below the centre point
15982               
15983 48F2 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     48F4 C07C     
15984 48F6 06A0  32        bl   @jsr                       ;
     48F8 FE1E     
15985               
15986 48FA 024D  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     48FC 0700     
15987               
15988                      .adi ((X-4)*256)                ; ADC #X-4          ; Set LASX to four pixels left of the centre of the
     **** ****     > ADI
0001 48FE 1701  14        jnc  !
0002 4900 B347  18        ab   rone,ra
0003               !:
0004 4902 022D  22        ai   ra,((X-4)*256)
     4904 7C00     
                   < elite.a99
15989 4906 D80D  30        movb ra,@LASX                   ; STA LASX          ; screen (#X), plus our random number, so the laser
     4908 0F14     
15990                                                                          ; dances to the left and right of the centre point
15991               
15992 490A D360  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Add 8 to the laser temperature in GNTMP
     490C 0D61     
15993                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 490E 1701  14        jnc  !
0002 4910 B347  18        ab   rone,ra
0003               !:
0004 4912 022D  22        ai   ra,(>08*256)
     4914 0800     
                   < elite.a99
15994 4916 D80D  30        movb ra,@GNTMP                  ; STA GNTMP
     4918 0D61     
15995               
15996 491A 0200  20        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     491C ACE2     
15997 491E 06A0  32        bl   @jsr                       ;
     4920 FE1E     
15998               
15999               LASLI2:
16000 4922 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     4924 0096     
16001 4926 1632  14        jne  PU1-1                      ; BNE PU1-1         ; then jump to MA9 to return from the main flight loop
16002                                                                          ; (as PU1-1 is an RTS)
16003               
16004 4928 020D  20        li   ra,>20*256                 ; LDA #32           ; Set A = 32 and Y = 224 for the first set of laser
     492A 2000     
16005 492C 020F  20        li   ry,>e0*256                 ; LDY #224          ; lines (the wider pair of lines)
     492E E000     
16006               
16007 4930 0200  20        li   rtmp,las_                  ; JSR las           ; Call las below to draw the first set of laser lines
     4932 4940     
16008 4934 06A0  32        bl   @jsr                       ;
     4936 FE1E     
16009               
16010 4938 020D  20        li   ra,>30*256                 ; LDA #48           ; Fall through into las with A = 48 and Y = 208 to draw
     493A 3000     
16011 493C 020F  20        li   ry,>d0*256                 ; LDY #208          ; a second set of lines (the narrower pair)
     493E D000     
16012               
16013                                                                          ; The following routine draws two laser lines, one from
16014                                                                          ; the centre point down to point A on the bottom row,
16015                                                                          ; and the other from the centre point down to point Y
16016                                                                          ; on the bottom row. We therefore get lines from the
16017                                                                          ; centre point to points 32, 48, 208 and 224 along the
16018                                                                          ; bottom row, giving us the triangular laser effect
16019                                                                          ; we're after
16020               
16021               las_:
16022 4940 D80D  30        movb ra,@X2                     ; STA X2            ; Set X2 = A
     4942 0033     
16023               
16024 4944 D360  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     4946 0F14     
16025 4948 D80D  30        movb ra,@X1                     ; STA X1
     494A 0031     
16026 494C D360  30        movb @LASY,ra                   ; LDA LASY
     494E 0F15     
16027 4950 D80D  30        movb ra,@Y1                     ; STA Y1
     4952 0032     
16028               
16029 4954 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4956 BF00     
16030 4958 D80D  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     495A 0034     
16031                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16032                                                                          ; pixel row of the space view
16033               
16034 495C 0200  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     495E 224E     
16035 4960 06A0  32        bl   @jsr                       ;
     4962 FE1E     
16036                                                                          ; the centre point to (A, 191)
16037               
16038 4964 D360  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     4966 0F14     
16039 4968 D80D  30        movb ra,@X1                     ; STA X1
     496A 0031     
16040 496C D360  30        movb @LASY,ra                   ; LDA LASY
     496E 0F15     
16041 4970 D80D  30        movb ra,@Y1                     ; STA Y1
     4972 0032     
16042               
16043 4974 D80F  30        movb ry,@X2                     ; STY X2            ; Set X2 = Y
     4976 0033     
16044               
16045 4978 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
     497A BF00     
16046 497C D80D  30        movb ra,@Y2                     ; STA Y2            ; pixel row of the space view (as before)
     497E 0034     
16047               
16048 4980 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     4982 224E     
16049                                                                          ; the centre point to (Y, 191), and return from
16050                                                                          ; the subroutine using a tail call
16051               
16052               * ******************************************************************************
16053               *
16054               * Name: PLUT
16055               * Type: Subroutine
16056               * Category: Flight
16057               * Summary: Flip the coordinate axes for the four different views
16058               * Deep dive: Flipping axes between space views
16059               *
16060               * ------------------------------------------------------------------------------
16061               *
16062               * This routine flips the relevant geometric axes in INWK depending on which
16063               * view we are looking through (front, rear, left, right).
16064               *
16065               * ------------------------------------------------------------------------------
16066               *
16067               * Other entry points:
16068               *
16069               * PU1-1               Contains an RTS
16070               *
16071               * ******************************************************************************
16072               
16073               PLUT:
16074 4984 D3A0  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     4986 0D5F     
16075                                                                          ;
16076                                                                          ; 0 = front
16077                                                                          ; 1 = rear
16078                                                                          ; 2 = left
16079                                                                          ; 3 = right
16080               
16081 4988 1602  14        jne  PU1                        ; BNE PU1           ; If the current view is the front view, return from the
16082 498A 0460  28        b    @rts                       ; RTS               ; subroutine, as the geometry in INWK is already correct
     498C FE2A     
16083               
16084               PU1:
16085 498E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the view, so now:
16086                                                                          ;
16087                                                                          ; 0 = rear
16088                                                                          ; 1 = left
16089                                                                          ; 2 = right
16090               
16091 4990 163A  14        jne  PU2                        ; BNE PU2           ; If the current view is left or right, jump to PU2,
16092                                                                          ; otherwise this is the rear view, so continue on
16093               
16094 4992 D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Flip the sign of x_sign
     4994 0055     
16095                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4996 0200  20        li   rtmp,(>80*256)
     4998 8000     
0002 499A 2B40  18        xor  rtmp,ra
                   < elite.a99
16096 499C D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     499E 0055     
16097               
16098 49A0 D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Flip the sign of z_sign
     49A2 005B     
16099                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49A4 0200  20        li   rtmp,(>80*256)
     49A6 8000     
0002 49A8 2B40  18        xor  rtmp,ra
                   < elite.a99
16100 49AA D80D  30        movb ra,@INWK+8                 ; STA INWK+8
     49AC 005B     
16101               
16102 49AE D360  30        movb @INWK+10,ra                ; LDA INWK+10       ; Flip the sign of nosev_x_hi
     49B0 005D     
16103                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49B2 0200  20        li   rtmp,(>80*256)
     49B4 8000     
0002 49B6 2B40  18        xor  rtmp,ra
                   < elite.a99
16104 49B8 D80D  30        movb ra,@INWK+10                ; STA INWK+10
     49BA 005D     
16105               
16106 49BC D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; Flip the sign of nosev_z_hi
     49BE 0061     
16107                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49C0 0200  20        li   rtmp,(>80*256)
     49C2 8000     
0002 49C4 2B40  18        xor  rtmp,ra
                   < elite.a99
16108 49C6 D80D  30        movb ra,@INWK+14                ; STA INWK+14
     49C8 0061     
16109               
16110 49CA D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Flip the sign of roofv_x_hi
     49CC 0063     
16111                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49CE 0200  20        li   rtmp,(>80*256)
     49D0 8000     
0002 49D2 2B40  18        xor  rtmp,ra
                   < elite.a99
16112 49D4 D80D  30        movb ra,@INWK+16                ; STA INWK+16
     49D6 0063     
16113               
16114 49D8 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Flip the sign of roofv_z_hi
     49DA 0067     
16115                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49DC 0200  20        li   rtmp,(>80*256)
     49DE 8000     
0002 49E0 2B40  18        xor  rtmp,ra
                   < elite.a99
16116 49E2 D80D  30        movb ra,@INWK+20                ; STA INWK+20
     49E4 0067     
16117               
16118 49E6 D360  30        movb @INWK+22,ra                ; LDA INWK+22       ; Flip the sign of sidev_x_hi
     49E8 0069     
16119                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49EA 0200  20        li   rtmp,(>80*256)
     49EC 8000     
0002 49EE 2B40  18        xor  rtmp,ra
                   < elite.a99
16120 49F0 D80D  30        movb ra,@INWK+22                ; STA INWK+22
     49F2 0069     
16121               
16122 49F4 D360  30        movb @INWK+26,ra                ; LDA INWK+26       ; Flip the sign of roofv_z_hi
     49F6 006D     
16123                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 49F8 0200  20        li   rtmp,(>80*256)
     49FA 8000     
0002 49FC 2B40  18        xor  rtmp,ra
                   < elite.a99
16124 49FE D80D  30        movb ra,@INWK+26                ; STA INWK+26
     4A00 006D     
16125               
16126 4A02 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4A04 FE2A     
16127               
16128               PU2:
16129                                                                          ; We enter this with X set to the view, as follows:
16130                                                                          ;
16131                                                                          ; 1 = left
16132                                                                          ; 2 = right
16133 4A06 020D  20        li   ra,>00*256                 ; LDA #0            ; Set RAT2 = 0 (left view) or -1 (right view)
     4A08 0000     
16134 4A0A 028E  22        ci   rx,>02*256                 ; CPX #2
     4A0C 0200     
16135 4A0E 06A0  32        bl   @rora                      ; ROR A
     4A10 FE58     
16136 4A12 D80D  30        movb ra,@RAT2                   ; STA RAT2
     4A14 00AB     
16137               
16138                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT = -1 (left view) or 0 (right view)
     **** ****     > EOI
0001 4A16 0200  20        li   rtmp,(>80*256)
     4A18 8000     
0002 4A1A 2B40  18        xor  rtmp,ra
                   < elite.a99
16139 4A1C D80D  30        movb ra,@RAT                    ; STA RAT
     4A1E 00AA     
16140               
16141 4A20 D360  30        movb @INWK,ra                   ; LDA INWK          ; Swap x_lo and z_lo
     4A22 0053     
16142 4A24 D3A0  30        movb @INWK+6,rx                 ; LDX INWK+6
     4A26 0059     
16143 4A28 D80D  30        movb ra,@INWK+6                 ; STA INWK+6
     4A2A 0059     
16144 4A2C D80E  30        movb rx,@INWK                   ; STX INWK
     4A2E 0053     
16145               
16146 4A30 D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Swap x_hi and z_hi
     4A32 0054     
16147 4A34 D3A0  30        movb @INWK+7,rx                 ; LDX INWK+7
     4A36 005A     
16148 4A38 D80D  30        movb ra,@INWK+7                 ; STA INWK+7
     4A3A 005A     
16149 4A3C D80E  30        movb rx,@INWK+1                 ; STX INWK+1
     4A3E 0054     
16150               
16151 4A40 D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Swap x_sign and z_sign
     4A42 0055     
16152                      .eor @RAT                       ; EOR RAT           ; If left view, flip sign of new z_sign
     **** ****     > EOR
0001 4A44 D020  30        movb @RAT,rtmp
     4A46 00AA     
0002 4A48 2B40  18        xor  rtmp,ra
                   < elite.a99
16153 4A4A D38D  18        movb ra,rx                      ; TAX               ; If right view, flip sign of new x_sign
16154 4A4C D360  30        movb @INWK+8,ra                 ; LDA INWK+8
     4A4E 005B     
16155                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4A50 D020  30        movb @RAT2,rtmp
     4A52 00AB     
0002 4A54 2B40  18        xor  rtmp,ra
                   < elite.a99
16156 4A56 D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     4A58 0055     
16157 4A5A D80E  30        movb rx,@INWK+8                 ; STX INWK+8
     4A5C 005B     
16158               
16159 4A5E 020F  20        li   ry,>09*256                 ; LDY #9            ; Swap nosev_x_lo and nosev_z_lo
     4A60 0900     
16160 4A62 0200  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap nosev_x_hi and nosev_z_hi
     4A64 4A7A     
16161 4A66 06A0  32        bl   @jsr                       ;
     4A68 FE1E     
16162                                                                          ; If left view, flip sign of new nosev_z_hi
16163                                                                          ; If right view, flip sign of new nosev_x_hi
16164               
16165 4A6A 020F  20        li   ry,>0f*256                 ; LDY #15           ; Swap roofv_x_lo and roofv_z_lo
     4A6C 0F00     
16166 4A6E 0200  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap roofv_x_hi and roofv_z_hi
     4A70 4A7A     
16167 4A72 06A0  32        bl   @jsr                       ;
     4A74 FE1E     
16168                                                                          ; If left view, flip sign of new roofv_z_hi
16169                                                                          ; If right view, flip sign of new roofv_x_hi
16170               
16171 4A76 020F  20        li   ry,>15*256                 ; LDY #21           ; Swap sidev_x_lo and sidev_z_lo
     4A78 1500     
16172                                                                          ; Swap sidev_x_hi and sidev_z_hi
16173                                                                          ; If left view, flip sign of new sidev_z_hi
16174                                                                          ; If right view, flip sign of new sidev_x_hi
16175               
16176               PUS1:
16177 4A7A D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Swap the low x and z bytes for the vector in Y:
     4A7C 0053     
16178 4A7E D3AF  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ;
     4A80 0057     
16179 4A82 DBCD  38        movb ra,@INWK+4(ry)             ; STA INWK+4,Y      ; * For Y =  9 swap nosev_x_lo and nosev_z_lo
     4A84 0057     
16180 4A86 DBCE  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; * For Y = 15 swap roofv_x_lo and roofv_z_lo
     4A88 0053     
16181                                                                          ; * For Y = 21 swap sidev_x_lo and sidev_z_lo
16182               
16183 4A8A D36F  34        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Swap the high x and z bytes for the offset in Y:
     4A8C 0054     
16184                      .eor @RAT                       ; EOR RAT           ;
     **** ****     > EOR
0001 4A8E D020  30        movb @RAT,rtmp
     4A90 00AA     
0002 4A92 2B40  18        xor  rtmp,ra
                   < elite.a99
16185 4A94 D38D  18        movb ra,rx                      ; TAX               ; * If left view, flip sign of new z-coordinate
16186 4A96 D36F  34        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; * If right view, flip sign of new x-coordinate
     4A98 0058     
16187                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4A9A D020  30        movb @RAT2,rtmp
     4A9C 00AB     
0002 4A9E 2B40  18        xor  rtmp,ra
                   < elite.a99
16188 4AA0 DBCD  38        movb ra,@INWK+1(ry)             ; STA INWK+1,Y
     4AA2 0054     
16189 4AA4 DBCE  38        movb rx,@INWK+5(ry)             ; STX INWK+5,Y
     4AA6 0058     
16190               
16191                                                                          ; Fall through into LOOK1 to return from the subroutine
16192               
16193               * ******************************************************************************
16194               *
16195               * Name: LOOK1
16196               * Type: Subroutine
16197               * Category: Flight
16198               * Summary: Initialise the space view
16199               *
16200               * ------------------------------------------------------------------------------
16201               *
16202               * Initialise the space view, with the direction of view given in X. This clears
16203               * the upper screen and draws the laser crosshairs, if the view in X has lasers
16204               * fitted. It also wipes all the ships from the scanner, so we can recalculate
16205               * ship positions for the new view (they get put back in the main flight loop).
16206               *
16207               * ------------------------------------------------------------------------------
16208               *
16209               * Arguments:
16210               *
16211               * X                   The space view to set:
16212               *
16213               * * 0 = front
16214               * * 1 = rear
16215               * * 2 = left
16216               * * 3 = right
16217               *
16218               * ------------------------------------------------------------------------------
16219               *
16220               * Other entry points:
16221               *
16222               * LO2                 Contains an RTS
16223               *
16224               * ******************************************************************************
16225               
16226               LO2:
16227 4AA8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4AAA FE2A     
16228               
16229               LQ:
16230 4AAC D80E  30        movb rx,@VIEW                   ; STX VIEW          ; Set the current space view to X
     4AAE 0D5F     
16231               
16232 4AB0 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4AB2 4B2A     
16233 4AB4 06A0  32        bl   @jsr                       ;
     4AB6 FE1E     
16234                                                                          ; and set the current view type in QQ11 to 0 (space
16235                                                                          ; view)
16236               
16237 4AB8 0200  20        li   rtmp,SIGHT                 ; JSR SIGHT         ; Draw the laser crosshairs
     4ABA 4AF0     
16238 4ABC 06A0  32        bl   @jsr                       ;
     4ABE FE1E     
16239               
16240 4AC0 0460  28        b    @NWSTARS                   ; JMP NWSTARS       ; Set up a new stardust field and return from the
     4AC2 ABE6     
16241                                                                          ; subroutine using a tail call
16242               
16243               LOOK1:
16244 4AC4 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, the type number of a space view
     4AC6 0000     
16245               
16246 4AC8 D3E0  30        movb @QQ11,ry                   ; LDY QQ11          ; If the current view is not a space view, jump up to LQ
     4ACA 0096     
16247 4ACC 16EF  14        jne  LQ                         ; BNE LQ            ; to set up a new space view
16248               
16249 4ACE 93A0  30        cb   @VIEW,rx                   ; CPX VIEW          ; If the current view is already of type X, jump to LO2
     4AD0 0D5F     
16250 4AD2 13EA  14        jeq  LO2                        ; BEQ LO2           ; to return from the subroutine (as LO2 contains an RTS)
16251               
16252 4AD4 D80E  30        movb rx,@VIEW                   ; STX VIEW          ; Change the current space view to X
     4AD6 0D5F     
16253               
16254 4AD8 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4ADA 4B2A     
16255 4ADC 06A0  32        bl   @jsr                       ;
     4ADE FE1E     
16256                                                                          ; and set the current view type in QQ11 to 0 (space
16257                                                                          ; view)
16258               
16259 4AE0 0200  20        li   rtmp,FLIP                  ; JSR FLIP          ; Swap the x- and y-coordinates of all the stardust
     4AE2 2964     
16260 4AE4 06A0  32        bl   @jsr                       ;
     4AE6 FE1E     
16261                                                                          ; particles and redraw the stardust field
16262               
16263 4AE8 0200  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all the ships from the scanner and mark them all
     4AEA AC30     
16264 4AEC 06A0  32        bl   @jsr                       ;
     4AEE FE1E     
16265                                                                          ; as not being shown on-screen
16266               
16267                                                                          ; And fall through into SIGHT to draw the laser
16268                                                                          ; crosshairs
16269               
16270               * ******************************************************************************
16271               *
16272               * Name: SIGHT
16273               * Type: Subroutine
16274               * Category: Flight
16275               * Summary: Draw the laser crosshairs
16276               *
16277               * ******************************************************************************
16278               
16279               SIGHT:
16280 4AF0 D3E0  30        movb @VIEW,ry                   ; LDY VIEW          ; Fetch the laser power for our new view
     4AF2 0D5F     
16281 4AF4 D36F  34        movb @LASER(ry),ra              ; LDA LASER,Y
     4AF6 0310     
16282               
16283 4AF8 13D7  14        jeq  LO2                        ; BEQ LO2           ; If it is zero (i.e. there is no laser fitted to this
16284                                                                          ; view), jump to LO2 to return from the subroutine (as
16285                                                                          ; LO2 contains an RTS)
16286               
16287 4AFA 020D  20        li   ra,>80*256                 ; LDA #128          ; Set QQ19 to the x-coordinate of the centre of the
     4AFC 8000     
16288 4AFE D80D  30        movb ra,@QQ19                   ; STA QQ19          ; screen
     4B00 007F     
16289               
16290 4B02 020D  20        li   ra,(Y-24)*256              ; LDA #Y-24         ; Set QQ19+1 to the y-coordinate of the centre of the
     4B04 4800     
16291 4B06 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; screen, minus 24 (because TT15 will add 24 to the
     4B08 0080     
16292                                                                          ; coordinate when it draws the crosshairs)
16293               
16294 4B0A 020D  20        li   ra,>14*256                 ; LDA #20           ; Set QQ19+2 to size 20 for the crosshairs size
     4B0C 1400     
16295 4B0E D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4B10 0081     
16296               
16297 4B12 0200  20        li   rtmp,TT15                  ; JSR TT15          ; Call TT15 to draw crosshairs of size 20 just to the
     4B14 5316     
16298 4B16 06A0  32        bl   @jsr                       ;
     4B18 FE1E     
16299                                                                          ; left of the middle of the screen
16300               
16301 4B1A 020D  20        li   ra,>0a*256                 ; LDA #10           ; Set QQ19+2 to size 10 for the crosshairs size
     4B1C 0A00     
16302 4B1E D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4B20 0081     
16303               
16304 4B22 0460  28        b    @TT15                      ; JMP TT15          ; Call TT15 to draw crosshairs of size 10 at the same
     4B24 5316     
16305                                                                          ; location, which will remove the centre part from the
16306                                                                          ; laser crosshairs, leaving a gap in the middle, and
16307                                                                          ; return from the subroutine using a tail call
16308               
16309               * ******************************************************************************
16310               *
16311               * Name: TT66
16312               * Type: Subroutine
16313               * Category: Drawing the screen
16314               * Summary: Clear the screen and set the current view type
16315               *
16316               * ------------------------------------------------------------------------------
16317               *
16318               * Clear the top part of the screen, draw a white border, and set the current
16319               * view type in QQ11 to A.
16320               *
16321               * ------------------------------------------------------------------------------
16322               *
16323               * Arguments:
16324               *
16325               * A                   The type of the new current view (see QQ11 for a list of
16326               * view types)
16327               *
16328               * ------------------------------------------------------------------------------
16329               *
16330               * Other entry points:
16331               *
16332               * TT66-2              Call TT66 with A = 1
16333               *
16334               * ******************************************************************************
16335               
16336 4B26 020D  20        li   ra,>01*256                 ; LDA #1            ; Set the view type to 1 when this is called via the
     4B28 0100     
16337                                                                          ; TT66-2 entry point
16338               
16339               TT66:
16340 4B2A D80D  30        movb ra,@QQ11                   ; STA QQ11          ; Set the current view type in QQ11 to A
     4B2C 0096     
16341               
16342                                                                          ; Fall through into TTX66 to clear the screen and draw a
16343                                                                          ; white border
16344               
16345               * ******************************************************************************
16346               *
16347               * Name: TTX66
16348               * Type: Subroutine
16349               * Category: Drawing the screen
16350               * Summary: Clear the top part of the screen and draw a white border
16351               *
16352               * ------------------------------------------------------------------------------
16353               *
16354               * Clear the top part of the screen (the space view) and draw a white border
16355               * along the top and sides.
16356               *
16357               * ------------------------------------------------------------------------------
16358               *
16359               * Other entry points:
16360               *
16361               * BOX                 Just draw the border and (if this is a space view) the
16362               * view name. This can be used to remove the border and
16363               * view name, as it is drawn using EOR logic
16364               *
16365               * ******************************************************************************
16366               
16367               TTX66:
16368 4B2E 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     4B30 8000     
16369 4B32 D80D  30        movb ra,@QQ17                   ; STA QQ17
     4B34 007E     
16370               
16377               
16378                      .asla                           ; ASL A             ; Set LAS2 to 0, as 128 << 1 = %10000000 << 1 = 0. This
     **** ****     > ASLA
0001 4B36 024D  22        andi ra,>ff00
     4B38 FF00     
0002 4B3A 0A1D  18        sla  ra,1
                   < elite.a99
16379 4B3C D80D  30        movb ra,@LAS2                   ; STA LAS2          ; stops any laser pulsing
     4B3E 0D5D     
16380               
16382               
16383 4B40 D80D  30        movb ra,@DLY                    ; STA DLY           ; Set the delay in DLY to 0, to indicate that we are
     4B42 0D64     
16384                                                                          ; no longer showing an in-flight message, so any new
16385                                                                          ; in-flight messages will be shown instantly
16386               
16387 4B44 D80D  30        movb ra,@de_                    ; STA de            ; Clear de, the flag that appends " DESTROYED" to the
     4B46 0D65     
16388                                                                          ; end of the next text token, so that it doesn't
16389               
16390 4B48 020E  20        li   rx,>60*256                 ; LDX #&60          ; Set X to the screen memory page for the top row of the
     4B4A 6000     
16391                                                                          ; screen (as screen memory starts at &6000)
16392               
16393               BOL1:
16394 4B4C 0200  20        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X, which clears
     4B4E C81E     
16395 4B50 06A0  32        bl   @jsr                       ;
     4B52 FE1E     
16396                                                                          ; that character row on the screen
16397               
16398 4B54 B387  18        ab   rone,rx                    ; INX               ; Increment X to point to the next page, i.e. the next
16399                                                                          ; character row
16400               
16401 4B56 028E  22        ci   rx,>78*256                 ; CPX #&78          ; Loop back to BOL1 until we have cleared page &7700,
     4B58 7800     
16402 4B5A 16F8  14        jne  BOL1                       ; BNE BOL1          ; the last character row in the space view part of the
16403                                                                          ; screen (the top part)
16404               
16405 4B5C D3A0  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Fetch into X the number that's shown on-screen during
     4B5E 002F     
16406                                                                          ; the hyperspace countdown
16407               
16408 4B60 1304  14        jeq  BOX                        ; BEQ BOX           ; If the counter is zero then we are not counting down
16409                                                                          ; to hyperspace, so jump to BOX to skip the next
16410                                                                          ; instruction
16411               
16412 4B62 0200  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     4B64 5D36     
16413 4B66 06A0  32        bl   @jsr                       ;
     4B68 FE1E     
16414                                                                          ; i.e. print the hyperspace countdown in the top-left
16415                                                                          ; corner
16416               
16417               BOX:
16418 4B6A 020F  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     4B6C 0100     
16419 4B6E D80F  30        movb ry,@YC                     ; STY YC
     4B70 002D     
16420               
16421 4B72 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to tt66 to skip
     4B74 0096     
16422 4B76 1616  14        jne  tt66_                      ; BNE tt66          ; displaying the view name
16423               
16424 4B78 020F  20        li   ry,>0b*256                 ; LDY #11           ; Move the text cursor to row 11
     4B7A 0B00     
16425 4B7C D80F  30        movb ry,@XC                     ; STY XC
     4B7E 002C     
16426               
16427 4B80 D360  30        movb @VIEW,ra                   ; LDA VIEW          ; Load the current view into A:
     4B82 0D5F     
16428                                                                          ;
16429                                                                          ; 0 = front
16430                                                                          ; 1 = rear
16431                                                                          ; 2 = left
16432                                                                          ; 3 = right
16433               
16434 4B84 026D  22        ori  ra,>60*256                 ; ORA #&60          ; OR with &60 so we get a value of &60 to &63 (96 to 99)
     4B86 6000     
16435               
16436 4B88 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print recursive token 96 to 99, which will be in the
     4B8A A6E8     
16437 4B8C 06A0  32        bl   @jsr                       ;
     4B8E FE1E     
16438                                                                          ; range "FRONT" to "RIGHT"
16439               
16440 4B90 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     4B92 5E64     
16441 4B94 06A0  32        bl   @jsr                       ;
     4B96 FE1E     
16442               
16443 4B98 020D  20        li   ra,>af*256                 ; LDA #175          ; Print recursive token 15 ("VIEW ")
     4B9A AF00     
16444 4B9C 0200  20        li   rtmp,TT27                  ; JSR TT27
     4B9E A6E8     
16445 4BA0 06A0  32        bl   @jsr                       ;
     4BA2 FE1E     
16446               
16447               tt66_:
16448 4BA4 020E  20        li   rx,>00*256                 ; LDX #0            ; Set (X1, Y1) to (0, 0)
     4BA6 0000     
16449 4BA8 D80E  30        movb rx,@X1                     ; STX X1
     4BAA 0031     
16450 4BAC D80E  30        movb rx,@Y1                     ; STX Y1
     4BAE 0032     
16451               
16452 4BB0 D80E  30        movb rx,@QQ17                   ; STX QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     4BB2 007E     
16453               
16454 4BB4 7387  18        sb   rone,rx                    ; DEX               ; Set X2 = 255
16455 4BB6 D80E  30        movb rx,@X2                     ; STX X2
     4BB8 0033     
16456               
16457 4BBA 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1), so
     4BBC 25EE     
16458 4BBE 06A0  32        bl   @jsr                       ;
     4BC0 FE1E     
16459                                                                          ; that's (0, 0) to (255, 0), along the very top of the
16460                                                                          ; screen
16461               
16462 4BC2 020D  20        li   ra,>02*256                 ; LDA #2            ; Set X1 = X2 = 2
     4BC4 0200     
16463 4BC6 D80D  30        movb ra,@X1                     ; STA X1
     4BC8 0031     
16464 4BCA D80D  30        movb ra,@X2                     ; STA X2
     4BCC 0033     
16465               
16466 4BCE 0200  20        li   rtmp,BOS2                  ; JSR BOS2          ; Call BOS2 below, which will call BOS1 twice, and then
     4BD0 4BD6     
16467 4BD2 06A0  32        bl   @jsr                       ;
     4BD4 FE1E     
16468                                                                          ; fall through into BOS2 again, so we effectively do
16469                                                                          ; BOS1 four times, decrementing X1 and X2 each time
16470                                                                          ; before calling LOIN, so this whole loop-within-a-loop
16471                                                                          ; mind-bender ends up drawing these four lines:
16472                                                                          ;
16473                                                                          ; (1, 0)   to (1, 191)
16474                                                                          ; (0, 0)   to (0, 191)
16475                                                                          ; (255, 0) to (255, 191)
16476                                                                          ; (254, 0) to (254, 191)
16477                                                                          ;
16478                                                                          ; So that's a 2-pixel wide vertical border along the
16479                                                                          ; left edge of the upper part of the screen, and a
16480                                                                          ; 2-pixel wide vertical border along the right edge
16481               
16482               BOS2:
16483 4BD6 0200  20        li   rtmp,BOS1                  ; JSR BOS1          ; Call BOS1 below and then fall through into it, which
     4BD8 4BDE     
16484 4BDA 06A0  32        bl   @jsr                       ;
     4BDC FE1E     
16485                                                                          ; ends up running BOS1 twice. This is all part of the
16486                                                                          ; loop-the-loop border-drawing mind-bender explained
16487                                                                          ; above
16488               
16489               BOS1:
16490 4BDE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set Y1 = 0
     4BE0 0000     
16491 4BE2 D80D  30        movb ra,@Y1                     ; STA Y1
     4BE4 0032     
16492               
16493 4BE6 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4BE8 BF00     
16494 4BEA D80D  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     4BEC 0034     
16495                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16496                                                                          ; pixel row of the space view
16497               
16498 4BEE 7347  18        sb   rone,ra                    ; DEC X1            ; Decrement X1 and X2
16499 4BF0 7347  18        sb   rone,ra                    ; DEC X2
16500               
16501 4BF2 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), and return from
     4BF4 224E     
16502                                                                          ; the subroutine using a tail call
16503               
16504               * ******************************************************************************
16505               *
16506               * Name: DELAY
16507               * Type: Subroutine
16508               * Category: Utility routines
16509               * Summary: Wait for a specified time, in 1/50s of a second
16510               *
16511               * ------------------------------------------------------------------------------
16512               *
16513               * Wait for the number of vertical syncs given in Y, so this effectively waits
16514               * for Y/50 of a second (as the vertical sync occurs 50 times a second).
16515               *
16516               * ------------------------------------------------------------------------------
16517               *
16518               * Arguments:
16519               *
16520               * Y                   The number of vertical sync events to wait for
16521               *
16522               * ------------------------------------------------------------------------------
16523               *
16524               * Other entry points:
16525               *
16526               * DEL8                Wait for 8/50 of a second (0.16 seconds)
16527               *
16528               * DELAY-5             Wait for 2/50 of a second (0.04 seconds)
16529               *
16530               * ******************************************************************************
16531               
16532 4BF6 020F  20        li   ry,>02*256                 ; LDY #2            ; Set Y to 2 vertical syncs
     4BF8 0200     
16533               
16534 4BFA 2C              byte >2c                                            ; Skip the next instruction by turning it into
16535                                                                          ; &2C &A0 &08, or BIT &08A0, which does nothing apart
16536                                                                          ; from affect the flags
16537               
16538               DEL8:
16539 4BFC 020F  20        li   ry,>08*256                 ; LDY #8            ; Set Y to 8 vertical syncs and fall through into DELAY
     4BFE 0800     
16540                                                                          ; to wait for this long
16541               
16542               DELAY:
16543 4C00 0200  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     4C02 4DE2     
16544 4C04 06A0  32        bl   @jsr                       ;
     4C06 FE1E     
16545                                                                          ; screen gets drawn
16546               
16547 4C08 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter in Y
16548               
16549 4C0A 16FA  14        jne  DELAY                      ; BNE DELAY         ; If Y isn't yet at zero, jump back to DELAY to wait
16550                                                                          ; for another vertical sync
16551               
16552 4C0C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4C0E FE2A     
16553               
16554               * ******************************************************************************
16555               *
16556               * Name: hm
16557               * Type: Subroutine
16558               * Category: Charts
16559               * Summary: Select the closest system and redraw the chart crosshairs
16560               *
16561               * ------------------------------------------------------------------------------
16562               *
16563               * Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
16564               * system, redraw the crosshairs on the chart accordingly (if they are being
16565               * shown), and, if this is not a space view, clear the bottom three text rows of
16566               * the screen.
16567               *
16568               * ******************************************************************************
16569               
16570               hm_:
16571 4C10 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4C12 5872     
16572 4C14 06A0  32        bl   @jsr                       ;
     4C16 FE1E     
16573                                                                          ; which will erase the crosshairs currently there
16574               
16575 4C18 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     4C1A 5AB8     
16576 4C1C 06A0  32        bl   @jsr                       ;
     4C1E FE1E     
16577                                                                          ; (QQ9, QQ10)
16578               
16579 4C20 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4C22 5872     
16580 4C24 06A0  32        bl   @jsr                       ;
     4C26 FE1E     
16581                                                                          ; which will draw the crosshairs at our current home
16582                                                                          ; system
16583               
16584 4C28 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, return from the subroutine
     4C2A 0096     
16585 4C2C 132A  14        jeq  SC5                        ; BEQ SC5           ; (as SC5 contains an RTS)
16586               
16587                                                                          ; Otherwise fall through into CLYNS to clear space at
16588                                                                          ; the bottom of the screen
16589               
16590               * ******************************************************************************
16591               *
16592               * Name: CLYNS
16593               * Type: Subroutine
16594               * Category: Drawing the screen
16595               * Summary: Clear the bottom three text rows of the mode 4 screen
16596               *
16597               * ------------------------------------------------------------------------------
16598               *
16599               * This routine clears some space at the bottom of the screen and moves the text
16600               * cursor to column 1, row 21.
16601               *
16602               * Specifically, it zeroes the following screen locations:
16603               *
16604               * &7507 to &75F0
16605               * &7607 to &76F0
16606               * &7707 to &77F0
16607               *
16608               * which clears the three bottom text rows of the mode 4 screen (rows 21 to 23),
16609               * clearing each row from text column 1 to 30 (so it doesn't overwrite the box
16610               * border in columns 0 and 32, or the last usable column in column 31).
16611               *
16612               * ------------------------------------------------------------------------------
16613               *
16614               * Returns:
16615               *
16616               * A                   A is set to 0
16617               *
16618               * Y                   Y is set to 0
16619               *
16620               * ******************************************************************************
16621               
16622               CLYNS:
16623 4C2E 020D  20        li   ra,>14*256                 ; LDA #20           ; Move the text cursor to row 20, near the bottom of
     4C30 1400     
16624 4C32 D80D  30        movb ra,@YC                     ; STA YC            ; the screen
     4C34 002D     
16625               
16626 4C36 020D  20        li   ra,>75*256                 ; LDA #&75          ; Set the two-byte value in SC to &7507
     4C38 7500     
16627 4C3A D80D  30        movb ra,@SC+1                   ; STA SC+1
     4C3C 0008     
16628 4C3E 020D  20        li   ra,>07*256                 ; LDA #7
     4C40 0700     
16629 4C42 D80D  30        movb ra,@SC                     ; STA SC
     4C44 0007     
16630               
16631 4C46 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline, which will move the text cursor down
     4C48 4EE6     
16632 4C4A 06A0  32        bl   @jsr                       ;
     4C4C FE1E     
16633                                                                          ; a line (to row 21) and back to column 1
16634               
16635 4C4E 020D  20        li   ra,>00*256                 ; LDA #0            ; Call LYN to clear the pixels from &7507 to &75F0
     4C50 0000     
16636 4C52 0200  20        li   rtmp,LYN                   ; JSR LYN
     4C54 4C6C     
16637 4C56 06A0  32        bl   @jsr                       ;
     4C58 FE1E     
16638               
16639 4C5A B347  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7607
16640               
16641 4C5C 0200  20        li   rtmp,LYN                   ; JSR LYN           ; Call LYN to clear the pixels from &7607 to &76F0
     4C5E 4C6C     
16642 4C60 06A0  32        bl   @jsr                       ;
     4C62 FE1E     
16643               
16644 4C64 B347  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7707
16645               
16646 4C66 B3C7  18        ab   rone,ry                    ; INY               ; Move the text cursor to column 1 (as LYN sets Y to 0)
16647 4C68 D80F  30        movb ry,@XC                     ; STY XC
     4C6A 002C     
16648               
16649                                                                          ; Fall through into LYN to clear the pixels from &7707
16650                                                                          ; to &77F0
16651               
16652               * ******************************************************************************
16653               *
16654               * Name: LYN
16655               * Type: Subroutine
16656               * Category: Drawing the screen
16657               * Summary: Clear most of a row of pixels
16658               *
16659               * ------------------------------------------------------------------------------
16660               *
16661               * Set pixels 0-233 to the value in A, starting at the pixel pointed to by SC.
16662               *
16663               * ------------------------------------------------------------------------------
16664               *
16665               * Arguments:
16666               *
16667               * A                   The value to store in pixels 1-233 (the only value that
16668               * is actually used is A = 0, which clears those pixels)
16669               *
16670               * ------------------------------------------------------------------------------
16671               *
16672               * Returns:
16673               *
16674               * Y                   Y is set to 0
16675               *
16676               * ------------------------------------------------------------------------------
16677               *
16678               * Other entry points:
16679               *
16680               * SC5                 Contains an RTS
16681               *
16682               * ******************************************************************************
16683               
16684               LYN:
16685 4C6C 020F  20        li   ry,>e9*256                 ; LDY #233          ; Set up a counter in Y to count down from pixel 233
     4C6E E900     
16686               
16687               EE2:
16688                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store A in the Y-th byte after the address pointed to
     **** ****     > ST_IND_Y_IDX
0001 4C70 D820  50        movb @SC,@rtmplb
     4C72 0007     
     4C74 206D     
0002 4C76 D020  30        movb @SC+1,rtmp
     4C78 0008     
0003 4C7A A00F  18        a    ry,rtmp
0004 4C7C D40D  30        movb RA,*rtmp
                   < elite.a99
16689                                                                          ; by SC
16690               
16691 4C7E 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y
16692               
16693 4C80 16F7  14        jne  EE2                        ; BNE EE2           ; Loop back until Y is zero
16694               
16695               SC5:
16696 4C82 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4C84 FE2A     
16697               
16698               * ******************************************************************************
16699               *
16700               * Name: SCAN
16701               * Type: Subroutine
16702               * Category: Dashboard
16703               * Summary: Display the current ship on the scanner
16704               * Deep dive: The 3D scanner
16705               *
16706               * ------------------------------------------------------------------------------
16707               *
16708               * This is used both to display a ship on the scanner, and to erase it again.
16709               *
16710               * ------------------------------------------------------------------------------
16711               *
16712               * Arguments:
16713               *
16714               * INWK                The ship's data block
16715               *
16716               * ******************************************************************************
16717               
16718               SCAN:
16719 4C86 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's scanner flag from byte #31
     4C88 0072     
16720               
16721 4C8A 024D  22        andi ra,>10*256                 ; AND #%00010000    ; If bit 4 is clear then the ship should not be shown
     4C8C 1000     
16722 4C8E 13F9  14        jeq  SC5                        ; BEQ SC5           ; on the scanner, so return from the subroutine (as SC5
16723                                                                          ; contains an RTS)
16724               
16725 4C90 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship's type from TYPE into A
     4C92 009B     
16726               
16727 4C94 11F6  14        jlt  SC5                        ; BMI SC5           ; If this is the planet or the sun, then the type will
16728                                                                          ; have bit 7 set and we don't want to display it on the
16729                                                                          ; scanner, so return from the subroutine (as SC5
16730                                                                          ; contains an RTS)
16731               
16732 4C96 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to the default scanner colour of green/cyan
     4C98 FF00     
16733                                                                          ; (a 4-pixel mode 5 byte in colour 3)
16734               
16735               * CMP #TGL               \ These instructions are commented out in the original
16736               * BEQ SC49               \ source. Along with the block just below, they would
16737                                                                          ; set X to colour 1 (red) for asteroids, cargo canisters
16738                                                                          ; and escape pods, rather than green/cyan. Presumably
16739                                                                          ; they decided it didn't work that well against the red
16740                                                                          ; ellipse and took this code out for release
16741               
16742 4C9A 028D  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If this is not a missile, skip the following
     4C9C 0900     
16743 4C9E 1602  14        jne  B47                        ; BNE B47           ; instruction
16744               
16745 4CA0 020E  20        li   rx,>f0*256                 ; LDX #&F0          ; This is a missile, so set X to colour 2 (yellow/white)
     4CA2 F000     
16746               
16747               B47:
16748               * CMP #AST               \ These instructions are commented out in the original
16749               * BCC P%+4               \ source. See above for an explanation of what they do
16750               * LDX #&0F
16751               * .SC49
16752 4CA4 D80E  30        movb rx,@COL                    ; STX COL           ; Store X, the colour of this ship on the scanner, in
     4CA6 00A2     
16753                                                                          ; COL
16754               
16755 4CA8 D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; If any of x_hi, y_hi and z_hi have a 1 in bit 6 or 7,
     4CAA 0054     
16756 4CAC F360  30        socb @INWK+4,ra                 ; ORA INWK+4        ; then the ship is too far away to be shown on the
     4CAE 0057     
16757 4CB0 F360  30        socb @INWK+7,ra                 ; ORA INWK+7        ; scanner, so return from the subroutine (as SC5
     4CB2 005A     
16758 4CB4 024D  22        andi ra,>c0*256                 ; AND #%11000000    ; contains an RTS)
     4CB6 C000     
16759 4CB8 16E4  14        jne  SC5                        ; BNE SC5
16760               
16761                                                                          ; If we get here, we know x_hi, y_hi and z_hi are all
16762                                                                          ; 63 (%00111111) or less
16763               
16764                                                                          ; Now, we convert the x_hi coordinate of the ship into
16765                                                                          ; the screen x-coordinate of the dot on the scanner,
16766                                                                          ; using the following (see the deep dive on "The 3D
16767                                                                          ; scanner" for an explanation):
16768                                                                          ;
16769                                                                          ; X1 = 123 + (x_sign x_hi)
16770               
16771 4CBA D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     4CBC 0054     
16772               
16773                      .clc                            ; CLC               ; Clear the C flag so we can do addition below
     **** ****     > CLC
0001 4CBE 0A16  18        sla  rzero,1
                   < elite.a99
16774               
16775 4CC0 D3A0  30        movb @INWK+2,rx                 ; LDX INWK+2        ; Set X = x_sign
     4CC2 0055     
16776               
16777 4CC4 1507  14        jgt  SC2                        ; BPL SC2           ; If x_sign is positive, skip the following
16778               
16779                      .eoi (>ff*256)                  ; EOR #%11111111    ; x_sign is negative, so flip the bits in A and add 1
     **** ****     > EOI
0001 4CC6 0200  20        li   rtmp,(>FF*256)
     4CC8 FF00     
0002 4CCA 2B40  18        xor  rtmp,ra
                   < elite.a99
16780                      .adi (>01*256)                  ; ADC #1            ; to make it a negative number (bit 7 will now be set
     **** ****     > ADI
0001 4CCC 1701  14        jnc  !
0002 4CCE B347  18        ab   rone,ra
0003               !:
0004 4CD0 022D  22        ai   ra,(>01*256)
     4CD2 0100     
                   < elite.a99
16781                                                                          ; as we confirmed above that bits 6 and 7 are clear). So
16782                                                                          ; this gives A the sign of x_sign and gives it a value
16783                                                                          ; range of -63 (%11000001) to 0
16784               
16785               SC2:
16786                      .adi (>7b*256)                  ; ADC #123          ; Set X1 = 123 + (x_sign x_hi)
     **** ****     > ADI
0001 4CD4 1701  14        jnc  !
0002 4CD6 B347  18        ab   rone,ra
0003               !:
0004 4CD8 022D  22        ai   ra,(>7B*256)
     4CDA 7B00     
                   < elite.a99
16787 4CDC D80D  30        movb ra,@X1                     ; STA X1
     4CDE 0031     
16788               
16789                                                                          ; Next, we convert the z_hi coordinate of the ship into
16790                                                                          ; the y-coordinate of the base of the ship's stick,
16791                                                                          ; like this (see the deep dive on "The 3D scanner" for
16792                                                                          ; an explanation):
16793                                                                          ;
16794                                                                          ; SC = 220 - (z_sign z_hi) / 4
16795                                                                          ;
16796                                                                          ; though the following code actually does it like this:
16797                                                                          ;
16798                                                                          ; SC = 255 - (35 + z_hi / 4)
16799               
16800 4CE0 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi / 4
     4CE2 005A     
16801 4CE4 091D  18        srl  ra,1                       ; LSR A             ;
16802 4CE6 091D  18        srl  ra,1                       ; LSR A             ; So A is in the range 0-15
16803               
16804                      .clc                            ; CLC               ; Clear the C flag for the addition below
     **** ****     > CLC
0001 4CE8 0A16  18        sla  rzero,1
                   < elite.a99
16805               
16806 4CEA D3A0  30        movb @INWK+8,rx                 ; LDX INWK+8        ; Set X = z_sign
     4CEC 005B     
16807               
16808 4CEE 1504  14        jgt  SC3                        ; BPL SC3           ; If z_sign is positive, skip the following
16809               
16810                      .eoi (>ff*256)                  ; EOR #%11111111    ; z_sign is negative, so flip the bits in A and set the
     **** ****     > EOI
0001 4CF0 0200  20        li   rtmp,(>FF*256)
     4CF2 FF00     
0002 4CF4 2B40  18        xor  rtmp,ra
                   < elite.a99
16811                      .sec                            ; SEC               ; C flag. As above, this makes A negative, this time
     **** ****     > SEC
0001 4CF6 0A18  18        sla  rmone,1
                   < elite.a99
16812                                                                          ; with a range of -16 (%11110000) to -1 (%11111111). And
16813                                                                          ; as we are about to do an ADC, the SEC effectively adds
16814                                                                          ; another 1 to that value, giving a range of -15 to 0
16815               
16816               SC3:
16817                      .adi (>23*256)                  ; ADC #35           ; Set A = 35 + A to give a number in the range 20 to 50
     **** ****     > ADI
0001 4CF8 1701  14        jnc  !
0002 4CFA B347  18        ab   rone,ra
0003               !:
0004 4CFC 022D  22        ai   ra,(>23*256)
     4CFE 2300     
                   < elite.a99
16818               
16819                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip all the bits and store in SC, so SC is in the
     **** ****     > EOI
0001 4D00 0200  20        li   rtmp,(>FF*256)
     4D02 FF00     
0002 4D04 2B40  18        xor  rtmp,ra
                   < elite.a99
16820 4D06 D80D  30        movb ra,@SC                     ; STA SC            ; range 205 to 235, with a higher z_hi giving a lower SC
     4D08 0007     
16821               
16822                                                                          ; Now for the stick height, which we calculate using the
16823                                                                          ; following (see the deep dive on "The 3D scanner" for
16824                                                                          ; an explanation):
16825                                                                          ;
16826                                                                          ; A = - (y_sign y_hi) / 2
16827               
16828 4D0A D360  30        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi / 2
     4D0C 0057     
16829 4D0E 091D  18        srl  ra,1                       ; LSR A
16830               
16831                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 4D10 0A16  18        sla  rzero,1
                   < elite.a99
16832               
16833 4D12 D3A0  30        movb @INWK+5,rx                 ; LDX INWK+5        ; Set X = y_sign
     4D14 0058     
16834               
16835 4D16 1104  14        jlt  SCD6                       ; BMI SCD6          ; If y_sign is negative, skip the following, as we
16836                                                                          ; already have a positive value in A
16837               
16838                      .eoi (>ff*256)                  ; EOR #%11111111    ; y_sign is positive, so flip the bits in A and set the
     **** ****     > EOI
0001 4D18 0200  20        li   rtmp,(>FF*256)
     4D1A FF00     
0002 4D1C 2B40  18        xor  rtmp,ra
                   < elite.a99
16839                      .sec                            ; SEC               ; C flag. This makes A negative, and as we are about to
     **** ****     > SEC
0001 4D1E 0A18  18        sla  rmone,1
                   < elite.a99
16840                                                                          ; do an ADC below, the SEC effectively adds another 1 to
16841                                                                          ; that value to implement two's complement negation, so
16842                                                                          ; we don't need to add another 1 here
16843               
16844               SCD6:
16845                                                                          ; We now have all the information we need to draw this
16846                                                                          ; ship on the scanner, namely:
16847                                                                          ;
16848                                                                          ; X1 = the screen x-coordinate of the ship's dot
16849                                                                          ;
16850                                                                          ; SC = the screen y-coordinate of the base of the
16851                                                                          ; stick
16852                                                                          ;
16853                                                                          ; A = the screen height of the ship's stick, with the
16854                                                                          ; correct sign for adding to the base of the stick
16855                                                                          ; to get the dot's y-coordinate
16856                                                                          ;
16857                                                                          ; First, though, we have to make sure the dot is inside
16858                                                                          ; the dashboard, by moving it if necessary
16859                      .adc @SC,ra                     ; ADC SC            ; Set A = SC + A, so A now contains the y-coordinate of
     **** ****     > ADC
0001 4D20 1701  14        jnc  !
0002 4D22 B347  18        ab   rone,ra
0003               !:
0004 4D24 B360  30        ab   @SC,ra
     4D26 0007     
                   < elite.a99
16860                                                                          ; the end of the stick, plus the length of the stick, to
16861                                                                          ; give us the screen y-coordinate of the dot
16862               
16863 4D28 1508  14        jgt  ld246_                     ; BPL ld246         ; If the result has bit 0 clear, then the result has
16864                                                                          ; overflowed and is bigger than 256, so jump to ld246 to
16865                                                                          ; set A to the maximum allowed value of 246 (this
16866                                                                          ; instruction isn't required as we test both the maximum
16867                                                                          ; and minimum below, but it might save a few cycles)
16868               
16869 4D2A 028D  22        ci   ra,>c2*256                 ; CMP #194          ; If A >= 194, skip the following instruction, as 194 is
     4D2C C200     
16870 4D2E 1802  14        joc  B48                        ; BCS B48           ; the minimum allowed value of A
16871               
16872 4D30 020D  20        li   ra,>c2*256                 ; LDA #194          ; A < 194, so set A to 194, the minimum allowed value
     4D32 C200     
16873                                                                          ; for the y-coordinate of our ship's dot
16874               
16875               B48:
16876 4D34 028D  22        ci   ra,>f7*256                 ; CMP #247          ; If A < 247, skip the following instruction, as 246 is
     4D36 F700     
16877 4D38 1700  14        jnc  B49                        ; BCC B49           ; the maximum allowed value of A
16878               
16879               ld246_:
16880                      equ  $
16881               B49:
16882 4D3A 020D  20        li   ra,>f6*256                 ; LDA #246          ; A >= 247, so set A to 246, the maximum allowed value
     4D3C F600     
16883                                                                          ; for the y-coordinate of our ship's dot
16884               
16885 4D3E D80D  30        movb ra,@Y1                     ; STA Y1            ; Store A in Y1, as it now contains the screen
     4D40 0032     
16886                                                                          ; y-coordinate for the ship's dot, clipped so that it
16887                                                                          ; fits within the dashboard
16888               
16889                      .sec                            ; SEC               ; Set A = A - SC to get the stick length, by reversing
     **** ****     > SEC
0001 4D42 0A18  18        sla  rmone,1
                   < elite.a99
16890                      .sbc @SC,ra                     ; SBC SC            ; the ADC SC we did above. This clears the C flag if the
     **** ****     > SBC
0001 4D44 1801  14        joc  !
0002 4D46 7347  18        sb   rone,ra
0003               !:
0004 4D48 7360  30        sb   @SC,ra
     4D4A 0007     
                   < elite.a99
16891                                                                          ; result is negative (i.e. the stick length is negative)
16892                                                                          ; and sets it if the result is positive (i.e. the stick
16893                                                                          ; length is negative)
16894               
16895                                                                          ; So now we have the following:
16896                                                                          ;
16897                                                                          ; X1 = the screen x-coordinate of the ship's dot,
16898                                                                          ; clipped to fit into the dashboard
16899                                                                          ;
16900                                                                          ; Y1 = the screen y-coordinate of the ship's dot,
16901                                                                          ; clipped to fit into the dashboard
16902                                                                          ;
16903                                                                          ; SC = the screen y-coordinate of the base of the
16904                                                                          ; stick
16905                                                                          ;
16906                                                                          ; A = the screen height of the ship's stick, with the
16907                                                                          ; correct sign for adding to the base of the stick
16908                                                                          ; to get the dot's y-coordinate
16909                                                                          ;
16910                                                                          ; C = 0 if A is negative, 1 if A is positive
16911                                                                          ;
16912                                                                          ; and we can get on with drawing the dot and stick
16913               
16914                      .php                            ; PHP               ; Store the flags (specifically the C flag) from the
     **** ****     > PHP
0001 4D4C 02C0  12        stst rtmp
0002 4D4E D680  30        movb rtmp,*rsp
0003 4D50 060A  14        dec  rsp
                   < elite.a99
16915                                                                          ; above subtraction
16916               
16917               * BCS SC48               \ These instructions are commented out in the original
16918               * EOR #&FF               \ source. They would negate A if the C flag were set,
16919               * ADC #1                 \ which would reverse the direction of all the sticks,
16920                                                                          ; so you could turn your joystick around. Perhaps one of
16921                                                                          ; the authors' test sticks was easier to use upside
16922                                                                          ; down? Who knows...
16923               
16924               SC48:
16925                      .pha                            ; PHA               ; Store the stick height in A on the stack
     **** ****     > PHA
0001 4D52 D68D  30        movb ra,*rsp
0002 4D54 060A  14        dec  rsp
                   < elite.a99
16926               
16927 4D56 0200  20        li   rtmp,CPIX4                 ; JSR CPIX4         ; Draw a double-height dot at (X1, Y1). This also leaves
     4D58 ADDE     
16928 4D5A 06A0  32        bl   @jsr                       ;
     4D5C FE1E     
16929                                                                          ; the following variables set up for the dot's top-right
16930                                                                          ; pixel, the last pixel to be drawn (as the dot gets
16931                                                                          ; drawn from the bottom up):
16932                                                                          ;
16933                                                                          ; SC(1 0) = screen address of the pixel's character
16934                                                                          ; block
16935                                                                          ;
16936                                                                          ; Y = number of the character row containing the pixel
16937                                                                          ;
16938                                                                          ; X = the pixel's number (0-3) in that row
16939                                                                          ;
16940                                                                          ; We can use there as the starting point for drawing the
16941                                                                          ; stick, if there is one
16942               
16943 4D5E D36E  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Load the same mode 5 1-pixel byte that we just used
     4D60 224A     
16944                      .and @COL                       ; AND COL           ; for the top-right pixel, and mask it with the same
     **** ****     > AND
0001 4D62 D020  30        movb @COL,rtmp
     4D64 00A2     
0002 4D66 0540  14        inv  rtmp
0003 4D68 5340  18        szcb rtmp,ra
                   < elite.a99
16945 4D6A D80D  30        movb ra,@X1                     ; STA X1            ; colour, storing the result in X1, so we can use it as
     4D6C 0031     
16946                                                                          ; the character row byte for the stick
16947               
16948                      .pla                            ; PLA               ; Restore the stick height from the stack into A
     **** ****     > PLA
0001 4D6E 058A  14        inc  rsp
0002 4D70 D35A  26        movb *rsp,ra
                   < elite.a99
16949               
16950                      .plp                            ; PLP               ; Restore the flags from above, so the C flag once again
     **** ****     > PLP
0001 4D72 058A  14        INC  rsp
0002 4D74 D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
16951                                                                          ; reflects the sign of the stick height
16952               
16953 4D76 D38D  18        movb ra,rx                      ; TAX               ; Copy the stick height into X
16954               
16955 4D78 1314  14        jeq  RTS1                       ; BEQ RTS1          ; If the stick height is zero, then there is no stick to
16956                                                                          ; draw, so return from the subroutine (as RTS contains
16957                                                                          ; an RTS)
16958               
16959 4D7A 1715  14        jnc  RTS3                       ; BCC RTS3          ; If the C flag is clear then the stick height in A is
16960                                                                          ; negative, so jump down to RTS+1
16961               
16962               VLL1:
16963                                                                          ; If we get here then the stick length is positive (so
16964                                                                          ; the dot is below the ellipse and the stick is above
16965                                                                          ; the dot, and we need to draw the stick upwards from
16966                                                                          ; the dot)
16967 4D7C 73C7  18        sb   rone,ry                    ; DEY               ; We want to draw the stick upwards, so decrement the
16968                                                                          ; pixel row in Y
16969               
16970 4D7E 1503  14        jgt  VL1                        ; BPL VL1           ; If Y is still positive then it correctly points at the
16971                                                                          ; line above, so jump to VL1 to skip the following
16972               
16973 4D80 020F  20        li   ry,>07*256                 ; LDY #7            ; We just decremented Y up through the top of the
     4D82 0700     
16974                                                                          ; character block, so we need to move it to the last row
16975                                                                          ; in the character above, so set Y to 7, the number of
16976                                                                          ; the last row
16977               
16978 4D84 7347  18        sb   rone,ra                    ; DEC SC+1          ; Decrement the high byte of the screen address to move
16979                                                                          ; to the character block above
16980               
16981               VL1:
16982 4D86 D360  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     4D88 0031     
16983                                                                          ; we stored in X1 above, and which has the same pixel
16984                                                                          ; pattern as the bottom-right pixel of the dot (so the
16985                                                                          ; stick comes out of the right side of the dot)
16986               
16987                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 4D8A D020  30        movb @SC,rtmp
     4D8C 0007     
0002 4D8E 2B40  18        xor  rtmp,ra
                   < elite.a99
16988                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 4D90 D820  50        movb @SC,@rtmplb
     4D92 0007     
     4D94 206D     
0002 4D96 D020  30        movb @SC+1,rtmp
     4D98 0008     
0003 4D9A A00F  18        a    ry,rtmp
0004 4D9C D40D  30        movb RA,*rtmp
                   < elite.a99
16989               
16990 4D9E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the (positive) stick height in X
16991               
16992 4DA0 16ED  14        jne  VLL1                       ; BNE VLL1          ; If we still have more stick to draw, jump up to VLL1
16993                                                                          ; to draw the next pixel
16994               
16995               RTS1:
16996 4DA2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4DA4 FE2A     
16997               
16998                                                                          ; If we get here then the stick length is negative (so
16999                                                                          ; the dot is above the ellipse and the stick is below
17000                                                                          ; the dot, and we need to draw the stick downwards from
17001                                                                          ; the dot)
17002               
17003               RTS3:
17004 4DA6 B3C7  18        ab   rone,ry                    ; INY               ; We want to draw the stick downwards, so we first
17005                                                                          ; increment the row counter so that it's pointing to the
17006                                                                          ; bottom-right pixel in the dot (as opposed to the top-
17007                                                                          ; right pixel that the call to CPIX4 finished on)
17008               
17009 4DA8 028F  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     4DAA 0800     
17010 4DAC 1603  14        jne  VLL2                       ; BNE VLL2          ; correctly points at the next line down, so jump to
17011                                                                          ; VLL2 to skip the following
17012               
17013 4DAE 020F  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     4DB0 0000     
17014                                                                          ; character block, so we need to move it to the first
17015                                                                          ; row in the character below, so set Y to 0, the number
17016                                                                          ; of the first row
17017               
17018 4DB2 B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17019                                                                          ; to the character block above
17020               
17021               VLL2:
17022 4DB4 B3C7  18        ab   rone,ry                    ; INY               ; We want to draw the stick itself, heading downwards,
17023                                                                          ; so increment the pixel row in Y
17024               
17025 4DB6 028F  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     4DB8 0800     
17026 4DBA 1603  14        jne  VL2                        ; BNE VL2           ; correctly points at the next line down, so jump to
17027                                                                          ; VL2 to skip the following
17028               
17029 4DBC 020F  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     4DBE 0000     
17030                                                                          ; character block, so we need to move it to the first
17031                                                                          ; row in the character below, so set Y to 0, the number
17032                                                                          ; of the first row
17033               
17034 4DC0 B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17035                                                                          ; to the character block above
17036               
17037               VL2:
17038 4DC2 D360  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     4DC4 0031     
17039                                                                          ; we stored in X1 above, and which has the same pixel
17040                                                                          ; pattern as the bottom-right pixel of the dot (so the
17041                                                                          ; stick comes out of the right side of the dot)
17042               
17043                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 4DC6 D020  30        movb @SC,rtmp
     4DC8 0007     
0002 4DCA 2B40  18        xor  rtmp,ra
                   < elite.a99
17044                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 4DCC D820  50        movb @SC,@rtmplb
     4DCE 0007     
     4DD0 206D     
0002 4DD2 D020  30        movb @SC+1,rtmp
     4DD4 0008     
0003 4DD6 A00F  18        a    ry,rtmp
0004 4DD8 D40D  30        movb RA,*rtmp
                   < elite.a99
17045               
17046 4DDA B387  18        ab   rone,rx                    ; INX               ; Increment the (negative) stick height in X
17047               
17048 4DDC 16EB  14        jne  VLL2                       ; BNE VLL2          ; If we still have more stick to draw, jump up to VLL2
17049                                                                          ; to draw the next pixel
17050               
17051 4DDE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4DE0 FE2A     
17052               
17053               * ******************************************************************************
17054               *
17055               * Name: WSCAN
17056               * Type: Subroutine
17057               * Category: Drawing the screen
17058               * Summary: Wait for the vertical sync
17059               *
17060               * ------------------------------------------------------------------------------
17061               *
17062               * Wait for vertical sync to occur on the video system - in other words, wait
17063               * for the screen to start its refresh cycle, which it does 50 times a second
17064               * (50Hz).
17065               *
17066               * ******************************************************************************
17067               
17068               WSCAN:
17069 4DE2 020D  20        li   ra,>00*256                 ; LDA #0            ; Set DL to 0
     4DE4 0000     
17070 4DE6 D80D  30        movb ra,@DL                     ; STA DL
     4DE8 009A     
17071               
17072               B50:
17073 4DEA D360  30        movb @DL,ra                     ; LDA DL            ; Loop round these two instructions until DL is no
     4DEC 009A     
17074 4DEE 13FD  14        jeq  B50                        ; BEQ B50           ; longer 0 (DL gets set to 30 in the LINSCN routine,
17075                                                                          ; which is run when vertical sync has occurred on the
17076                                                                          ; video system, so DL will change to a non-zero value
17077                                                                          ; at the start of each screen refresh)
17078               
17079 4DF0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4DF2 FE2A     
17080               
17081               * ******************************************************************************
17082               *
17083               * Save ELTC.bin
17084               *
17085               * ******************************************************************************
17086               
17087                      ; PRINT "ELITE C"
17088                      ; PRINT "Assembled at ", ~CODE_C%
17089                      ; PRINT "Ends at ", ~P%
17090                      ; PRINT "Code size is ", ~(P% - CODE_C%)
17091                      ; PRINT "Execute at ", ~LOAD%
17092                      ; PRINT "Reload at ", ~LOAD_C%
17093               
17094                      ; PRINT "S.ELTC ", ~CODE_C%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_C%
17095                      ; SAVE "3-assembled-output/ELTC.bin", CODE_C%, P%, LOAD%
17096               
17097               * ******************************************************************************
17098               *
17099               * ELITE D FILE
17100               *
17101               * Produces the binary file ELTD.bin that gets loaded by elite-bcfs.asm.
17102               *
17103               * ******************************************************************************
17104               
17105               CODE_D.:
17106                      equ $
17107               
17108               LOAD_D.:
17109                      equ LOAD. + $ - CODE.
17110               
17111               * ******************************************************************************
17112               *
17113               * Name: tnpr
17114               * Type: Subroutine
17115               * Category: Market
17116               * Summary: Work out if we have space for a specific amount of cargo
17117               *
17118               * ------------------------------------------------------------------------------
17119               *
17120               * Given a market item and an amount, work out whether there is room in the
17121               * cargo hold for this item.
17122               *
17123               * For standard tonne canisters, the limit is given by the type of cargo hold we
17124               * have, with a standard cargo hold having a capacity of 20t and an extended
17125               * cargo bay being 35t.
17126               *
17127               * For items measured in kg (gold, platinum), g (gem-stones) and alien items,
17128               * the individual limit on each of these is 200 units.
17129               *
17130               * ------------------------------------------------------------------------------
17131               *
17132               * Arguments:
17133               *
17134               * A                   The number of units of this market item
17135               *
17136               * QQ29                The type of market item (see QQ23 for a list of market
17137               * item numbers)
17138               *
17139               * ------------------------------------------------------------------------------
17140               *
17141               * Returns:
17142               *
17143               * A                   A is preserved
17144               *
17145               * C flag              Returns the result:
17146               *
17147               * * Set if there is no room for this item
17148               *
17149               * * Clear if there is room for this item
17150               *
17151               * ******************************************************************************
17152               
17153               tnpr_:
17154                      .pha                            ; PHA               ; Store A on the stack
     **** ****     > PHA
0001 4DF4 D68D  30        movb ra,*rsp
0002 4DF6 060A  14        dec  rsp
                   < elite.a99
17155               
17156 4DF8 020E  20        li   rx,>0c*256                 ; LDX #12           ; If QQ29 > 12 then jump to kg below, as this cargo
     4DFA 0C00     
17157 4DFC 93A0  30        cb   @QQ29,rx                   ; CPX QQ29          ; type is gold, platinum, gem-stones or alien items,
     4DFE 0F1B     
17158 4E00 170C  14        jnc  kg_                        ; BCC kg            ; and they have different cargo limits to the standard
17159                                                                          ; tonne canisters
17160               
17161               Tml:
17162                                                                          ; Here we count the tonne canisters we have in the hold
17163                                                                          ; and add to A to see if we have enough room for A more
17164                                                                          ; tonnes of cargo, using X as the loop counter, starting
17165                                                                          ; with X = 12
17166                      .adc @QQ20(rx),ra               ; ADC QQ20,X        ; Set A = A + the number of tonnes we have in the hold
     **** ****     > ADC
0001 4E02 1701  14        jnc  !
0002 4E04 B347  18        ab   rone,ra
0003               !:
0004 4E06 B36E  34        ab   @QQ20(RX),ra
     4E08 0317     
                   < elite.a99
17167                                                                          ; of market item number X. Note that the first time we
17168                                                                          ; go round this loop, the C flag is set (as we didn't
17169                                                                          ; branch with the BCC above, so the effect of this loop
17170                                                                          ; is to count the number of tonne canisters in the hold,
17171                                                                          ; and add 1
17172               
17173 4E0A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
17174               
17175 4E0C 15FA  14        jgt  Tml                        ; BPL Tml           ; Loop back to add in the next market item in the hold,
17176                                                                          ; until we have added up all market items from 12
17177                                                                          ; (minerals) down to 0 (food)
17178               
17179 4E0E 9360  30        cb   @CRGO,ra                   ; CMP CRGO          ; If A < CRGO then the C flag will be clear (we have
     4E10 0316     
17180                                                                          ; room in the hold)
17181                                                                          ;
17182                                                                          ; If A >= CRGO then the C flag will be set (we do not
17183                                                                          ; have room in the hold)
17184                                                                          ;
17185                                                                          ; This works because A contains the number of canisters
17186                                                                          ; plus 1, while CRGO contains our cargo capacity plus 2,
17187                                                                          ; so if we actually have "a" canisters and a capacity
17188                                                                          ; of "c", then:
17189                                                                          ;
17190                                                                          ; A < CRGO means: a+1 <  c+2
17191                                                                          ; a   <  c+1
17192                                                                          ; a   <= c
17193                                                                          ;
17194                                                                          ; So this is why the value in CRGO is 2 higher than the
17195                                                                          ; actual cargo bay size, i.e. it's 22 for the standard
17196                                                                          ; 20-tonne bay, and 37 for the large 35-tonne bay
17197               
17198                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 4E12 058A  14        inc  rsp
0002 4E14 D35A  26        movb *rsp,ra
                   < elite.a99
17199               
17200 4E16 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4E18 FE2A     
17201               
17202               kg_:
17203                                                                          ; Here we count the number of items of this type that
17204                                                                          ; we already have in the hold, and add to A to see if
17205                                                                          ; we have enough room for A more units
17206 4E1A D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set Y to the item number we want to add
     4E1C 0F1B     
17207               
17208                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Set A = A + the number of units of this item that we
     **** ****     > ADC
0001 4E1E 1701  14        jnc  !
0002 4E20 B347  18        ab   rone,ra
0003               !:
0004 4E22 B36F  34        ab   @QQ20(RY),ra
     4E24 0317     
                   < elite.a99
17209                                                                          ; already have in the hold
17210               
17211 4E26 028D  22        ci   ra,>c8*256                 ; CMP #200          ; Is the result greater than 200 (the limit on
     4E28 C800     
17212                                                                          ; individual stocks of gold, platinum, gem-stones and
17213                                                                          ; alien items)?
17214                                                                          ;
17215                                                                          ; If so, this sets the C flag (no room)
17216                                                                          ;
17217                                                                          ; Otherwise it is clear (we have room)
17218               
17219                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 4E2A 058A  14        inc  rsp
0002 4E2C D35A  26        movb *rsp,ra
                   < elite.a99
17220               
17221 4E2E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4E30 FE2A     
17222               
17223               * ******************************************************************************
17224               *
17225               * Name: TT20
17226               * Type: Subroutine
17227               * Category: Universe
17228               * Summary: Twist the selected system's seeds four times
17229               * Deep dive: Twisting the system seeds
17230               * Galaxy and system seeds
17231               *
17232               * ------------------------------------------------------------------------------
17233               *
17234               * Twist the three 16-bit seeds in QQ15 (selected system) four times, to
17235               * generate the next system.
17236               *
17237               * ******************************************************************************
17238               
17239               TT20:
17240 4E32 0200  20        li   rtmp,B51                   ; JSR B51           ; This line calls the line below as a subroutine, which
     4E34 4E3A     
17241 4E36 06A0  32        bl   @jsr                       ;
     4E38 FE1E     
17242                                                                          ; does two twists before returning here, and then we
17243                                                                          ; fall through to the line below for another two
17244                                                                          ; twists, so the net effect of these two consecutive
17245                                                                          ; JSR calls is four twists, not counting the ones
17246                                                                          ; inside your head as you try to follow this process
17247               
17248               B51:
17249 4E3A 0200  20        li   rtmp,TT54                  ; JSR TT54          ; This line calls TT54 as a subroutine to do a twist,
     4E3C 4E42     
17250 4E3E 06A0  32        bl   @jsr                       ;
     4E40 FE1E     
17251                                                                          ; and then falls through into TT54 to do another twist
17252                                                                          ; before returning from the subroutine
17253               
17254               * ******************************************************************************
17255               *
17256               * Name: TT54
17257               * Type: Subroutine
17258               * Category: Universe
17259               * Summary: Twist the selected system's seeds
17260               * Deep dive: Twisting the system seeds
17261               * Galaxy and system seeds
17262               *
17263               * ------------------------------------------------------------------------------
17264               *
17265               * This routine twists the three 16-bit seeds in QQ15 once.
17266               *
17267               * If we start with seeds s0, s1 and s2 and we want to work out their new values
17268               * after we perform a twist (let's call the new values s0, s1 and s2), then:
17269               *
17270               * s0 = s1
17271               * s1 = s2
17272               * s2 = s0 + s1 + s2
17273               *
17274               * So given an existing set of seeds in s0, s1 and s2, we can get the new values
17275               * s0, s1 and s2 simply by doing the above sums. And if we want to do the
17276               * above in-place without creating three new s variables, then we can do the
17277               * following:
17278               *
17279               * tmp = s0 + s1
17280               * s0 = s1
17281               * s1 = s2
17282               * s2 = tmp + s1
17283               *
17284               * So this is what we do in this routine, where each seed is a 16-bit number.
17285               *
17286               * ******************************************************************************
17287               
17288               TT54:
17289 4E42 D360  30        movb @QQ15,ra                   ; LDA QQ15          ; X = tmp_lo = s0_lo + s1_lo
     4E44 0078     
17290                      .clc                            ; CLC
     **** ****     > CLC
0001 4E46 0A16  18        sla  rzero,1
                   < elite.a99
17291                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 4E48 1701  14        jnc  !
0002 4E4A B347  18        ab   rone,ra
0003               !:
0004 4E4C B360  30        ab   @QQ15+2,ra
     4E4E 007A     
                   < elite.a99
17292 4E50 D38D  18        movb ra,rx                      ; TAX
17293               
17294 4E52 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Y = tmp_hi = s1_hi + s1_hi + C
     4E54 0079     
17295                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 4E56 1701  14        jnc  !
0002 4E58 B347  18        ab   rone,ra
0003               !:
0004 4E5A B360  30        ab   @QQ15+3,ra
     4E5C 007B     
                   < elite.a99
17296 4E5E D3CD  18        movb ra,ry                      ; TAY
17297               
17298 4E60 D360  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; s0_lo = s1_lo
     4E62 007A     
17299 4E64 D80D  30        movb ra,@QQ15                   ; STA QQ15
     4E66 0078     
17300               
17301 4E68 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; s0_hi = s1_hi
     4E6A 007B     
17302 4E6C D80D  30        movb ra,@QQ15+1                 ; STA QQ15+1
     4E6E 0079     
17303               
17304 4E70 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; s1_hi = s2_hi
     4E72 007D     
17305 4E74 D80D  30        movb ra,@QQ15+3                 ; STA QQ15+3
     4E76 007B     
17306               
17307 4E78 D360  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; s1_lo = s2_lo
     4E7A 007C     
17308 4E7C D80D  30        movb ra,@QQ15+2                 ; STA QQ15+2
     4E7E 007A     
17309               
17310                      .clc                            ; CLC               ; s2_lo = X + s1_lo
     **** ****     > CLC
0001 4E80 0A16  18        sla  rzero,1
                   < elite.a99
17311 4E82 D34E  18        movb rx,ra                      ; TXA
17312                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 4E84 1701  14        jnc  !
0002 4E86 B347  18        ab   rone,ra
0003               !:
0004 4E88 B360  30        ab   @QQ15+2,ra
     4E8A 007A     
                   < elite.a99
17313 4E8C D80D  30        movb ra,@QQ15+4                 ; STA QQ15+4
     4E8E 007C     
17314               
17315 4E90 D34F  18        movb ry,ra                      ; TYA               ; s2_hi = Y + s1_hi + C
17316                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 4E92 1701  14        jnc  !
0002 4E94 B347  18        ab   rone,ra
0003               !:
0004 4E96 B360  30        ab   @QQ15+3,ra
     4E98 007B     
                   < elite.a99
17317 4E9A D80D  30        movb ra,@QQ15+5                 ; STA QQ15+5
     4E9C 007D     
17318               
17319 4E9E 0460  28        b    @rts                       ; RTS               ; The twist is complete so return from the subroutine
     4EA0 FE2A     
17320               
17321               * ******************************************************************************
17322               *
17323               * Name: TT146
17324               * Type: Subroutine
17325               * Category: Universe
17326               * Summary: Print the distance to the selected system in light years
17327               *
17328               * ------------------------------------------------------------------------------
17329               *
17330               * If it is non-zero, print the distance to the selected system in light years.
17331               * If it is zero, just move the text cursor down a line.
17332               *
17333               * Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
17334               * then a colon, then the distance to one decimal place, then token 35 ("LIGHT
17335               * YEARS"). If the distance is zero, move the cursor down one line.
17336               *
17337               * ******************************************************************************
17338               
17339               TT146:
17340 4EA2 D360  30        movb @QQ8,ra                    ; LDA QQ8           ; Take the two bytes of the 16-bit value in QQ8 and
     4EA4 0F2F     
17341 4EA6 F360  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; OR them together to check whether there are any
     4EA8 0F30     
17342 4EAA 1603  14        jne  TT63                       ; BNE TT63          ; non-zero bits, and if so, jump to TT63 to print the
17343                                                                          ; distance
17344               
17345 4EAC B347  18        ab   rone,ra                    ; INC YC            ; The distance is zero, so we just move the text cursor
17346 4EAE 0460  28        b    @rts                       ; RTS               ; in YC down by one line and return from the subroutine
     4EB0 FE2A     
17347               
17348               TT63:
17349 4EB2 020D  20        li   ra,>bf*256                 ; LDA #191          ; Print recursive token 31 ("DISTANCE") followed by
     4EB4 BF00     
17350 4EB6 0200  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4EB8 A6DC     
17351 4EBA 06A0  32        bl   @jsr                       ;
     4EBC FE1E     
17352               
17353 4EBE D3A0  30        movb @QQ8,rx                    ; LDX QQ8           ; Load (Y X) from QQ8, which contains the 16-bit
     4EC0 0F2F     
17354 4EC2 D3E0  30        movb @QQ8+1,ry                  ; LDY QQ8+1         ; distance we want to show
     4EC4 0F30     
17355               
17356                      .sec                            ; SEC               ; Set the C flag so that the call to pr5 will include a
     **** ****     > SEC
0001 4EC6 0A18  18        sla  rmone,1
                   < elite.a99
17357                                                                          ; decimal point, and display the value as (Y X) / 10
17358               
17359 4EC8 0200  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, including a decimal point
     4ECA 5D46     
17360 4ECC 06A0  32        bl   @jsr                       ;
     4ECE FE1E     
17361               
17362 4ED0 020D  20        li   ra,>c3*256                 ; LDA #195          ; Set A to the recursive token 35 (" LIGHT YEARS") and
     4ED2 C300     
17363                                                                          ; fall through into TT60 to print the token followed
17364                                                                          ; by a paragraph break
17365               
17366               * ******************************************************************************
17367               *
17368               * Name: TT60
17369               * Type: Subroutine
17370               * Category: Text
17371               * Summary: Print a text token and a paragraph break
17372               *
17373               * ------------------------------------------------------------------------------
17374               *
17375               * Print a text token (i.e. a character, control code, two-letter token or
17376               * recursive token). Then print a paragraph break (a blank line between
17377               * paragraphs) by moving the cursor down a line, setting Sentence Case, and then
17378               * printing a newline.
17379               *
17380               * ------------------------------------------------------------------------------
17381               *
17382               * Arguments:
17383               *
17384               * A                   The text token to be printed
17385               *
17386               * ******************************************************************************
17387               
17388               TT60:
17389 4ED4 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TTX69
     4ED6 A6E8     
17390 4ED8 06A0  32        bl   @jsr                       ;
     4EDA FE1E     
17391                                                                          ; to print the paragraph break
17392               
17393               * ******************************************************************************
17394               *
17395               * Name: TTX69
17396               * Type: Subroutine
17397               * Category: Text
17398               * Summary: Print a paragraph break
17399               *
17400               * ------------------------------------------------------------------------------
17401               *
17402               * Print a paragraph break (a blank line between paragraphs) by moving the cursor
17403               * down a line, setting Sentence Case, and then printing a newline.
17404               *
17405               * ******************************************************************************
17406               
17407               TTX69:
17408 4EDC B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a line
17409               
17410                                                                          ; Fall through into TT69 to set Sentence Case and print
17411                                                                          ; a newline
17412               
17413               * ******************************************************************************
17414               *
17415               * Name: TT69
17416               * Type: Subroutine
17417               * Category: Text
17418               * Summary: Set Sentence Case and print a newline
17419               *
17420               * ******************************************************************************
17421               
17422               TT69:
17423 4EDE 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     4EE0 8000     
17424 4EE2 D80D  30        movb ra,@QQ17                   ; STA QQ17
     4EE4 007E     
17425               
17426                                                                          ; Fall through into TT67 to print a newline
17427               
17428               * ******************************************************************************
17429               *
17430               * Name: TT67
17431               * Type: Subroutine
17432               * Category: Text
17433               * Summary: Print a newline
17434               *
17435               * ******************************************************************************
17436               
17437               TT67:
17438 4EE6 020D  20        li   ra,>0d*256                 ; LDA #13           ; Load a newline character into A
     4EE8 0D00     
17439               
17440 4EEA 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     4EEC A6E8     
17441                                                                          ; subroutine using a tail call
17442               
17443               * ******************************************************************************
17444               *
17445               * Name: TT70
17446               * Type: Subroutine
17447               * Category: Universe
17448               * Summary: Display "MAINLY " and jump to TT72
17449               *
17450               * ------------------------------------------------------------------------------
17451               *
17452               * This subroutine is called by TT25 when displaying a system's economy.
17453               *
17454               * ******************************************************************************
17455               
17456               TT70:
17457 4EEE 020D  20        li   ra,>ad*256                 ; LDA #173          ; Print recursive token 13 ("MAINLY ")
     4EF0 AD00     
17458 4EF2 0200  20        li   rtmp,TT27                  ; JSR TT27
     4EF4 A6E8     
17459 4EF6 06A0  32        bl   @jsr                       ;
     4EF8 FE1E     
17460               
17461 4EFA 0460  28        b    @TT72                      ; JMP TT72          ; Jump to TT72 to continue printing system data as part
     4EFC 4F82     
17462                                                                          ; of routine TT25
17463               
17464               * ******************************************************************************
17465               *
17466               * Name: spc
17467               * Type: Subroutine
17468               * Category: Text
17469               * Summary: Print a text token followed by a space
17470               *
17471               * ------------------------------------------------------------------------------
17472               *
17473               * Print a text token (i.e. a character, control code, two-letter token or
17474               * recursive token) followed by a space.
17475               *
17476               * ------------------------------------------------------------------------------
17477               *
17478               * Arguments:
17479               *
17480               * A                   The text token to be printed
17481               *
17482               * ******************************************************************************
17483               
17484               spc_:
17485 4EFE 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     4F00 A6E8     
17486 4F02 06A0  32        bl   @jsr                       ;
     4F04 FE1E     
17487               
17488 4F06 0460  28        b    @TT162                     ; JMP TT162         ; Print a space and return from the subroutine using a
     4F08 5E64     
17489                                                                          ; tail call
17490               
17491               * ******************************************************************************
17492               *
17493               * Name: TT25
17494               * Type: Subroutine
17495               * Category: Universe
17496               * Summary: Show the Data on System screen (red key f6)
17497               * Deep dive: Generating system data
17498               * Galaxy and system seeds
17499               *
17500               * ------------------------------------------------------------------------------
17501               *
17502               * Other entry points:
17503               *
17504               * TT72                Used by TT70 to re-enter the routine after displaying
17505               * "MAINLY" for the economy type
17506               *
17507               * ******************************************************************************
17508               
17509               TT25:
17510 4F0A 0200  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     4F0C 4B28     
17511 4F0E 06A0  32        bl   @jsr                       ;
     4F10 FE1E     
17512                                                                          ; and set the current view type in QQ11 to 1
17513               
17514 4F12 020D  20        li   ra,>09*256                 ; LDA #9            ; Move the text cursor to column 9
     4F14 0900     
17515 4F16 D80D  30        movb ra,@XC                     ; STA XC
     4F18 002C     
17516               
17517 4F1A 020D  20        li   ra,>a3*256                 ; LDA #163          ; Print recursive token 3 as a title in capitals at
     4F1C A300     
17518 4F1E 0200  20        li   rtmp,TT27                  ; JSR TT27          ; the top ("DATA ON {selected system name}")
     4F20 A6E8     
17519 4F22 06A0  32        bl   @jsr                       ;
     4F24 FE1E     
17520               
17521 4F26 0200  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line underneath the title
     4F28 25BE     
17522 4F2A 06A0  32        bl   @jsr                       ;
     4F2C FE1E     
17523               
17524 4F2E 0200  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     4F30 4EDC     
17525 4F32 06A0  32        bl   @jsr                       ;
     4F34 FE1E     
17526               
17527 4F36 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one more line
17528               
17529 4F38 0200  20        li   rtmp,TT146                 ; JSR TT146         ; If the distance to this system is non-zero, print
     4F3A 4EA2     
17530 4F3C 06A0  32        bl   @jsr                       ;
     4F3E FE1E     
17531                                                                          ; "DISTANCE", then the distance, "LIGHT YEARS" and a
17532                                                                          ; paragraph break, otherwise just move the cursor down
17533                                                                          ; a line
17534               
17535 4F40 020D  20        li   ra,>c2*256                 ; LDA #194          ; Print recursive token 34 ("ECONOMY") followed by
     4F42 C200     
17536 4F44 0200  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4F46 A6DC     
17537 4F48 06A0  32        bl   @jsr                       ;
     4F4A FE1E     
17538               
17539 4F4C D360  30        movb @QQ3,ra                    ; LDA QQ3           ; The system economy is determined by the value in QQ3,
     4F4E 0F28     
17540                                                                          ; so fetch it into A. First we work out the system's
17541                                                                          ; prosperity as follows:
17542                                                                          ;
17543                                                                          ; QQ3 = 0 or 5 = %000 or %101 = Rich
17544                                                                          ; QQ3 = 1 or 6 = %001 or %110 = Average
17545                                                                          ; QQ3 = 2 or 7 = %010 or %111 = Poor
17546                                                                          ; QQ3 = 3 or 4 = %011 or %100 = Mainly
17547               
17548                      .clc                            ; CLC               ; If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
     **** ****     > CLC
0001 4F50 0A16  18        sla  rzero,1
                   < elite.a99
17549                      .adi (>01*256)                  ; ADC #1            ; (3 or 4), then call TT70, which prints "MAINLY " and
     **** ****     > ADI
0001 4F52 1701  14        jnc  !
0002 4F54 B347  18        ab   rone,ra
0003               !:
0004 4F56 022D  22        ai   ra,(>01*256)
     4F58 0100     
                   < elite.a99
17550 4F5A 091D  18        srl  ra,1                       ; LSR A             ; jumps down to TT72 to print the type of economy
17551 4F5C 028D  22        ci   ra,>02*256                 ; CMP #%00000010
     4F5E 0200     
17552 4F60 13C6  14        jeq  TT70                       ; BEQ TT70
17553               
17554 4F62 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; If (QQ3 + 1) >> 1 < %10, i.e. if QQ3 = %000, %001 or
     4F64 0F28     
17555 4F66 1705  14        jnc  TT71                       ; BCC TT71          ; %010 (0, 1 or 2), then jump to TT71 with A set to the
17556                                                                          ; original value of QQ3
17557               
17558                      .sbi (>05*256)                  ; SBC #5            ; Here QQ3 = %101, %110 or %111 (5, 6 or 7), so subtract
     **** ****     > SBI
0001 4F68 1801  14        joc  !
0002 4F6A 7347  18        sb   rone,ra
0003               !:
0004 4F6C 022D  22        ai   ra,-(>05*256)
     4F6E FB00     
                   < elite.a99
17559                      .clc                            ; CLC               ; 5 to bring it down to 0, 1 or 2 (the C flag is already
     **** ****     > CLC
0001 4F70 0A16  18        sla  rzero,1
                   < elite.a99
17560                                                                          ; set so the SBC will be correct)
17561               
17562               TT71:
17563                      .adi (>aa*256)                  ; ADC #170          ; A is now 0, 1 or 2, so print recursive token 10 + A.
     **** ****     > ADI
0001 4F72 1701  14        jnc  !
0002 4F74 B347  18        ab   rone,ra
0003               !:
0004 4F76 022D  22        ai   ra,(>AA*256)
     4F78 AA00     
                   < elite.a99
17564 4F7A 0200  20        li   rtmp,TT27                  ; JSR TT27          ; This means that:
     4F7C A6E8     
17565 4F7E 06A0  32        bl   @jsr                       ;
     4F80 FE1E     
17566                                                                          ;
17567                                                                          ; QQ3 = 0 or 5 prints token 10 ("RICH ")
17568                                                                          ; QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
17569                                                                          ; QQ3 = 2 or 7 prints token 12 ("POOR ")
17570               
17571               TT72:
17572 4F82 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the type of economy, which is
     4F84 0F28     
17573 4F86 091D  18        srl  ra,1                       ; LSR A             ; determined by bit 2 of QQ3, as follows:
17574 4F88 091D  18        srl  ra,1                       ; LSR A             ;
17575                                                                          ; QQ3 bit 2 = 0 = Industrial
17576                                                                          ; QQ3 bit 2 = 1 = Agricultural
17577                                                                          ;
17578                                                                          ; So we fetch QQ3 into A and set A = bit 2 of QQ3 using
17579                                                                          ; two right shifts (which will work as QQ3 is only a
17580                                                                          ; 3-bit number)
17581               
17582                      .clc                            ; CLC               ; Print recursive token 8 + A, followed by a paragraph
     **** ****     > CLC
0001 4F8A 0A16  18        sla  rzero,1
                   < elite.a99
17583                      .adi (>a8*256)                  ; ADC #168          ; break and Sentence Case, so:
     **** ****     > ADI
0001 4F8C 1701  14        jnc  !
0002 4F8E B347  18        ab   rone,ra
0003               !:
0004 4F90 022D  22        ai   ra,(>A8*256)
     4F92 A800     
                   < elite.a99
17584 4F94 0200  20        li   rtmp,TT60                  ; JSR TT60          ;
     4F96 4ED4     
17585 4F98 06A0  32        bl   @jsr                       ;
     4F9A FE1E     
17586                                                                          ; QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
17587                                                                          ; QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")
17588               
17589 4F9C 020D  20        li   ra,>a2*256                 ; LDA #162          ; Print recursive token 2 ("GOVERNMENT") followed by
     4F9E A200     
17590 4FA0 0200  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     4FA2 A6DC     
17591 4FA4 06A0  32        bl   @jsr                       ;
     4FA6 FE1E     
17592               
17593 4FA8 D360  30        movb @QQ4,ra                    ; LDA QQ4           ; The system's government is determined by the value in
     4FAA 0F29     
17594                                                                          ; QQ4, so fetch it into A
17595               
17596                      .clc                            ; CLC               ; Print recursive token 17 + A, followed by a paragraph
     **** ****     > CLC
0001 4FAC 0A16  18        sla  rzero,1
                   < elite.a99
17597                      .adi (>b1*256)                  ; ADC #177          ; break and Sentence Case, so:
     **** ****     > ADI
0001 4FAE 1701  14        jnc  !
0002 4FB0 B347  18        ab   rone,ra
0003               !:
0004 4FB2 022D  22        ai   ra,(>B1*256)
     4FB4 B100     
                   < elite.a99
17598 4FB6 0200  20        li   rtmp,TT60                  ; JSR TT60          ;
     4FB8 4ED4     
17599 4FBA 06A0  32        bl   @jsr                       ;
     4FBC FE1E     
17600                                                                          ; QQ4 = 0 prints token 17 ("ANARCHY")
17601                                                                          ; QQ4 = 1 prints token 18 ("FEUDAL")
17602                                                                          ; QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
17603                                                                          ; QQ4 = 3 prints token 20 ("DICTATORSHIP")
17604                                                                          ; QQ4 = 4 prints token 21 ("COMMUNIST")
17605                                                                          ; QQ4 = 5 prints token 22 ("CONFEDERACY")
17606                                                                          ; QQ4 = 6 prints token 23 ("DEMOCRACY")
17607                                                                          ; QQ4 = 7 prints token 24 ("CORPORATE STATE")
17608               
17609 4FBE 020D  20        li   ra,>c4*256                 ; LDA #196          ; Print recursive token 36 ("TECH.LEVEL") followed by a
     4FC0 C400     
17610 4FC2 0200  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     4FC4 A6DC     
17611 4FC6 06A0  32        bl   @jsr                       ;
     4FC8 FE1E     
17612               
17613 4FCA D3A0  30        movb @QQ5,rx                    ; LDX QQ5           ; Fetch the tech level from QQ5 and increment it, as it
     4FCC 0F2A     
17614 4FCE B387  18        ab   rone,rx                    ; INX               ; is stored in the range 0-14 but the displayed range
17615                                                                          ; should be 1-15
17616               
17617                      .clc                            ; CLC               ; Call pr2 to print the technology level as a 3-digit
     **** ****     > CLC
0001 4FD0 0A16  18        sla  rzero,1
                   < elite.a99
17618 4FD2 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; number without a decimal point (by clearing the C
     4FD4 2FAC     
17619 4FD6 06A0  32        bl   @jsr                       ;
     4FD8 FE1E     
17620                                                                          ; flag)
17621               
17622 4FDA 0200  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     4FDC 4EDC     
17623 4FDE 06A0  32        bl   @jsr                       ;
     4FE0 FE1E     
17624               
17625 4FE2 020D  20        li   ra,>c0*256                 ; LDA #192          ; Print recursive token 32 ("POPULATION") followed by a
     4FE4 C000     
17626 4FE6 0200  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     4FE8 A6DC     
17627 4FEA 06A0  32        bl   @jsr                       ;
     4FEC FE1E     
17628               
17629                      .sec                            ; SEC               ; Call pr2 to print the population as a 3-digit number
     **** ****     > SEC
0001 4FEE 0A18  18        sla  rmone,1
                   < elite.a99
17630 4FF0 D3A0  30        movb @QQ6,rx                    ; LDX QQ6           ; with a decimal point (by setting the C flag), so the
     4FF2 0F2B     
17631 4FF4 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; number printed will be population / 10
     4FF6 2FAC     
17632 4FF8 06A0  32        bl   @jsr                       ;
     4FFA FE1E     
17633               
17634 4FFC 020D  20        li   ra,>c6*256                 ; LDA #198          ; Print recursive token 38 (" BILLION"), followed by a
     4FFE C600     
17635 5000 0200  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     5002 4ED4     
17636 5004 06A0  32        bl   @jsr                       ;
     5006 FE1E     
17637               
17638 5008 020D  20        li   ra,('(')*256               ; LDA #'('          ; Print an opening bracket
     500A 2800     
17639 500C 0200  20        li   rtmp,TT27                  ; JSR TT27
     500E A6E8     
17640 5010 06A0  32        bl   @jsr                       ;
     5012 FE1E     
17641               
17642 5014 D360  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; Now to calculate the species, so first check bit 7 of
     5016 007C     
17643 5018 1108  14        jlt  TT75                       ; BMI TT75          ; s2_lo, and if it is set, jump to TT75 as this is an
17644                                                                          ; alien species
17645               
17646 501A 020D  20        li   ra,>bc*256                 ; LDA #188          ; Bit 7 of s2_lo is clear, so print recursive token 28
     501C BC00     
17647 501E 0200  20        li   rtmp,TT27                  ; JSR TT27          ; ("HUMAN COLONIAL")
     5020 A6E8     
17648 5022 06A0  32        bl   @jsr                       ;
     5024 FE1E     
17649               
17650 5026 0460  28        b    @TT76                      ; JMP TT76          ; Jump to TT76 to print "S)" and a paragraph break, so
     5028 50BE     
17651                                                                          ; the whole species string is "(HUMAN COLONIALS)"
17652               
17653               TT75:
17654 502A D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; This is an alien species, and we start with the first
     502C 007D     
17655 502E 091D  18        srl  ra,1                       ; LSR A             ; adjective, so fetch bits 2-7 of s2_hi into A and push
17656 5030 091D  18        srl  ra,1                       ; LSR A             ; onto the stack so we can use this later
17657                      .pha                            ; PHA
     **** ****     > PHA
0001 5032 D68D  30        movb ra,*rsp
0002 5034 060A  14        dec  rsp
                   < elite.a99
17658               
17659 5036 024D  22        andi ra,>07*256                 ; AND #%00000111    ; Set A = bits 0-2 of A (so that's bits 2-4 of s2_hi)
     5038 0700     
17660               
17661 503A 028D  22        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, jump to TT205 to skip the first adjective,
     503C 0300     
17662 503E 1808  14        joc  TT205                      ; BCS TT205
17663               
17664                      .adi (>e3*256)                  ; ADC #227          ; Otherwise A = 0, 1 or 2, so print recursive token
     **** ****     > ADI
0001 5040 1701  14        jnc  !
0002 5042 B347  18        ab   rone,ra
0003               !:
0004 5044 022D  22        ai   ra,(>E3*256)
     5046 E300     
                   < elite.a99
17665 5048 0200  20        li   rtmp,spc_                  ; JSR spc           ; 67 + A, followed by a space, so:
     504A 4EFE     
17666 504C 06A0  32        bl   @jsr                       ;
     504E FE1E     
17667                                                                          ;
17668                                                                          ; A = 0 prints token 67 ("LARGE") and a space
17669                                                                          ; A = 1 prints token 68 ("FIERCE") and a space
17670                                                                          ; A = 2 prints token 69 ("SMALL") and a space
17671               
17672               TT205:
17673                      .pla                            ; PLA               ; Now for the second adjective, so restore A to bits
     **** ****     > PLA
0001 5050 058A  14        inc  rsp
0002 5052 D35A  26        movb *rsp,ra
                   < elite.a99
17674 5054 091D  18        srl  ra,1                       ; LSR A             ; 2-7 of s2_hi, and throw away bits 2-4 to leave
17675 5056 091D  18        srl  ra,1                       ; LSR A             ; A = bits 5-7 of s2_hi
17676 5058 091D  18        srl  ra,1                       ; LSR A
17677               
17678 505A 028D  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT206 to skip the second adjective
     505C 0600     
17679 505E 1808  14        joc  TT206                      ; BCS TT206
17680               
17681                      .adi (>e6*256)                  ; ADC #230          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5060 1701  14        jnc  !
0002 5062 B347  18        ab   rone,ra
0003               !:
0004 5064 022D  22        ai   ra,(>E6*256)
     5066 E600     
                   < elite.a99
17682 5068 0200  20        li   rtmp,spc_                  ; JSR spc           ; 70 + A, followed by a space, so:
     506A 4EFE     
17683 506C 06A0  32        bl   @jsr                       ;
     506E FE1E     
17684                                                                          ;
17685                                                                          ; A = 0 prints token 70 ("GREEN") and a space
17686                                                                          ; A = 1 prints token 71 ("RED") and a space
17687                                                                          ; A = 2 prints token 72 ("YELLOW") and a space
17688                                                                          ; A = 3 prints token 73 ("BLUE") and a space
17689                                                                          ; A = 4 prints token 74 ("BLACK") and a space
17690                                                                          ; A = 5 prints token 75 ("HARMLESS") and a space
17691               
17692               TT206:
17693 5070 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Now for the third adjective, so EOR the high bytes of
     5072 007B     
17694                      .eor @QQ15+1                    ; EOR QQ15+1        ; s0 and s1 and extract bits 0-2 of the result:
     **** ****     > EOR
0001 5074 D020  30        movb @QQ15+1,rtmp
     5076 0079     
0002 5078 2B40  18        xor  rtmp,ra
                   < elite.a99
17695 507A 024D  22        andi ra,>07*256                 ; AND #%00000111    ;
     507C 0700     
17696 507E D80D  30        movb ra,@QQ19                   ; STA QQ19          ; A = (s0_hi EOR s1_hi) AND %111
     5080 007F     
17697                                                                          ;
17698                                                                          ; storing the result in QQ19 so we can use it later
17699               
17700 5082 028D  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT207 to skip the third adjective
     5084 0600     
17701 5086 1808  14        joc  TT207                      ; BCS TT207
17702               
17703                      .adi (>ec*256)                  ; ADC #236          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5088 1701  14        jnc  !
0002 508A B347  18        ab   rone,ra
0003               !:
0004 508C 022D  22        ai   ra,(>EC*256)
     508E EC00     
                   < elite.a99
17704 5090 0200  20        li   rtmp,spc_                  ; JSR spc           ; 76 + A, followed by a space, so:
     5092 4EFE     
17705 5094 06A0  32        bl   @jsr                       ;
     5096 FE1E     
17706                                                                          ;
17707                                                                          ; A = 0 prints token 76 ("SLIMY") and a space
17708                                                                          ; A = 1 prints token 77 ("BUG-EYED") and a space
17709                                                                          ; A = 2 prints token 78 ("HORNED") and a space
17710                                                                          ; A = 3 prints token 79 ("BONY") and a space
17711                                                                          ; A = 4 prints token 80 ("FAT") and a space
17712                                                                          ; A = 5 prints token 81 ("FURRY") and a space
17713               
17714               TT207:
17715 5098 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Now for the actual species, so take bits 0-1 of
     509A 007D     
17716 509C 024D  22        andi ra,>03*256                 ; AND #%00000011    ; s2_hi, add this to the value of A that we used for
     509E 0300     
17717                      .clc                            ; CLC               ; the third adjective, and take bits 0-2 of the result
     **** ****     > CLC
0001 50A0 0A16  18        sla  rzero,1
                   < elite.a99
17718                      .adc @QQ19,ra                   ; ADC QQ19
     **** ****     > ADC
0001 50A2 1701  14        jnc  !
0002 50A4 B347  18        ab   rone,ra
0003               !:
0004 50A6 B360  30        ab   @QQ19,ra
     50A8 007F     
                   < elite.a99
17719 50AA 024D  22        andi ra,>07*256                 ; AND #%00000111
     50AC 0700     
17720               
17721                      .adi (>f2*256)                  ; ADC #242          ; A = 0 to 7, so print recursive token 82 + A, so:
     **** ****     > ADI
0001 50AE 1701  14        jnc  !
0002 50B0 B347  18        ab   rone,ra
0003               !:
0004 50B2 022D  22        ai   ra,(>F2*256)
     50B4 F200     
                   < elite.a99
17722 50B6 0200  20        li   rtmp,TT27                  ; JSR TT27          ;
     50B8 A6E8     
17723 50BA 06A0  32        bl   @jsr                       ;
     50BC FE1E     
17724                                                                          ; A = 0 prints token 82 ("RODENT")
17725                                                                          ; A = 1 prints token 83 ("FROG")
17726                                                                          ; A = 2 prints token 84 ("LIZARD")
17727                                                                          ; A = 3 prints token 85 ("LOBSTER")
17728                                                                          ; A = 4 prints token 86 ("BIRD")
17729                                                                          ; A = 5 prints token 87 ("HUMANOID")
17730                                                                          ; A = 6 prints token 88 ("FELINE")
17731                                                                          ; A = 7 prints token 89 ("INSECT")
17732               
17733               TT76:
17734 50BE 020D  20        li   ra,('S')*256               ; LDA #'S'          ; Print an "S" to pluralise the species
     50C0 5300     
17735 50C2 0200  20        li   rtmp,TT27                  ; JSR TT27
     50C4 A6E8     
17736 50C6 06A0  32        bl   @jsr                       ;
     50C8 FE1E     
17737               
17738 50CA 020D  20        li   ra,(')')*256               ; LDA #')'          ; And finally, print a closing bracket, followed by a
     50CC 2900     
17739 50CE 0200  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case, to end the species
     50D0 4ED4     
17740 50D2 06A0  32        bl   @jsr                       ;
     50D4 FE1E     
17741                                                                          ; section
17742               
17743 50D6 020D  20        li   ra,>c1*256                 ; LDA #193          ; Print recursive token 33 ("GROSS PRODUCTIVITY"),
     50D8 C100     
17744 50DA 0200  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     50DC A6DC     
17745 50DE 06A0  32        bl   @jsr                       ;
     50E0 FE1E     
17746               
17747 50E2 D3A0  30        movb @QQ7,rx                    ; LDX QQ7           ; Fetch the 16-bit productivity value from QQ7 into
     50E4 0F2D     
17748 50E6 D3E0  30        movb @QQ7+1,ry                  ; LDY QQ7+1         ; (Y X)
     50E8 0F2E     
17749               
17750 50EA 0200  20        li   rtmp,pr6_                  ; JSR pr6           ; Print (Y X) to 5 digits with no decimal point
     50EC 5D44     
17751 50EE 06A0  32        bl   @jsr                       ;
     50F0 FE1E     
17752               
17753 50F2 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     50F4 5E64     
17754 50F6 06A0  32        bl   @jsr                       ;
     50F8 FE1E     
17755               
17756 50FA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     50FC 0000     
17757 50FE D80D  30        movb ra,@QQ17                   ; STA QQ17
     5100 007E     
17758               
17759 5102 020D  20        li   ra,('M')*256               ; LDA #'M'          ; Print "M"
     5104 4D00     
17760 5106 0200  20        li   rtmp,TT27                  ; JSR TT27
     5108 A6E8     
17761 510A 06A0  32        bl   @jsr                       ;
     510C FE1E     
17762               
17763 510E 020D  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR"), followed by a
     5110 E200     
17764 5112 0200  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     5114 4ED4     
17765 5116 06A0  32        bl   @jsr                       ;
     5118 FE1E     
17766               
17767 511A 020D  20        li   ra,>fa*256                 ; LDA #250          ; Print recursive token 90 ("AVERAGE RADIUS"), followed
     511C FA00     
17768 511E 0200  20        li   rtmp,TT68                  ; JSR TT68          ; by a colon
     5120 A6DC     
17769 5122 06A0  32        bl   @jsr                       ;
     5124 FE1E     
17770               
17771                                                                          ; The average radius is calculated like this:
17772                                                                          ;
17773                                                                          ; ((s2_hi AND %1111) + 11) * 256 + s1_hi
17774                                                                          ;
17775                                                                          ; or, in terms of memory locations:
17776                                                                          ;
17777                                                                          ; ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
17778                                                                          ;
17779                                                                          ; Because the multiplication is by 256, this is the
17780                                                                          ; same as saying a 16-bit number, with high byte:
17781                                                                          ;
17782                                                                          ; (QQ15+5 AND %1111) + 11
17783                                                                          ;
17784                                                                          ; and low byte:
17785                                                                          ;
17786                                                                          ; QQ15+3
17787                                                                          ;
17788                                                                          ; so we can set this up in (Y X) and call the pr5
17789                                                                          ; routine to print it out
17790               
17791 5126 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Set A = QQ15+5
     5128 007D     
17792 512A D3A0  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Set X = QQ15+3
     512C 007B     
17793               
17794 512E 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Set Y = (A AND %1111) + 11
     5130 0F00     
17795                      .clc                            ; CLC
     **** ****     > CLC
0001 5132 0A16  18        sla  rzero,1
                   < elite.a99
17796                      .adi (>0b*256)                  ; ADC #11
     **** ****     > ADI
0001 5134 1701  14        jnc  !
0002 5136 B347  18        ab   rone,ra
0003               !:
0004 5138 022D  22        ai   ra,(>0B*256)
     513A 0B00     
                   < elite.a99
17797 513C D3CD  18        movb ra,ry                      ; TAY
17798               
17799 513E 0200  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, not including a decimal
     5140 5D46     
17800 5142 06A0  32        bl   @jsr                       ;
     5144 FE1E     
17801                                                                          ; point, as the C flag will be clear (as the maximum
17802                                                                          ; radius will always fit into 16 bits)
17803               
17804 5146 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     5148 5E64     
17805 514A 06A0  32        bl   @jsr                       ;
     514C FE1E     
17806               
17807 514E 020D  20        li   ra,('k')*256               ; LDA #'k'          ; Print "km", returning from the subroutine using a
     5150 6B00     
17808 5152 0200  20        li   rtmp,TT26                  ; JSR TT26          ; tail call
     5154 3172     
17809 5156 06A0  32        bl   @jsr                       ;
     5158 FE1E     
17810 515A 020D  20        li   ra,('m')*256               ; LDA #'m'
     515C 6D00     
17811 515E 0460  28        b    @TT26                      ; JMP TT26
     5160 3172     
17812               
17813               * ******************************************************************************
17814               *
17815               * Name: TT24
17816               * Type: Subroutine
17817               * Category: Universe
17818               * Summary: Calculate system data from the system seeds
17819               * Deep dive: Generating system data
17820               * Galaxy and system seeds
17821               *
17822               * ------------------------------------------------------------------------------
17823               *
17824               * Calculate system data from the seeds in QQ15 and store them in the relevant
17825               * locations. Specifically, this routine calculates the following from the three
17826               * 16-bit seeds in QQ15 (using only s0_hi, s1_hi and s1_lo):
17827               *
17828               * QQ3 = economy (0-7)
17829               * QQ4 = government (0-7)
17830               * QQ5 = technology level (0-14)
17831               * QQ6 = population * 10 (1-71)
17832               * QQ7 = productivity (96-62480)
17833               *
17834               * The ranges of the various values are shown in brackets. Note that the radius
17835               * and type of inhabitant are calculated on-the-fly in the TT25 routine when
17836               * the system data gets displayed, so they aren't calculated here.
17837               *
17838               * ******************************************************************************
17839               
17840               TT24:
17841 5162 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi and extract bits 0-2 to determine the
     5164 0079     
17842 5166 024D  22        andi ra,>07*256                 ; AND #%00000111    ; system's economy, and store in QQ3
     5168 0700     
17843 516A D80D  30        movb ra,@QQ3                    ; STA QQ3
     516C 0F28     
17844               
17845 516E D360  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; Fetch s1_lo and extract bits 3-5 to determine the
     5170 007A     
17846 5172 091D  18        srl  ra,1                       ; LSR A             ; system's government, and store in QQ4
17847 5174 091D  18        srl  ra,1                       ; LSR A
17848 5176 091D  18        srl  ra,1                       ; LSR A
17849 5178 024D  22        andi ra,>07*256                 ; AND #%00000111
     517A 0700     
17850 517C D80D  30        movb ra,@QQ4                    ; STA QQ4
     517E 0F29     
17851               
17852 5180 091D  18        srl  ra,1                       ; LSR A             ; If government isn't anarchy or feudal, skip to TT77,
17853 5182 1606  14        jne  TT77                       ; BNE TT77          ; as we need to fix the economy of anarchy and feudal
17854                                                                          ; systems so they can't be rich
17855               
17856 5184 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Set bit 1 of the economy in QQ3 to fix the economy
     5186 0F28     
17857 5188 026D  22        ori  ra,>02*256                 ; ORA #%00000010    ; for anarchy and feudal governments
     518A 0200     
17858 518C D80D  30        movb ra,@QQ3                    ; STA QQ3
     518E 0F28     
17859               
17860               TT77:
17861 5190 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the tech level, which we do like this:
     5192 0F28     
17862                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 5194 0200  20        li   rtmp,(>07*256)
     5196 0700     
0002 5198 2B40  18        xor  rtmp,ra
                   < elite.a99
17863                      .clc                            ; CLC               ; flipped_economy + (s1_hi AND %11) + (government / 2)
     **** ****     > CLC
0001 519A 0A16  18        sla  rzero,1
                   < elite.a99
17864 519C D80D  30        movb ra,@QQ5                    ; STA QQ5           ;
     519E 0F2A     
17865                                                                          ; or, in terms of memory locations:
17866                                                                          ;
17867                                                                          ; QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
17868                                                                          ;
17869                                                                          ; We start by setting QQ5 = QQ3 EOR %111
17870               
17871 51A0 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; We then take the first 2 bits of s1_hi (QQ15+3) and
     51A2 007B     
17872 51A4 024D  22        andi ra,>03*256                 ; AND #%00000011    ; add it into QQ5
     51A6 0300     
17873                      .adc @QQ5,ra                    ; ADC QQ5
     **** ****     > ADC
0001 51A8 1701  14        jnc  !
0002 51AA B347  18        ab   rone,ra
0003               !:
0004 51AC B360  30        ab   @QQ5,ra
     51AE 0F2A     
                   < elite.a99
17874 51B0 D80D  30        movb ra,@QQ5                    ; STA QQ5
     51B2 0F2A     
17875               
17876 51B4 D360  30        movb @QQ4,ra                    ; LDA QQ4           ; And finally we add QQ4 / 2 and store the result in
     51B6 0F29     
17877 51B8 091D  18        srl  ra,1                       ; LSR A             ; QQ5, using LSR then ADC to divide by 2, which rounds
17878                      .adc @QQ5,ra                    ; ADC QQ5           ; up the result for odd-numbered government types
     **** ****     > ADC
0001 51BA 1701  14        jnc  !
0002 51BC B347  18        ab   rone,ra
0003               !:
0004 51BE B360  30        ab   @QQ5,ra
     51C0 0F2A     
                   < elite.a99
17879 51C2 D80D  30        movb ra,@QQ5                    ; STA QQ5
     51C4 0F2A     
17880               
17881                      .asla                           ; ASL A             ; Now to work out the population, like so:
     **** ****     > ASLA
0001 51C6 024D  22        andi ra,>ff00
     51C8 FF00     
0002 51CA 0A1D  18        sla  ra,1
                   < elite.a99
17882                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 51CC 024D  22        andi ra,>ff00
     51CE FF00     
0002 51D0 0A1D  18        sla  ra,1
                   < elite.a99
17883                      .adc @QQ3,ra                    ; ADC QQ3           ; (tech level * 4) + economy + government + 1
     **** ****     > ADC
0001 51D2 1701  14        jnc  !
0002 51D4 B347  18        ab   rone,ra
0003               !:
0004 51D6 B360  30        ab   @QQ3,ra
     51D8 0F28     
                   < elite.a99
17884                      .adc @QQ4,ra                    ; ADC QQ4           ;
     **** ****     > ADC
0001 51DA 1701  14        jnc  !
0002 51DC B347  18        ab   rone,ra
0003               !:
0004 51DE B360  30        ab   @QQ4,ra
     51E0 0F29     
                   < elite.a99
17885                      .adi (>01*256)                  ; ADC #1            ; or, in terms of memory locations:
     **** ****     > ADI
0001 51E2 1701  14        jnc  !
0002 51E4 B347  18        ab   rone,ra
0003               !:
0004 51E6 022D  22        ai   ra,(>01*256)
     51E8 0100     
                   < elite.a99
17886 51EA D80D  30        movb ra,@QQ6                    ; STA QQ6           ;
     51EC 0F2B     
17887                                                                          ; QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1
17888               
17889 51EE D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Finally, we work out productivity, like this:
     51F0 0F28     
17890                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 51F2 0200  20        li   rtmp,(>07*256)
     51F4 0700     
0002 51F6 2B40  18        xor  rtmp,ra
                   < elite.a99
17891                      .adi (>03*256)                  ; ADC #3            ; (flipped_economy + 3) * (government + 4)
     **** ****     > ADI
0001 51F8 1701  14        jnc  !
0002 51FA B347  18        ab   rone,ra
0003               !:
0004 51FC 022D  22        ai   ra,(>03*256)
     51FE 0300     
                   < elite.a99
17892 5200 D80D  30        movb ra,@P                      ; STA P             ; * population
     5202 001B     
17893 5204 D360  30        movb @QQ4,ra                    ; LDA QQ4           ; * 8
     5206 0F29     
17894                      .adi (>04*256)                  ; ADC #4            ;
     **** ****     > ADI
0001 5208 1701  14        jnc  !
0002 520A B347  18        ab   rone,ra
0003               !:
0004 520C 022D  22        ai   ra,(>04*256)
     520E 0400     
                   < elite.a99
17895 5210 D80D  30        movb ra,@Q                      ; STA Q             ; or, in terms of memory locations:
     5212 0090     
17896 5214 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ;
     5216 42DE     
17897 5218 06A0  32        bl   @jsr                       ;
     521A FE1E     
17898                                                                          ; QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
17899                                                                          ;
17900                                                                          ; We do the first step by setting P to the first
17901                                                                          ; expression in brackets and Q to the second, and
17902                                                                          ; calling MULTU, so now (A P) = P * Q. The highest this
17903                                                                          ; can be is 10 * 11 (as the maximum values of economy
17904                                                                          ; and government are 7), so the high byte of the result
17905                                                                          ; will always be 0, so we actually have:
17906                                                                          ;
17907                                                                          ; P = P * Q
17908                                                                          ; = (flipped_economy + 3) * (government + 4)
17909               
17910 521C D360  30        movb @QQ6,ra                    ; LDA QQ6           ; We now take the result in P and multiply by the
     521E 0F2B     
17911 5220 D80D  30        movb ra,@Q                      ; STA Q             ; population to get the productivity, by setting Q to
     5222 0090     
17912 5224 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ; the population from QQ6 and calling MULTU again, so
     5226 42DE     
17913 5228 06A0  32        bl   @jsr                       ;
     522A FE1E     
17914                                                                          ; now we have:
17915                                                                          ;
17916                                                                          ; (A P) = P * population
17917               
17918                      .asl @P                         ; ASL P             ; Next we multiply the result by 8, as a 16-bit number,
     **** ****     > ASL
0001 522C D020  30        movb @P,rtmp
     522E 001B     
0002 5230 0240  22        andi rtmp,>ff00
     5232 FF00     
0003 5234 0A10  18        sla  rtmp,1
0004 5236 D800  30        movb rtmp,@P
     5238 001B     
                   < elite.a99
17919 523A 06A0  32        bl   @rola                      ; ROL A             ; so we shift both bytes to the left three times, using
     523C FE34     
17920                      .asl @P                         ; ASL P             ; the C flag to carry bits from bit 7 of the low byte
     **** ****     > ASL
0001 523E D020  30        movb @P,rtmp
     5240 001B     
0002 5242 0240  22        andi rtmp,>ff00
     5244 FF00     
0003 5246 0A10  18        sla  rtmp,1
0004 5248 D800  30        movb rtmp,@P
     524A 001B     
                   < elite.a99
17921 524C 06A0  32        bl   @rola                      ; ROL A             ; into bit 0 of the high byte
     524E FE34     
17922                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 5250 D020  30        movb @P,rtmp
     5252 001B     
0002 5254 0240  22        andi rtmp,>ff00
     5256 FF00     
0003 5258 0A10  18        sla  rtmp,1
0004 525A D800  30        movb rtmp,@P
     525C 001B     
                   < elite.a99
17923 525E 06A0  32        bl   @rola                      ; ROL A
     5260 FE34     
17924               
17925 5262 D80D  30        movb ra,@QQ7+1                  ; STA QQ7+1         ; Finally, we store the productivity in two bytes, with
     5264 0F2E     
17926 5266 D360  30        movb @P,ra                      ; LDA P             ; the low byte in QQ7 and the high byte in QQ7+1
     5268 001B     
17927 526A D80D  30        movb ra,@QQ7                    ; STA QQ7
     526C 0F2D     
17928               
17929 526E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5270 FE2A     
17930               
17931               * ******************************************************************************
17932               *
17933               * Name: TT22
17934               * Type: Subroutine
17935               * Category: Charts
17936               * Summary: Show the Long-range Chart (red key f4)
17937               *
17938               * ******************************************************************************
17939               
17940               TT22:
17941 5272 020D  20        li   ra,>40*256                 ; LDA #64           ; Clear the top part of the screen, draw a white border,
     5274 4000     
17942 5276 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Long-
     5278 4B2A     
17943 527A 06A0  32        bl   @jsr                       ;
     527C FE1E     
17944                                                                          ; range Chart)
17945               
17946 527E 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     5280 0700     
17947 5282 D80D  30        movb ra,@XC                     ; STA XC
     5284 002C     
17948               
17949 5286 0200  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5288 5AA4     
17950 528A 06A0  32        bl   @jsr                       ;
     528C FE1E     
17951                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
17952               
17953 528E 020D  20        li   ra,>c7*256                 ; LDA #199          ; Print recursive token 39 ("GALACTIC CHART{galaxy
     5290 C700     
17954 5292 0200  20        li   rtmp,TT27                  ; JSR TT27          ; number right-aligned to width 3}")
     5294 A6E8     
17955 5296 06A0  32        bl   @jsr                       ;
     5298 FE1E     
17956               
17957 529A 0200  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line at pixel row 23 to box in the
     529C 25BE     
17958 529E 06A0  32        bl   @jsr                       ;
     52A0 FE1E     
17959                                                                          ; title and act as the top frame of the chart, and move
17960                                                                          ; the text cursor down one line
17961               
17962 52A2 020D  20        li   ra,>98*256                 ; LDA #152          ; Draw a screen-wide horizontal line at pixel row 152
     52A4 9800     
17963 52A6 0200  20        li   rtmp,NLIN2                 ; JSR NLIN2         ; for the bottom edge of the chart, so the chart itself
     52A8 25C4     
17964 52AA 06A0  32        bl   @jsr                       ;
     52AC FE1E     
17965                                                                          ; is 128 pixels high, starting on row 24 and ending on
17966                                                                          ; row 151
17967               
17968 52AE 0200  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     52B0 53FA     
17969 52B2 06A0  32        bl   @jsr                       ;
     52B4 FE1E     
17970                                                                          ; current system's galactic coordinates
17971               
17972 52B6 020E  20        li   rx,>00*256                 ; LDX #0            ; We're now going to plot each of the galaxy's systems,
     52B8 0000     
17973                                                                          ; so set up a counter in X for each system, starting at
17974                                                                          ; 0 and looping through to 255
17975               
17976               TT83:
17977 52BA D80E  30        movb rx,@XSAV                   ; STX XSAV          ; Store the counter in XSAV
     52BC 0093     
17978               
17979 52BE D3A0  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Fetch the s1_hi seed into X, which gives us the
     52C0 007B     
17980                                                                          ; galactic x-coordinate of this system
17981               
17982 52C2 D3E0  30        movb @QQ15+4,ry                 ; LDY QQ15+4        ; Fetch the s2_lo seed and set bits 4 and 6, storing the
     52C4 007C     
17983 52C6 D34F  18        movb ry,ra                      ; TYA               ; result in ZZ to give a random number between 80 and
17984 52C8 026D  22        ori  ra,>50*256                 ; ORA #%01010000    ; (but which will always be the same for this system).
     52CA 5000     
17985 52CC D80D  30        movb ra,@ZZ                     ; STA ZZ            ; We use this value to determine the size of the point
     52CE 0097     
17986                                                                          ; for this system on the chart by passing it as the
17987                                                                          ; distance argument to the PIXEL routine below
17988               
17989 52D0 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch the s0_hi seed into A, which gives us the
     52D2 0079     
17990                                                                          ; galactic y-coordinate of this system
17991               
17992 52D4 091D  18        srl  ra,1                       ; LSR A             ; We halve the y-coordinate because the galaxy in
17993                                                                          ; in Elite is rectangular rather than square, and is
17994                                                                          ; twice as wide (x-axis) as it is high (y-axis), so the
17995                                                                          ; chart is 256 pixels wide and 128 high
17996               
17997                      .clc                            ; CLC               ; Add 24 to the halved y-coordinate and store in XX15+1
     **** ****     > CLC
0001 52D6 0A16  18        sla  rzero,1
                   < elite.a99
17998                      .adi (>18*256)                  ; ADC #24           ; (as the top of the chart is on pixel row 24, just
     **** ****     > ADI
0001 52D8 1701  14        jnc  !
0002 52DA B347  18        ab   rone,ra
0003               !:
0004 52DC 022D  22        ai   ra,(>18*256)
     52DE 1800     
                   < elite.a99
17999 52E0 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; below the line we drew on row 23 above)
     52E2 0032     
18000               
18001 52E4 0200  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Call PIXEL to draw a point at (X, A), with the size of
     52E6 27BC     
18002 52E8 06A0  32        bl   @jsr                       ;
     52EA FE1E     
18003                                                                          ; the point dependent on the distance specified in ZZ
18004                                                                          ; (so a high value of ZZ will produce a 1-pixel point,
18005                                                                          ; a medium value will produce a 2-pixel dash, and a
18006                                                                          ; small value will produce a 4-pixel square)
18007               
18008 52EC 0200  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     52EE 4E32     
18009 52F0 06A0  32        bl   @jsr                       ;
     52F2 FE1E     
18010                                                                          ; to twist the three 16-bit seeds in QQ15
18011               
18012 52F4 D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the loop counter from XSAV
     52F6 0093     
18013               
18014 52F8 B387  18        ab   rone,rx                    ; INX               ; Increment the counter
18015               
18016 52FA 16DF  14        jne  TT83                       ; BNE TT83          ; If X > 0 then we haven't done all 256 systems yet, so
18017                                                                          ; loop back up to TT83
18018               
18019 52FC D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Set QQ19 to the selected system's x-coordinate
     52FE 0F31     
18020 5300 D80D  30        movb ra,@QQ19                   ; STA QQ19
     5302 007F     
18021               
18022 5304 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set QQ19+1 to the selected system's y-coordinate,
     5306 0F32     
18023 5308 091D  18        srl  ra,1                       ; LSR A             ; halved to fit it into the chart
18024 530A D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1
     530C 0080     
18025               
18026 530E 020D  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to size 4 for the crosshairs size
     5310 0400     
18027 5312 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5314 0081     
18028               
18029                                                                          ; Fall through into TT15 to draw crosshairs of size 4 at
18030                                                                          ; the selected system's coordinates
18031               
18032               * ******************************************************************************
18033               *
18034               * Name: TT15
18035               * Type: Subroutine
18036               * Category: Drawing lines
18037               * Summary: Draw a set of crosshairs
18038               *
18039               * ------------------------------------------------------------------------------
18040               *
18041               * For all views except the Short-range Chart, the centre is drawn 24 pixels to
18042               * the right of the y-coordinate given.
18043               *
18044               * ------------------------------------------------------------------------------
18045               *
18046               * Arguments:
18047               *
18048               * QQ19                The pixel x-coordinate of the centre of the crosshairs
18049               *
18050               * QQ19+1              The pixel y-coordinate of the centre of the crosshairs
18051               *
18052               * QQ19+2              The size of the crosshairs
18053               *
18054               * ******************************************************************************
18055               
18056               TT15:
18057 5316 020D  20        li   ra,>18*256                 ; LDA #24           ; Set A to 24, which we will use as the minimum
     5318 1800     
18058                                                                          ; screen indent for the crosshairs (i.e. the minimum
18059                                                                          ; distance from the top-left corner of the screen)
18060               
18061 531A D3A0  30        movb @QQ11,rx                   ; LDX QQ11          ; If the current view is not the Short-range Chart,
     531C 0096     
18062 531E 1502  14        jgt  B52                        ; BPL B52           ; which is the only view with bit 7 set, then skip the
18063                                                                          ; following instruction
18064               
18065 5320 020D  20        li   ra,>00*256                 ; LDA #0            ; This is the Short-range Chart, so set A to 0, so the
     5322 0000     
18066                                                                          ; crosshairs can go right up against the screen edges
18067               
18068               B52:
18069 5324 D80D  30        movb ra,@QQ19+5                 ; STA QQ19+5        ; Set QQ19+5 to A, which now contains the correct indent
     5326 0084     
18070                                                                          ; for this view
18071               
18072 5328 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate - crosshairs size
     532A 007F     
18073                      .sec                            ; SEC               ; to get the x-coordinate of the left edge of the
     **** ****     > SEC
0001 532C 0A18  18        sla  rmone,1
                   < elite.a99
18074                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 532E 1801  14        joc  !
0002 5330 7347  18        sb   rone,ra
0003               !:
0004 5332 7360  30        sb   @QQ19+2,ra
     5334 0081     
                   < elite.a99
18075               
18076 5336 1802  14        joc  TT84                       ; BCS TT84          ; If the above subtraction didn't underflow, then A is
18077                                                                          ; positive, so skip the next instruction
18078               
18079 5338 020D  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     533A 0000     
18080                                                                          ; crosshairs don't spill out of the left of the screen
18081               
18082               TT84:
18083                                                                          ; In the following, the authors have used XX15 for
18084                                                                          ; temporary storage. XX15 shares location with X1, Y1,
18085                                                                          ; X2 and Y2, so in the following, you can consider
18086                                                                          ; the variables like this:
18087                                                                          ;
18088                                                                          ; XX15   is the same as X1
18089                                                                          ; XX15+1 is the same as Y1
18090                                                                          ; XX15+2 is the same as X2
18091                                                                          ; XX15+3 is the same as Y2
18092                                                                          ;
18093                                                                          ; Presumably this routine was written at a different
18094                                                                          ; time to the line-drawing routine, before the two
18095                                                                          ; workspaces were merged to save space
18096 533C D80D  30        movb ra,@XX15                   ; STA XX15          ; Set XX15 (X1) = A (the x-coordinate of the left edge
     533E 0031     
18097                                                                          ; of the crosshairs)
18098               
18099 5340 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate + crosshairs size
     5342 007F     
18100                      .clc                            ; CLC               ; to get the x-coordinate of the right edge of the
     **** ****     > CLC
0001 5344 0A16  18        sla  rzero,1
                   < elite.a99
18101                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; crosshairs
     **** ****     > ADC
0001 5346 1701  14        jnc  !
0002 5348 B347  18        ab   rone,ra
0003               !:
0004 534A B360  30        ab   @QQ19+2,ra
     534C 0081     
                   < elite.a99
18102               
18103 534E 1702  14        jnc  B53                        ; BCC B53           ; If the above addition didn't overflow, then A is
18104                                                                          ; correct, so skip the next instruction
18105               
18106 5350 020D  20        li   ra,>ff*256                 ; LDA #255          ; The addition overflowed, so set A to 255 so the
     5352 FF00     
18107                                                                          ; crosshairs don't spill out of the right of the screen
18108                                                                          ; (as 255 is the x-coordinate of the rightmost pixel
18109                                                                          ; on-screen)
18110               
18111               B53:
18112 5354 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = A (the x-coordinate of the right
     5356 0033     
18113                                                                          ; edge of the crosshairs)
18114               
18115 5358 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set XX15+1 (Y1) = crosshairs y-coordinate + indent
     535A 0080     
18116                      .clc                            ; CLC               ; to get the y-coordinate of the centre of the
     **** ****     > CLC
0001 535C 0A16  18        sla  rzero,1
                   < elite.a99
18117                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; crosshairs
     **** ****     > ADC
0001 535E 1701  14        jnc  !
0002 5360 B347  18        ab   rone,ra
0003               !:
0004 5362 B360  30        ab   @QQ19+5,ra
     5364 0084     
                   < elite.a99
18118 5366 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     5368 0032     
18119               
18120 536A 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1),
     536C 25EE     
18121 536E 06A0  32        bl   @jsr                       ;
     5370 FE1E     
18122                                                                          ; which will draw from the left edge of the crosshairs
18123                                                                          ; to the right edge, through the centre of the
18124                                                                          ; crosshairs
18125               
18126 5372 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate - crosshairs size
     5374 0080     
18127                      .sec                            ; SEC               ; to get the y-coordinate of the top edge of the
     **** ****     > SEC
0001 5376 0A18  18        sla  rmone,1
                   < elite.a99
18128                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 5378 1801  14        joc  !
0002 537A 7347  18        sb   rone,ra
0003               !:
0004 537C 7360  30        sb   @QQ19+2,ra
     537E 0081     
                   < elite.a99
18129               
18130 5380 1802  14        joc  TT86                       ; BCS TT86          ; If the above subtraction didn't underflow, then A is
18131                                                                          ; correct, so skip the next instruction
18132               
18133 5382 020D  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     5384 0000     
18134                                                                          ; crosshairs don't spill out of the top of the screen
18135               
18136               TT86:
18137                      .clc                            ; CLC               ; Set XX15+1 (Y1) = A + indent to get the y-coordinate
     **** ****     > CLC
0001 5386 0A16  18        sla  rzero,1
                   < elite.a99
18138                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; of the top edge of the indented crosshairs
     **** ****     > ADC
0001 5388 1701  14        jnc  !
0002 538A B347  18        ab   rone,ra
0003               !:
0004 538C B360  30        ab   @QQ19+5,ra
     538E 0084     
                   < elite.a99
18139 5390 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     5392 0032     
18140               
18141 5394 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate + crosshairs size
     5396 0080     
18142                      .clc                            ; CLC               ; + indent to get the y-coordinate of the bottom edge
     **** ****     > CLC
0001 5398 0A16  18        sla  rzero,1
                   < elite.a99
18143                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; of the indented crosshairs
     **** ****     > ADC
0001 539A 1701  14        jnc  !
0002 539C B347  18        ab   rone,ra
0003               !:
0004 539E B360  30        ab   @QQ19+2,ra
     53A0 0081     
                   < elite.a99
18144                      .adc @QQ19+5,ra                 ; ADC QQ19+5
     **** ****     > ADC
0001 53A2 1701  14        jnc  !
0002 53A4 B347  18        ab   rone,ra
0003               !:
0004 53A6 B360  30        ab   @QQ19+5,ra
     53A8 0084     
                   < elite.a99
18145               
18146 53AA 028D  22        ci   ra,>98*256                 ; CMP #152          ; If A < 152 then skip the following, as the crosshairs
     53AC 9800     
18147 53AE 1705  14        jnc  TT87                       ; BCC TT87          ; won't spill out of the bottom of the screen
18148               
18149 53B0 D3A0  30        movb @QQ11,rx                   ; LDX QQ11          ; A >= 152, so we need to check whether this will fit in
     53B2 0096     
18150                                                                          ; this view, so fetch the view type
18151               
18152 53B4 1102  14        jlt  TT87                       ; BMI TT87          ; If this is the Short-range Chart then the y-coordinate
18153                                                                          ; is fine, so skip to TT87
18154               
18155 53B6 020D  20        li   ra,>97*256                 ; LDA #151          ; Otherwise this is the Long-range Chart, so we need to
     53B8 9700     
18156                                                                          ; clip the crosshairs at a maximum y-coordinate of 151
18157               
18158               TT87:
18159 53BA D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; Set XX15+3 (Y2) = A (the y-coordinate of the bottom
     53BC 0034     
18160                                                                          ; edge of the crosshairs)
18161               
18162 53BE D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set XX15 (X1) = the x-coordinate of the centre of the
     53C0 007F     
18163 53C2 D80D  30        movb ra,@XX15                   ; STA XX15          ; crosshairs
     53C4 0031     
18164               
18165 53C6 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = the x-coordinate of the centre of
     53C8 0033     
18166                                                                          ; the crosshairs
18167               
18168 53CA 0460  28        b    @LL30                      ; JMP LL30          ; Draw a vertical line (X1, Y1) to (X2, Y2), which will
     53CC 224E     
18169                                                                          ; draw from the top edge of the crosshairs to the bottom
18170                                                                          ; edge, through the centre of the crosshairs, returning
18171                                                                          ; from the subroutine using a tail call
18172               
18173               * ******************************************************************************
18174               *
18175               * Name: TT14
18176               * Type: Subroutine
18177               * Category: Drawing circles
18178               * Summary: Draw a circle with crosshairs on a chart
18179               *
18180               * ------------------------------------------------------------------------------
18181               *
18182               * Draw a circle with crosshairs at the current system's galactic coordinates.
18183               *
18184               * ******************************************************************************
18185               
18186               TT126:
18187 53CE 020D  20        li   ra,>68*256                 ; LDA #104          ; Set QQ19 = 104, for the x-coordinate of the centre of
     53D0 6800     
18188 53D2 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; the fixed circle on the Short-range Chart
     53D4 007F     
18189               
18190 53D6 020D  20        li   ra,>5a*256                 ; LDA #90           ; Set QQ19+1 = 90, for the y-coordinate of the centre of
     53D8 5A00     
18191 53DA D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; the fixed circle on the Short-range Chart
     53DC 0080     
18192               
18193 53DE 020D  20        li   ra,>10*256                 ; LDA #16           ; Set QQ19+2 = 16, the size of the crosshairs on the
     53E0 1000     
18194 53E2 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Short-range Chart
     53E4 0081     
18195               
18196 53E6 0200  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, at the
     53E8 5316     
18197 53EA 06A0  32        bl   @jsr                       ;
     53EC FE1E     
18198                                                                          ; exact coordinates as this is the Short-range Chart
18199               
18200 53EE D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14, so this can act as
     53F0 030D     
18201 53F2 D80D  30        movb ra,@K                      ; STA K             ; the circle's radius (70 being a full tank)
     53F4 003D     
18202               
18203 53F6 0460  28        b    @TT128                     ; JMP TT128         ; Jump to TT128 to draw a circle with the centre at the
     53F8 5440     
18204                                                                          ; same coordinates as the crosshairs, (QQ19, QQ19+1),
18205                                                                          ; and radius K that reflects the current fuel levels,
18206                                                                          ; returning from the subroutine using a tail call
18207               
18208               TT14:
18209 53FA D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is the Short-range Chart, which
     53FC 0096     
18210 53FE 11E7  14        jlt  TT126                      ; BMI TT126         ; is the only view with bit 7 set, then jump up to TT126
18211                                                                          ; to draw the crosshairs and circle for that view
18212               
18213                                                                          ; Otherwise this is the Long-range Chart, so we draw the
18214                                                                          ; crosshairs and circle for that view instead
18215               
18216 5400 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14 divided by 4, so
     5402 030D     
18217 5404 091D  18        srl  ra,1                       ; LSR A             ; this can act as the circle's radius (70 being a full
18218 5406 091D  18        srl  ra,1                       ; LSR A             ; tank, which divides down to a radius of 17)
18219 5408 D80D  30        movb ra,@K                      ; STA K
     540A 003D     
18220               
18221 540C D360  30        movb @QQ0,ra                    ; LDA QQ0           ; Set QQ19 to the x-coordinate of the current system,
     540E 0301     
18222 5410 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; which will be the centre of the circle and crosshairs
     5412 007F     
18223                                                                          ; we draw
18224               
18225 5414 D360  30        movb @QQ1,ra                    ; LDA QQ1           ; Set QQ19+1 to the y-coordinate of the current system,
     5416 0302     
18226 5418 091D  18        srl  ra,1                       ; LSR A             ; halved because the galactic chart is half as high as
18227 541A D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; it is wide, which will again be the centre of the
     541C 0080     
18228                                                                          ; circle and crosshairs we draw
18229               
18230 541E 020D  20        li   ra,>07*256                 ; LDA #7            ; Set QQ19+2 = 7, the size of the crosshairs on the
     5420 0700     
18231 5422 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Long-range Chart
     5424 0081     
18232               
18233 5426 0200  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, which will
     5428 5316     
18234 542A 06A0  32        bl   @jsr                       ;
     542C FE1E     
18235                                                                          ; be drawn 24 pixels to the right of QQ19+1
18236               
18237 542E D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Add 24 to the y-coordinate of the crosshairs in QQ19+1
     5430 0080     
18238                      .clc                            ; CLC               ; so that the centre of the circle matches the centre
     **** ****     > CLC
0001 5432 0A16  18        sla  rzero,1
                   < elite.a99
18239                      .adi (>18*256)                  ; ADC #24           ; of the crosshairs
     **** ****     > ADI
0001 5434 1701  14        jnc  !
0002 5436 B347  18        ab   rone,ra
0003               !:
0004 5438 022D  22        ai   ra,(>18*256)
     543A 1800     
                   < elite.a99
18240 543C D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1
     543E 0080     
18241               
18242                                                                          ; Fall through into TT128 to draw a circle with the
18243                                                                          ; centre at the same coordinates as the crosshairs,
18244                                                                          ; (QQ19, QQ19+1), and radius K that reflects the
18245                                                                          ; current fuel levels
18246               
18247               * ******************************************************************************
18248               *
18249               * Name: TT128
18250               * Type: Subroutine
18251               * Category: Drawing circles
18252               * Summary: Draw a circle on a chart
18253               * Deep dive: Drawing circles
18254               *
18255               * ------------------------------------------------------------------------------
18256               *
18257               * Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
18258               *
18259               * ------------------------------------------------------------------------------
18260               *
18261               * Arguments:
18262               *
18263               * QQ19                The x-coordinate of the centre of the circle
18264               *
18265               * QQ19+1              The y-coordinate of the centre of the circle
18266               *
18267               * K                   The radius of the circle
18268               *
18269               * ******************************************************************************
18270               
18271               TT128:
18272 5440 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set K3 = the x-coordinate of the centre
     5442 007F     
18273 5444 D80D  30        movb ra,@K3                     ; STA K3
     5446 00D2     
18274               
18275 5448 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set K4 = the y-coordinate of the centre
     544A 0080     
18276 544C D80D  30        movb ra,@K4                     ; STA K4
     544E 00E0     
18277               
18278 5450 020E  20        li   rx,>00*256                 ; LDX #0            ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     5452 0000     
18279 5454 D80E  30        movb rx,@K4+1                   ; STX K4+1
     5456 00E1     
18280 5458 D80E  30        movb rx,@K3+1                   ; STX K3+1
     545A 00D3     
18281               
18282               * STX LSX                \ This instruction is commented out in the original
18283                                                                          ; source
18284               
18285 545C B387  18        ab   rone,rx                    ; INX               ; Set LSP = 1 to reset the ball line heap
18286 545E D80E  30        movb rx,@LSP                    ; STX LSP
     5460 0077     
18287               
18288 5462 020E  20        li   rx,>02*256                 ; LDX #2            ; Set STP = 2, the step size for the circle
     5464 0200     
18289 5466 D80E  30        movb rx,@STP                    ; STX STP
     5468 00A6     
18290               
18291 546A 0200  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     546C B82C     
18292 546E 06A0  32        bl   @jsr                       ;
     5470 FE1E     
18293                                                                          ; (K3(1 0), K4(1 0)) and radius K
18294               
18295               * LDA #&FF               \ These instructions are commented out in the original
18296               * STA LSX                \ source
18297               
18298 5472 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5474 FE2A     
18299               
18300               * ******************************************************************************
18301               *
18302               * Name: TT219
18303               * Type: Subroutine
18304               * Category: Market
18305               * Summary: Show the Buy Cargo screen (red key f1)
18306               *
18307               * ------------------------------------------------------------------------------
18308               *
18309               * Other entry points:
18310               *
18311               * BAY2                Jump into the main loop at FRCE, setting the key
18312               * "pressed" to red key f9 (so we show the Inventory
18313               * screen)
18314               *
18315               * ******************************************************************************
18316               
18317               TT219:
18318               * LDA #2                 \ This instruction is commented out in the original
18319                                                                          ; source. Perhaps this view originally had a QQ11 value
18320                                                                          ; of 2, but it turned out not to need its own unique ID,
18321                                                                          ; so the authors found they could just use a view value
18322                                                                          ; of 1 and save an instruction at the same time?
18323 5476 0200  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     5478 4B28     
18324 547A 06A0  32        bl   @jsr                       ;
     547C FE1E     
18325                                                                          ; and set the current view type in QQ11 to 1
18326               
18327 547E 0200  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     5480 5E8E     
18328 5482 06A0  32        bl   @jsr                       ;
     5484 FE1E     
18329               
18330 5486 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     5488 8000     
18331 548A D80D  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     548C 007E     
18332               
18333               * JSR FLKB               \ This instruction is commented out in the original
18334                                                                          ; source. It calls a routine to flush the keyboard
18335                                                                          ; buffer (FLKB) that isn't present in the cassette
18336                                                                          ; version but is in other versions
18337               
18338 548E 020D  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     5490 0000     
18339 5492 D80D  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     5494 0F1B     
18340                                                                          ; current item and start it at 0
18341               
18342               TT220:
18343 5496 0200  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     5498 5D62     
18344 549A 06A0  32        bl   @jsr                       ;
     549C FE1E     
18345                                                                          ; availability of the current item, and set QQ24 to the
18346                                                                          ; item's price / 4, QQ25 to the quantity available and
18347                                                                          ; QQ19+1 to byte #1 from the market prices table for
18348                                                                          ; this item
18349               
18350 549E D360  30        movb @QQ25,ra                   ; LDA QQ25          ; If there are some of the current item available, jump
     54A0 0F19     
18351 54A2 1611  14        jne  TT224                      ; BNE TT224         ; to TT224 below to see if we want to buy any
18352               
18353 54A4 0460  28        b    @TT222                     ; JMP TT222         ; Otherwise there are none available, so jump down to
     54A6 559C     
18354                                                                          ; TT222 to skip this item
18355               
18356               TQ4:
18357 54A8 020F  20        li   ry,>b0*256                 ; LDY #176          ; Set Y to the recursive token 16 ("QUANTITY")
     54AA B000     
18358               
18359               Tc:
18360 54AC 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     54AE 5E64     
18361 54B0 06A0  32        bl   @jsr                       ;
     54B2 FE1E     
18362               
18363 54B4 D34F  18        movb ry,ra                      ; TYA               ; Print the recursive token in Y followed by a question
18364 54B6 0200  20        li   rtmp,prq_                  ; JSR prq           ; mark
     54B8 5D52     
18365 54BA 06A0  32        bl   @jsr                       ;
     54BC FE1E     
18366               
18367               TTX224:
18368 54BE 0200  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     54C0 A4E8     
18369 54C2 06A0  32        bl   @jsr                       ;
     54C4 FE1E     
18370                                                                          ; second
18371               
18372               TT224:
18373 54C6 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     54C8 4C2E     
18374 54CA 06A0  32        bl   @jsr                       ;
     54CC FE1E     
18375                                                                          ; and move the text cursor to column 1 on row 21, i.e.
18376                                                                          ; the start of the top row of the three bottom rows
18377               
18378 54CE 020D  20        li   ra,>cc*256                 ; LDA #204          ; Print recursive token 44 ("QUANTITY OF ")
     54D0 CC00     
18379 54D2 0200  20        li   rtmp,TT27                  ; JSR TT27
     54D4 A6E8     
18380 54D6 06A0  32        bl   @jsr                       ;
     54D8 FE1E     
18381               
18382 54DA D360  30        movb @QQ29,ra                   ; LDA QQ29          ; Print recursive token 48 + QQ29, which will be in the
     54DC 0F1B     
18383                      .clc                            ; CLC               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     **** ****     > CLC
0001 54DE 0A16  18        sla  rzero,1
                   < elite.a99
18384                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 54E0 1701  14        jnc  !
0002 54E2 B347  18        ab   rone,ra
0003               !:
0004 54E4 022D  22        ai   ra,(>D0*256)
     54E6 D000     
                   < elite.a99
18385 54E8 0200  20        li   rtmp,TT27                  ; JSR TT27
     54EA A6E8     
18386 54EC 06A0  32        bl   @jsr                       ;
     54EE FE1E     
18387               
18388 54F0 020D  20        li   ra,('/')*256               ; LDA #'/'          ; Print "/"
     54F2 2F00     
18389 54F4 0200  20        li   rtmp,TT27                  ; JSR TT27
     54F6 A6E8     
18390 54F8 06A0  32        bl   @jsr                       ;
     54FA FE1E     
18391               
18392 54FC 0200  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the current item
     54FE 5E4C     
18393 5500 06A0  32        bl   @jsr                       ;
     5502 FE1E     
18394                                                                          ; (as the call to TT151 above set QQ19+1 with the
18395                                                                          ; appropriate value)
18396               
18397 5504 020D  20        li   ra,('?')*256               ; LDA #'?'          ; Print "?"
     5506 3F00     
18398 5508 0200  20        li   rtmp,TT27                  ; JSR TT27
     550A A6E8     
18399 550C 06A0  32        bl   @jsr                       ;
     550E FE1E     
18400               
18401 5510 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     5512 4EE6     
18402 5514 06A0  32        bl   @jsr                       ;
     5516 FE1E     
18403               
18404 5518 020E  20        li   rx,>00*256                 ; LDX #0            ; These instructions have no effect, as they are
     551A 0000     
18405 551C D80E  30        movb rx,@R                      ; STX R             ; repeated at the start of gnum, which we call next.
     551E 0091     
18406 5520 020E  20        li   rx,>0c*256                 ; LDX #12           ; Perhaps they were left behind when code was moved from
     5522 0C00     
18407 5524 D80E  30        movb rx,@T1                     ; STX T1            ; here into gnum, and weren't deleted?
     5526 0006     
18408               
18409               * .TT223                 \ This label is commented out in the original source,
18410                                                                          ; and is a duplicate of a label in gnum, so this could
18411                                                                          ; also be a remnant if the code in gnum was originally
18412                                                                          ; here, but got moved into the gnum subroutine
18413               
18414 5528 0200  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     552A 55CE     
18415 552C 06A0  32        bl   @jsr                       ;
     552E FE1E     
18416                                                                          ; will be the quantity of this item we want to purchase,
18417                                                                          ; returning the number entered in A and R
18418               
18419 5530 18BB  14        joc  TQ4                        ; BCS TQ4           ; If gnum set the C flag, the number entered is greater
18420                                                                          ; than the quantity available, so jump up to TQ4 to
18421                                                                          ; display a "Quantity?" error, beep, clear the number
18422                                                                          ; and try again
18423               
18424 5532 D80D  30        movb ra,@P                      ; STA P             ; Otherwise we have a valid purchase quantity entered,
     5534 001B     
18425                                                                          ; so store the amount we want to purchase in P
18426               
18427 5536 0200  20        li   rtmp,tnpr_                 ; JSR tnpr          ; Call tnpr to work out whether there is room in the
     5538 4DF4     
18428 553A 06A0  32        bl   @jsr                       ;
     553C FE1E     
18429                                                                          ; cargo hold for this item
18430               
18431 553E 020F  20        li   ry,>ce*256                 ; LDY #206          ; Set Y to recursive token 46 (" CARGO{sentence case}")
     5540 CE00     
18432                                                                          ; to pass to the Tc routine if we call it
18433               
18434 5542 18B4  14        joc  Tc                         ; BCS Tc            ; If the C flag is set, then there is no room in the
18435                                                                          ; cargo hold, jump up to Tc to print a "Cargo?" error,
18436                                                                          ; beep, clear the number and try again
18437               
18438 5544 D360  30        movb @QQ24,ra                   ; LDA QQ24          ; There is room in the cargo hold, so now to check
     5546 0F18     
18439 5548 D80D  30        movb ra,@Q                      ; STA Q             ; whether we have enough cash, so fetch the item's
     554A 0090     
18440                                                                          ; price / 4, which was returned in QQ24 by the call
18441                                                                          ; to TT151 above and store it in Q
18442               
18443 554C 0200  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate:
     554E A202     
18444 5550 06A0  32        bl   @jsr                       ;
     5552 FE1E     
18445                                                                          ;
18446                                                                          ; (Y X) = P * Q * 4
18447                                                                          ;
18448                                                                          ; which will be the total price of this transaction
18449                                                                          ; (as P contains the purchase quantity and Q contains
18450                                                                          ; the item's price / 4)
18451               
18452 5554 0200  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot in CASH
     5556 A172     
18453 5558 06A0  32        bl   @jsr                       ;
     555A FE1E     
18454               
18455 555C 020F  20        li   ry,>c5*256                 ; LDY #197          ; If the C flag is clear, we didn't have enough cash,
     555E C500     
18456 5560 17A5  14        jnc  Tc                         ; BCC Tc            ; so set Y to the recursive token 37 ("CASH") and jump
18457                                                                          ; up to Tc to print a "Cash?" error, beep, clear the
18458                                                                          ; number and try again
18459               
18460 5562 D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the current market item number from QQ29 into Y
     5564 0F1B     
18461               
18462 5566 D360  30        movb @R,ra                      ; LDA R             ; Set A to the number of items we just purchased (this
     5568 0091     
18463                                                                          ; was set by gnum above)
18464               
18465                      .pha                            ; PHA               ; Store the quantity just purchased on the stack
     **** ****     > PHA
0001 556A D68D  30        movb ra,*rsp
0002 556C 060A  14        dec  rsp
                   < elite.a99
18466               
18467                      .clc                            ; CLC               ; Add the number purchased to the Y-th byte of QQ20,
     **** ****     > CLC
0001 556E 0A16  18        sla  rzero,1
                   < elite.a99
18468                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; which contains the number of items of this type in
     **** ****     > ADC
0001 5570 1701  14        jnc  !
0002 5572 B347  18        ab   rone,ra
0003               !:
0004 5574 B36F  34        ab   @QQ20(RY),ra
     5576 0317     
                   < elite.a99
18469 5578 DBCD  38        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; our hold (so this transfers the bought items into our
     557A 0317     
18470                                                                          ; cargo hold)
18471               
18472 557C D36F  34        movb @AVL(ry),ra                ; LDA AVL,Y         ; Subtract the number of items from the Y-th byte of
     557E 0335     
18473                      .sec                            ; SEC               ; AVL, which contains the number of items of this type
     **** ****     > SEC
0001 5580 0A18  18        sla  rmone,1
                   < elite.a99
18474                      .sbc @R,ra                      ; SBC R             ; that are available on the market
     **** ****     > SBC
0001 5582 1801  14        joc  !
0002 5584 7347  18        sb   rone,ra
0003               !:
0004 5586 7360  30        sb   @R,ra
     5588 0091     
                   < elite.a99
18475 558A DBCD  38        movb ra,@AVL(ry)                ; STA AVL,Y
     558C 0335     
18476               
18477                      .pla                            ; PLA               ; Restore the quantity just purchased
     **** ****     > PLA
0001 558E 058A  14        inc  rsp
0002 5590 D35A  26        movb *rsp,ra
                   < elite.a99
18478               
18479 5592 1304  14        jeq  TT222                      ; BEQ TT222         ; If we didn't buy anything, jump to TT222 to skip the
18480                                                                          ; following instruction
18481               
18482 5594 0200  20        li   rtmp,dn_                   ; JSR dn            ; Call dn to print the amount of cash left in the cash
     5596 A4D4     
18483 5598 06A0  32        bl   @jsr                       ;
     559A FE1E     
18484                                                                          ; pot, then make a short, high beep to confirm the
18485                                                                          ; purchase, and delay for 1 second
18486               
18487               TT222:
18488 559C D360  30        movb @QQ29,ra                   ; LDA QQ29          ; Move the text cursor to row QQ29 + 5 (where QQ29 is
     559E 0F1B     
18489                      .clc                            ; CLC               ; the item number, starting from 0)
     **** ****     > CLC
0001 55A0 0A16  18        sla  rzero,1
                   < elite.a99
18490                      .adi (>05*256)                  ; ADC #5
     **** ****     > ADI
0001 55A2 1701  14        jnc  !
0002 55A4 B347  18        ab   rone,ra
0003               !:
0004 55A6 022D  22        ai   ra,(>05*256)
     55A8 0500     
                   < elite.a99
18491 55AA D80D  30        movb ra,@YC                     ; STA YC
     55AC 002D     
18492               
18493 55AE 020D  20        li   ra,>00*256                 ; LDA #0            ; Move the text cursor to column 0
     55B0 0000     
18494 55B2 D80D  30        movb ra,@XC                     ; STA XC
     55B4 002C     
18495               
18496 55B6 B347  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
18497               
18498 55B8 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to BAY2 as we have done the
     55BA 0F1B     
18499 55BC 028D  22        ci   ra,>11*256                 ; CMP #17           ; last item
     55BE 1100     
18500 55C0 1802  14        joc  BAY2                       ; BCS BAY2
18501               
18502 55C2 0460  28        b    @TT220                     ; JMP TT220         ; Otherwise loop back to TT220 to print the next market
     55C4 5496     
18503                                                                          ; item
18504               
18505               BAY2:
18506 55C6 020D  20        li   ra,(f9_)*256               ; LDA #f9           ; Jump into the main loop at FRCE, setting the key
     55C8 7700     
18507 55CA 0460  28        b    @FRCE                      ; JMP FRCE          ; "pressed" to red key f9 (so we show the Inventory
     55CC C2B8     
18508                                                                          ; screen)
18509               
18510               * ******************************************************************************
18511               *
18512               * Name: gnum
18513               * Type: Subroutine
18514               * Category: Market
18515               * Summary: Get a number from the keyboard
18516               *
18517               * ------------------------------------------------------------------------------
18518               *
18519               * Get a number from the keyboard, up to the maximum number in QQ25, for the
18520               * buying and selling of cargo and equipment.
18521               *
18522               * Pressing a key with an ASCII code less than ASCII "0" will return a 0 in A (so
18523               * that includes pressing Space or Return), while pressing a key with an ASCII
18524               * code greater than ASCII "9" will jump to the Inventory screen (so that
18525               * includes all letters and most punctuation).
18526               *
18527               * ------------------------------------------------------------------------------
18528               *
18529               * Arguments:
18530               *
18531               * QQ25                The maximum number allowed
18532               *
18533               * ------------------------------------------------------------------------------
18534               *
18535               * Returns:
18536               *
18537               * A                   The number entered
18538               *
18539               * R                   Also contains the number entered
18540               *
18541               * C flag              Set if the number is too large (> QQ25), clear otherwise
18542               *
18543               * ******************************************************************************
18544               
18545               gnum_:
18546 55CE 020E  20        li   rx,>00*256                 ; LDX #0            ; We will build the number entered in R, so initialise
     55D0 0000     
18547 55D2 D80E  30        movb rx,@R                      ; STX R             ; it with 0
     55D4 0091     
18548               
18549 55D6 020E  20        li   rx,>0c*256                 ; LDX #12           ; We will check for up to 12 key presses, so set a
     55D8 0C00     
18550 55DA D80E  30        movb rx,@T1                     ; STX T1            ; counter in T1
     55DC 0006     
18551               
18552               TT223:
18553 55DE 0200  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     55E0 CE00     
18554 55E2 06A0  32        bl   @jsr                       ;
     55E4 FE1E     
18555                                                                          ; the key's ASCII code in A (and X)
18556               
18557 55E6 D80D  30        movb ra,@Q                      ; STA Q             ; Store the key pressed in Q
     55E8 0090     
18558               
18559                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 55EA 0A18  18        sla  rmone,1
                   < elite.a99
18560                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 55EC 1801  14        joc  !
0002 55EE 7347  18        sb   rone,ra
0003               !:
0004 55F0 022D  22        ai   ra,-(('0')*256)
     55F2 D000     
                   < elite.a99
18561               
18562 55F4 172B  14        jnc  OUT                        ; BCC OUT           ; If A < 0, jump to OUT to load the current number and
18563                                                                          ; return from the subroutine, as the key pressed was
18564                                                                          ; RETURN (or some other ncharacter with a value less
18565                                                                          ; than ASCII "0")
18566               
18567 55F6 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to BAY2 to display the Inventory
     55F8 0A00     
18568 55FA 18E5  14        joc  BAY2                       ; BCS BAY2          ; screen, as the key pressed was a letter or other
18569                                                                          ; non-digit and is greater than ASCII "9"
18570               
18571 55FC D80D  30        movb ra,@S                      ; STA S             ; Store the numeric value of the key pressed in S
     55FE 0092     
18572               
18573 5600 D360  30        movb @R,ra                      ; LDA R             ; Fetch the result so far into A
     5602 0091     
18574               
18575 5604 028D  22        ci   ra,>1a*256                 ; CMP #26           ; If A >= 26, where A is the number entered so far, then
     5606 1A00     
18576 5608 1821  14        joc  OUT                        ; BCS OUT           ; adding a further digit will make it bigger than 256,
18577                                                                          ; so jump to OUT to return from the subroutine with the
18578                                                                          ; result in R (i.e. ignore the last key press)
18579               
18580                      .asla                           ; ASL A             ; Set A = (A * 2) + (A * 8) = A * 10
     **** ****     > ASLA
0001 560A 024D  22        andi ra,>ff00
     560C FF00     
0002 560E 0A1D  18        sla  ra,1
                   < elite.a99
18581 5610 D80D  30        movb ra,@T                      ; STA T
     5612 00D1     
18582                      .asla                           ; ASL A
     **** ****     > ASLA
0001 5614 024D  22        andi ra,>ff00
     5616 FF00     
0002 5618 0A1D  18        sla  ra,1
                   < elite.a99
18583                      .asla                           ; ASL A
     **** ****     > ASLA
0001 561A 024D  22        andi ra,>ff00
     561C FF00     
0002 561E 0A1D  18        sla  ra,1
                   < elite.a99
18584                      .adc @T,ra                      ; ADC T
     **** ****     > ADC
0001 5620 1701  14        jnc  !
0002 5622 B347  18        ab   rone,ra
0003               !:
0004 5624 B360  30        ab   @T,ra
     5626 00D1     
                   < elite.a99
18585               
18586                      .adc @S,ra                      ; ADC S             ; Add the pressed digit to A and store in R, so R now
     **** ****     > ADC
0001 5628 1701  14        jnc  !
0002 562A B347  18        ab   rone,ra
0003               !:
0004 562C B360  30        ab   @S,ra
     562E 0092     
                   < elite.a99
18587 5630 D80D  30        movb ra,@R                      ; STA R             ; contains its previous value with the new key press
     5632 0091     
18588                                                                          ; tacked onto the end
18589               
18590 5634 9360  30        cb   @QQ25,ra                   ; CMP QQ25          ; If the result in R = the maximum allowed in QQ25, jump
     5636 0F19     
18591 5638 1301  14        jeq  TT226                      ; BEQ TT226         ; to TT226 to print the key press and keep looping (the
18592                                                                          ; BEQ is needed because the BCS below would jump to OUT
18593                                                                          ; if R >= QQ25, which we don't want)
18594               
18595 563A 1808  14        joc  OUT                        ; BCS OUT           ; If the result in R > QQ25, jump to OUT to return from
18596                                                                          ; the subroutine with the result in R
18597               
18598               TT226:
18599 563C D360  30        movb @Q,ra                      ; LDA Q             ; Print the character in Q (i.e. the key that was
     563E 0090     
18600 5640 0200  20        li   rtmp,TT26                  ; JSR TT26          ; pressed, as we stored the ASCII value in Q earlier)
     5642 3172     
18601 5644 06A0  32        bl   @jsr                       ;
     5646 FE1E     
18602               
18603 5648 7347  18        sb   rone,ra                    ; DEC T1            ; Decrement the loop counter
18604               
18605 564A 16C9  14        jne  TT223                      ; BNE TT223         ; Loop back to TT223 until we have checked for 12 digits
18606               
18607               OUT:
18608 564C D360  30        movb @R,ra                      ; LDA R             ; Set A to the result we have been building in R
     564E 0091     
18609               
18610 5650 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5652 FE2A     
18611               
18612               * ******************************************************************************
18613               *
18614               * Name: TT208
18615               * Type: Subroutine
18616               * Category: Market
18617               * Summary: Show the Sell Cargo screen (red key f2)
18618               *
18619               * ******************************************************************************
18620               
18621               TT208:
18622 5654 020D  20        li   ra,>04*256                 ; LDA #4            ; Clear the top part of the screen, draw a white border,
     5656 0400     
18623 5658 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 4 (Sell
     565A 4B2A     
18624 565C 06A0  32        bl   @jsr                       ;
     565E FE1E     
18625                                                                          ; Cargo screen)
18626               
18627 5660 020D  20        li   ra,>04*256                 ; LDA #4            ; Move the text cursor to row 4, column 4
     5662 0400     
18628 5664 D80D  30        movb ra,@YC                     ; STA YC
     5666 002D     
18629 5668 D80D  30        movb ra,@XC                     ; STA XC
     566A 002C     
18630               
18631               * JSR FLKB               \ This instruction is commented out in the original
18632                                                                          ; source. It calls a routine to flush the keyboard
18633                                                                          ; buffer (FLKB) that isn't present in the cassette
18634                                                                          ; version but is in other versions
18635               
18636 566C 020D  20        li   ra,>cd*256                 ; LDA #205          ; Print recursive token 45 ("SELL")
     566E CD00     
18637 5670 0200  20        li   rtmp,TT27                  ; JSR TT27
     5672 A6E8     
18638 5674 06A0  32        bl   @jsr                       ;
     5676 FE1E     
18639               
18640 5678 020D  20        li   ra,>ce*256                 ; LDA #206          ; Print recursive token 46 (" CARGO{sentence case}")
     567A CE00     
18641 567C 0200  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     567E A6DC     
18642 5680 06A0  32        bl   @jsr                       ;
     5682 FE1E     
18643               
18644                                                                          ; Fall through into TT210 to show the Inventory screen
18645                                                                          ; with the option to sell
18646               
18647               * ******************************************************************************
18648               *
18649               * Name: TT210
18650               * Type: Subroutine
18651               * Category: Market
18652               * Summary: Show a list of current cargo in our hold, optionally to sell
18653               *
18654               * ------------------------------------------------------------------------------
18655               *
18656               * Show a list of current cargo in our hold, either with the ability to sell (the
18657               * Sell Cargo screen) or without (the Inventory screen), depending on the current
18658               * view.
18659               *
18660               * ------------------------------------------------------------------------------
18661               *
18662               * Arguments:
18663               *
18664               * QQ11                The current view:
18665               *
18666               * * 4 = Sell Cargo
18667               *
18668               * * 8 = Inventory
18669               *
18670               * ******************************************************************************
18671               
18672               TT210:
18673 5684 020F  20        li   ry,>00*256                 ; LDY #0            ; We're going to loop through all the available market
     5686 0000     
18674                                                                          ; items and check whether we have any in the hold (and,
18675                                                                          ; if we are in the Sell Cargo screen, whether we want
18676                                                                          ; to sell any items), so we set up a counter in Y to
18677                                                                          ; denote the current item and start it at 0
18678               
18679               TT211:
18680 5688 D80F  30        movb ry,@QQ29                   ; STY QQ29          ; Store the current item number in QQ29
     568A 0F1B     
18681               
18682 568C D3AF  34        movb @QQ20(ry),rx               ; LDX QQ20,Y        ; Fetch into X the amount of the current item that we
     568E 0317     
18683 5690 135E  14        jeq  TT212                      ; BEQ TT212         ; have in our cargo hold, which is stored in QQ20+Y,
18684                                                                          ; and if there are no items of this type in the hold,
18685                                                                          ; jump down to TT212 to skip to the next item
18686               
18687 5692 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y * 4, so this will act as an index into the
18688                      .asla                           ; ASL A             ; market prices table at QQ23 for this item (as there
     **** ****     > ASLA
0001 5694 024D  22        andi ra,>ff00
     5696 FF00     
0002 5698 0A1D  18        sla  ra,1
                   < elite.a99
18689                      .asla                           ; ASL A             ; are four bytes per item in the table)
     **** ****     > ASLA
0001 569A 024D  22        andi ra,>ff00
     569C FF00     
0002 569E 0A1D  18        sla  ra,1
                   < elite.a99
18690 56A0 D3CD  18        movb ra,ry                      ; TAY
18691               
18692 56A2 D36F  34        movb @QQ23+1(ry),ra             ; LDA QQ23+1,Y      ; Fetch byte #1 from the market prices table for the
     56A4 CF2F     
18693 56A6 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; current item and store it in QQ19+1, for use by the
     56A8 0080     
18694                                                                          ; call to TT152 below
18695               
18696 56AA D34E  18        movb rx,ra                      ; TXA               ; Store the amount of item in the hold (in X) on the
18697                      .pha                            ; PHA               ; stack
     **** ****     > PHA
0001 56AC D68D  30        movb ra,*rsp
0002 56AE 060A  14        dec  rsp
                   < elite.a99
18698               
18699 56B0 0200  20        li   rtmp,TT69                  ; JSR TT69          ; Call TT69 to set Sentence Case and print a newline
     56B2 4EDE     
18700 56B4 06A0  32        bl   @jsr                       ;
     56B6 FE1E     
18701               
18702                      .clc                            ; CLC               ; Print recursive token 48 + QQ29, which will be in the
     **** ****     > CLC
0001 56B8 0A16  18        sla  rzero,1
                   < elite.a99
18703 56BA D360  30        movb @QQ29,ra                   ; LDA QQ29          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     56BC 0F1B     
18704                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 56BE 1701  14        jnc  !
0002 56C0 B347  18        ab   rone,ra
0003               !:
0004 56C2 022D  22        ai   ra,(>D0*256)
     56C4 D000     
                   < elite.a99
18705 56C6 0200  20        li   rtmp,TT27                  ; JSR TT27
     56C8 A6E8     
18706 56CA 06A0  32        bl   @jsr                       ;
     56CC FE1E     
18707               
18708 56CE 020D  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the item's
     56D0 0E00     
18709 56D2 D80D  30        movb ra,@XC                     ; STA XC            ; quantity
     56D4 002C     
18710               
18711                      .pla                            ; PLA               ; Restore the amount of item in the hold into X
     **** ****     > PLA
0001 56D6 058A  14        inc  rsp
0002 56D8 D35A  26        movb *rsp,ra
                   < elite.a99
18712 56DA D38D  18        movb ra,rx                      ; TAX
18713               
18714                      .clc                            ; CLC               ; Print the 8-bit number in X to 3 digits, without a
     **** ****     > CLC
0001 56DC 0A16  18        sla  rzero,1
                   < elite.a99
18715 56DE 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; decimal point
     56E0 2FAC     
18716 56E2 06A0  32        bl   @jsr                       ;
     56E4 FE1E     
18717               
18718 56E6 0200  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the market item
     56E8 5E4C     
18719 56EA 06A0  32        bl   @jsr                       ;
     56EC FE1E     
18720                                                                          ; whose byte #1 from the market prices table is in
18721                                                                          ; QQ19+1 (which we set up above)
18722               
18723 56EE D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     56F0 0096     
18724 56F2 028D  22        ci   ra,>04*256                 ; CMP #4            ; screen), jump to TT212 to skip the option to sell
     56F4 0400     
18725 56F6 162B  14        jne  TT212                      ; BNE TT212         ; items
18726               
18727 56F8 020D  20        li   ra,>cd*256                 ; LDA #205          ; Set A to recursive token 45 ("SELL")
     56FA CD00     
18728               
18729 56FC 0200  20        li   rtmp,TT214                 ; JSR TT214         ; Call TT214 to print "Sell(Y/N)?" and return the
     56FE 57C2     
18730 5700 06A0  32        bl   @jsr                       ;
     5702 FE1E     
18731                                                                          ; response in the C flag
18732               
18733 5704 1724  14        jnc  TT212                      ; BCC TT212         ; If the response was "no", jump to TT212 to move on to
18734                                                                          ; the next item
18735               
18736 5706 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; We are selling this item, so fetch the item number
     5708 0F1B     
18737                                                                          ; from QQ29
18738               
18739 570A 020E  20        li   rx,>ff*256                 ; LDX #255          ; Set QQ17 = 255 to disable printing
     570C FF00     
18740 570E D80E  30        movb rx,@QQ17                   ; STX QQ17
     5710 007E     
18741               
18742 5712 0200  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to set QQ24 to the item's price / 4 (the
     5714 5D62     
18743 5716 06A0  32        bl   @jsr                       ;
     5718 FE1E     
18744                                                                          ; routine doesn't print the item details, as we just
18745                                                                          ; disabled printing)
18746               
18747 571A D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set P to the amount of this item we have in our cargo
     571C 0F1B     
18748 571E D36F  34        movb @QQ20(ry),ra               ; LDA QQ20,Y        ; hold (which is the amount to sell)
     5720 0317     
18749 5722 D80D  30        movb ra,@P                      ; STA P
     5724 001B     
18750               
18751 5726 D360  30        movb @QQ24,ra                   ; LDA QQ24          ; Set Q to the item's price / 4
     5728 0F18     
18752 572A D80D  30        movb ra,@Q                      ; STA Q
     572C 0090     
18753               
18754 572E 0200  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate
     5730 A202     
18755 5732 06A0  32        bl   @jsr                       ;
     5734 FE1E     
18756                                                                          ;
18757                                                                          ; (Y X) = P * Q * 4
18758                                                                          ;
18759                                                                          ; which will be the total price we make from this sale
18760                                                                          ; (as P contains the quantity we're selling and Q
18761                                                                          ; contains the item's price / 4)
18762               
18763 5736 0200  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH
     5738 A1BE     
18764 573A 06A0  32        bl   @jsr                       ;
     573C FE1E     
18765               
18766 573E 020D  20        li   ra,>00*256                 ; LDA #0            ; We've made the sale, so set the amount
     5740 0000     
18767 5742 D3E0  30        movb @QQ29,ry                   ; LDY QQ29
     5744 0F1B     
18768 5746 DBCD  38        movb ra,@QQ20(ry)               ; STA QQ20,Y
     5748 0317     
18769               
18770 574A D80D  30        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0, which enables printing again
     574C 007E     
18771               
18772               TT212:
18773 574E D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the item number from QQ29 into Y, and increment
     5750 0F1B     
18774 5752 B3C7  18        ab   rone,ry                    ; INY               ; Y to point to the next item
18775               
18776 5754 028F  22        ci   ry,>11*256                 ; CPY #17           ; If Y >= 17 then skip the next instruction as we have
     5756 1100     
18777 5758 1802  14        joc  B54                        ; BCS B54           ; done the last item
18778               
18779 575A 0460  28        b    @TT211                     ; JMP TT211         ; Otherwise loop back to TT211 to print the next item
     575C 5688     
18780                                                                          ; in the hold
18781               
18782               B54:
18783 575E D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     5760 0096     
18784 5762 028D  22        ci   ra,>04*256                 ; CMP #4            ; screen), skip the next two instructions and just
     5764 0400     
18785 5766 1606  14        jne  B55                        ; BNE B55           ; return from the subroutine
18786               
18787 5768 0200  20        li   rtmp,dn2_                  ; JSR dn2           ; This is the Sell Cargo screen, so call dn2 to make a
     576A A4E8     
18788 576C 06A0  32        bl   @jsr                       ;
     576E FE1E     
18789                                                                          ; short, high beep and delay for 1 second
18790               
18791 5770 0460  28        b    @BAY2                      ; JMP BAY2          ; And then jump to BAY2 to display the Inventory
     5772 55C6     
18792                                                                          ; screen, as we have finished selling cargo
18793               
18794               B55:
18795 5774 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5776 FE2A     
18796               
18797               * ******************************************************************************
18798               *
18799               * Name: TT213
18800               * Type: Subroutine
18801               * Category: Market
18802               * Summary: Show the Inventory screen (red key f9)
18803               *
18804               * ******************************************************************************
18805               
18806               TT213:
18807 5778 020D  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     577A 0800     
18808 577C 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Inventory
     577E 4B2A     
18809 5780 06A0  32        bl   @jsr                       ;
     5782 FE1E     
18810                                                                          ; screen)
18811               
18812 5784 020D  20        li   ra,>0b*256                 ; LDA #11           ; Move the text cursor to column 11 to print the screen
     5786 0B00     
18813 5788 D80D  30        movb ra,@XC                     ; STA XC            ; title
     578A 002C     
18814               
18815 578C 020D  20        li   ra,>a4*256                 ; LDA #164          ; Print recursive token 4 ("INVENTORY{crlf}") followed
     578E A400     
18816 5790 0200  20        li   rtmp,TT60                  ; JSR TT60          ; by a paragraph break and Sentence Case
     5792 4ED4     
18817 5794 06A0  32        bl   @jsr                       ;
     5796 FE1E     
18818               
18819 5798 0200  20        li   rtmp,NLIN4                 ; JSR NLIN4         ; Draw a horizontal line at pixel row 19 to box in the
     579A 25B8     
18820 579C 06A0  32        bl   @jsr                       ;
     579E FE1E     
18821                                                                          ; title. The authors could have used a call to NLIN3
18822                                                                          ; instead and saved the above call to TT60, but you
18823                                                                          ; just can't optimise everything
18824               
18825 57A0 0200  20        li   rtmp,fwl_                  ; JSR fwl           ; Call fwl to print the fuel and cash levels on two
     57A2 A67E     
18826 57A4 06A0  32        bl   @jsr                       ;
     57A6 FE1E     
18827                                                                          ; separate lines
18828               
18829 57A8 D360  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     57AA 0316     
18830 57AC 028D  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     57AE 1A00     
18831 57B0 1706  14        jnc  B56                        ; BCC B56           ; instructions
18832               
18833 57B2 020D  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     57B4 6B00     
18834 57B6 0200  20        li   rtmp,TT27                  ; JSR TT27          ; token 107 ("LARGE CARGO{sentence case} BAY")
     57B8 A6E8     
18835 57BA 06A0  32        bl   @jsr                       ;
     57BC FE1E     
18836               
18837               B56:
18838 57BE 0460  28        b    @TT210                     ; JMP TT210         ; Jump to TT210 to print the contents of our cargo bay
     57C0 5684     
18839                                                                          ; and return from the subroutine using a tail call
18840               
18841               * ******************************************************************************
18842               *
18843               * Name: TT214
18844               * Type: Subroutine
18845               * Category: Keyboard
18846               * Summary: Ask a question with a "Y/N?" prompt and return the response
18847               *
18848               * ------------------------------------------------------------------------------
18849               *
18850               * Arguments:
18851               *
18852               * A                   The text token to print before the "Y/N?" prompt
18853               *
18854               * ------------------------------------------------------------------------------
18855               *
18856               * Returns:
18857               *
18858               * C flag              Set if the response was "yes", clear otherwise
18859               *
18860               * ******************************************************************************
18861               
18862               TT214:
18863                      .pha                            ; PHA               ; Print a space, using the stack to preserve the value
     **** ****     > PHA
0001 57C2 D68D  30        movb ra,*rsp
0002 57C4 060A  14        dec  rsp
                   < elite.a99
18864 57C6 0200  20        li   rtmp,TT162                 ; JSR TT162         ; of A
     57C8 5E64     
18865 57CA 06A0  32        bl   @jsr                       ;
     57CC FE1E     
18866                      .pla                            ; PLA
     **** ****     > PLA
0001 57CE 058A  14        inc  rsp
0002 57D0 D35A  26        movb *rsp,ra
                   < elite.a99
18867               
18868               TT221:
18869 57D2 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     57D4 A6E8     
18870 57D6 06A0  32        bl   @jsr                       ;
     57D8 FE1E     
18871               
18872 57DA 020D  20        li   ra,>e1*256                 ; LDA #225          ; Print recursive token 65 ("(Y/N)?")
     57DC E100     
18873 57DE 0200  20        li   rtmp,TT27                  ; JSR TT27
     57E0 A6E8     
18874 57E2 06A0  32        bl   @jsr                       ;
     57E4 FE1E     
18875               
18876 57E6 0200  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     57E8 CE00     
18877 57EA 06A0  32        bl   @jsr                       ;
     57EC FE1E     
18878                                                                          ; the key's ASCII code in A and X
18879               
18880 57EE 026D  22        ori  ra,>20*256                 ; ORA #%00100000    ; Set bit 5 in the value of the key pressed, which
     57F0 2000     
18881                                                                          ; converts it to lower case
18882               
18883 57F2 028D  22        ci   ra,('y')*256               ; CMP #'y'          ; If "y" was pressed, jump to TT218
     57F4 7900     
18884 57F6 1304  14        jeq  TT218                      ; BEQ TT218
18885               
18886 57F8 020D  20        li   ra,('n')*256               ; LDA #'n'          ; Otherwise jump to TT26 to print "n" and return from
     57FA 6E00     
18887 57FC 0460  28        b    @TT26                      ; JMP TT26          ; the subroutine using a tail call (so all other
     57FE 3172     
18888                                                                          ; responses apart from "y" indicate a no)
18889               
18890               TT218:
18891 5800 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character in A, i.e. print "y"
     5802 3172     
18892 5804 06A0  32        bl   @jsr                       ;
     5806 FE1E     
18893               
18894                      .sec                            ; SEC               ; Set the C flag to indicate a "yes" response
     **** ****     > SEC
0001 5808 0A18  18        sla  rmone,1
                   < elite.a99
18895               
18896 580A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     580C FE2A     
18897               
18898               * ******************************************************************************
18899               *
18900               * Name: TT16
18901               * Type: Subroutine
18902               * Category: Charts
18903               * Summary: Move the crosshairs on a chart
18904               *
18905               * ------------------------------------------------------------------------------
18906               *
18907               * Move the chart crosshairs by the amount in X and Y.
18908               *
18909               * ------------------------------------------------------------------------------
18910               *
18911               * Arguments:
18912               *
18913               * X                   The amount to move the crosshairs in the x-axis
18914               *
18915               * Y                   The amount to move the crosshairs in the y-axis
18916               *
18917               * ******************************************************************************
18918               
18919               TT16:
18920 580E D34E  18        movb rx,ra                      ; TXA               ; Push the change in X onto the stack (let's call this
18921                      .pha                            ; PHA               ; the x-delta)
     **** ****     > PHA
0001 5810 D68D  30        movb ra,*rsp
0002 5812 060A  14        dec  rsp
                   < elite.a99
18922               
18923 5814 73C7  18        sb   rone,ry                    ; DEY               ; Negate the change in Y and push it onto the stack
18924 5816 D34F  18        movb ry,ra                      ; TYA               ; (let's call this the y-delta)
18925                      .eoi (>ff*256)                  ; EOR #&FF
     **** ****     > EOI
0001 5818 0200  20        li   rtmp,(>FF*256)
     581A FF00     
0002 581C 2B40  18        xor  rtmp,ra
                   < elite.a99
18926                      .pha                            ; PHA
     **** ****     > PHA
0001 581E D68D  30        movb ra,*rsp
0002 5820 060A  14        dec  rsp
                   < elite.a99
18927               
18928 5822 0200  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     5824 4DE2     
18929 5826 06A0  32        bl   @jsr                       ;
     5828 FE1E     
18930                                                                          ; screen gets drawn and we can move the crosshairs with
18931                                                                          ; no screen flicker
18932               
18933 582A 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     582C 5872     
18934 582E 06A0  32        bl   @jsr                       ;
     5830 FE1E     
18935                                                                          ; which will erase the crosshairs currently there
18936               
18937                      .pla                            ; PLA               ; Store the y-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 5832 058A  14        inc  rsp
0002 5834 D35A  26        movb *rsp,ra
                   < elite.a99
18938 5836 D80D  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; y-coordinate of the crosshairs from QQ10 into A, ready
     5838 0082     
18939 583A D360  30        movb @QQ10,ra                   ; LDA QQ10          ; for the call to TT123
     583C 0F32     
18940               
18941 583E 0200  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5840 5898     
18942 5842 06A0  32        bl   @jsr                       ;
     5844 FE1E     
18943                                                                          ; y-coordinate by the y-delta, putting the new value in
18944                                                                          ; QQ19+4
18945               
18946 5846 D360  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated y-coordinate in QQ10 (the current
     5848 0083     
18947 584A D80D  30        movb ra,@QQ10                   ; STA QQ10          ; y-coordinate of the crosshairs)
     584C 0F32     
18948               
18949 584E D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; This instruction has no effect, as QQ19+1 is
     5850 0080     
18950                                                                          ; overwritten below, both in TT103 and TT105
18951               
18952                      .pla                            ; PLA               ; Store the x-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 5852 058A  14        inc  rsp
0002 5854 D35A  26        movb *rsp,ra
                   < elite.a99
18953 5856 D80D  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; x-coordinate of the crosshairs from QQ10 into A, ready
     5858 0082     
18954 585A D360  30        movb @QQ9,ra                    ; LDA QQ9           ; for the call to TT123
     585C 0F31     
18955               
18956 585E 0200  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5860 5898     
18957 5862 06A0  32        bl   @jsr                       ;
     5864 FE1E     
18958                                                                          ; x-coordinate by the x-delta, putting the new value in
18959                                                                          ; QQ19+4
18960               
18961 5866 D360  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated x-coordinate in QQ9 (the current
     5868 0083     
18962 586A D80D  30        movb ra,@QQ9                    ; STA QQ9           ; x-coordinate of the crosshairs)
     586C 0F31     
18963               
18964 586E D80D  30        movb ra,@QQ19                   ; STA QQ19          ; This instruction has no effect, as QQ19 is overwritten
     5870 007F     
18965                                                                          ; below, both in TT103 and TT105
18966               
18967                                                                          ; Now we've updated the coordinates of the crosshairs,
18968                                                                          ; fall through into TT103 to redraw them at their new
18969                                                                          ; location
18970               
18971               * ******************************************************************************
18972               *
18973               * Name: TT103
18974               * Type: Subroutine
18975               * Category: Charts
18976               * Summary: Draw a small set of crosshairs on a chart
18977               *
18978               * ------------------------------------------------------------------------------
18979               *
18980               * Draw a small set of crosshairs on a galactic chart at the coordinates in
18981               * (QQ9, QQ10).
18982               *
18983               * ******************************************************************************
18984               
18985               TT103:
18986 5872 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; Fetch the current view type into A
     5874 0096     
18987               
18988 5876 1320  14        jeq  TT180                      ; BEQ TT180         ; If this is a space view, return from the subroutine
18989                                                                          ; (as TT180 contains an RTS), as there are no moveable
18990                                                                          ; crosshairs in space
18991               
18992 5878 1121  14        jlt  TT105                      ; BMI TT105         ; If this is the Short-range Chart screen, jump to TT105
18993               
18994 587A D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Store the crosshairs x-coordinate in QQ19
     587C 0F31     
18995 587E D80D  30        movb ra,@QQ19                   ; STA QQ19
     5880 007F     
18996               
18997 5882 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Halve the crosshairs y-coordinate and store it in QQ19
     5884 0F32     
18998 5886 091D  18        srl  ra,1                       ; LSR A             ; (we halve it because the Long-range Chart is half as
18999 5888 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; high as it is wide)
     588A 0080     
19000               
19001 588C 020D  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to 4 denote crosshairs of size 4
     588E 0400     
19002 5890 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5892 0081     
19003               
19004 5894 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 4 at the
     5896 5316     
19005                                                                          ; crosshairs coordinates, returning from the subroutine
19006                                                                          ; using a tail call
19007               
19008               * ******************************************************************************
19009               *
19010               * Name: TT123
19011               * Type: Subroutine
19012               * Category: Charts
19013               * Summary: Move galactic coordinates by a signed delta
19014               *
19015               * ------------------------------------------------------------------------------
19016               *
19017               * Move an 8-bit galactic coordinate by a certain distance in either direction
19018               * (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
19019               * overflow. The coordinate is in a single axis, so it's either an x-coordinate
19020               * or a y-coordinate.
19021               *
19022               * ------------------------------------------------------------------------------
19023               *
19024               * Arguments:
19025               *
19026               * A                   The galactic coordinate to update
19027               *
19028               * QQ19+3              The delta (can be positive or negative)
19029               *
19030               * ------------------------------------------------------------------------------
19031               *
19032               * Returns:
19033               *
19034               * QQ19+4              The updated coordinate after moving by the delta (this
19035               * will be the same as A if moving by the delta overflows)
19036               *
19037               * ------------------------------------------------------------------------------
19038               *
19039               * Other entry points:
19040               *
19041               * TT180               Contains an RTS
19042               *
19043               * ******************************************************************************
19044               
19045               TT123:
19046 5898 D80D  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the original coordinate in temporary storage at
     589A 0083     
19047                                                                          ; QQ19+4
19048               
19049                      .clc                            ; CLC               ; Set A = A + QQ19+3, so A now contains the original
     **** ****     > CLC
0001 589C 0A16  18        sla  rzero,1
                   < elite.a99
19050                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ; coordinate, moved by the delta
     **** ****     > ADC
0001 589E 1701  14        jnc  !
0002 58A0 B347  18        ab   rone,ra
0003               !:
0004 58A2 B360  30        ab   @QQ19+3,ra
     58A4 0082     
                   < elite.a99
19051               
19052 58A6 D3A0  30        movb @QQ19+3,rx                 ; LDX QQ19+3        ; If the delta is negative, jump to TT124
     58A8 0082     
19053 58AA 1103  14        jlt  TT124                      ; BMI TT124
19054               
19055 58AC 1703  14        jnc  TT125                      ; BCC TT125         ; If the C flag is clear, then the above addition didn't
19056                                                                          ; overflow, so jump to TT125 to return the updated value
19057               
19058 58AE 0460  28        b    @rts                       ; RTS               ; Otherwise the C flag is set and the above addition
     58B0 FE2A     
19059                                                                          ; overflowed, so do not update the return value
19060               
19061               TT124:
19062 58B2 1702  14        jnc  TT180                      ; BCC TT180         ; If the C flag is clear, then because the delta is
19063                                                                          ; negative, this indicates the addition (which is
19064                                                                          ; effectively a subtraction) underflowed, so jump to
19065                                                                          ; TT180 to return from the subroutine without updating
19066                                                                          ; the return value
19067               
19068               TT125:
19069 58B4 D80D  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the updated coordinate in QQ19+4
     58B6 0083     
19070               
19071               TT180:
19072 58B8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     58BA FE2A     
19073               
19074               * ******************************************************************************
19075               *
19076               * Name: TT105
19077               * Type: Subroutine
19078               * Category: Charts
19079               * Summary: Draw crosshairs on the Short-range Chart, with clipping
19080               *
19081               * ------------------------------------------------------------------------------
19082               *
19083               * Check whether the crosshairs are close enough to the current system to appear
19084               * on the Short-range Chart, and if so, draw them.
19085               *
19086               * ******************************************************************************
19087               
19088               TT105:
19089 58BC D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Set A = QQ9 - QQ0, the horizontal distance between the
     58BE 0F31     
19090                      .sec                            ; SEC               ; crosshairs (QQ9) and the current system (QQ0)
     **** ****     > SEC
0001 58C0 0A18  18        sla  rmone,1
                   < elite.a99
19091                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 58C2 1801  14        joc  !
0002 58C4 7347  18        sb   rone,ra
0003               !:
0004 58C6 7360  30        sb   @QQ0,ra
     58C8 0301     
                   < elite.a99
19092               
19093 58CA 028D  22        ci   ra,>26*256                 ; CMP #38           ; If the horizontal distance in A < 38, then the
     58CC 2600     
19094 58CE 1703  14        jnc  TT179                      ; BCC TT179         ; crosshairs are close enough to the current system to
19095                                                                          ; appear in the Short-range Chart, so jump to TT179 to
19096                                                                          ; check the vertical distance
19097               
19098 58D0 028D  22        ci   ra,>e6*256                 ; CMP #230          ; If the horizontal distance in A < -26, then the
     58D2 E600     
19099 58D4 17F1  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19100                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19101                                                                          ; return from the subroutine (as TT180 contains an RTS)
19102               
19103               TT179:
19104                      .asla                           ; ASL A             ; Set QQ19 = 104 + A * 4
     **** ****     > ASLA
0001 58D6 024D  22        andi ra,>ff00
     58D8 FF00     
0002 58DA 0A1D  18        sla  ra,1
                   < elite.a99
19105                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 58DC 024D  22        andi ra,>ff00
     58DE FF00     
0002 58E0 0A1D  18        sla  ra,1
                   < elite.a99
19106                      .clc                            ; CLC               ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > CLC
0001 58E2 0A16  18        sla  rzero,1
                   < elite.a99
19107                      .adi (>68*256)                  ; ADC #104          ; so this sets QQ19 to the screen pixel x-coordinate
     **** ****     > ADI
0001 58E4 1701  14        jnc  !
0002 58E6 B347  18        ab   rone,ra
0003               !:
0004 58E8 022D  22        ai   ra,(>68*256)
     58EA 6800     
                   < elite.a99
19108 58EC D80D  30        movb ra,@QQ19                   ; STA QQ19          ; of the crosshairs
     58EE 007F     
19109               
19110 58F0 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     58F2 0F32     
19111                      .sec                            ; SEC               ; crosshairs (QQ10) and the current system (QQ1)
     **** ****     > SEC
0001 58F4 0A18  18        sla  rmone,1
                   < elite.a99
19112                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 58F6 1801  14        joc  !
0002 58F8 7347  18        sb   rone,ra
0003               !:
0004 58FA 7360  30        sb   @QQ1,ra
     58FC 0302     
                   < elite.a99
19113               
19114 58FE 028D  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is < 38, then the
     5900 2600     
19115 5902 1703  14        jnc  B57                        ; BCC B57           ; crosshairs are close enough to the current system to
19116                                                                          ; appear in the Short-range Chart, so skip the next two
19117                                                                          ; instructions
19118               
19119 5904 028D  22        ci   ra,>dc*256                 ; CMP #220          ; If the horizontal distance in A is < -36, then the
     5906 DC00     
19120 5908 17D7  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19121                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19122                                                                          ; return from the subroutine (as TT180 contains an RTS)
19123               
19124               B57:
19125                      .asla                           ; ASL A             ; Set QQ19+1 = 90 + A * 2
     **** ****     > ASLA
0001 590A 024D  22        andi ra,>ff00
     590C FF00     
0002 590E 0A1D  18        sla  ra,1
                   < elite.a99
19126                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 5910 0A16  18        sla  rzero,1
                   < elite.a99
19127                      .adi (>5a*256)                  ; ADC #90           ; 90 is the y-coordinate of the centre of the chart,
     **** ****     > ADI
0001 5912 1701  14        jnc  !
0002 5914 B347  18        ab   rone,ra
0003               !:
0004 5916 022D  22        ai   ra,(>5A*256)
     5918 5A00     
                   < elite.a99
19128 591A D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; so this sets QQ19+1 to the screen pixel x-coordinate
     591C 0080     
19129                                                                          ; of the crosshairs
19130               
19131 591E 020D  20        li   ra,>08*256                 ; LDA #8            ; Set QQ19+2 to 8 denote crosshairs of size 8
     5920 0800     
19132 5922 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5924 0081     
19133               
19134 5926 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 8 at the
     5928 5316     
19135                                                                          ; crosshairs coordinates, returning from the subroutine
19136                                                                          ; using a tail call
19137               
19138               * ******************************************************************************
19139               *
19140               * Name: TT23
19141               * Type: Subroutine
19142               * Category: Charts
19143               * Summary: Show the Short-range Chart (red key f5)
19144               *
19145               * ******************************************************************************
19146               
19147               TT23:
19148 592A 020D  20        li   ra,>80*256                 ; LDA #128          ; Clear the top part of the screen, draw a white border,
     592C 8000     
19149 592E 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 128 (Short-
     5930 4B2A     
19150 5932 06A0  32        bl   @jsr                       ;
     5934 FE1E     
19151                                                                          ; range Chart)
19152               
19153 5936 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     5938 0700     
19154 593A D80D  30        movb ra,@XC                     ; STA XC
     593C 002C     
19155               
19156 593E 020D  20        li   ra,>be*256                 ; LDA #190          ; Print recursive token 30 ("SHORT RANGE CHART") and
     5940 BE00     
19157 5942 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; draw a horizontal line at pixel row 19 to box in the
     5944 25B0     
19158 5946 06A0  32        bl   @jsr                       ;
     5948 FE1E     
19159                                                                          ; title
19160               
19161 594A 0200  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     594C 53FA     
19162 594E 06A0  32        bl   @jsr                       ;
     5950 FE1E     
19163                                                                          ; current system's galactic coordinates
19164               
19165 5952 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     5954 5872     
19166 5956 06A0  32        bl   @jsr                       ;
     5958 FE1E     
19167                                                                          ; i.e. at the selected system
19168               
19169 595A 0200  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     595C 5AA4     
19170 595E 06A0  32        bl   @jsr                       ;
     5960 FE1E     
19171                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19172               
19173 5962 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, which we'll use below to zero out the INWK
     5964 0000     
19174                                                                          ; workspace
19175               
19176 5966 D80D  30        movb ra,@XX20                   ; STA XX20          ; We're about to start working our way through each of
     5968 00A8     
19177                                                                          ; the galaxy's systems, so set up a counter in XX20 for
19178                                                                          ; each system, starting at 0 and looping through to 255
19179               
19180 596A 020E  20        li   rx,>18*256                 ; LDX #24           ; First, though, we need to zero out the 25 bytes at
     596C 1800     
19181                                                                          ; INWK so we can use them to work out which systems have
19182                                                                          ; room for a label, so set a counter in X for 25 bytes
19183               
19184               EE3:
19185 596E DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X        ; Set the X-th byte of INWK to zero
     5970 0053     
19186               
19187 5972 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19188               
19189 5974 15FC  14        jgt  EE3                        ; BPL EE3           ; Loop back to EE3 for the next byte until we've zeroed
19190                                                                          ; all 25 bytes
19191               
19192                                                                          ; We now loop through every single system in the galaxy
19193                                                                          ; and check the distance from the current system whose
19194                                                                          ; coordinates are in (QQ0, QQ1). We get the galactic
19195                                                                          ; coordinates of each system from the system's seeds,
19196                                                                          ; like this:
19197                                                                          ;
19198                                                                          ; x = s1_hi (which is stored in QQ15+3)
19199                                                                          ; y = s0_hi (which is stored in QQ15+1)
19200                                                                          ;
19201                                                                          ; so the following loops through each system in the
19202                                                                          ; galaxy in turn and calculates the distance between
19203                                                                          ; (QQ0, QQ1) and (s1_hi, s0_hi) to find the closest one
19204               
19205               TT182:
19206 5976 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     5978 007B     
19207                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 597A 0A18  18        sla  rmone,1
                   < elite.a99
19208                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 597C 1801  14        joc  !
0002 597E 7347  18        sb   rone,ra
0003               !:
0004 5980 7360  30        sb   @QQ0,ra
     5982 0301     
                   < elite.a99
19209               
19210 5984 1807  14        joc  TT184                      ; BCS TT184         ; If a borrow didn't occur, i.e. s1_hi >= QQ0, then the
19211                                                                          ; result is positive, so jump to TT184 and skip the
19212                                                                          ; following two instructions
19213               
19214                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5986 0200  20        li   rtmp,(>FF*256)
     5988 FF00     
0002 598A 2B40  18        xor  rtmp,ra
                   < elite.a99
19215                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ0|)
     **** ****     > ADI
0001 598C 1701  14        jnc  !
0002 598E B347  18        ab   rone,ra
0003               !:
0004 5990 022D  22        ai   ra,(>01*256)
     5992 0100     
                   < elite.a99
19216               
19217               TT184:
19218 5994 028D  22        ci   ra,>14*256                 ; CMP #20           ; If the horizontal distance in A is >= 20, then this
     5996 1400     
19219 5998 187D  14        joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
19220                                                                          ; appear in the Short-range Chart, so jump to TT187 to
19221                                                                          ; move on to the next system
19222               
19223 599A D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     599C 0079     
19224                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 599E 0A18  18        sla  rmone,1
                   < elite.a99
19225                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 59A0 1801  14        joc  !
0002 59A2 7347  18        sb   rone,ra
0003               !:
0004 59A4 7360  30        sb   @QQ1,ra
     59A6 0302     
                   < elite.a99
19226               
19227 59A8 1807  14        joc  TT186                      ; BCS TT186         ; If a borrow didn't occur, i.e. s0_hi >= QQ1, then the
19228                                                                          ; result is positive, so jump to TT186 and skip the
19229                                                                          ; following two instructions
19230               
19231                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 59AA 0200  20        li   rtmp,(>FF*256)
     59AC FF00     
0002 59AE 2B40  18        xor  rtmp,ra
                   < elite.a99
19232                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ1|)
     **** ****     > ADI
0001 59B0 1701  14        jnc  !
0002 59B2 B347  18        ab   rone,ra
0003               !:
0004 59B4 022D  22        ai   ra,(>01*256)
     59B6 0100     
                   < elite.a99
19233               
19234               TT186:
19235 59B8 028D  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is >= 38, then this
     59BA 2600     
19236 59BC 186B  14        joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
19237                                                                          ; appear in the Short-range Chart, so jump to TT187 to
19238                                                                          ; move on to the next system
19239               
19240                                                                          ; This system should be shown on the Short-range Chart,
19241                                                                          ; so now we need to work out where the label should go,
19242                                                                          ; and set up the various variables we need to draw the
19243                                                                          ; system's filled circle on the chart
19244               
19245 59BE D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     59C0 007B     
19246                      .sec                            ; SEC               ; this system and the current system, where |A| < 20.
     **** ****     > SEC
0001 59C2 0A18  18        sla  rmone,1
                   < elite.a99
19247                      .sbc @QQ0,ra                    ; SBC QQ0           ; Let's call this the x-delta, as it's the horizontal
     **** ****     > SBC
0001 59C4 1801  14        joc  !
0002 59C6 7347  18        sb   rone,ra
0003               !:
0004 59C8 7360  30        sb   @QQ0,ra
     59CA 0301     
                   < elite.a99
19248                                                                          ; difference between the current system at the centre of
19249                                                                          ; the chart, and this system (and this time we keep the
19250                                                                          ; sign of A, so it can be negative if it's to the left
19251                                                                          ; of the chart's centre, or positive if it's to the
19252                                                                          ; right)
19253               
19254                      .asla                           ; ASL A             ; Set XX12 = 104 + x-delta * 4
     **** ****     > ASLA
0001 59CC 024D  22        andi ra,>ff00
     59CE FF00     
0002 59D0 0A1D  18        sla  ra,1
                   < elite.a99
19255                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 59D2 024D  22        andi ra,>ff00
     59D4 FF00     
0002 59D6 0A1D  18        sla  ra,1
                   < elite.a99
19256                      .adi (>68*256)                  ; ADC #104          ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > ADI
0001 59D8 1701  14        jnc  !
0002 59DA B347  18        ab   rone,ra
0003               !:
0004 59DC 022D  22        ai   ra,(>68*256)
     59DE 6800     
                   < elite.a99
19257 59E0 D80D  30        movb ra,@XX12                   ; STA XX12          ; so this sets XX12 to the centre 104 +/- 76, the pixel
     59E2 0037     
19258                                                                          ; x-coordinate of this system
19259               
19260 59E4 091D  18        srl  ra,1                       ; LSR A             ; Move the text cursor to column x-delta / 2 + 1
19261 59E6 091D  18        srl  ra,1                       ; LSR A             ; which will be in the range 1-10
19262 59E8 091D  18        srl  ra,1                       ; LSR A
19263 59EA D80D  30        movb ra,@XC                     ; STA XC
     59EC 002C     
19264 59EE B347  18        ab   rone,ra                    ; INC XC
19265               
19266 59F0 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     59F2 0079     
19267                      .sec                            ; SEC               ; this system and the current system, where |A| < 38.
     **** ****     > SEC
0001 59F4 0A18  18        sla  rmone,1
                   < elite.a99
19268                      .sbc @QQ1,ra                    ; SBC QQ1           ; Let's call this the y-delta, as it's the vertical
     **** ****     > SBC
0001 59F6 1801  14        joc  !
0002 59F8 7347  18        sb   rone,ra
0003               !:
0004 59FA 7360  30        sb   @QQ1,ra
     59FC 0302     
                   < elite.a99
19269                                                                          ; difference between the current system at the centre of
19270                                                                          ; the chart, and this system (and this time we keep the
19271                                                                          ; sign of A, so it can be negative if it's above the
19272                                                                          ; chart's centre, or positive if it's below)
19273               
19274                      .asla                           ; ASL A             ; Set K4 = 90 + y-delta * 2
     **** ****     > ASLA
0001 59FE 024D  22        andi ra,>ff00
     5A00 FF00     
0002 5A02 0A1D  18        sla  ra,1
                   < elite.a99
19275                      .adi (>5a*256)                  ; ADC #90           ;
     **** ****     > ADI
0001 5A04 1701  14        jnc  !
0002 5A06 B347  18        ab   rone,ra
0003               !:
0004 5A08 022D  22        ai   ra,(>5A*256)
     5A0A 5A00     
                   < elite.a99
19276 5A0C D80D  30        movb ra,@K4                     ; STA K4            ; 90 is the y-coordinate of the centre of the chart,
     5A0E 00E0     
19277                                                                          ; so this sets K4 to the centre 90 +/- 74, the pixel
19278                                                                          ; y-coordinate of this system
19279               
19280 5A10 091D  18        srl  ra,1                       ; LSR A             ; Set Y = K4 / 8, so Y contains the number of the text
19281 5A12 091D  18        srl  ra,1                       ; LSR A             ; row that contains this system
19282 5A14 091D  18        srl  ra,1                       ; LSR A
19283 5A16 D3CD  18        movb ra,ry                      ; TAY
19284               
19285                                                                          ; Now to see if there is room for this system's label.
19286                                                                          ; Ideally we would print the system name on the same
19287                                                                          ; text row as the system, but we only want to print one
19288                                                                          ; label per row, to prevent overlap, so now we check
19289                                                                          ; this system's row, and if that's already occupied,
19290                                                                          ; the row above, and if that's already occupied, the
19291                                                                          ; row below... and if that's already occupied, we give
19292                                                                          ; up and don't print a label for this system
19293               
19294 5A18 D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; If the value in INWK+Y is 0 (i.e. the text row
     5A1A 0053     
19295 5A1C 1309  14        jeq  EE4                        ; BEQ EE4           ; containing this system does not already have another
19296                                                                          ; system's label on it), jump to EE4 to store this
19297                                                                          ; system's label on this row
19298               
19299 5A1E B3C7  18        ab   rone,ry                    ; INY               ; If the value in INWK+Y+1 is 0 (i.e. the text row below
19300 5A20 D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; the one containing this system does not already have
     5A22 0053     
19301 5A24 1305  14        jeq  EE4                        ; BEQ EE4           ; another system's label on it), jump to EE4 to store
19302                                                                          ; this system's label on this row
19303               
19304 5A26 73C7  18        sb   rone,ry                    ; DEY               ; If the value in INWK+Y-1 is 0 (i.e. the text row above
19305 5A28 73C7  18        sb   rone,ry                    ; DEY               ; the one containing this system does not already have
19306 5A2A D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; another system's label on it), fall through into to
     5A2C 0053     
19307 5A2E 1610  14        jne  ee1_                       ; BNE ee1           ; EE4 to store this system's label on this row,
19308                                                                          ; otherwise jump to ee1 to skip printing a label for
19309                                                                          ; this system (as there simply isn't room)
19310               
19311               EE4:
19312 5A30 D80F  30        movb ry,@YC                     ; STY YC            ; Now to print the label, so move the text cursor to row
     5A32 002D     
19313                                                                          ; Y (which contains the row where we can print this
19314                                                                          ; system's label)
19315               
19316 5A34 028F  22        ci   ry,>03*256                 ; CPY #3            ; If Y < 3, then the system would clash with the chart
     5A36 0300     
19317 5A38 172D  14        jnc  TT187                      ; BCC TT187         ; title, so jump to TT187 to skip showing the system
19318               
19319 5A3A 7387  18        sb   rone,rx                    ; DEX               ; We entered the EE4 routine with X = 0, so this stores
19320 5A3C DBCE  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; &FF in INWK+Y, to denote that this row is now occupied
     5A3E 0053     
19321                                                                          ; so we don't try to print another system's label on
19322                                                                          ; this row
19323               
19324 5A40 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     5A42 8000     
19325 5A44 D80D  30        movb ra,@QQ17                   ; STA QQ17
     5A46 007E     
19326               
19327 5A48 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     5A4A A5C4     
19328 5A4C 06A0  32        bl   @jsr                       ;
     5A4E FE1E     
19329                                                                          ; in QQ15 (which now contains the seeds for the current
19330                                                                          ; system)
19331               
19332               ee1_:
19333 5A50 020D  20        li   ra,>00*256                 ; LDA #0            ; Now to plot the star, so set the high bytes of K, K3
     5A52 0000     
19334 5A54 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; and K4 to 0
     5A56 00D3     
19335 5A58 D80D  30        movb ra,@K4+1                   ; STA K4+1
     5A5A 00E1     
19336 5A5C D80D  30        movb ra,@K+1                    ; STA K+1
     5A5E 003E     
19337               
19338 5A60 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set the low byte of K3 to XX12, the pixel x-coordinate
     5A62 0037     
19339 5A64 D80D  30        movb ra,@K3                     ; STA K3            ; of this system
     5A66 00D2     
19340               
19341 5A68 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi for this system from QQ15+5, extract bit 0
     5A6A 007D     
19342 5A6C 024D  22        andi ra,>01*256                 ; AND #1            ; and add 2 to get the size of the star, which we store
     5A6E 0100     
19343                      .adi (>02*256)                  ; ADC #2            ; in K. This will be either 2, 3 or 4, depending on the
     **** ****     > ADI
0001 5A70 1701  14        jnc  !
0002 5A72 B347  18        ab   rone,ra
0003               !:
0004 5A74 022D  22        ai   ra,(>02*256)
     5A76 0200     
                   < elite.a99
19344 5A78 D80D  30        movb ra,@K                      ; STA K             ; value of bit 0, and whether the C flag is set (which
     5A7A 003D     
19345                                                                          ; will vary depending on what happens in the above call
19346                                                                          ; to cpl). Incidentally, the planet's average radius
19347                                                                          ; also uses s2_hi, bits 0-3 to be precise, but that
19348                                                                          ; doesn't mean the two sizes affect each other
19349               
19350                                                                          ; We now have the following:
19351                                                                          ;
19352                                                                          ; K(1 0)  = radius of star (2, 3 or 4)
19353                                                                          ;
19354                                                                          ; K3(1 0) = pixel x-coordinate of system
19355                                                                          ;
19356                                                                          ; K4(1 0) = pixel y-coordinate of system
19357                                                                          ;
19358                                                                          ; which we can now pass to the SUN routine to draw a
19359                                                                          ; small "sun" on the Short-range Chart for this system
19360               
19361 5A7C 0200  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5A7E ACA6     
19362 5A80 06A0  32        bl   @jsr                       ;
     5A82 FE1E     
19363               
19364 5A84 0200  20        li   rtmp,SUN                   ; JSR SUN           ; Call SUN to plot a sun with radius K at pixel
     5A86 B5C4     
19365 5A88 06A0  32        bl   @jsr                       ;
     5A8A FE1E     
19366                                                                          ; coordinate (K3, K4)
19367               
19368 5A8C 0200  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5A8E ACA6     
19369 5A90 06A0  32        bl   @jsr                       ;
     5A92 FE1E     
19370               
19371               TT187:
19372 5A94 0200  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     5A96 4E32     
19373 5A98 06A0  32        bl   @jsr                       ;
     5A9A FE1E     
19374                                                                          ; to twist the three 16-bit seeds in QQ15
19375               
19376 5A9C B347  18        ab   rone,ra                    ; INC XX20          ; Increment the counter
19377               
19378 5A9E 130B  14        jeq  TT111-1                    ; BEQ TT111-1       ; If X = 0 then we have done all 256 systems, so return
19379                                                                          ; from the subroutine (as TT111-1 contains an RTS)
19380               
19381 5AA0 0460  28        b    @TT182                     ; JMP TT182         ; Otherwise jump back up to TT182 to process the next
     5AA2 5976     
19382                                                                          ; system
19383               
19384               * ******************************************************************************
19385               *
19386               * Name: TT81
19387               * Type: Subroutine
19388               * Category: Universe
19389               * Summary: Set the selected system's seeds to those of system 0
19390               *
19391               * ------------------------------------------------------------------------------
19392               *
19393               * Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
19394               * seeds for the selected system (QQ15) - in other words, set the selected
19395               * system's seeds to those of system 0.
19396               *
19397               * ******************************************************************************
19398               
19399               TT81:
19400 5AA4 020E  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X to copy six bytes (for three
     5AA6 0500     
19401                                                                          ; 16-bit numbers)
19402               
19403 5AA8 D36E  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Copy the X-th byte in QQ21 to the X-th byte in QQ15
     5AAA 0303     
19404 5AAC DB8D  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     5AAE 0078     
19405               
19406 5AB0 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19407               
19408 5AB2 15F9  14        jgt  TT81+2                     ; BPL TT81+2        ; Loop back up to the LDA instruction if we still have
19409                                                                          ; more bytes to copy
19410               
19411 5AB4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5AB6 FE2A     
19412               
19413               * ******************************************************************************
19414               *
19415               * Name: TT111
19416               * Type: Subroutine
19417               * Category: Universe
19418               * Summary: Set the current system to the nearest system to a point
19419               *
19420               * ------------------------------------------------------------------------------
19421               *
19422               * Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
19423               * to this point in the galaxy, and set this as the currently selected system.
19424               *
19425               * ------------------------------------------------------------------------------
19426               *
19427               * Arguments:
19428               *
19429               * QQ9                 The x-coordinate near which we want to find a system
19430               *
19431               * QQ10                The y-coordinate near which we want to find a system
19432               *
19433               * ------------------------------------------------------------------------------
19434               *
19435               * Returns:
19436               *
19437               * QQ8(1 0)            The distance from the current system to the nearest
19438               * system to the original coordinates
19439               *
19440               * QQ9                 The x-coordinate of the nearest system to the original
19441               * coordinates
19442               *
19443               * QQ10                The y-coordinate of the nearest system to the original
19444               * coordinates
19445               *
19446               * QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
19447               * original coordinates
19448               *
19449               * ------------------------------------------------------------------------------
19450               *
19451               * Other entry points:
19452               *
19453               * TT111-1             Contains an RTS
19454               *
19455               * ******************************************************************************
19456               
19457               TT111:
19458 5AB8 0200  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5ABA 5AA4     
19459 5ABC 06A0  32        bl   @jsr                       ;
     5ABE FE1E     
19460                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19461               
19462                                                                          ; We now loop through every single system in the galaxy
19463                                                                          ; and check the distance from (QQ9, QQ10). We get the
19464                                                                          ; galactic coordinates of each system from the system's
19465                                                                          ; seeds, like this:
19466                                                                          ;
19467                                                                          ; x = s1_hi (which is stored in QQ15+3)
19468                                                                          ; y = s0_hi (which is stored in QQ15+1)
19469                                                                          ;
19470                                                                          ; so the following loops through each system in the
19471                                                                          ; galaxy in turn and calculates the distance between
19472                                                                          ; (QQ9, QQ10) and (s1_hi, s0_hi) to find the closest one
19473               
19474 5AC0 020F  20        li   ry,>7f*256                 ; LDY #127          ; Set Y = T = 127 to hold the shortest distance we've
     5AC2 7F00     
19475 5AC4 D80F  30        movb ry,@T                      ; STY T             ; found so far, which we initially set to half the
     5AC6 00D1     
19476                                                                          ; distance across the galaxy, or 127, as our coordinate
19477                                                                          ; system ranges from (0,0) to (255, 255)
19478               
19479 5AC8 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = U = 0 to act as a counter for each system in
     5ACA 0000     
19480 5ACC D80D  30        movb ra,@U                      ; STA U             ; the current galaxy, which we start at system 0 and
     5ACE 008F     
19481                                                                          ; loop through to 255, the last system
19482               
19483               TT130:
19484 5AD0 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ9, the horizontal distance between
     5AD2 007B     
19485                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 5AD4 0A18  18        sla  rmone,1
                   < elite.a99
19486                      .sbc @QQ9,ra                    ; SBC QQ9
     **** ****     > SBC
0001 5AD6 1801  14        joc  !
0002 5AD8 7347  18        sb   rone,ra
0003               !:
0004 5ADA 7360  30        sb   @QQ9,ra
     5ADC 0F31     
                   < elite.a99
19487               
19488 5ADE 1807  14        joc  TT132                      ; BCS TT132         ; If a borrow didn't occur, i.e. s1_hi >= QQ9, then the
19489                                                                          ; result is positive, so jump to TT132 and skip the
19490                                                                          ; following two instructions
19491               
19492                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5AE0 0200  20        li   rtmp,(>FF*256)
     5AE2 FF00     
0002 5AE4 2B40  18        xor  rtmp,ra
                   < elite.a99
19493                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ9|)
     **** ****     > ADI
0001 5AE6 1701  14        jnc  !
0002 5AE8 B347  18        ab   rone,ra
0003               !:
0004 5AEA 022D  22        ai   ra,(>01*256)
     5AEC 0100     
                   < elite.a99
19494               
19495               TT132:
19496 5AEE 091D  18        srl  ra,1                       ; LSR A             ; Set S = A / 2
19497 5AF0 D80D  30        movb ra,@S                      ; STA S             ; = |s1_hi - QQ9| / 2
     5AF2 0092     
19498               
19499 5AF4 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ10, the vertical distance between
     5AF6 0079     
19500                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 5AF8 0A18  18        sla  rmone,1
                   < elite.a99
19501                      .sbc @QQ10,ra                   ; SBC QQ10
     **** ****     > SBC
0001 5AFA 1801  14        joc  !
0002 5AFC 7347  18        sb   rone,ra
0003               !:
0004 5AFE 7360  30        sb   @QQ10,ra
     5B00 0F32     
                   < elite.a99
19502               
19503 5B02 1807  14        joc  TT134                      ; BCS TT134         ; If a borrow didn't occur, i.e. s0_hi >= QQ10, then the
19504                                                                          ; result is positive, so jump to TT134 and skip the
19505                                                                          ; following two instructions
19506               
19507                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5B04 0200  20        li   rtmp,(>FF*256)
     5B06 FF00     
0002 5B08 2B40  18        xor  rtmp,ra
                   < elite.a99
19508                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ10|)
     **** ****     > ADI
0001 5B0A 1701  14        jnc  !
0002 5B0C B347  18        ab   rone,ra
0003               !:
0004 5B0E 022D  22        ai   ra,(>01*256)
     5B10 0100     
                   < elite.a99
19509               
19510               TT134:
19511 5B12 091D  18        srl  ra,1                       ; LSR A             ; Set A = S + A / 2
19512                      .clc                            ; CLC               ; = |s1_hi - QQ9| / 2 + |s0_hi - QQ10| / 2
     **** ****     > CLC
0001 5B14 0A16  18        sla  rzero,1
                   < elite.a99
19513                      .adc @S,ra                      ; ADC S             ;
     **** ****     > ADC
0001 5B16 1701  14        jnc  !
0002 5B18 B347  18        ab   rone,ra
0003               !:
0004 5B1A B360  30        ab   @S,ra
     5B1C 0092     
                   < elite.a99
19514                                                                          ; So A now contains the sum of the horizontal and
19515                                                                          ; vertical distances, both divided by 2 so the result
19516                                                                          ; fits into one byte, and although this doesn't contain
19517                                                                          ; the actual distance between the systems, it's a good
19518                                                                          ; enough approximation to use for comparing distances
19519               
19520 5B1E 9360  30        cb   @T,ra                      ; CMP T             ; If A >= T, then this system's distance is bigger than
     5B20 00D1     
19521 5B22 180A  14        joc  TT135                      ; BCS TT135         ; our "minimum distance so far" stored in T, so it's no
19522                                                                          ; closer than the systems we have already found, so
19523                                                                          ; skip to TT135 to move on to the next system
19524               
19525 5B24 D80D  30        movb ra,@T                      ; STA T             ; This system is the closest to (QQ9, QQ10) so far, so
     5B26 00D1     
19526                                                                          ; update T with the new "distance" approximation
19527               
19528 5B28 020E  20        li   rx,>05*256                 ; LDX #5            ; As this system is the closest we have found yet, we
     5B2A 0500     
19529                                                                          ; want to store the system's seeds in case it ends up
19530                                                                          ; being the closest of all, so we set up a counter in X
19531                                                                          ; to copy six bytes (for three 16-bit numbers)
19532               
19533               TT136:
19534 5B2C D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ19,
     5B2E 0078     
19535 5B30 DB8D  38        movb ra,@QQ19(rx)               ; STA QQ19,X        ; where QQ15 contains the seeds for the system we just
     5B32 007F     
19536                                                                          ; found to be the closest so far, and QQ19 is temporary
19537                                                                          ; storage
19538               
19539 5B34 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19540               
19541 5B36 15FA  14        jgt  TT136                      ; BPL TT136         ; Loop back to TT136 if we still have more bytes to
19542                                                                          ; copy
19543               
19544               TT135:
19545 5B38 0200  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     5B3A 4E32     
19546 5B3C 06A0  32        bl   @jsr                       ;
     5B3E FE1E     
19547                                                                          ; to twist the three 16-bit seeds in QQ15
19548               
19549 5B40 B347  18        ab   rone,ra                    ; INC U             ; Increment the system counter in U
19550               
19551 5B42 16C6  14        jne  TT130                      ; BNE TT130         ; If U > 0 then we haven't done all 256 systems yet, so
19552                                                                          ; loop back up to TT130
19553               
19554                                                                          ; We have now finished checking all the systems in the
19555                                                                          ; galaxy, and the seeds for the closest system are in
19556                                                                          ; QQ19, so now we want to copy these seeds to QQ15,
19557                                                                          ; to set the selected system to this closest system
19558               
19559 5B44 020E  20        li   rx,>05*256                 ; LDX #5            ; So we set up a counter in X to copy six bytes (for
     5B46 0500     
19560                                                                          ; three 16-bit numbers)
19561               
19562               TT137:
19563 5B48 D36E  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy the X-th byte in QQ19 to the X-th byte in QQ15
     5B4A 007F     
19564 5B4C DB8D  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     5B4E 0078     
19565               
19566 5B50 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19567               
19568 5B52 15FA  14        jgt  TT137                      ; BPL TT137         ; Loop back to TT137 if we still have more bytes to
19569                                                                          ; copy
19570               
19571 5B54 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; The y-coordinate of the system described by the seeds
     5B56 0079     
19572 5B58 D80D  30        movb ra,@QQ10                   ; STA QQ10          ; in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
     5B5A 0F32     
19573                                                                          ; as this is where we store the selected system's
19574                                                                          ; y-coordinate
19575               
19576 5B5C D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; The x-coordinate of the system described by the seeds
     5B5E 007B     
19577 5B60 D80D  30        movb ra,@QQ9                    ; STA QQ9           ; in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
     5B62 0F31     
19578                                                                          ; as this is where we store the selected system's
19579                                                                          ; x-coordinate
19580               
19581                                                                          ; We have now found the closest system to (QQ9, QQ10)
19582                                                                          ; and have set it as the selected system, so now we
19583                                                                          ; need to work out the distance between the selected
19584                                                                          ; system and the current system
19585               
19586                      .sec                            ; SEC               ; Set A = QQ9 - QQ0, the horizontal distance between
     **** ****     > SEC
0001 5B64 0A18  18        sla  rmone,1
                   < elite.a99
19587                      .sbc @QQ0,ra                    ; SBC QQ0           ; the selected system's x-coordinate (QQ9) and the
     **** ****     > SBC
0001 5B66 1801  14        joc  !
0002 5B68 7347  18        sb   rone,ra
0003               !:
0004 5B6A 7360  30        sb   @QQ0,ra
     5B6C 0301     
                   < elite.a99
19588                                                                          ; current system's x-coordinate (QQ0)
19589               
19590 5B6E 1807  14        joc  TT139                      ; BCS TT139         ; If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
19591                                                                          ; result is positive, so jump to TT139 and skip the
19592                                                                          ; following two instructions
19593               
19594                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5B70 0200  20        li   rtmp,(>FF*256)
     5B72 FF00     
0002 5B74 2B40  18        xor  rtmp,ra
                   < elite.a99
19595                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ9 - QQ0|)
     **** ****     > ADI
0001 5B76 1701  14        jnc  !
0002 5B78 B347  18        ab   rone,ra
0003               !:
0004 5B7A 022D  22        ai   ra,(>01*256)
     5B7C 0100     
                   < elite.a99
19596               
19597                                                                          ; A now contains the difference between the two
19598                                                                          ; systems' x-coordinates, with the sign removed. We
19599                                                                          ; will refer to this as the x-delta ("delta" means
19600                                                                          ; change or difference in maths)
19601               
19602               TT139:
19603 5B7E 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     5B80 42BA     
19604 5B82 06A0  32        bl   @jsr                       ;
     5B84 FE1E     
19605                                                                          ; = |QQ9 - QQ0| ^ 2
19606                                                                          ; = x_delta ^ 2
19607               
19608 5B86 D80D  30        movb ra,@K+1                    ; STA K+1           ; Store (A P) in K(1 0)
     5B88 003E     
19609 5B8A D360  30        movb @P,ra                      ; LDA P
     5B8C 001B     
19610 5B8E D80D  30        movb ra,@K                      ; STA K
     5B90 003D     
19611               
19612 5B92 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     5B94 0F32     
19613                      .sec                            ; SEC               ; selected system's y-coordinate (QQ10) and the current
     **** ****     > SEC
0001 5B96 0A18  18        sla  rmone,1
                   < elite.a99
19614                      .sbc @QQ1,ra                    ; SBC QQ1           ; system's y-coordinate (QQ1)
     **** ****     > SBC
0001 5B98 1801  14        joc  !
0002 5B9A 7347  18        sb   rone,ra
0003               !:
0004 5B9C 7360  30        sb   @QQ1,ra
     5B9E 0302     
                   < elite.a99
19615               
19616 5BA0 1807  14        joc  TT141                      ; BCS TT141         ; If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
19617                                                                          ; result is positive, so jump to TT141 and skip the
19618                                                                          ; following two instructions
19619               
19620                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5BA2 0200  20        li   rtmp,(>FF*256)
     5BA4 FF00     
0002 5BA6 2B40  18        xor  rtmp,ra
                   < elite.a99
19621                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ10 - QQ1|)
     **** ****     > ADI
0001 5BA8 1701  14        jnc  !
0002 5BAA B347  18        ab   rone,ra
0003               !:
0004 5BAC 022D  22        ai   ra,(>01*256)
     5BAE 0100     
                   < elite.a99
19622               
19623               TT141:
19624 5BB0 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
19625               
19626                                                                          ; A now contains the difference between the two
19627                                                                          ; systems' y-coordinates, with the sign removed, and
19628                                                                          ; halved. We halve the value because the galaxy in
19629                                                                          ; in Elite is rectangular rather than square, and is
19630                                                                          ; twice as wide (x-axis) as it is high (y-axis), so to
19631                                                                          ; get a distance that matches the shape of the
19632                                                                          ; long-range galaxy chart, we need to halve the
19633                                                                          ; distance between the vertical y-coordinates. We will
19634                                                                          ; refer to this as the y-delta
19635               
19636 5BB2 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     5BB4 42BA     
19637 5BB6 06A0  32        bl   @jsr                       ;
     5BB8 FE1E     
19638                                                                          ; = (|QQ10 - QQ1| / 2) ^ 2
19639                                                                          ; = y_delta ^ 2
19640               
19641                                                                          ; By this point we have the following results:
19642                                                                          ;
19643                                                                          ; K(1 0) = x_delta ^ 2
19644                                                                          ; (A P) = y_delta ^ 2
19645                                                                          ;
19646                                                                          ; so to find the distance between the two points, we
19647                                                                          ; can use Pythagoras - so first we need to add the two
19648                                                                          ; results together, and then take the square root
19649               
19650                      .pha                            ; PHA               ; Store the high byte of the y-axis value on the stack,
     **** ****     > PHA
0001 5BBA D68D  30        movb ra,*rsp
0002 5BBC 060A  14        dec  rsp
                   < elite.a99
19651                                                                          ; so we can use A for another purpose
19652               
19653 5BBE D360  30        movb @P,ra                      ; LDA P             ; Set Q = P + K, which adds the low bytes of the two
     5BC0 001B     
19654                      .clc                            ; CLC               ; calculated values
     **** ****     > CLC
0001 5BC2 0A16  18        sla  rzero,1
                   < elite.a99
19655                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 5BC4 1701  14        jnc  !
0002 5BC6 B347  18        ab   rone,ra
0003               !:
0004 5BC8 B360  30        ab   @K,ra
     5BCA 003D     
                   < elite.a99
19656 5BCC D80D  30        movb ra,@Q                      ; STA Q
     5BCE 0090     
19657               
19658                      .pla                            ; PLA               ; Restore the high byte of the y-axis value from the
     **** ****     > PLA
0001 5BD0 058A  14        inc  rsp
0002 5BD2 D35A  26        movb *rsp,ra
                   < elite.a99
19659                                                                          ; stack into A again
19660               
19661                      .adc @K+1,ra                    ; ADC K+1           ; Set R = A + K+1, which adds the high bytes of the two
     **** ****     > ADC
0001 5BD4 1701  14        jnc  !
0002 5BD6 B347  18        ab   rone,ra
0003               !:
0004 5BD8 B360  30        ab   @K+1,ra
     5BDA 003E     
                   < elite.a99
19662 5BDC D80D  30        movb ra,@R                      ; STA R             ; calculated values, so we now have:
     5BDE 0091     
19663                                                                          ;
19664                                                                          ; (R Q) = K(1 0) + (A P)
19665                                                                          ; = (x_delta ^ 2) + (y_delta ^ 2)
19666               
19667 5BE0 0200  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q), so Q now contains the distance
     5BE2 D2B6     
19668 5BE4 06A0  32        bl   @jsr                       ;
     5BE6 FE1E     
19669                                                                          ; between the two systems, in terms of coordinates
19670               
19671                                                                          ; We now store the distance to the selected system * 4
19672                                                                          ; in the two-byte location QQ8, by taking (0 Q) and
19673                                                                          ; shifting it left twice, storing it in QQ8(1 0)
19674               
19675 5BE8 D360  30        movb @Q,ra                      ; LDA Q             ; First we shift the low byte left by setting
     5BEA 0090     
19676                      .asla                           ; ASL A             ; A = Q * 2, with bit 7 of A going into the C flag
     **** ****     > ASLA
0001 5BEC 024D  22        andi ra,>ff00
     5BEE FF00     
0002 5BF0 0A1D  18        sla  ra,1
                   < elite.a99
19677               
19678 5BF2 020E  20        li   rx,>00*256                 ; LDX #0            ; Now we set the high byte in QQ8+1 to 0 and rotate
     5BF4 0000     
19679 5BF6 D80E  30        movb rx,@QQ8+1                  ; STX QQ8+1         ; the C flag into bit 0 of QQ8+1
     5BF8 0F30     
19680 5BFA 0204  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     5BFC 0F30     
19681 5BFE 06A0  32        bl   @rol                       ;
     5C00 FE44     
19682               
19683                      .asla                           ; ASL A             ; And then we repeat the shift left of (QQ8+1 A)
     **** ****     > ASLA
0001 5C02 024D  22        andi ra,>ff00
     5C04 FF00     
0002 5C06 0A1D  18        sla  ra,1
                   < elite.a99
19684 5C08 0204  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     5C0A 0F30     
19685 5C0C 06A0  32        bl   @rol                       ;
     5C0E FE44     
19686               
19687 5C10 D80D  30        movb ra,@QQ8                    ; STA QQ8           ; And store A in the low byte, QQ8, so QQ8(1 0) now
     5C12 0F2F     
19688                                                                          ; contains Q * 4. Given that the width of the galaxy is
19689                                                                          ; 256 in coordinate terms, the width of the galaxy
19690                                                                          ; would be 1024 in the units we store in QQ8
19691               
19692 5C14 0460  28        b    @TT24                      ; JMP TT24          ; Call TT24 to calculate system data from the seeds in
     5C16 5162     
19693                                                                          ; QQ15 and store them in the relevant locations, so our
19694                                                                          ; new selected system is fully set up, and return from
19695                                                                          ; the subroutine using a tail call
19696               
19697               * ******************************************************************************
19698               *
19699               * Name: hy6
19700               * Type: Subroutine
19701               * Category: Flight
19702               * Summary: Print a message to say there is no hyperspacing allowed inside the
19703               * station
19704               *
19705               * ------------------------------------------------------------------------------
19706               *
19707               * Print "Docked" at the bottom of the screen to indicate we can't hyperspace
19708               * when docked.
19709               *
19710               * ******************************************************************************
19711               
19712               hy6_:
19713 5C18 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     5C1A 4C2E     
19714 5C1C 06A0  32        bl   @jsr                       ;
     5C1E FE1E     
19715                                                                          ; and move the text cursor to column 1 on row 21, i.e.
19716                                                                          ; the start of the top row of the three bottom rows
19717               
19718 5C20 020D  20        li   ra,>0f*256                 ; LDA #15           ; Move the text cursor to column 15 (the middle of the
     5C22 0F00     
19719 5C24 D80D  30        movb ra,@XC                     ; STA XC            ; screen), setting A to 15 at the same time for the
     5C26 002C     
19720                                                                          ; following call to TT27
19721               
19722 5C28 0460  28        b    @TT27                      ; JMP TT27          ; Print recursive token 129 ("{sentence case}DOCKED")
     5C2A A6E8     
19723                                                                          ; and return from the subroutine using a tail call
19724               
19725               * ******************************************************************************
19726               *
19727               * Name: hyp
19728               * Type: Subroutine
19729               * Category: Flight
19730               * Summary: Start the hyperspace process
19731               *
19732               * ------------------------------------------------------------------------------
19733               *
19734               * Called when "H" or CTRL-H is pressed during flight. Checks the following:
19735               *
19736               * * We are in space
19737               *
19738               * * We are not already in a hyperspace countdown
19739               *
19740               * If CTRL is being held down, we jump to Ghy to engage the galactic hyperdrive,
19741               * otherwise we check that:
19742               *
19743               * * The selected system is not the current system
19744               *
19745               * * We have enough fuel to make the jump
19746               *
19747               * and if all the pre-jump checks are passed, we print the destination on-screen
19748               * and start the countdown.
19749               *
19750               * ******************************************************************************
19751               
19752               hyp_:
19753 5C2C D360  30        movb @QQ12,ra                   ; LDA QQ12          ; If we are docked (QQ12 = &FF) then jump to hy6 to
     5C2E 009F     
19754 5C30 16F3  14        jne  hy6_                       ; BNE hy6           ; print an error message and return from the subroutine
19755                                                                          ; using a tail call (as we can't hyperspace when docked)
19756               
19757 5C32 D360  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; Fetch QQ22+1, which contains the number that's shown
     5C34 002F     
19758                                                                          ; on-screen during hyperspace countdown
19759               
19760 5C36 165B  14        jne  zZ_+1                      ; BNE zZ_+1         ; If it is non-zero, return from the subroutine (as zZ+1
19761                                                                          ; contains an RTS), as there is already a countdown in
19762                                                                          ; progress
19763               
19764 5C38 0200  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed
     5C3A CC24     
19765 5C3C 06A0  32        bl   @jsr                       ;
     5C3E FE1E     
19766               
19767 5C40 1136  14        jlt  Ghy                        ; BMI Ghy           ; If it is, then the galactic hyperdrive has been
19768                                                                          ; activated, so jump to Ghy to process it
19769               
19770 5C42 0200  20        li   rtmp,hm_                   ; JSR hm            ; This is a chart view, so call hm to redraw the chart
     5C44 4C10     
19771 5C46 06A0  32        bl   @jsr                       ;
     5C48 FE1E     
19772                                                                          ; crosshairs
19773               
19774 5C4A D360  30        movb @QQ8,ra                    ; LDA QQ8           ; If both bytes of the distance to the selected system
     5C4C 0F2F     
19775 5C4E F360  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; in QQ8 are zero, return from the subroutine (as zZ+1
     5C50 0F30     
19776 5C52 134D  14        jeq  zZ_+1                      ; BEQ zZ_+1         ; contains an RTS), as the selected system is the
19777                                                                          ; current system
19778               
19779 5C54 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7, row 23 (in the
     5C56 0700     
19780 5C58 D80D  30        movb ra,@XC                     ; STA XC            ; middle of the bottom text row)
     5C5A 002C     
19781 5C5C 020D  20        li   ra,>17*256                 ; LDA #23
     5C5E 1700     
19782 5C60 D80D  30        movb ra,@YC                     ; STA YC
     5C62 002D     
19783               
19784 5C64 020D  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     5C66 0000     
19785 5C68 D80D  30        movb ra,@QQ17                   ; STA QQ17
     5C6A 007E     
19786               
19787 5C6C 020D  20        li   ra,>bd*256                 ; LDA #189          ; Print recursive token 29 ("HYPERSPACE ")
     5C6E BD00     
19788 5C70 0200  20        li   rtmp,TT27                  ; JSR TT27
     5C72 A6E8     
19789 5C74 06A0  32        bl   @jsr                       ;
     5C76 FE1E     
19790               
19791 5C78 D360  30        movb @QQ8+1,ra                  ; LDA QQ8+1         ; If the high byte of the distance to the selected
     5C7A 0F30     
19792 5C7C 1668  14        jne  TT147                      ; BNE TT147         ; system in QQ8 is > 0, then it is definitely too far to
19793                                                                          ; jump (as our maximum range is 7.0 light years, or a
19794                                                                          ; value of 70 in QQ8(1 0)), so jump to TT147 to print
19795                                                                          ; "RANGE?" and return from the subroutine using a tail
19796                                                                          ; call
19797               
19798 5C7E D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Fetch our current fuel level from Q114 into A
     5C80 030D     
19799               
19800 5C82 9360  30        cb   @QQ8,ra                    ; CMP QQ8           ; If our fuel reserves are less than the distance to the
     5C84 0F2F     
19801 5C86 1763  14        jnc  TT147                      ; BCC TT147         ; selected system, then we don't have enough fuel for
19802                                                                          ; this jump, so jump to TT147 to print "RANGE?" and
19803                                                                          ; return from the subroutine using a tail call
19804               
19805 5C88 020D  20        li   ra,('-')*256               ; LDA #'-'          ; Print a hyphen
     5C8A 2D00     
19806 5C8C 0200  20        li   rtmp,TT27                  ; JSR TT27
     5C8E A6E8     
19807 5C90 06A0  32        bl   @jsr                       ;
     5C92 FE1E     
19808               
19809 5C94 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print the name of the selected system
     5C96 A5C4     
19810 5C98 06A0  32        bl   @jsr                       ;
     5C9A FE1E     
19811               
19812                                                                          ; Fall through into wW to start the hyperspace countdown
19813               
19814               * ******************************************************************************
19815               *
19816               * Name: wW
19817               * Type: Subroutine
19818               * Category: Flight
19819               * Summary: Start a hyperspace countdown
19820               *
19821               * ------------------------------------------------------------------------------
19822               *
19823               * Start the hyperspace countdown (for both inter-system hyperspace and the
19824               * galactic hyperdrive).
19825               *
19826               * ******************************************************************************
19827               
19828               wW:
19829 5C9C 020D  20        li   ra,>0f*256                 ; LDA #15           ; The hyperspace countdown starts from 15, so set A to
     5C9E 0F00     
19830                                                                          ; 15 so we can set the two hyperspace counters
19831               
19832 5CA0 D80D  30        movb ra,@QQ22+1                 ; STA QQ22+1        ; Set the number in QQ22+1 to A, which is the number
     5CA2 002F     
19833                                                                          ; that's shown on-screen during the hyperspace countdown
19834               
19835 5CA4 D80D  30        movb ra,@QQ22                   ; STA QQ22          ; Set the number in QQ22 to 15, which is the internal
     5CA6 002E     
19836                                                                          ; counter that counts down by 1 each iteration of the
19837                                                                          ; main game loop, and each time it reaches zero, the
19838                                                                          ; on-screen counter gets decremented, and QQ22 gets set
19839                                                                          ; to 5, so setting QQ22 to 15 here makes the first tick
19840                                                                          ; of the hyperspace counter longer than subsequent ticks
19841               
19842 5CA8 D38D  18        movb ra,rx                      ; TAX               ; Print the 8-bit number in X (i.e. 15) at text location
19843 5CAA 0460  28        b    @ee3_                      ; JMP ee3           ; (0, 1), padded to 5 digits, so it appears in the top
     5CAC 5D36     
19844                                                                          ; left corner of the screen, and return from the
19845                                                                          ; subroutine using a tail call
19846               
19847               * .hy5                   \ This instruction and the hy5 label are commented out
19848               * RTS                    \ in the original - they can actually be found at the
19849                                                                          ; end of the jmp routine below, so perhaps this is where
19850                                                                          ; they were originally, but the authors realised they
19851                                                                          ; could save a byte by using a tail call instead of an
19852                                                                          ; RTS?
19853               
19854               * ******************************************************************************
19855               *
19856               * Name: Ghy
19857               * Type: Subroutine
19858               * Category: Flight
19859               * Summary: Perform a galactic hyperspace jump
19860               * Deep dive: Twisting the system seeds
19861               * Galaxy and system seeds
19862               *
19863               * ------------------------------------------------------------------------------
19864               *
19865               * Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
19866               * being pressed.
19867               *
19868               * This routine also updates the galaxy seeds to point to the next galaxy. Using
19869               * a galactic hyperdrive rotates each seed byte to the left, rolling each byte
19870               * left within itself like this:
19871               *
19872               * 01234567 -> 12345670
19873               *
19874               * to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
19875               * roll round to those of the first galaxy again.
19876               *
19877               * We always arrive in a new galaxy at galactic coordinates (96, 96), and then
19878               * find the nearest system and set that as our location.
19879               *
19880               * ------------------------------------------------------------------------------
19881               *
19882               * Other entry points:
19883               *
19884               * zZ+1                Contains an RTS
19885               *
19886               * ******************************************************************************
19887               
19888               Ghy:
19917               
19918 5CAE D3A0  30        movb @GHYP,rx                   ; LDX GHYP          ; Fetch GHYP, which tells us whether we own a galactic
     5CB0 032D     
19919 5CB2 133F  14        jeq  hy5_                       ; BEQ hy5           ; hyperdrive, and if it is zero, which means we don't,
19920                                                                          ; return from the subroutine (as hy5 contains an RTS)
19921               
19922 5CB4 B387  18        ab   rone,rx                    ; INX               ; We own a galactic hyperdrive, so X is &FF, so this
19923                                                                          ; instruction sets X = 0
19924               
19931               
19932 5CB6 D80E  30        movb rx,@GHYP                   ; STX GHYP          ; The galactic hyperdrive is a one-use item, so set GHYP
     5CB8 032D     
19933                                                                          ; to 0 so we no longer have one fitted
19934               
19935 5CBA D80E  30        movb rx,@FIST                   ; STX FIST          ; Changing galaxy also clears our criminal record, so
     5CBC 0334     
19936                                                                          ; set our legal status in FIST to 0 ("clean")
19937               
19938 5CBE 0200  20        li   rtmp,wW                    ; JSR wW            ; Call wW to start the hyperspace countdown
     5CC0 5C9C     
19939 5CC2 06A0  32        bl   @jsr                       ;
     5CC4 FE1E     
19940               
19941 5CC6 020E  20        li   rx,>05*256                 ; LDX #5            ; To move galaxy, we rotate the galaxy's seeds left, so
     5CC8 0500     
19942                                                                          ; set a counter in X for the 6 seed bytes
19943               
19944 5CCA B347  18        ab   rone,ra                    ; INC GCNT          ; Increment the current galaxy number in GCNT
19945               
19946 5CCC D360  30        movb @GCNT,ra                   ; LDA GCNT          ; Set GCNT = GCNT mod 8, so we jump from galaxy 7 back
     5CCE 030F     
19947 5CD0 024D  22        andi ra,>07*256                 ; AND #7            ; to galaxy 0 (shown in-game as going from galaxy 8 back
     5CD2 0700     
19948 5CD4 D80D  30        movb ra,@GCNT                   ; STA GCNT          ; to the starting point in galaxy 1)
     5CD6 030F     
19949               
19950               G1:
19951 5CD8 D36E  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Load the X-th seed byte into A
     5CDA 0303     
19952               
19953                      .asla                           ; ASL A             ; Set the C flag to bit 7 of the seed
     **** ****     > ASLA
0001 5CDC 024D  22        andi ra,>ff00
     5CDE FF00     
0002 5CE0 0A1D  18        sla  ra,1
                   < elite.a99
19954               
19955 5CE2 0204  20        li   rarg1,QQ21                 ; ROL QQ21,X        ; Rotate the seed in memory, which will add bit 7 back
     5CE4 0303     
19956 5CE6 06A0  32        bl   @rol                       ;
     5CE8 FE44     
19957                                                                          ; in as bit 0, so this rolls the seed around on itself
19958               
19959 5CEA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19960               
19961 5CEC 15F5  14        jgt  G1                         ; BPL G1            ; Loop back for the next seed byte, until we have
19962                                                                          ; rotated them all
19963               
19964               * JSR DORND              \ This instruction is commented out in the original
19965                                                                          ; source, and would set A and X to random numbers, so
19966                                                                          ; perhaps the original plan was to arrive in each new
19967                                                                          ; galaxy in a random place?
19968               
19969               zZ_:
19970 5CEE 020D  20        li   ra,>60*256                 ; LDA #96           ; Set (QQ9, QQ10) to (96, 96), which is where we always
     5CF0 6000     
19971 5CF2 D80D  30        movb ra,@QQ9                    ; STA QQ9           ; arrive in a new galaxy (the selected system will be
     5CF4 0F31     
19972 5CF6 D80D  30        movb ra,@QQ10                   ; STA QQ10          ; set to the nearest actual system later on)
     5CF8 0F32     
19973               
19974 5CFA 0200  20        li   rtmp,TT110                 ; JSR TT110         ; Call TT110 to show the front space view
     5CFC A10A     
19975 5CFE 06A0  32        bl   @jsr                       ;
     5D00 FE1E     
19976               
19978               
19979 5D02 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Call TT111 to set the current system to the nearest
     5D04 5AB8     
19980 5D06 06A0  32        bl   @jsr                       ;
     5D08 FE1E     
19981                                                                          ; system to (QQ9, QQ10), and put the seeds of the
19982                                                                          ; nearest system into QQ15 to QQ15+5
19983                                                                          ;
19984                                                                          ; This call fixes a bug in the early cassette versions,
19985                                                                          ; where the galactic hyperdrive will take us to
19986                                                                          ; coordinates (96, 96) in the new galaxy, even if there
19987                                                                          ; isn't actually a system there, so if we jump when we
19988                                                                          ; are low on fuel, it is possible to get stuck in the
19989                                                                          ; middle of nowhere when changing galaxy
19990                                                                          ;
19991                                                                          ; This call sets the current system correctly, so we
19992                                                                          ; always arrive at the nearest system to (96, 96)
19993               
19995               
19997               
19998 5D0A 020E  20        li   rx,>00*256                 ; LDX #0            ; Set the distance to the selected system in QQ8(1 0)
     5D0C 0000     
19999 5D0E D80E  30        movb rx,@QQ8                    ; STX QQ8           ; to 0
     5D10 0F2F     
20000 5D12 D80E  30        movb rx,@QQ8+1                  ; STX QQ8+1
     5D14 0F30     
20001               
20003               
20004 5D16 020D  20        li   ra,>74*256                 ; LDA #116          ; Print recursive token 116 ("GALACTIC HYPERSPACE")
     5D18 7400     
20005 5D1A 0200  20        li   rtmp,MESS                  ; JSR MESS          ; as an in-flight message
     5D1C CE5E     
20006 5D1E 06A0  32        bl   @jsr                       ;
     5D20 FE1E     
20007               
20008                                                                          ; Fall through into jmp to set the system to the
20009                                                                          ; current system and return from the subroutine there
20010               
20011               * ******************************************************************************
20012               *
20013               * Name: jmp
20014               * Type: Subroutine
20015               * Category: Universe
20016               * Summary: Set the current system to the selected system
20017               *
20018               * ------------------------------------------------------------------------------
20019               *
20020               * Returns:
20021               *
20022               * (QQ0, QQ1)          The galactic coordinates of the new system
20023               *
20024               * ------------------------------------------------------------------------------
20025               *
20026               * Other entry points:
20027               *
20028               * hy5                 Contains an RTS
20029               *
20030               * ******************************************************************************
20031               
20032               jmp_:
20033 5D22 D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Set the current system's galactic x-coordinate to the
     5D24 0F31     
20034 5D26 D80D  30        movb ra,@QQ0                    ; STA QQ0           ; x-coordinate of the selected system
     5D28 0301     
20035               
20036 5D2A D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set the current system's galactic y-coordinate to the
     5D2C 0F32     
20037 5D2E D80D  30        movb ra,@QQ1                    ; STA QQ1           ; y-coordinate of the selected system
     5D30 0302     
20038               
20039               hy5_:
20040 5D32 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5D34 FE2A     
20041               
20042               * ******************************************************************************
20043               *
20044               * Name: ee3
20045               * Type: Subroutine
20046               * Category: Flight
20047               * Summary: Print the hyperspace countdown in the top-left of the screen
20048               *
20049               * ------------------------------------------------------------------------------
20050               *
20051               * Print the 8-bit number in X at text location (0, 1). Print the number to
20052               * 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
20053               * numbers < 10000 are right-aligned), with no decimal point.
20054               *
20055               * ------------------------------------------------------------------------------
20056               *
20057               * Arguments:
20058               *
20059               * X                   The number to print
20060               *
20061               * ******************************************************************************
20062               
20063               ee3_:
20064 5D36 020F  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     5D38 0100     
20065 5D3A D80F  30        movb ry,@YC                     ; STY YC
     5D3C 002D     
20066               
20067 5D3E 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0 for the high byte in pr6
20068               
20069 5D40 D80F  30        movb ry,@XC                     ; STY XC            ; Move the text cursor to column 0
     5D42 002C     
20070               
20071                                                                          ; Fall through into pr6 to print X to 5 digits, as the
20072                                                                          ; high byte in Y is 0
20073               
20074               * ******************************************************************************
20075               *
20076               * Name: pr6
20077               * Type: Subroutine
20078               * Category: Text
20079               * Summary: Print 16-bit number, left-padded to 5 digits, no point
20080               *
20081               * ------------------------------------------------------------------------------
20082               *
20083               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20084               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
20085               * with no decimal point.
20086               *
20087               * ------------------------------------------------------------------------------
20088               *
20089               * Arguments:
20090               *
20091               * X                   The low byte of the number to print
20092               *
20093               * Y                   The high byte of the number to print
20094               *
20095               * ******************************************************************************
20096               
20097               pr6_:
20098                      .clc                            ; CLC               ; Do not display a decimal point when printing
     **** ****     > CLC
0001 5D44 0A16  18        sla  rzero,1
                   < elite.a99
20099               
20100                                                                          ; Fall through into pr5 to print X to 5 digits
20101               
20102               * ******************************************************************************
20103               *
20104               * Name: pr5
20105               * Type: Subroutine
20106               * Category: Text
20107               * Summary: Print a 16-bit number, left-padded to 5 digits, and optional point
20108               *
20109               * ------------------------------------------------------------------------------
20110               *
20111               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20112               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
20113               * Optionally include a decimal point.
20114               *
20115               * ------------------------------------------------------------------------------
20116               *
20117               * Arguments:
20118               *
20119               * X                   The low byte of the number to print
20120               *
20121               * Y                   The high byte of the number to print
20122               *
20123               * C flag              If set, include a decimal point
20124               *
20125               * ******************************************************************************
20126               
20127               pr5_:
20128 5D46 020D  20        li   ra,>05*256                 ; LDA #5            ; Set the number of digits to print to 5
     5D48 0500     
20129               
20130 5D4A 0460  28        b    @TT11                      ; JMP TT11          ; Call TT11 to print (Y X) to 5 digits and return from
     5D4C 2FB4     
20131                                                                          ; the subroutine using a tail call
20132               
20133               * ******************************************************************************
20134               *
20135               * Name: TT147
20136               * Type: Subroutine
20137               * Category: Flight
20138               * Summary: Print an error when a system is out of hyperspace range
20139               *
20140               * ------------------------------------------------------------------------------
20141               *
20142               * Print "RANGE?" for when the hyperspace distance is too far
20143               *
20144               * ******************************************************************************
20145               
20146               TT147:
20147 5D4E 020D  20        li   ra,>ca*256                 ; LDA #202          ; Load A with token 42 ("RANGE") and fall through into
     5D50 CA00     
20148                                                                          ; prq to print it, followed by a question mark
20149               
20150               * ******************************************************************************
20151               *
20152               * Name: prq
20153               * Type: Subroutine
20154               * Category: Text
20155               * Summary: Print a text token followed by a question mark
20156               *
20157               * ------------------------------------------------------------------------------
20158               *
20159               * Arguments:
20160               *
20161               * A                   The text token to be printed
20162               *
20163               * ------------------------------------------------------------------------------
20164               *
20165               * Other entry points:
20166               *
20167               * prq+3               Print a question mark
20168               *
20169               * ******************************************************************************
20170               
20171               prq_:
20172 5D52 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     5D54 A6E8     
20173 5D56 06A0  32        bl   @jsr                       ;
     5D58 FE1E     
20174               
20175 5D5A 020D  20        li   ra,('?')*256               ; LDA #'?'          ; Print a question mark and return from the
     5D5C 3F00     
20176 5D5E 0460  28        b    @TT27                      ; JMP TT27          ; subroutine using a tail call
     5D60 A6E8     
20177               
20178               * ******************************************************************************
20179               *
20180               * Name: TT151
20181               * Type: Subroutine
20182               * Category: Market
20183               * Summary: Print the name, price and availability of a market item
20184               * Deep dive: Market item prices and availability
20185               * Galaxy and system seeds
20186               *
20187               * ------------------------------------------------------------------------------
20188               *
20189               * Arguments:
20190               *
20191               * A                   The number of the market item to print, 0-16 (see QQ23
20192               * for details of item numbers)
20193               *
20194               * ------------------------------------------------------------------------------
20195               *
20196               * Returns:
20197               *
20198               * QQ19+1              Byte #1 from the market prices table for this item
20199               *
20200               * QQ24                The item's price / 4
20201               *
20202               * QQ25                The item's availability
20203               *
20204               * ******************************************************************************
20205               
20206               TT151:
20207                      .pha                            ; PHA               ; Store the item number on the stack and in QQ19+4
     **** ****     > PHA
0001 5D62 D68D  30        movb ra,*rsp
0002 5D64 060A  14        dec  rsp
                   < elite.a99
20208 5D66 D80D  30        movb ra,@QQ19+4                 ; STA QQ19+4
     5D68 0083     
20209               
20210                      .asla                           ; ASL A             ; Store the item number * 4 in QQ19, so this will act as
     **** ****     > ASLA
0001 5D6A 024D  22        andi ra,>ff00
     5D6C FF00     
0002 5D6E 0A1D  18        sla  ra,1
                   < elite.a99
20211                      .asla                           ; ASL A             ; an index into the market prices table at QQ23 for this
     **** ****     > ASLA
0001 5D70 024D  22        andi ra,>ff00
     5D72 FF00     
0002 5D74 0A1D  18        sla  ra,1
                   < elite.a99
20212 5D76 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; item (as there are four bytes per item in the table)
     5D78 007F     
20213               
20214 5D7A 020D  20        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1, for the item's name
     5D7C 0100     
20215 5D7E D80D  30        movb ra,@XC                     ; STA XC
     5D80 002C     
20216               
20217                      .pla                            ; PLA               ; Restore the item number
     **** ****     > PLA
0001 5D82 058A  14        inc  rsp
0002 5D84 D35A  26        movb *rsp,ra
                   < elite.a99
20218               
20219                      .adi (>d0*256)                  ; ADC #208          ; Print recursive token 48 + A, which will be in the
     **** ****     > ADI
0001 5D86 1701  14        jnc  !
0002 5D88 B347  18        ab   rone,ra
0003               !:
0004 5D8A 022D  22        ai   ra,(>D0*256)
     5D8C D000     
                   < elite.a99
20220 5D8E 0200  20        li   rtmp,TT27                  ; JSR TT27          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     5D90 A6E8     
20221 5D92 06A0  32        bl   @jsr                       ;
     5D94 FE1E     
20222                                                                          ; prints the item's name
20223               
20224 5D96 020D  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the price
     5D98 0E00     
20225 5D9A D80D  30        movb ra,@XC                     ; STA XC
     5D9C 002C     
20226               
20227 5D9E D3A0  30        movb @QQ19,rx                   ; LDX QQ19          ; Fetch byte #1 from the market prices table (units and
     5DA0 007F     
20228 5DA2 D36E  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; economic_factor) for this item and store in QQ19+1
     5DA4 CF2F     
20229 5DA6 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1
     5DA8 0080     
20230               
20231 5DAA D360  30        movb @QQ26,ra                   ; LDA QQ26          ; Fetch the random number for this system visit and
     5DAC 0346     
20232                      .and @QQ23+3(rx)                ; AND QQ23+3,X      ; AND with byte #3 from the market prices table (mask)
     **** ****     > AND
0001 5DAE D02E  34        movb @QQ23+3(RX),rtmp
     5DB0 CF31     
0002 5DB2 0540  14        inv  rtmp
0003 5DB4 5340  18        szcb rtmp,ra
                   < elite.a99
20233                                                                          ; to give:
20234                                                                          ;
20235                                                                          ; A = random AND mask
20236               
20237                      .clc                            ; CLC               ; Add byte #0 from the market prices table (base_price),
     **** ****     > CLC
0001 5DB6 0A16  18        sla  rzero,1
                   < elite.a99
20238                      .adc @QQ23(rx),ra               ; ADC QQ23,X        ; so we now have:
     **** ****     > ADC
0001 5DB8 1701  14        jnc  !
0002 5DBA B347  18        ab   rone,ra
0003               !:
0004 5DBC B36E  34        ab   @QQ23(RX),ra
     5DBE CF2E     
                   < elite.a99
20239 5DC0 D80D  30        movb ra,@QQ24                   ; STA QQ24          ;
     5DC2 0F18     
20240                                                                          ; A = base_price + (random AND mask)
20241               
20242 5DC4 0200  20        li   rtmp,TT152                 ; JSR TT152         ; Call TT152 to print the item's unit ("t", "kg" or
     5DC6 5E4C     
20243 5DC8 06A0  32        bl   @jsr                       ;
     5DCA FE1E     
20244                                                                          ; "g"), padded to a width of two characters
20245               
20246 5DCC 0200  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     5DCE 5EF6     
20247 5DD0 06A0  32        bl   @jsr                       ;
     5DD2 FE1E     
20248                                                                          ; (and set the availability of alien items to 0)
20249               
20250 5DD4 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     5DD6 0080     
20251 5DD8 1108  14        jlt  TT155                      ; BMI TT155         ; TT155 if it is negative (i.e. if the economic_factor
20252                                                                          ; is negative)
20253               
20254 5DDA D360  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 + QQ19+3
     5DDC 0F18     
20255                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 5DDE 1701  14        jnc  !
0002 5DE0 B347  18        ab   rone,ra
0003               !:
0004 5DE2 B360  30        ab   @QQ19+3,ra
     5DE4 0082     
                   < elite.a99
20256                                                                          ; = base_price + (random AND mask)
20257                                                                          ; + (economy * |economic_factor|)
20258                                                                          ;
20259                                                                          ; which is the result we want, as the economic_factor
20260                                                                          ; is positive
20261               
20262 5DE6 0460  28        b    @TT156                     ; JMP TT156         ; Jump to TT156 to multiply the result by 4
     5DE8 5DF8     
20263               
20264               TT155:
20265 5DEA D360  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 - QQ19+3
     5DEC 0F18     
20266                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 5DEE 0A18  18        sla  rmone,1
                   < elite.a99
20267                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ; = base_price + (random AND mask)
     **** ****     > SBC
0001 5DF0 1801  14        joc  !
0002 5DF2 7347  18        sb   rone,ra
0003               !:
0004 5DF4 7360  30        sb   @QQ19+3,ra
     5DF6 0082     
                   < elite.a99
20268                                                                          ; - (economy * |economic_factor|)
20269                                                                          ;
20270                                                                          ; which is the result we want, as economic_factor
20271                                                                          ; is negative
20272               
20273               TT156:
20274 5DF8 D80D  30        movb ra,@QQ24                   ; STA QQ24          ; Store the result in QQ24 and P
     5DFA 0F18     
20275 5DFC D80D  30        movb ra,@P                      ; STA P
     5DFE 001B     
20276               
20277 5E00 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
     5E02 0000     
20278 5E04 0200  20        li   rtmp,GC2                   ; JSR GC2           ; which is the same as (Y X) = P * 4 because A = 0
     5E06 A20A     
20279 5E08 06A0  32        bl   @jsr                       ;
     5E0A FE1E     
20280               
20281                      .sec                            ; SEC               ; We now have our final price, * 10, so we can call pr5
     **** ****     > SEC
0001 5E0C 0A18  18        sla  rmone,1
                   < elite.a99
20282 5E0E 0200  20        li   rtmp,pr5_                  ; JSR pr5           ; to print (Y X) to 5 digits, including a decimal
     5E10 5D46     
20283 5E12 06A0  32        bl   @jsr                       ;
     5E14 FE1E     
20284                                                                          ; point, as the C flag is set
20285               
20286 5E16 D3E0  30        movb @QQ19+4,ry                 ; LDY QQ19+4        ; We now move on to availability, so fetch the market
     5E18 0083     
20287                                                                          ; item number that we stored in QQ19+4 at the start
20288               
20289 5E1A 020D  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 so we can print the availability to 5
     5E1C 0500     
20290                                                                          ; digits (right-padded with spaces)
20291               
20292 5E1E D3AF  34        movb @AVL(ry),rx                ; LDX AVL,Y         ; Set X to the item's availability, which is given in
     5E20 0335     
20293                                                                          ; the AVL table
20294               
20295 5E22 D80E  30        movb rx,@QQ25                   ; STX QQ25          ; Store the availability in QQ25
     5E24 0F19     
20296               
20297                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 5E26 0A16  18        sla  rzero,1
                   < elite.a99
20298               
20299 5E28 1306  14        jeq  TT172                      ; BEQ TT172         ; If none are available, jump to TT172 to print a tab
20300                                                                          ; and a "-"
20301               
20302 5E2A 0200  20        li   rtmp,pr2_+2                ; JSR pr2+2         ; Otherwise print the 8-bit number in X to 5 digits,
     5E2C 2FAE     
20303 5E2E 06A0  32        bl   @jsr                       ;
     5E30 FE1E     
20304                                                                          ; right-aligned with spaces. This works because we set
20305                                                                          ; A to 5 above, and we jump into the pr2 routine just
20306                                                                          ; after the first instruction, which would normally
20307                                                                          ; set the number of digits to 3
20308               
20309 5E32 0460  28        b    @TT152                     ; JMP TT152         ; Print the unit ("t", "kg" or "g") for the market item,
     5E34 5E4C     
20310                                                                          ; with a following space if required to make it two
20311                                                                          ; characters long, and return from the subroutine using
20312                                                                          ; a tail call
20313               
20314               TT172:
20315 5E36 D360  30        movb @XC,ra                     ; LDA XC            ; Move the text cursor in XC to the right by 4 columns,
     5E38 002C     
20316                      .adi (>04*256)                  ; ADC #4            ; so the cursor is where the last digit would be if we
     **** ****     > ADI
0001 5E3A 1701  14        jnc  !
0002 5E3C B347  18        ab   rone,ra
0003               !:
0004 5E3E 022D  22        ai   ra,(>04*256)
     5E40 0400     
                   < elite.a99
20317 5E42 D80D  30        movb ra,@XC                     ; STA XC            ; were printing a 5-digit availability number
     5E44 002C     
20318               
20319 5E46 020D  20        li   ra,('-')*256               ; LDA #'-'          ; Print a "-" character by jumping to TT162+2, which
     5E48 2D00     
20320 5E4A 160D  14        jne  TT162+2                    ; BNE TT162+2       ; contains JMP TT27 (this BNE is effectively a JMP as A
20321                                                                          ; will never be zero), and return from the subroutine
20322                                                                          ; using a tail call
20323               
20324               * ******************************************************************************
20325               *
20326               * Name: TT152
20327               * Type: Subroutine
20328               * Category: Market
20329               * Summary: Print the unit ("t", "kg" or "g") for a market item
20330               *
20331               * ------------------------------------------------------------------------------
20332               *
20333               * Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
20334               * market prices table is in QQ19+1, right-padded with spaces to a width of two
20335               * characters (so that's "t ", "kg" or "g ").
20336               *
20337               * ******************************************************************************
20338               
20339               TT152:
20340 5E4C D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the economic_factor from QQ19+1
     5E4E 0080     
20341               
20342 5E50 024D  22        andi ra,>60*256                 ; AND #96           ; If bits 5 and 6 are both clear, jump to TT160 to
     5E52 6000     
20343 5E54 130B  14        jeq  TT160                      ; BEQ TT160         ; print "t" for tonne, followed by a space, and return
20344                                                                          ; from the subroutine using a tail call
20345               
20346 5E56 028D  22        ci   ra,>20*256                 ; CMP #32           ; If bit 5 is set, jump to TT161 to print "kg" for
     5E58 2000     
20347 5E5A 130F  14        jeq  TT161                      ; BEQ TT161         ; kilograms, and return from the subroutine using a tail
20348                                                                          ; call
20349               
20350 5E5C 0200  20        li   rtmp,TT16a                 ; JSR TT16a         ; Otherwise call TT16a to print "g" for grams, and fall
     5E5E 5E86     
20351 5E60 06A0  32        bl   @jsr                       ;
     5E62 FE1E     
20352                                                                          ; through into TT162 to print a space and return from
20353                                                                          ; the subroutine
20354               
20355               * ******************************************************************************
20356               *
20357               * Name: TT162
20358               * Type: Subroutine
20359               * Category: Text
20360               * Summary: Print a space
20361               *
20362               * ------------------------------------------------------------------------------
20363               *
20364               * Other entry points:
20365               *
20366               * TT162+2             Jump to TT27 to print the text token in A
20367               *
20368               * ******************************************************************************
20369               
20370               TT162:
20371 5E64 020D  20        li   ra,(' ')*256               ; LDA #' '          ; Load a space character into A
     5E66 2000     
20372               
20373 5E68 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     5E6A A6E8     
20374                                                                          ; subroutine using a tail call
20375               
20376               * ******************************************************************************
20377               *
20378               * Name: TT160
20379               * Type: Subroutine
20380               * Category: Market
20381               * Summary: Print "t" (for tonne) and a space
20382               *
20383               * ******************************************************************************
20384               
20385               TT160:
20386 5E6C 020D  20        li   ra,('t')*256               ; LDA #'t'          ; Load a "t" character into A
     5E6E 7400     
20387               
20388 5E70 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     5E72 3172     
20389 5E74 06A0  32        bl   @jsr                       ;
     5E76 FE1E     
20390                                                                          ; change the character case
20391               
20392 5E78 17F5  14        jnc  TT162                      ; BCC TT162         ; Jump to TT162 to print a space and return from the
20393                                                                          ; subroutine using a tail call (this BCC is effectively
20394                                                                          ; a JMP as the C flag is cleared by TT26)
20395               
20396               * ******************************************************************************
20397               *
20398               * Name: TT161
20399               * Type: Subroutine
20400               * Category: Market
20401               * Summary: Print "kg" (for kilograms)
20402               *
20403               * ******************************************************************************
20404               
20405               TT161:
20406 5E7A 020D  20        li   ra,('k')*256               ; LDA #'k'          ; Load a "k" character into A
     5E7C 6B00     
20407               
20408 5E7E 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     5E80 3172     
20409 5E82 06A0  32        bl   @jsr                       ;
     5E84 FE1E     
20410                                                                          ; change the character case, and fall through into
20411                                                                          ; TT16a to print a "g" character
20412               
20413               * ******************************************************************************
20414               *
20415               * Name: TT16a
20416               * Type: Subroutine
20417               * Category: Market
20418               * Summary: Print "g" (for grams)
20419               *
20420               * ******************************************************************************
20421               
20422               TT16a:
20423 5E86 020D  20        li   ra,('g')*256               ; LDA #'g'          ; Load a "g" character into A
     5E88 6700     
20424               
20425 5E8A 0460  28        b    @TT26                      ; JMP TT26          ; Print the character, using TT216 so that it doesn't
     5E8C 3172     
20426                                                                          ; change the character case, and return from the
20427                                                                          ; subroutine using a tail call
20428               
20429               * ******************************************************************************
20430               *
20431               * Name: TT163
20432               * Type: Subroutine
20433               * Category: Market
20434               * Summary: Print the headers for the table of market prices
20435               *
20436               * ------------------------------------------------------------------------------
20437               *
20438               * Print the column headers for the prices table in the Buy Cargo and Market
20439               * Price screens.
20440               *
20441               * ******************************************************************************
20442               
20443               TT163:
20444 5E8E 020D  20        li   ra,>11*256                 ; LDA #17           ; Move the text cursor in XC to column 17
     5E90 1100     
20445 5E92 D80D  30        movb ra,@XC                     ; STA XC
     5E94 002C     
20446               
20447 5E96 020D  20        li   ra,>ff*256                 ; LDA #255          ; Print recursive token 95 token ("UNIT  QUANTITY
     5E98 FF00     
20448 5E9A 16E5  14        jne  TT162+2                    ; BNE TT162+2       ; {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
20449                                                                          ; jumping to TT162+2, which contains JMP TT27 (this BNE
20450                                                                          ; is effectively a JMP as A will never be zero), and
20451                                                                          ; return from the subroutine using a tail call
20452               
20453               * ******************************************************************************
20454               *
20455               * Name: TT167
20456               * Type: Subroutine
20457               * Category: Market
20458               * Summary: Show the Market Price screen (red key f7)
20459               *
20460               * ******************************************************************************
20461               
20462               TT167:
20463 5E9C 020D  20        li   ra,>10*256                 ; LDA #16           ; Clear the top part of the screen, draw a white border,
     5E9E 1000     
20464 5EA0 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 16 (Market
     5EA2 4B2A     
20465 5EA4 06A0  32        bl   @jsr                       ;
     5EA6 FE1E     
20466                                                                          ; Price screen)
20467               
20468 5EA8 020D  20        li   ra,>05*256                 ; LDA #5            ; Move the text cursor to column 5
     5EAA 0500     
20469 5EAC D80D  30        movb ra,@XC                     ; STA XC
     5EAE 002C     
20470               
20471 5EB0 020D  20        li   ra,>a7*256                 ; LDA #167          ; Print recursive token 7 ("{current system name} MARKET
     5EB2 A700     
20472 5EB4 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; PRICES") and draw a horizontal line at pixel row 19
     5EB6 25B0     
20473 5EB8 06A0  32        bl   @jsr                       ;
     5EBA FE1E     
20474                                                                          ; to box in the title
20475               
20476 5EBC 020D  20        li   ra,>03*256                 ; LDA #3            ; Move the text cursor to row 3
     5EBE 0300     
20477 5EC0 D80D  30        movb ra,@YC                     ; STA YC
     5EC2 002D     
20478               
20479 5EC4 0200  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     5EC6 5E8E     
20480 5EC8 06A0  32        bl   @jsr                       ;
     5ECA FE1E     
20481               
20482 5ECC 020D  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     5ECE 0000     
20483 5ED0 D80D  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     5ED2 0F1B     
20484                                                                          ; current item and start it at 0
20485               
20486               TT168:
20487 5ED4 020E  20        li   rx,>80*256                 ; LDX #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     5ED6 8000     
20488 5ED8 D80E  30        movb rx,@QQ17                   ; STX QQ17          ; next letter in capitals
     5EDA 007E     
20489               
20490 5EDC 0200  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     5EDE 5D62     
20491 5EE0 06A0  32        bl   @jsr                       ;
     5EE2 FE1E     
20492                                                                          ; availability of the current item, and set QQ24 to the
20493                                                                          ; item's price / 4, QQ25 to the quantity available and
20494                                                                          ; QQ19+1 to byte #1 from the market prices table for
20495                                                                          ; this item
20496               
20497 5EE4 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one row
20498               
20499 5EE6 B347  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
20500               
20501 5EE8 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to TT168 as we have done the
     5EEA 0F1B     
20502 5EEC 028D  22        ci   ra,>11*256                 ; CMP #17           ; last item
     5EEE 1100     
20503 5EF0 17F1  14        jnc  TT168                      ; BCC TT168
20504               
20505 5EF2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5EF4 FE2A     
20506               
20507               * ******************************************************************************
20508               *
20509               * Name: var
20510               * Type: Subroutine
20511               * Category: Market
20512               * Summary: Calculate QQ19+3 = economy * |economic_factor|
20513               *
20514               * ------------------------------------------------------------------------------
20515               *
20516               * Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
20517               * table for an item. Also sets the availability of alien items to 0.
20518               *
20519               * This routine forms part of the calculations for market item prices (TT151)
20520               * and availability (GVL).
20521               *
20522               * ------------------------------------------------------------------------------
20523               *
20524               * Arguments:
20525               *
20526               * QQ19+1              Byte #1 of the market prices table for this market item
20527               * (which contains the economic_factor in bits 0-5, and the
20528               * sign of the economic_factor in bit 7)
20529               *
20530               * ******************************************************************************
20531               
20532               var_:
20533 5EF6 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Extract bits 0-5 from QQ19+1 into A, to get the
     5EF8 0080     
20534 5EFA 024D  22        andi ra,>1f*256                 ; AND #31           ; economic_factor without its sign, in other words:
     5EFC 1F00     
20535                                                                          ;
20536                                                                          ; A = |economic_factor|
20537               
20538 5EFE D3E0  30        movb @QQ28,ry                   ; LDY QQ28          ; Set Y to the economy byte of the current system
     5F00 0F1A     
20539               
20540 5F02 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Store A in QQ19+2
     5F04 0081     
20541               
20542                      .clc                            ; CLC               ; Clear the C flag so we can do additions below
     **** ****     > CLC
0001 5F06 0A16  18        sla  rzero,1
                   < elite.a99
20543               
20544 5F08 020D  20        li   ra,>00*256                 ; LDA #0            ; Set AVL+16 (availability of alien items) to 0,
     5F0A 0000     
20545 5F0C D80D  30        movb ra,@AVL+16                 ; STA AVL+16        ; setting A to 0 in the process
     5F0E 0345     
20546               
20547               TT153:
20548                                                                          ; We now do the multiplication by doing a series of
20549                                                                          ; additions in a loop, building the result in A. Each
20550                                                                          ; loop adds QQ19+2 (|economic_factor|) to A, and it
20551                                                                          ; loops the number of times given by the economy byte;
20552                                                                          ; in other words, because A starts at 0, this sets:
20553                                                                          ;
20554                                                                          ; A = economy * |economic_factor|
20555 5F10 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the economy in Y, exiting the loop when it
20556 5F12 1106  14        jlt  TT154                      ; BMI TT154         ; becomes negative
20557               
20558                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; Add QQ19+2 to A
     **** ****     > ADC
0001 5F14 1701  14        jnc  !
0002 5F16 B347  18        ab   rone,ra
0003               !:
0004 5F18 B360  30        ab   @QQ19+2,ra
     5F1A 0081     
                   < elite.a99
20559               
20560 5F1C 0460  28        b    @TT153                     ; JMP TT153         ; Loop back to TT153 to do another addition
     5F1E 5F10     
20561               
20562               TT154:
20563 5F20 D80D  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; Store the result in QQ19+3
     5F22 0082     
20564               
20565 5F24 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5F26 FE2A     
20566               
20567               * ******************************************************************************
20568               *
20569               * Name: hyp1
20570               * Type: Subroutine
20571               * Category: Universe
20572               * Summary: Process a jump to the system closest to (QQ9, QQ10)
20573               *
20574               * ------------------------------------------------------------------------------
20575               *
20576               * Do a hyperspace jump to the system closest to galactic coordinates
20577               * (QQ9, QQ10), and set up the current system's state to those of the new system.
20578               *
20579               * ------------------------------------------------------------------------------
20580               *
20581               * Returns:
20582               *
20583               * (QQ0, QQ1)          The galactic coordinates of the new system
20584               *
20585               * QQ2 to QQ2+6        The seeds of the new system
20586               *
20587               * EV                  Set to 0
20588               *
20589               * QQ28                The new system's economy
20590               *
20591               * tek                 The new system's tech level
20592               *
20593               * gov                 The new system's government
20594               *
20595               * ------------------------------------------------------------------------------
20596               *
20597               * Other entry points:
20598               *
20599               * hyp1+3              Jump straight to the system at (QQ9, QQ10) without
20600               * first calculating which system is closest. We do this
20601               * if we already know that (QQ9, QQ10) points to a system
20602               *
20603               * ******************************************************************************
20604               
20605               hyp1_:
20606 5F28 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     5F2A 5AB8     
20607 5F2C 06A0  32        bl   @jsr                       ;
     5F2E FE1E     
20608                                                                          ; (QQ9, QQ10)
20609               
20610 5F30 0200  20        li   rtmp,jmp_                  ; JSR jmp           ; Set the current system to the selected system
     5F32 5D22     
20611 5F34 06A0  32        bl   @jsr                       ;
     5F36 FE1E     
20612               
20613 5F38 020E  20        li   rx,>05*256                 ; LDX #5            ; We now want to copy the seeds for the selected system
     5F3A 0500     
20614                                                                          ; in QQ15 into QQ2, where we store the seeds for the
20615                                                                          ; current system, so set up a counter in X for copying
20616                                                                          ; 6 bytes (for three 16-bit seeds)
20617               
20618               TT112:
20619 5F3C D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ2, to
     5F3E 0078     
20620 5F40 DB8D  38        movb ra,@QQ2(rx)                ; STA QQ2,X         ; update the selected system to the new one. Note that
     5F42 0F22     
20621                                                                          ; this approach has a minor bug associated with it: if
20622                                                                          ; your hyperspace counter hits 0 just as you're docking,
20623                                                                          ; then you will magically appear in the station in your
20624                                                                          ; hyperspace destination, without having to go to the
20625                                                                          ; effort of actually flying there. This bug was fixed in
20626                                                                          ; later versions by saving the destination seeds in a
20627                                                                          ; separate location called safehouse, and using those
20628                                                                          ; instead... but that isn't the case in this version
20629               
20630 5F44 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
20631               
20632 5F46 15FA  14        jgt  TT112                      ; BPL TT112         ; Loop back to TT112 if we still have more bytes to
20633                                                                          ; copy
20634               
20635 5F48 B387  18        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X = &FF)
20636               
20637 5F4A D80E  30        movb rx,@EV                     ; STX EV            ; Set EV, the extra vessels spawning counter, to 0, as
     5F4C 0D63     
20638                                                                          ; we are entering a new system with no extra vessels
20639                                                                          ; spawned
20640               
20641 5F4E D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Set the current system's economy in QQ28 to the
     5F50 0F28     
20642 5F52 D80D  30        movb ra,@QQ28                   ; STA QQ28          ; selected system's economy from QQ3
     5F54 0F1A     
20643               
20644 5F56 D360  30        movb @QQ5,ra                    ; LDA QQ5           ; Set the current system's tech level in tek to the
     5F58 0F2A     
20645 5F5A D80D  30        movb ra,@tek_                   ; STA tek           ; selected system's economy from QQ5
     5F5C 0F1D     
20646               
20647 5F5E D360  30        movb @QQ4,ra                    ; LDA QQ4           ; Set the current system's government in gov to the
     5F60 0F29     
20648 5F62 D80D  30        movb ra,@gov_                   ; STA gov           ; selected system's government from QQ4
     5F64 0F1C     
20649               
20650 5F66 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5F68 FE2A     
20651               
20652               * ******************************************************************************
20653               *
20654               * Name: GVL
20655               * Type: Subroutine
20656               * Category: Universe
20657               * Summary: Calculate the availability of market items
20658               * Deep dive: Market item prices and availability
20659               * Galaxy and system seeds
20660               *
20661               * ------------------------------------------------------------------------------
20662               *
20663               * Calculate the availability for each market item and store it in AVL. This is
20664               * called on arrival in a new system.
20665               *
20666               * ------------------------------------------------------------------------------
20667               *
20668               * Other entry points:
20669               *
20670               * hyR                 Contains an RTS
20671               *
20672               * ******************************************************************************
20673               
20674               GVL:
20675 5F6A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     5F6C C07C     
20676 5F6E 06A0  32        bl   @jsr                       ;
     5F70 FE1E     
20677               
20678 5F72 D80D  30        movb ra,@QQ26                   ; STA QQ26          ; Set QQ26 to the random byte that's used in the market
     5F74 0346     
20679                                                                          ; calculations
20680               
20681 5F76 020E  20        li   rx,>00*256                 ; LDX #0            ; We are now going to loop through the market item
     5F78 0000     
20682 5F7A D80E  30        movb rx,@XX4                    ; STX XX4           ; availability table in AVL, so set a counter in XX4
     5F7C 00A7     
20683                                                                          ; (and X) for the market item number, starting with 0
20684               
20685               hy9_:
20686 5F7E D36E  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; Fetch byte #1 from the market prices table (units and
     5F80 CF2F     
20687 5F82 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; economic_factor) for item number X and store it in
     5F84 0080     
20688                                                                          ; QQ19+1
20689               
20690 5F86 0200  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     5F88 5EF6     
20691 5F8A 06A0  32        bl   @jsr                       ;
     5F8C FE1E     
20692                                                                          ; (and set the availability of alien items to 0)
20693               
20694 5F8E D36E  34        movb @QQ23+3(rx),ra             ; LDA QQ23+3,X      ; Fetch byte #3 from the market prices table (mask) and
     5F90 CF31     
20695                      .and @QQ26                      ; AND QQ26          ; AND with the random number for this system visit
     **** ****     > AND
0001 5F92 D020  30        movb @QQ26,rtmp
     5F94 0346     
0002 5F96 0540  14        inv  rtmp
0003 5F98 5340  18        szcb rtmp,ra
                   < elite.a99
20696                                                                          ; to give:
20697                                                                          ;
20698                                                                          ; A = random AND mask
20699               
20700                      .clc                            ; CLC               ; Add byte #2 from the market prices table
     **** ****     > CLC
0001 5F9A 0A16  18        sla  rzero,1
                   < elite.a99
20701                      .adc @QQ23+2(rx),ra             ; ADC QQ23+2,X      ; (base_quantity) so we now have:
     **** ****     > ADC
0001 5F9C 1701  14        jnc  !
0002 5F9E B347  18        ab   rone,ra
0003               !:
0004 5FA0 B36E  34        ab   @QQ23+2(RX),ra
     5FA2 CF30     
                   < elite.a99
20702                                                                          ;
20703                                                                          ; A = base_quantity + (random AND mask)
20704               
20705 5FA4 D3E0  30        movb @QQ19+1,ry                 ; LDY QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     5FA6 0080     
20706 5FA8 1107  14        jlt  TT157                      ; BMI TT157         ; TT157 if it is negative (i.e. if the economic_factor
20707                                                                          ; is negative)
20708               
20709                      .sec                            ; SEC               ; Set A = A - QQ19+3
     **** ****     > SEC
0001 5FAA 0A18  18        sla  rmone,1
                   < elite.a99
20710                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ;
     **** ****     > SBC
0001 5FAC 1801  14        joc  !
0002 5FAE 7347  18        sb   rone,ra
0003               !:
0004 5FB0 7360  30        sb   @QQ19+3,ra
     5FB2 0082     
                   < elite.a99
20711                                                                          ; = base_quantity + (random AND mask)
20712                                                                          ; - (economy * |economic_factor|)
20713                                                                          ;
20714                                                                          ; which is the result we want, as the economic_factor
20715                                                                          ; is positive
20716               
20717 5FB4 0460  28        b    @TT158                     ; JMP TT158         ; Jump to TT158 to skip TT157
     5FB6 5FC2     
20718               
20719               TT157:
20720                      .clc                            ; CLC               ; Set A = A + QQ19+3
     **** ****     > CLC
0001 5FB8 0A16  18        sla  rzero,1
                   < elite.a99
20721                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 5FBA 1701  14        jnc  !
0002 5FBC B347  18        ab   rone,ra
0003               !:
0004 5FBE B360  30        ab   @QQ19+3,ra
     5FC0 0082     
                   < elite.a99
20722                                                                          ; = base_quantity + (random AND mask)
20723                                                                          ; + (economy * |economic_factor|)
20724                                                                          ;
20725                                                                          ; which is the result we want, as the economic_factor
20726                                                                          ; is negative
20727               
20728               TT158:
20729 5FC2 1502  14        jgt  TT159                      ; BPL TT159         ; If A < 0, then set A = 0, so we don't have negative
20730 5FC4 020D  20        li   ra,>00*256                 ; LDA #0            ; availability
     5FC6 0000     
20731               
20732               TT159:
20733 5FC8 D3E0  30        movb @XX4,ry                    ; LDY XX4           ; Fetch the counter (the market item number) into Y
     5FCA 00A7     
20734               
20735 5FCC 024D  22        andi ra,>3f*256                 ; AND #%00111111    ; Take bits 0-5 of A, i.e. A mod 64, and store this as
     5FCE 3F00     
20736 5FD0 DBCD  38        movb ra,@AVL(ry)                ; STA AVL,Y         ; this item's availability in the Y=th byte of AVL, so
     5FD2 0335     
20737                                                                          ; each item has a maximum availability of 63t
20738               
20739 5FD4 B3C7  18        ab   rone,ry                    ; INY               ; Increment the counter into XX44, Y and A
20740 5FD6 D34F  18        movb ry,ra                      ; TYA
20741 5FD8 D80D  30        movb ra,@XX4                    ; STA XX4
     5FDA 00A7     
20742               
20743                      .asla                           ; ASL A             ; Set X = counter * 4, so that X points to the next
     **** ****     > ASLA
0001 5FDC 024D  22        andi ra,>ff00
     5FDE FF00     
0002 5FE0 0A1D  18        sla  ra,1
                   < elite.a99
20744                      .asla                           ; ASL A             ; item's entry in the four-byte market prices table,
     **** ****     > ASLA
0001 5FE2 024D  22        andi ra,>ff00
     5FE4 FF00     
0002 5FE6 0A1D  18        sla  ra,1
                   < elite.a99
20745 5FE8 D38D  18        movb ra,rx                      ; TAX               ; ready for the next loop
20746               
20747 5FEA 028D  22        ci   ra,>3f*256                 ; CMP #63           ; If A < 63, jump back up to hy9 to set the availability
     5FEC 3F00     
20748 5FEE 17C7  14        jnc  hy9_                       ; BCC hy9           ; for the next market item
20749               
20750               hyR:
20751 5FF0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5FF2 FE2A     
20752               
20753               * ******************************************************************************
20754               *
20755               * Name: GTHG
20756               * Type: Subroutine
20757               * Category: Universe
20758               * Summary: Spawn a Thargoid ship and a Thargon companion
20759               * Deep dive: Fixing ship positions
20760               *
20761               * ******************************************************************************
20762               
20763                      aorg CODE_UPPER.                                    ; TI-99/4A upper RAM code
20764               
20765               GTHG:
20766 A000 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK
     A002 C032     
20767 A004 06A0  32        bl   @jsr                       ;
     A006 FE1E     
20768                                                                          ;
20769                                                                          ; Note that because Ze uses the value of X returned by
20770                                                                          ; DORND, and X contains the value of A returned by the
20771                                                                          ; previous call to DORND, this does not set the new ship
20772                                                                          ; to a totally random location. See the deep dive on
20773                                                                          ; "Fixing ship positions" for details
20774               
20775 A008 020D  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set the AI flag in byte #32 so that the ship has AI,
     A00A FF00     
20776 A00C D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; is extremely and aggressively hostile, and has E.C.M.
     A00E 0073     
20777               
20778 A010 020D  20        li   ra,(THG)*256               ; LDA #THG          ; Call NWSHP to add a new Thargoid ship to our local
     A012 0600     
20779 A014 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; bubble of universe
     A016 AF7A     
20780 A018 06A0  32        bl   @jsr                       ;
     A01A FE1E     
20781               
20782 A01C 020D  20        li   ra,(TGL)*256               ; LDA #TGL          ; Call NWSHP to add a new Thargon ship to our local
     A01E 0C00     
20783 A020 0460  28        b    @NWSHP                     ; JMP NWSHP         ; bubble of universe, and return from the subroutine
     A022 AF7A     
20784                                                                          ; using a tail call
20785               
20786               * ******************************************************************************
20787               *
20788               * Name: MJP
20789               * Type: Subroutine
20790               * Category: Flight
20791               * Summary: Process a mis-jump into witchspace
20792               *
20793               * ------------------------------------------------------------------------------
20794               *
20795               * Process a mis-jump into witchspace (which happens very rarely). Witchspace has
20796               * a strange, almost dust-free aspect to it, and it is populated by hostile
20797               * Thargoids. Using our escape pod will be fatal, and our position on the
20798               * galactic chart is in-between systems. It is a scary place...
20799               *
20800               * There is a 0.78% chance that this routine is called from TT18 instead of doing
20801               * a normal hyperspace, or we can manually trigger a mis-jump by holding down
20802               * CTRL after first enabling the "author display" configuration option ("X") when
20803               * paused.
20804               *
20805               * ------------------------------------------------------------------------------
20806               *
20807               * Other entry points:
20808               *
20809               * ptg                 Called when the user manually forces a mis-jump
20810               *
20811               * ******************************************************************************
20812               
20813               ptg_:
20814                      .lsr @COK                       ; LSR COK           ; Set bit 0 of the competition flags in COK, so that the
     **** ****     > LSR
0001 A024 D020  30        movb @COK,rtmp
     A026 030E     
0002 A028 0910  18        srl  rtmp,1
0003 A02A D800  30        movb rtmp,@COK
     A02C 030E     
                   < elite.a99
20815                      .sec                            ; SEC               ; competition code will include the fact that we have
     **** ****     > SEC
0001 A02E 0A18  18        sla  rmone,1
                   < elite.a99
20816 A030 0204  20        li   rarg1,COK                  ; ROL COK           ; manually forced a mis-jump into witchspace
     A032 030E     
20817 A034 06A0  32        bl   @rol                       ;
     A036 FE44     
20818               
20819               MJP:
20820               * LDA #1                 \ This instruction is commented out in the original
20821                                                                          ; source - it is not required as a call to TT66-2 sets
20822                                                                          ; A to 1 for us. This is presumably an example of the
20823                                                                          ; authors saving a couple of bytes by calling TT66-2
20824                                                                          ; instead of TT66, while leaving the original LDA
20825                                                                          ; instruction in place
20826 A038 0200  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     A03A 4B28     
20827 A03C 06A0  32        bl   @jsr                       ;
     A03E FE1E     
20828                                                                          ; and set the current view type in QQ11 to 1
20829               
20830 A040 0200  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     A042 3E3C     
20831 A044 06A0  32        bl   @jsr                       ;
     A046 FE1E     
20832                                                                          ; hyperspace sound for a second time (as we already
20833                                                                          ; called LL164 in TT18)
20834               
20835 A048 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces, as
     A04A BF32     
20836 A04C 06A0  32        bl   @jsr                       ;
     A04E FE1E     
20837                                                                          ; well as setting Y to &FF
20838               
20839 A050 D80F  30        movb ry,@MJ                     ; STY MJ            ; Set the mis-jump flag in MJ to &FF, to indicate that
     A052 0D5C     
20840                                                                          ; we are now in witchspace
20841               
20842               MJP1:
20843 A054 0200  20        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     A056 A000     
20844 A058 06A0  32        bl   @jsr                       ;
     A05A FE1E     
20845                                                                          ; companion
20846               
20847 A05C 020D  20        li   ra,>03*256                 ; LDA #3            ; Fetch the number of Thargoid ships from MANY+THG, and
     A05E 0300     
20848 A060 9360  30        cb   @MANY+THG,ra               ; CMP MANY+THG      ; if it is less than or equal to 3, loop back to MJP1 to
     A062 0D53     
20849 A064 18F7  14        joc  MJP1                       ; BCS MJP1          ; spawn another one, until we have four Thargoids
20850               
20851 A066 D80D  30        movb ra,@NOSTM                  ; STA NOSTM         ; Set NOSTM (the maximum number of stardust particles)
     A068 0F33     
20852                                                                          ; to 3, so there are fewer bits of stardust in
20853                                                                          ; witchspace (normal space has a maximum of 18)
20854               
20855 A06A 020E  20        li   rx,>00*256                 ; LDX #0            ; Initialise the front space view
     A06C 0000     
20856 A06E 0200  20        li   rtmp,LOOK1                 ; JSR LOOK1
     A070 4AC4     
20857 A072 06A0  32        bl   @jsr                       ;
     A074 FE1E     
20858               
20859 A076 D360  30        movb @QQ1,ra                    ; LDA QQ1           ; Fetch the current system's galactic y-coordinate in
     A078 0302     
20860                      .eoi (>1f*256)                  ; EOR #%00011111    ; QQ1 and flip bits 0-5, so we end up somewhere in the
     **** ****     > EOI
0001 A07A 0200  20        li   rtmp,(>1F*256)
     A07C 1F00     
0002 A07E 2B40  18        xor  rtmp,ra
                   < elite.a99
20861 A080 D80D  30        movb ra,@QQ1                    ; STA QQ1           ; vicinity of our original destination, but above or
     A082 0302     
20862                                                                          ; below it in the galactic chart
20863               ptg1_:
20864 A084 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A086 FE2A     
20865               
20866               * ******************************************************************************
20867               *
20868               * Name: TT18
20869               * Type: Subroutine
20870               * Category: Flight
20871               * Summary: Try to initiate a jump into hyperspace
20872               *
20873               * ------------------------------------------------------------------------------
20874               *
20875               * Try to go through hyperspace. Called from TT102 in the main loop when the
20876               * hyperspace countdown has finished.
20877               *
20878               * ******************************************************************************
20879               
20880               TT18:
20881 A088 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Subtract the distance to the selected system (in QQ8)
     A08A 030D     
20882                      .sec                            ; SEC               ; from the amount of fuel in our tank (in QQ14) into A
     **** ****     > SEC
0001 A08C 0A18  18        sla  rmone,1
                   < elite.a99
20883                      .sbc @QQ8,ra                    ; SBC QQ8
     **** ****     > SBC
0001 A08E 1801  14        joc  !
0002 A090 7347  18        sb   rone,ra
0003               !:
0004 A092 7360  30        sb   @QQ8,ra
     A094 0F2F     
                   < elite.a99
20884               
20885 A096 D80D  30        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel amount in QQ14
     A098 030D     
20886               
20887 A09A D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, jump to ee5
     A09C 0096     
20888 A09E 1608  14        jne  ee5_                       ; BNE ee5           ; to skip the following
20889               
20890 A0A0 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     A0A2 4B2A     
20891 A0A4 06A0  32        bl   @jsr                       ;
     A0A6 FE1E     
20892                                                                          ; and set the current view type in QQ11 to 0 (space
20893                                                                          ; view)
20894               
20895 A0A8 0200  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     A0AA 3E3C     
20896 A0AC 06A0  32        bl   @jsr                       ;
     A0AE FE1E     
20897                                                                          ; hyperspace sound
20898               
20899               ee5_:
20900 A0B0 0200  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed,
     A0B2 CC24     
20901 A0B4 06A0  32        bl   @jsr                       ;
     A0B6 FE1E     
20902                                                                          ; returning a negative value in A if it is
20903               
20904                      .and @PATG                      ; AND PATG          ; If the game is configured to show the author's names
     **** ****     > AND
0001 A0B8 D020  30        movb @PATG,rtmp
     A0BA 0F4C     
0002 A0BC 0540  14        inv  rtmp
0003 A0BE 5340  18        szcb rtmp,ra
                   < elite.a99
20905                                                                          ; on the start-up screen, then PATG will contain &FF,
20906                                                                          ; otherwise it will be 0
20907               
20908 A0C0 11B1  14        jlt  ptg_                       ; BMI ptg           ; By now, A will be negative if we are holding down CTRL
20909                                                                          ; and author names are configured, which is what we have
20910                                                                          ; to do in order to trigger a manual mis-jump, so jump
20911                                                                          ; to ptg to do a mis-jump (ptg not only mis-jumps, but
20912                                                                          ; updates the competition flags, so Acornsoft could tell
20913                                                                          ; from the competition code whether this feature had
20914                                                                          ; been used)
20915               
20916 A0C2 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     A0C4 C07C     
20917 A0C6 06A0  32        bl   @jsr                       ;
     A0C8 FE1E     
20918               
20919 A0CA 028D  22        ci   ra,>fd*256                 ; CMP #253          ; If A >= 253 (0.78% chance) then jump to MJP to trigger
     A0CC FD00     
20920 A0CE 18B4  14        joc  MJP                        ; BCS MJP           ; a mis-jump into witchspace
20921               
20922               * JSR TT111              \ This instruction is commented out in the original
20923                                                                          ; source. It finds the closest system to coordinates
20924                                                                          ; (QQ9, QQ10), but we don't need to do this as the
20925                                                                          ; crosshairs will already be on a system by this point
20926               
20927 A0D0 0200  20        li   rtmp,hyp1_+3               ; JSR hyp1+3        ; Jump straight to the system at (QQ9, QQ10) without
     A0D2 5F2B     
20928 A0D4 06A0  32        bl   @jsr                       ;
     A0D6 FE1E     
20929                                                                          ; first calculating which system is closest
20930               
20931 A0D8 0200  20        li   rtmp,GVL                   ; JSR GVL           ; Calculate the availability for each market item in the
     A0DA 5F6A     
20932 A0DC 06A0  32        bl   @jsr                       ;
     A0DE FE1E     
20933                                                                          ; new system
20934               
20935 A0E0 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     A0E2 BF32     
20936 A0E4 06A0  32        bl   @jsr                       ;
     A0E6 FE1E     
20937               
20938 A0E8 0200  20        li   rtmp,SOLAR                 ; JSR SOLAR         ; Halve our legal status, update the missile indicators,
     A0EA AB72     
20939 A0EC 06A0  32        bl   @jsr                       ;
     A0EE FE1E     
20940                                                                          ; and set up data blocks and slots for the planet and
20941                                                                          ; sun
20942               
20943 A0F0 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view in QQ11 is not a space view (0) or
     A0F2 0096     
20944 A0F4 024D  22        andi ra,>3f*256                 ; AND #%00111111    ; one of the charts (64 or 128), return from the
     A0F6 3F00     
20945 A0F8 16C5  14        jne  ptg1_                      ; BNE ptg1          ; subroutine (as hyR contains an RTS)
20946               
20947 A0FA 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise clear the screen and draw a white border
     A0FC 4B2E     
20948 A0FE 06A0  32        bl   @jsr                       ;
     A100 FE1E     
20949               
20950 A102 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is one of the charts, jump to
     A104 0096     
20951 A106 1630  14        jne  TT114                      ; BNE TT114         ; TT114 (from which we jump to the correct routine to
20952                                                                          ; display the chart)
20953               
20954 A108 B347  18        ab   rone,ra                    ; INC QQ11          ; This is a space view, so increment QQ11 to 1
20955               
20956                                                                          ; Fall through into TT110 to show the front space view
20957               
20958               * ******************************************************************************
20959               *
20960               * Name: TT110
20961               * Type: Subroutine
20962               * Category: Flight
20963               * Summary: Launch from a station or show the front space view
20964               *
20965               * ------------------------------------------------------------------------------
20966               *
20967               * Launch the ship (if we are docked), or show the front space view (if we are
20968               * already in space).
20969               *
20970               * Called when red key f0 is pressed while docked (launch), after we arrive in a
20971               * new galaxy, or after a hyperspace if the current view is a space view.
20972               *
20973               * ******************************************************************************
20974               
20975               TT110:
20976 A10A D3A0  30        movb @QQ12,rx                   ; LDX QQ12          ; If we are not docked (QQ12 = 0) then jump to NLUNCH
     A10C 009F     
20977 A10E 1326  14        jeq  NLUNCH                     ; BEQ NLUNCH        ; to skip the launch tunnel and setup process
20978               
20979 A110 0200  20        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     A112 3E62     
20980 A114 06A0  32        bl   @jsr                       ;
     A116 FE1E     
20981               
20982 A118 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     A11A BF32     
20983 A11C 06A0  32        bl   @jsr                       ;
     A11E FE1E     
20984               
20985 A120 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     A122 5AB8     
20986 A124 06A0  32        bl   @jsr                       ;
     A126 FE1E     
20987                                                                          ; (QQ9, QQ10)
20988               
20989 A128 B347  18        ab   rone,ra                    ; INC INWK+8        ; Increment z_sign ready for the call to SOS, so the
20990                                                                          ; planet appears at a z_sign of 1 in front of us when
20991                                                                          ; we launch
20992               
20993 A12A 0200  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     A12C AB4E     
20994 A12E 06A0  32        bl   @jsr                       ;
     A130 FE1E     
20995                                                                          ; to FRIN, where it will get put in the first slot as
20996                                                                          ; it's the first one to be added to our local bubble of
20997                                                                          ; universe following the call to RES2 above
20998               
20999 A132 020D  20        li   ra,>80*256                 ; LDA #128          ; For the space station, set z_sign to &80, so it's
     A134 8000     
21000 A136 D80D  30        movb ra,@INWK+8                 ; STA INWK+8        ; behind us (&80 is negative)
     A138 005B     
21001               
21002 A13A B347  18        ab   rone,ra                    ; INC INWK+7        ; And increment z_hi, so it's only just behind us
21003               
21004 A13C 0200  20        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     A13E AF2A     
21005 A140 06A0  32        bl   @jsr                       ;
     A142 FE1E     
21006                                                                          ; universe
21007               
21008 A144 020D  20        li   ra,>0c*256                 ; LDA #12           ; Set our launch speed in DELTA to 12
     A146 0C00     
21009 A148 D80D  30        movb ra,@DELTA                  ; STA DELTA
     A14A 008C     
21010               
21011 A14C 0200  20        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     A14E C436     
21012 A150 06A0  32        bl   @jsr                       ;
     A152 FE1E     
21013                                                                          ; are carrying in our hold (A is up to 40 for a
21014                                                                          ; standard hold crammed with contraband, up to 70 for
21015                                                                          ; an extended cargo hold full of narcotics and slaves)
21016               
21017 A154 F360  30        socb @FIST,ra                   ; ORA FIST          ; OR the value in A with our legal status in FIST to
     A156 0334     
21018                                                                          ; get a new value that is at least as high as both
21019                                                                          ; values, to reflect the fact that launching with a
21020                                                                          ; hold full of contraband can only make matters worse
21021               
21022 A158 D80D  30        movb ra,@FIST                   ; STA FIST          ; Update our legal status with the new value
     A15A 0334     
21023               
21024               NLUNCH:
21025 A15C 020E  20        li   rx,>00*256                 ; LDX #0            ; Set QQ12 to 0 to indicate we are not docked
     A15E 0000     
21026 A160 D80E  30        movb rx,@QQ12                   ; STX QQ12
     A162 009F     
21027               
21028 A164 0460  28        b    @LOOK1                     ; JMP LOOK1         ; Jump to LOOK1 to switch to the front view (X = 0),
     A166 4AC4     
21029                                                                          ; returning from the subroutine using a tail call
21030               
21031               * ******************************************************************************
21032               *
21033               * Name: TT114
21034               * Type: Subroutine
21035               * Category: Charts
21036               * Summary: Display either the Long-range or Short-range Chart
21037               *
21038               * ------------------------------------------------------------------------------
21039               *
21040               * Display either the Long-range or Short-range Chart, depending on the current
21041               * view setting. Called from TT18 once we know the current view is one of the
21042               * charts.
21043               *
21044               * ------------------------------------------------------------------------------
21045               *
21046               * Arguments:
21047               *
21048               * A                   The current view, loaded from QQ11
21049               *
21050               * ******************************************************************************
21051               
21052               TT114:
21053 A168 1102  14        jlt  TT115                      ; BMI TT115         ; If bit 7 of the current view is set (i.e. the view is
21054                                                                          ; the Short-range Chart, 128), skip to TT115 below to
21055                                                                          ; jump to TT23 to display the chart
21056               
21057 A16A 0460  28        b    @TT22                      ; JMP TT22          ; Otherwise the current view is the Long-range Chart, so
     A16C 5272     
21058                                                                          ; jump to TT22 to display it
21059               
21060               TT115:
21061 A16E 0460  28        b    @TT23                      ; JMP TT23          ; Jump to TT23 to display the Short-range Chart
     A170 592A     
21062               
21063               * ******************************************************************************
21064               *
21065               * Name: LCASH
21066               * Type: Subroutine
21067               * Category: Maths (Arithmetic)
21068               * Summary: Subtract an amount of cash from the cash pot
21069               *
21070               * ------------------------------------------------------------------------------
21071               *
21072               * Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
21073               * cash in the pot. As CASH is a four-byte number, this calculates:
21074               *
21075               * CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
21076               *
21077               * ------------------------------------------------------------------------------
21078               *
21079               * Returns:
21080               *
21081               * C flag              If set, there was enough cash to do the subtraction
21082               *
21083               * If clear, there was not enough cash to do the
21084               * subtraction
21085               *
21086               * ******************************************************************************
21087               
21088               LCASH:
21089 A172 D80E  30        movb rx,@T1                     ; STX T1            ; Subtract the least significant bytes:
     A174 0006     
21090 A176 D360  30        movb @CASH+3,ra                 ; LDA CASH+3        ;
     A178 030C     
21091                      .sec                            ; SEC               ; CASH+3 = CASH+3 - X
     **** ****     > SEC
0001 A17A 0A18  18        sla  rmone,1
                   < elite.a99
21092                      .sbc @T1,ra                     ; SBC T1
     **** ****     > SBC
0001 A17C 1801  14        joc  !
0002 A17E 7347  18        sb   rone,ra
0003               !:
0004 A180 7360  30        sb   @T1,ra
     A182 0006     
                   < elite.a99
21093 A184 D80D  30        movb ra,@CASH+3                 ; STA CASH+3
     A186 030C     
21094               
21095 A188 D80F  30        movb ry,@T1                     ; STY T1            ; Then the second most significant bytes:
     A18A 0006     
21096 A18C D360  30        movb @CASH+2,ra                 ; LDA CASH+2        ;
     A18E 030B     
21097                      .sbc @T1,ra                     ; SBC T1            ; CASH+2 = CASH+2 - Y
     **** ****     > SBC
0001 A190 1801  14        joc  !
0002 A192 7347  18        sb   rone,ra
0003               !:
0004 A194 7360  30        sb   @T1,ra
     A196 0006     
                   < elite.a99
21098 A198 D80D  30        movb ra,@CASH+2                 ; STA CASH+2
     A19A 030B     
21099               
21100 A19C D360  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     A19E 030A     
21101                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A1A0 1801  14        joc  !
0002 A1A2 7347  18        sb   rone,ra
0003               !:
0004 A1A4 022D  22        ai   ra,-(>00*256)
     A1A6 0000     
                   < elite.a99
21102 A1A8 D80D  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 - 0
     A1AA 030A     
21103               
21104 A1AC D360  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     A1AE 0309     
21105                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A1B0 1801  14        joc  !
0002 A1B2 7347  18        sb   rone,ra
0003               !:
0004 A1B4 022D  22        ai   ra,-(>00*256)
     A1B6 0000     
                   < elite.a99
21106 A1B8 D80D  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH - 0
     A1BA 0309     
21107               
21108 A1BC 1820  14        joc  TT113                      ; BCS TT113         ; If the C flag is set then the subtraction didn't
21109                                                                          ; underflow, so the value in CASH is correct and we can
21110                                                                          ; jump to TT113 to return from the subroutine with the
21111                                                                          ; C flag set to indicate success (as TT113 contains an
21112                                                                          ; RTS)
21113               
21114                                                                          ; Otherwise we didn't have enough cash in CASH to
21115                                                                          ; subtract (Y X) from it, so fall through into
21116                                                                          ; MCASH to reverse the sum and restore the original
21117                                                                          ; value in CASH, and returning with the C flag clear
21118               
21119               * ******************************************************************************
21120               *
21121               * Name: MCASH
21122               * Type: Subroutine
21123               * Category: Maths (Arithmetic)
21124               * Summary: Add an amount of cash to the cash pot
21125               *
21126               * ------------------------------------------------------------------------------
21127               *
21128               * Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
21129               * calculates:
21130               *
21131               * CASH(0 1 2 3) = CASH(0 1 2 3) + (Y X)
21132               *
21133               * ------------------------------------------------------------------------------
21134               *
21135               * Other entry points:
21136               *
21137               * TT113               Contains an RTS
21138               *
21139               * ******************************************************************************
21140               
21141               MCASH:
21142 A1BE D34E  18        movb rx,ra                      ; TXA               ; Add the least significant bytes:
21143                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 A1C0 0A16  18        sla  rzero,1
                   < elite.a99
21144                      .adc @CASH+3,ra                 ; ADC CASH+3        ; CASH+3 = CASH+3 + X
     **** ****     > ADC
0001 A1C2 1701  14        jnc  !
0002 A1C4 B347  18        ab   rone,ra
0003               !:
0004 A1C6 B360  30        ab   @CASH+3,ra
     A1C8 030C     
                   < elite.a99
21145 A1CA D80D  30        movb ra,@CASH+3                 ; STA CASH+3
     A1CC 030C     
21146               
21147 A1CE D34F  18        movb ry,ra                      ; TYA               ; Then the second most significant bytes:
21148                      .adc @CASH+2,ra                 ; ADC CASH+2        ;
     **** ****     > ADC
0001 A1D0 1701  14        jnc  !
0002 A1D2 B347  18        ab   rone,ra
0003               !:
0004 A1D4 B360  30        ab   @CASH+2,ra
     A1D6 030B     
                   < elite.a99
21149 A1D8 D80D  30        movb ra,@CASH+2                 ; STA CASH+2        ; CASH+2 = CASH+2 + Y
     A1DA 030B     
21150               
21151 A1DC D360  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     A1DE 030A     
21152                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 A1E0 1701  14        jnc  !
0002 A1E2 B347  18        ab   rone,ra
0003               !:
0004 A1E4 022D  22        ai   ra,(>00*256)
     A1E6 0000     
                   < elite.a99
21153 A1E8 D80D  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 + 0
     A1EA 030A     
21154               
21155 A1EC D360  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     A1EE 0309     
21156                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 A1F0 1701  14        jnc  !
0002 A1F2 B347  18        ab   rone,ra
0003               !:
0004 A1F4 022D  22        ai   ra,(>00*256)
     A1F6 0000     
                   < elite.a99
21157 A1F8 D80D  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH + 0
     A1FA 0309     
21158               
21159                      .clc                            ; CLC               ; Clear the C flag, so if the above was done following
     **** ****     > CLC
0001 A1FC 0A16  18        sla  rzero,1
                   < elite.a99
21160                                                                          ; a failed LCASH call, the C flag correctly indicates
21161                                                                          ; failure
21162               
21163               TT113:
21164 A1FE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A200 FE2A     
21165               
21166               * ******************************************************************************
21167               *
21168               * Name: GCASH
21169               * Type: Subroutine
21170               * Category: Maths (Arithmetic)
21171               * Summary: Calculate (Y X) = P * Q * 4
21172               *
21173               * ------------------------------------------------------------------------------
21174               *
21175               * Calculate the following multiplication of unsigned 8-bit numbers:
21176               *
21177               * (Y X) = P * Q * 4
21178               *
21179               * ******************************************************************************
21180               
21181               GCASH:
21182 A202 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate (A P) = P * Q
     A204 42DE     
21183 A206 06A0  32        bl   @jsr                       ;
     A208 FE1E     
21184               
21185               * ******************************************************************************
21186               *
21187               * Name: GC2
21188               * Type: Subroutine
21189               * Category: Maths (Arithmetic)
21190               * Summary: Calculate (Y X) = (A P) * 4
21191               *
21192               * ------------------------------------------------------------------------------
21193               *
21194               * Calculate the following multiplication of unsigned 16-bit numbers:
21195               *
21196               * (Y X) = (A P) * 4
21197               *
21198               * ******************************************************************************
21199               
21200               GC2:
21201                      .asl @P                         ; ASL P             ; Set (A P) = (A P) * 4
     **** ****     > ASL
0001 A20A D020  30        movb @P,rtmp
     A20C 001B     
0002 A20E 0240  22        andi rtmp,>ff00
     A210 FF00     
0003 A212 0A10  18        sla  rtmp,1
0004 A214 D800  30        movb rtmp,@P
     A216 001B     
                   < elite.a99
21202 A218 06A0  32        bl   @rola                      ; ROL A
     A21A FE34     
21203                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 A21C D020  30        movb @P,rtmp
     A21E 001B     
0002 A220 0240  22        andi rtmp,>ff00
     A222 FF00     
0003 A224 0A10  18        sla  rtmp,1
0004 A226 D800  30        movb rtmp,@P
     A228 001B     
                   < elite.a99
21204 A22A 06A0  32        bl   @rola                      ; ROL A
     A22C FE34     
21205               
21206 A22E D3CD  18        movb ra,ry                      ; TAY               ; Set (Y X) = (A P)
21207 A230 D3A0  30        movb @P,rx                      ; LDX P
     A232 001B     
21208               
21209 A234 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A236 FE2A     
21210               
21211               * ******************************************************************************
21212               *
21213               * Name: EQSHP
21214               * Type: Subroutine
21215               * Category: Equipment
21216               * Summary: Show the Equip Ship screen (red key f3)
21217               *
21218               * ------------------------------------------------------------------------------
21219               *
21220               * Other entry points:
21221               *
21222               * err                 Beep, pause and go to the docking bay (i.e. show the
21223               * Status Mode screen)
21224               *
21225               * pres                Given an item number A with the item name in recursive
21226               * token Y, show an error to say that the item is already
21227               * present, refund the cost of the item, and then beep and
21228               * exit to the docking bay (i.e. show the Status Mode
21229               * screen)
21230               *
21231               * ******************************************************************************
21232               
21233               bay_:
21234 A238 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     A23A C65C     
21235                                                                          ; screen)
21236               
21237               EQSHP:
21238 A23C 0200  20        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     A23E 3272     
21239 A240 06A0  32        bl   @jsr                       ;
     A242 FE1E     
21240               
21241 A244 020D  20        li   ra,>20*256                 ; LDA #32           ; Clear the top part of the screen, draw a white border,
     A246 2000     
21242 A248 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Equip
     A24A 4B2A     
21243 A24C 06A0  32        bl   @jsr                       ;
     A24E FE1E     
21244                                                                          ; Ship screen)
21245               
21246 A250 020D  20        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12
     A252 0C00     
21247 A254 D80D  30        movb ra,@XC                     ; STA XC
     A256 002C     
21248               
21249 A258 020D  20        li   ra,>cf*256                 ; LDA #207          ; Print recursive token 47 ("EQUIP") followed by a space
     A25A CF00     
21250 A25C 0200  20        li   rtmp,spc_                  ; JSR spc
     A25E 4EFE     
21251 A260 06A0  32        bl   @jsr                       ;
     A262 FE1E     
21252               
21253 A264 020D  20        li   ra,>b9*256                 ; LDA #185          ; Print recursive token 25 ("SHIP") and draw a
     A266 B900     
21254 A268 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; horizontal line at pixel row 19 to box in the title
     A26A 25B0     
21255 A26C 06A0  32        bl   @jsr                       ;
     A26E FE1E     
21256               
21257 A270 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     A272 8000     
21258 A274 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     A276 007E     
21259               
21260 A278 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21261               
21262 A27A D360  30        movb @tek_,ra                   ; LDA tek           ; Fetch the tech level of the current system from tek
     A27C 0F1D     
21263                      .clc                            ; CLC               ; and add 3 (the tech level is stored as 0-14, so A is
     **** ****     > CLC
0001 A27E 0A16  18        sla  rzero,1
                   < elite.a99
21264                      .adi (>03*256)                  ; ADC #3            ; now set to between 3 and 17)
     **** ****     > ADI
0001 A280 1701  14        jnc  !
0002 A282 B347  18        ab   rone,ra
0003               !:
0004 A284 022D  22        ai   ra,(>03*256)
     A286 0300     
                   < elite.a99
21265               
21266 A288 028D  22        ci   ra,>0c*256                 ; CMP #12           ; If A >= 12 then set A = 12, so A is now set to between
     A28A 0C00     
21267 A28C 1702  14        jnc  B58                        ; BCC B58           ; 3 and 12
21268 A28E 020D  20        li   ra,>0c*256                 ; LDA #12
     A290 0C00     
21269               
21270               B58:
21271 A292 D80D  30        movb ra,@Q                      ; STA Q             ; Set QQ25 = A (so QQ25 is in the range 3-12 and
     A294 0090     
21272 A296 D80D  30        movb ra,@QQ25                   ; STA QQ25          ; represents number of the most advanced item available
     A298 0F19     
21273 A29A B347  18        ab   rone,ra                    ; INC Q             ; in this system, which we can pass to gnum below when
21274                                                                          ; asking which item we want to buy)
21275                                                                          ;
21276                                                                          ; Set Q = A + 1 (so Q is in the range 4-13 and contains
21277                                                                          ; QQ25 + 1, i.e. the highest item number on sale + 1)
21278               
21279 A29C 020D  20        li   ra,>46*256                 ; LDA #70           ; Set A = 70 - QQ14, where QQ14 contains the current
     A29E 4600     
21280                      .sec                            ; SEC               ; fuel in light years * 10, so this leaves the amount
     **** ****     > SEC
0001 A2A0 0A18  18        sla  rmone,1
                   < elite.a99
21281                      .sbc @QQ14,ra                   ; SBC QQ14          ; of fuel we need to fill 'er up (in light years * 10)
     **** ****     > SBC
0001 A2A2 1801  14        joc  !
0002 A2A4 7347  18        sb   rone,ra
0003               !:
0004 A2A6 7360  30        sb   @QQ14,ra
     A2A8 030D     
                   < elite.a99
21282               
21283                      .asla                           ; ASL A             ; The price of fuel is always 2 Cr per light year, so we
     **** ****     > ASLA
0001 A2AA 024D  22        andi ra,>ff00
     A2AC FF00     
0002 A2AE 0A1D  18        sla  ra,1
                   < elite.a99
21284 A2B0 D80D  38        movb ra,@PRXS                   ; STA PRXS          ; double A and store it in PRXS, as the first price in
     A2B2 2DF0     
21285                                                                          ; the price list (which is reserved for fuel), and
21286                                                                          ; because the table contains prices as price * 10, it's
21287                                                                          ; in the right format (so tank containing 7.0 light
21288                                                                          ; years of fuel would be 14.0 Cr, or a PRXS value of
21289                                                                          ; 140)
21290               
21291 A2B4 020E  20        li   rx,>01*256                 ; LDX #1            ; We are now going to work our way through the equipment
     A2B6 0100     
21292                                                                          ; price list at PRXS, printing out the equipment that is
21293                                                                          ; available at this station, so set a counter in X,
21294                                                                          ; starting at 1, to hold the number of the current item
21295                                                                          ; plus 1 (so the item number in X loops through 1-13)
21296               
21297               EQL1:
21298 A2B8 D80E  30        movb rx,@XX13                   ; STX XX13          ; Store the current item number + 1 in XX13
     A2BA 0098     
21299               
21300 A2BC 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     A2BE 4EE6     
21301 A2C0 06A0  32        bl   @jsr                       ;
     A2C2 FE1E     
21302               
21303 A2C4 D3A0  30        movb @XX13,rx                   ; LDX XX13          ; Print the current item number + 1 to 3 digits, left-
     A2C6 0098     
21304                      .clc                            ; CLC               ; padding with spaces, and with no decimal point, so the
     **** ****     > CLC
0001 A2C8 0A16  18        sla  rzero,1
                   < elite.a99
21305 A2CA 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; items are numbered from 1
     A2CC 2FAC     
21306 A2CE 06A0  32        bl   @jsr                       ;
     A2D0 FE1E     
21307               
21308 A2D2 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     A2D4 5E64     
21309 A2D6 06A0  32        bl   @jsr                       ;
     A2D8 FE1E     
21310               
21311 A2DA D360  30        movb @XX13,ra                   ; LDA XX13          ; Print recursive token 104 + XX13, which will be in the
     A2DC 0098     
21312                      .clc                            ; CLC               ; range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
     **** ****     > CLC
0001 A2DE 0A16  18        sla  rzero,1
                   < elite.a99
21313                      .adi (>68*256)                  ; ADC #104          ; so this prints the current item's name
     **** ****     > ADI
0001 A2E0 1701  14        jnc  !
0002 A2E2 B347  18        ab   rone,ra
0003               !:
0004 A2E4 022D  22        ai   ra,(>68*256)
     A2E6 6800     
                   < elite.a99
21314 A2E8 0200  20        li   rtmp,TT27                  ; JSR TT27
     A2EA A6E8     
21315 A2EC 06A0  32        bl   @jsr                       ;
     A2EE FE1E     
21316               
21317 A2F0 D360  30        movb @XX13,ra                   ; LDA XX13          ; Call prx-3 to set (Y X) to the price of the item with
     A2F2 0098     
21318 A2F4 0200  20        li   rtmp,prx_-3                ; JSR prx-3         ; number XX13 - 1 (as XX13 contains the item number + 1)
     A2F6 A521     
21319 A2F8 06A0  32        bl   @jsr                       ;
     A2FA FE1E     
21320               
21321                      .sec                            ; SEC               ; Set the C flag so we will print a decimal point when
     **** ****     > SEC
0001 A2FC 0A18  18        sla  rmone,1
                   < elite.a99
21322                                                                          ; we print the price
21323               
21324 A2FE 020D  20        li   ra,>19*256                 ; LDA #25           ; Move the text cursor to column 25
     A300 1900     
21325 A302 D80D  30        movb ra,@XC                     ; STA XC
     A304 002C     
21326               
21327 A306 020D  20        li   ra,>06*256                 ; LDA #6            ; Print the number in (Y X) to 6 digits, left-padding
     A308 0600     
21328 A30A 0200  20        li   rtmp,TT11                  ; JSR TT11          ; with spaces and including a decimal point, which will
     A30C 2FB4     
21329 A30E 06A0  32        bl   @jsr                       ;
     A310 FE1E     
21330                                                                          ; be the correct price for this item as (Y X) contains
21331                                                                          ; the price * 10, so the trailing zero will go after the
21332                                                                          ; decimal point (i.e. 5250 will be printed as 525.0)
21333               
21334 A312 D3A0  30        movb @XX13,rx                   ; LDX XX13          ; Increment the current item number in XX13
     A314 0098     
21335 A316 B387  18        ab   rone,rx                    ; INX
21336               
21337 A318 93A0  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, loop back up to print the next item on the
     A31A 0090     
21338 A31C 17CD  14        jnc  EQL1                       ; BCC EQL1          ; list of equipment available at this station
21339               
21340 A31E 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     A320 4C2E     
21341 A322 06A0  32        bl   @jsr                       ;
     A324 FE1E     
21342                                                                          ; and move the text cursor to column 1 on row 21, i.e.
21343                                                                          ; the start of the top row of the three bottom rows
21344               
21345 A326 020D  20        li   ra,>7f*256                 ; LDA #127          ; Print recursive token 127 ("ITEM") followed by a
     A328 7F00     
21346 A32A 0200  20        li   rtmp,prq_                  ; JSR prq           ; question mark
     A32C 5D52     
21347 A32E 06A0  32        bl   @jsr                       ;
     A330 FE1E     
21348               
21349 A332 0200  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     A334 55CE     
21350 A336 06A0  32        bl   @jsr                       ;
     A338 FE1E     
21351                                                                          ; will be the number of the item we want to purchase,
21352                                                                          ; returning the number entered in A and R, and setting
21353                                                                          ; the C flag if the number is bigger than the highest
21354                                                                          ; item number in QQ25
21355               
21356 A33A 1602  14        jne  FIX004                     ; BNE FIX004        ; If no number was entered, jump up to bay to go to the
21357                                                                          ; docking bay (i.e. show the Status Mode screen)
21358 A33C 0460  28        b    @bay_                      ; JMP bay
     A33E A238     
21359               FIX004:
21360 A340 1702  14        jnc  FIX005                     ; BCC FIX005        ; If the number entered was too big, jump up to bay to
21361                                                                          ; go to the docking bay (i.e. show the Status Mode
21362                                                                          ; screen)
21363 A342 0460  28        b    @bay_                      ; JMP bay
     A344 A238     
21364               FIX005:
21365                      .sbi (>00*256)                  ; SBC #0            ; Set A to the number entered - 1 (because the C flag is
     **** ****     > SBI
0001 A346 1801  14        joc  !
0002 A348 7347  18        sb   rone,ra
0003               !:
0004 A34A 022D  22        ai   ra,-(>00*256)
     A34C 0000     
                   < elite.a99
21366                                                                          ; clear), which will be the actual item number we want
21367                                                                          ; to buy
21368               
21369 A34E 020E  20        li   rx,>02*256                 ; LDX #2            ; Move the text cursor to column 2
     A350 0200     
21370 A352 D80E  30        movb rx,@XC                     ; STX XC
     A354 002C     
21371               
21372 A356 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21373               
21374                      .pha                            ; PHA               ; While preserving the value in A, call eq to subtract
     **** ****     > PHA
0001 A358 D68D  30        movb ra,*rsp
0002 A35A 060A  14        dec  rsp
                   < elite.a99
21375 A35C 0200  20        li   rtmp,eq_                   ; JSR eq            ; the price of the item we want to buy (which is in A)
     A35E A4F8     
21376 A360 06A0  32        bl   @jsr                       ;
     A362 FE1E     
21377                      .pla                            ; PLA               ; from our cash pot, but only if we have enough cash in
     **** ****     > PLA
0001 A364 058A  14        inc  rsp
0002 A366 D35A  26        movb *rsp,ra
                   < elite.a99
21378                                                                          ; the pot. If we don't have enough cash, exit to the
21379                                                                          ; docking bay (i.e. show the Status Mode screen)
21380               
21381 A368 1606  14        jne  et0_                       ; BNE et0           ; If A is not 0 (i.e. the item we've just bought is not
21382                                                                          ; fuel), skip to et0
21383               
21384 A36A D80D  30        movb ra,@MCNT                   ; STA MCNT          ; We just bought fuel, so we zero the main loop counter
     A36C 0099     
21385               
21386 A36E 020E  20        li   rx,>46*256                 ; LDX #70           ; Set the current fuel level * 10 in QQ14 to 70, or 7.0
     A370 4600     
21387 A372 D80E  30        movb rx,@QQ14                   ; STX QQ14          ; light years (a full tank)
     A374 030D     
21388               
21389               et0_:
21390 A376 028D  22        ci   ra,>01*256                 ; CMP #1            ; If A is not 1 (i.e. the item we've just bought is not
     A378 0100     
21391 A37A 160E  14        jne  et1_                       ; BNE et1           ; a missile), skip to et1
21392               
21393 A37C D3A0  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Fetch the current number of missiles from NOMSL into X
     A37E 0333     
21394               
21395 A380 B387  18        ab   rone,rx                    ; INX               ; Increment X to the new number of missiles
21396               
21397 A382 020F  20        li   ry,>75*256                 ; LDY #117          ; Set Y to recursive token 117 ("ALL")
     A384 7500     
21398               
21399 A386 028E  22        ci   rx,>05*256                 ; CPX #5            ; If buying this missile would give us 5 missiles, this
     A388 0500     
21400 A38A 1856  14        joc  pres_                      ; BCS pres          ; is more than the maximum of 4 missiles that we can
21401                                                                          ; fit, so jump to pres to show the error "All Present",
21402                                                                          ; beep and exit to the docking bay (i.e. show the Status
21403                                                                          ; Mode screen)
21404               
21405 A38C D80E  30        movb rx,@NOMSL                  ; STX NOMSL         ; Otherwise update the number of missiles in NOMSL
     A38E 0333     
21406               
21407 A390 0200  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     A392 BFE8     
21408 A394 06A0  32        bl   @jsr                       ;
     A396 FE1E     
21409                                                                          ; them are targeted
21410               
21411               et1_:
21412 A398 020F  20        li   ry,>6b*256                 ; LDY #107          ; Set Y to recursive token 107 ("LARGE CARGO{sentence
     A39A 6B00     
21413                                                                          ; case} BAY")
21414               
21415 A39C 028D  22        ci   ra,>02*256                 ; CMP #2            ; If A is not 2 (i.e. the item we've just bought is not
     A39E 0200     
21416 A3A0 1607  14        jne  et2_                       ; BNE et2           ; a large cargo bay), skip to et2
21417               
21418 A3A2 020E  20        li   rx,>25*256                 ; LDX #37           ; If our current cargo capacity in CRGO is 37, then we
     A3A4 2500     
21419 A3A6 93A0  30        cb   @CRGO,rx                   ; CPX CRGO          ; already have a large cargo bay fitted, so jump to pres
     A3A8 0316     
21420 A3AA 1346  14        jeq  pres_                      ; BEQ pres          ; to show the error "Large Cargo Bay Present", beep and
21421                                                                          ; exit to the docking bay (i.e. show the Status Mode
21422                                                                          ; screen)
21423               
21424 A3AC D80E  30        movb rx,@CRGO                   ; STX CRGO          ; Otherwise we just scored ourselves a large cargo bay,
     A3AE 0316     
21425                                                                          ; so update our current cargo capacity in CRGO to 37
21426               
21427               et2_:
21428 A3B0 028D  22        ci   ra,>03*256                 ; CMP #3            ; If A is not 3 (i.e. the item we've just bought is not
     A3B2 0300     
21429 A3B4 1605  14        jne  et3_                       ; BNE et3           ; an E.C.M. system), skip to et3
21430               
21431 A3B6 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 108 ("E.C.M.SYSTEM")
21432               
21433 A3B8 D3A0  30        movb @ECM,rx                    ; LDX ECM           ; If we already have an E.C.M. fitted (i.e. ECM is
     A3BA 0328     
21434 A3BC 163D  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "E.C.M.
21435                                                                          ; System Present", beep and exit to the docking bay
21436                                                                          ; (i.e. show the Status Mode screen)
21437               
21438 A3BE 7347  18        sb   rone,ra                    ; DEC ECM           ; Otherwise we just took delivery of a brand new E.C.M.
21439                                                                          ; system, so set ECM to &FF (as ECM was 0 before the DEC
21440                                                                          ; instruction)
21441               
21442               et3_:
21443 A3C0 028D  22        ci   ra,>04*256                 ; CMP #4            ; If A is not 4 (i.e. the item we've just bought is not
     A3C2 0400     
21444 A3C4 1612  14        jne  et4_                       ; BNE et4           ; an extra pulse laser), skip to et4
21445               
21446 A3C6 0200  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     A3C8 A53A     
21447 A3CA 06A0  32        bl   @jsr                       ;
     A3CC FE1E     
21448                                                                          ; prompt, and ask for a view number, which is returned
21449                                                                          ; in X (which now contains 0-3)
21450               
21451 A3CE 020D  20        li   ra,>04*256                 ; LDA #4            ; This instruction doesn't appear to do anything, as we
     A3D0 0400     
21452                                                                          ; either don't need it (if we already have this laser)
21453                                                                          ; or we set A to 4 below (if we buy it)
21454               
21455 A3D2 D3EE  34        movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     A3D4 0310     
21456 A3D6 1303  14        jeq  ed4_                       ; BEQ ed4           ; LASER+X, which contains the laser power for view X, is
21457                                                                          ; zero), jump to ed4 to buy a pulse laser
21458               
21459               ed7_:
21460 A3D8 020F  20        li   ry,>bb*256                 ; LDY #187          ; Otherwise we already have a laser mounted in this
     A3DA BB00     
21461 A3DC 162D  14        jne  pres_                      ; BNE pres          ; view, so jump to pres with Y set to token 27
21462                                                                          ; (" LASER") to show the error "Laser Present", beep
21463                                                                          ; and exit to the docking bay (i.e. show the Status
21464                                                                          ; Mode screen)
21465               
21466               ed4_:
21467 A3DE 020D  20        li   ra,(POW)*256               ; LDA #POW          ; We just bought a pulse laser for view X, so we need
     A3E0 0F00     
21468 A3E2 DB8D  38        movb ra,@LASER(rx)              ; STA LASER,X       ; to fit it by storing the laser power for a pulse laser
     A3E4 0310     
21469                                                                          ; (given in POW) in LASER+X
21470               
21471 A3E6 020D  20        li   ra,>04*256                 ; LDA #4            ; Set A to 4 as we just overwrote the original value,
     A3E8 0400     
21472                                                                          ; and we still need it set correctly so we can continue
21473                                                                          ; through the conditional statements for all the other
21474                                                                          ; equipment
21475               
21476               et4_:
21477 A3EA 028D  22        ci   ra,>05*256                 ; CMP #5            ; If A is not 5 (i.e. the item we've just bought is not
     A3EC 0500     
21478 A3EE 161C  14        jne  et5_                       ; BNE et5           ; an extra beam laser), skip to et5
21479               
21480 A3F0 0200  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     A3F2 A53A     
21481 A3F4 06A0  32        bl   @jsr                       ;
     A3F6 FE1E     
21482                                                                          ; prompt, and ask for a view number, which is returned
21483                                                                          ; in X (which now contains 0-3)
21484               
21485 A3F8 D80E  30        movb rx,@T1                     ; STX T1            ; Store the view in T1 so we can retrieve it below
     A3FA 0006     
21486               
21487 A3FC 020D  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 as the call to qv will have overwritten
     A3FE 0500     
21488                                                                          ; the original value, and we still need it set
21489                                                                          ; correctly so we can continue through the conditional
21490                                                                          ; statements for all the other equipment
21491               
21492 A400 D3EE  34        movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     A402 0310     
21493 A404 130B  14        jeq  ed5_                       ; BEQ ed5           ; LASER+X, which contains the laser power for view X,
21494                                                                          ; is zero), jump to ed5 to buy a beam laser
21495               
21496               * BPL P%+4               \ This instruction is commented out in the original
21497                                                                          ; source, though it would have no effect (it would
21498                                                                          ; simply skip the BMI if A is positive, which is what
21499                                                                          ; BMI does anyway)
21500               
21501 A406 11E8  14        jlt  ed7_                       ; BMI ed7           ; If there is a beam laser already mounted in the chosen
21502                                                                          ; view (i.e. LASER+X has bit 7 set, which indicates a
21503                                                                          ; beam laser rather than a pulse laser), skip back to
21504                                                                          ; ed7 to print a "Laser Present" error, beep and exit
21505                                                                          ; to the docking bay (i.e. show the Status Mode screen)
21506               
21507 A408 020D  20        li   ra,>04*256                 ; LDA #4            ; If we get here then we already have a pulse laser in
     A40A 0400     
21508 A40C 0200  20        li   rtmp,prx_                  ; JSR prx           ; the selected view, so we call prx to set (Y X) to the
     A40E A524     
21509 A410 06A0  32        bl   @jsr                       ;
     A412 FE1E     
21510                                                                          ; price of equipment item number 4 (extra pulse laser)
21511                                                                          ; so we can give a refund of the pulse laser
21512               
21513 A414 0200  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, so we refund
     A416 A1BE     
21514 A418 06A0  32        bl   @jsr                       ;
     A41A FE1E     
21515                                                                          ; the price of the pulse laser we are exchanging for a
21516                                                                          ; new beam laser
21517               
21518               ed5_:
21519 A41C 020D  20        li   ra,(POW+128)*256           ; LDA #POW+128      ; We just bought a beam laser for view X, so we need
     A41E 8F00     
21520 A420 D3A0  30        movb @T1,rx                     ; LDX T1            ; to fit it by storing the laser power for a beam laser
     A422 0006     
21521 A424 DB8D  38        movb ra,@LASER(rx)              ; STA LASER,X       ; (given in POW+128) in LASER+X, using the view number
     A426 0310     
21522                                                                          ; we stored in T1 earlier, as the call to prx will have
21523                                                                          ; overwritten the original value in X
21524               
21525               et5_:
21526 A428 020F  20        li   ry,>6f*256                 ; LDY #111          ; Set Y to recursive token 107 ("FUEL SCOOPS")
     A42A 6F00     
21527               
21528 A42C 028D  22        ci   ra,>06*256                 ; CMP #6            ; If A is not 6 (i.e. the item we've just bought is not
     A42E 0600     
21529 A430 1620  14        jne  et6_                       ; BNE et6           ; a fuel scoop), skip to et6
21530               
21531 A432 D3A0  30        movb @BST,rx                    ; LDX BST           ; If we already have fuel scoops fitted (i.e. BST is
     A434 0329     
21532 A436 131C  14        jeq  ed9_                       ; BEQ ed9           ; zero), jump to ed9, otherwise fall through into pres
21533                                                                          ; to show the error "Fuel Scoops Present", beep and
21534                                                                          ; exit to the docking bay (i.e. show the Status Mode
21535                                                                          ; screen)
21536               
21537               pres_:
21538                                                                          ; If we get here we need to show an error to say that
21539                                                                          ; the item whose name is in recursive token Y is already
21540                                                                          ; present, and then process a refund for the cost of
21541                                                                          ; item number A
21542 A438 D80F  30        movb ry,@K                      ; STY K             ; Store the item's name in K
     A43A 003D     
21543               
21544 A43C 0200  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     A43E A524     
21545 A440 06A0  32        bl   @jsr                       ;
     A442 FE1E     
21546                                                                          ; number A
21547               
21548 A444 0200  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, as the station
     A446 A1BE     
21549 A448 06A0  32        bl   @jsr                       ;
     A44A FE1E     
21550                                                                          ; already took the money for this item in the JSR eq
21551                                                                          ; instruction above, but we can't fit the item, so need
21552                                                                          ; our money back
21553               
21554 A44C D360  30        movb @K,ra                      ; LDA K             ; Print the recursive token in K (the item's name)
     A44E 003D     
21555 A450 0200  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     A452 4EFE     
21556 A454 06A0  32        bl   @jsr                       ;
     A456 FE1E     
21557               
21558 A458 020D  20        li   ra,>1f*256                 ; LDA #31           ; Print recursive token 145 ("PRESENT")
     A45A 1F00     
21559 A45C 0200  20        li   rtmp,TT27                  ; JSR TT27
     A45E A6E8     
21560 A460 06A0  32        bl   @jsr                       ;
     A462 FE1E     
21561               
21562               err_:
21563 A464 0200  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     A466 A4E8     
21564 A468 06A0  32        bl   @jsr                       ;
     A46A FE1E     
21565                                                                          ; second
21566               
21567 A46C 0460  28        b    @BAY                       ; JMP BAY           ; Jump to BAY to go to the docking bay (i.e. show the
     A46E C65C     
21568                                                                          ; Status Mode screen)
21569               
21570               ed9_:
21571 A470 7347  18        sb   rone,ra                    ; DEC BST           ; We just bought a shiny new fuel scoop, so set BST to
21572                                                                          ; &FF (as BST was 0 before the jump to ed9 above)
21573               
21574               et6_:
21575 A472 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 112 ("E.C.M.SYSTEM")
21576               
21577 A474 028D  22        ci   ra,>07*256                 ; CMP #7            ; If A is not 7 (i.e. the item we've just bought is not
     A476 0700     
21578 A478 1604  14        jne  et7_                       ; BNE et7           ; an escape pod), skip to et7
21579               
21580 A47A D3A0  30        movb @ESCP,rx                   ; LDX ESCP          ; If we already have an escape pod fitted (i.e. ESCP is
     A47C 032E     
21581 A47E 16DC  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Escape Pod
21582                                                                          ; Present", beep and exit to the docking bay (i.e. show
21583                                                                          ; the Status Mode screen)
21584               
21585 A480 7347  18        sb   rone,ra                    ; DEC ESCP          ; Otherwise we just bought an escape pod, so set ESCP
21586                                                                          ; to &FF (as ESCP was 0 before the DEC instruction)
21587               
21588               et7_:
21589 A482 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 113 ("ENERGY BOMB")
21590               
21591 A484 028D  22        ci   ra,>08*256                 ; CMP #8            ; If A is not 8 (i.e. the item we've just bought is not
     A486 0800     
21592 A488 1607  14        jne  et8_                       ; BNE et8           ; an energy bomb), skip to et8
21593               
21594 A48A D3A0  30        movb @BOMB,rx                   ; LDX BOMB          ; If we already have an energy bomb fitted (i.e. BOMB
     A48C 032A     
21595 A48E 16D4  14        jne  pres_                      ; BNE pres          ; is non-zero), jump to pres to show the error "Energy
21596                                                                          ; Bomb Present", beep and exit to the docking bay (i.e.
21597                                                                          ; show the Status Mode screen)
21598               
21599 A490 020E  20        li   rx,>7f*256                 ; LDX #&7F          ; Otherwise we just bought an energy bomb, so set BOMB
     A492 7F00     
21600 A494 D80E  30        movb rx,@BOMB                   ; STX BOMB          ; to &7F
     A496 032A     
21601               
21602               et8_:
21603 A498 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 114 ("ENERGY UNIT")
21604               
21605 A49A 028D  22        ci   ra,>09*256                 ; CMP #9            ; If A is not 9 (i.e. the item we've just bought is not
     A49C 0900     
21606 A49E 1604  14        jne  etA                        ; BNE etA           ; an energy unit), skip to etA
21607               
21608 A4A0 D3A0  30        movb @ENGY,rx                   ; LDX ENGY          ; If we already have an energy unit fitted (i.e. ENGY is
     A4A2 032B     
21609 A4A4 16C9  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Energy Unit
21610                                                                          ; Present", beep and exit to the docking bay (i.e. show
21611                                                                          ; the Status Mode screen)
21612               
21613 A4A6 B347  18        ab   rone,ra                    ; INC ENGY          ; Otherwise we just picked up an energy unit, so set
21614                                                                          ; ENGY to 1 (as ENGY was 0 before the INC instruction)
21615               
21616               etA:
21617 A4A8 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 115 ("DOCKING
21618                                                                          ; COMPUTERS")
21619               
21620 A4AA 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If A is not 10 (i.e. the item we've just bought is not
     A4AC 0A00     
21621 A4AE 1604  14        jne  etB                        ; BNE etB           ; a docking computer), skip to etB
21622               
21623 A4B0 D3A0  30        movb @DKCMP,rx                  ; LDX DKCMP         ; If we already have a docking computer fitted (i.e.
     A4B2 032C     
21624 A4B4 16C1  14        jne  pres_                      ; BNE pres          ; DKCMP is non-zero), jump to pres to show the error
21625                                                                          ; "Docking Computer Present", beep and exit to the
21626                                                                          ; docking bay (i.e. show the Status Mode screen)
21627               
21628 A4B6 7347  18        sb   rone,ra                    ; DEC DKCMP         ; Otherwise we just got hold of a docking computer, so
21629                                                                          ; set DKCMP to &FF (as DKCMP was 0 before the DEC
21630                                                                          ; instruction)
21631               
21632               etB:
21633 A4B8 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 116 ("GALACTIC
21634                                                                          ; HYPERSPACE ")
21635               
21636 A4BA 028D  22        ci   ra,>0b*256                 ; CMP #11           ; If A is not 11 (i.e. the item we've just bought is not
     A4BC 0B00     
21637 A4BE 1604  14        jne  et9_                       ; BNE et9           ; a galactic hyperdrive), skip to et9
21638               
21639 A4C0 D3A0  30        movb @GHYP,rx                   ; LDX GHYP          ; If we already have a galactic hyperdrive fitted (i.e.
     A4C2 032D     
21640 A4C4 16B9  14        jne  pres_                      ; BNE pres          ; GHYP is non-zero), jump to pres to show the error
21641                                                                          ; "Galactic Hyperspace Present", beep and exit to the
21642                                                                          ; docking bay (i.e. show the Status Mode screen)
21643               
21644 A4C6 7347  18        sb   rone,ra                    ; DEC GHYP          ; Otherwise we just splashed out on a galactic
21645                                                                          ; hyperdrive, so set GHYP to &FF (as GHYP was 0 before
21646                                                                          ; the DEC instruction)
21647               
21648               et9_:
21649 A4C8 0200  20        li   rtmp,dn_                   ; JSR dn            ; We are done buying equipment, so print the amount of
     A4CA A4D4     
21650 A4CC 06A0  32        bl   @jsr                       ;
     A4CE FE1E     
21651                                                                          ; cash left in the cash pot, then make a short, high
21652                                                                          ; beep to confirm the purchase, and delay for 1 second
21653               
21654 A4D0 0460  28        b    @EQSHP                     ; JMP EQSHP         ; Jump back up to EQSHP to show the Equip Ship screen
     A4D2 A23C     
21655                                                                          ; again and see if we can't track down another bargain
21656               
21657               * ******************************************************************************
21658               *
21659               * Name: dn
21660               * Type: Subroutine
21661               * Category: Market
21662               * Summary: Print the amount of money we have left in the cash pot, then make
21663               * a short, high beep and delay for 1 second
21664               *
21665               * ******************************************************************************
21666               
21667               dn_:
21668 A4D4 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     A4D6 5E64     
21669 A4D8 06A0  32        bl   @jsr                       ;
     A4DA FE1E     
21670               
21671 A4DC 020D  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:{cash} CR{crlf}")
     A4DE 7700     
21672 A4E0 0200  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     A4E2 4EFE     
21673 A4E4 06A0  32        bl   @jsr                       ;
     A4E6 FE1E     
21674               
21675                                                                          ; Fall through into dn2 to make a beep and delay for
21676                                                                          ; 1 second before returning from the subroutine
21677               
21678               * ******************************************************************************
21679               *
21680               * Name: dn2
21681               * Type: Subroutine
21682               * Category: Text
21683               * Summary: Make a short, high beep and delay for 1 second
21684               *
21685               * ******************************************************************************
21686               
21687               dn2_:
21688 A4E8 0200  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     A4EA CBAC     
21689 A4EC 06A0  32        bl   @jsr                       ;
     A4EE FE1E     
21690               
21691 A4F0 020F  20        li   ry,>32*256                 ; LDY #50           ; Delay for 50 vertical syncs (50/50 = 1 second) and
     A4F2 3200     
21692 A4F4 0460  28        b    @DELAY                     ; JMP DELAY         ; return from the subroutine using a tail call
     A4F6 4C00     
21693               
21694               * ******************************************************************************
21695               *
21696               * Name: eq
21697               * Type: Subroutine
21698               * Category: Equipment
21699               * Summary: Subtract the price of equipment from the cash pot
21700               *
21701               * ------------------------------------------------------------------------------
21702               *
21703               * If we have enough cash, subtract the price of a specified piece of equipment
21704               * from our cash pot and return from the subroutine. If we don't have enough
21705               * cash, exit to the docking bay (i.e. show the Status Mode screen).
21706               *
21707               * ------------------------------------------------------------------------------
21708               *
21709               * Arguments:
21710               *
21711               * A                   The item number of the piece of equipment (0-11) as
21712               * shown in the table at PRXS
21713               *
21714               * ******************************************************************************
21715               
21716               eq_:
21717 A4F8 0200  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     A4FA A524     
21718 A4FC 06A0  32        bl   @jsr                       ;
     A4FE FE1E     
21719                                                                          ; number A
21720               
21721 A500 0200  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot, but only if
     A502 A172     
21722 A504 06A0  32        bl   @jsr                       ;
     A506 FE1E     
21723                                                                          ; we have enough cash
21724               
21725 A508 1816  14        joc  c_                         ; BCS c             ; If the C flag is set then we did have enough cash for
21726                                                                          ; the transaction, so jump to c to return from the
21727                                                                          ; subroutine (as c contains an RTS)
21728               
21729 A50A 020D  20        li   ra,>c5*256                 ; LDA #197          ; Otherwise we don't have enough cash to buy this piece
     A50C C500     
21730 A50E 0200  20        li   rtmp,prq_                  ; JSR prq           ; of equipment, so print recursive token 37 ("CASH")
     A510 5D52     
21731 A512 06A0  32        bl   @jsr                       ;
     A514 FE1E     
21732                                                                          ; followed by a question mark
21733               
21734 A516 0460  28        b    @err_                      ; JMP err           ; Jump to err to beep, pause and go to the docking bay
     A518 A464     
21735                                                                          ; (i.e. show the Status Mode screen)
21736               
21737               * ******************************************************************************
21738               *
21739               * Name: prx
21740               * Type: Subroutine
21741               * Category: Equipment
21742               * Summary: Return the price of a piece of equipment
21743               *
21744               * ------------------------------------------------------------------------------
21745               *
21746               * This routine returns the price of equipment as listed in the table at PRXS.
21747               *
21748               * ------------------------------------------------------------------------------
21749               *
21750               * Arguments:
21751               *
21752               * A                   The item number of the piece of equipment (0-11) as
21753               * shown in the table at PRXS
21754               *
21755               * ------------------------------------------------------------------------------
21756               *
21757               * Returns:
21758               *
21759               * (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
21760               *
21761               * ------------------------------------------------------------------------------
21762               *
21763               * Other entry points:
21764               *
21765               * prx-3               Return the price of the item with number A - 1
21766               *
21767               * c                   Contains an RTS
21768               *
21769               * ******************************************************************************
21770               
21771                      .sec                            ; SEC               ; Decrement A (for when this routine is called via
     **** ****     > SEC
0001 A51A 0A18  18        sla  rmone,1
                   < elite.a99
21772                      .sbi (>01*256)                  ; SBC #1            ; prx-3)
     **** ****     > SBI
0001 A51C 1801  14        joc  !
0002 A51E 7347  18        sb   rone,ra
0003               !:
0004 A520 022D  22        ai   ra,-(>01*256)
     A522 FF00     
                   < elite.a99
21773               
21774               prx_:
21775                      .asla                           ; ASL A             ; Set Y = A * 2, so it can act as an index into the
     **** ****     > ASLA
0001 A524 024D  22        andi ra,>ff00
     A526 FF00     
0002 A528 0A1D  18        sla  ra,1
                   < elite.a99
21776 A52A D3CD  18        movb ra,ry                      ; TAY               ; PRXS table, which has two bytes per entry
21777               
21778 A52C D3AF  34        movb @PRXS(ry),rx               ; LDX PRXS,Y        ; Fetch the low byte of the price into X
     A52E 2DF0     
21779               
21780 A530 D36F  34        movb @PRXS+1(ry),ra             ; LDA PRXS+1,Y      ; Fetch the high byte of the price into A and transfer
     A532 2DF1     
21781 A534 D3CD  18        movb ra,ry                      ; TAY               ; it to X, so the price is now in (Y X)
21782               
21783               c_:
21784 A536 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A538 FE2A     
21785               
21786               * ******************************************************************************
21787               *
21788               * Name: qv
21789               * Type: Subroutine
21790               * Category: Equipment
21791               * Summary: Print a menu of the four space views, for buying lasers
21792               *
21793               * ------------------------------------------------------------------------------
21794               *
21795               * Print a menu in the bottom-middle of the screen, at row 16, column 12, that
21796               * lists the four available space views, like this:
21797               *
21798               * 0 Front
21799               * 1 Rear
21800               * 2 Left
21801               * 3 Right
21802               *
21803               * Also print a "View ?" prompt and ask for a view number. The menu is shown
21804               * when we choose to buy a new laser in the Equip Ship screen.
21805               *
21806               * ------------------------------------------------------------------------------
21807               *
21808               * Returns:
21809               *
21810               * X                   The chosen view number (0-3)
21811               *
21812               * ******************************************************************************
21813               
21814               qv_:
21815 A53A 020F  20        li   ry,>10*256                 ; LDY #16           ; Move the text cursor to row 16, and at the same time
     A53C 1000     
21816 A53E D80F  30        movb ry,@YC                     ; STY YC            ; set Y to a counter going from 16 to 19 in the loop
     A540 002D     
21817                                                                          ; below
21818               
21819               qv1_:
21820 A542 020E  20        li   rx,>0c*256                 ; LDX #12           ; Move the text cursor to column 12
     A544 0C00     
21821 A546 D80E  30        movb rx,@XC                     ; STX XC
     A548 002C     
21822               
21823 A54A D34F  18        movb ry,ra                      ; TYA               ; Transfer the counter value from Y to A
21824               
21825                      .clc                            ; CLC               ; Print ASCII character "0" - 16 + A, so as A goes from
     **** ****     > CLC
0001 A54C 0A16  18        sla  rzero,1
                   < elite.a99
21826                      .adi (('0'-16)*256)             ; ADC #'0'-16       ; 16 to 19, this prints "0" through "3" followed by a
     **** ****     > ADI
0001 A54E 1701  14        jnc  !
0002 A550 B347  18        ab   rone,ra
0003               !:
0004 A552 022D  22        ai   ra,(('0'-16)*256)
     A554 2000     
                   < elite.a99
21827 A556 0200  20        li   rtmp,spc_                  ; JSR spc           ; space
     A558 4EFE     
21828 A55A 06A0  32        bl   @jsr                       ;
     A55C FE1E     
21829               
21830 A55E D360  30        movb @YC,ra                     ; LDA YC            ; Print recursive text token 80 + YC, so as YC goes from
     A560 002D     
21831                      .clc                            ; CLC               ; 16 to 19, this prints "FRONT", "REAR", "LEFT" and
     **** ****     > CLC
0001 A562 0A16  18        sla  rzero,1
                   < elite.a99
21832                      .adi (>50*256)                  ; ADC #80           ; "RIGHT"
     **** ****     > ADI
0001 A564 1701  14        jnc  !
0002 A566 B347  18        ab   rone,ra
0003               !:
0004 A568 022D  22        ai   ra,(>50*256)
     A56A 5000     
                   < elite.a99
21833 A56C 0200  20        li   rtmp,TT27                  ; JSR TT27
     A56E A6E8     
21834 A570 06A0  32        bl   @jsr                       ;
     A572 FE1E     
21835               
21836 A574 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row, and increment the
21837                                                                          ; counter in YC at the same time
21838               
21839 A576 D3E0  30        movb @YC,ry                     ; LDY YC            ; Update Y with the incremented counter in YC
     A578 002D     
21840               
21841 A57A 028F  22        ci   ry,>14*256                 ; CPY #20           ; If Y < 20 then loop back up to qv1 to print the next
     A57C 1400     
21842 A57E 17E1  14        jnc  qv1_                       ; BCC qv1           ; view in the menu
21843               
21844               qv3_:
21845 A580 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     A582 4C2E     
21846 A584 06A0  32        bl   @jsr                       ;
     A586 FE1E     
21847                                                                          ; and move the text cursor to column 1 on row 21, i.e.
21848                                                                          ; the start of the top row of the three bottom rows
21849               
21850               qv2_:
21851 A588 020D  20        li   ra,>af*256                 ; LDA #175          ; Print recursive text token 15 ("VIEW ") followed by
     A58A AF00     
21852 A58C 0200  20        li   rtmp,prq_                  ; JSR prq           ; a question mark
     A58E 5D52     
21853 A590 06A0  32        bl   @jsr                       ;
     A592 FE1E     
21854               
21855 A594 0200  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     A596 CE00     
21856 A598 06A0  32        bl   @jsr                       ;
     A59A FE1E     
21857                                                                          ; the key's ASCII code in A (and X)
21858               
21859                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 A59C 0A18  18        sla  rmone,1
                   < elite.a99
21860                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 A59E 1801  14        joc  !
0002 A5A0 7347  18        sb   rone,ra
0003               !:
0004 A5A2 022D  22        ai   ra,-(('0')*256)
     A5A4 D000     
                   < elite.a99
21861               
21862 A5A6 028D  22        ci   ra,>04*256                 ; CMP #4            ; If the number entered in A >= 4, then it is not a
     A5A8 0400     
21863 A5AA 18EA  14        joc  qv3_                       ; BCS qv3           ; valid view number, so jump back to qv3 to try again
21864               
21865 A5AC D38D  18        movb ra,rx                      ; TAX               ; We have a valid view number, so transfer it to X
21866               
21867 A5AE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A5B0 FE2A     
21868               
21869               * ******************************************************************************
21870               *
21871               * Save ELTD.bin
21872               *
21873               * ******************************************************************************
21874               
21875                      ; PRINT "ELITE D"
21876                      ; PRINT "Assembled at ", ~CODE_D%
21877                      ; PRINT "Ends at ", ~P%
21878                      ; PRINT "Code size is ", ~(P% - CODE_D%)
21879                      ; PRINT "Execute at ", ~LOAD%
21880                      ; PRINT "Reload at ", ~LOAD_D%
21881               
21882                      ; PRINT "S.ELTD ", ~CODE_D%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_D%
21883                      ; SAVE "3-assembled-output/ELTD.bin", CODE_D%, P%, LOAD%
21884               
21885               * ******************************************************************************
21886               *
21887               * ELITE E FILE
21888               *
21889               * Produces the binary file ELTE.bin that gets loaded by elite-bcfs.asm.
21890               *
21891               * ******************************************************************************
21892               
21893               CODE_E.:
21894                      equ $
21895               
21896               LOAD_E.:
21897                      equ LOAD. + $ - CODE.
21898               
21899               * ******************************************************************************
21900               *
21901               * Name: Authors' names
21902               * Type: Variable
21903               * Category: Copy protection
21904               * Summary: The authors' names and a copyright notice, buried in the code
21905               *
21906               * ------------------------------------------------------------------------------
21907               *
21908               * This copyright notice is not used anywhere and it is obfuscated by EOR'ing
21909               * each character with 164, but presumably the authors wanted their names buried
21910               * in the code somewhere. Though they do also have recursive token 94, which
21911               * reads "BY D.BRABEN & I.BELL" and can be displayed on the title screen using
21912               * the "X" configuration option, so this isn't the only author name easter egg
21913               * in the game. It contains the following text:
21914               *
21915               * (C)Bell/Braben1984
21916               *
21917               * ******************************************************************************
21918               
21919 A5B2 8C              byte '(' ^ 164
21920 A5B3   E7            byte 'C' ^ 164
21921 A5B4 8D              byte ')' ^ 164
21922 A5B5   E6            byte 'B' ^ 164
21923 A5B6 C1              byte 'e' ^ 164
21924 A5B7   C8            byte 'l' ^ 164
21925 A5B8 C8              byte 'l' ^ 164
21926 A5B9   8B            byte '/' ^ 164
21927 A5BA E6              byte 'B' ^ 164
21928 A5BB   D6            byte 'r' ^ 164
21929 A5BC C5              byte 'a' ^ 164
21930 A5BD   C6            byte 'b' ^ 164
21931 A5BE C1              byte 'e' ^ 164
21932 A5BF   CA            byte 'n' ^ 164
21933 A5C0 95              byte '1' ^ 164
21934 A5C1   9D            byte '9' ^ 164
21935 A5C2 9C              byte '8' ^ 164
21936 A5C3   90            byte '4' ^ 164
21937               
21938               * ******************************************************************************
21939               *
21940               * Name: cpl
21941               * Type: Subroutine
21942               * Category: Universe
21943               * Summary: Print the selected system name
21944               * Deep dive: Generating system names
21945               * Galaxy and system seeds
21946               *
21947               * ------------------------------------------------------------------------------
21948               *
21949               * Print control code 3 (the selected system name, i.e. the one in the crosshairs
21950               * in the Short-range Chart).
21951               *
21952               * ******************************************************************************
21953               
21954               cpl_:
21955 A5C4 020E  20        li   rx,>05*256                 ; LDX #5            ; First we need to back up the seeds in QQ15, so set up
     A5C6 0500     
21956                                                                          ; a counter in X to cover three 16-bit seeds (i.e.
21957                                                                          ; 6 bytes)
21958               
21959               TT53:
21960 A5C8 D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy byte X from QQ15 to QQ19
     A5CA 0078     
21961 A5CC DB8D  38        movb ra,@QQ19(rx)               ; STA QQ19,X
     A5CE 007F     
21962               
21963 A5D0 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
21964               
21965 A5D2 15FA  14        jgt  TT53                       ; BPL TT53          ; Loop back for the next byte to back up
21966               
21967 A5D4 020F  20        li   ry,>03*256                 ; LDY #3            ; Step 1: Now that the seeds are backed up, we can
     A5D6 0300     
21968                                                                          ; start the name-generation process. We will either
21969                                                                          ; need to loop three or four times, so for now set
21970                                                                          ; up a counter in Y to loop four times
21971               
21972                      .bit @QQ15                      ; BIT QQ15          ; Check bit 6 of s0_lo, which is stored in QQ15
     **** ****     > BIT
0001 A5D8 D020  30        movb @QQ15,rtmp
     A5DA 0078     
0002 A5DC 0540  14        inv  rtmp
0003 A5DE D047  18        movb rone,rtmp2
0004 A5E0 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
21973               
21974                      .bvs B59                        ; BVS B59           ; If bit 6 is set then skip over the next instruction
     **** ****     > BVS
0001 A5E2 1801  14        joc  !
0002 A5E4 1001  14        jmp  B59
0003               !:
                   < elite.a99
21975               
21976 A5E6 73C7  18        sb   rone,ry                    ; DEY               ; Bit 6 is clear, so we only want to loop three times,
21977                                                                          ; so decrement the loop counter in Y
21978               
21979               B59:
21980 A5E8 D80F  30        movb ry,@T                      ; STY T             ; Store the loop counter in T
     A5EA 00D1     
21981               
21982               TT55:
21983 A5EC D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Step 2: Load s2_hi, which is stored in QQ15+5, and
     A5EE 007D     
21984 A5F0 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; extract bits 0-4 by AND'ing with %11111
     A5F2 1F00     
21985               
21986 A5F4 1306  14        jeq  B60                        ; BEQ B60           ; If all those bits are zero, then skip the following
21987                                                                          ; two instructions to go to step 3
21988               
21989 A5F6 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now have a number in the range 1-31, which we can
     A5F8 8000     
21990                                                                          ; easily convert into a two-letter token, but first we
21991                                                                          ; need to add 128 (or set bit 7) to get a range of
21992                                                                          ; 129-159
21993               
21994 A5FA 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the two-letter token in A
     A5FC A6E8     
21995 A5FE 06A0  32        bl   @jsr                       ;
     A600 FE1E     
21996               
21997               B60:
21998 A602 0200  20        li   rtmp,TT54                  ; JSR TT54          ; Step 3: twist the seeds in QQ15
     A604 4E42     
21999 A606 06A0  32        bl   @jsr                       ;
     A608 FE1E     
22000               
22001 A60A 7347  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
22002               
22003 A60C 15EF  14        jgt  TT55                       ; BPL TT55          ; Loop back for the next two letters
22004               
22005 A60E 020E  20        li   rx,>05*256                 ; LDX #5            ; We have printed the system name, so we can now
     A610 0500     
22006                                                                          ; restore the seeds we backed up earlier. Set up a
22007                                                                          ; counter in X to cover three 16-bit seeds (i.e. 6
22008                                                                          ; bytes)
22009               
22010               TT56:
22011 A612 D36E  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy byte X from QQ19 to QQ15
     A614 007F     
22012 A616 DB8D  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     A618 0078     
22013               
22014 A61A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22015               
22016 A61C 15FA  14        jgt  TT56                       ; BPL TT56          ; Loop back for the next byte to restore
22017               
22018 A61E 0460  28        b    @rts                       ; RTS               ; Once all the seeds are restored, return from the
     A620 FE2A     
22019                                                                          ; subroutine
22020               
22021               * ******************************************************************************
22022               *
22023               * Name: cmn
22024               * Type: Subroutine
22025               * Category: Status
22026               * Summary: Print the commander's name
22027               *
22028               * ------------------------------------------------------------------------------
22029               *
22030               * Print control code 4 (the commander's name).
22031               *
22032               * ------------------------------------------------------------------------------
22033               *
22034               * Other entry points:
22035               *
22036               * cmn-1               Contains an RTS
22037               *
22038               * ******************************************************************************
22039               
22040               cmn_:
22041 A622 020F  20        li   ry,>00*256                 ; LDY #0            ; Set up a counter in Y, starting from 0
     A624 0000     
22042               
22043               QUL4:
22044 A626 D36F  34        movb @NA.(ry),ra                ; LDA NA%,Y         ; The commander's name is stored at NA%, so load the
     A628 21C8     
22045                                                                          ; Y-th character from NA%
22046               
22047 A62A 028D  22        ci   ra,>0d*256                 ; CMP #13           ; If we have reached the end of the name, return from
     A62C 0D00     
22048 A62E 1307  14        jeq  ypl_-1                     ; BEQ ypl-1         ; the subroutine (ypl-1 points to the RTS below)
22049               
22050 A630 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character we just loaded
     A632 3172     
22051 A634 06A0  32        bl   @jsr                       ;
     A636 FE1E     
22052               
22053 A638 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter
22054               
22055 A63A 16F5  14        jne  QUL4                       ; BNE QUL4          ; Loop back for the next character
22056               
22057 A63C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A63E FE2A     
22058               
22059               * ******************************************************************************
22060               *
22061               * Name: ypl
22062               * Type: Subroutine
22063               * Category: Universe
22064               * Summary: Print the current system name
22065               *
22066               * ------------------------------------------------------------------------------
22067               *
22068               * Print control code 2 (the current system name).
22069               *
22070               * ------------------------------------------------------------------------------
22071               *
22072               * Other entry points:
22073               *
22074               * ypl-1               Contains an RTS
22075               *
22076               * ******************************************************************************
22077               
22078               ypl_:
22079 A640 D360  30        movb @MJ,ra                     ; LDA MJ            ; Check the mis-jump flag at MJ, and if it is non-zero
     A642 0D5C     
22080 A644 16ED  14        jne  cmn_-1                     ; BNE cmn-1         ; then we are in witchspace, and witchspace doesn't have
22081                                                                          ; a system name, so return from the subroutine (cmn-1
22082                                                                          ; contains an RTS)
22083               
22084 A646 0200  20        li   rtmp,TT62                  ; JSR TT62          ; Call TT62 below to swap the three 16-bit seeds in
     A648 A656     
22085 A64A 06A0  32        bl   @jsr                       ;
     A64C FE1E     
22086                                                                          ; QQ2 and QQ15 (before the swap, QQ2 contains the seeds
22087                                                                          ; for the current system, while QQ15 contains the seeds
22088                                                                          ; for the selected system)
22089               
22090 A64E 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     A650 A5C4     
22091 A652 06A0  32        bl   @jsr                       ;
     A654 FE1E     
22092                                                                          ; in QQ15 (which now contains the seeds for the current
22093                                                                          ; system)
22094               
22095                                                                          ; Now we fall through into the TT62 subroutine, which
22096                                                                          ; will swap QQ2 and QQ15 once again, so everything goes
22097                                                                          ; back into the right place, and the RTS at the end of
22098                                                                          ; TT62 will return from the subroutine
22099               
22100               TT62:
22101 A656 020E  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X for the three 16-bit seeds we
     A658 0500     
22102                                                                          ; want to swap (i.e. 6 bytes)
22103               
22104               TT78:
22105 A65A D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Swap byte X between QQ2 and QQ15
     A65C 0078     
22106 A65E D3EE  34        movb @QQ2(rx),ry                ; LDY QQ2,X
     A660 0F22     
22107 A662 DB8D  38        movb ra,@QQ2(rx)                ; STA QQ2,X
     A664 0F22     
22108 A666 DB8F  38        movb ry,@QQ15(rx)               ; STY QQ15,X
     A668 0078     
22109               
22110 A66A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22111               
22112 A66C 15F6  14        jgt  TT78                       ; BPL TT78          ; Loop back for the next byte to swap
22113               
22114 A66E 0460  28        b    @rts                       ; RTS               ; Once all bytes are swapped, return from the
     A670 FE2A     
22115                                                                          ; subroutine
22116               
22117               * ******************************************************************************
22118               *
22119               * Name: tal
22120               * Type: Subroutine
22121               * Category: Universe
22122               * Summary: Print the current galaxy number
22123               *
22124               * ------------------------------------------------------------------------------
22125               *
22126               * Print control code 1 (the current galaxy number, right-aligned to width 3).
22127               *
22128               * ******************************************************************************
22129               
22130               tal_:
22131                      .clc                            ; CLC               ; We don't want to print the galaxy number with a
     **** ****     > CLC
0001 A672 0A16  18        sla  rzero,1
                   < elite.a99
22132                                                                          ; decimal point, so clear the C flag for pr2 to take as
22133                                                                          ; an argument
22134               
22135 A674 D3A0  30        movb @GCNT,rx                   ; LDX GCNT          ; Load the current galaxy number from GCNT into X
     A676 030F     
22136               
22137 A678 B387  18        ab   rone,rx                    ; INX               ; Add 1 to the galaxy number, as the galaxy numbers
22138                                                                          ; are 0-7 internally, but we want to display them as
22139                                                                          ; galaxy 1 through 8
22140               
22141 A67A 0460  28        b    @pr2_                      ; JMP pr2           ; Jump to pr2, which prints the number in X to a width
     A67C 2FAC     
22142                                                                          ; of 3 figures, left-padding with spaces to a width of
22143                                                                          ; 3, and return from the subroutine using a tail call
22144               
22145               * ******************************************************************************
22146               *
22147               * Name: fwl
22148               * Type: Subroutine
22149               * Category: Status
22150               * Summary: Print fuel and cash levels
22151               *
22152               * ------------------------------------------------------------------------------
22153               *
22154               * Print control code 5 ("FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:",
22155               * control code 0).
22156               *
22157               * ******************************************************************************
22158               
22159               fwl_:
22160 A67E 020D  20        li   ra,>69*256                 ; LDA #105          ; Print recursive token 105 ("FUEL") followed by a
     A680 6900     
22161 A682 0200  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     A684 A6DC     
22162 A686 06A0  32        bl   @jsr                       ;
     A688 FE1E     
22163               
22164 A68A D3A0  30        movb @QQ14,rx                   ; LDX QQ14          ; Load the current fuel level from QQ14
     A68C 030D     
22165               
22166                      .sec                            ; SEC               ; We want to print the fuel level with a decimal point,
     **** ****     > SEC
0001 A68E 0A18  18        sla  rmone,1
                   < elite.a99
22167                                                                          ; so set the C flag for pr2 to take as an argument
22168               
22169 A690 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; Call pr2, which prints the number in X to a width of
     A692 2FAC     
22170 A694 06A0  32        bl   @jsr                       ;
     A696 FE1E     
22171                                                                          ; 3 figures (i.e. in the format x.x, which will always
22172                                                                          ; be exactly 3 characters as the maximum fuel is 7.0)
22173               
22174 A698 020D  20        li   ra,>c3*256                 ; LDA #195          ; Print recursive token 35 ("LIGHT YEARS") followed by
     A69A C300     
22175 A69C 0200  20        li   rtmp,plf_                  ; JSR plf           ; a newline
     A69E A6D0     
22176 A6A0 06A0  32        bl   @jsr                       ;
     A6A2 FE1E     
22177               
22178               PCASH:
22179 A6A4 020D  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:" then control code
     A6A6 7700     
22180 A6A8 161F  14        jne  TT27                       ; BNE TT27          ; 0, which prints cash levels, then " CR" and newline)
22181               
22182               * ******************************************************************************
22183               *
22184               * Name: csh
22185               * Type: Subroutine
22186               * Category: Status
22187               * Summary: Print the current amount of cash
22188               *
22189               * ------------------------------------------------------------------------------
22190               *
22191               * Print control code 0 (the current amount of cash, right-aligned to width 9,
22192               * followed by " CR" and a newline).
22193               *
22194               * ******************************************************************************
22195               
22196               csh_:
22197 A6AA 020E  20        li   rx,>03*256                 ; LDX #3            ; We are going to use the BPRNT routine to print out
     A6AC 0300     
22198                                                                          ; the current amount of cash, which is stored as a
22199                                                                          ; 32-bit number at location CASH. BPRNT prints out
22200                                                                          ; the 32-bit number stored in K, so before we call
22201                                                                          ; BPRNT, we need to copy the four bytes from CASH into
22202                                                                          ; K, so first we set up a counter in X for the 4 bytes
22203               
22204               pc1_:
22205 A6AE D36E  34        movb @CASH(rx),ra               ; LDA CASH,X        ; Copy byte X from CASH to K
     A6B0 0309     
22206 A6B2 DB8D  38        movb ra,@K(rx)                  ; STA K,X
     A6B4 003D     
22207               
22208 A6B6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22209               
22210 A6B8 15FA  14        jgt  pc1_                       ; BPL pc1           ; Loop back for the next byte to copy
22211               
22212 A6BA 020D  20        li   ra,>09*256                 ; LDA #9            ; We want to print the cash amount using up to 9 digits
     A6BC 0900     
22213 A6BE D80D  30        movb ra,@U                      ; STA U             ; (including the decimal point), so store this in U
     A6C0 008F     
22214                                                                          ; for BRPNT to take as an argument
22215               
22216                      .sec                            ; SEC               ; We want to print the cash amount with a decimal point,
     **** ****     > SEC
0001 A6C2 0A18  18        sla  rmone,1
                   < elite.a99
22217                                                                          ; so set the C flag for BRPNT to take as an argument
22218               
22219 A6C4 0200  20        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the amount of cash to 9 digits with a decimal
     A6C6 2FCC     
22220 A6C8 06A0  32        bl   @jsr                       ;
     A6CA FE1E     
22221                                                                          ; point
22222               
22223 A6CC 020D  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR") followed by a
     A6CE E200     
22224                                                                          ; newline by falling through into plf
22225               
22226               * ******************************************************************************
22227               *
22228               * Name: plf
22229               * Type: Subroutine
22230               * Category: Text
22231               * Summary: Print a text token followed by a newline
22232               *
22233               * ------------------------------------------------------------------------------
22234               *
22235               * Arguments:
22236               *
22237               * A                   The text token to be printed
22238               *
22239               * ******************************************************************************
22240               
22241               plf_:
22242 A6D0 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     A6D2 A6E8     
22243 A6D4 06A0  32        bl   @jsr                       ;
     A6D6 FE1E     
22244               
22245 A6D8 0460  28        b    @TT67                      ; JMP TT67          ; Jump to TT67 to print a newline and return from the
     A6DA 4EE6     
22246                                                                          ; subroutine using a tail call
22247               
22248               * ******************************************************************************
22249               *
22250               * Name: TT68
22251               * Type: Subroutine
22252               * Category: Text
22253               * Summary: Print a text token followed by a colon
22254               *
22255               * ------------------------------------------------------------------------------
22256               *
22257               * Arguments:
22258               *
22259               * A                   The text token to be printed
22260               *
22261               * ******************************************************************************
22262               
22263               TT68:
22264 A6DC 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TT73
     A6DE A6E8     
22265 A6E0 06A0  32        bl   @jsr                       ;
     A6E2 FE1E     
22266                                                                          ; to print a colon
22267               
22268               * ******************************************************************************
22269               *
22270               * Name: TT73
22271               * Type: Subroutine
22272               * Category: Text
22273               * Summary: Print a colon
22274               *
22275               * ******************************************************************************
22276               
22277               TT73:
22278 A6E4 020D  20        li   ra,(':')*256               ; LDA #':'          ; Set A to ASCII ":" and fall through into TT27 to
     A6E6 3A00     
22279                                                                          ; actually print the colon
22280               
22281               * ******************************************************************************
22282               *
22283               * Name: TT27
22284               * Type: Subroutine
22285               * Category: Text
22286               * Summary: Print a text token
22287               * Deep dive: Printing text tokens
22288               *
22289               * ------------------------------------------------------------------------------
22290               *
22291               * Print a text token (i.e. a character, control code, two-letter token or
22292               * recursive token).
22293               *
22294               * ------------------------------------------------------------------------------
22295               *
22296               * Arguments:
22297               *
22298               * A                   The text token to be printed
22299               *
22300               * ******************************************************************************
22301               
22302               TT27:
22303 A6E8 D38D  18        movb ra,rx                      ; TAX               ; Copy the token number from A to X. We can then keep
22304                                                                          ; decrementing X and testing it against zero, while
22305                                                                          ; keeping the original token number intact in A; this
22306                                                                          ; effectively implements a switch statement on the
22307                                                                          ; value of the token
22308               
22309 A6EA 13DF  14        jeq  csh_                       ; BEQ csh           ; If token = 0, this is control code 0 (current amount
22310                                                                          ; of cash and newline), so jump to csh to print the
22311                                                                          ; amount of cash and return from the subroutine using
22312                                                                          ; a tail call
22313               
22314 A6EC 116E  14        jlt  TT43                       ; BMI TT43          ; If token > 127, this is either a two-letter token
22315                                                                          ; (128-159) or a recursive token (160-255), so jump
22316                                                                          ; to TT43 to process tokens
22317               
22318 A6EE 7387  18        sb   rone,rx                    ; DEX               ; If token = 1, this is control code 1 (current galaxy
22319 A6F0 13C0  14        jeq  tal_                       ; BEQ tal           ; number), so jump to tal to print the galaxy number and
22320                                                                          ; return from the subroutine using a tail call
22321               
22322 A6F2 7387  18        sb   rone,rx                    ; DEX               ; If token = 2, this is control code 2 (current system
22323 A6F4 13A5  14        jeq  ypl_                       ; BEQ ypl           ; name), so jump to ypl to print the current system name
22324                                                                          ; and return from the subroutine using a tail call
22325               
22326 A6F6 7387  18        sb   rone,rx                    ; DEX               ; If token > 3, skip the following instruction
22327 A6F8 1602  14        jne  B61                        ; BNE B61
22328               
22329 A6FA 0460  28        b    @cpl_                      ; JMP cpl           ; This token is control code 3 (selected system name)
     A6FC A5C4     
22330                                                                          ; so jump to cpl to print the selected system name
22331                                                                          ; and return from the subroutine using a tail call
22332               
22333               B61:
22334 A6FE 7387  18        sb   rone,rx                    ; DEX               ; If token = 4, this is control code 4 (commander
22335 A700 1390  14        jeq  cmn_                       ; BEQ cmn           ; name), so jump to cmm to print the commander name
22336                                                                          ; and return from the subroutine using a tail call
22337               
22338 A702 7387  18        sb   rone,rx                    ; DEX               ; If token = 5, this is control code 5 (fuel, newline,
22339 A704 13BC  14        jeq  fwl_                       ; BEQ fwl           ; cash, newline), so jump to fwl to print the fuel level
22340                                                                          ; and return from the subroutine using a tail call
22341               
22342 A706 7387  18        sb   rone,rx                    ; DEX               ; If token > 6, skip the following three instructions
22343 A708 1606  14        jne  B62                        ; BNE B62
22344               
22345 A70A 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; This token is control code 6 (switch to Sentence
     A70C 8000     
22346 A70E D80D  30        movb ra,@QQ17                   ; STA QQ17          ; Case), so set bit 7 of QQ17 to switch to Sentence Case
     A710 007E     
22347 A712 0460  28        b    @rts                       ; RTS               ; and return from the subroutine as we are done
     A714 FE2A     
22348               
22349               B62:
22350 A716 7387  18        sb   rone,rx                    ; DEX               ; If token > 8, skip the following two instructions
22351 A718 7387  18        sb   rone,rx                    ; DEX
22352 A71A 1604  14        jne  B63                        ; BNE B63
22353               
22354 A71C D80E  30        movb rx,@QQ17                   ; STX QQ17          ; This token is control code 8 (switch to ALL CAPS), so
     A71E 007E     
22355 A720 0460  28        b    @rts                       ; RTS               ; set QQ17 to 0 to switch to ALL CAPS and return from
     A722 FE2A     
22356                                                                          ; the subroutine as we are done
22357               
22358               B63:
22359 A724 7387  18        sb   rone,rx                    ; DEX               ; If token = 9, this is control code 9 (tab to column
22360 A726 1339  14        jeq  crlf_                      ; BEQ crlf          ; 21 and print a colon), so jump to crlf
22361               
22362 A728 028D  22        ci   ra,>60*256                 ; CMP #96           ; By this point, token is either 7, or in 10-127.
     A72A 6000     
22363 A72C 186A  14        joc  ex_                        ; BCS ex            ; Check token number in A and if token >= 96, then the
22364                                                                          ; token is in 96-127, which is a recursive token, so
22365                                                                          ; jump to ex, which prints recursive tokens in this
22366                                                                          ; range (i.e. where the recursive token number is
22367                                                                          ; correct and doesn't need correcting)
22368               
22369 A72E 028D  22        ci   ra,>0e*256                 ; CMP #14           ; If token < 14, skip the following two instructions
     A730 0E00     
22370 A732 1703  14        jnc  B64                        ; BCC B64
22371               
22372 A734 028D  22        ci   ra,>20*256                 ; CMP #32           ; If token < 32, then this means token is in 14-31, so
     A736 2000     
22373 A738 172B  14        jnc  qw_                        ; BCC qw            ; this is a recursive token that needs 114 adding to it
22374                                                                          ; to get the recursive token number, so jump to qw
22375                                                                          ; which will do this
22376               
22377                                                                          ; By this point, token is either 7 (beep) or in 10-13
22378                                                                          ; (line feeds and carriage returns), or in 32-95
22379                                                                          ; (ASCII letters, numbers and punctuation)
22380               
22381               B64:
22382 A73A D3A0  30        movb @QQ17,rx                   ; LDX QQ17          ; Fetch QQ17, which controls letter case, into X
     A73C 007E     
22383               
22384 A73E 1343  14        jeq  TT74                       ; BEQ TT74          ; If QQ17 = 0, then ALL CAPS is set, so jump to TT74
22385                                                                          ; to print this character as is (i.e. as a capital)
22386               
22387 A740 1113  14        jlt  TT41                       ; BMI TT41          ; If QQ17 has bit 7 set, then we are using Sentence
22388                                                                          ; Case, so jump to TT41, which will print the
22389                                                                          ; character in upper or lower case, depending on
22390                                                                          ; whether this is the first letter in a word
22391               
22392                      .bit @QQ17                      ; BIT QQ17          ; If we get here, QQ17 is not 0 and bit 7 is clear, so
     **** ****     > BIT
0001 A742 D020  30        movb @QQ17,rtmp
     A744 007E     
0002 A746 0540  14        inv  rtmp
0003 A748 D047  18        movb rone,rtmp2
0004 A74A 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22393                      .bvs TT46                       ; BVS TT46          ; either it is bit 6 that is set, or some other flag in
     **** ****     > BVS
0001 A74C 1801  14        joc  !
0002 A74E 1032  14        jmp  TT46
0003               !:
                   < elite.a99
22394                                                                          ; QQ17 is set (bits 0-5). So check whether bit 6 is set.
22395                                                                          ; If it is, then ALL CAPS has been set (as bit 7 is
22396                                                                          ; clear) but bit 6 is still indicating that the next
22397                                                                          ; character should be printed in lower case, so we need
22398                                                                          ; to fix this. We do this with a jump to TT46, which
22399                                                                          ; will print this character in upper case and clear bit
22400                                                                          ; 6, so the flags are consistent with ALL CAPS going
22401                                                                          ; forward
22402               
22403                                                                          ; If we get here, some other flag is set in QQ17 (one
22404                                                                          ; of bits 0-5 is set), which shouldn't happen in this
22405                                                                          ; version of Elite. If this were the case, then we
22406                                                                          ; would fall through into TT42 to print in lower case,
22407                                                                          ; which is how printing all words in lower case could
22408                                                                          ; be supported (by setting QQ17 to 1, say)
22409               
22410               * ******************************************************************************
22411               *
22412               * Name: TT42
22413               * Type: Subroutine
22414               * Category: Text
22415               * Summary: Print a letter in lower case
22416               *
22417               * ------------------------------------------------------------------------------
22418               *
22419               * Arguments:
22420               *
22421               * A                   The character to be printed. Can be one of the
22422               * following:
22423               *
22424               * * 7 (beep)
22425               *
22426               * * 10-13 (line feeds and carriage returns)
22427               *
22428               * * 32-95 (ASCII capital letters, numbers and
22429               * punctuation)
22430               *
22431               * ------------------------------------------------------------------------------
22432               *
22433               * Other entry points:
22434               *
22435               * TT44                Jumps to TT26 to print the character in A (used to
22436               * enable us to use a branch instruction to jump to TT26)
22437               *
22438               * ******************************************************************************
22439               
22440               TT42:
22441 A750 028D  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     A752 4100     
22442 A754 1707  14        jnc  TT44                       ; BCC TT44          ; to TT26 (via TT44) to print the character as is, as
22443                                                                          ; we don't care about the character's case
22444               
22445 A756 028D  22        ci   ra,('Z'+1)*256             ; CMP #'Z'+1        ; If A >= (ASCII "Z" + 1), then this is also
     A758 5B00     
22446 A75A 1804  14        joc  TT44                       ; BCS TT44          ; punctuation, so jump to TT26 (via TT44) to print the
22447                                                                          ; character as is, as we don't care about the
22448                                                                          ; character's case
22449               
22450                      .adi (>20*256)                  ; ADC #32           ; Add 32 to the character, to convert it from upper to
     **** ****     > ADI
0001 A75C 1701  14        jnc  !
0002 A75E B347  18        ab   rone,ra
0003               !:
0004 A760 022D  22        ai   ra,(>20*256)
     A762 2000     
                   < elite.a99
22451                                                                          ; lower case
22452               
22453               TT44:
22454 A764 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     A766 3172     
22455               
22456               * ******************************************************************************
22457               *
22458               * Name: TT41
22459               * Type: Subroutine
22460               * Category: Text
22461               * Summary: Print a letter according to Sentence Case
22462               *
22463               * ------------------------------------------------------------------------------
22464               *
22465               * The rules for printing in Sentence Case are as follows:
22466               *
22467               * * If QQ17 bit 6 is set, print lower case (via TT45)
22468               *
22469               * * If QQ17 bit 6 is clear, then:
22470               *
22471               * * If character is punctuation, just print it
22472               *
22473               * * If character is a letter, set QQ17 bit 6 and print letter as a capital
22474               *
22475               * ------------------------------------------------------------------------------
22476               *
22477               * Arguments:
22478               *
22479               * A                   The character to be printed. Can be one of the
22480               * following:
22481               *
22482               * * 7 (beep)
22483               *
22484               * * 10-13 (line feeds and carriage returns)
22485               *
22486               * * 32-95 (ASCII capital letters, numbers and
22487               * punctuation)
22488               *
22489               * X                   Contains the current value of QQ17
22490               *
22491               * QQ17                Bit 7 is set
22492               *
22493               * ******************************************************************************
22494               
22495               TT41:
22496                                                                          ; If we get here, then QQ17 has bit 7 set, so we are in
22497                                                                          ; Sentence Case
22498                      .bit @QQ17                      ; BIT QQ17          ; If QQ17 also has bit 6 set, jump to TT45 to print
     **** ****     > BIT
0001 A768 D020  30        movb @QQ17,rtmp
     A76A 007E     
0002 A76C 0540  14        inv  rtmp
0003 A76E D047  18        movb rone,rtmp2
0004 A770 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22499                      .bvs TT45                       ; BVS TT45          ; this character in lower case
     **** ****     > BVS
0001 A772 1801  14        joc  !
0002 A774 1017  14        jmp  TT45
0003               !:
                   < elite.a99
22500               
22501                                                                          ; If we get here, then QQ17 has bit 6 clear and bit 7
22502                                                                          ; set, so we are in Sentence Case and we need to print
22503                                                                          ; the next letter in upper case
22504               
22505 A776 028D  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     A778 4100     
22506 A77A 1725  14        jnc  TT74                       ; BCC TT74          ; to TT26 (via TT44) to print the character as is, as
22507                                                                          ; we don't care about the character's case
22508               
22509                      .pha                            ; PHA               ; Otherwise this is a letter, so store the token number
     **** ****     > PHA
0001 A77C D68D  30        movb ra,*rsp
0002 A77E 060A  14        dec  rsp
                   < elite.a99
22510               
22511 A780 D34E  18        movb rx,ra                      ; TXA               ; Set bit 6 in QQ17 (X contains the current QQ17)
22512 A782 026D  22        ori  ra,>40*256                 ; ORA #%1000000     ; so the next letter after this one is printed in lower
     A784 4000     
22513 A786 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; case
     A788 007E     
22514               
22515                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 A78A 058A  14        inc  rsp
0002 A78C D35A  26        movb *rsp,ra
                   < elite.a99
22516               
22517 A78E 16EA  14        jne  TT44                       ; BNE TT44          ; Jump to TT26 (via TT44) to print the character in A
22518                                                                          ; (this BNE is effectively a JMP as A will never be
22519                                                                          ; zero)
22520               
22521               * ******************************************************************************
22522               *
22523               * Name: qw
22524               * Type: Subroutine
22525               * Category: Text
22526               * Summary: Print a recursive token in the range 128-145
22527               *
22528               * ------------------------------------------------------------------------------
22529               *
22530               * Print a recursive token where the token number is in 128-145 (so the value
22531               * passed to TT27 is in the range 14-31).
22532               *
22533               * ------------------------------------------------------------------------------
22534               *
22535               * Arguments:
22536               *
22537               * A                   A value from 128-145, which refers to a recursive token
22538               * in the range 14-31
22539               *
22540               * ******************************************************************************
22541               
22542               qw_:
22543                      .adi (>72*256)                  ; ADC #114          ; This is a recursive token in the range 0-95, so add
     **** ****     > ADI
0001 A790 1701  14        jnc  !
0002 A792 B347  18        ab   rone,ra
0003               !:
0004 A794 022D  22        ai   ra,(>72*256)
     A796 7200     
                   < elite.a99
22544 A798 1634  14        jne  ex_                        ; BNE ex            ; 114 to the argument to get the token number 128-145
22545                                                                          ; and jump to ex to print it
22546               
22547               * ******************************************************************************
22548               *
22549               * Name: crlf
22550               * Type: Subroutine
22551               * Category: Text
22552               * Summary: Tab to column 21 and print a colon
22553               *
22554               * ------------------------------------------------------------------------------
22555               *
22556               * Print control code 9 (tab to column 21 and print a colon). The subroutine
22557               * name is pretty misleading, as it doesn't have anything to do with carriage
22558               * returns or line feeds.
22559               *
22560               * ******************************************************************************
22561               
22562               crlf_:
22563 A79A 020D  20        li   ra,>15*256                 ; LDA #21           ; Set the X-column in XC to 21
     A79C 1500     
22564 A79E D80D  30        movb ra,@XC                     ; STA XC
     A7A0 002C     
22565               
22566 A7A2 16A0  14        jne  TT73                       ; BNE TT73          ; Jump to TT73, which prints a colon (this BNE is
22567                                                                          ; effectively a JMP as A will never be zero)
22568               
22569               * ******************************************************************************
22570               *
22571               * Name: TT45
22572               * Type: Subroutine
22573               * Category: Text
22574               * Summary: Print a letter in lower case
22575               *
22576               * ------------------------------------------------------------------------------
22577               *
22578               * This routine prints a letter in lower case. Specifically:
22579               *
22580               * * If QQ17 = 255, abort printing this character as printing is disabled
22581               *
22582               * * If this is a letter then print in lower case
22583               *
22584               * * Otherwise this is punctuation, so clear bit 6 in QQ17 and print
22585               *
22586               * ------------------------------------------------------------------------------
22587               *
22588               * Arguments:
22589               *
22590               * A                   The character to be printed. Can be one of the
22591               * following:
22592               *
22593               * * 7 (beep)
22594               *
22595               * * 10-13 (line feeds and carriage returns)
22596               *
22597               * * 32-95 (ASCII capital letters, numbers and
22598               * punctuation)
22599               *
22600               * X                   Contains the current value of QQ17
22601               *
22602               * QQ17                Bits 6 and 7 are set
22603               *
22604               * ******************************************************************************
22605               
22606               TT45:
22607                                                                          ; If we get here, then QQ17 has bit 6 and 7 set, so we
22608                                                                          ; are in Sentence Case and we need to print the next
22609                                                                          ; letter in lower case
22610 A7A4 028E  22        ci   rx,>ff*256                 ; CPX #255          ; If QQ17 = 255 then printing is disabled, so return
     A7A6 FF00     
22611 A7A8 1602  14        jne  FIX006                     ; BNE FIX006        ; from the subroutine (as TT48 contains an RTS)
22612 A7AA 0460  28        b    @TT48                      ; JMP TT48
     A7AC A88C     
22613               
22614               FIX006:
22615 A7AE 028D  22        ci   ra,('A')*256               ; CMP #'A'          ; If A >= ASCII "A", then jump to TT42, which will
     A7B0 4100     
22616 A7B2 18CE  14        joc  TT42                       ; BCS TT42          ; print the letter in lowercase
22617               
22618                                                                          ; Otherwise this is not a letter, it's punctuation, so
22619                                                                          ; this is effectively a word break. We therefore fall
22620                                                                          ; through to TT46 to print the character and set QQ17
22621                                                                          ; to ensure the next word starts with a capital letter
22622               
22623               * ******************************************************************************
22624               *
22625               * Name: TT46
22626               * Type: Subroutine
22627               * Category: Text
22628               * Summary: Print a character and switch to capitals
22629               *
22630               * ------------------------------------------------------------------------------
22631               *
22632               * Print a character and clear bit 6 in QQ17, so that the next letter that gets
22633               * printed after this will start with a capital letter.
22634               *
22635               * ------------------------------------------------------------------------------
22636               *
22637               * Arguments:
22638               *
22639               * A                   The character to be printed. Can be one of the
22640               * following:
22641               *
22642               * * 7 (beep)
22643               *
22644               * * 10-13 (line feeds and carriage returns)
22645               *
22646               * * 32-95 (ASCII capital letters, numbers and
22647               * punctuation)
22648               *
22649               * X                   Contains the current value of QQ17
22650               *
22651               * QQ17                Bits 6 and 7 are set
22652               *
22653               * ******************************************************************************
22654               
22655               TT46:
22656                      .pha                            ; PHA               ; Store the token number
     **** ****     > PHA
0001 A7B4 D68D  30        movb ra,*rsp
0002 A7B6 060A  14        dec  rsp
                   < elite.a99
22657               
22658 A7B8 D34E  18        movb rx,ra                      ; TXA               ; Clear bit 6 in QQ17 (X contains the current QQ17) so
22659 A7BA 024D  22        andi ra,>bf*256                 ; AND #%10111111    ; the next letter after this one is printed in upper
     A7BC BF00     
22660 A7BE D80D  30        movb ra,@QQ17                   ; STA QQ17          ; case
     A7C0 007E     
22661               
22662                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 A7C2 058A  14        inc  rsp
0002 A7C4 D35A  26        movb *rsp,ra
                   < elite.a99
22663               
22664                                                                          ; Now fall through into TT74 to print the character
22665               
22666               * ******************************************************************************
22667               *
22668               * Name: TT74
22669               * Type: Subroutine
22670               * Category: Text
22671               * Summary: Print a character
22672               *
22673               * ------------------------------------------------------------------------------
22674               *
22675               * Arguments:
22676               *
22677               * A                   The character to be printed
22678               *
22679               * ******************************************************************************
22680               
22681               TT74:
22682 A7C6 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     A7C8 3172     
22683               
22684               * ******************************************************************************
22685               *
22686               * Name: TT43
22687               * Type: Subroutine
22688               * Category: Text
22689               * Summary: Print a two-letter token or recursive token 0-95
22690               *
22691               * ------------------------------------------------------------------------------
22692               *
22693               * Print a two-letter token, or a recursive token where the token number is in
22694               * 0-95 (so the value passed to TT27 is in the range 160-255).
22695               *
22696               * ------------------------------------------------------------------------------
22697               *
22698               * Arguments:
22699               *
22700               * A                   One of the following:
22701               *
22702               * * 128-159 (two-letter token)
22703               *
22704               * * 160-255 (the argument to TT27 that refers to a
22705               * recursive token in the range 0-95)
22706               *
22707               * ******************************************************************************
22708               
22709               TT43:
22710 A7CA 028D  22        ci   ra,>a0*256                 ; CMP #160          ; If token >= 160, then this is a recursive token, so
     A7CC A000     
22711 A7CE 1815  14        joc  TT47                       ; BCS TT47          ; jump to TT47 below to process it
22712               
22713 A7D0 024D  22        andi ra,>7f*256                 ; AND #127          ; This is a two-letter token with number 128-159. The
     A7D2 7F00     
22714                      .asla                           ; ASL A             ; set of two-letter tokens is stored in a lookup table
     **** ****     > ASLA
0001 A7D4 024D  22        andi ra,>ff00
     A7D6 FF00     
0002 A7D8 0A1D  18        sla  ra,1
                   < elite.a99
22715                                                                          ; at QQ16, with each token taking up two bytes, so to
22716                                                                          ; convert this into the token's position in the table,
22717                                                                          ; we subtract 128 (or just clear bit 7) and multiply
22718                                                                          ; by 2 (or shift left)
22719               
22720 A7DA D3CD  18        movb ra,ry                      ; TAY               ; Transfer the token's position into Y so we can look
22721                                                                          ; up the token using absolute indexed mode
22722               
22723 A7DC D36F  34        movb @QQ16(ry),ra               ; LDA QQ16,Y        ; Get the first letter of the token and print it
     A7DE CEEE     
22724 A7E0 0200  20        li   rtmp,TT27                  ; JSR TT27
     A7E2 A6E8     
22725 A7E4 06A0  32        bl   @jsr                       ;
     A7E6 FE1E     
22726               
22727 A7E8 D36F  34        movb @QQ16+1(ry),ra             ; LDA QQ16+1,Y      ; Get the second letter of the token
     A7EA CEEF     
22728               
22729 A7EC 028D  22        ci   ra,('?')*256               ; CMP #'?'          ; If the second letter of the token is a question mark
     A7EE 3F00     
22730 A7F0 1602  14        jne  FIX007                     ; BNE FIX007        ; then this is a one-letter token, so just return from
22731                                                                          ; the subroutine without printing (as TT48 contains an
22732                                                                          ; RTS)
22733 A7F2 0460  28        b    @TT48                      ; JMP TT48
     A7F4 A88C     
22734               FIX007:
22735 A7F6 0460  28        b    @TT27                      ; JMP TT27          ; Print the second letter and return from the
     A7F8 A6E8     
22736                                                                          ; subroutine
22737               
22738               TT47:
22739                      .sbi (>a0*256)                  ; SBC #160          ; This is a recursive token in the range 160-255, so
     **** ****     > SBI
0001 A7FA 1801  14        joc  !
0002 A7FC 7347  18        sb   rone,ra
0003               !:
0004 A7FE 022D  22        ai   ra,-(>A0*256)
     A800 6000     
                   < elite.a99
22740                                                                          ; subtract 160 from the argument to get the token
22741                                                                          ; number 0-95 and fall through into ex to print it
22742               
22743               * ******************************************************************************
22744               *
22745               * Name: ex
22746               * Type: Subroutine
22747               * Category: Text
22748               * Summary: Print a recursive token
22749               * Deep dive: Printing text tokens
22750               *
22751               * ------------------------------------------------------------------------------
22752               *
22753               * This routine works its way through the recursive text tokens that are stored
22754               * in tokenised form in the table at QQ18, and when it finds token number A,
22755               * it prints it. Tokens are null-terminated in memory and fill three pages,
22756               * but there is no lookup table as that would consume too much memory, so the
22757               * only way to find the correct token is to start at the beginning and look
22758               * through the table byte by byte, counting tokens as we go until we are in the
22759               * right place. This approach might not be terribly speed efficient, but it is
22760               * certainly memory-efficient.
22761               *
22762               * ------------------------------------------------------------------------------
22763               *
22764               * Arguments:
22765               *
22766               * A                   The recursive token to be printed, in the range 0-148
22767               *
22768               * ------------------------------------------------------------------------------
22769               *
22770               * Other entry points:
22771               *
22772               * TT48                Contains an RTS
22773               *
22774               * ******************************************************************************
22775               
22776               ex_:
22777 A802 D38D  18        movb ra,rx                      ; TAX               ; Copy the token number into X
22778               
22779 A804 020D  20        li   ra,((QQ18)%256)*256        ; LDA #LO(QQ18)     ; Set V(1 0) to point to the recursive token table at
     A806 0000     
22780 A808 D80D  30        movb ra,@V                      ; STA V             ; location QQ18
     A80A 0022     
22781 A80C 020D  20        li   ra,((QQ18)/256)*256        ; LDA #HI(QQ18)
     A80E 0400     
22782 A810 D80D  30        movb ra,@V+1                    ; STA V+1
     A812 0023     
22783               
22784 A814 020F  20        li   ry,>00*256                 ; LDY #0            ; Set a counter Y to point to the character offset
     A816 0000     
22785                                                                          ; as we scan through the table
22786               
22787 A818 D34E  18        movb rx,ra                      ; TXA               ; Copy the token number back into A, so both A and X
22788                                                                          ; now contain the token number we want to print
22789               
22790 A81A 1311  14        jeq  TT50                       ; BEQ TT50          ; If the token number we want is 0, then we have
22791                                                                          ; already found the token we are looking for, so jump
22792                                                                          ; to TT50, otherwise start working our way through the
22793                                                                          ; null-terminated token table until we find the X-th
22794                                                                          ; token
22795               
22796               TT51:
22797                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch the Y-th character from the token table page
     **** ****     > LD_IND_Y_IDX
0001 A81C D820  50        movb @V,@rtmplb
     A81E 0022     
     A820 206D     
0002 A822 D020  30        movb @V+1,rtmp
     A824 0023     
0003 A826 A00F  18        a    ry,rtmp
0004 A828 D350  26        movb *rtmp,RA
                   < elite.a99
22798                                                                          ; we are currently scanning
22799               
22800 A82A 1304  14        jeq  TT49                       ; BEQ TT49          ; If the character is null, we've reached the end of
22801                                                                          ; this token, so jump to TT49
22802               
22803 A82C B3C7  18        ab   rone,ry                    ; INY               ; Increment character pointer and loop back around for
22804 A82E 16F6  14        jne  TT51                       ; BNE TT51          ; the next character in this token, assuming Y hasn't
22805                                                                          ; yet wrapped around to 0
22806               
22807 A830 B347  18        ab   rone,ra                    ; INC V+1           ; If it has wrapped round to 0, we have just crossed
22808 A832 16F4  14        jne  TT51                       ; BNE TT51          ; into a new page, so increment V+1 so that V points
22809                                                                          ; to the start of the new page
22810               
22811               TT49:
22812 A834 B3C7  18        ab   rone,ry                    ; INY               ; Increment the character pointer
22813               
22814 A836 1601  14        jne  TT59                       ; BNE TT59          ; If Y hasn't just wrapped around to 0, skip the next
22815                                                                          ; instruction
22816               
22817 A838 B347  18        ab   rone,ra                    ; INC V+1           ; We have just crossed into a new page, so increment
22818                                                                          ; V+1 so that V points to the start of the new page
22819               
22820               TT59:
22821 A83A 7387  18        sb   rone,rx                    ; DEX               ; We have just reached a new token, so decrement the
22822                                                                          ; token number we are looking for
22823               
22824 A83C 16EF  14        jne  TT51                       ; BNE TT51          ; Assuming we haven't yet reached the token number in
22825                                                                          ; X, look back up to keep fetching characters
22826               
22827               TT50:
22828                                                                          ; We have now reached the correct token in the token
22829                                                                          ; table, with Y pointing to the start of the token as
22830                                                                          ; an offset within the page pointed to by V, so let's
22831                                                                          ; print the recursive token. Because recursive tokens
22832                                                                          ; can contain other recursive tokens, we need to store
22833                                                                          ; our current state on the stack, so we can retrieve
22834                                                                          ; it after printing each character in this token
22835 A83E D34F  18        movb ry,ra                      ; TYA               ; Store the offset in Y on the stack
22836                      .pha                            ; PHA
     **** ****     > PHA
0001 A840 D68D  30        movb ra,*rsp
0002 A842 060A  14        dec  rsp
                   < elite.a99
22837               
22838 A844 D360  30        movb @V+1,ra                    ; LDA V+1           ; Store the high byte of V (the page containing the
     A846 0023     
22839                      .pha                            ; PHA               ; token we have found) on the stack, so the stack now
     **** ****     > PHA
0001 A848 D68D  30        movb ra,*rsp
0002 A84A 060A  14        dec  rsp
                   < elite.a99
22840                                                                          ; contains the address of the start of this token
22841               
22842                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the character at offset Y in the token table,
     **** ****     > LD_IND_Y_IDX
0001 A84C D820  50        movb @V,@rtmplb
     A84E 0022     
     A850 206D     
0002 A852 D020  30        movb @V+1,rtmp
     A854 0023     
0003 A856 A00F  18        a    ry,rtmp
0004 A858 D350  26        movb *rtmp,RA
                   < elite.a99
22843                                                                          ; which is the next character of this token that we
22844                                                                          ; want to print
22845               
22846                      .eoi ((RE)*256)                 ; EOR #RE           ; Tokens are stored in memory having been EOR'd with the
     **** ****     > EOI
0001 A85A 0200  20        li   rtmp,((RE)*256)
     A85C 2300     
0002 A85E 2B40  18        xor  rtmp,ra
                   < elite.a99
22847                                                                          ; value of RE - which is 35 for all versions of Elite
22848                                                                          ; except for NES, where RE is 62 - so we repeat the
22849                                                                          ; EOR to get the actual character to print
22850               
22851 A860 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A, which could be a letter,
     A862 A6E8     
22852 A864 06A0  32        bl   @jsr                       ;
     A866 FE1E     
22853                                                                          ; number, control code, two-letter token or another
22854                                                                          ; recursive token
22855               
22856                      .pla                            ; PLA               ; Restore the high byte of V (the page containing the
     **** ****     > PLA
0001 A868 058A  14        inc  rsp
0002 A86A D35A  26        movb *rsp,ra
                   < elite.a99
22857 A86C D80D  30        movb ra,@V+1                    ; STA V+1           ; token we have found) into V+1
     A86E 0023     
22858               
22859                      .pla                            ; PLA               ; Restore the offset into Y
     **** ****     > PLA
0001 A870 058A  14        inc  rsp
0002 A872 D35A  26        movb *rsp,ra
                   < elite.a99
22860 A874 D3CD  18        movb ra,ry                      ; TAY
22861               
22862 A876 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next character in the
22863                                                                          ; token we are printing
22864               
22865 A878 1601  14        jne  B65                        ; BNE B65           ; If Y is zero then we have just crossed into a new
22866 A87A B347  18        ab   rone,ra                    ; INC V+1           ; page, so increment V+1 so that V points to the start
22867                                                                          ; of the new page
22868               
22869               B65:
22870                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the next character we want to print into A
     **** ****     > LD_IND_Y_IDX
0001 A87C D820  50        movb @V,@rtmplb
     A87E 0022     
     A880 206D     
0002 A882 D020  30        movb @V+1,rtmp
     A884 0023     
0003 A886 A00F  18        a    ry,rtmp
0004 A888 D350  26        movb *rtmp,RA
                   < elite.a99
22871               
22872 A88A 16D9  14        jne  TT50                       ; BNE TT50          ; If this is not the null character at the end of the
22873                                                                          ; token, jump back up to TT50 to print the next
22874                                                                          ; character, otherwise we are done printing
22875               
22876               TT48:
22877 A88C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A88E FE2A     
22878               
22879               * ******************************************************************************
22880               *
22881               * Name: DOEXP
22882               * Type: Subroutine
22883               * Category: Drawing ships
22884               * Summary: Draw an exploding ship
22885               * Deep dive: Drawing explosion clouds
22886               * Generating random numbers
22887               *
22888               * ******************************************************************************
22889               
22890               EX2:
22891 A890 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bits 5 and 7 of the ship's byte #31 to denote that
     A892 0072     
22892 A894 026D  22        ori  ra,>a0*256                 ; ORA #%10100000    ; the ship is exploding and has been killed
     A896 A000     
22893 A898 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     A89A 0072     
22894               
22895 A89C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A89E FE2A     
22896               
22897               DOEXP:
22898 A8A0 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 6 of the ship's byte #31 is clear, then the
     A8A2 0072     
22899 A8A4 024D  22        andi ra,>40*256                 ; AND #%01000000    ; ship is not already exploding so there is no existing
     A8A6 4000     
22900 A8A8 1304  14        jeq  B66                        ; BEQ B66           ; explosion cloud to remove, so skip the following
22901                                                                          ; instruction
22902               
22903 A8AA 0200  20        li   rtmp,PTCLS                 ; JSR PTCLS         ; Call PTCLS to remove the existing cloud by drawing it
     A8AC A9D0     
22904 A8AE 06A0  32        bl   @jsr                       ;
     A8B0 FE1E     
22905                                                                          ; again
22906               
22907               B66:
22908 A8B2 D360  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set T = z_lo
     A8B4 0059     
22909 A8B6 D80D  30        movb ra,@T                      ; STA T
     A8B8 00D1     
22910               
22911 A8BA D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi, so (A T) = z
     A8BC 005A     
22912               
22913 A8BE 028D  22        ci   ra,>20*256                 ; CMP #32           ; If z_hi < 32, skip the next two instructions
     A8C0 2000     
22914 A8C2 1703  14        jnc  B67                        ; BCC B67
22915               
22916 A8C4 020D  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and jump to yy (this BNE is effectively a
     A8C6 FE00     
22917 A8C8 1615  14        jne  yy_                        ; BNE yy            ; JMP, as A is never zero)
22918               
22919               B67:
22920                      .asl @T                         ; ASL T             ; Shift (A T) left twice
     **** ****     > ASL
0001 A8CA D020  30        movb @T,rtmp
     A8CC 00D1     
0002 A8CE 0240  22        andi rtmp,>ff00
     A8D0 FF00     
0003 A8D2 0A10  18        sla  rtmp,1
0004 A8D4 D800  30        movb rtmp,@T
     A8D6 00D1     
                   < elite.a99
22921 A8D8 06A0  32        bl   @rola                      ; ROL A
     A8DA FE34     
22922                      .asl @T                         ; ASL T
     **** ****     > ASL
0001 A8DC D020  30        movb @T,rtmp
     A8DE 00D1     
0002 A8E0 0240  22        andi rtmp,>ff00
     A8E2 FF00     
0003 A8E4 0A10  18        sla  rtmp,1
0004 A8E6 D800  30        movb rtmp,@T
     A8E8 00D1     
                   < elite.a99
22923 A8EA 06A0  32        bl   @rola                      ; ROL A
     A8EC FE34     
22924               
22925                      .sec                            ; SEC               ; And then shift A left once more, inserting a 1 into
     **** ****     > SEC
0001 A8EE 0A18  18        sla  rmone,1
                   < elite.a99
22926 A8F0 06A0  32        bl   @rola                      ; ROL A             ; bit 0
     A8F2 FE34     
22927               
22928                                                                          ; Overall, the above multiplies A by 8 and makes sure it
22929                                                                          ; is at least 1, to leave a one-byte distance in A. We
22930                                                                          ; can use this as the distance for our cloud, to ensure
22931                                                                          ; that the explosion cloud is visible even for ships
22932                                                                          ; that blow up a long way away
22933               
22934               yy_:
22935 A8F4 D80D  30        movb ra,@Q                      ; STA Q             ; Store the distance to the explosion in Q
     A8F6 0090     
22936               
22937 A8F8 020F  20        li   ry,>01*256                 ; LDY #1            ; Fetch byte #1 of the ship line heap, which contains
     A8FA 0100     
22938                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud counter
     **** ****     > LD_IND_Y_IDX
0001 A8FC D820  50        movb @XX19,@rtmplb
     A8FE 0074     
     A900 206D     
0002 A902 D020  30        movb @XX19+1,rtmp
     A904 0075     
0003 A906 A00F  18        a    ry,rtmp
0004 A908 D350  26        movb *rtmp,RA
                   < elite.a99
22939               
22940                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the cloud counter, so it ticks onwards every
     **** ****     > ADI
0001 A90A 1701  14        jnc  !
0002 A90C B347  18        ab   rone,ra
0003               !:
0004 A90E 022D  22        ai   ra,(>04*256)
     A910 0400     
                   < elite.a99
22941                                                                          ; we redraw it
22942               
22943 A912 18BE  14        joc  EX2                        ; BCS EX2           ; If the addition overflowed, jump up to EX2 to update
22944                                                                          ; the explosion flags and return from the subroutine
22945               
22946                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the updated cloud counter in byte #1 of the ship
     **** ****     > ST_IND_Y_IDX
0001 A914 D820  50        movb @XX19,@rtmplb
     A916 0074     
     A918 206D     
0002 A91A D020  30        movb @XX19+1,rtmp
     A91C 0075     
0003 A91E A00F  18        a    ry,rtmp
0004 A920 D40D  30        movb RA,*rtmp
                   < elite.a99
22947                                                                          ; line heap
22948               
22949 A922 0200  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     A924 45B0     
22950 A926 06A0  32        bl   @jsr                       ;
     A928 FE1E     
22951                                                                          ;
22952                                                                          ; (P R) = 256 * A / Q
22953                                                                          ; = 256 * cloud counter / distance
22954                                                                          ;
22955                                                                          ; We are going to use this as our cloud size, so the
22956                                                                          ; further away the cloud, the smaller it is, and as the
22957                                                                          ; cloud counter ticks onward, the cloud expands
22958               
22959 A92A D360  30        movb @P,ra                      ; LDA P             ; Set A = P, so we now have:
     A92C 001B     
22960                                                                          ;
22961                                                                          ; (A R) = 256 * cloud counter / distance
22962               
22963 A92E 028D  22        ci   ra,>1c*256                 ; CMP #&1C          ; If A < 28, skip the next two instructions
     A930 1C00     
22964 A932 1703  14        jnc  B68                        ; BCC B68
22965               
22966 A934 020D  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and skip the following (this BNE is
     A936 FE00     
22967 A938 161B  14        jne  LABEL_1                    ; BNE LABEL_1       ; effectively a JMP as A is never zero)
22968               
22969               B68:
22970                      .asl @R                         ; ASL R             ; Shift (A R) left three times to multiply by 8
     **** ****     > ASL
0001 A93A D020  30        movb @R,rtmp
     A93C 0091     
0002 A93E 0240  22        andi rtmp,>ff00
     A940 FF00     
0003 A942 0A10  18        sla  rtmp,1
0004 A944 D800  30        movb rtmp,@R
     A946 0091     
                   < elite.a99
22971 A948 06A0  32        bl   @rola                      ; ROL A
     A94A FE34     
22972                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 A94C D020  30        movb @R,rtmp
     A94E 0091     
0002 A950 0240  22        andi rtmp,>ff00
     A952 FF00     
0003 A954 0A10  18        sla  rtmp,1
0004 A956 D800  30        movb rtmp,@R
     A958 0091     
                   < elite.a99
22973 A95A 06A0  32        bl   @rola                      ; ROL A
     A95C FE34     
22974                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 A95E D020  30        movb @R,rtmp
     A960 0091     
0002 A962 0240  22        andi rtmp,>ff00
     A964 FF00     
0003 A966 0A10  18        sla  rtmp,1
0004 A968 D800  30        movb rtmp,@R
     A96A 0091     
                   < elite.a99
22975 A96C 06A0  32        bl   @rola                      ; ROL A
     A96E FE34     
22976               
22977                                                                          ; Overall, the above multiplies (A R) by 8 to leave a
22978                                                                          ; one-byte cloud size in A, given by the following:
22979                                                                          ;
22980                                                                          ; A = 8 * cloud counter / distance
22981               
22982               LABEL_1:
22983 A970 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0
22984               
22985                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the cloud size in byte #0 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 A972 D820  50        movb @XX19,@rtmplb
     A974 0074     
     A976 206D     
0002 A978 D020  30        movb @XX19+1,rtmp
     A97A 0075     
0003 A97C A00F  18        a    ry,rtmp
0004 A97E D40D  30        movb RA,*rtmp
                   < elite.a99
22986               
22987 A980 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 6 of the ship's byte #31 to denote that the
     A982 0072     
22988 A984 024D  22        andi ra,>bf*256                 ; AND #%10111111    ; explosion has not yet been drawn
     A986 BF00     
22989 A988 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     A98A 0072     
22990               
22991 A98C 024D  22        andi ra,>08*256                 ; AND #%00001000    ; If bit 3 of the ship's byte #31 is clear, then nothing
     A98E 0800     
22992 A990 1602  14        jne  FIX008                     ; BNE FIX008        ; is being drawn on-screen for this ship anyway, so
22993 A992 0460  28        b    @TT48                      ; JMP TT48          ; return from the subroutine (as TT48 contains an RTS)
     A994 A88C     
22994               
22995               FIX008:
22996 A996 020F  20        li   ry,>02*256                 ; LDY #2            ; Otherwise it's time to draw an explosion cloud, so
     A998 0200     
22997                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; fetch byte #2 of the ship line heap into Y, which we
     **** ****     > LD_IND_Y_IDX
0001 A99A D820  50        movb @XX19,@rtmplb
     A99C 0074     
     A99E 206D     
0002 A9A0 D020  30        movb @XX19+1,rtmp
     A9A2 0075     
0003 A9A4 A00F  18        a    ry,rtmp
0004 A9A6 D350  26        movb *rtmp,RA
                   < elite.a99
22998 A9A8 D3CD  18        movb ra,ry                      ; TAY               ; set to the explosion count for this ship (i.e. the
22999                                                                          ; number of vertices used as origins for explosion
23000                                                                          ; clouds)
23001                                                                          ;
23002                                                                          ; The explosion count is stored as 4 * n + 6, where n is
23003                                                                          ; the number of vertices, so the following loop copies
23004                                                                          ; the coordinates of the first n vertices from the heap
23005                                                                          ; at XX3, which is where we stored all the visible
23006                                                                          ; vertex coordinates in part 8 of the LL9 routine, and
23007                                                                          ; sticks them in the ship line heap pointed to by XX19,
23008                                                                          ; starting at byte #7 (so it leaves the first 6 bytes of
23009                                                                          ; the ship line heap alone)
23010               
23011               EXL1:
23012 A9AA D36F  34        movb @XX3-7(ry),ra              ; LDA XX3-7,Y       ; Copy byte Y-7 from the XX3 heap, into the Y-th byte of
     A9AC 00F9     
23013                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 A9AE D820  50        movb @XX19,@rtmplb
     A9B0 0074     
     A9B2 206D     
0002 A9B4 D020  30        movb @XX19+1,rtmp
     A9B6 0075     
0003 A9B8 A00F  18        a    ry,rtmp
0004 A9BA D40D  30        movb RA,*rtmp
                   < elite.a99
23014               
23015 A9BC 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
23016               
23017 A9BE 028F  22        ci   ry,>06*256                 ; CPY #6            ; Keep copying vertex coordinates into the ship line
     A9C0 0600     
23018 A9C2 16F3  14        jne  EXL1                       ; BNE EXL1          ; heap until Y = 6 (which will copy n vertices, where n
23019                                                                          ; is the number of vertices we should be exploding)
23020               
23021 A9C4 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 of the ship's byte #31 to denote that the
     A9C6 0072     
23022 A9C8 026D  22        ori  ra,>40*256                 ; ORA #%01000000    ; explosion has been drawn (as it's about to be)
     A9CA 4000     
23023 A9CC D80D  30        movb ra,@INWK+31                ; STA INWK+31
     A9CE 0072     
23024               
23025               PTCLS:
23026                                                                          ; This part of the routine actually draws the explosion
23027                                                                          ; cloud
23028 A9D0 020F  20        li   ry,>00*256                 ; LDY #0            ; Fetch byte #0 of the ship line heap, which contains
     A9D2 0000     
23029                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud size we stored above, and store it in Q
     **** ****     > LD_IND_Y_IDX
0001 A9D4 D820  50        movb @XX19,@rtmplb
     A9D6 0074     
     A9D8 206D     
0002 A9DA D020  30        movb @XX19+1,rtmp
     A9DC 0075     
0003 A9DE A00F  18        a    ry,rtmp
0004 A9E0 D350  26        movb *rtmp,RA
                   < elite.a99
23030 A9E2 D80D  30        movb ra,@Q                      ; STA Q
     A9E4 0090     
23031               
23032 A9E6 B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #1
23033               
23034                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #1 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 A9E8 D820  50        movb @XX19,@rtmplb
     A9EA 0074     
     A9EC 206D     
0002 A9EE D020  30        movb @XX19+1,rtmp
     A9F0 0075     
0003 A9F2 A00F  18        a    ry,rtmp
0004 A9F4 D350  26        movb *rtmp,RA
                   < elite.a99
23035                                                                          ; the cloud counter. We are now going to process this
23036                                                                          ; into the number of particles in each vertex's cloud
23037               
23038 A9F6 1503  14        jgt  B69                        ; BPL B69           ; If the cloud counter < 128, then we are in the first
23039                                                                          ; half of the cloud's existence, so skip the next
23040                                                                          ; instruction
23041               
23042                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the value of A so that in the second half of the
     **** ****     > EOI
0001 A9F8 0200  20        li   rtmp,(>FF*256)
     A9FA FF00     
0002 A9FC 2B40  18        xor  rtmp,ra
                   < elite.a99
23043                                                                          ; cloud's existence, A counts down instead of up
23044               
23045               B69:
23046 A9FE 091D  18        srl  ra,1                       ; LSR A             ; Divide A by 8 so that is has a maximum value of 15
23047 AA00 091D  18        srl  ra,1                       ; LSR A
23048 AA02 091D  18        srl  ra,1                       ; LSR A
23049               
23050 AA04 026D  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1 and store it in U, to
     AA06 0100     
23051 AA08 D80D  30        movb ra,@U                      ; STA U             ; give us the number of particles in the explosion for
     AA0A 008F     
23052                                                                          ; each vertex
23053               
23054 AA0C B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #2
23055               
23056                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #2 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 AA0E D820  50        movb @XX19,@rtmplb
     AA10 0074     
     AA12 206D     
0002 AA14 D020  30        movb @XX19+1,rtmp
     AA16 0075     
0003 AA18 A00F  18        a    ry,rtmp
0004 AA1A D350  26        movb *rtmp,RA
                   < elite.a99
23057 AA1C D80D  30        movb ra,@TGT                    ; STA TGT           ; the explosion count for this ship (i.e. the number of
     AA1E 00A0     
23058                                                                          ; vertices used as origins for explosion clouds) and
23059                                                                          ; store it in TGT
23060               
23061 AA20 D360  30        movb @RAND+1,ra                 ; LDA RAND+1        ; Fetch the current random number seed in RAND+1 and
     AA22 0001     
23062                      .pha                            ; PHA               ; store it on the stack, so we can re-randomise the
     **** ****     > PHA
0001 AA24 D68D  30        movb ra,*rsp
0002 AA26 060A  14        dec  rsp
                   < elite.a99
23063                                                                          ; seeds when we are done
23064               
23065 AA28 020F  20        li   ry,>06*256                 ; LDY #6            ; Set Y = 6 to point to the byte before the first vertex
     AA2A 0600     
23066                                                                          ; coordinate we stored on the ship line heap above (we
23067                                                                          ; increment it below so it points to the first vertex)
23068               
23069               EXL5:
23070 AA2C 020E  20        li   rx,>03*256                 ; LDX #3            ; We are about to fetch a pair of coordinates from the
     AA2E 0300     
23071                                                                          ; ship line heap, so set a counter in X for 4 bytes
23072               
23073               EXL3:
23074 AA30 B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next byte
23075                                                                          ; from the coordinate we are copying
23076               
23077                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Copy the Y-th byte from the ship line heap to the X-th
     **** ****     > LD_IND_Y_IDX
0001 AA32 D820  50        movb @XX19,@rtmplb
     AA34 0074     
     AA36 206D     
0002 AA38 D020  30        movb @XX19+1,rtmp
     AA3A 0075     
0003 AA3C A00F  18        a    ry,rtmp
0004 AA3E D350  26        movb *rtmp,RA
                   < elite.a99
23078 AA40 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X          ; byte of K3
     AA42 00D2     
23079               
23080 AA44 7387  18        sb   rone,rx                    ; DEX               ; Decrement the X index
23081               
23082 AA46 15F4  14        jgt  EXL3                       ; BPL EXL3          ; Loop back to EXL3 until we have copied all four bytes
23083               
23084                                                                          ; The above loop copies the vertex coordinates from the
23085                                                                          ; ship line heap to K3, reversing them as we go, so it
23086                                                                          ; sets the following:
23087                                                                          ;
23088                                                                          ; K3+3 = x_lo
23089                                                                          ; K3+2 = x_hi
23090                                                                          ; K3+1 = y_lo
23091                                                                          ; K3+0 = y_hi
23092               
23093 AA48 D80F  30        movb ry,@CNT                    ; STY CNT           ; Set CNT to the index that points to the next vertex on
     AA4A 00A4     
23094                                                                          ; the ship line heap
23095               
23096 AA4C 020F  20        li   ry,>02*256                 ; LDY #2            ; Set Y = 2, which we will use to point to bytes #3 to
     AA4E 0200     
23097                                                                          ; #6, after incrementing it
23098               
23099                                                                          ; This next loop copies bytes #3 to #6 from the ship
23100                                                                          ; line heap into the four random number seeds in RAND to
23101                                                                          ; RAND+3, EOR'ing them with the vertex index so they are
23102                                                                          ; different for every vertex. This enables us to
23103                                                                          ; generate random numbers for drawing each vertex that
23104                                                                          ; are random but repeatable, which we need when we
23105                                                                          ; redraw the cloud to remove it
23106                                                                          ;
23107                                                                          ; Note that we haven't actually set the values of bytes
23108                                                                          ; #3 to #6 in the ship line heap, so we have no idea
23109                                                                          ; what they are, we just use what's already there. But
23110                                                                          ; the fact that those bytes are stored for this ship
23111                                                                          ; means we can repeat the random generation of the
23112                                                                          ; cloud, which is the important bit
23113               
23114               EXL2:
23115 AA50 B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next
23116                                                                          ; random number seed to copy
23117               
23118                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y-th byte from the ship line heap
     **** ****     > LD_IND_Y_IDX
0001 AA52 D820  50        movb @XX19,@rtmplb
     AA54 0074     
     AA56 206D     
0002 AA58 D020  30        movb @XX19+1,rtmp
     AA5A 0075     
0003 AA5C A00F  18        a    ry,rtmp
0004 AA5E D350  26        movb *rtmp,RA
                   < elite.a99
23119               
23120                      .eor @CNT                       ; EOR CNT           ; EOR with the vertex index, so the seeds are different
     **** ****     > EOR
0001 AA60 D020  30        movb @CNT,rtmp
     AA62 00A4     
0002 AA64 2B40  18        xor  rtmp,ra
                   < elite.a99
23121                                                                          ; for each vertex
23122               
23123 AA66 DBCD  38        movb ra,@>FFFD(ry)              ; STA &FFFD,Y       ; Y is going from 3 to 6, so this stores the four bytes
     AA68 FFFD     
23124                                                                          ; in memory locations &00, &01, &02 and &03, which are
23125                                                                          ; the memory locations of RAND through RAND+3
23126               
23127 AA6A 028F  22        ci   ry,>06*256                 ; CPY #6            ; Loop back to EXL2 until Y = 6, which means we have
     AA6C 0600     
23128 AA6E 16F0  14        jne  EXL2                       ; BNE EXL2          ; copied four bytes
23129               
23130 AA70 D3E0  30        movb @U,ry                      ; LDY U             ; Set Y to the number of particles in the explosion for
     AA72 008F     
23131                                                                          ; each vertex, which we stored in U above. We will now
23132                                                                          ; use this as a loop counter to iterate through all the
23133                                                                          ; particles in the explosion
23134               
23135               EXL4:
23136 AA74 0200  20        li   rtmp,DORND2                ; JSR DORND2        ; Set ZZ to a random number, making sure the C flag
     AA76 C07A     
23137 AA78 06A0  32        bl   @jsr                       ;
     AA7A FE1E     
23138 AA7C D80D  30        movb ra,@ZZ                     ; STA ZZ            ; doesn't affect the outcome
     AA7E 0097     
23139               
23140 AA80 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Set (A R) = (y_hi y_lo)
     AA82 00D3     
23141 AA84 D80D  30        movb ra,@R                      ; STA R             ; = y
     AA86 0091     
23142 AA88 D360  30        movb @K3,ra                     ; LDA K3
     AA8A 00D2     
23143               
23144 AA8C 0200  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     AA8E AAF0     
23145 AA90 06A0  32        bl   @jsr                       ;
     AA92 FE1E     
23146                                                                          ; = y +/- random * cloud size
23147               
23148 AA94 1627  14        jne  EX11                       ; BNE EX11          ; If A is non-zero, the particle is off-screen as the
23149                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23150                                                                          ; the next particle
23151               
23152 AA96 028E  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If X > the y-coordinate of the bottom of the screen,
     AA98 BF00     
23153 AA9A 1824  14        joc  EX11                       ; BCS EX11          ; the particle is off the bottom of the screen, so jump
23154                                                                          ; to EX11 to do the next particle
23155               
23156                                                                          ; Otherwise X contains a random y-coordinate within the
23157                                                                          ; cloud
23158               
23159 AA9C D80E  30        movb rx,@Y1                     ; STX Y1            ; Set Y1 = our random y-coordinate within the cloud
     AA9E 0032     
23160               
23161 AAA0 D360  30        movb @K3+3,ra                   ; LDA K3+3          ; Set (A R) = (x_hi x_lo)
     AAA2 00D5     
23162 AAA4 D80D  30        movb ra,@R                      ; STA R
     AAA6 0091     
23163 AAA8 D360  30        movb @K3+2,ra                   ; LDA K3+2
     AAAA 00D4     
23164               
23165 AAAC 0200  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     AAAE AAF0     
23166 AAB0 06A0  32        bl   @jsr                       ;
     AAB2 FE1E     
23167                                                                          ; = x +/- random * cloud size
23168               
23169 AAB4 1606  14        jne  EX4                        ; BNE EX4           ; If A is non-zero, the particle is off-screen as the
23170                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23171                                                                          ; the next particle
23172               
23173                                                                          ; Otherwise X contains a random x-coordinate within the
23174                                                                          ; cloud
23175               
23176 AAB6 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = our random y-coordinate within the cloud
     AAB8 0032     
23177               
23178 AABA 0200  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Draw a point at screen coordinate (X, A) with the
     AABC 27BC     
23179 AABE 06A0  32        bl   @jsr                       ;
     AAC0 FE1E     
23180                                                                          ; point size determined by the distance in ZZ
23181               
23182               EX4:
23183 AAC2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter for the next particle
23184               
23185 AAC4 15D7  14        jgt  EXL4                       ; BPL EXL4          ; Loop back to EXL4 until we have done all the particles
23186                                                                          ; in the cloud
23187               
23188 AAC6 D3E0  30        movb @CNT,ry                    ; LDY CNT           ; Set Y to the index that points to the next vertex on
     AAC8 00A4     
23189                                                                          ; the ship line heap
23190               
23191 AACA 93E0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y < TGT, which we set to the explosion count for
     AACC 00A0     
23192 AACE 17AE  14        jnc  EXL5                       ; BCC EXL5          ; this ship (i.e. the number of vertices used as origins
23193                                                                          ; for explosion clouds), loop back to EXL5 to do a cloud
23194                                                                          ; for the next vertex
23195               
23196                      .pla                            ; PLA               ; Restore the current random number seed to RAND+1 that
     **** ****     > PLA
0001 AAD0 058A  14        inc  rsp
0002 AAD2 D35A  26        movb *rsp,ra
                   < elite.a99
23197 AAD4 D80D  30        movb ra,@RAND+1                 ; STA RAND+1        ; we stored at the start of the routine
     AAD6 0001     
23198               
23199 AAD8 D360  30        movb @K.+6,ra                   ; LDA K%+6          ; Store the z_lo coordinate for the planet (which will
     AADA 0906     
23200 AADC D80D  30        movb ra,@RAND+3                 ; STA RAND+3        ; be pretty random) in the RAND+3 seed
     AADE 0003     
23201               
23202 AAE0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AAE2 FE2A     
23203               
23204               EX11:
23205 AAE4 0200  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     AAE6 C07A     
23206 AAE8 06A0  32        bl   @jsr                       ;
     AAEA FE1E     
23207                                                                          ; doesn't affect the outcome
23208               
23209 AAEC 0460  28        b    @EX4                       ; JMP EX4           ; We just skipped a particle, so jump up to EX4 to do
     AAEE AAC2     
23210                                                                          ; the next one
23211               
23212               EXS1:
23213                                                                          ; This routine calculates the following:
23214                                                                          ;
23215                                                                          ; (A X) = (A R) +/- random * cloud size
23216                                                                          ;
23217                                                                          ; returning with the flags set for the high byte in A
23218 AAF0 D80D  30        movb ra,@S                      ; STA S             ; Store A in S so we can use it later
     AAF2 0092     
23219               
23220 AAF4 0200  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     AAF6 C07A     
23221 AAF8 06A0  32        bl   @jsr                       ;
     AAFA FE1E     
23222                                                                          ; doesn't affect the outcome
23223               
23224 AAFC 06A0  32        bl   @rola                      ; ROL A             ; Set A = A * 2
     AAFE FE34     
23225               
23226 AB00 1811  14        joc  EX5                        ; BCS EX5           ; If bit 7 of A was set (50% chance), jump to EX5
23227               
23228 AB02 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set A = A * Q / 256
     AB04 4338     
23229 AB06 06A0  32        bl   @jsr                       ;
     AB08 FE1E     
23230                                                                          ; = random << 1 * projected cloud size / 256
23231               
23232                      .adc @R,ra                      ; ADC R             ; Set (A X) = (S R) + A
     **** ****     > ADC
0001 AB0A 1701  14        jnc  !
0002 AB0C B347  18        ab   rone,ra
0003               !:
0004 AB0E B360  30        ab   @R,ra
     AB10 0091     
                   < elite.a99
23233 AB12 D38D  18        movb ra,rx                      ; TAX               ; = (S R) + random * projected cloud size
23234                                                                          ;
23235                                                                          ; where S contains the argument A, starting with the low
23236                                                                          ; bytes
23237               
23238 AB14 D360  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     AB16 0092     
23239                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 AB18 1701  14        jnc  !
0002 AB1A B347  18        ab   rone,ra
0003               !:
0004 AB1C 022D  22        ai   ra,(>00*256)
     AB1E 0000     
                   < elite.a99
23240               
23241 AB20 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AB22 FE2A     
23242               
23243               EX5:
23244 AB24 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     AB26 4338     
23245 AB28 06A0  32        bl   @jsr                       ;
     AB2A FE1E     
23246 AB2C D80D  30        movb ra,@T                      ; STA T             ; = random << 1 * projected cloud size / 256
     AB2E 00D1     
23247               
23248 AB30 D360  30        movb @R,ra                      ; LDA R             ; Set (A X) = (S R) - T
     AB32 0091     
23249                      .sbc @T,ra                      ; SBC T             ;
     **** ****     > SBC
0001 AB34 1801  14        joc  !
0002 AB36 7347  18        sb   rone,ra
0003               !:
0004 AB38 7360  30        sb   @T,ra
     AB3A 00D1     
                   < elite.a99
23250 AB3C D38D  18        movb ra,rx                      ; TAX               ; where S contains the argument A, starting with the low
23251                                                                          ; bytes
23252               
23253 AB3E D360  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     AB40 0092     
23254                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 AB42 1801  14        joc  !
0002 AB44 7347  18        sb   rone,ra
0003               !:
0004 AB46 022D  22        ai   ra,-(>00*256)
     AB48 0000     
                   < elite.a99
23255               
23256 AB4A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AB4C FE2A     
23257               
23258               * ******************************************************************************
23259               *
23260               * Name: SOS1
23261               * Type: Subroutine
23262               * Category: Universe
23263               * Summary: Update the missile indicators, set up the planet data block
23264               *
23265               * ------------------------------------------------------------------------------
23266               *
23267               * Update the missile indicators, and set up a data block for the planet, but
23268               * only setting the pitch and roll counters to 127 (no damping).
23269               *
23270               * ******************************************************************************
23271               
23272               SOS1:
23273 AB4E 0200  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     AB50 BFE8     
23274 AB52 06A0  32        bl   @jsr                       ;
     AB54 FE1E     
23275                                                                          ; them are targeted
23276               
23277 AB56 020D  20        li   ra,>7f*256                 ; LDA #127          ; Set the pitch and roll counters to 127, so that's a
     AB58 7F00     
23278 AB5A D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; clockwise roll and a diving pitch with no damping, so
     AB5C 0070     
23279 AB5E D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; the planet's rotation doesn't slow down
     AB60 0071     
23280               
23281 AB62 D360  30        movb @tek_,ra                   ; LDA tek           ; Set A = 128 or 130 depending on bit 1 of the system's
     AB64 0F1D     
23282 AB66 024D  22        andi ra,>02*256                 ; AND #%00000010    ; tech level in tek
     AB68 0200     
23283 AB6A 026D  22        ori  ra,>80*256                 ; ORA #%10000000
     AB6C 8000     
23284               
23285 AB6E 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Add a new planet to our local bubble of universe,
     AB70 AF7A     
23286                                                                          ; with the planet type defined by A (128 is a planet
23287                                                                          ; with an equator and meridian, 130 is a planet with
23288                                                                          ; a crater)
23289               
23290               * ******************************************************************************
23291               *
23292               * Name: SOLAR
23293               * Type: Subroutine
23294               * Category: Universe
23295               * Summary: Set up various aspects of arriving in a new system
23296               *
23297               * ------------------------------------------------------------------------------
23298               *
23299               * Halve our legal status, update the missile indicators, and set up data blocks
23300               * and slots for the planet and sun.
23301               *
23302               * ******************************************************************************
23303               
23304               SOLAR:
23305                      .lsr @FIST                      ; LSR FIST          ; Halve our legal status in FIST, making us less bad,
     **** ****     > LSR
0001 AB72 D020  30        movb @FIST,rtmp
     AB74 0334     
0002 AB76 0910  18        srl  rtmp,1
0003 AB78 D800  30        movb rtmp,@FIST
     AB7A 0334     
                   < elite.a99
23306                                                                          ; and moving bit 0 into the C flag (so every time we
23307                                                                          ; arrive in a new system, our legal status improves a
23308                                                                          ; bit)
23309               
23310 AB7C 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace, which
     AB7E BFC0     
23311 AB80 06A0  32        bl   @jsr                       ;
     AB82 FE1E     
23312                                                                          ; doesn't affect the C flag
23313               
23314 AB84 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi
     AB86 0079     
23315               
23316 AB88 024D  22        andi ra,>07*256                 ; AND #%00000111    ; Extract bits 0-2 (which also happen to determine the
     AB8A 0700     
23317                                                                          ; economy), which will be between 0 and 7
23318               
23319                      .adi (>06*256)                  ; ADC #6            ; Add 6 + C, and divide by 2, to get a result between 3
     **** ****     > ADI
0001 AB8C 1701  14        jnc  !
0002 AB8E B347  18        ab   rone,ra
0003               !:
0004 AB90 022D  22        ai   ra,(>06*256)
     AB92 0600     
                   < elite.a99
23320 AB94 091D  18        srl  ra,1                       ; LSR A             ; and 7, at the same time shifting bit 0 of the result
23321                                                                          ; of the addition into the C flag
23322               
23323 AB96 D80D  30        movb ra,@INWK+8                 ; STA INWK+8        ; Store the result in z_sign in byte #6
     AB98 005B     
23324               
23325 AB9A 06A0  32        bl   @rora                      ; ROR A             ; Halve A, rotating in the C flag, which was previously
     AB9C FE58     
23326 AB9E D80D  30        movb ra,@INWK+2                 ; STA INWK+2        ; bit 0 of s0_hi + 6 + C, so when this is stored in both
     ABA0 0055     
23327 ABA2 D80D  30        movb ra,@INWK+5                 ; STA INWK+5        ; x_sign and y_sign, it moves the planet to the upper
     ABA4 0058     
23328                                                                          ; right or lower left
23329               
23330 ABA6 0200  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     ABA8 AB4E     
23331 ABAA 06A0  32        bl   @jsr                       ;
     ABAC FE1E     
23332                                                                          ; to FRIN, where it will get put in the first slot as
23333                                                                          ; it's the first one to be added to our local bubble of
23334                                                                          ; this new system's universe
23335               
23336 ABAE D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Fetch s1_hi, extract bits 0-2, set bits 0 and 7 and
     ABB0 007B     
23337 ABB2 024D  22        andi ra,>07*256                 ; AND #%00000111    ; store in z_sign, so the sun is behind us at a distance
     ABB4 0700     
23338 ABB6 026D  22        ori  ra,>81*256                 ; ORA #%10000001    ; of 1 to 7
     ABB8 8100     
23339 ABBA D80D  30        movb ra,@INWK+8                 ; STA INWK+8
     ABBC 005B     
23340               
23341 ABBE D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi, extract bits 0-1 and store in x_sign and
     ABC0 007D     
23342 ABC2 024D  22        andi ra,>03*256                 ; AND #%00000011    ; y_sign, so the sun is either dead centre in our rear
     ABC4 0300     
23343 ABC6 D80D  30        movb ra,@INWK+2                 ; STA INWK+2        ; laser crosshairs, or off to the top left by a distance
     ABC8 0055     
23344 ABCA D80D  30        movb ra,@INWK+1                 ; STA INWK+1        ; of 1 or 2 when we look out the back
     ABCC 0054     
23345               
23346 ABCE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the pitch and roll counters to 0 (no rotation)
     ABD0 0000     
23347 ABD2 D80D  30        movb ra,@INWK+29                ; STA INWK+29
     ABD4 0070     
23348 ABD6 D80D  30        movb ra,@INWK+30                ; STA INWK+30
     ABD8 0071     
23349               
23350 ABDA 020D  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     ABDC 8100     
23351               
23352 ABDE 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Call NWSHP to set up the sun's data block and add it
     ABE0 AF7A     
23353 ABE2 06A0  32        bl   @jsr                       ;
     ABE4 FE1E     
23354                                                                          ; to FRIN, where it will get put in the second slot as
23355                                                                          ; it's the second one to be added to our local bubble
23356                                                                          ; of this new system's universe
23357               
23358               * ******************************************************************************
23359               *
23360               * Name: NWSTARS
23361               * Type: Subroutine
23362               * Category: Stardust
23363               * Summary: Initialise the stardust field
23364               *
23365               * ------------------------------------------------------------------------------
23366               *
23367               * This routine is called when the space view is initialised in routine LOOK1.
23368               *
23369               * ******************************************************************************
23370               
23371               NWSTARS:
23372 ABE6 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to WPSHPS to skip
     ABE8 0096     
23373               * ORA MJ                 \ the initialisation of the SX, SY and SZ tables. The OR
23374 ABEA 1622  14        jne  WPSHPS                     ; BNE WPSHPS        ; instruction is commented out in the original source,
23375                                                                          ; but it would have the effect of also skipping the
23376                                                                          ; initialisation if we had mis-jumped into witchspace
23377               
23378               * ******************************************************************************
23379               *
23380               * Name: nWq
23381               * Type: Subroutine
23382               * Category: Stardust
23383               * Summary: Create a random cloud of stardust
23384               *
23385               * ------------------------------------------------------------------------------
23386               *
23387               * Create a random cloud of stardust containing the correct number of dust
23388               * particles, i.e. NOSTM of them, which is 3 in witchspace and 18 (#NOST) in
23389               * normal space. Also clears the scanner and initialises the LSO block.
23390               *
23391               * This is called by the DEATH routine when it displays our untimely demise.
23392               *
23393               * ******************************************************************************
23394               
23395               nWq:
23396 ABEC D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     ABEE 0F33     
23397                                                                          ; we can use it as a counter through all the stardust
23398               
23399               SAL4:
23400 ABF0 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     ABF2 C07C     
23401 ABF4 06A0  32        bl   @jsr                       ;
     ABF6 FE1E     
23402               
23403 ABF8 026D  22        ori  ra,>08*256                 ; ORA #8            ; Set A so that it's at least 8
     ABFA 0800     
23404               
23405 ABFC DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; Store A in the Y-th particle's z_hi coordinate at
     ABFE 0EE8     
23406                                                                          ; SZ+Y, so the particle appears in front of us
23407               
23408 AC00 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the particle's z_hi coordinate
     AC02 0097     
23409               
23410 AC04 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     AC06 C07C     
23411 AC08 06A0  32        bl   @jsr                       ;
     AC0A FE1E     
23412               
23413 AC0C DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; Store A in the Y-th particle's x_hi coordinate at
     AC0E 034C     
23414                                                                          ; SX+Y, so the particle appears in front of us
23415               
23416 AC10 D80D  30        movb ra,@X1                     ; STA X1            ; Set X1 to the particle's x_hi coordinate
     AC12 0031     
23417               
23418 AC14 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     AC16 C07C     
23419 AC18 06A0  32        bl   @jsr                       ;
     AC1A FE1E     
23420               
23421 AC1C DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; Store A in the Y-th particle's y_hi coordinate at
     AC1E 0EC2     
23422                                                                          ; SY+Y, so the particle appears in front of us
23423               
23424 AC20 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 to the particle's y_hi coordinate
     AC22 0032     
23425               
23426 AC24 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     AC26 276C     
23427 AC28 06A0  32        bl   @jsr                       ;
     AC2A FE1E     
23428               
23429 AC2C 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
23430                                                                          ; stardust
23431               
23432 AC2E 16E0  14        jne  SAL4                       ; BNE SAL4          ; Loop back to SAL4 until we have randomised all the
23433                                                                          ; stardust particles
23434               
23435                                                                          ; Fall through into WPSHPS to clear the scanner and
23436                                                                          ; reset the LSO block
23437               
23438               * ******************************************************************************
23439               *
23440               * Name: WPSHPS
23441               * Type: Subroutine
23442               * Category: Dashboard
23443               * Summary: Clear the scanner, reset the ball line and sun line heaps
23444               *
23445               * ------------------------------------------------------------------------------
23446               *
23447               * Remove all ships from the scanner, reset the sun line heap at LSO, and reset
23448               * the ball line heap at LSX2 and LSY2.
23449               *
23450               * ******************************************************************************
23451               
23452               WPSHPS:
23453 AC30 020E  20        li   rx,>00*256                 ; LDX #0            ; Set up a counter in X to work our way through all the
     AC32 0000     
23454                                                                          ; ship slots in FRIN
23455               
23456               WSL1:
23457 AC34 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type in slot X
     AC36 0D40     
23458               
23459 AC38 1330  14        jeq  WS2                        ; BEQ WS2           ; If the slot contains 0 then it is empty and we have
23460                                                                          ; checked all the slots (as they are always shuffled
23461                                                                          ; down in the main loop to close up and gaps), so jump
23462                                                                          ; to WS2 as we are done
23463               
23464 AC3A 112D  14        jlt  WS1                        ; BMI WS1           ; If the slot contains a ship type with bit 7 set, then
23465                                                                          ; it contains the planet or the sun, so jump down to WS1
23466                                                                          ; to skip this slot, as the planet and sun don't appear
23467                                                                          ; on the scanner
23468               
23469 AC3C D80D  30        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     AC3E 009B     
23470               
23471 AC40 0200  20        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to get the address of the data block for
     AC42 AF0C     
23472 AC44 06A0  32        bl   @jsr                       ;
     AC46 FE1E     
23473                                                                          ; ship slot X and store it in INF
23474               
23475 AC48 020F  20        li   ry,>1f*256                 ; LDY #31           ; We now want to copy the first 32 bytes from the ship's
     AC4A 1F00     
23476                                                                          ; data block into INWK, so set a counter in Y
23477               
23478               WSL2:
23479                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte from the data block pointed to by
     **** ****     > LD_IND_Y_IDX
0001 AC4C D820  50        movb @INF,@rtmplb
     AC4E 0020     
     AC50 206D     
0002 AC52 D020  30        movb @INF+1,rtmp
     AC54 0021     
0003 AC56 A00F  18        a    ry,rtmp
0004 AC58 D350  26        movb *rtmp,RA
                   < elite.a99
23480 AC5A DBCD  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; INF into the Y-th byte of INWK workspace
     AC5C 0053     
23481               
23482 AC5E 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point at the next byte
23483               
23484 AC60 15F5  14        jgt  WSL2                       ; BPL WSL2          ; Loop back to WSL2 until we have copied all 32 bytes
23485               
23486 AC62 D80E  30        movb rx,@XSAV                   ; STX XSAV          ; Store the ship slot number in XSAV while we call SCAN
     AC64 0093     
23487               
23488 AC66 0200  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to plot this ship on the scanner, which will
     AC68 4C86     
23489 AC6A 06A0  32        bl   @jsr                       ;
     AC6C FE1E     
23490                                                                          ; remove it as it's plotted with EOR logic
23491               
23492 AC6E D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the ship slot number from XSAV into X
     AC70 0093     
23493               
23494 AC72 020F  20        li   ry,>1f*256                 ; LDY #31           ; Clear bits 3, 4 and 6 in the ship's byte #31, which
     AC74 1F00     
23495                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; stops drawing the ship on-screen (bit 3), hides it
     **** ****     > LD_IND_Y_IDX
0001 AC76 D820  50        movb @INF,@rtmplb
     AC78 0020     
     AC7A 206D     
0002 AC7C D020  30        movb @INF+1,rtmp
     AC7E 0021     
0003 AC80 A00F  18        a    ry,rtmp
0004 AC82 D350  26        movb *rtmp,RA
                   < elite.a99
23496 AC84 024D  22        andi ra,>a7*256                 ; AND #%10100111    ; from the scanner (bit 4) and stops any lasers firing
     AC86 A700     
23497                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; (bit 6)
     **** ****     > ST_IND_Y_IDX
0001 AC88 D820  50        movb @INF,@rtmplb
     AC8A 0020     
     AC8C 206D     
0002 AC8E D020  30        movb @INF+1,rtmp
     AC90 0021     
0003 AC92 A00F  18        a    ry,rtmp
0004 AC94 D40D  30        movb RA,*rtmp
                   < elite.a99
23498               
23499               WS1:
23500 AC96 B387  18        ab   rone,rx                    ; INX               ; Increment X to point to the next ship slot
23501               
23502 AC98 16CD  14        jne  WSL1                       ; BNE WSL1          ; Loop back up to process the next slot (this BNE is
23503                                                                          ; effectively a JMP as X will never be zero)
23504               
23505               WS2:
23506 AC9A 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set LSX2 = LSY2 = &FF to clear the ball line heap
     AC9C FF00     
23507 AC9E D80E  30        movb rx,@LSX2                   ; STX LSX2
     ACA0 0E26     
23508 ACA2 D80E  30        movb rx,@LSY2                   ; STX LSY2
     ACA4 0E74     
23509               
23510                                                                          ; Fall through into FLFLLS to reset the LSO block
23511               
23512               * ******************************************************************************
23513               *
23514               * Name: FLFLLS
23515               * Type: Subroutine
23516               * Category: Drawing suns
23517               * Summary: Reset the sun line heap
23518               *
23519               * ------------------------------------------------------------------------------
23520               *
23521               * Reset the sun line heap at LSO by zero-filling it and setting the first byte
23522               * to &FF.
23523               *
23524               * ------------------------------------------------------------------------------
23525               *
23526               * Returns:
23527               *
23528               * A                   A is set to 0
23529               *
23530               * ******************************************************************************
23531               
23532               FLFLLS:
23533 ACA6 020F  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     ACA8 BF00     
23534                                                                          ; view, so this sets Y as a counter for the number of
23535                                                                          ; lines in the space view (i.e. 191), which is also the
23536                                                                          ; number of lines in the LSO block
23537               
23538 ACAA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the LSO block
     ACAC 0000     
23539               
23540               SAL6:
23541 ACAE DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Set the Y-th byte of the LSO block to 0
     ACB0 0D66     
23542               
23543 ACB2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
23544               
23545 ACB4 16FC  14        jne  SAL6                       ; BNE SAL6          ; Loop back until we have filled all the way to LSO+1
23546               
23547 ACB6 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to value of &FF (as we exit the above loop
23548                                                                          ; with Y = 0)
23549               
23550 ACB8 D80F  30        movb ry,@LSX                    ; STY LSX           ; Set the first byte of the LSO block, which has its own
     ACBA 0D66     
23551                                                                          ; label LSX, to &FF, to indicate that the sun line heap
23552                                                                          ; is empty
23553               
23554 ACBC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ACBE FE2A     
23555               
23556               * ******************************************************************************
23557               *
23558               * Name: DET1
23559               * Type: Subroutine
23560               * Category: Drawing the screen
23561               * Summary: Show or hide the dashboard (for when we die)
23562               *
23563               * ------------------------------------------------------------------------------
23564               *
23565               * This routine sets the screen to show the number of text rows given in X.
23566               *
23567               * It is used when we are killed, as reducing the number of rows from the usual
23568               * 31 to 24 has the effect of hiding the dashboard, leaving a monochrome image
23569               * of ship debris and explosion clouds. Increasing the rows back up to 31 makes
23570               * the dashboard reappear, as the dashboard's screen memory doesn't get touched
23571               * by this process.
23572               *
23573               * ------------------------------------------------------------------------------
23574               *
23575               * Arguments:
23576               *
23577               * X                   The number of text rows to display on the screen (24
23578               * will hide the dashboard, 31 will make it reappear)
23579               *
23580               * ------------------------------------------------------------------------------
23581               *
23582               * Returns:
23583               *
23584               * A                   A is set to 6
23585               *
23586               * ******************************************************************************
23587               
23588               DET1:
23589 ACC0 020D  20        li   ra,>06*256                 ; LDA #6            ; Set A to 6 so we can update 6845 register R6 below
     ACC2 0600     
23590               
23591 ACC4 0300  22        limi 0                          ; SEI               ; Disable interrupts so we can update the 6845
     ACC6 0000     
23592               
23593 ACC8 D80D  38        movb ra,@VIA+>00                ; STA VIA+&00       ; Set 6845 register R6 to the value in X. Register R6
     ACCA FE00     
23594 ACCC D80E  38        movb rx,@VIA+>01                ; STX VIA+&01       ; is the "vertical displayed" register, which sets the
     ACCE FE01     
23595                                                                          ; number of rows shown on the screen
23596               
23597 ACD0 0300  22        limi 2                          ; CLI               ; Re-enable interrupts
     ACD2 0002     
23598               
23599 ACD4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ACD6 FE2A     
23600               
23601               * ******************************************************************************
23602               *
23603               * Name: SHD
23604               * Type: Subroutine
23605               * Category: Flight
23606               * Summary: Charge a shield and drain some energy from the energy banks
23607               *
23608               * ------------------------------------------------------------------------------
23609               *
23610               * Charge up a shield, and if it needs charging, drain some energy from the
23611               * energy banks.
23612               *
23613               * ------------------------------------------------------------------------------
23614               *
23615               * Arguments:
23616               *
23617               * X                   The value of the shield to recharge
23618               *
23619               * ******************************************************************************
23620               
23621 ACD8 7387  18        sb   rone,rx                    ; DEX               ; Increment the shield value so that it doesn't go past
23622                                                                          ; a maximum of 255
23623               
23624 ACDA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ACDC FE2A     
23625               
23626               SHD:
23627 ACDE B387  18        ab   rone,rx                    ; INX               ; Increment the shield value
23628               
23629 ACE0 13FD  14        jeq  SHD-2                      ; BEQ SHD-2         ; If the shield value is 0 then this means it was 255
23630                                                                          ; before, which is the maximum value, so jump to SHD-2
23631                                                                          ; to bring it back down to 258 and return
23632               
23633                                                                          ; Otherwise fall through into DENGY to drain our energy
23634                                                                          ; to pay for all this shield charging
23635               
23636               * ******************************************************************************
23637               *
23638               * Name: DENGY
23639               * Type: Subroutine
23640               * Category: Flight
23641               * Summary: Drain some energy from the energy banks
23642               *
23643               * ------------------------------------------------------------------------------
23644               *
23645               * Returns:
23646               *
23647               * Z flag              Set if we have no energy left, clear otherwise
23648               *
23649               * ******************************************************************************
23650               
23651               DENGY:
23652 ACE2 7347  18        sb   rone,ra                    ; DEC ENERGY        ; Decrement the energy banks in ENERGY
23653               
23654                      .php                            ; PHP               ; Save the flags on the stack
     **** ****     > PHP
0001 ACE4 02C0  12        stst rtmp
0002 ACE6 D680  30        movb rtmp,*rsp
0003 ACE8 060A  14        dec  rsp
                   < elite.a99
23655               
23656 ACEA 1601  14        jne  B70                        ; BNE B70           ; If the energy levels are not yet zero, skip the
23657                                                                          ; following instruction
23658               
23659 ACEC B347  18        ab   rone,ra                    ; INC ENERGY        ; The minimum allowed energy level is 1, and we just
23660                                                                          ; reached 0, so increment ENERGY back to 1
23661               
23662               B70:
23663                      .plp                            ; PLP               ; Restore the flags from the stack, so we return with
     **** ****     > PLP
0001 ACEE 058A  14        INC  rsp
0002 ACF0 D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
23664                                                                          ; the Z flag from the DEC instruction above
23665               
23666 ACF2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ACF4 FE2A     
23667               
23668               * ******************************************************************************
23669               *
23670               * Name: COMPAS
23671               * Type: Subroutine
23672               * Category: Dashboard
23673               * Summary: Update the compass
23674               *
23675               * ******************************************************************************
23676               
23677               COMPAS:
23678 ACF6 0200  20        li   rtmp,DOT                   ; JSR DOT           ; Call DOT to redraw (i.e. remove) the current compass
     ACF8 ADC0     
23679 ACFA 06A0  32        bl   @jsr                       ;
     ACFC FE1E     
23680                                                                          ; dot
23681               
23682 ACFE D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     AD00 0D55     
23683 AD02 1634  14        jne  SP1                        ; BNE SP1           ; SP1 to draw the space station on the compass
23684               
23685 AD04 0200  20        li   rtmp,SPS1                  ; JSR SPS1          ; Otherwise we need to draw the planet on the compass,
     AD06 C97A     
23686 AD08 06A0  32        bl   @jsr                       ;
     AD0A FE1E     
23687                                                                          ; so first call SPS1 to calculate the vector to the
23688                                                                          ; planet and store it in XX15
23689               
23690 AD0C 0460  28        b    @SP2                       ; JMP SP2           ; Jump to SP2 to draw XX15 on the compass, returning
     AD0E AD74     
23691                                                                          ; from the subroutine using a tail call
23692               
23693               * ******************************************************************************
23694               *
23695               * Name: SPS2
23696               * Type: Subroutine
23697               * Category: Maths (Arithmetic)
23698               * Summary: Calculate (Y X) = A / 10
23699               *
23700               * ------------------------------------------------------------------------------
23701               *
23702               * Calculate the following, where A is a sign-magnitude 8-bit integer and the
23703               * result is a signed 16-bit integer:
23704               *
23705               * (Y X) = A / 10
23706               *
23707               * ------------------------------------------------------------------------------
23708               *
23709               * Returns:
23710               *
23711               * C flag              The C flag is cleared
23712               *
23713               * ******************************************************************************
23714               
23715               SPS2:
23716                      .asla                           ; ASL A             ; Set X = |A| * 2, and set the C flag to the sign bit of
     **** ****     > ASLA
0001 AD10 024D  22        andi ra,>ff00
     AD12 FF00     
0002 AD14 0A1D  18        sla  ra,1
                   < elite.a99
23717 AD16 D38D  18        movb ra,rx                      ; TAX               ; A
23718               
23719 AD18 020D  20        li   ra,>00*256                 ; LDA #0            ; Set Y to have the sign bit from A in bit 7, with the
     AD1A 0000     
23720 AD1C 06A0  32        bl   @rora                      ; ROR A             ; rest of its bits zeroed, so Y now contains the sign of
     AD1E FE58     
23721 AD20 D3CD  18        movb ra,ry                      ; TAY               ; the original argument
23722               
23723 AD22 020D  20        li   ra,>14*256                 ; LDA #20           ; Set Q = 20
     AD24 1400     
23724 AD26 D80D  30        movb ra,@Q                      ; STA Q
     AD28 0090     
23725               
23726 AD2A D34E  18        movb rx,ra                      ; TXA               ; Copy X into A, so A now contains the argument A * 2
23727               
23728 AD2C 0200  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     AD2E 45B0     
23729 AD30 06A0  32        bl   @jsr                       ;
     AD32 FE1E     
23730                                                                          ;
23731                                                                          ; P = A / Q
23732                                                                          ; = |argument A| * 2 / 20
23733                                                                          ; = |argument A| / 10
23734               
23735 AD34 D3A0  30        movb @P,rx                      ; LDX P             ; Set X to the result
     AD36 001B     
23736               
23737 AD38 D34F  18        movb ry,ra                      ; TYA               ; If the sign of the original argument A is negative,
23738 AD3A 1104  14        jlt  LL163                      ; BMI LL163         ; jump to LL163 to flip the sign of the result
23739               
23740 AD3C 020F  20        li   ry,>00*256                 ; LDY #0            ; Set the high byte of the result to 0, as the result is
     AD3E 0000     
23741                                                                          ; positive
23742               
23743 AD40 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AD42 FE2A     
23744               
23745               LL163:
23746 AD44 020F  20        li   ry,>ff*256                 ; LDY #&FF          ; The result is negative, so set the high byte to &FF
     AD46 FF00     
23747               
23748 AD48 D34E  18        movb rx,ra                      ; TXA               ; Flip the low byte and add 1 to get the negated low
23749                      .eoi (>ff*256)                  ; EOR #&FF          ; byte, using two's complement
     **** ****     > EOI
0001 AD4A 0200  20        li   rtmp,(>FF*256)
     AD4C FF00     
0002 AD4E 2B40  18        xor  rtmp,ra
                   < elite.a99
23750 AD50 D38D  18        movb ra,rx                      ; TAX
23751 AD52 B387  18        ab   rone,rx                    ; INX
23752               
23753 AD54 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AD56 FE2A     
23754               
23755               * ******************************************************************************
23756               *
23757               * Name: SPS4
23758               * Type: Subroutine
23759               * Category: Maths (Geometry)
23760               * Summary: Calculate the vector to the space station
23761               *
23762               * ------------------------------------------------------------------------------
23763               *
23764               * Calculate the vector between our ship and the space station and store it in
23765               * XX15.
23766               *
23767               * ******************************************************************************
23768               
23769               SPS4:
23770 AD58 020E  20        li   rx,>08*256                 ; LDX #8            ; First we need to copy the space station's coordinates
     AD5A 0800     
23771                                                                          ; into K3, so set a counter to copy the first 9 bytes
23772                                                                          ; (the 3-byte x, y and z coordinates) from the station's
23773                                                                          ; data block at K% + NI% into K3
23774               
23775               SPL1:
23776 AD5C D36E  34        movb @K.+NI.(rx),ra             ; LDA K%+NI%,X      ; Copy the X-th byte from the station's data block at
     AD5E 0924     
23777 AD60 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X          ; K% + NI% to the X-th byte of K3
     AD62 00D2     
23778               
23779 AD64 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
23780               
23781 AD66 15FA  14        jgt  SPL1                       ; BPL SPL1          ; Loop back to SPL1 until we have copied all 9 bytes
23782               
23783 AD68 0460  28        b    @TAS2                      ; JMP TAS2          ; Call TAS2 to build XX15 from K3, returning from the
     AD6A C99E     
23784                                                                          ; subroutine using a tail call
23785               
23786               * ******************************************************************************
23787               *
23788               * Name: SP1
23789               * Type: Subroutine
23790               * Category: Dashboard
23791               * Summary: Draw the space station on the compass
23792               *
23793               * ******************************************************************************
23794               
23795               SP1:
23796 AD6C 0200  20        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to calculate the vector to the space station
     AD6E AD58     
23797 AD70 06A0  32        bl   @jsr                       ;
     AD72 FE1E     
23798                                                                          ; and store it in XX15
23799               
23800                                                                          ; Fall through into SP2 to draw XX15 on the compass
23801               
23802               * ******************************************************************************
23803               *
23804               * Name: SP2
23805               * Type: Subroutine
23806               * Category: Dashboard
23807               * Summary: Draw a dot on the compass, given the planet/station vector
23808               *
23809               * ------------------------------------------------------------------------------
23810               *
23811               * Draw a dot on the compass to represent the planet or station, whose normalised
23812               * vector is in XX15.
23813               *
23814               * XX15 to XX15+2      The normalised vector to the planet or space station,
23815               * stored as x in XX15, y in XX15+1 and z in XX15+2
23816               *
23817               * ******************************************************************************
23818               
23819               SP2:
23820 AD74 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A to the x-coordinate of the planet or station to
     AD76 0031     
23821                                                                          ; show on the compass, which will be in the range -96 to
23822                                                                          ; +96 as the vector has been normalised
23823               
23824 AD78 0200  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     AD7A AD10     
23825 AD7C 06A0  32        bl   @jsr                       ;
     AD7E FE1E     
23826                                                                          ; is the x-offset from the centre of the compass of the
23827                                                                          ; dot we want to draw. Returns with the C flag clear
23828               
23829 AD80 D34E  18        movb rx,ra                      ; TXA               ; Set COMX = 195 + X, as 186 is the pixel x-coordinate
23830                      .adi (>c3*256)                  ; ADC #195          ; of the leftmost dot possible on the compass, and X can
     **** ****     > ADI
0001 AD82 1701  14        jnc  !
0002 AD84 B347  18        ab   rone,ra
0003               !:
0004 AD86 022D  22        ai   ra,(>C3*256)
     AD88 C300     
                   < elite.a99
23831 AD8A D80D  30        movb ra,@COMX                   ; STA COMX          ; be -9, which would be 195 - 9 = 186. This also means
     AD8C 0F16     
23832                                                                          ; that the highest value for COMX is 195 + 9 = 204,
23833                                                                          ; which is the pixel x-coordinate of the rightmost dot
23834                                                                          ; in the compass... but the compass dot is actually two
23835                                                                          ; pixels wide, so the compass dot can overlap the right
23836                                                                          ; edge of the compass, but not the left edge
23837               
23838 AD8E D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A to the y-coordinate of the planet or station to
     AD90 0032     
23839                                                                          ; show on the compass, which will be in the range -96 to
23840                                                                          ; +96 as the vector has been normalised
23841               
23842 AD92 0200  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     AD94 AD10     
23843 AD96 06A0  32        bl   @jsr                       ;
     AD98 FE1E     
23844                                                                          ; is the x-offset from the centre of the compass of the
23845                                                                          ; dot we want to draw. Returns with the C flag clear
23846               
23847 AD9A D80E  30        movb rx,@T                      ; STX T             ; Set COMY = 204 - X, as 203 is the pixel y-coordinate
     AD9C 00D1     
23848 AD9E 020D  20        li   ra,>cc*256                 ; LDA #204          ; of the centre of the compass, the C flag is clear,
     ADA0 CC00     
23849                      .sbc @T,ra                      ; SBC T             ; and the y-axis needs to be flipped around (because
     **** ****     > SBC
0001 ADA2 1801  14        joc  !
0002 ADA4 7347  18        sb   rone,ra
0003               !:
0004 ADA6 7360  30        sb   @T,ra
     ADA8 00D1     
                   < elite.a99
23850 ADAA D80D  30        movb ra,@COMY                   ; STA COMY          ; when the planet or station is above us, and the
     ADAC 0F17     
23851                                                                          ; vector is therefore positive, we want to show the dot
23852                                                                          ; higher up on the compass, which has a smaller pixel
23853                                                                          ; y-coordinate). So this calculation does this:
23854                                                                          ;
23855                                                                          ; COMY = 204 - X - (1 - 0) = 203 - X
23856               
23857 ADAE 020D  20        li   ra,>f0*256                 ; LDA #&F0          ; Set A to a 4-pixel mode 5 byte row in colour 2
     ADB0 F000     
23858                                                                          ; (yellow/white), the colour for when the planet or
23859                                                                          ; station in the compass is in front of us
23860               
23861 ADB2 D3A0  30        movb @XX15+2,rx                 ; LDX XX15+2        ; If the z-coordinate of the XX15 vector is positive,
     ADB4 0033     
23862 ADB6 1502  14        jgt  B71                        ; BPL B71           ; skip the following instruction
23863               
23864 ADB8 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; The z-coordinate of XX15 is negative, so the planet or
     ADBA FF00     
23865                                                                          ; station is behind us and the compass dot should be in
23866                                                                          ; green/cyan, so set A to a 4-pixel mode 5 byte row in
23867                                                                          ; colour 3
23868               
23869               B71:
23870 ADBC D80D  30        movb ra,@COMC                   ; STA COMC          ; Store the compass colour in COMC
     ADBE 0F48     
23871               
23872                                                                          ; Fall through into DOT to draw the dot on the compass
23873               
23874               * ******************************************************************************
23875               *
23876               * Name: DOT
23877               * Type: Subroutine
23878               * Category: Dashboard
23879               * Summary: Draw a dash on the compass
23880               *
23881               * ------------------------------------------------------------------------------
23882               *
23883               * Arguments:
23884               *
23885               * COMX                The screen pixel x-coordinate of the dash
23886               *
23887               * COMY                The screen pixel y-coordinate of the dash
23888               *
23889               * COMC                The colour and thickness of the dash:
23890               *
23891               * * &F0 = a double-height dash in yellow/white, for when
23892               * the object in the compass is in front of us
23893               *
23894               * * &FF = a single-height dash in green/cyan, for when
23895               * the object in the compass is behind us
23896               *
23897               * ******************************************************************************
23898               
23899               DOT:
23900 ADC0 D360  30        movb @COMY,ra                   ; LDA COMY          ; Set Y1 = COMY, the y-coordinate of the dash
     ADC2 0F17     
23901 ADC4 D80D  30        movb ra,@Y1                     ; STA Y1
     ADC6 0032     
23902               
23903 ADC8 D360  30        movb @COMX,ra                   ; LDA COMX          ; Set X1 = COMX, the x-coordinate of the dash
     ADCA 0F16     
23904 ADCC D80D  30        movb ra,@X1                     ; STA X1
     ADCE 0031     
23905               
23906 ADD0 D360  30        movb @COMC,ra                   ; LDA COMC          ; Set COL = COMC, the mode 5 colour byte for the dash
     ADD2 0F48     
23907 ADD4 D80D  30        movb ra,@COL                    ; STA COL
     ADD6 00A2     
23908               
23909 ADD8 028D  22        ci   ra,>f0*256                 ; CMP #&F0          ; If COL is &F0 then the planet/station is in front of
     ADDA F000     
23910 ADDC 1605  14        jne  CPIX2                      ; BNE CPIX2         ; us and we want to draw a double-height dash, so if it
23911                                                                          ; isn't &F0 jump to CPIX2 to draw a single-height dash
23912               
23913                                                                          ; Otherwise fall through into CPIX4 to draw a double-
23914                                                                          ; height dash
23915               
23916               * ******************************************************************************
23917               *
23918               * Name: CPIX4
23919               * Type: Subroutine
23920               * Category: Drawing pixels
23921               * Summary: Draw a double-height dot on the dashboard
23922               *
23923               * ------------------------------------------------------------------------------
23924               *
23925               * Draw a double-height mode 5 dot (2 pixels high, 2 pixels wide).
23926               *
23927               * ------------------------------------------------------------------------------
23928               *
23929               * Arguments:
23930               *
23931               * X1                  The screen pixel x-coordinate of the bottom-left corner
23932               * of the dot
23933               *
23934               * Y1                  The screen pixel y-coordinate of the bottom-left corner
23935               * of the dot
23936               *
23937               * COL                 The colour of the dot as a mode 5 character row byte
23938               *
23939               * ******************************************************************************
23940               
23941               CPIX4:
23942 ADDE 0200  20        li   rtmp,CPIX2                 ; JSR CPIX2         ; Call CPIX2 to draw a single-height dash at (X1, Y1)
     ADE0 ADE8     
23943 ADE2 06A0  32        bl   @jsr                       ;
     ADE4 FE1E     
23944               
23945 ADE6 7347  18        sb   rone,ra                    ; DEC Y1            ; Decrement Y1
23946               
23947                                                                          ; Fall through into CPIX2 to draw a second single-height
23948                                                                          ; dash on the pixel row above the first one, to create a
23949                                                                          ; double-height dot
23950               
23951               * ******************************************************************************
23952               *
23953               * Name: CPIX2
23954               * Type: Subroutine
23955               * Category: Drawing pixels
23956               * Summary: Draw a single-height dash on the dashboard
23957               * Deep dive: Drawing colour pixels in mode 5
23958               *
23959               * ------------------------------------------------------------------------------
23960               *
23961               * Draw a single-height mode 5 dash (1 pixel high, 2 pixels wide).
23962               *
23963               * ------------------------------------------------------------------------------
23964               *
23965               * Arguments:
23966               *
23967               * X1                  The screen pixel x-coordinate of the dash
23968               *
23969               * Y1                  The screen pixel y-coordinate of the dash
23970               *
23971               * COL                 The colour of the dash as a mode 5 character row byte
23972               *
23973               * ******************************************************************************
23974               
23975               CPIX2:
23976 ADE8 D360  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate into A
     ADEA 0032     
23977               
23978               * .CPIX                  \ This label is commented out in the original source. It
23979                                                                          ; would provide a new entry point with A specifying the
23980                                                                          ; y-coordinate instead of Y1, but it isn't used anywhere
23981               
23982 ADEC D3CD  18        movb ra,ry                      ; TAY               ; Store the y-coordinate in Y
23983               
23984 ADEE 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 8, so A now contains the character row we
23985 ADF0 091D  18        srl  ra,1                       ; LSR A             ; need to draw in (as each character row contains 8
23986 ADF2 091D  18        srl  ra,1                       ; LSR A             ; pixel rows)
23987               
23988 ADF4 026D  22        ori  ra,>60*256                 ; ORA #&60          ; Each character row in Elite's screen mode takes up one
     ADF6 6000     
23989                                                                          ; page in memory (256 bytes), so we now OR with &60 to
23990                                                                          ; get the page containing the dash (see the comments in
23991                                                                          ; routine TT26 for more discussion about calculating
23992                                                                          ; screen memory addresses)
23993               
23994 ADF8 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the screen page in the high byte of SC(1 0)
     ADFA 0008     
23995               
23996 ADFC D360  30        movb @X1,ra                     ; LDA X1            ; Each character block contains 8 pixel rows, so to get
     ADFE 0031     
23997 AE00 024D  22        andi ra,>f8*256                 ; AND #%11111000    ; the address of the first byte in the character block
     AE02 F800     
23998                                                                          ; that we need to draw into, as an offset from the start
23999                                                                          ; of the row, we clear bits 0-2
24000               
24001 AE04 D80D  30        movb ra,@SC                     ; STA SC            ; Store the address of the character block in the low
     AE06 0007     
24002                                                                          ; byte of SC(1 0), so now SC(1 0) points to the
24003                                                                          ; character block we need to draw into
24004               
24005 AE08 D34F  18        movb ry,ra                      ; TYA               ; Set Y to just bits 0-2 of the y-coordinate, which will
24006 AE0A 024D  22        andi ra,>07*256                 ; AND #%00000111    ; be the number of the pixel row we need to draw into
     AE0C 0700     
24007 AE0E D3CD  18        movb ra,ry                      ; TAY               ; within the character block
24008               
24009 AE10 D360  30        movb @X1,ra                     ; LDA X1            ; Copy bits 0-1 of X1 to bits 1-2 of X, and clear the C
     AE12 0031     
24010 AE14 024D  22        andi ra,>06*256                 ; AND #%00000110    ; flag in the process (using the LSR). X will now be
     AE16 0600     
24011 AE18 091D  18        srl  ra,1                       ; LSR A             ; a value between 0 and 3, and will be the pixel number
24012 AE1A D38D  18        movb ra,rx                      ; TAX               ; in the character row for the left pixel in the dash.
24013                                                                          ; This is because each character row is one byte that
24014                                                                          ; contains 4 pixels, but covers 8 screen coordinates, so
24015                                                                          ; this effectively does the division by 2 that we need
24016               
24017 AE1C D36E  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; Fetch a mode 5 1-pixel byte with the pixel position
     AE1E 2249     
24018                      .and @COL                       ; AND COL           ; at X, and AND with the colour byte so that pixel takes
     **** ****     > AND
0001 AE20 D020  30        movb @COL,rtmp
     AE22 00A2     
0002 AE24 0540  14        inv  rtmp
0003 AE26 5340  18        szcb rtmp,ra
                   < elite.a99
24019                                                                          ; on the colour we want to draw (i.e. A is acting as a
24020                                                                          ; mask on the colour byte)
24021               
24022                      .eor @SC                        ; EOR (SC),Y        ; Draw the pixel on-screen using EOR logic, so we can
     **** ****     > EOR
0001 AE28 D020  30        movb @SC,rtmp
     AE2A 0007     
0002 AE2C 2B40  18        xor  rtmp,ra
                   < elite.a99
24023                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; remove it later without ruining the background that's
     **** ****     > ST_IND_Y_IDX
0001 AE2E D820  50        movb @SC,@rtmplb
     AE30 0007     
     AE32 206D     
0002 AE34 D020  30        movb @SC+1,rtmp
     AE36 0008     
0003 AE38 A00F  18        a    ry,rtmp
0004 AE3A D40D  30        movb RA,*rtmp
                   < elite.a99
24024                                                                          ; already on-screen
24025               
24026 AE3C D36E  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Fetch a mode 5 1-pixel byte with the pixel position
     AE3E 224A     
24027                                                                          ; at X+1, so we can draw the right pixel of the dash
24028               
24029 AE40 150A  14        jgt  CP1                        ; BPL CP1           ; The CTWOS table has an extra row at the end of it that
24030                                                                          ; repeats the first value, %10001000, so if we have not
24031                                                                          ; fetched that value, then the right pixel of the dash
24032                                                                          ; is in the same character block as the left pixel, so
24033                                                                          ; jump to CP1 to draw it
24034               
24035 AE42 D360  30        movb @SC,ra                     ; LDA SC            ; Otherwise the left pixel we drew was at the last
     AE44 0007     
24036                      .adi (>08*256)                  ; ADC #8            ; position of four in this character block, so we add
     **** ****     > ADI
0001 AE46 1701  14        jnc  !
0002 AE48 B347  18        ab   rone,ra
0003               !:
0004 AE4A 022D  22        ai   ra,(>08*256)
     AE4C 0800     
                   < elite.a99
24037 AE4E D80D  30        movb ra,@SC                     ; STA SC            ; 8 to the screen address to move onto the next block
     AE50 0007     
24038                                                                          ; along (as there are 8 bytes in a character block).
24039                                                                          ; The C flag was cleared above, so this ADC is correct
24040               
24041 AE52 D36E  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Re-fetch the mode 5 1-pixel byte, as we just overwrote
     AE54 224A     
24042                                                                          ; A (the byte will still be the fifth byte from the
24043                                                                          ; table, which is correct as we want to draw the
24044                                                                          ; leftmost pixel in the next character along as the
24045                                                                          ; dash's right pixel)
24046               
24047               CP1:
24048                      .and @COL                       ; AND COL           ; Apply the colour mask to the pixel byte, as above
     **** ****     > AND
0001 AE56 D020  30        movb @COL,rtmp
     AE58 00A2     
0002 AE5A 0540  14        inv  rtmp
0003 AE5C 5340  18        szcb rtmp,ra
                   < elite.a99
24049               
24050                      .eor @SC                        ; EOR (SC),Y        ; Draw the dash's right pixel according to the mask in
     **** ****     > EOR
0001 AE5E D020  30        movb @SC,rtmp
     AE60 0007     
0002 AE62 2B40  18        xor  rtmp,ra
                   < elite.a99
24051                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; A, with the colour in COL, using EOR logic, just as
     **** ****     > ST_IND_Y_IDX
0001 AE64 D820  50        movb @SC,@rtmplb
     AE66 0007     
     AE68 206D     
0002 AE6A D020  30        movb @SC+1,rtmp
     AE6C 0008     
0003 AE6E A00F  18        a    ry,rtmp
0004 AE70 D40D  30        movb RA,*rtmp
                   < elite.a99
24052                                                                          ; above
24053               
24054 AE72 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AE74 FE2A     
24055               
24056               * ******************************************************************************
24057               *
24058               * Name: OOPS
24059               * Type: Subroutine
24060               * Category: Flight
24061               * Summary: Take some damage
24062               *
24063               * ------------------------------------------------------------------------------
24064               *
24065               * We just took some damage, so reduce the shields if we have any, or reduce the
24066               * energy levels and potentially take some damage to the cargo if we don't.
24067               *
24068               * ------------------------------------------------------------------------------
24069               *
24070               * Arguments:
24071               *
24072               * A                   The amount of damage to take
24073               *
24074               * INF                 The address of the ship block for the ship that attacked
24075               * us, or the ship that we just ran into
24076               *
24077               * ******************************************************************************
24078               
24079               OOPS:
24080 AE76 D80D  30        movb ra,@T                      ; STA T             ; Store the amount of damage in T
     AE78 00D1     
24081               
24082 AE7A 020F  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 (z_sign) for the ship attacking us, and
     AE7C 0800     
24083 AE7E 020E  20        li   rx,>00*256                 ; LDX #0            ; set X = 0
     AE80 0000     
24084                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 AE82 D820  50        movb @INF,@rtmplb
     AE84 0020     
     AE86 206D     
0002 AE88 D020  30        movb @INF+1,rtmp
     AE8A 0021     
0003 AE8C A00F  18        a    ry,rtmp
0004 AE8E D350  26        movb *rtmp,RA
                   < elite.a99
24085               
24086 AE90 110E  14        jlt  OO1                        ; BMI OO1           ; If A is negative, then we got hit in the rear, so jump
24087                                                                          ; to OO1 to process damage to the aft shield
24088               
24089 AE92 D360  30        movb @FSH,ra                    ; LDA FSH           ; Otherwise the forward shield was damaged, so fetch the
     AE94 0F11     
24090                      .sbc @T,ra                      ; SBC T             ; shield strength from FSH and subtract the damage in T
     **** ****     > SBC
0001 AE96 1801  14        joc  !
0002 AE98 7347  18        sb   rone,ra
0003               !:
0004 AE9A 7360  30        sb   @T,ra
     AE9C 00D1     
                   < elite.a99
24091               
24092 AE9E 1704  14        jnc  OO2                        ; BCC OO2           ; If the C flag is clear then this amount of damage was
24093                                                                          ; too much for the shields, so jump to OO2 to set the
24094                                                                          ; shield level to 0 and start taking damage directly
24095                                                                          ; from the energy banks
24096               
24097 AEA0 D80D  30        movb ra,@FSH                    ; STA FSH           ; Store the new value of the forward shield in FSH
     AEA2 0F11     
24098               
24099 AEA4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AEA6 FE2A     
24100               
24101               OO2:
24102               * LDX #0                 \ This instruction is commented out in the original
24103                                                                          ; source, and isn't required as X is set to 0 above
24104 AEA8 D80E  30        movb rx,@FSH                    ; STX FSH           ; Set the forward shield to 0
     AEAA 0F11     
24105               
24106 AEAC 170D  14        jnc  OO3                        ; BCC OO3           ; Jump to OO3 to start taking damage directly from the
24107                                                                          ; energy banks (this BCC is effectively a JMP as the C
24108                                                                          ; flag is clear, as we jumped to OO2 with a BCC)
24109               
24110               OO1:
24111 AEAE D360  30        movb @ASH,ra                    ; LDA ASH           ; The aft shield was damaged, so fetch the shield
     AEB0 0F12     
24112                      .sbc @T,ra                      ; SBC T             ; strength from ASH and subtract the damage in T
     **** ****     > SBC
0001 AEB2 1801  14        joc  !
0002 AEB4 7347  18        sb   rone,ra
0003               !:
0004 AEB6 7360  30        sb   @T,ra
     AEB8 00D1     
                   < elite.a99
24113               
24114 AEBA 1704  14        jnc  OO5                        ; BCC OO5           ; If the C flag is clear then this amount of damage was
24115                                                                          ; too much for the shields, so jump to OO5 to set the
24116                                                                          ; shield level to 0 and start taking damage directly
24117                                                                          ; from the energy banks
24118               
24119 AEBC D80D  30        movb ra,@ASH                    ; STA ASH           ; Store the new value of the aft shield in ASH
     AEBE 0F12     
24120               
24121 AEC0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AEC2 FE2A     
24122               
24123               OO5:
24124               * LDX #0                 \ This instruction is commented out in the original
24125                                                                          ; source, and isn't required as X is set to 0 above
24126 AEC4 D80E  30        movb rx,@ASH                    ; STX ASH           ; Set the aft shield to 0
     AEC6 0F12     
24127               
24128               OO3:
24129                      .adc @ENERGY,ra                 ; ADC ENERGY        ; A is negative and contains the amount by which the
     **** ****     > ADC
0001 AEC8 1701  14        jnc  !
0002 AECA B347  18        ab   rone,ra
0003               !:
0004 AECC B360  30        ab   @ENERGY,ra
     AECE 0F13     
                   < elite.a99
24130 AED0 D80D  30        movb ra,@ENERGY                 ; STA ENERGY        ; damage overwhelmed the shields, so this drains the
     AED2 0F13     
24131                                                                          ; energy banks by that amount (and because the energy
24132                                                                          ; banks are shown over four indicators rather than one,
24133                                                                          ; but with the same value range of 0-255, energy will
24134                                                                          ; appear to drain away four times faster than the
24135                                                                          ; shields did)
24136               
24137 AED4 1301  14        jeq  B72                        ; BEQ B72           ; If we have just run out of energy, skip the next
24138                                                                          ; instruction to jump straight to our death
24139               
24140 AED6 1802  14        joc  B73                        ; BCS B73           ; If the C flag is set, then subtracting the damage from
24141                                                                          ; the energy banks didn't underflow, so we had enough
24142                                                                          ; energy to survive, and we can skip the next
24143                                                                          ; instruction to make a sound and take some damage
24144               
24145               B72:
24146 AED8 0460  28        b    @DEATH                     ; JMP DEATH         ; Otherwise our energy levels are either 0 or negative,
     AEDA C47E     
24147                                                                          ; and in either case that means we jump to our DEATH,
24148                                                                          ; returning from the subroutine using a tail call
24149               
24150               B73:
24151 AEDC 0200  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; We didn't die, so call EXNO3 to make the sound of a
     AEDE CB2E     
24152 AEE0 06A0  32        bl   @jsr                       ;
     AEE2 FE1E     
24153                                                                          ; collision
24154               
24155 AEE4 0460  28        b    @OUCH                      ; JMP OUCH          ; And jump to OUCH to take damage and return from the
     AEE6 CEA0     
24156                                                                          ; subroutine using a tail call
24157               
24158               * ******************************************************************************
24159               *
24160               * Name: SPS3
24161               * Type: Subroutine
24162               * Category: Maths (Geometry)
24163               * Summary: Copy a space coordinate from the K% block into K3
24164               *
24165               * ------------------------------------------------------------------------------
24166               *
24167               * Copy one of the planet's coordinates into the corresponding location in the
24168               * temporary variable K3. The high byte and absolute value of the sign byte are
24169               * copied into the first two K3 bytes, and the sign of the sign byte is copied
24170               * into the highest K3 byte.
24171               *
24172               * The comments below are written for copying the planet's x-coordinate into
24173               * K3(2 1 0).
24174               *
24175               * ------------------------------------------------------------------------------
24176               *
24177               * Arguments:
24178               *
24179               * X                   Determines which coordinate to copy, and to where:
24180               *
24181               * * X = 0 copies (x_sign, x_hi) into K3(2 1 0)
24182               *
24183               * * X = 3 copies (y_sign, y_hi) into K3(5 4 3)
24184               *
24185               * * X = 6 copies (z_sign, z_hi) into K3(8 7 6)
24186               *
24187               * ******************************************************************************
24188               
24189               SPS3:
24190 AEE8 D36E  34        movb @K.+1(rx),ra               ; LDA K%+1,X        ; Copy x_hi into K3+X
     AEEA 0901     
24191 AEEC DB8D  38        movb ra,@K3(rx)                 ; STA K3,X
     AEEE 00D2     
24192               
24193 AEF0 D36E  34        movb @K.+2(rx),ra               ; LDA K%+2,X        ; Set A = Y = x_sign
     AEF2 0902     
24194 AEF4 D3CD  18        movb ra,ry                      ; TAY
24195               
24196 AEF6 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K3+1 = |x_sign|
     AEF8 7F00     
24197 AEFA DB8D  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     AEFC 00D3     
24198               
24199 AEFE D34F  18        movb ry,ra                      ; TYA               ; Set K3+2 = the sign of x_sign
24200 AF00 024D  22        andi ra,>80*256                 ; AND #%10000000
     AF02 8000     
24201 AF04 DB8D  38        movb ra,@K3+2(rx)               ; STA K3+2,X
     AF06 00D4     
24202               
24203 AF08 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AF0A FE2A     
24204               
24205               * ******************************************************************************
24206               *
24207               * Name: GINF
24208               * Type: Subroutine
24209               * Category: Universe
24210               * Summary: Fetch the address of a ship's data block into INF
24211               *
24212               * ------------------------------------------------------------------------------
24213               *
24214               * Get the address of the data block for ship slot X and store it in INF. This
24215               * address is fetched from the UNIV table, which stores the addresses of the 13
24216               * ship data blocks in workspace K%.
24217               *
24218               * ------------------------------------------------------------------------------
24219               *
24220               * Arguments:
24221               *
24222               * X                   The ship slot number for which we want the data block
24223               * address
24224               *
24225               * ******************************************************************************
24226               
24227               GINF:
24228 AF0C D34E  18        movb rx,ra                      ; TXA               ; Set Y = X * 2
24229                      .asla                           ; ASL A
     **** ****     > ASLA
0001 AF0E 024D  22        andi ra,>ff00
     AF10 FF00     
0002 AF12 0A1D  18        sla  ra,1
                   < elite.a99
24230 AF14 D3CD  18        movb ra,ry                      ; TAY
24231               
24232 AF16 D36F  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Get the high byte of the address of the X-th ship
     AF18 221F     
24233 AF1A D80D  30        movb ra,@INF                    ; STA INF           ; from UNIV and store it in INF
     AF1C 0020     
24234               
24235 AF1E D36F  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y      ; Get the low byte of the address of the X-th ship
     AF20 2220     
24236 AF22 D80D  30        movb ra,@INF+1                  ; STA INF+1         ; from UNIV and store it in INF
     AF24 0021     
24237               
24238 AF26 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AF28 FE2A     
24239               
24240               * ******************************************************************************
24241               *
24242               * Name: NWSPS
24243               * Type: Subroutine
24244               * Category: Universe
24245               * Summary: Add a new space station to our local bubble of universe
24246               *
24247               * ******************************************************************************
24248               
24249               NWSPS:
24250 AF2A 0200  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     AF2C B0E2     
24251 AF2E 06A0  32        bl   @jsr                       ;
     AF30 FE1E     
24252               
24253 AF32 020E  20        li   rx,>01*256                 ; LDX #%00000001    ; Set the AI flag in byte #32 to %00000001 (friendly, no
     AF34 0100     
24254 AF36 D80E  30        movb rx,@INWK+32                ; STX INWK+32       ; AI, has an E.C.M.)
     AF38 0073     
24255               
24256 AF3A 7387  18        sb   rone,rx                    ; DEX               ; Set pitch counter to 0 (no pitch, roll only)
24257 AF3C D80E  30        movb rx,@INWK+30                ; STX INWK+30
     AF3E 0071     
24258               
24259               * STX INWK+31            \ This instruction is commented out in the original
24260                                                                          ; source. It would set the exploding state and missile
24261                                                                          ; count to 0
24262               
24263 AF40 D80E  30        movb rx,@FRIN+1                 ; STX FRIN+1        ; Set the second slot in the FRIN table to 0, so when we
     AF42 0D41     
24264                                                                          ; fall through into NWSHP below, the new station that
24265                                                                          ; gets created will go into slot FRIN+1, as this will be
24266                                                                          ; the first empty slot that the routine finds
24267               
24268 AF44 7387  18        sb   rone,rx                    ; DEX               ; Set the roll counter to 255 (maximum anti-clockwise
24269 AF46 D80E  30        movb rx,@INWK+29                ; STX INWK+29       ; roll with no damping)
     AF48 0070     
24270               
24271 AF4A 020E  20        li   rx,>0a*256                 ; LDX #10           ; Call NwS1 to flip the sign of nosev_x_hi (byte #10)
     AF4C 0A00     
24272 AF4E 0200  20        li   rtmp,NwS1                  ; JSR NwS1
     AF50 B08C     
24273 AF52 06A0  32        bl   @jsr                       ;
     AF54 FE1E     
24274               
24275 AF56 0200  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_y_hi (byte #12)
     AF58 B08C     
24276 AF5A 06A0  32        bl   @jsr                       ;
     AF5C FE1E     
24277               
24278 AF5E 0200  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_z_hi (byte #14)
     AF60 B08C     
24279 AF62 06A0  32        bl   @jsr                       ;
     AF64 FE1E     
24280               
24281 AF66 020D  20        li   ra,((LSO)%256)*256         ; LDA #LO(LSO)      ; Set bytes #33 and #34 to point to LSO for the ship
     AF68 6600     
24282 AF6A D80D  30        movb ra,@INWK+33                ; STA INWK+33       ; line heap for the space station
     AF6C 0074     
24283 AF6E 020D  20        li   ra,((LSO)/256)*256         ; LDA #HI(LSO)
     AF70 0D00     
24284 AF72 D80D  30        movb ra,@INWK+34                ; STA INWK+34
     AF74 0075     
24285               
24286 AF76 020D  20        li   ra,(SST)*256               ; LDA #SST          ; Set A to the space station type, and fall through
     AF78 0800     
24287                                                                          ; into NWSHP to finish adding the space station to the
24288                                                                          ; universe
24289               
24290               * ******************************************************************************
24291               *
24292               * Name: NWSHP
24293               * Type: Subroutine
24294               * Category: Universe
24295               * Summary: Add a new ship to our local bubble of universe
24296               *
24297               * ------------------------------------------------------------------------------
24298               *
24299               * This creates a new block of ship data in the K% workspace, allocates a new
24300               * block in the ship line heap at WP, adds the new ship's type into the first
24301               * empty slot in FRIN, and adds a pointer to the ship data into UNIV. If there
24302               * isn't enough free memory for the new ship, it isn't added.
24303               *
24304               * ------------------------------------------------------------------------------
24305               *
24306               * Arguments:
24307               *
24308               * A                   The type of the ship to add (see variable XX21 for a
24309               * list of ship types)
24310               *
24311               * ------------------------------------------------------------------------------
24312               *
24313               * Returns:
24314               *
24315               * C flag              Set if the ship was successfully added, clear if it
24316               * wasn't (as there wasn't enough free memory)
24317               *
24318               * INF                 Points to the new ship's data block in K%
24319               *
24320               * ******************************************************************************
24321               
24322               NWSHP:
24323 AF7A D80D  30        movb ra,@T                      ; STA T             ; Store the ship type in location T
     AF7C 00D1     
24324               
24325 AF7E 020E  20        li   rx,>00*256                 ; LDX #0            ; Before we can add a new ship, we need to check
     AF80 0000     
24326                                                                          ; whether we have an empty slot we can put it in. To do
24327                                                                          ; this, we need to loop through all the slots to look
24328                                                                          ; for an empty one, so set a counter in X that starts
24329                                                                          ; from the first slot at 0. When ships are killed, then
24330                                                                          ; the slots are shuffled down by the KILLSHP routine, so
24331                                                                          ; the first empty slot will always come after the last
24332                                                                          ; filled slot. This allows us to tack the new ship's
24333                                                                          ; data block and ship line heap onto the end of the
24334                                                                          ; existing ship data and heap, as shown in the memory
24335                                                                          ; map below
24336               
24337               NWL1:
24338 AF82 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Load the ship type for the X-th slot
     AF84 0D40     
24339               
24340 AF86 1307  14        jeq  NW1                        ; BEQ NW1           ; If it is zero, then this slot is empty and we can use
24341                                                                          ; it for our new ship, so jump down to NW1
24342               
24343 AF88 B387  18        ab   rone,rx                    ; INX               ; Otherwise increment X to point to the next slot
24344               
24345 AF8A 028E  22        ci   rx,(NOSH)*256              ; CPX #NOSH         ; If we haven't reached the last slot yet, loop back up
     AF8C 0C00     
24346 AF8E 17F9  14        jnc  NWL1                       ; BCC NWL1          ; to NWL1 to check the next slot (note that this means
24347                                                                          ; only slots from 0 to #NOSH - 1 are populated by this
24348                                                                          ; routine, but there is one more slot reserved in FRIN,
24349                                                                          ; which is used to identify the end of the slot list
24350                                                                          ; when shuffling the slots down in the KILLSHP routine)
24351               
24352               NW3:
24353                      .clc                            ; CLC               ; Otherwise we don't have an empty slot, so we can't
     **** ****     > CLC
0001 AF90 0A16  18        sla  rzero,1
                   < elite.a99
24354 AF92 0460  28        b    @rts                       ; RTS               ; add a new ship, so clear the C flag to indicate that
     AF94 FE2A     
24355                                                                          ; we have not managed to create the new ship, and return
24356                                                                          ; from the subroutine
24357               
24358               NW1:
24359                                                                          ; If we get here, then we have found an empty slot at
24360                                                                          ; index X, so we can go ahead and create our new ship.
24361                                                                          ; We do that by creating a ship data block at INWK and,
24362                                                                          ; when we are done, copying the block from INWK into
24363                                                                          ; the K% workspace (specifically, to INF)
24364 AF96 0200  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for ship slot X
     AF98 AF0C     
24365 AF9A 06A0  32        bl   @jsr                       ;
     AF9C FE1E     
24366                                                                          ; (which is in workspace K%) and store it in INF
24367               
24368 AF9E D360  30        movb @T,ra                      ; LDA T             ; If the type of ship that we want to create is
     AFA0 00D1     
24369 AFA2 115F  14        jlt  NW2                        ; BMI NW2           ; negative, then this indicates a planet or sun, so
24370                                                                          ; jump down to NW2, as the next section sets up a ship
24371                                                                          ; data block, which doesn't apply to planets and suns,
24372                                                                          ; as they don't have things like shields, missiles,
24373                                                                          ; vertices and edges
24374               
24375                                                                          ; This is a ship, so first we need to set up various
24376                                                                          ; pointers to the ship blueprint we will need. The
24377                                                                          ; blueprints for each ship type in Elite are stored
24378                                                                          ; in a table at location XX21, so refer to the comments
24379                                                                          ; on that variable for more details on the data we're
24380                                                                          ; about to access
24381               
24382                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 AFA4 024D  22        andi ra,>ff00
     AFA6 FF00     
0002 AFA8 0A1D  18        sla  ra,1
                   < elite.a99
24383 AFAA D3CD  18        movb ra,ry                      ; TAY
24384               
24385 AFAC D36F  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     AFAE E7E0     
24386 AFB0 D80D  30        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     AFB2 001E     
24387                                                                          ; so this fetches the low byte of this particular ship
24388                                                                          ; type's blueprint and stores it in XX0
24389               
24390 AFB4 D36F  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     AFB6 E7E1     
24391 AFB8 D80D  30        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1, so XX0(1 0) now
     AFBA 001F     
24392                                                                          ; contains the address of this ship's blueprint
24393               
24394 AFBC 028F  22        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship type is a space station (SST), then jump
     AFBE 1000     
24395 AFC0 1336  14        jeq  NW6                        ; BEQ NW6           ; to NW6, skipping the heap space steps below, as the
24396                                                                          ; space station has its own line heap at LSO (which it
24397                                                                          ; shares with the sun)
24398               
24399                                                                          ; We now want to allocate space for a heap that we can
24400                                                                          ; use to store the lines we draw for our new ship (so it
24401                                                                          ; can easily be erased from the screen again). SLSP
24402                                                                          ; points to the start of the current heap space, and we
24403                                                                          ; can extend it downwards with the heap for our new ship
24404                                                                          ; (as the heap space always ends just before the WP
24405                                                                          ; workspace)
24406               
24407 AFC2 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch ship blueprint byte #5, which contains the
     AFC4 0500     
24408                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; maximum heap size required for plotting the new ship,
     **** ****     > LD_IND_Y_IDX
0001 AFC6 D820  50        movb @XX0,@rtmplb
     AFC8 001E     
     AFCA 206D     
0002 AFCC D020  30        movb @XX0+1,rtmp
     AFCE 001F     
0003 AFD0 A00F  18        a    ry,rtmp
0004 AFD2 D350  26        movb *rtmp,RA
                   < elite.a99
24409 AFD4 D80D  30        movb ra,@T1                     ; STA T1            ; and store it in T1
     AFD6 0006     
24410               
24411 AFD8 D360  30        movb @SLSP,ra                   ; LDA SLSP          ; Take the 16-bit address in SLSP and subtract T1,
     AFDA 0F1E     
24412                      .sec                            ; SEC               ; storing the 16-bit result in INWK(34 33), so this now
     **** ****     > SEC
0001 AFDC 0A18  18        sla  rmone,1
                   < elite.a99
24413                      .sbc @T1,ra                     ; SBC T1            ; points to the start of the line heap for our new ship
     **** ****     > SBC
0001 AFDE 1801  14        joc  !
0002 AFE0 7347  18        sb   rone,ra
0003               !:
0004 AFE2 7360  30        sb   @T1,ra
     AFE4 0006     
                   < elite.a99
24414 AFE6 D80D  30        movb ra,@INWK+33                ; STA INWK+33
     AFE8 0074     
24415 AFEA D360  30        movb @SLSP+1,ra                 ; LDA SLSP+1
     AFEC 0F1F     
24416                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 AFEE 1801  14        joc  !
0002 AFF0 7347  18        sb   rone,ra
0003               !:
0004 AFF2 022D  22        ai   ra,-(>00*256)
     AFF4 0000     
                   < elite.a99
24417 AFF6 D80D  30        movb ra,@INWK+34                ; STA INWK+34
     AFF8 0075     
24418               
24419                                                                          ; We now need to check that there is enough free space
24420                                                                          ; for both this new line heap and the new data block
24421                                                                          ; for our ship. In memory, this is the layout of the
24422                                                                          ; ship data blocks and ship line heaps:
24423                                                                          ;
24424                                                                          ; +-----------------------------------+   &0F34
24425                                                                          ; |                                   |
24426                                                                          ; | WP workspace                      |
24427                                                                          ; |                                   |
24428                                                                          ; +-----------------------------------+   &0D40 = WP
24429                                                                          ; |                                   |
24430                                                                          ; | Current ship line heap            |
24431                                                                          ; |                                   |
24432                                                                          ; +-----------------------------------+   SLSP
24433                                                                          ; |                                   |
24434                                                                          ; | Proposed heap for new ship        |
24435                                                                          ; |                                   |
24436                                                                          ; +-----------------------------------+   INWK(34 33)
24437                                                                          ; |                                   |
24438                                                                          ; .                                   .
24439                                                                          ; .                                   .
24440                                                                          ; .                                   .
24441                                                                          ; .                                   .
24442                                                                          ; .                                   .
24443                                                                          ; |                                   |
24444                                                                          ; +-----------------------------------+   INF + NI%
24445                                                                          ; |                                   |
24446                                                                          ; | Proposed data block for new ship  |
24447                                                                          ; |                                   |
24448                                                                          ; +-----------------------------------+   INF
24449                                                                          ; |                                   |
24450                                                                          ; | Existing ship data blocks         |
24451                                                                          ; |                                   |
24452                                                                          ; +-----------------------------------+   &0900 = K%
24453                                                                          ;
24454                                                                          ; So, to work out if we have enough space, we have to
24455                                                                          ; make sure there is room between the end of our new
24456                                                                          ; ship data block at INF + NI%, and the start of the
24457                                                                          ; proposed heap for our new ship at the address we
24458                                                                          ; stored in INWK(34 33). Or, to put it another way, we
24459                                                                          ; and to make sure that:
24460                                                                          ;
24461                                                                          ; INWK(34 33) > INF + NI%
24462                                                                          ;
24463                                                                          ; which is the same as saying:
24464                                                                          ;
24465                                                                          ; INWK+33 - INF > NI%
24466                                                                          ;
24467                                                                          ; because INWK is in zero page, so INWK+34 = 0
24468               
24469 AFFA D360  30        movb @INWK+33,ra                ; LDA INWK+33       ; Calculate INWK+33 - INF, again using 16-bit
     AFFC 0074     
24470               * SEC                    \ arithmetic, and put the result in (A Y), so the high
24471                      .sbc @INF,ra                    ; SBC INF           ; byte is in A and the low byte in Y. The SEC
     **** ****     > SBC
0001 AFFE 1801  14        joc  !
0002 B000 7347  18        sb   rone,ra
0003               !:
0004 B002 7360  30        sb   @INF,ra
     B004 0020     
                   < elite.a99
24472 B006 D3CD  18        movb ra,ry                      ; TAY               ; instruction is commented out in the original source;
24473 B008 D360  30        movb @INWK+34,ra                ; LDA INWK+34       ; as the previous subtraction will never underflow, it
     B00A 0075     
24474                      .sbc @INF+1,ra                  ; SBC INF+1         ; is superfluous
     **** ****     > SBC
0001 B00C 1801  14        joc  !
0002 B00E 7347  18        sb   rone,ra
0003               !:
0004 B010 7360  30        sb   @INF+1,ra
     B012 0021     
                   < elite.a99
24475               
24476 B014 17BD  14        jnc  NW3+1                      ; BCC NW3+1         ; If we have an underflow from the subtraction, then
24477                                                                          ; INF > INWK+33 and we definitely don't have enough
24478                                                                          ; room for this ship, so jump to NW3+1, which returns
24479                                                                          ; from the subroutine (with the C flag already cleared)
24480               
24481 B016 1603  14        jne  NW4                        ; BNE NW4           ; If the subtraction of the high bytes in A is not
24482                                                                          ; zero, and we don't have underflow, then we definitely
24483                                                                          ; have enough space, so jump to NW4 to continue setting
24484                                                                          ; up the new ship
24485               
24486 B018 028F  22        ci   ry,(NI.)*256               ; CPY #NI%          ; Otherwise the high bytes are the same in our
     B01A 2400     
24487 B01C 17B9  14        jnc  NW3+1                      ; BCC NW3+1         ; subtraction, so now we compare the low byte of the
24488                                                                          ; result (which is in Y) with NI%. This is the same as
24489                                                                          ; doing INWK+33 - INF > NI% (see above). If this isn't
24490                                                                          ; true, the C flag will be clear and we don't have
24491                                                                          ; enough space, so we jump to NW3+1, which returns
24492                                                                          ; from the subroutine (with the C flag already cleared)
24493               
24494               NW4:
24495 B01E D360  30        movb @INWK+33,ra                ; LDA INWK+33       ; If we get here then we do have enough space for our
     B020 0074     
24496 B022 D80D  30        movb ra,@SLSP                   ; STA SLSP          ; new ship, so store the new bottom of the ship line
     B024 0F1E     
24497 B026 D360  30        movb @INWK+34,ra                ; LDA INWK+34       ; heap (i.e. INWK+33) in SLSP, doing both the high and
     B028 0075     
24498 B02A D80D  30        movb ra,@SLSP+1                 ; STA SLSP+1        ; low bytes
     B02C 0F1F     
24499               
24500               NW6:
24501 B02E 020F  20        li   ry,>0e*256                 ; LDY #14           ; Fetch ship blueprint byte #14, which contains the
     B030 0E00     
24502                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; ship's energy, and store it in byte #35
     **** ****     > LD_IND_Y_IDX
0001 B032 D820  50        movb @XX0,@rtmplb
     B034 001E     
     B036 206D     
0002 B038 D020  30        movb @XX0+1,rtmp
     B03A 001F     
0003 B03C A00F  18        a    ry,rtmp
0004 B03E D350  26        movb *rtmp,RA
                   < elite.a99
24503 B040 D80D  30        movb ra,@INWK+35                ; STA INWK+35
     B042 0076     
24504               
24505 B044 020F  20        li   ry,>13*256                 ; LDY #19           ; Fetch ship blueprint byte #19, which contains the
     B046 1300     
24506                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of missiles and laser power, and AND with %111
     **** ****     > LD_IND_Y_IDX
0001 B048 D820  50        movb @XX0,@rtmplb
     B04A 001E     
     B04C 206D     
0002 B04E D020  30        movb @XX0+1,rtmp
     B050 001F     
0003 B052 A00F  18        a    ry,rtmp
0004 B054 D350  26        movb *rtmp,RA
                   < elite.a99
24507 B056 024D  22        andi ra,>07*256                 ; AND #%00000111    ; to extract the number of missiles before storing in
     B058 0700     
24508 B05A D80D  30        movb ra,@INWK+31                ; STA INWK+31       ; byte #31
     B05C 0072     
24509               
24510 B05E D360  30        movb @T,ra                      ; LDA T             ; Restore the ship type we stored above
     B060 00D1     
24511               
24512               NW2:
24513 B062 DB8D  38        movb ra,@FRIN(rx)               ; STA FRIN,X        ; Store the ship type in the X-th byte of FRIN, so the
     B064 0D40     
24514                                                                          ; this slot is now shown as occupied in the index table
24515               
24516 B066 D38D  18        movb ra,rx                      ; TAX               ; Copy the ship type into X
24517               
24518 B068 1101  14        jlt  B74                        ; BMI B74           ; If the ship type is negative (planet or sun), then
24519                                                                          ; skip the following instruction
24520               
24521 B06A B347  18        ab   rone,ra                    ; INC MANY,X        ; Increment the total number of ships of type X
24522               
24523               B74:
24524 B06C 020F  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; The final step is to copy the new ship's data block
     B06E 2300     
24525                                                                          ; from INWK to INF, so set up a counter for NI% bytes
24526                                                                          ; in Y
24527               
24528               NWL3:
24529 B070 D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store in the Y-th byte
     B072 0053     
24530                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; of the workspace pointed to by INF
     **** ****     > ST_IND_Y_IDX
0001 B074 D820  50        movb @INF,@rtmplb
     B076 0020     
     B078 206D     
0002 B07A D020  30        movb @INF+1,rtmp
     B07C 0021     
0003 B07E A00F  18        a    ry,rtmp
0004 B080 D40D  30        movb RA,*rtmp
                   < elite.a99
24531               
24532 B082 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
24533               
24534 B084 15F5  14        jgt  NWL3                       ; BPL NWL3          ; Loop back for the next byte until we have copied them
24535                                                                          ; all over
24536               
24537                      .sec                            ; SEC               ; We have successfully created our new ship, so set the
     **** ****     > SEC
0001 B086 0A18  18        sla  rmone,1
                   < elite.a99
24538                                                                          ; C flag to indicate success
24539               
24540 B088 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B08A FE2A     
24541               
24542               * ******************************************************************************
24543               *
24544               * Name: NwS1
24545               * Type: Subroutine
24546               * Category: Universe
24547               * Summary: Flip the sign and double an INWK byte
24548               *
24549               * ------------------------------------------------------------------------------
24550               *
24551               * Flip the sign of the INWK byte at offset X, and increment X by 2. This is
24552               * used by the space station creation routine at NWSPS.
24553               *
24554               * ------------------------------------------------------------------------------
24555               *
24556               * Arguments:
24557               *
24558               * X                   The offset of the INWK byte to be flipped
24559               *
24560               * ------------------------------------------------------------------------------
24561               *
24562               * Returns:
24563               *
24564               * X                   X is incremented by 2
24565               *
24566               * ******************************************************************************
24567               
24568               NwS1:
24569 B08C D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Load the X-th byte of INWK into A and flip bit 7,
     B08E 0053     
24570                      .eoi (>80*256)                  ; EOR #%10000000    ; storing the result back in the X-th byte of INWK
     **** ****     > EOI
0001 B090 0200  20        li   rtmp,(>80*256)
     B092 8000     
0002 B094 2B40  18        xor  rtmp,ra
                   < elite.a99
24571 B096 DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X
     B098 0053     
24572               
24573 B09A B387  18        ab   rone,rx                    ; INX               ; Add 2 to X
24574 B09C B387  18        ab   rone,rx                    ; INX
24575               
24576 B09E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B0A0 FE2A     
24577               
24578               * ******************************************************************************
24579               *
24580               * Name: ABORT
24581               * Type: Subroutine
24582               * Category: Dashboard
24583               * Summary: Disarm missiles and update the dashboard indicators
24584               *
24585               * ------------------------------------------------------------------------------
24586               *
24587               * Arguments:
24588               *
24589               * Y                   The new status of the leftmost missile indicator
24590               *
24591               * ******************************************************************************
24592               
24593               ABORT:
24594 B0A2 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to &FF, which is the value of MSTG when we have
     B0A4 FF00     
24595                                                                          ; no target lock for our missile
24596               
24597                                                                          ; Fall through into ABORT2 to set the missile lock to
24598                                                                          ; the value in X, which effectively disarms the missile
24599               
24600               * ******************************************************************************
24601               *
24602               * Name: ABORT2
24603               * Type: Subroutine
24604               * Category: Dashboard
24605               * Summary: Set/unset the lock target for a missile and update the dashboard
24606               *
24607               * ------------------------------------------------------------------------------
24608               *
24609               * Set the lock target for the leftmost missile and update the dashboard.
24610               *
24611               * ------------------------------------------------------------------------------
24612               *
24613               * Arguments:
24614               *
24615               * X                   The slot number of the ship to lock our missile onto, or
24616               * &FF to remove missile lock
24617               *
24618               * Y                   The new colour of the missile indicator:
24619               *
24620               * * &00 = black (no missile)
24621               *
24622               * * &0E = red (armed and locked)
24623               *
24624               * * &E0 = yellow/white (armed)
24625               *
24626               * * &EE = green/cyan (disarmed)
24627               *
24628               * ******************************************************************************
24629               
24630               ABORT2:
24631 B0A6 D80E  30        movb rx,@MSTG                   ; STX MSTG          ; Store the target of our missile lock in MSTG
     B0A8 0052     
24632               
24633 B0AA D3A0  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Call MSBAR to update the leftmost indicator in the
     B0AC 0333     
24634 B0AE 0200  20        li   rtmp,MSBAR                 ; JSR MSBAR         ; dashboard's missile bar, which returns with Y = 0
     B0B0 B10E     
24635 B0B2 06A0  32        bl   @jsr                       ;
     B0B4 FE1E     
24636               
24637 B0B6 D80F  30        movb ry,@MSAR                   ; STY MSAR          ; Set MSAR = 0 to indicate that the leftmost missile
     B0B8 0D5E     
24638                                                                          ; is no longer seeking a target lock
24639               
24640 B0BA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B0BC FE2A     
24641               
24642               * ******************************************************************************
24643               *
24644               * Name: ECBLB2
24645               * Type: Subroutine
24646               * Category: Dashboard
24647               * Summary: Start up the E.C.M. (light up the indicator, start the countdown
24648               * and make the E.C.M. sound)
24649               *
24650               * ******************************************************************************
24651               
24652               ECBLB2:
24653 B0BE 020D  20        li   ra,>20*256                 ; LDA #32           ; Set the E.C.M. countdown timer in ECMA to 32
     B0C0 2000     
24654 B0C2 D80D  30        movb ra,@ECMA                   ; STA ECMA
     B0C4 0030     
24655               
24656                      .asla                           ; ASL A             ; Call the NOISE routine with A = 64 to make the sound
     **** ****     > ASLA
0001 B0C6 024D  22        andi ra,>ff00
     B0C8 FF00     
0002 B0CA 0A1D  18        sla  ra,1
                   < elite.a99
24657 B0CC 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the E.C.M. being switched on
     B0CE CBB0     
24658 B0D0 06A0  32        bl   @jsr                       ;
     B0D2 FE1E     
24659               
24660                                                                          ; Fall through into ECBLB to light up the E.C.M. bulb
24661               
24662               * ******************************************************************************
24663               *
24664               * Name: ECBLB
24665               * Type: Subroutine
24666               * Category: Dashboard
24667               * Summary: Light up the E.C.M. indicator bulb ("E") on the dashboard
24668               *
24669               * ******************************************************************************
24670               
24671               ECBLB:
24672 B0D4 020D  20        li   ra,(7*8)*256               ; LDA #7*8          ; The E.C.M. bulb is in character block number 7
     B0D6 3800     
24673                                                                          ; with each character taking 8 bytes, so this sets the
24674                                                                          ; low byte of the screen address of the character block
24675                                                                          ; we want to draw to
24676               
24677 B0D8 020E  20        li   rx,((ECBT)%256)*256        ; LDX #LO(ECBT)     ; Set (Y X) to point to the character definition in
     B0DA FE00     
24678 B0DC 020F  20        li   ry,((ECBT)/256)*256        ; LDY #HI(ECBT)     ; ECBT. The LDY has no effect, as we overwrite Y with
     B0DE B200     
24679                                                                          ; the jump to BULB-2, which writes the high byte of SPBT
24680                                                                          ; into Y. This works as long as ECBT and SPBT are in
24681                                                                          ; the same page of memory, so perhaps the BNE below got
24682                                                                          ; changed from BULB to BULB-2 so they could remove the
24683                                                                          ; LDY, but for some reason it didn't get culled? Who
24684                                                                          ; knows...
24685               
24686 B0E0 1605  14        jne  BULB-2                     ; BNE BULB-2        ; Jump down to BULB-2 (this BNE is effectively a JMP as
24687                                                                          ; A will never be zero)
24688               
24689               * ******************************************************************************
24690               *
24691               * Name: SPBLB
24692               * Type: Subroutine
24693               * Category: Dashboard
24694               * Summary: Light up the space station indicator ("S") on the dashboard
24695               *
24696               * ******************************************************************************
24697               
24698               SPBLB:
24699 B0E2 020D  20        li   ra,(24*8)*256              ; LDA #24*8         ; The space station bulb is in character block number 24
     B0E4 C000     
24700                                                                          ; with each character taking 8 bytes, so this sets the
24701                                                                          ; low byte of the screen address of the character block
24702                                                                          ; we want to draw to
24703               
24704 B0E6 020E  20        li   rx,((SPBT)%256)*256        ; LDX #LO(SPBT)     ; Set (Y X) to point to the character definition in SPBT
     B0E8 FB00     
24705 B0EA 020F  20        li   ry,((SPBT)/256)*256        ; LDY #HI(SPBT)
     B0EC B200     
24706               
24707                                                                          ; Fall through into BULB to draw the space station bulb
24708               
24709               * ******************************************************************************
24710               *
24711               * Name: BULB
24712               * Type: Subroutine
24713               * Category: Dashboard
24714               * Summary: Draw an indicator bulb on the dashboard
24715               *
24716               * ------------------------------------------------------------------------------
24717               *
24718               * Arguments:
24719               *
24720               * A                   The y-coordinate of the bulb as a low-byte screen
24721               * address offset within screen page &7D (as both bulbs
24722               * are on this character row in the dashboard)
24723               *
24724               * (Y X)               The address of the character definition of the bulb to
24725               * be drawn (i.e. ECBT for the E.C.M. bulb, or SPBT for the
24726               * space station bulb)
24727               *
24728               * ------------------------------------------------------------------------------
24729               *
24730               * Other entry points:
24731               *
24732               * BULB-2              Set the Y screen address
24733               *
24734               * ******************************************************************************
24735               
24736               BULB:
24737 B0EE D80D  30        movb ra,@SC                     ; STA SC            ; Store the low byte of the screen address in SC
     B0F0 0007     
24738               
24739 B0F2 D80E  30        movb rx,@P+1                    ; STX P+1           ; Set P(2 1) = (Y X)
     B0F4 001C     
24740 B0F6 D80F  30        movb ry,@P+2                    ; STY P+2
     B0F8 001D     
24741               
24742 B0FA 020D  20        li   ra,>7d*256                 ; LDA #&7D          ; Set A to the high byte of the screen address, which is
     B0FC 7D00     
24743                                                                          ; &7D as the bulbs are both in the character row from
24744                                                                          ; &7D00 to &7DFF
24745               
24746 B0FE 0460  28        b    @RREN                      ; JMP RREN          ; Call RREN to print the character definition pointed to
     B100 3226     
24747                                                                          ; by P(2 1) at the screen address pointed to by (A SC),
24748                                                                          ; returning from the subroutine using a tail call
24749               
24750               * ******************************************************************************
24751               *
24752               * Name: ECBT
24753               * Type: Variable
24754               * Category: Dashboard
24755               * Summary: The character bitmap for the E.C.M. indicator bulb
24756               *
24757               * ------------------------------------------------------------------------------
24758               *
24759               * The character bitmap for the E.C.M. indicator's "E" bulb that gets displayed
24760               * on the dashboard.
24761               *
24762               * The E.C.M. indicator uses the first 5 rows of the space station's "S" bulb
24763               * below, as the bottom 5 rows of the "E" match the top 5 rows of the "S".
24764               *
24765               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
24766               *
24767               * ******************************************************************************
24768               
24769               ECBT:
24770 B102 E0              byte >e0                                            ; x x x .
24771 B103   E0            byte >e0                                            ; x x x .
24772 B104 80              byte >80                                            ; x . . .
24773                                                                          ; x x x .
24774                                                                          ; x x x .
24775                                                                          ; x . . .
24776                                                                          ; x x x .
24777                                                                          ; x x x .
24778               
24779               * ******************************************************************************
24780               *
24781               * Name: SPBT
24782               * Type: Variable
24783               * Category: Dashboard
24784               * Summary: The bitmap definition for the space station indicator bulb
24785               *
24786               * ------------------------------------------------------------------------------
24787               *
24788               * The bitmap definition for the space station indicator's "S" bulb that gets
24789               * displayed on the dashboard.
24790               *
24791               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
24792               *
24793               * ******************************************************************************
24794               
24795               SPBT:
24796 B105   E0            byte >e0                                            ; x x x .
24797 B106 E0              byte >e0                                            ; x x x .
24798 B107   80            byte >80                                            ; x . . .
24799 B108 E0              byte >e0                                            ; x x x .
24800 B109   E0            byte >e0                                            ; x x x .
24801 B10A 20              byte >20                                            ; . . x .
24802 B10B   E0            byte >e0                                            ; x x x .
24803 B10C E0              byte >e0                                            ; x x x .
24804               
24805               * ******************************************************************************
24806               *
24807               * Name: MSBAR
24808               * Type: Subroutine
24809               * Category: Dashboard
24810               * Summary: Draw a specific indicator in the dashboard's missile bar
24811               *
24812               * ------------------------------------------------------------------------------
24813               *
24814               * Each indicator is a rectangle that's 3 pixels wide and 5 pixels high. If the
24815               * indicator is set to black, this effectively removes a missile.
24816               *
24817               * ------------------------------------------------------------------------------
24818               *
24819               * Arguments:
24820               *
24821               * X                   The number of the missile indicator to update (counting
24822               * from right to left, so indicator NOMSL is the leftmost
24823               * indicator)
24824               *
24825               * Y                   The colour of the missile indicator:
24826               *
24827               * * &00 = black (no missile)
24828               *
24829               * * &0E = red (armed and locked)
24830               *
24831               * * &E0 = yellow/white (armed)
24832               *
24833               * * &EE = green/cyan (disarmed)
24834               *
24835               * ------------------------------------------------------------------------------
24836               *
24837               * Returns:
24838               *
24839               * X                   X is preserved
24840               *
24841               * Y                   Y is set to 0
24842               *
24843               * ******************************************************************************
24844               
24845               MSBAR:
24846 B10E D34E  18        movb rx,ra                      ; TXA               ; Set T = X * 8
24847                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B110 024D  22        andi ra,>ff00
     B112 FF00     
0002 B114 0A1D  18        sla  ra,1
                   < elite.a99
24848                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B116 024D  22        andi ra,>ff00
     B118 FF00     
0002 B11A 0A1D  18        sla  ra,1
                   < elite.a99
24849                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B11C 024D  22        andi ra,>ff00
     B11E FF00     
0002 B120 0A1D  18        sla  ra,1
                   < elite.a99
24850 B122 D80D  30        movb ra,@T                      ; STA T
     B124 00D1     
24851               
24852 B126 020D  20        li   ra,>31*256                 ; LDA #49           ; Set SC = 49 - T
     B128 3100     
24853                      .sbc @T,ra                      ; SBC T             ; = 48 + 1 - (X * 8)
     **** ****     > SBC
0001 B12A 1801  14        joc  !
0002 B12C 7347  18        sb   rone,ra
0003               !:
0004 B12E 7360  30        sb   @T,ra
     B130 00D1     
                   < elite.a99
24854 B132 D80D  30        movb ra,@SC                     ; STA SC
     B134 0007     
24855               
24856                                                                          ; So the low byte of SC(1 0) contains the row address
24857                                                                          ; for the rightmost missile indicator, made up as
24858                                                                          ; follows:
24859                                                                          ;
24860                                                                          ; * 48 (character block 7, as byte #7 * 8 = 48), the
24861                                                                          ; character block of the rightmost missile
24862                                                                          ;
24863                                                                          ; * 1 (so we start drawing on the second row of the
24864                                                                          ; character block)
24865                                                                          ;
24866                                                                          ; * Move left one character (8 bytes) for each count
24867                                                                          ; of X, so when X = 0 we are drawing the rightmost
24868                                                                          ; missile, for X = 1 we hop to the left by one
24869                                                                          ; character, and so on
24870               
24871 B136 020D  20        li   ra,>7e*256                 ; LDA #&7E          ; Set the high byte of SC(1 0) to &7E, the character row
     B138 7E00     
24872 B13A D80D  30        movb ra,@SCH                    ; STA SCH           ; that contains the missile indicators (i.e. the bottom
     B13C 0008     
24873                                                                          ; row of the screen)
24874               
24875 B13E D34F  18        movb ry,ra                      ; TYA               ; Set A to the correct colour, which is a 3-pixel wide
24876                                                                          ; mode 5 character row in the correct colour (for
24877                                                                          ; example, a green block has Y = &EE, or %11101110, so
24878                                                                          ; the missile blocks are 3 pixels wide, with the
24879                                                                          ; fourth pixel on the character row being empty)
24880               
24881 B140 020F  20        li   ry,>05*256                 ; LDY #5            ; We now want to draw this line five times, so set a
     B142 0500     
24882                                                                          ; counter in Y
24883               
24884               MBL1:
24885                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the 3-pixel row, and as we do not use EOR logic,
     **** ****     > ST_IND_Y_IDX
0001 B144 D820  50        movb @SC,@rtmplb
     B146 0007     
     B148 206D     
0002 B14A D020  30        movb @SC+1,rtmp
     B14C 0008     
0003 B14E A00F  18        a    ry,rtmp
0004 B150 D40D  30        movb RA,*rtmp
                   < elite.a99
24886                                                                          ; this will overwrite anything that is already there
24887                                                                          ; (so drawing a black missile will delete what's there)
24888               
24889 B152 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter for the next row
24890               
24891 B154 16F7  14        jne  MBL1                       ; BNE MBL1          ; Loop back to MBL1 if have more rows to draw
24892               
24893 B156 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B158 FE2A     
24894               
24895               * ******************************************************************************
24896               *
24897               * Name: PROJ
24898               * Type: Subroutine
24899               * Category: Maths (Geometry)
24900               * Summary: Project the current ship or planet onto the screen
24901               * Deep dive: Extended screen coordinates
24902               *
24903               * ------------------------------------------------------------------------------
24904               *
24905               * Project the current ship's location or the planet onto the screen, either
24906               * returning the screen coordinates of the projection (if it's on-screen), or
24907               * returning an error via the C flag.
24908               *
24909               * In this context, "on-screen" means that the point is projected into the
24910               * following range:
24911               *
24912               * centre of screen - 1024 < x < centre of screen + 1024
24913               * centre of screen - 1024 < y < centre of screen + 1024
24914               *
24915               * This is to cater for ships (and, more likely, planets and suns) whose centres
24916               * are off-screen but whose edges may still be visible.
24917               *
24918               * The projection calculation is:
24919               *
24920               * K3(1 0) = #X + x / z
24921               * K4(1 0) = #Y + y / z
24922               *
24923               * where #X and #Y are the pixel x-coordinate and y-coordinate of the centre of
24924               * the screen.
24925               *
24926               * ------------------------------------------------------------------------------
24927               *
24928               * Arguments:
24929               *
24930               * INWK                The ship data block for the ship to project on-screen
24931               *
24932               * ------------------------------------------------------------------------------
24933               *
24934               * Returns:
24935               *
24936               * K3(1 0)             The x-coordinate of the ship's projection on-screen
24937               *
24938               * K4(1 0)             The y-coordinate of the ship's projection on-screen
24939               *
24940               * C flag              Set if the ship's projection doesn't fit on the screen,
24941               * clear if it does project onto the screen
24942               *
24943               * A                   Contains K4+1, the high byte of the y-coordinate
24944               *
24945               * ******************************************************************************
24946               
24947               PROJ:
24948 B15A D360  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     B15C 0053     
24949 B15E D80D  30        movb ra,@P                      ; STA P             ; = x
     B160 001B     
24950 B162 D360  30        movb @INWK+1,ra                 ; LDA INWK+1
     B164 0054     
24951 B166 D80D  30        movb ra,@P+1                    ; STA P+1
     B168 001C     
24952               
24953 B16A D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     B16C 0055     
24954               
24955 B16E 0200  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     B170 BB40     
24956 B172 06A0  32        bl   @jsr                       ;
     B174 FE1E     
24957                                                                          ;
24958                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
24959                                                                          ; = (x_sign x_hi x_lo) / (z_sign z_hi z_lo)
24960                                                                          ; = x / z
24961               
24962 B176 1832  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
24963                                                                          ; the coordinate doesn't fit on the screen, so return
24964                                                                          ; from the subroutine with the C flag set (as PL2-1
24965                                                                          ; contains an RTS)
24966               
24967 B178 D360  30        movb @K,ra                      ; LDA K             ; Set K3(1 0) = (X K) + #X
     B17A 003D     
24968                      .adi ((X)*256)                  ; ADC #X            ; = #X + x / z
     **** ****     > ADI
0001 B17C 1701  14        jnc  !
0002 B17E B347  18        ab   rone,ra
0003               !:
0004 B180 022D  22        ai   ra,((X)*256)
     B182 8000     
                   < elite.a99
24969 B184 D80D  30        movb ra,@K3                     ; STA K3            ;
     B186 00D2     
24970                                                                          ; first doing the low bytes
24971               
24972 B188 D34E  18        movb rx,ra                      ; TXA               ; And then the high bytes. #X is the x-coordinate of
24973                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 B18A 1701  14        jnc  !
0002 B18C B347  18        ab   rone,ra
0003               !:
0004 B18E 022D  22        ai   ra,(>00*256)
     B190 0000     
                   < elite.a99
24974 B192 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; space x-coordinate into a screen x-coordinate
     B194 00D3     
24975               
24976 B196 D360  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     B198 0056     
24977 B19A D80D  30        movb ra,@P                      ; STA P
     B19C 001B     
24978 B19E D360  30        movb @INWK+4,ra                 ; LDA INWK+4
     B1A0 0057     
24979 B1A2 D80D  30        movb ra,@P+1                    ; STA P+1
     B1A4 001C     
24980               
24981 B1A6 D360  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = -y_sign
     B1A8 0058     
24982                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B1AA 0200  20        li   rtmp,(>80*256)
     B1AC 8000     
0002 B1AE 2B40  18        xor  rtmp,ra
                   < elite.a99
24983               
24984 B1B0 0200  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     B1B2 BB40     
24985 B1B4 06A0  32        bl   @jsr                       ;
     B1B6 FE1E     
24986                                                                          ;
24987                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
24988                                                                          ; = -(y_sign y_hi y_lo) / (z_sign z_hi z_lo)
24989                                                                          ; = -y / z
24990               
24991 B1B8 1811  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
24992                                                                          ; the coordinate doesn't fit on the screen, so return
24993                                                                          ; from the subroutine with the C flag set (as PL2-1
24994                                                                          ; contains an RTS)
24995               
24996 B1BA D360  30        movb @K,ra                      ; LDA K             ; Set K4(1 0) = (X K) + #Y
     B1BC 003D     
24997                      .adi ((Y)*256)                  ; ADC #Y            ; = #Y - y / z
     **** ****     > ADI
0001 B1BE 1701  14        jnc  !
0002 B1C0 B347  18        ab   rone,ra
0003               !:
0004 B1C2 022D  22        ai   ra,((Y)*256)
     B1C4 6000     
                   < elite.a99
24998 B1C6 D80D  30        movb ra,@K4                     ; STA K4            ;
     B1C8 00E0     
24999                                                                          ; first doing the low bytes
25000               
25001 B1CA D34E  18        movb rx,ra                      ; TXA               ; And then the high bytes. #Y is the y-coordinate of
25002                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 B1CC 1701  14        jnc  !
0002 B1CE B347  18        ab   rone,ra
0003               !:
0004 B1D0 022D  22        ai   ra,(>00*256)
     B1D2 0000     
                   < elite.a99
25003 B1D4 D80D  30        movb ra,@K4+1                   ; STA K4+1          ; space x-coordinate into a screen y-coordinate
     B1D6 00E1     
25004               
25005                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 B1D8 0A16  18        sla  rzero,1
                   < elite.a99
25006               
25007 B1DA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B1DC FE2A     
25008               
25009               * ******************************************************************************
25010               *
25011               * Name: PL2
25012               * Type: Subroutine
25013               * Category: Drawing planets
25014               * Summary: Remove the planet or sun from the screen
25015               *
25016               * ------------------------------------------------------------------------------
25017               *
25018               * Other entry points:
25019               *
25020               * PL2-1               Contains an RTS
25021               *
25022               * ******************************************************************************
25023               
25024               PL2:
25025 B1DE D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Shift bit 0 of the planet/sun's type into the C flag
     B1E0 009B     
25026 B1E2 091D  18        srl  ra,1                       ; LSR A
25027               
25028 B1E4 1802  14        joc  B75                        ; BCS B75           ; If the planet/sun's type has bit 0 clear, then it's
25029                                                                          ; either 128 or 130, which is a planet; meanwhile, the
25030                                                                          ; sun has type 129, which has bit 0 set. So if this is
25031                                                                          ; the sun, skip the following instruction
25032               
25033 B1E6 0460  28        b    @WPLS2                     ; JMP WPLS2         ; This is the planet, so jump to WPLS2 to remove it from
     B1E8 B90A     
25034                                                                          ; screen, returning from the subroutine using a tail
25035                                                                          ; call
25036               
25037               B75:
25038 B1EA 0460  28        b    @WPLS                      ; JMP WPLS          ; This is the sun, so jump to WPLS to remove it from
     B1EC B97C     
25039                                                                          ; screen, returning from the subroutine using a tail
25040                                                                          ; call
25041               
25042               * ******************************************************************************
25043               *
25044               * Name: PLANET
25045               * Type: Subroutine
25046               * Category: Drawing planets
25047               * Summary: Draw the planet or sun
25048               *
25049               * ------------------------------------------------------------------------------
25050               *
25051               * Arguments:
25052               *
25053               * INWK                The planet or sun's ship data block
25054               *
25055               * ******************************************************************************
25056               
25057               PLANET:
25058 B1EE D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign (the highest byte in the planet/sun's
     B1F0 005B     
25059                                                                          ; coordinates)
25060               
25061 B1F2 11F5  14        jlt  PL2                        ; BMI PL2           ; If A is negative then the planet/sun is behind us, so
25062                                                                          ; jump to PL2 to remove it from the screen, returning
25063                                                                          ; from the subroutine using a tail call
25064               
25065 B1F4 028D  22        ci   ra,>30*256                 ; CMP #48           ; If A >= 48 then the planet/sun is too far away to be
     B1F6 3000     
25066 B1F8 18F2  14        joc  PL2                        ; BCS PL2           ; seen, so jump to PL2 to remove it from the screen,
25067                                                                          ; returning from the subroutine using a tail call
25068               
25069 B1FA F360  30        socb @INWK+7,ra                 ; ORA INWK+7        ; Set A to 0 if both z_sign and z_hi are 0
     B1FC 005A     
25070               
25071 B1FE 13EF  14        jeq  PL2                        ; BEQ PL2           ; If both z_sign and z_hi are 0, then the planet/sun is
25072                                                                          ; too close to be shown, so jump to PL2 to remove it
25073                                                                          ; from the screen, returning from the subroutine using a
25074                                                                          ; tail call
25075               
25076 B200 0200  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the planet/sun onto the screen, returning the
     B202 B15A     
25077 B204 06A0  32        bl   @jsr                       ;
     B206 FE1E     
25078                                                                          ; centre's coordinates in K3(1 0) and K4(1 0)
25079               
25080 B208 18EA  14        joc  PL2                        ; BCS PL2           ; If the C flag is set by PROJ then the planet/sun is
25081                                                                          ; not visible on-screen, so jump to PL2 to remove it
25082                                                                          ; from the screen, returning from the subroutine using
25083                                                                          ; a tail call
25084               
25085 B20A 020D  20        li   ra,>60*256                 ; LDA #96           ; Set (A P+1 P) = (0 96 0) = 24576
     B20C 6000     
25086 B20E D80D  30        movb ra,@P+1                    ; STA P+1           ;
     B210 001C     
25087 B212 020D  20        li   ra,>00*256                 ; LDA #0            ; This represents the planet/sun's radius at a distance
     B214 0000     
25088 B216 D80D  30        movb ra,@P                      ; STA P             ; of z = 1
     B218 001B     
25089               
25090 B21A 0200  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     B21C 45E8     
25091 B21E 06A0  32        bl   @jsr                       ;
     B220 FE1E     
25092                                                                          ;
25093                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
25094                                                                          ; = (0 96 0) / z
25095                                                                          ; = 24576 / z
25096                                                                          ;
25097                                                                          ; so K now contains the planet/sun's radius, reduced by
25098                                                                          ; the actual distance to the planet/sun. We know that
25099                                                                          ; K+3 and K+2 will be 0, as the number we are dividing,
25100                                                                          ; (0 96 0), fits into the two bottom bytes, so the
25101                                                                          ; result is actually in K(1 0)
25102               
25103 B222 D360  30        movb @K+1,ra                    ; LDA K+1           ; If the high byte of the reduced radius is zero, jump
     B224 003E     
25104 B226 1304  14        jeq  PL82                       ; BEQ PL82          ; to PL82, as K contains the radius on its own
25105               
25106 B228 020D  20        li   ra,>f8*256                 ; LDA #248          ; Otherwise set K = 248, to round up the radius in
     B22A F800     
25107 B22C D80D  30        movb ra,@K                      ; STA K             ; K(1 0) to the nearest integer (if we consider the low
     B22E 003D     
25108                                                                          ; byte to be the fractional part)
25109               
25110               PL82:
25111 B230 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet/sun's type has bit 0 clear, then it's
     B232 009B     
25112 B234 091D  18        srl  ra,1                       ; LSR A             ; either 128 or 130, which is a planet (the sun has type
25113 B236 1702  14        jnc  PL9                        ; BCC PL9           ; 129, which has bit 0 set). So jump to PL9 to draw the
25114                                                                          ; planet with radius K, returning from the subroutine
25115                                                                          ; using a tail call
25116               
25117 B238 0460  28        b    @SUN                       ; JMP SUN           ; Otherwise jump to SUN to draw the sun with radius K,
     B23A B5C4     
25118                                                                          ; returning from the subroutine using a tail call
25119               
25120               * ******************************************************************************
25121               *
25122               * Name: PL9 (Part 1 of 3)
25123               * Type: Subroutine
25124               * Category: Drawing planets
25125               * Summary: Draw the planet, with either an equator and meridian, or a crater
25126               *
25127               * ------------------------------------------------------------------------------
25128               *
25129               * Draw the planet with radius K at pixel coordinate (K3, K4), and with either an
25130               * equator and meridian, or a crater.
25131               *
25132               * ------------------------------------------------------------------------------
25133               *
25134               * Arguments:
25135               *
25136               * K(1 0)              The planet's radius
25137               *
25138               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25139               *
25140               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25141               *
25142               * INWK                The planet's ship data block
25143               *
25144               * ******************************************************************************
25145               
25146               PL9:
25147 B23C 0200  20        li   rtmp,WPLS2                 ; JSR WPLS2         ; Call WPLS2 to remove the planet from the screen
     B23E B90A     
25148 B240 06A0  32        bl   @jsr                       ;
     B242 FE1E     
25149               
25150 B244 0200  20        li   rtmp,CIRCLE                ; JSR CIRCLE        ; Call CIRCLE to draw the planet's new circle
     B246 B7FE     
25151 B248 06A0  32        bl   @jsr                       ;
     B24A FE1E     
25152               
25153 B24C 1803  14        joc  PL20                       ; BCS PL20          ; If the call to CIRCLE returned with the C flag set,
25154                                                                          ; then the circle does not fit on-screen, so jump to
25155                                                                          ; PL20 to return from the subroutine
25156               
25157 B24E D360  30        movb @K+1,ra                    ; LDA K+1           ; If K+1 is zero, jump to PL25 as K(1 0) < 256, so the
     B250 003E     
25158 B252 1302  14        jeq  PL25                       ; BEQ PL25          ; planet fits on the screen and we can draw meridians or
25159                                                                          ; craters
25160               
25161               PL20:
25162 B254 0460  28        b    @rts                       ; RTS               ; The planet doesn't fit on-screen, so return from the
     B256 FE2A     
25163                                                                          ; subroutine
25164               
25165               PL25:
25166 B258 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet type is 128 then it has an equator and
     B25A 009B     
25167 B25C 028D  22        ci   ra,>80*256                 ; CMP #128          ; a meridian, so this jumps to PL26 if this is not a
     B25E 8000     
25168 B260 1643  14        jne  PL26                       ; BNE PL26          ; planet with an equator - in other words, if it is a
25169                                                                          ; planet with a crater
25170               
25171                                                                          ; Otherwise this is a planet with an equator and
25172                                                                          ; meridian, so fall through into the following to draw
25173                                                                          ; them
25174               
25175               * ******************************************************************************
25176               *
25177               * Name: PL9 (Part 2 of 3)
25178               * Type: Subroutine
25179               * Category: Drawing planets
25180               * Summary: Draw the planet's equator and meridian
25181               * Deep dive: Drawing meridians and equators
25182               *
25183               * ------------------------------------------------------------------------------
25184               *
25185               * Draw the planet's equator and meridian.
25186               *
25187               * ------------------------------------------------------------------------------
25188               *
25189               * Arguments:
25190               *
25191               * K(1 0)              The planet's radius
25192               *
25193               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25194               *
25195               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25196               *
25197               * INWK                The planet's ship data block
25198               *
25199               * ******************************************************************************
25200               
25201 B262 D360  30        movb @K,ra                      ; LDA K             ; If the planet's radius is less than 6, the planet is
     B264 003D     
25202 B266 028D  22        ci   ra,>06*256                 ; CMP #6            ; too small to show a meridian, so jump to PL20 to
     B268 0600     
25203 B26A 17F4  14        jnc  PL20                       ; BCC PL20          ; return from the subroutine
25204               
25205 B26C D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     B26E 0061     
25206                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B270 0200  20        li   rtmp,(>80*256)
     B272 8000     
0002 B274 2B40  18        xor  rtmp,ra
                   < elite.a99
25207 B276 D80D  30        movb ra,@P                      ; STA P
     B278 001B     
25208               
25209 B27A D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     B27C 0067     
25210               
25211 B27E 0200  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     B280 BAF8     
25212 B282 06A0  32        bl   @jsr                       ;
     B284 FE1E     
25213                                                                          ;
25214                                                                          ; CNT2 = arctan(P / A) / 4
25215                                                                          ; = arctan(-nosev_z_hi / roofv_z_hi) / 4
25216                                                                          ;
25217                                                                          ; and do the following if nosev_z_hi >= 0:
25218                                                                          ;
25219                                                                          ; CNT2 = CNT2 + PI
25220               
25221 B286 020E  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 so the call to PLS1 divides nosev_x
     B288 0900     
25222               
25223 B28A 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B28C B3AC     
25224 B28E 06A0  32        bl   @jsr                       ;
     B290 FE1E     
25225 B292 D80D  30        movb ra,@K2                     ; STA K2            ;
     B294 00AC     
25226 B296 D80F  30        movb ry,@XX16                   ; STY XX16          ; (XX16 K2) = nosev_x / z
     B298 0009     
25227                                                                          ;
25228                                                                          ; and increment X to point to nosev_y for the next call
25229               
25230 B29A 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B29C B3AC     
25231 B29E 06A0  32        bl   @jsr                       ;
     B2A0 FE1E     
25232 B2A2 D80D  30        movb ra,@K2+1                   ; STA K2+1          ;
     B2A4 00AD     
25233 B2A6 D80F  30        movb ry,@XX16+1                 ; STY XX16+1        ; (XX16+1 K2+1) = nosev_y / z
     B2A8 000A     
25234               
25235 B2AA 020E  20        li   rx,>0f*256                 ; LDX #15           ; Set X to 15 so the call to PLS5 divides roofv_x
     B2AC 0F00     
25236               
25237 B2AE 0200  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     B2B0 BB1C     
25238 B2B2 06A0  32        bl   @jsr                       ;
     B2B4 FE1E     
25239                                                                          ;
25240                                                                          ; (XX16+2 K2+2) = roofv_x / z
25241                                                                          ;
25242                                                                          ; (XX16+3 K2+3) = roofv_y / z
25243               
25244 B2B6 0200  20        li   rtmp,PLS2                  ; JSR PLS2          ; Call PLS2 to draw the first meridian
     B2B8 B3EA     
25245 B2BA 06A0  32        bl   @jsr                       ;
     B2BC FE1E     
25246               
25247 B2BE D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     B2C0 0061     
25248                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B2C2 0200  20        li   rtmp,(>80*256)
     B2C4 8000     
0002 B2C6 2B40  18        xor  rtmp,ra
                   < elite.a99
25249 B2C8 D80D  30        movb ra,@P                      ; STA P
     B2CA 001B     
25250               
25251 B2CC D360  30        movb @INWK+26,ra                ; LDA INWK+26       ; Set A = sidev_z_hi, so the second meridian will be at
     B2CE 006D     
25252                                                                          ; 90 degrees to the first
25253               
25254 B2D0 0200  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     B2D2 BAF8     
25255 B2D4 06A0  32        bl   @jsr                       ;
     B2D6 FE1E     
25256                                                                          ;
25257                                                                          ; CNT2 = arctan(P / A) / 4
25258                                                                          ; = arctan(-nosev_z_hi / sidev_z_hi) / 4
25259                                                                          ;
25260                                                                          ; and do the following if nosev_z_hi >= 0:
25261                                                                          ;
25262                                                                          ; CNT2 = CNT2 + PI
25263               
25264 B2D8 020E  20        li   rx,>15*256                 ; LDX #21           ; Set X to 21 so the call to PLS5 divides sidev_x
     B2DA 1500     
25265               
25266 B2DC 0200  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     B2DE BB1C     
25267 B2E0 06A0  32        bl   @jsr                       ;
     B2E2 FE1E     
25268                                                                          ;
25269                                                                          ; (XX16+2 K2+2) = sidev_x / z
25270                                                                          ;
25271                                                                          ; (XX16+3 K2+3) = sidev_y / z
25272               
25273 B2E4 0460  28        b    @PLS2                      ; JMP PLS2          ; Jump to PLS2 to draw the second meridian, returning
     B2E6 B3EA     
25274                                                                          ; from the subroutine using a tail call
25275               
25276               * ******************************************************************************
25277               *
25278               * Name: PL9 (Part 3 of 3)
25279               * Type: Subroutine
25280               * Category: Drawing planets
25281               * Summary: Draw the planet's crater
25282               * Deep dive: Drawing craters
25283               *
25284               * ------------------------------------------------------------------------------
25285               *
25286               * Draw the planet's crater.
25287               *
25288               * ------------------------------------------------------------------------------
25289               *
25290               * Arguments:
25291               *
25292               * K(1 0)              The planet's radius
25293               *
25294               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25295               *
25296               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25297               *
25298               * INWK                The planet's ship data block
25299               *
25300               * ******************************************************************************
25301               
25302               PL26:
25303 B2E8 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     B2EA 0067     
25304               
25305 B2EC 11B3  14        jlt  PL20                       ; BMI PL20          ; If A is negative, the crater is on the far side of the
25306                                                                          ; planet, so return from the subroutine (as PL2
25307                                                                          ; contains an RTS)
25308               
25309 B2EE 020E  20        li   rx,>0f*256                 ; LDX #15           ; Set X = 15, so the following call to PLS3 operates on
     B2F0 0F00     
25310                                                                          ; roofv
25311               
25312 B2F2 0200  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     B2F4 BAAC     
25313 B2F6 06A0  32        bl   @jsr                       ;
     B2F8 FE1E     
25314                                                                          ;
25315                                                                          ; (Y A P) = 222 * roofv_x / z
25316                                                                          ;
25317                                                                          ; to give the x-coordinate of the crater offset and
25318                                                                          ; increment X to point to roofv_y for the next call
25319               
25320                      .clc                            ; CLC               ; Calculate:
     **** ****     > CLC
0001 B2FA 0A16  18        sla  rzero,1
                   < elite.a99
25321                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 B2FC 1701  14        jnc  !
0002 B2FE B347  18        ab   rone,ra
0003               !:
0004 B300 B360  30        ab   @K3,ra
     B302 00D2     
                   < elite.a99
25322 B304 D80D  30        movb ra,@K3                     ; STA K3            ; K3(1 0) = (Y A) + K3(1 0)
     B306 00D2     
25323                                                                          ; = 222 * roofv_x / z + x-coordinate of planet
25324                                                                          ; centre
25325                                                                          ;
25326                                                                          ; starting with the high bytes
25327               
25328 B308 D34F  18        movb ry,ra                      ; TYA               ; And then doing the low bytes, so now K3(1 0) contains
25329                      .adc @K3+1,ra                   ; ADC K3+1          ; the x-coordinate of the crater offset plus the planet
     **** ****     > ADC
0001 B30A 1701  14        jnc  !
0002 B30C B347  18        ab   rone,ra
0003               !:
0004 B30E B360  30        ab   @K3+1,ra
     B310 00D3     
                   < elite.a99
25330 B312 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; centre to give the x-coordinate of the crater's centre
     B314 00D3     
25331               
25332 B316 0200  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     B318 BAAC     
25333 B31A 06A0  32        bl   @jsr                       ;
     B31C FE1E     
25334                                                                          ;
25335                                                                          ; (Y A P) = 222 * roofv_y / z
25336                                                                          ;
25337                                                                          ; to give the y-coordinate of the crater offset
25338               
25339 B31E D80D  30        movb ra,@P                      ; STA P             ; Calculate:
     B320 001B     
25340 B322 D360  30        movb @K4,ra                     ; LDA K4            ;
     B324 00E0     
25341                      .sec                            ; SEC               ; K4(1 0) = K4(1 0) - (Y A)
     **** ****     > SEC
0001 B326 0A18  18        sla  rmone,1
                   < elite.a99
25342                      .sbc @P,ra                      ; SBC P             ; = 222 * roofv_y / z - y-coordinate of planet
     **** ****     > SBC
0001 B328 1801  14        joc  !
0002 B32A 7347  18        sb   rone,ra
0003               !:
0004 B32C 7360  30        sb   @P,ra
     B32E 001B     
                   < elite.a99
25343 B330 D80D  30        movb ra,@K4                     ; STA K4            ; centre
     B332 00E0     
25344                                                                          ;
25345                                                                          ; starting with the low bytes
25346               
25347 B334 D80F  30        movb ry,@P                      ; STY P             ; And then doing the low bytes, so now K4(1 0) contains
     B336 001B     
25348 B338 D360  30        movb @K4+1,ra                   ; LDA K4+1          ; the y-coordinate of the crater offset plus the planet
     B33A 00E1     
25349                      .sbc @P,ra                      ; SBC P             ; centre to give the y-coordinate of the crater's centre
     **** ****     > SBC
0001 B33C 1801  14        joc  !
0002 B33E 7347  18        sb   rone,ra
0003               !:
0004 B340 7360  30        sb   @P,ra
     B342 001B     
                   < elite.a99
25350 B344 D80D  30        movb ra,@K4+1                   ; STA K4+1
     B346 00E1     
25351               
25352 B348 020E  20        li   rx,>09*256                 ; LDX #9            ; Set X = 9, so the following call to PLS1 operates on
     B34A 0900     
25353                                                                          ; nosev
25354               
25355 B34C 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B34E B3AC     
25356 B350 06A0  32        bl   @jsr                       ;
     B352 FE1E     
25357                                                                          ;
25358                                                                          ; (Y A) = nosev_x / z
25359                                                                          ;
25360                                                                          ; and increment X to point to nosev_y for the next call
25361               
25362 B354 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16 K2) = (Y A) / 2
25363 B356 D80D  30        movb ra,@K2                     ; STA K2
     B358 00AC     
25364 B35A D80F  30        movb ry,@XX16                   ; STY XX16
     B35C 0009     
25365               
25366 B35E 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B360 B3AC     
25367 B362 06A0  32        bl   @jsr                       ;
     B364 FE1E     
25368                                                                          ;
25369                                                                          ; (Y A) = nosev_y / z
25370                                                                          ;
25371                                                                          ; and increment X to point to nosev_z for the next call
25372               
25373 B366 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16+1 K2+1) = (Y A) / 2
25374 B368 D80D  30        movb ra,@K2+1                   ; STA K2+1
     B36A 00AD     
25375 B36C D80F  30        movb ry,@XX16+1                 ; STY XX16+1
     B36E 000A     
25376               
25377 B370 020E  20        li   rx,>15*256                 ; LDX #21           ; Set X = 21, so the following call to PLS1 operates on
     B372 1500     
25378                                                                          ; sidev
25379               
25380 B374 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B376 B3AC     
25381 B378 06A0  32        bl   @jsr                       ;
     B37A FE1E     
25382                                                                          ;
25383                                                                          ; (Y A) = sidev_x / z
25384                                                                          ;
25385                                                                          ; and increment X to point to sidev_y for the next call
25386               
25387 B37C 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16+2 K2+2) = (Y A) / 2
25388 B37E D80D  30        movb ra,@K2+2                   ; STA K2+2
     B380 00AE     
25389 B382 D80F  30        movb ry,@XX16+2                 ; STY XX16+2
     B384 000B     
25390               
25391 B386 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B388 B3AC     
25392 B38A 06A0  32        bl   @jsr                       ;
     B38C FE1E     
25393                                                                          ;
25394                                                                          ; (Y A) = sidev_y / z
25395                                                                          ;
25396                                                                          ; and increment X to point to sidev_z for the next call
25397               
25398 B38E 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16+3 K2+3) = (Y A) / 2
25399 B390 D80D  30        movb ra,@K2+3                   ; STA K2+3
     B392 00AF     
25400 B394 D80F  30        movb ry,@XX16+3                 ; STY XX16+3
     B396 000C     
25401               
25402 B398 020D  20        li   ra,>40*256                 ; LDA #64           ; Set TGT = 64, so we draw a full ellipse in the call to
     B39A 4000     
25403 B39C D80D  30        movb ra,@TGT                    ; STA TGT           ; PLS22 below
     B39E 00A0     
25404               
25405 B3A0 020D  20        li   ra,>00*256                 ; LDA #0            ; Set CNT2 = 0 as we are drawing a full ellipse, so we
     B3A2 0000     
25406 B3A4 D80D  30        movb ra,@CNT2                   ; STA CNT2          ; don't need to apply an offset
     B3A6 00A5     
25407               
25408 B3A8 0460  28        b    @PLS22                     ; JMP PLS22         ; Jump to PLS22 to draw the crater, returning from the
     B3AA B3F2     
25409                                                                          ; subroutine using a tail call
25410               
25411               * ******************************************************************************
25412               *
25413               * Name: PLS1
25414               * Type: Subroutine
25415               * Category: Drawing planets
25416               * Summary: Calculate (Y A) = nosev_x / z
25417               *
25418               * ------------------------------------------------------------------------------
25419               *
25420               * Calculate the following division of a specified value from one of the
25421               * orientation vectors (in this example, nosev_x):
25422               *
25423               * (Y A) = nosev_x / z
25424               *
25425               * where z is the z-coordinate of the planet from INWK. The result is an 8-bit
25426               * magnitude in A, with maximum value 254, and just a sign bit (bit 7) in Y.
25427               *
25428               * ------------------------------------------------------------------------------
25429               *
25430               * Arguments:
25431               *
25432               * X                   Determines which of the INWK orientation vectors to
25433               * divide:
25434               *
25435               * * X = 9, 11, 13: divides nosev_x, nosev_y, nosev_z
25436               *
25437               * * X = 15, 17, 19: divides roofv_x, roofv_y, roofv_z
25438               *
25439               * * X = 21, 23, 25: divides sidev_x, sidev_y, sidev_z
25440               *
25441               * INWK                The planet's ship data block
25442               *
25443               * ------------------------------------------------------------------------------
25444               *
25445               * Returns:
25446               *
25447               * A                   The result as an 8-bit magnitude with maximum value 254
25448               *
25449               * Y                   The sign of the result in bit 7
25450               *
25451               * K+3                 Also the sign of the result in bit 7
25452               *
25453               * X                   X gets incremented by 2 so it points to the next
25454               * coordinate in this orientation vector (so consecutive
25455               * calls to the routine will start with x, then move onto y
25456               * and then z)
25457               *
25458               * ******************************************************************************
25459               
25460               PLS1:
25461 B3AC D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = nosev_x_lo
     B3AE 0053     
25462 B3B0 D80D  30        movb ra,@P                      ; STA P
     B3B2 001B     
25463               
25464 B3B4 D36E  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set P+1 = |nosev_x_hi|
     B3B6 0054     
25465 B3B8 024D  22        andi ra,>7f*256                 ; AND #%01111111
     B3BA 7F00     
25466 B3BC D80D  30        movb ra,@P+1                    ; STA P+1
     B3BE 001C     
25467               
25468 B3C0 D36E  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set A = sign bit of nosev_x_lo
     B3C2 0054     
25469 B3C4 024D  22        andi ra,>80*256                 ; AND #%10000000
     B3C6 8000     
25470               
25471 B3C8 0200  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     B3CA 45E8     
25472 B3CC 06A0  32        bl   @jsr                       ;
     B3CE FE1E     
25473                                                                          ;
25474                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
25475               
25476 B3D0 D360  30        movb @K,ra                      ; LDA K             ; Fetch the lowest byte of the result into A
     B3D2 003D     
25477               
25478 B3D4 D3E0  30        movb @K+1,ry                    ; LDY K+1           ; Fetch the second byte of the result into Y
     B3D6 003E     
25479               
25480 B3D8 1302  14        jeq  B76                        ; BEQ B76           ; If the second byte is 0, skip the next instruction
25481               
25482 B3DA 020D  20        li   ra,>fe*256                 ; LDA #254          ; The second byte is non-zero, so the result won't fit
     B3DC FE00     
25483                                                                          ; into one byte, so set A = 254 as our maximum one-byte
25484                                                                          ; value to return
25485               
25486               B76:
25487 B3DE D3E0  30        movb @K+3,ry                    ; LDY K+3           ; Fetch the sign of the result from K+3 into Y
     B3E0 0040     
25488               
25489 B3E2 B387  18        ab   rone,rx                    ; INX               ; Add 2 to X so the index points to the next coordinate
25490 B3E4 B387  18        ab   rone,rx                    ; INX               ; in this orientation vector (so consecutive calls to
25491                                                                          ; the routine will start with x, then move onto y and z)
25492               
25493 B3E6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B3E8 FE2A     
25494               
25495               * ******************************************************************************
25496               *
25497               * Name: PLS2
25498               * Type: Subroutine
25499               * Category: Drawing planets
25500               * Summary: Draw a half-ellipse
25501               * Deep dive: Drawing ellipses
25502               * Drawing meridians and equators
25503               *
25504               * ------------------------------------------------------------------------------
25505               *
25506               * Draw a half-ellipse, used for the planet's equator and meridian.
25507               *
25508               * ******************************************************************************
25509               
25510               PLS2:
25511 B3EA 020D  20        li   ra,>1f*256                 ; LDA #31           ; Set TGT = 31, so we only draw half an ellipse
     B3EC 1F00     
25512 B3EE D80D  30        movb ra,@TGT                    ; STA TGT
     B3F0 00A0     
25513               
25514                                                                          ; Fall through into PLS22 to draw the half-ellipse
25515               
25516               * ******************************************************************************
25517               *
25518               * Name: PLS22
25519               * Type: Subroutine
25520               * Category: Drawing planets
25521               * Summary: Draw an ellipse or half-ellipse
25522               * Deep dive: Drawing ellipses
25523               * Drawing meridians and equators
25524               * Drawing craters
25525               *
25526               * ------------------------------------------------------------------------------
25527               *
25528               * Draw an ellipse or half-ellipse, to be used for the planet's equator and
25529               * meridian (in which case we draw half an ellipse), or crater (in which case we
25530               * draw a full ellipse).
25531               *
25532               * The ellipse is defined by a centre point, plus two conjugate radius vectors,
25533               * u and v, where:
25534               *
25535               * u = [ u_x ]       v = [ v_x ]
25536               * [ u_y ]           [ v_y ]
25537               *
25538               * The individual components of these 2D vectors (i.e. u_x, u_y etc.) are 16-bit
25539               * sign-magnitude numbers, where the high bytes contain only the sign bit (in
25540               * bit 7), with bits 0 to 6 being clear. This means that as we store u_x as
25541               * (XX16 K2), for example, we know that |u_x| = K2.
25542               *
25543               * This routine calls BLINE to draw each line segment in the ellipse, passing the
25544               * coordinates as follows:
25545               *
25546               * K6(1 0) = K3(1 0) + u_x * cos(CNT2) + v_x * sin(CNT2)
25547               *
25548               * K6(3 2) = K4(1 0) - u_y * cos(CNT2) - v_y * sin(CNT2)
25549               *
25550               * The y-coordinates are negated because BLINE expects pixel coordinates but the
25551               * u and v vectors are extracted from the orientation vector. The y-axis runs
25552               * in the opposite direction in 3D space to that on the screen, so we need to
25553               * negate the 3D space coordinates before we can combine them with the ellipse's
25554               * centre coordinates.
25555               *
25556               * ------------------------------------------------------------------------------
25557               *
25558               * Arguments:
25559               *
25560               * K(1 0)              The planet's radius
25561               *
25562               * K3(1 0)             The pixel x-coordinate of the centre of the ellipse
25563               *
25564               * K4(1 0)             The pixel y-coordinate of the centre of the ellipse
25565               *
25566               * (XX16 K2)           The x-component of u (i.e. u_x), where XX16 contains
25567               * just the sign of the sign-magnitude number
25568               *
25569               * (XX16+1 K2+1)       The y-component of u (i.e. u_y), where XX16+1 contains
25570               * just the sign of the sign-magnitude number
25571               *
25572               * (XX16+2 K2+2)       The x-component of v (i.e. v_x), where XX16+2 contains
25573               * just the sign of the sign-magnitude number
25574               *
25575               * (XX16+3 K2+3)       The y-component of v (i.e. v_y), where XX16+3 contains
25576               * just the sign of the sign-magnitude number
25577               *
25578               * TGT                 The number of segments to draw:
25579               *
25580               * * 32 for a half ellipse (a meridian)
25581               *
25582               * * 64 for a full ellipse (a crater)
25583               *
25584               * CNT2                The starting segment for drawing the half-ellipse
25585               *
25586               * ******************************************************************************
25587               
25588               PLS22:
25589 B3F2 020E  20        li   rx,>00*256                 ; LDX #0            ; Set CNT = 0
     B3F4 0000     
25590 B3F6 D80E  30        movb rx,@CNT                    ; STX CNT
     B3F8 00A4     
25591               
25592 B3FA 7387  18        sb   rone,rx                    ; DEX               ; Set FLAG = &FF to start a new line in the ball line
25593 B3FC D80E  30        movb rx,@FLAG                   ; STX FLAG          ; heap when calling BLIN below, so the crater or
     B3FE 00A3     
25594                                                                          ; meridian is separate from any previous ellipses
25595               
25596               PLL4:
25597 B400 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = CNT2 mod 32
     B402 00A5     
25598 B404 024D  22        andi ra,>1f*256                 ; AND #31           ;
     B406 1F00     
25599 B408 D38D  18        movb ra,rx                      ; TAX               ; So X is the starting segment, reduced to the range 0
25600                                                                          ; to 32, so as there are 64 segments in the circle, this
25601                                                                          ; reduces the starting angle to 0 to 180 degrees, so we
25602                                                                          ; can use X as an index into the sine table (which only
25603                                                                          ; contains values for segments 0 to 31)
25604                                                                          ;
25605                                                                          ; Also, because CNT2 mod 32 is in the range 0 to 180
25606                                                                          ; degrees, we know that sin(CNT2 mod 32) is always
25607                                                                          ; positive, or to put it another way:
25608                                                                          ;
25609                                                                          ; sin(CNT2 mod 32) = |sin(CNT2)|
25610               
25611 B40A D36E  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     B40C 4112     
25612 B40E D80D  30        movb ra,@Q                      ; STA Q             ; = sin(CNT2 mod 32)
     B410 0090     
25613                                                                          ; = |sin(CNT2)|
25614               
25615 B412 D360  30        movb @K2+2,ra                   ; LDA K2+2          ; Set A = K2+2
     B414 00AE     
25616                                                                          ; = |v_x|
25617               
25618 B416 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     B418 4338     
25619 B41A 06A0  32        bl   @jsr                       ;
     B41C FE1E     
25620 B41E D80D  30        movb ra,@R                      ; STA R             ; = |v_x| * |sin(CNT2)|
     B420 0091     
25621               
25622 B422 D360  30        movb @K2+3,ra                   ; LDA K2+3          ; Set A = K2+3
     B424 00AF     
25623                                                                          ; = |v_y|
25624               
25625 B426 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K = A * Q / 256
     B428 4338     
25626 B42A 06A0  32        bl   @jsr                       ;
     B42C FE1E     
25627 B42E D80D  30        movb ra,@K                      ; STA K             ; = |v_y| * |sin(CNT2)|
     B430 003D     
25628               
25629 B432 D3A0  30        movb @CNT2,rx                   ; LDX CNT2          ; If CNT2 >= 33 then this sets the C flag, otherwise
     B434 00A5     
25630 B436 028E  22        ci   rx,>21*256                 ; CPX #33           ; it's clear, so this means that:
     B438 2100     
25631                                                                          ;
25632                                                                          ; * C is clear if the segment starts in the first half
25633                                                                          ; of the circle, 0 to 180 degrees
25634                                                                          ;
25635                                                                          ; * C is set if the segment starts in the second half
25636                                                                          ; of the circle, 180 to 360 degrees
25637                                                                          ;
25638                                                                          ; In other words, the C flag contains the sign bit for
25639                                                                          ; sin(CNT2), which is positive for 0 to 180 degrees
25640                                                                          ; and negative for 180 to 360 degrees
25641               
25642 B43A 020D  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+5, so
     B43C 0000     
25643 B43E 06A0  32        bl   @rora                      ; ROR A             ; XX16+5 has the correct sign for sin(CNT2)
     B440 FE58     
25644 B442 D80D  30        movb ra,@XX16+5                 ; STA XX16+5        ;
     B444 000E     
25645                                                                          ; Because we set the following above:
25646                                                                          ;
25647                                                                          ; K = |v_y| * |sin(CNT2)|
25648                                                                          ; R = |v_x| * |sin(CNT2)|
25649                                                                          ;
25650                                                                          ; we can add XX16+5 as the high byte to give us the
25651                                                                          ; following:
25652                                                                          ;
25653                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
25654                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
25655               
25656 B446 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = (CNT2 + 16) mod 32
     B448 00A5     
25657                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 B44A 0A16  18        sla  rzero,1
                   < elite.a99
25658                      .adi (>10*256)                  ; ADC #16           ; So we can use X as a lookup index into the SNE table
     **** ****     > ADI
0001 B44C 1701  14        jnc  !
0002 B44E B347  18        ab   rone,ra
0003               !:
0004 B450 022D  22        ai   ra,(>10*256)
     B452 1000     
                   < elite.a99
25659 B454 024D  22        andi ra,>1f*256                 ; AND #31           ; to get the cosine (as there are 16 segments in a
     B456 1F00     
25660 B458 D38D  18        movb ra,rx                      ; TAX               ; quarter-circle)
25661                                                                          ;
25662                                                                          ; Also, because the sine table only contains positive
25663                                                                          ; values, we know that sin((CNT2 + 16) mod 32) will
25664                                                                          ; always be positive, or to put it another way:
25665                                                                          ;
25666                                                                          ; sin((CNT2 + 16) mod 32) = |cos(CNT2)|
25667               
25668 B45A D36E  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     B45C 4112     
25669 B45E D80D  30        movb ra,@Q                      ; STA Q             ; = sin((CNT2 + 16) mod 32)
     B460 0090     
25670                                                                          ; = |cos(CNT2)|
25671               
25672 B462 D360  30        movb @K2+1,ra                   ; LDA K2+1          ; Set A = K2+1
     B464 00AD     
25673                                                                          ; = |u_y|
25674               
25675 B466 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K+2 = A * Q / 256
     B468 4338     
25676 B46A 06A0  32        bl   @jsr                       ;
     B46C FE1E     
25677 B46E D80D  30        movb ra,@K+2                    ; STA K+2           ; = |u_y| * |cos(CNT2)|
     B470 003F     
25678               
25679 B472 D360  30        movb @K2,ra                     ; LDA K2            ; Set A = K2
     B474 00AC     
25680                                                                          ; = |u_x|
25681               
25682 B476 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set P = A * Q / 256
     B478 4338     
25683 B47A 06A0  32        bl   @jsr                       ;
     B47C FE1E     
25684 B47E D80D  30        movb ra,@P                      ; STA P             ; = |u_x| * |cos(CNT2)|
     B480 001B     
25685                                                                          ;
25686                                                                          ; The call to FMLTU also sets the C flag, so in the
25687                                                                          ; following, ADC #15 adds 16 rather than 15
25688               
25689 B482 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; If (CNT2 + 16) mod 64 >= 33 then this sets the C flag,
     B484 00A5     
25690                      .adi (>0f*256)                  ; ADC #15           ; otherwise it's clear, so this means that:
     **** ****     > ADI
0001 B486 1701  14        jnc  !
0002 B488 B347  18        ab   rone,ra
0003               !:
0004 B48A 022D  22        ai   ra,(>0F*256)
     B48C 0F00     
                   < elite.a99
25691 B48E 024D  22        andi ra,>3f*256                 ; AND #63           ;
     B490 3F00     
25692 B492 028D  22        ci   ra,>21*256                 ; CMP #33           ; * C is clear if the segment starts in the first or
     B494 2100     
25693                                                                          ; last quarter of the circle, 0 to 90 degrees or 270
25694                                                                          ; to 360 degrees
25695                                                                          ;
25696                                                                          ; * C is set if the segment starts in the second or
25697                                                                          ; third quarter of the circle, 90 to 270 degrees
25698                                                                          ;
25699                                                                          ; In other words, the C flag contains the sign bit for
25700                                                                          ; cos(CNT2), which is positive for 0 to 90 degrees or
25701                                                                          ; 270 to 360 degrees, and negative for 90 to 270 degrees
25702               
25703 B496 020D  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+4, so:
     B498 0000     
25704 B49A 06A0  32        bl   @rora                      ; ROR A             ; XX16+4 has the correct sign for cos(CNT2)
     B49C FE58     
25705 B49E D80D  30        movb ra,@XX16+4                 ; STA XX16+4        ;
     B4A0 000D     
25706                                                                          ; Because we set the following above:
25707                                                                          ;
25708                                                                          ; K+2 = |u_y| * |cos(CNT2)|
25709                                                                          ; P   = |u_x| * |cos(CNT2)|
25710                                                                          ;
25711                                                                          ; we can add XX16+4 as the high byte to give us the
25712                                                                          ; following:
25713                                                                          ;
25714                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
25715                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
25716               
25717 B4A2 D360  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+2 * XX16+5
     B4A4 000E     
25718                      .eor @XX16+2                    ; EOR XX16+2        ; = the sign of v_x * XX16+5
     **** ****     > EOR
0001 B4A6 D020  30        movb @XX16+2,rtmp
     B4A8 000B     
0002 B4AA 2B40  18        xor  rtmp,ra
                   < elite.a99
25719 B4AC D80D  30        movb ra,@S                      ; STA S             ;
     B4AE 0092     
25720                                                                          ; So because we set this above:
25721                                                                          ;
25722                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
25723                                                                          ;
25724                                                                          ; we now have this:
25725                                                                          ;
25726                                                                          ; (S R) = v_x * sin(CNT2)
25727               
25728 B4B0 D360  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16 * XX16+4
     B4B2 000D     
25729                      .eor @XX16                      ; EOR XX16          ; = the sign of u_x * XX16+4
     **** ****     > EOR
0001 B4B4 D020  30        movb @XX16,rtmp
     B4B6 0009     
0002 B4B8 2B40  18        xor  rtmp,ra
                   < elite.a99
25730                                                                          ;
25731                                                                          ; So because we set this above:
25732                                                                          ;
25733                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
25734                                                                          ;
25735                                                                          ; we now have this:
25736                                                                          ;
25737                                                                          ; (A P) = u_x * cos(CNT2)
25738               
25739 B4BA 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     B4BC 44BA     
25740 B4BE 06A0  32        bl   @jsr                       ;
     B4C0 FE1E     
25741                                                                          ; = u_x * cos(CNT2) + v_x * sin(CNT2)
25742               
25743 B4C2 D80D  30        movb ra,@T                      ; STA T             ; Store the high byte in T, so the result is now:
     B4C4 00D1     
25744                                                                          ;
25745                                                                          ; (T X) = u_x * cos(CNT2) + v_x * sin(CNT2)
25746               
25747 B4C6 1515  14        jgt  PL42                       ; BPL PL42          ; If the result is positive, jump down to PL42
25748               
25749 B4C8 D34E  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
25750                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 B4CA 0200  20        li   rtmp,(>FF*256)
     B4CC FF00     
0002 B4CE 2B40  18        xor  rtmp,ra
                   < elite.a99
25751                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 B4D0 0A16  18        sla  rzero,1
                   < elite.a99
25752                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 B4D2 1701  14        jnc  !
0002 B4D4 B347  18        ab   rone,ra
0003               !:
0004 B4D6 022D  22        ai   ra,(>01*256)
     B4D8 0100     
                   < elite.a99
25753 B4DA D38D  18        movb ra,rx                      ; TAX
25754               
25755 B4DC D360  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     B4DE 00D1     
25756                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 B4E0 0200  20        li   rtmp,(>7F*256)
     B4E2 7F00     
0002 B4E4 2B40  18        xor  rtmp,ra
                   < elite.a99
25757                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B4E6 1701  14        jnc  !
0002 B4E8 B347  18        ab   rone,ra
0003               !:
0004 B4EA 022D  22        ai   ra,(>00*256)
     B4EC 0000     
                   < elite.a99
25758 B4EE D80D  30        movb ra,@T                      ; STA T
     B4F0 00D1     
25759               
25760               PL42:
25761 B4F2 D34E  18        movb rx,ra                      ; TXA               ; Set K6(1 0) = K3(1 0) + (T X)
25762                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 B4F4 1701  14        jnc  !
0002 B4F6 B347  18        ab   rone,ra
0003               !:
0004 B4F8 B360  30        ab   @K3,ra
     B4FA 00D2     
                   < elite.a99
25763 B4FC D80D  30        movb ra,@K6                     ; STA K6            ; starting with the low bytes
     B4FE 0082     
25764               
25765 B500 D360  30        movb @T,ra                      ; LDA T             ; And then doing the high bytes, so we now get:
     B502 00D1     
25766                      .adc @K3+1,ra                   ; ADC K3+1          ;
     **** ****     > ADC
0001 B504 1701  14        jnc  !
0002 B506 B347  18        ab   rone,ra
0003               !:
0004 B508 B360  30        ab   @K3+1,ra
     B50A 00D3     
                   < elite.a99
25767 B50C D80D  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K3(1 0) + (T X)
     B50E 0083     
25768                                                                          ; = K3(1 0) + u_x * cos(CNT2)
25769                                                                          ; + v_x * sin(CNT2)
25770                                                                          ;
25771                                                                          ; K3(1 0) is the x-coordinate of the centre of the
25772                                                                          ; ellipse, so we now have the correct x-coordinate for
25773                                                                          ; our ellipse segment that we can pass to BLINE below
25774               
25775 B510 D360  30        movb @K,ra                      ; LDA K             ; Set R = K = |v_y| * sin(CNT2)
     B512 003D     
25776 B514 D80D  30        movb ra,@R                      ; STA R
     B516 0091     
25777               
25778 B518 D360  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+3 * XX16+5
     B51A 000E     
25779                      .eor @XX16+3                    ; EOR XX16+3        ; = the sign of v_y * XX16+5
     **** ****     > EOR
0001 B51C D020  30        movb @XX16+3,rtmp
     B51E 000C     
0002 B520 2B40  18        xor  rtmp,ra
                   < elite.a99
25780 B522 D80D  30        movb ra,@S                      ; STA S             ;
     B524 0092     
25781                                                                          ; So because we set this above:
25782                                                                          ;
25783                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
25784                                                                          ;
25785                                                                          ; and we just set R = K, we now have this:
25786                                                                          ;
25787                                                                          ; (S R) = v_y * sin(CNT2)
25788               
25789 B526 D360  30        movb @K+2,ra                    ; LDA K+2           ; Set P = K+2 = |u_y| * cos(CNT2)
     B528 003F     
25790 B52A D80D  30        movb ra,@P                      ; STA P
     B52C 001B     
25791               
25792 B52E D360  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16+1 * XX16+4
     B530 000D     
25793                      .eor @XX16+1                    ; EOR XX16+1        ; = the sign of u_y * XX16+4
     **** ****     > EOR
0001 B532 D020  30        movb @XX16+1,rtmp
     B534 000A     
0002 B536 2B40  18        xor  rtmp,ra
                   < elite.a99
25794                                                                          ;
25795                                                                          ; So because we set this above:
25796                                                                          ;
25797                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
25798                                                                          ;
25799                                                                          ; and we just set P = K+2, we now have this:
25800                                                                          ;
25801                                                                          ; (A P) = u_y * cos(CNT2)
25802               
25803 B538 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     B53A 44BA     
25804 B53C 06A0  32        bl   @jsr                       ;
     B53E FE1E     
25805                                                                          ; =  u_y * cos(CNT2) + v_y * sin(CNT2)
25806               
25807                      .eoi (>80*256)                  ; EOR #%10000000    ; Store the negated high byte in T, so the result is
     **** ****     > EOI
0001 B540 0200  20        li   rtmp,(>80*256)
     B542 8000     
0002 B544 2B40  18        xor  rtmp,ra
                   < elite.a99
25808 B546 D80D  30        movb ra,@T                      ; STA T             ; now:
     B548 00D1     
25809                                                                          ;
25810                                                                          ; (T X) = - u_y * cos(CNT2) - v_y * sin(CNT2)
25811                                                                          ;
25812                                                                          ; This negation is necessary because BLINE expects us
25813                                                                          ; to pass pixel coordinates, where y-coordinates get
25814                                                                          ; larger as we go down the screen; u_y and v_y, on the
25815                                                                          ; other hand, are extracted from the orientation
25816                                                                          ; vectors, where y-coordinates get larger as we go up
25817                                                                          ; in space, so to rectify this we need to negate the
25818                                                                          ; result in (T X) before we can add it to the
25819                                                                          ; y-coordinate of the ellipse's centre in BLINE
25820               
25821 B54A 1515  14        jgt  PL43                       ; BPL PL43          ; If the result is positive, jump down to PL43
25822               
25823 B54C D34E  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
25824                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 B54E 0200  20        li   rtmp,(>FF*256)
     B550 FF00     
0002 B552 2B40  18        xor  rtmp,ra
                   < elite.a99
25825                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 B554 0A16  18        sla  rzero,1
                   < elite.a99
25826                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 B556 1701  14        jnc  !
0002 B558 B347  18        ab   rone,ra
0003               !:
0004 B55A 022D  22        ai   ra,(>01*256)
     B55C 0100     
                   < elite.a99
25827 B55E D38D  18        movb ra,rx                      ; TAX
25828               
25829 B560 D360  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     B562 00D1     
25830                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 B564 0200  20        li   rtmp,(>7F*256)
     B566 7F00     
0002 B568 2B40  18        xor  rtmp,ra
                   < elite.a99
25831                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B56A 1701  14        jnc  !
0002 B56C B347  18        ab   rone,ra
0003               !:
0004 B56E 022D  22        ai   ra,(>00*256)
     B570 0000     
                   < elite.a99
25832 B572 D80D  30        movb ra,@T                      ; STA T
     B574 00D1     
25833               
25834               PL43:
25835                                                                          ; We now call BLINE to draw the ellipse line segment
25836                                                                          ;
25837                                                                          ; The first few instructions of BLINE do the following:
25838                                                                          ;
25839                                                                          ; K6(3 2) = K4(1 0) + (T X)
25840                                                                          ;
25841                                                                          ; which gives:
25842                                                                          ;
25843                                                                          ; K6(3 2) = K4(1 0) - u_y * cos(CNT2)
25844                                                                          ; - v_y * sin(CNT2)
25845                                                                          ;
25846                                                                          ; K4(1 0) is the pixel y-coordinate of the centre of the
25847                                                                          ; ellipse, so this gives us the correct y-coordinate for
25848                                                                          ; our ellipse segment (we already calculated the
25849                                                                          ; x-coordinate in K3(1 0) above)
25850 B576 0200  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also returns
     B578 283E     
25851 B57A 06A0  32        bl   @jsr                       ;
     B57C FE1E     
25852                                                                          ; the updated value of CNT in A
25853               
25854 B57E 9360  30        cb   @TGT,ra                    ; CMP TGT           ; If CNT > TGT then jump to PL40 to stop drawing the
     B580 00A0     
25855 B582 1301  14        jeq  B77                        ; BEQ B77           ; ellipse (which is how we draw half-ellipses)
25856 B584 180D  14        joc  PL40                       ; BCS PL40
25857               
25858               B77:
25859 B586 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; Set CNT2 = (CNT2 + STP) mod 64
     B588 00A5     
25860                      .clc                            ; CLC
     **** ****     > CLC
0001 B58A 0A16  18        sla  rzero,1
                   < elite.a99
25861                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 B58C 1701  14        jnc  !
0002 B58E B347  18        ab   rone,ra
0003               !:
0004 B590 B360  30        ab   @STP,ra
     B592 00A6     
                   < elite.a99
25862 B594 024D  22        andi ra,>3f*256                 ; AND #63
     B596 3F00     
25863 B598 D80D  30        movb ra,@CNT2                   ; STA CNT2
     B59A 00A5     
25864               
25865 B59C 0460  28        b    @PLL4                      ; JMP PLL4          ; Jump back to PLL4 to draw the next segment
     B59E B400     
25866               
25867               PL40:
25868 B5A0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B5A2 FE2A     
25869               
25870               * ******************************************************************************
25871               *
25872               * Name: SUN (Part 1 of 4)
25873               * Type: Subroutine
25874               * Category: Drawing suns
25875               * Summary: Draw the sun: Set up all the variables needed to draw the sun
25876               * Deep dive: Drawing the sun
25877               *
25878               * ------------------------------------------------------------------------------
25879               *
25880               * Draw a new sun with radius K at pixel coordinate (K3, K4), removing the old
25881               * sun if there is one. This routine is used to draw the sun, as well as the
25882               * star systems on the Short-range Chart.
25883               *
25884               * The first part sets up all the variables needed to draw the new sun.
25885               *
25886               * ------------------------------------------------------------------------------
25887               *
25888               * Arguments:
25889               *
25890               * K                   The new sun's radius
25891               *
25892               * K3(1 0)             Pixel x-coordinate of the centre of the new sun
25893               *
25894               * K4(1 0)             Pixel y-coordinate of the centre of the new sun
25895               *
25896               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the old
25897               * sun (the one currently on-screen)
25898               *
25899               * ******************************************************************************
25900               
25901 B5A4 0460  28        b    @WPLS                      ; JMP WPLS          ; Jump to WPLS to remove the old sun from the screen. We
     B5A6 B97C     
25902                                                                          ; only get here via the BCS just after the SUN entry
25903                                                                          ; point below, when there is no new sun to draw
25904               
25905               PLF3:
25906                                                                          ; This is called from below to negate X and set A to
25907                                                                          ; &FF, for when the new sun's centre is off the bottom
25908                                                                          ; of the screen (so we don't need to draw its bottom
25909                                                                          ; half)
25910                                                                          ;
25911                                                                          ; This happens when the y-coordinate of the centre of
25912                                                                          ; the sun is bigger than the y-coordinate of the bottom
25913                                                                          ; of the space view
25914 B5A8 D34E  18        movb rx,ra                      ; TXA               ; Negate X using two's complement, so X = ~X + 1
25915                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 B5AA 0200  20        li   rtmp,(>FF*256)
     B5AC FF00     
0002 B5AE 2B40  18        xor  rtmp,ra
                   < elite.a99
25916                      .clc                            ; CLC
     **** ****     > CLC
0001 B5B0 0A16  18        sla  rzero,1
                   < elite.a99
25917                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 B5B2 1701  14        jnc  !
0002 B5B4 B347  18        ab   rone,ra
0003               !:
0004 B5B6 022D  22        ai   ra,(>01*256)
     B5B8 0100     
                   < elite.a99
25918 B5BA D38D  18        movb ra,rx                      ; TAX
25919               
25920               PLF17:
25921                                                                          ; This is called from below to set A to &FF, for when
25922                                                                          ; the new sun's centre is right on the bottom of the
25923                                                                          ; screen (so we don't need to draw its bottom half)
25924 B5BC 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A = &FF
     B5BE FF00     
25925               
25926 B5C0 0460  28        b    @PLF5                      ; JMP PLF5          ; Jump to PLF5
     B5C2 B64C     
25927               
25928               SUN:
25929 B5C4 020D  20        li   ra,>01*256                 ; LDA #1            ; Set LSX = 1 to indicate the sun line heap is about to
     B5C6 0100     
25930 B5C8 D80D  30        movb ra,@LSX                    ; STA LSX           ; be filled up
     B5CA 0D66     
25931               
25932 B5CC 0200  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether any part of the new sun's
     B5CE BA20     
25933 B5D0 06A0  32        bl   @jsr                       ;
     B5D2 FE1E     
25934                                                                          ; circle appears on-screen, and if it does, set P(2 1)
25935                                                                          ; to the maximum y-coordinate of the new sun on-screen
25936               
25937 B5D4 18E7  14        joc  PLF3-3                     ; BCS PLF3-3        ; If CHKON set the C flag then the new sun's circle does
25938                                                                          ; not appear on-screen, so jump to WPLS (via the JMP at
25939                                                                          ; the top of this routine) to remove the sun from the
25940                                                                          ; screen, returning from the subroutine using a tail
25941                                                                          ; call
25942               
25943 B5D6 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     B5D8 0000     
25944               
25945 B5DA D3A0  30        movb @K,rx                      ; LDX K             ; Set X = K = radius of the new sun
     B5DC 003D     
25946               
25947 B5DE 028E  22        ci   rx,>60*256                 ; CPX #96           ; If X >= 96, set the C flag and rotate it into bit 0
     B5E0 6000     
25948 B5E2 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     B5E4 FE34     
25949               
25950 B5E6 028E  22        ci   rx,>28*256                 ; CPX #40           ; If X >= 40, set the C flag and rotate it into bit 0
     B5E8 2800     
25951 B5EA 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     B5EC FE34     
25952               
25953 B5EE 028E  22        ci   rx,>10*256                 ; CPX #16           ; If X >= 16, set the C flag and rotate it into bit 0
     B5F0 1000     
25954 B5F2 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     B5F4 FE34     
25955               
25956                                                                          ; By now, A contains the following:
25957                                                                          ;
25958                                                                          ; * If radius is 96-255 then A = %111 = 7
25959                                                                          ;
25960                                                                          ; * If radius is 40-95  then A = %11  = 3
25961                                                                          ;
25962                                                                          ; * If radius is 16-39  then A = %1   = 1
25963                                                                          ;
25964                                                                          ; * If radius is 0-15   then A = %0   = 0
25965                                                                          ;
25966                                                                          ; The value of A determines the size of the new sun's
25967                                                                          ; ragged fringes - the bigger the sun, the bigger the
25968                                                                          ; fringes
25969               
25970               PLF18:
25971 B5F6 D80D  30        movb ra,@CNT                    ; STA CNT           ; Store the fringe size in CNT
     B5F8 00A4     
25972               
25973                                                                          ; We now calculate the highest pixel y-coordinate of the
25974                                                                          ; new sun, given that P(2 1) contains the 16-bit maximum
25975                                                                          ; y-coordinate of the new sun on-screen
25976               
25977 B5FA 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     B5FC BF00     
25978                                                                          ; view, so this sets Y to the y-coordinate of the bottom
25979                                                                          ; of the space view
25980               
25981 B5FE D3A0  30        movb @P+2,rx                    ; LDX P+2           ; If P+2 is non-zero, the maximum y-coordinate is off
     B600 001D     
25982 B602 1608  14        jne  PLF2                       ; BNE PLF2          ; the bottom of the screen, so skip to PLF2 with A set
25983                                                                          ; to the y-coordinate of the bottom of the space view
25984               
25985 B604 9360  30        cb   @P+1,ra                    ; CMP P+1           ; If A < P+1, the maximum y-coordinate is underneath the
     B606 001C     
25986 B608 1705  14        jnc  PLF2                       ; BCC PLF2          ; dashboard, so skip to PLF2 with A set to the
25987                                                                          ; y-coordinate of the bottom of the space view
25988               
25989 B60A D360  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1, the low byte of the maximum y-coordinate
     B60C 001C     
25990                                                                          ; of the sun on-screen
25991               
25992 B60E 1602  14        jne  PLF2                       ; BNE PLF2          ; If A is non-zero, skip to PLF2 as it contains the
25993                                                                          ; value we are after
25994               
25995 B610 020D  20        li   ra,>01*256                 ; LDA #1            ; Otherwise set A = 1, the top line of the screen
     B612 0100     
25996               
25997               PLF2:
25998 B614 D80D  30        movb ra,@TGT                    ; STA TGT           ; Set TGT to A, the maximum y-coordinate of the sun on
     B616 00A0     
25999                                                                          ; screen
26000               
26001                                                                          ; We now calculate the number of lines we need to draw
26002                                                                          ; and the direction in which we need to draw them, both
26003                                                                          ; from the centre of the new sun
26004               
26005 B618 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set (A X) = y-coordinate of bottom of screen - K4(1 0)
     B61A BF00     
26006                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 B61C 0A18  18        sla  rmone,1
                   < elite.a99
26007                      .sbc @K4,ra                     ; SBC K4            ; Starting with the low bytes
     **** ****     > SBC
0001 B61E 1801  14        joc  !
0002 B620 7347  18        sb   rone,ra
0003               !:
0004 B622 7360  30        sb   @K4,ra
     B624 00E0     
                   < elite.a99
26008 B626 D38D  18        movb ra,rx                      ; TAX
26009               
26010 B628 020D  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so (A X) now contains
     B62A 0000     
26011                      .sbc @K4+1,ra                   ; SBC K4+1          ; the number of lines between the centre of the sun and
     **** ****     > SBC
0001 B62C 1801  14        joc  !
0002 B62E 7347  18        sb   rone,ra
0003               !:
0004 B630 7360  30        sb   @K4+1,ra
     B632 00E1     
                   < elite.a99
26012                                                                          ; the bottom of the screen. If it is positive then the
26013                                                                          ; centre of the sun is above the bottom of the screen,
26014                                                                          ; if it is negative then the centre of the sun is below
26015                                                                          ; the bottom of the screen
26016               
26017 B634 11B9  14        jlt  PLF3                       ; BMI PLF3          ; If A < 0, then this means the new sun's centre is off
26018                                                                          ; the bottom of the screen, so jump up to PLF3 to negate
26019                                                                          ; the height in X (so it becomes positive), set A to &FF
26020                                                                          ; and jump down to PLF5
26021               
26022 B636 1606  14        jne  PLF4                       ; BNE PLF4          ; If A > 0, then the new sun's centre is at least a full
26023                                                                          ; screen above the bottom of the space view, so jump
26024                                                                          ; down to PLF4 to set X = radius and A = 0
26025               
26026 B638 B387  18        ab   rone,rx                    ; INX               ; Set the flags depending on the value of X
26027 B63A 7387  18        sb   rone,rx                    ; DEX
26028               
26029 B63C 13BF  14        jeq  PLF17                      ; BEQ PLF17         ; If X = 0 (we already know A = 0 by this point) then
26030                                                                          ; jump up to PLF17 to set A to &FF before jumping down
26031                                                                          ; to PLF5
26032               
26033 B63E 93A0  30        cb   @K,rx                      ; CPX K             ; If X < the radius in K, jump down to PLF5, so if
     B640 003D     
26034 B642 1704  14        jnc  PLF5                       ; BCC PLF5          ; X >= the radius in K, we set X = radius and A = 0
26035               
26036               PLF4:
26037 B644 D3A0  30        movb @K,rx                      ; LDX K             ; Set X to the radius
     B646 003D     
26038               
26039 B648 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     B64A 0000     
26040               
26041               PLF5:
26042 B64C D80E  30        movb rx,@V                      ; STX V             ; Store the height in V
     B64E 0022     
26043               
26044 B650 D80D  30        movb ra,@V+1                    ; STA V+1           ; Store the direction in V+1
     B652 0023     
26045               
26046 B654 D360  30        movb @K,ra                      ; LDA K             ; Set (A P) = K * K
     B656 003D     
26047 B658 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2
     B65A 42BA     
26048 B65C 06A0  32        bl   @jsr                       ;
     B65E FE1E     
26049               
26050 B660 D80D  30        movb ra,@K2+1                   ; STA K2+1          ; Set K2(1 0) = (A P) = K * K
     B662 00AD     
26051 B664 D360  30        movb @P,ra                      ; LDA P
     B666 001B     
26052 B668 D80D  30        movb ra,@K2                     ; STA K2
     B66A 00AC     
26053               
26054                                                                          ; By the time we get here, the variables should be set
26055                                                                          ; up as shown in the header for part 3 below
26056               
26057               * ******************************************************************************
26058               *
26059               * Name: SUN (Part 2 of 4)
26060               * Type: Subroutine
26061               * Category: Drawing suns
26062               * Summary: Draw the sun: Start from the bottom of the screen and erase the
26063               * old sun line by line
26064               * Deep dive: Drawing the sun
26065               *
26066               * ------------------------------------------------------------------------------
26067               *
26068               * This part erases the old sun, starting at the bottom of the screen and working
26069               * upwards until we reach the bottom of the new sun.
26070               *
26071               * ******************************************************************************
26072               
26073 B66C 020F  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; Set Y = y-coordinate of the bottom of the screen,
     B66E BF00     
26074                                                                          ; which we use as a counter in the following routine to
26075                                                                          ; redraw the old sun
26076               
26077 B670 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B672 0028     
26078 B674 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     B676 0026     
26079 B678 D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     B67A 0029     
26080 B67C D80D  30        movb ra,@YY+1                   ; STA YY+1
     B67E 0027     
26081               
26082               PLFL2:
26083 B680 93E0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y = TGT, we have reached the line where we will
     B682 00A0     
26084 B684 1309  14        jeq  PLFL                       ; BEQ PLFL          ; start drawing the new sun, so there is no need to
26085                                                                          ; keep erasing the old one, so jump down to PLFL
26086               
26087 B686 D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     B688 0D66     
26088                                                                          ; gives us the half-width of the old sun's line on this
26089                                                                          ; line of the screen
26090               
26091 B68A 1304  14        jeq  PLF13                      ; BEQ PLF13         ; If A = 0, skip the following call to HLOIN2 as there
26092                                                                          ; is no sun line on this line of the screen
26093               
26094 B68C 0200  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     B68E 25DA     
26095 B690 06A0  32        bl   @jsr                       ;
     B692 FE1E     
26096                                                                          ; with centre point YY(1 0) and half-width A, and remove
26097                                                                          ; the line from the sun line heap once done
26098               
26099               PLF13:
26100 B694 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
26101               
26102 B696 16F4  14        jne  PLFL2                      ; BNE PLFL2         ; Loop back for the next line in the line heap until
26103                                                                          ; we have either gone through the entire heap, or
26104                                                                          ; reached the bottom row of the new sun
26105               
26106               * ******************************************************************************
26107               *
26108               * Name: SUN (Part 3 of 4)
26109               * Type: Subroutine
26110               * Category: Drawing suns
26111               * Summary: Draw the sun: Continue to move up the screen, drawing the new sun
26112               * line by line
26113               * Deep dive: Drawing the sun
26114               *
26115               * ------------------------------------------------------------------------------
26116               *
26117               * This part draws the new sun. By the time we get to this point, the following
26118               * variables should have been set up by parts 1 and 2:
26119               *
26120               * ------------------------------------------------------------------------------
26121               *
26122               * Arguments:
26123               *
26124               * V                   As we draw lines for the new sun, V contains the
26125               * vertical distance between the line we're drawing and the
26126               * centre of the new sun. As we draw lines and move up the
26127               * screen, we either decrement (bottom half) or increment
26128               * (top half) this value. See the deep dive on "Drawing the
26129               * sun" to see a diagram that shows V in action
26130               *
26131               * V+1                 This determines which half of the new sun we are drawing
26132               * as we work our way up the screen, line by line:
26133               *
26134               * * 0 means we are drawing the bottom half, so the lines
26135               * get wider as we work our way up towards the centre,
26136               * at which point we will move into the top half, and
26137               * V+1 will switch to &FF
26138               *
26139               * * &FF means we are drawing the top half, so the lines
26140               * get smaller as we work our way up, away from the
26141               * centre
26142               *
26143               * TGT                 The maximum y-coordinate of the new sun on-screen (i.e.
26144               * the screen y-coordinate of the bottom row of the new
26145               * sun)
26146               *
26147               * CNT                 The fringe size of the new sun
26148               *
26149               * K2(1 0)             The new sun's radius squared, i.e. K^2
26150               *
26151               * Y                   The y-coordinate of the bottom row of the new sun
26152               *
26153               * ******************************************************************************
26154               
26155               PLFL:
26156 B698 D360  30        movb @V,ra                      ; LDA V             ; Set (T P) = V * V
     B69A 0022     
26157 B69C 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; = V^2
     B69E 42BA     
26158 B6A0 06A0  32        bl   @jsr                       ;
     B6A2 FE1E     
26159 B6A4 D80D  30        movb ra,@T                      ; STA T
     B6A6 00D1     
26160               
26161 B6A8 D360  30        movb @K2,ra                     ; LDA K2            ; Set (R Q) = K^2 - V^2
     B6AA 00AC     
26162                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 B6AC 0A18  18        sla  rmone,1
                   < elite.a99
26163                      .sbc @P,ra                      ; SBC P             ; First calculating the low bytes
     **** ****     > SBC
0001 B6AE 1801  14        joc  !
0002 B6B0 7347  18        sb   rone,ra
0003               !:
0004 B6B2 7360  30        sb   @P,ra
     B6B4 001B     
                   < elite.a99
26164 B6B6 D80D  30        movb ra,@Q                      ; STA Q
     B6B8 0090     
26165               
26166 B6BA D360  30        movb @K2+1,ra                   ; LDA K2+1          ; And then doing the high bytes
     B6BC 00AD     
26167                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 B6BE 1801  14        joc  !
0002 B6C0 7347  18        sb   rone,ra
0003               !:
0004 B6C2 7360  30        sb   @T,ra
     B6C4 00D1     
                   < elite.a99
26168 B6C6 D80D  30        movb ra,@R                      ; STA R
     B6C8 0091     
26169               
26170 B6CA D80F  30        movb ry,@Y1                     ; STY Y1            ; Store Y in Y1, so we can restore it after the call to
     B6CC 0032     
26171                                                                          ; LL5
26172               
26173 B6CE 0200  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q)
     B6D0 D2B6     
26174 B6D2 06A0  32        bl   @jsr                       ;
     B6D4 FE1E     
26175                                                                          ; = SQRT(K^2 - V^2)
26176                                                                          ;
26177                                                                          ; So Q contains the half-width of the new sun's line at
26178                                                                          ; height V from the sun's centre - in other words, it
26179                                                                          ; contains the half-width of the sun's line on the
26180                                                                          ; current pixel row Y
26181               
26182 B6D6 D3E0  30        movb @Y1,ry                     ; LDY Y1            ; Restore Y from Y1
     B6D8 0032     
26183               
26184 B6DA 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     B6DC C07C     
26185 B6DE 06A0  32        bl   @jsr                       ;
     B6E0 FE1E     
26186               
26187                      .and @CNT                       ; AND CNT           ; Reduce A to a random number in the range 0 to CNT,
     **** ****     > AND
0001 B6E2 D020  30        movb @CNT,rtmp
     B6E4 00A4     
0002 B6E6 0540  14        inv  rtmp
0003 B6E8 5340  18        szcb rtmp,ra
                   < elite.a99
26188                                                                          ; where CNT is the fringe size of the new sun
26189               
26190                      .clc                            ; CLC               ; Set A = A + Q
     **** ****     > CLC
0001 B6EA 0A16  18        sla  rzero,1
                   < elite.a99
26191                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 B6EC 1701  14        jnc  !
0002 B6EE B347  18        ab   rone,ra
0003               !:
0004 B6F0 B360  30        ab   @Q,ra
     B6F2 0090     
                   < elite.a99
26192                                                                          ; So A now contains the half-width of the sun on row
26193                                                                          ; V, plus a random variation based on the fringe size
26194               
26195 B6F4 1702  14        jnc  PLF44                      ; BCC PLF44         ; If the above addition did not overflow, skip the
26196                                                                          ; following instruction
26197               
26198 B6F6 020D  20        li   ra,>ff*256                 ; LDA #255          ; The above overflowed, so set the value of A to 255
     B6F8 FF00     
26199               
26200                                                                          ; So A contains the half-width of the new sun on pixel
26201                                                                          ; line Y, changed by a random amount within the size of
26202                                                                          ; the sun's fringe
26203               
26204               PLF44:
26205 B6FA D3AF  34        movb @LSO(ry),rx                ; LDX LSO,Y         ; Set X to the line heap value for the old sun's line
     B6FC 0D66     
26206                                                                          ; at row Y
26207               
26208 B6FE DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Store the half-width of the new row Y line in the line
     B700 0D66     
26209                                                                          ; heap
26210               
26211 B702 1346  14        jeq  PLF11                      ; BEQ PLF11         ; If X = 0 then there was no sun line on pixel row Y, so
26212                                                                          ; jump to PLF11
26213               
26214 B704 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B706 0028     
26215 B708 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     B70A 0026     
26216 B70C D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     B70E 0029     
26217 B710 D80D  30        movb ra,@YY+1                   ; STA YY+1
     B712 0027     
26218               
26219 B714 D34E  18        movb rx,ra                      ; TXA               ; Transfer the line heap value for the old sun's line
26220                                                                          ; from X into A
26221               
26222 B716 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     B718 B9B2     
26223 B71A 06A0  32        bl   @jsr                       ;
     B71C FE1E     
26224                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26225                                                                          ; the line for the old sun
26226               
26227 B71E D360  30        movb @X1,ra                     ; LDA X1            ; Store X1 and X2, the ends of the line for the old sun,
     B720 0031     
26228 B722 D80D  30        movb ra,@XX                     ; STA XX            ; in XX and XX+1
     B724 0024     
26229 B726 D360  30        movb @X2,ra                     ; LDA X2
     B728 0033     
26230 B72A D80D  30        movb ra,@XX+1                   ; STA XX+1
     B72C 0025     
26231               
26232 B72E D360  30        movb @K3,ra                     ; LDA K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     B730 00D2     
26233 B732 D80D  30        movb ra,@YY                     ; STA YY            ; of the new sun
     B734 0026     
26234 B736 D360  30        movb @K3+1,ra                   ; LDA K3+1
     B738 00D3     
26235 B73A D80D  30        movb ra,@YY+1                   ; STA YY+1
     B73C 0027     
26236               
26237 B73E D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the half-width of the new row Y line from the
     B740 0D66     
26238                                                                          ; line heap (which we stored above)
26239               
26240 B742 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     B744 B9B2     
26241 B746 06A0  32        bl   @jsr                       ;
     B748 FE1E     
26242                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26243                                                                          ; the line for the new sun
26244               
26245 B74A 180C  14        joc  PLF23                      ; BCS PLF23         ; If the C flag is set, the new line doesn't fit on the
26246                                                                          ; screen, so jump to PLF23 to just draw the old line
26247                                                                          ; without drawing the new one
26248               
26249                                                                          ; At this point the old line is from XX to XX+1 and the
26250                                                                          ; new line is from X1 to X2, and both fit on-screen. We
26251                                                                          ; now want to remove the old line and draw the new one.
26252                                                                          ; We could do this by simply drawing the old one then
26253                                                                          ; drawing the new one, but instead Elite does this by
26254                                                                          ; drawing first from X1 to XX and then from X2 to XX+1,
26255                                                                          ; which you can see in action by looking at all the
26256                                                                          ; permutations below of the four points on the line and
26257                                                                          ; imagining what happens if you draw from X1 to XX and
26258                                                                          ; X2 to XX+1 using EOR logic. The six possible
26259                                                                          ; permutations are as follows, along with the result of
26260                                                                          ; drawing X1 to XX and then X2 to XX+1:
26261                                                                          ;
26262                                                                          ; X1    X2    XX____XX+1      ->      +__+  +  +
26263                                                                          ;
26264                                                                          ; X1    XX____X2____XX+1      ->      +__+__+  +
26265                                                                          ;
26266                                                                          ; X1    XX____XX+1  X2        ->      +__+__+__+
26267                                                                          ;
26268                                                                          ; XX____X1____XX+1  X2        ->      +  +__+__+
26269                                                                          ;
26270                                                                          ; XX____XX+1  X1    X2        ->      +  +  +__+
26271                                                                          ;
26272                                                                          ; XX____X1____X2____XX+1      ->      +  +__+  +
26273                                                                          ;
26274                                                                          ; They all end up with a line between X1 and X2, which
26275                                                                          ; is what we want. There's probably a mathematical proof
26276                                                                          ; of why this works somewhere, but the above is probably
26277                                                                          ; easier to follow.
26278                                                                          ;
26279                                                                          ; We can draw from X1 to XX and X2 to XX+1 by swapping
26280                                                                          ; XX and X2 and drawing from X1 to X2, and then drawing
26281                                                                          ; from XX to XX+1, so let's do this now
26282               
26283 B74C D360  30        movb @X2,ra                     ; LDA X2            ; Swap XX and X2
     B74E 0033     
26284 B750 D3A0  30        movb @XX,rx                     ; LDX XX
     B752 0024     
26285 B754 D80E  30        movb rx,@X2                     ; STX X2
     B756 0033     
26286 B758 D80D  30        movb ra,@XX                     ; STA XX
     B75A 0024     
26287               
26288 B75C 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     B75E 25EE     
26289 B760 06A0  32        bl   @jsr                       ;
     B762 FE1E     
26290               
26291               PLF23:
26292                                                                          ; If we jump here from the BCS above when there is no
26293                                                                          ; new line this will just draw the old line
26294 B764 D360  30        movb @XX,ra                     ; LDA XX            ; Set X1 = XX
     B766 0024     
26295 B768 D80D  30        movb ra,@X1                     ; STA X1
     B76A 0031     
26296               
26297 B76C D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X2 = XX+1
     B76E 0025     
26298 B770 D80D  30        movb ra,@X2                     ; STA X2
     B772 0033     
26299               
26300               PLF16:
26301 B774 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     B776 25EE     
26302 B778 06A0  32        bl   @jsr                       ;
     B77A FE1E     
26303               
26304               PLF6:
26305 B77C 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26306                                                                          ; above
26307               
26308 B77E 1334  14        jeq  PLF8                       ; BEQ PLF8          ; If we have reached the top of the screen, jump to PLF8
26309                                                                          ; as we are done drawing (the top line of the screen is
26310                                                                          ; the border, so we don't draw there)
26311               
26312 B780 D360  30        movb @V+1,ra                    ; LDA V+1           ; If V+1 is non-zero then we are doing the top half of
     B782 0023     
26313 B784 1617  14        jne  PLF10                      ; BNE PLF10         ; the new sun, so jump down to PLF10 to increment V and
26314                                                                          ; decrease the width of the line we draw
26315               
26316 B786 7347  18        sb   rone,ra                    ; DEC V             ; Decrement V, the height of the sun that we use to work
26317                                                                          ; out the width, so this makes the line get wider, as we
26318                                                                          ; move up towards the sun's centre
26319               
26320 B788 1687  14        jne  PLFL                       ; BNE PLFL          ; If V is non-zero, jump back up to PLFL to do the next
26321                                                                          ; screen line up
26322               
26323 B78A 7347  18        sb   rone,ra                    ; DEC V+1           ; Otherwise V is 0 and we have reached the centre of the
26324                                                                          ; sun, so decrement V+1 to -1 so we start incrementing V
26325                                                                          ; each time, thus doing the top half of the new sun
26326               
26327               PLFLS:
26328 B78C 0460  28        b    @PLFL                      ; JMP PLFL          ; Jump back up to PLFL to do the next screen line up
     B78E B698     
26329               
26330               PLF11:
26331                                                                          ; If we get here then there is no old sun line on this
26332                                                                          ; line, so we can just draw the new sun's line
26333 B790 D3A0  30        movb @K3,rx                     ; LDX K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     B792 00D2     
26334 B794 D80E  30        movb rx,@YY                     ; STX YY            ; of the new sun's line
     B796 0026     
26335 B798 D3A0  30        movb @K3+1,rx                   ; LDX K3+1
     B79A 00D3     
26336 B79C D80E  30        movb rx,@YY+1                   ; STX YY+1
     B79E 0027     
26337               
26338 B7A0 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     B7A2 B9B2     
26339 B7A4 06A0  32        bl   @jsr                       ;
     B7A6 FE1E     
26340                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26341                                                                          ; the line for the new sun
26342               
26343 B7A8 17E5  14        jnc  PLF16                      ; BCC PLF16         ; If the line is on-screen, jump up to PLF16 to draw the
26344                                                                          ; line and loop round for the next line up
26345               
26346 B7AA 020D  20        li   ra,>00*256                 ; LDA #0            ; The line is not on-screen, so set the line heap for
     B7AC 0000     
26347 B7AE DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; line Y to 0, which means there is no sun line here
     B7B0 0D66     
26348               
26349 B7B2 13E4  14        jeq  PLF6                       ; BEQ PLF6          ; Jump up to PLF6 to loop round for the next line up
26350                                                                          ; (this BEQ is effectively a JMP as A is always zero)
26351               
26352               PLF10:
26353 B7B4 D3A0  30        movb @V,rx                      ; LDX V             ; Increment V, the height of the sun that we use to work
     B7B6 0022     
26354 B7B8 B387  18        ab   rone,rx                    ; INX               ; out the width, so this makes the line get narrower, as
26355 B7BA D80E  30        movb rx,@V                      ; STX V             ; we move up and away from the sun's centre
     B7BC 0022     
26356               
26357 B7BE 93A0  30        cb   @K,rx                      ; CPX K             ; If V <= the radius of the sun, we still have lines to
     B7C0 003D     
26358 B7C2 17E4  14        jnc  PLFLS                      ; BCC PLFLS         ; draw, so jump up to PLFL (via PLFLS) to do the next
26359 B7C4 13E3  14        jeq  PLFLS                      ; BEQ PLFLS         ; screen line up
26360               
26361               * ******************************************************************************
26362               *
26363               * Name: SUN (Part 4 of 4)
26364               * Type: Subroutine
26365               * Category: Drawing suns
26366               * Summary: Draw the sun: Continue to the top of the screen, erasing the old
26367               * sun line by line
26368               * Deep dive: Drawing the sun
26369               *
26370               * ------------------------------------------------------------------------------
26371               *
26372               * This part erases any remaining traces of the old sun, now that we have drawn
26373               * all the way to the top of the new sun.
26374               *
26375               * ------------------------------------------------------------------------------
26376               *
26377               * Other entry points:
26378               *
26379               * RTS2                Contains an RTS
26380               *
26381               * ******************************************************************************
26382               
26383 B7C6 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B7C8 0028     
26384 B7CA D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     B7CC 0026     
26385 B7CE D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     B7D0 0029     
26386 B7D2 D80D  30        movb ra,@YY+1                   ; STA YY+1
     B7D4 0027     
26387               
26388               PLFL3:
26389 B7D6 D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     B7D8 0D66     
26390                                                                          ; gives us the half-width of the old sun's line on this
26391                                                                          ; line of the screen
26392               
26393 B7DA 1304  14        jeq  PLF9                       ; BEQ PLF9          ; If A = 0, skip the following call to HLOIN2 as there
26394                                                                          ; is no sun line on this line of the screen
26395               
26396 B7DC 0200  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     B7DE 25DA     
26397 B7E0 06A0  32        bl   @jsr                       ;
     B7E2 FE1E     
26398                                                                          ; with centre point YY(1 0) and half-width A, and remove
26399                                                                          ; the line from the sun line heap once done
26400               
26401               PLF9:
26402 B7E4 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26403                                                                          ; above
26404               
26405 B7E6 16F7  14        jne  PLFL3                      ; BNE PLFL3         ; Jump up to PLFL3 to redraw the next line up, until we
26406                                                                          ; have reached the top of the screen
26407               
26408               PLF8:
26409                                                                          ; If we get here, we have successfully made it from the
26410                                                                          ; bottom line of the screen to the top, and the old sun
26411                                                                          ; has been replaced by the new one
26412                      .clc                            ; CLC               ; Clear the C flag to indicate success in drawing the
     **** ****     > CLC
0001 B7E8 0A16  18        sla  rzero,1
                   < elite.a99
26413                                                                          ; sun
26414               
26415 B7EA D360  30        movb @K3,ra                     ; LDA K3            ; Set SUNX(1 0) = K3(1 0)
     B7EC 00D2     
26416 B7EE D80D  30        movb ra,@SUNX                   ; STA SUNX
     B7F0 0028     
26417 B7F2 D360  30        movb @K3+1,ra                   ; LDA K3+1
     B7F4 00D3     
26418 B7F6 D80D  30        movb ra,@SUNX+1                 ; STA SUNX+1
     B7F8 0029     
26419               
26420               RTS2:
26421 B7FA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B7FC FE2A     
26422               
26423               * ******************************************************************************
26424               *
26425               * Name: CIRCLE
26426               * Type: Subroutine
26427               * Category: Drawing circles
26428               * Summary: Draw a circle for the planet
26429               * Deep dive: Drawing circles
26430               *
26431               * ------------------------------------------------------------------------------
26432               *
26433               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
26434               * planet's main outline.
26435               *
26436               * ------------------------------------------------------------------------------
26437               *
26438               * Arguments:
26439               *
26440               * K                   The planet's radius
26441               *
26442               * K3(1 0)             Pixel x-coordinate of the centre of the planet
26443               *
26444               * K4(1 0)             Pixel y-coordinate of the centre of the planet
26445               *
26446               * ******************************************************************************
26447               
26448               CIRCLE:
26449 B7FE 0200  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether the circle fits on-screen
     B800 BA20     
26450 B802 06A0  32        bl   @jsr                       ;
     B804 FE1E     
26451               
26452 B806 18F9  14        joc  RTS2                       ; BCS RTS2          ; If CHKON set the C flag then the circle does not fit
26453                                                                          ; on-screen, so return from the subroutine (as RTS2
26454                                                                          ; contains an RTS)
26455               
26456 B808 020D  20        li   ra,>00*256                 ; LDA #0            ; Set LSX2 = 0 to indicate that the ball line heap is
     B80A 0000     
26457 B80C D80D  30        movb ra,@LSX2                   ; STA LSX2          ; not empty, as we are about to fill it
     B80E 0E26     
26458               
26459 B810 D3A0  30        movb @K,rx                      ; LDX K             ; Set X = K = radius
     B812 003D     
26460               
26461 B814 020D  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8
     B816 0800     
26462               
26463 B818 028E  22        ci   rx,>08*256                 ; CPX #8            ; If the radius < 8, skip to PL89
     B81A 0800     
26464 B81C 1705  14        jnc  PL89                       ; BCC PL89
26465               
26466 B81E 091D  18        srl  ra,1                       ; LSR A             ; Halve A so A = 4
26467               
26468 B820 028E  22        ci   rx,>3c*256                 ; CPX #60           ; If the radius < 60, skip to PL89
     B822 3C00     
26469 B824 1701  14        jnc  PL89                       ; BCC PL89
26470               
26471 B826 091D  18        srl  ra,1                       ; LSR A             ; Halve A so A = 2
26472               
26473               PL89:
26474 B828 D80D  30        movb ra,@STP                    ; STA STP           ; Set STP = A. STP is the step size for the circle, so
     B82A 00A6     
26475                                                                          ; the above sets a smaller step size for bigger circles
26476               
26477                                                                          ; Fall through into CIRCLE2 to draw the circle with the
26478                                                                          ; correct step size
26479               
26480               * ******************************************************************************
26481               *
26482               * Name: CIRCLE2
26483               * Type: Subroutine
26484               * Category: Drawing circles
26485               * Summary: Draw a circle (for the planet or chart)
26486               * Deep dive: Drawing circles
26487               *
26488               * ------------------------------------------------------------------------------
26489               *
26490               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
26491               * planet and the chart circles.
26492               *
26493               * ------------------------------------------------------------------------------
26494               *
26495               * Arguments:
26496               *
26497               * STP                 The step size for the circle
26498               *
26499               * K                   The circle's radius
26500               *
26501               * K3(1 0)             Pixel x-coordinate of the centre of the circle
26502               *
26503               * K4(1 0)             Pixel y-coordinate of the centre of the circle
26504               *
26505               * ------------------------------------------------------------------------------
26506               *
26507               * Returns:
26508               *
26509               * C flag              The C flag is cleared
26510               *
26511               * ******************************************************************************
26512               
26513               CIRCLE2:
26514 B82C 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set FLAG = &FF to reset the ball line heap in the call
     B82E FF00     
26515 B830 D80E  30        movb rx,@FLAG                   ; STX FLAG          ; to the BLINE routine below
     B832 00A3     
26516               
26517 B834 B387  18        ab   rone,rx                    ; INX               ; Set CNT = 0, our counter that goes up to 64, counting
26518 B836 D80E  30        movb rx,@CNT                    ; STX CNT           ; segments in our circle
     B838 00A4     
26519               
26520               PLL3:
26521 B83A D360  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT
     B83C 00A4     
26522               
26523 B83E 0200  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     B840 4326     
26524 B842 06A0  32        bl   @jsr                       ;
     B844 FE1E     
26525                                                                          ;
26526                                                                          ; A = K * sin(A)
26527                                                                          ; = K * sin(CNT)
26528               
26529 B846 020E  20        li   rx,>00*256                 ; LDX #0            ; Set T = 0, so we have the following:
     B848 0000     
26530 B84A D80E  30        movb rx,@T                      ; STX T             ;
     B84C 00D1     
26531                                                                          ; (T A) = K * sin(CNT)
26532                                                                          ;
26533                                                                          ; which is the x-coordinate of the circle for this count
26534               
26535 B84E D3A0  30        movb @CNT,rx                    ; LDX CNT           ; If CNT < 33 then jump to PL37, as this is the right
     B850 00A4     
26536 B852 028E  22        ci   rx,>21*256                 ; CPX #33           ; half of the circle and the sign of the x-coordinate is
     B854 2100     
26537 B856 1712  14        jnc  PL37                       ; BCC PL37          ; correct
26538               
26539                      .eoi (>ff*256)                  ; EOR #%11111111    ; This is the left half of the circle, so we want to
     **** ****     > EOI
0001 B858 0200  20        li   rtmp,(>FF*256)
     B85A FF00     
0002 B85C 2B40  18        xor  rtmp,ra
                   < elite.a99
26540                      .adi (>00*256)                  ; ADC #0            ; flip the sign of the x-coordinate in (T A) using two's
     **** ****     > ADI
0001 B85E 1701  14        jnc  !
0002 B860 B347  18        ab   rone,ra
0003               !:
0004 B862 022D  22        ai   ra,(>00*256)
     B864 0000     
                   < elite.a99
26541 B866 D38D  18        movb ra,rx                      ; TAX               ; complement, so we start with the low byte and store it
26542                                                                          ; in X (the ADC adds 1 as we know the C flag is set)
26543               
26544 B868 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T
     B86A FF00     
26545                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B86C 1701  14        jnc  !
0002 B86E B347  18        ab   rone,ra
0003               !:
0004 B870 022D  22        ai   ra,(>00*256)
     B872 0000     
                   < elite.a99
26546 B874 D80D  30        movb ra,@T                      ; STA T
     B876 00D1     
26547               
26548 B878 D34E  18        movb rx,ra                      ; TXA               ; Finally, we restore the low byte from X, so we have
26549                                                                          ; now negated the x-coordinate in (T A)
26550               
26551                      .clc                            ; CLC               ; Clear the C flag so we can do some more addition below
     **** ****     > CLC
0001 B87A 0A16  18        sla  rzero,1
                   < elite.a99
26552               
26553               PL37:
26554                      .adc @K3,ra                     ; ADC K3            ; We now calculate the following:
     **** ****     > ADC
0001 B87C 1701  14        jnc  !
0002 B87E B347  18        ab   rone,ra
0003               !:
0004 B880 B360  30        ab   @K3,ra
     B882 00D2     
                   < elite.a99
26555 B884 D80D  30        movb ra,@K6                     ; STA K6            ;
     B886 0082     
26556                                                                          ; K6(1 0) = (T A) + K3(1 0)
26557                                                                          ;
26558                                                                          ; to add the coordinates of the centre to our circle
26559                                                                          ; point, starting with the low bytes
26560               
26561 B888 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; And then doing the high bytes, so we now have:
     B88A 00D3     
26562                      .adc @T,ra                      ; ADC T             ;
     **** ****     > ADC
0001 B88C 1701  14        jnc  !
0002 B88E B347  18        ab   rone,ra
0003               !:
0004 B890 B360  30        ab   @T,ra
     B892 00D1     
                   < elite.a99
26563 B894 D80D  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K * sin(CNT) + K3(1 0)
     B896 0083     
26564                                                                          ;
26565                                                                          ; which is the result we want for the x-coordinate
26566               
26567 B898 D360  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT + 16
     B89A 00A4     
26568                      .clc                            ; CLC
     **** ****     > CLC
0001 B89C 0A16  18        sla  rzero,1
                   < elite.a99
26569                      .adi (>10*256)                  ; ADC #16
     **** ****     > ADI
0001 B89E 1701  14        jnc  !
0002 B8A0 B347  18        ab   rone,ra
0003               !:
0004 B8A2 022D  22        ai   ra,(>10*256)
     B8A4 1000     
                   < elite.a99
26570               
26571 B8A6 0200  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     B8A8 4326     
26572 B8AA 06A0  32        bl   @jsr                       ;
     B8AC FE1E     
26573                                                                          ;
26574                                                                          ; A = K * sin(A)
26575                                                                          ; = K * sin(CNT + 16)
26576                                                                          ; = K * cos(CNT)
26577               
26578 B8AE D38D  18        movb ra,rx                      ; TAX               ; Set X = A
26579                                                                          ; = K * cos(CNT)
26580               
26581 B8B0 020D  20        li   ra,>00*256                 ; LDA #0            ; Set T = 0, so we have the following:
     B8B2 0000     
26582 B8B4 D80D  30        movb ra,@T                      ; STA T             ;
     B8B6 00D1     
26583                                                                          ; (T X) = K * cos(CNT)
26584                                                                          ;
26585                                                                          ; which is the y-coordinate of the circle for this count
26586               
26587 B8B8 D360  30        movb @CNT,ra                    ; LDA CNT           ; Set A = (CNT + 15) mod 64
     B8BA 00A4     
26588                      .adi (>0f*256)                  ; ADC #15
     **** ****     > ADI
0001 B8BC 1701  14        jnc  !
0002 B8BE B347  18        ab   rone,ra
0003               !:
0004 B8C0 022D  22        ai   ra,(>0F*256)
     B8C2 0F00     
                   < elite.a99
26589 B8C4 024D  22        andi ra,>3f*256                 ; AND #63
     B8C6 3F00     
26590               
26591 B8C8 028D  22        ci   ra,>21*256                 ; CMP #33           ; If A < 33 (i.e. CNT is 0-16 or 48-64) then jump to
     B8CA 2100     
26592 B8CC 1712  14        jnc  PL38                       ; BCC PL38          ; PL38, as this is the bottom half of the circle and the
26593                                                                          ; sign of the y-coordinate is correct
26594               
26595 B8CE D34E  18        movb rx,ra                      ; TXA               ; This is the top half of the circle, so we want to
26596                      .eoi (>ff*256)                  ; EOR #%11111111    ; flip the sign of the y-coordinate in (T X) using two's
     **** ****     > EOI
0001 B8D0 0200  20        li   rtmp,(>FF*256)
     B8D2 FF00     
0002 B8D4 2B40  18        xor  rtmp,ra
                   < elite.a99
26597                      .adi (>00*256)                  ; ADC #0            ; complement, so we start with the low byte in X (the
     **** ****     > ADI
0001 B8D6 1701  14        jnc  !
0002 B8D8 B347  18        ab   rone,ra
0003               !:
0004 B8DA 022D  22        ai   ra,(>00*256)
     B8DC 0000     
                   < elite.a99
26598 B8DE D38D  18        movb ra,rx                      ; TAX               ; ADC adds 1 as we know the C flag is set)
26599               
26600 B8E0 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T, so we have
     B8E2 FF00     
26601                      .adi (>00*256)                  ; ADC #0            ; now negated the y-coordinate in (T X)
     **** ****     > ADI
0001 B8E4 1701  14        jnc  !
0002 B8E6 B347  18        ab   rone,ra
0003               !:
0004 B8E8 022D  22        ai   ra,(>00*256)
     B8EA 0000     
                   < elite.a99
26602 B8EC D80D  30        movb ra,@T                      ; STA T
     B8EE 00D1     
26603               
26604                      .clc                            ; CLC               ; Clear the C flag so the addition at the start of BLINE
     **** ****     > CLC
0001 B8F0 0A16  18        sla  rzero,1
                   < elite.a99
26605                                                                          ; will work
26606               
26607               PL38:
26608 B8F2 0200  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also increases
     B8F4 283E     
26609 B8F6 06A0  32        bl   @jsr                       ;
     B8F8 FE1E     
26610                                                                          ; CNT by STP, the step size
26611               
26612 B8FA 028D  22        ci   ra,>41*256                 ; CMP #65           ; If CNT >= 65 then skip the next instruction
     B8FC 4100     
26613 B8FE 1802  14        joc  B78                        ; BCS B78
26614               
26615 B900 0460  28        b    @PLL3                      ; JMP PLL3          ; Jump back for the next segment
     B902 B83A     
26616               
26617               B78:
26618                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 B904 0A16  18        sla  rzero,1
                   < elite.a99
26619               
26620 B906 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B908 FE2A     
26621               
26622               * ******************************************************************************
26623               *
26624               * Name: WPLS2
26625               * Type: Subroutine
26626               * Category: Drawing planets
26627               * Summary: Remove the planet from the screen
26628               * Deep dive: The ball line heap
26629               *
26630               * ------------------------------------------------------------------------------
26631               *
26632               * We do this by redrawing it using the lines stored in the ball line heap when
26633               * the planet was originally drawn by the BLINE routine.
26634               *
26635               * ******************************************************************************
26636               
26637               WPLS2:
26638 B90A D3E0  30        movb @LSX2,ry                   ; LDY LSX2          ; If LSX2 is non-zero (which indicates the ball line
     B90C 0E26     
26639 B90E 162C  14        jne  WP1                        ; BNE WP1           ; heap is empty), jump to WP1 to reset the line heap
26640                                                                          ; without redrawing the planet
26641               
26642                                                                          ; Otherwise Y is now 0, so we can use it as a counter to
26643                                                                          ; loop through the lines in the line heap, redrawing
26644                                                                          ; each one to remove the planet from the screen, before
26645                                                                          ; resetting the line heap once we are done
26646               
26647               WPL1:
26648 B910 93E0  30        cb   @LSP,ry                    ; CPY LSP           ; If Y >= LSP then we have reached the end of the line
     B912 0077     
26649 B914 1829  14        joc  WP1                        ; BCS WP1           ; heap and have finished redrawing the planet (as LSP
26650                                                                          ; points to the end of the heap), so jump to WP1 to
26651                                                                          ; reset the line heap, returning from the subroutine
26652                                                                          ; using a tail call
26653               
26654 B916 D36F  34        movb @LSY2(ry),ra               ; LDA LSY2,Y        ; Set A to the y-coordinate of the current heap entry
     B918 0E74     
26655               
26656 B91A 028D  22        ci   ra,>ff*256                 ; CMP #&FF          ; If the y-coordinate is &FF, this indicates that the
     B91C FF00     
26657 B91E 1318  14        jeq  WP2                        ; BEQ WP2           ; next point in the heap denotes the start of a line
26658                                                                          ; segment, so jump to WP2 to put it into (X1, Y1)
26659               
26660 B920 D80D  30        movb ra,@Y2                     ; STA Y2            ; Set (X2, Y2) to the x- and y-coordinates from the
     B922 0034     
26661 B924 D36F  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; heap
     B926 0E26     
26662 B928 D80D  30        movb ra,@X2                     ; STA X2
     B92A 0033     
26663               
26664 B92C 0200  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     B92E 224E     
26665 B930 06A0  32        bl   @jsr                       ;
     B932 FE1E     
26666               
26667 B934 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26668               
26669 B936 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP is non-zero then we swapped the coordinates
     B938 00A1     
26670 B93A 16EA  14        jne  WPL1                       ; BNE WPL1          ; when filling the heap in BLINE, so loop back WPL1
26671                                                                          ; for the next point in the heap
26672               
26673 B93C D360  30        movb @X2,ra                     ; LDA X2            ; Swap (X1, Y1) and (X2, Y2), so the next segment will
     B93E 0033     
26674 B940 D80D  30        movb ra,@X1                     ; STA X1            ; be drawn from the current (X2, Y2) to the next point
     B942 0031     
26675 B944 D360  30        movb @Y2,ra                     ; LDA Y2            ; in the heap
     B946 0034     
26676 B948 D80D  30        movb ra,@Y1                     ; STA Y1
     B94A 0032     
26677               
26678 B94C 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     B94E B910     
26679               
26680               WP2:
26681 B950 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26682               
26683 B952 D36F  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; Set (X1, Y1) to the x- and y-coordinates from the
     B954 0E26     
26684 B956 D80D  30        movb ra,@X1                     ; STA X1            ; heap
     B958 0031     
26685 B95A D36F  34        movb @LSY2(ry),ra               ; LDA LSY2,Y
     B95C 0E74     
26686 B95E D80D  30        movb ra,@Y1                     ; STA Y1
     B960 0032     
26687               
26688 B962 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
26689               
26690 B964 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     B966 B910     
26691               
26692               * ******************************************************************************
26693               *
26694               * Name: WP1
26695               * Type: Subroutine
26696               * Category: Drawing planets
26697               * Summary: Reset the ball line heap
26698               *
26699               * ******************************************************************************
26700               
26701               WP1:
26702 B968 020D  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap pointer
     B96A 0100     
26703 B96C D80D  30        movb ra,@LSP                    ; STA LSP
     B96E 0077     
26704               
26705 B970 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set LSX2 = &FF to indicate the ball line heap is empty
     B972 FF00     
26706 B974 D80D  30        movb ra,@LSX2                   ; STA LSX2
     B976 0E26     
26707               
26708 B978 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B97A FE2A     
26709               
26710               * ******************************************************************************
26711               *
26712               * Name: WPLS
26713               * Type: Subroutine
26714               * Category: Drawing suns
26715               * Summary: Remove the sun from the screen
26716               * Deep dive: Drawing the sun
26717               *
26718               * ------------------------------------------------------------------------------
26719               *
26720               * We do this by redrawing it using the lines stored in the sun line heap when
26721               * the sun was originally drawn by the SUN routine.
26722               *
26723               * ------------------------------------------------------------------------------
26724               *
26725               * Arguments:
26726               *
26727               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the sun
26728               *
26729               * ------------------------------------------------------------------------------
26730               *
26731               * Other entry points:
26732               *
26733               * WPLS-1              Contains an RTS
26734               *
26735               * ******************************************************************************
26736               
26737               WPLS:
26738 B97C D360  30        movb @LSX,ra                    ; LDA LSX           ; If LSX < 0, the sun line heap is empty, so return from
     B97E 0D66     
26739 B980 11FC  14        jlt  WPLS-1                     ; BMI WPLS-1        ; the subroutine (as WPLS-1 contains an RTS)
26740               
26741 B982 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     B984 0028     
26742 B986 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the sun that's currently on
     B988 0026     
26743 B98A D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; screen
     B98C 0029     
26744 B98E D80D  30        movb ra,@YY+1                   ; STA YY+1
     B990 0027     
26745               
26746 B992 020F  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     B994 BF00     
26747                                                                          ; view, so this sets Y as a counter for the number of
26748                                                                          ; lines in the space view (i.e. 191), which is also the
26749                                                                          ; number of lines in the LSO block
26750               
26751               WPL2:
26752 B996 D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     B998 0D66     
26753                                                                          ; gives us the half-width of the sun's line on this line
26754                                                                          ; of the screen
26755               
26756 B99A 1304  14        jeq  B79                        ; BEQ B79           ; If A = 0, skip the following call to HLOIN2 as there
26757                                                                          ; is no sun line on this line of the screen
26758               
26759 B99C 0200  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     B99E 25DA     
26760 B9A0 06A0  32        bl   @jsr                       ;
     B9A2 FE1E     
26761                                                                          ; with centre point YY(1 0) and half-width A, and remove
26762                                                                          ; the line from the sun line heap once done
26763               
26764               B79:
26765 B9A4 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
26766               
26767 B9A6 16F7  14        jne  WPL2                       ; BNE WPL2          ; Loop back for the next line in the line heap until
26768                                                                          ; we have gone through the entire heap
26769               
26770 B9A8 73C7  18        sb   rone,ry                    ; DEY               ; This sets Y to &FF, as we end the loop with Y = 0
26771               
26772 B9AA D80F  30        movb ry,@LSX                    ; STY LSX           ; Set LSX to &FF to indicate the sun line heap is empty
     B9AC 0D66     
26773               
26774 B9AE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B9B0 FE2A     
26775               
26776               * ******************************************************************************
26777               *
26778               * Name: EDGES
26779               * Type: Subroutine
26780               * Category: Drawing lines
26781               * Summary: Draw a horizontal line given a centre and a half-width
26782               *
26783               * ------------------------------------------------------------------------------
26784               *
26785               * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
26786               * centre x-coordinate YY(1 0), and length A in either direction from the centre
26787               * (so a total line length of 2 * A). In other words, this line:
26788               *
26789               * X1             YY(1 0)             X2
26790               * +-----------------+-----------------+
26791               * <- A ->           <- A ->
26792               *
26793               * The resulting line gets clipped to the edges of the screen, if needed. If the
26794               * calculation doesn't overflow, we return with the C flag clear, otherwise the C
26795               * flag gets set to indicate failure and the Y-th LSO entry gets set to 0.
26796               *
26797               * ------------------------------------------------------------------------------
26798               *
26799               * Arguments:
26800               *
26801               * A                   The half-length of the line
26802               *
26803               * YY(1 0)             The centre x-coordinate
26804               *
26805               * ------------------------------------------------------------------------------
26806               *
26807               * Returns:
26808               *
26809               * C flag              Clear if the line fits on-screen, set if it doesn't
26810               *
26811               * X1, X2              The x-coordinates of the clipped line
26812               *
26813               * LSO+Y               If the line doesn't fit, LSO+Y is set to 0
26814               *
26815               * Y                   Y is preserved
26816               *
26817               * ******************************************************************************
26818               
26819               EDGES:
26820 B9B2 D80D  30        movb ra,@T                      ; STA T             ; Set T to the line's half-length in argument A
     B9B4 00D1     
26821               
26822                      .clc                            ; CLC               ; We now calculate:
     **** ****     > CLC
0001 B9B6 0A16  18        sla  rzero,1
                   < elite.a99
26823                      .adc @YY,ra                     ; ADC YY            ;
     **** ****     > ADC
0001 B9B8 1701  14        jnc  !
0002 B9BA B347  18        ab   rone,ra
0003               !:
0004 B9BC B360  30        ab   @YY,ra
     B9BE 0026     
                   < elite.a99
26824 B9C0 D80D  30        movb ra,@X2                     ; STA X2            ; (A X2) = YY(1 0) + A
     B9C2 0033     
26825                                                                          ;
26826                                                                          ; to set X2 to the x-coordinate of the right end of the
26827                                                                          ; line, starting with the low bytes
26828               
26829 B9C4 D360  30        movb @YY+1,ra                   ; LDA YY+1          ; And then adding the high bytes
     B9C6 0027     
26830                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B9C8 1701  14        jnc  !
0002 B9CA B347  18        ab   rone,ra
0003               !:
0004 B9CC 022D  22        ai   ra,(>00*256)
     B9CE 0000     
                   < elite.a99
26831               
26832 B9D0 1120  14        jlt  ED1                        ; BMI ED1           ; If the addition is negative then the calculation has
26833                                                                          ; overflowed, so jump to ED1 to return a failure
26834               
26835 B9D2 1304  14        jeq  B80                        ; BEQ B80           ; If the high byte A from the result is 0, skip the
26836                                                                          ; next two instructions, as the result already fits on
26837                                                                          ; the screen
26838               
26839 B9D4 020D  20        li   ra,>fe*256                 ; LDA #254          ; The high byte is positive and non-zero, so we went
     B9D6 FE00     
26840 B9D8 D80D  30        movb ra,@X2                     ; STA X2            ; past the right edge of the screen, so clip X2 to the
     B9DA 0033     
26841                                                                          ; x-coordinate of the right edge of the screen
26842               
26843               B80:
26844 B9DC D360  30        movb @YY,ra                     ; LDA YY            ; We now calculate:
     B9DE 0026     
26845                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 B9E0 0A18  18        sla  rmone,1
                   < elite.a99
26846                      .sbc @T,ra                      ; SBC T             ; (A X1) = YY(1 0) - argument A
     **** ****     > SBC
0001 B9E2 1801  14        joc  !
0002 B9E4 7347  18        sb   rone,ra
0003               !:
0004 B9E6 7360  30        sb   @T,ra
     B9E8 00D1     
                   < elite.a99
26847 B9EA D80D  30        movb ra,@X1                     ; STA X1            ;
     B9EC 0031     
26848                                                                          ; to set X1 to the x-coordinate of the left end of the
26849                                                                          ; line, starting with the low bytes
26850               
26851 B9EE D360  30        movb @YY+1,ra                   ; LDA YY+1          ; And then subtracting the high bytes
     B9F0 0027     
26852                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 B9F2 1801  14        joc  !
0002 B9F4 7347  18        sb   rone,ra
0003               !:
0004 B9F6 022D  22        ai   ra,-(>00*256)
     B9F8 0000     
                   < elite.a99
26853               
26854 B9FA 1603  14        jne  ED3                        ; BNE ED3           ; If the high byte subtraction is non-zero, then skip
26855                                                                          ; to ED3
26856               
26857                      .clc                            ; CLC               ; Otherwise the high byte of the subtraction was zero,
     **** ****     > CLC
0001 B9FC 0A16  18        sla  rzero,1
                   < elite.a99
26858                                                                          ; so the line fits on-screen and we clear the C flag to
26859                                                                          ; indicate success
26860               
26861 B9FE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA00 FE2A     
26862               
26863               ED3:
26864 BA02 1507  14        jgt  ED1                        ; BPL ED1           ; If the addition is positive then the calculation has
26865                                                                          ; underflowed, so jump to ED1 to return a failure
26866               
26867 BA04 020D  20        li   ra,>02*256                 ; LDA #2            ; The high byte is negative and non-zero, so we went
     BA06 0200     
26868 BA08 D80D  30        movb ra,@X1                     ; STA X1            ; past the left edge of the screen, so clip X1 to the
     BA0A 0031     
26869                                                                          ; x-coordinate of the left edge of the screen
26870               
26871                      .clc                            ; CLC               ; The line does fit on-screen, so clear the C flag to
     **** ****     > CLC
0001 BA0C 0A16  18        sla  rzero,1
                   < elite.a99
26872                                                                          ; indicate success
26873               
26874 BA0E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA10 FE2A     
26875               
26876               ED1:
26877 BA12 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     BA14 0000     
26878 BA16 DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y
     BA18 0D66     
26879               
26880                      .sec                            ; SEC               ; The line does not fit on the screen, so set the C flag
     **** ****     > SEC
0001 BA1A 0A18  18        sla  rmone,1
                   < elite.a99
26881                                                                          ; to indicate this result
26882               
26883 BA1C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA1E FE2A     
26884               
26885               * ******************************************************************************
26886               *
26887               * Name: CHKON
26888               * Type: Subroutine
26889               * Category: Drawing circles
26890               * Summary: Check whether any part of a circle appears on the extended screen
26891               *
26892               * ------------------------------------------------------------------------------
26893               *
26894               * Arguments:
26895               *
26896               * K                   The circle's radius
26897               *
26898               * K3(1 0)             Pixel x-coordinate of the centre of the circle
26899               *
26900               * K4(1 0)             Pixel y-coordinate of the centre of the circle
26901               *
26902               * ------------------------------------------------------------------------------
26903               *
26904               * Returns:
26905               *
26906               * C flag              Clear if any part of the circle appears on-screen, set
26907               * if none of the circle appears on-screen
26908               *
26909               * (A X)               Minimum y-coordinate of the circle on-screen (i.e. the
26910               * y-coordinate of the top edge of the circle)
26911               *
26912               * P(2 1)              Maximum y-coordinate of the circle on-screen (i.e. the
26913               * y-coordinate of the bottom edge of the circle)
26914               *
26915               * ******************************************************************************
26916               
26917               CHKON:
26918 BA20 D360  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 + K
     BA22 00D2     
26919                      .clc                            ; CLC
     **** ****     > CLC
0001 BA24 0A16  18        sla  rzero,1
                   < elite.a99
26920                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 BA26 1701  14        jnc  !
0002 BA28 B347  18        ab   rone,ra
0003               !:
0004 BA2A B360  30        ab   @K,ra
     BA2C 003D     
                   < elite.a99
26921               
26922 BA2E D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 + 0 + any carry from above, so this
     BA30 00D3     
26923                      .adi (>00*256)                  ; ADC #0            ; effectively sets A to the high byte of K3(1 0) + K:
     **** ****     > ADI
0001 BA32 1701  14        jnc  !
0002 BA34 B347  18        ab   rone,ra
0003               !:
0004 BA36 022D  22        ai   ra,(>00*256)
     BA38 0000     
                   < elite.a99
26924                                                                          ;
26925                                                                          ; (A ?) = K3(1 0) + K
26926                                                                          ;
26927                                                                          ; so A is the high byte of the x-coordinate of the right
26928                                                                          ; edge of the circle
26929               
26930 BA3A 1135  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the right edge of the circle is
26931                                                                          ; to the left of the screen, so jump to PL21 to set the
26932                                                                          ; C flag and return from the subroutine, as the whole
26933                                                                          ; circle is off-screen to the left
26934               
26935 BA3C D360  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 - K
     BA3E 00D2     
26936                      .sec                            ; SEC
     **** ****     > SEC
0001 BA40 0A18  18        sla  rmone,1
                   < elite.a99
26937                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 BA42 1801  14        joc  !
0002 BA44 7347  18        sb   rone,ra
0003               !:
0004 BA46 7360  30        sb   @K,ra
     BA48 003D     
                   < elite.a99
26938               
26939 BA4A D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 - 0 - any carry from above, so this
     BA4C 00D3     
26940                      .sbi (>00*256)                  ; SBC #0            ; effectively sets A to the high byte of K3(1 0) - K:
     **** ****     > SBI
0001 BA4E 1801  14        joc  !
0002 BA50 7347  18        sb   rone,ra
0003               !:
0004 BA52 022D  22        ai   ra,-(>00*256)
     BA54 0000     
                   < elite.a99
26941                                                                          ;
26942                                                                          ; (A ?) = K3(1 0) - K
26943                                                                          ;
26944                                                                          ; so A is the high byte of the x-coordinate of the left
26945                                                                          ; edge of the circle
26946               
26947 BA56 1101  14        jlt  PL31                       ; BMI PL31          ; If A is negative then the left edge of the circle is
26948                                                                          ; to the left of the screen, and we already know the
26949                                                                          ; right edge is either on-screen or off-screen to the
26950                                                                          ; right, so skip to PL31 to move on to the y-coordinate
26951                                                                          ; checks, as at least part of the circle is on-screen in
26952                                                                          ; terms of the x-axis
26953               
26954 BA58 1626  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the left edge of the circle is
26955                                                                          ; to the right of the screen, so jump to PL21 to set the
26956                                                                          ; C flag and return from the subroutine, as the whole
26957                                                                          ; circle is off-screen to the right
26958               
26959               PL31:
26960 BA5A D360  30        movb @K4,ra                     ; LDA K4            ; Set P+1 = K4 + K
     BA5C 00E0     
26961                      .clc                            ; CLC
     **** ****     > CLC
0001 BA5E 0A16  18        sla  rzero,1
                   < elite.a99
26962                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 BA60 1701  14        jnc  !
0002 BA62 B347  18        ab   rone,ra
0003               !:
0004 BA64 B360  30        ab   @K,ra
     BA66 003D     
                   < elite.a99
26963 BA68 D80D  30        movb ra,@P+1                    ; STA P+1
     BA6A 001C     
26964               
26965 BA6C D360  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 + 0 + any carry from above, so this
     BA6E 00E1     
26966                      .adi (>00*256)                  ; ADC #0            ; does the following:
     **** ****     > ADI
0001 BA70 1701  14        jnc  !
0002 BA72 B347  18        ab   rone,ra
0003               !:
0004 BA74 022D  22        ai   ra,(>00*256)
     BA76 0000     
                   < elite.a99
26967                                                                          ;
26968                                                                          ; (A P+1) = K4(1 0) + K
26969                                                                          ;
26970                                                                          ; so A is the high byte of the y-coordinate of the
26971                                                                          ; bottom edge of the circle
26972               
26973 BA78 1116  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the bottom edge of the circle is
26974                                                                          ; above the top of the screen, so jump to PL21 to set
26975                                                                          ; the C flag and return from the subroutine, as the
26976                                                                          ; whole circle is off-screen to the top
26977               
26978 BA7A D80D  30        movb ra,@P+2                    ; STA P+2           ; Store the high byte in P+2, so now we have:
     BA7C 001D     
26979                                                                          ;
26980                                                                          ; P(2 1) = K4(1 0) + K
26981                                                                          ;
26982                                                                          ; i.e. the maximum y-coordinate of the circle on-screen
26983                                                                          ; (which we return)
26984               
26985 BA7E D360  30        movb @K4,ra                     ; LDA K4            ; Set X = K4 - K
     BA80 00E0     
26986                      .sec                            ; SEC
     **** ****     > SEC
0001 BA82 0A18  18        sla  rmone,1
                   < elite.a99
26987                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 BA84 1801  14        joc  !
0002 BA86 7347  18        sb   rone,ra
0003               !:
0004 BA88 7360  30        sb   @K,ra
     BA8A 003D     
                   < elite.a99
26988 BA8C D38D  18        movb ra,rx                      ; TAX
26989               
26990 BA8E D360  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 - 0 - any carry from above, so this
     BA90 00E1     
26991                      .sbi (>00*256)                  ; SBC #0            ; does the following:
     **** ****     > SBI
0001 BA92 1801  14        joc  !
0002 BA94 7347  18        sb   rone,ra
0003               !:
0004 BA96 022D  22        ai   ra,-(>00*256)
     BA98 0000     
                   < elite.a99
26992                                                                          ;
26993                                                                          ; (A X) = K4(1 0) - K
26994                                                                          ;
26995                                                                          ; so A is the high byte of the y-coordinate of the top
26996                                                                          ; edge of the circle
26997               
26998 BA9A 1179  14        jlt  PL44                       ; BMI PL44          ; If A is negative then the top edge of the circle is
26999                                                                          ; above the top of the screen, and we already know the
27000                                                                          ; bottom edge is either on-screen or below the bottom
27001                                                                          ; of the screen, so skip to PL44 to clear the C flag and
27002                                                                          ; return from the subroutine using a tail call, as part
27003                                                                          ; of the circle definitely appears on-screen
27004               
27005 BA9C 1604  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the top edge of the circle is
27006                                                                          ; below the bottom of the screen, so jump to PL21 to set
27007                                                                          ; the C flag and return from the subroutine, as the
27008                                                                          ; whole circle is off-screen to the bottom
27009               
27010 BA9E 028E  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If we get here then A is zero, which means the top
     BAA0 BF00     
27011                                                                          ; edge of the circle is within the screen boundary, so
27012                                                                          ; now we need to check whether it is in the space view
27013                                                                          ; (in which case it is on-screen) or the dashboard (in
27014                                                                          ; which case the top of the circle is hidden by the
27015                                                                          ; dashboard, so the circle isn't on-screen). We do this
27016                                                                          ; by checking the low byte of the result in X against
27017                                                                          ; 2 * #Y - 1, and returning the C flag from this
27018                                                                          ; comparison. The constant #Y is the y-coordinate of the
27019                                                                          ; mid-point of the space view, so 2 * #Y - 1, the
27020                                                                          ; y-coordinate of the bottom pixel row of the space
27021                                                                          ; view. So this does the following:
27022                                                                          ;
27023                                                                          ; * The C flag is set if coordinate (A X) is below the
27024                                                                          ; bottom row of the space view, i.e. the top edge of
27025                                                                          ; the circle is hidden by the dashboard
27026                                                                          ;
27027                                                                          ; * The C flag is clear if coordinate (A X) is above
27028                                                                          ; the bottom row of the space view, i.e. the top
27029                                                                          ; edge of the circle is on-screen
27030               
27031 BAA2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BAA4 FE2A     
27032               
27033               * ******************************************************************************
27034               *
27035               * Name: PL21
27036               * Type: Subroutine
27037               * Category: Drawing planets
27038               * Summary: Return from a planet/sun-drawing routine with a failure flag
27039               *
27040               * ------------------------------------------------------------------------------
27041               *
27042               * Set the C flag and return from the subroutine. This is used to return from a
27043               * planet- or sun-drawing routine with the C flag indicating an overflow in the
27044               * calculation.
27045               *
27046               * ******************************************************************************
27047               
27048               PL21:
27049                      .sec                            ; SEC               ; Set the C flag to indicate an overflow
     **** ****     > SEC
0001 BAA6 0A18  18        sla  rmone,1
                   < elite.a99
27050               
27051 BAA8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BAAA FE2A     
27052               
27053               * ******************************************************************************
27054               *
27055               * Name: PLS3
27056               * Type: Subroutine
27057               * Category: Drawing planets
27058               * Summary: Calculate (Y A P) = 222 * roofv_x / z
27059               *
27060               * ------------------------------------------------------------------------------
27061               *
27062               * Calculate the following, with X determining the vector to use:
27063               *
27064               * (Y A P) = 222 * roofv_x / z
27065               *
27066               * though in reality only (Y A) is used.
27067               *
27068               * Although the code below supports a range of values of X, in practice the
27069               * routine is only called with X = 15, and then again after X has been
27070               * incremented to 17. So the values calculated by PLS1 use roofv_x first, then
27071               * roofv_y. The comments below refer to roofv_x, for the first call.
27072               *
27073               * ------------------------------------------------------------------------------
27074               *
27075               * Arguments:
27076               *
27077               * X                   Determines which of the INWK orientation vectors to
27078               * divide:
27079               *
27080               * * X = 15: divides roofv_x
27081               *
27082               * * X = 17: divides roofv_y
27083               *
27084               * ------------------------------------------------------------------------------
27085               *
27086               * Returns:
27087               *
27088               * X                   X gets incremented by 2 so it points to the next
27089               * coordinate in this orientation vector (so consecutive
27090               * calls to the routine will start with x, then move onto y
27091               * and then z)
27092               *
27093               * ******************************************************************************
27094               
27095               PLS3:
27096 BAAC 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BAAE B3AC     
27097 BAB0 06A0  32        bl   @jsr                       ;
     BAB2 FE1E     
27098 BAB4 D80D  30        movb ra,@P                      ; STA P             ;
     BAB6 001B     
27099                                                                          ; P = |roofv_x / z|
27100                                                                          ; K+3 = sign of roofv_x / z
27101                                                                          ;
27102                                                                          ; and increment X to point to roofv_y for the next call
27103               
27104 BAB8 020D  20        li   ra,>de*256                 ; LDA #222          ; Set Q = 222, the offset to the crater
     BABA DE00     
27105 BABC D80D  30        movb ra,@Q                      ; STA Q
     BABE 0090     
27106               
27107 BAC0 D80E  30        movb rx,@U                      ; STX U             ; Store the vector index X in U for retrieval after the
     BAC2 008F     
27108                                                                          ; call to MULTU
27109               
27110 BAC4 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate
     BAC6 42DE     
27111 BAC8 06A0  32        bl   @jsr                       ;
     BACA FE1E     
27112                                                                          ;
27113                                                                          ; (A P) = P * Q
27114                                                                          ; = 222 * |roofv_x / z|
27115               
27116 BACC D3A0  30        movb @U,rx                      ; LDX U             ; Restore the vector index from U into X
     BACE 008F     
27117               
27118 BAD0 D3E0  30        movb @K+3,ry                    ; LDY K+3           ; If the sign of the result in K+3 is positive, skip to
     BAD2 0040     
27119 BAD4 150D  14        jgt  PL12                       ; BPL PL12          ; PL12 to return with Y = 0
27120               
27121                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise the result should be negative, so negate the
     **** ****     > EOI
0001 BAD6 0200  20        li   rtmp,(>FF*256)
     BAD8 FF00     
0002 BADA 2B40  18        xor  rtmp,ra
                   < elite.a99
27122                      .clc                            ; CLC               ; high byte of the result using two's complement with
     **** ****     > CLC
0001 BADC 0A16  18        sla  rzero,1
                   < elite.a99
27123                      .adi (>01*256)                  ; ADC #1            ; A = ~A + 1
     **** ****     > ADI
0001 BADE 1701  14        jnc  !
0002 BAE0 B347  18        ab   rone,ra
0003               !:
0004 BAE2 022D  22        ai   ra,(>01*256)
     BAE4 0100     
                   < elite.a99
27124               
27125 BAE6 1304  14        jeq  PL12                       ; BEQ PL12          ; If A = 0, jump to PL12 to return with (Y A) = 0
27126               
27127 BAE8 020F  20        li   ry,>ff*256                 ; LDY #&FF          ; Set Y = &FF to be a negative high byte
     BAEA FF00     
27128               
27129 BAEC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BAEE FE2A     
27130               
27131               PL12:
27132 BAF0 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to be a positive high byte
     BAF2 0000     
27133               
27134 BAF4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BAF6 FE2A     
27135               
27136               * ******************************************************************************
27137               *
27138               * Name: PLS4
27139               * Type: Subroutine
27140               * Category: Drawing planets
27141               * Summary: Calculate CNT2 = arctan(P / A) / 4
27142               *
27143               * ------------------------------------------------------------------------------
27144               *
27145               * Calculate the following:
27146               *
27147               * CNT2 = arctan(P / A) / 4
27148               *
27149               * and do the following if nosev_z_hi >= 0:
27150               *
27151               * CNT2 = CNT2 + 32
27152               *
27153               * which is the equivalent of adding 180 degrees to the result (or PI radians),
27154               * as there are 64 segments in a full circle.
27155               *
27156               * This routine is called with the following arguments when calculating the
27157               * equator and meridian for planets:
27158               *
27159               * * A = roofv_z_hi, P = -nosev_z_hi
27160               *
27161               * * A = sidev_z_hi, P = -nosev_z_hi
27162               *
27163               * So it calculates the angle between the planet's orientation vectors, in the
27164               * z-axis.
27165               *
27166               * ******************************************************************************
27167               
27168               PLS4:
27169 BAF8 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = A
     BAFA 0090     
27170               
27171 BAFC 0200  20        li   rtmp,ARCTAN                ; JSR ARCTAN        ; Call ARCTAN to calculate:
     BAFE 4776     
27172 BB00 06A0  32        bl   @jsr                       ;
     BB02 FE1E     
27173                                                                          ;
27174                                                                          ; A = arctan(P / Q)
27175                                                                          ; arctan(P / A)
27176                                                                          ;
27177                                                                          ; The result in A will be in the range 0 to 128, which
27178                                                                          ; represents an angle of 0 to 180 degrees (or 0 to PI
27179                                                                          ; radians)
27180               
27181 BB04 D3A0  30        movb @INWK+14,rx                ; LDX INWK+14       ; If nosev_z_hi is negative, skip the following
     BB06 0061     
27182 BB08 1103  14        jlt  B81                        ; BMI B81           ; instruction to leave the angle in A as a positive
27183                                                                          ; integer in the range 0 to 128 (so when we calculate
27184                                                                          ; CNT2 below, it will be in the right half of the
27185                                                                          ; anti-clockwise arc that we describe when drawing
27186                                                                          ; circles, i.e. from 6 o'clock, through 3 o'clock and
27187                                                                          ; on to 12 o'clock)
27188               
27189                      .eoi (>80*256)                  ; EOR #%10000000    ; If we get here then nosev_z_hi is positive, so flip
     **** ****     > EOI
0001 BB0A 0200  20        li   rtmp,(>80*256)
     BB0C 8000     
0002 BB0E 2B40  18        xor  rtmp,ra
                   < elite.a99
27190                                                                          ; bit 7 of the angle in A, which is the same as adding
27191                                                                          ; 128 to give a result in the range 129 to 256 (i.e. 129
27192                                                                          ; to 0), or 180 to 360 degrees (so when we calculate
27193                                                                          ; CNT2 below, it will be in the left half of the
27194                                                                          ; anti-clockwise arc that we describe when drawing
27195                                                                          ; circles, i.e. from 12 o'clock, through 9 o'clock and
27196                                                                          ; on to 6 o'clock)
27197               
27198               B81:
27199 BB10 091D  18        srl  ra,1                       ; LSR A             ; Set CNT2 = A / 4
27200 BB12 091D  18        srl  ra,1                       ; LSR A
27201 BB14 D80D  30        movb ra,@CNT2                   ; STA CNT2
     BB16 00A5     
27202               
27203 BB18 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB1A FE2A     
27204               
27205               * ******************************************************************************
27206               *
27207               * Name: PLS5
27208               * Type: Subroutine
27209               * Category: Drawing planets
27210               * Summary: Calculate roofv_x / z and roofv_y / z
27211               *
27212               * ------------------------------------------------------------------------------
27213               *
27214               * Calculate the following divisions of a specified value from one of the
27215               * orientation vectors (in this example, roofv):
27216               *
27217               * (XX16+2 K2+2) = roofv_x / z
27218               *
27219               * (XX16+3 K2+3) = roofv_y / z
27220               *
27221               * ------------------------------------------------------------------------------
27222               *
27223               * Arguments:
27224               *
27225               * X                   Determines which of the INWK orientation vectors to
27226               * divide:
27227               *
27228               * * X = 15: divides roofv_x and roofv_y
27229               *
27230               * * X = 21: divides sidev_x and sidev_y
27231               *
27232               * INWK                The planet's ship data block
27233               *
27234               * ******************************************************************************
27235               
27236               PLS5:
27237 BB1C 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BB1E B3AC     
27238 BB20 06A0  32        bl   @jsr                       ;
     BB22 FE1E     
27239 BB24 D80D  30        movb ra,@K2+2                   ; STA K2+2          ;
     BB26 00AE     
27240 BB28 D80F  30        movb ry,@XX16+2                 ; STY XX16+2        ; K+2    = |roofv_x / z|
     BB2A 000B     
27241                                                                          ; XX16+2 = sign of roofv_x / z
27242                                                                          ;
27243                                                                          ; i.e. (XX16+2 K2+2) = roofv_x / z
27244                                                                          ;
27245                                                                          ; and increment X to point to roofv_y for the next call
27246               
27247 BB2C 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BB2E B3AC     
27248 BB30 06A0  32        bl   @jsr                       ;
     BB32 FE1E     
27249 BB34 D80D  30        movb ra,@K2+3                   ; STA K2+3          ;
     BB36 00AF     
27250 BB38 D80F  30        movb ry,@XX16+3                 ; STY XX16+3        ; K+3    = |roofv_y / z|
     BB3A 000C     
27251                                                                          ; XX16+3 = sign of roofv_y / z
27252                                                                          ;
27253                                                                          ; i.e. (XX16+3 K2+3) = roofv_y / z
27254                                                                          ;
27255                                                                          ; and increment X to point to roofv_z for the next call
27256               
27257 BB3C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB3E FE2A     
27258               
27259               * ******************************************************************************
27260               *
27261               * Name: PLS6
27262               * Type: Subroutine
27263               * Category: Drawing planets
27264               * Summary: Calculate (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27265               *
27266               * ------------------------------------------------------------------------------
27267               *
27268               * Calculate the following:
27269               *
27270               * (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27271               *
27272               * returning an overflow in the C flag if the result is >= 1024.
27273               *
27274               * ------------------------------------------------------------------------------
27275               *
27276               * Arguments:
27277               *
27278               * INWK                The planet or sun's ship data block
27279               *
27280               * ------------------------------------------------------------------------------
27281               *
27282               * Returns:
27283               *
27284               * C flag              Set if the result >= 1024, clear otherwise
27285               *
27286               * ------------------------------------------------------------------------------
27287               *
27288               * Other entry points:
27289               *
27290               * PL44                Clear the C flag and return from the subroutine
27291               *
27292               * ******************************************************************************
27293               
27294               PLS6:
27295 BB40 0200  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     BB42 45E8     
27296 BB44 06A0  32        bl   @jsr                       ;
     BB46 FE1E     
27297                                                                          ;
27298                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
27299               
27300 BB48 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set A = |K+3| OR K+2
     BB4A 0040     
27301 BB4C 024D  22        andi ra,>7f*256                 ; AND #%01111111
     BB4E 7F00     
27302 BB50 F360  30        socb @K+2,ra                    ; ORA K+2
     BB52 003F     
27303               
27304 BB54 16A8  14        jne  PL21                       ; BNE PL21          ; If A is non-zero then the two high bytes of K(3 2 1 0)
27305                                                                          ; are non-zero, so jump to PL21 to set the C flag and
27306                                                                          ; return from the subroutine
27307               
27308                                                                          ; We can now just consider K(1 0), as we know the top
27309                                                                          ; two bytes of K(3 2 1 0) are both 0
27310               
27311 BB56 D3A0  30        movb @K+1,rx                    ; LDX K+1           ; Set X = K+1, so now (X K) contains the result in
     BB58 003E     
27312                                                                          ; K(1 0), which is the format we want to return the
27313                                                                          ; result in
27314               
27315 BB5A 028E  22        ci   rx,>04*256                 ; CPX #4            ; If the high byte of K(1 0) >= 4 then the result is
     BB5C 0400     
27316 BB5E 1818  14        joc  PL6                        ; BCS PL6           ; >= 1024, so return from the subroutine with the C flag
27317                                                                          ; set to indicate an overflow (as PL6 contains an RTS)
27318               
27319 BB60 D360  30        movb @K+3,ra                    ; LDA K+3           ; Fetch the sign of the result from K+3 (which we know
     BB62 0040     
27320                                                                          ; has zeroes in bits 0-6, so this just fetches the sign)
27321               
27322               * CLC                    \ This instruction is commented out in the original
27323                                                                          ; source. It would have no effect as we know the C flag
27324                                                                          ; is already clear, as we skipped past the BCS above
27325               
27326 BB64 1515  14        jgt  PL6                        ; BPL PL6           ; If the sign bit is clear and the result is positive,
27327                                                                          ; then the result is already correct, so return from
27328                                                                          ; the subroutine with the C flag clear to indicate
27329                                                                          ; success (as PL6 contains an RTS)
27330               
27331 BB66 D360  30        movb @K,ra                      ; LDA K             ; Otherwise we need to negate the result, which we do
     BB68 003D     
27332                      .eoi (>ff*256)                  ; EOR #%11111111    ; using two's complement, starting with the low byte:
     **** ****     > EOI
0001 BB6A 0200  20        li   rtmp,(>FF*256)
     BB6C FF00     
0002 BB6E 2B40  18        xor  rtmp,ra
                   < elite.a99
27333                      .adi (>01*256)                  ; ADC #1            ;
     **** ****     > ADI
0001 BB70 1701  14        jnc  !
0002 BB72 B347  18        ab   rone,ra
0003               !:
0004 BB74 022D  22        ai   ra,(>01*256)
     BB76 0100     
                   < elite.a99
27334 BB78 D80D  30        movb ra,@K                      ; STA K             ; K = ~K + 1
     BB7A 003D     
27335               
27336 BB7C D34E  18        movb rx,ra                      ; TXA               ; And then the high byte:
27337                      .eoi (>ff*256)                  ; EOR #%11111111    ;
     **** ****     > EOI
0001 BB7E 0200  20        li   rtmp,(>FF*256)
     BB80 FF00     
0002 BB82 2B40  18        xor  rtmp,ra
                   < elite.a99
27338                      .adi (>00*256)                  ; ADC #0            ; X = ~X
     **** ****     > ADI
0001 BB84 1701  14        jnc  !
0002 BB86 B347  18        ab   rone,ra
0003               !:
0004 BB88 022D  22        ai   ra,(>00*256)
     BB8A 0000     
                   < elite.a99
27339 BB8C D38D  18        movb ra,rx                      ; TAX
27340               
27341               PL44:
27342                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 BB8E 0A16  18        sla  rzero,1
                   < elite.a99
27343               
27344               PL6:
27345 BB90 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BB92 FE2A     
27346               
27347               * ******************************************************************************
27348               *
27349               * Name: TT17
27350               * Type: Subroutine
27351               * Category: Keyboard
27352               * Summary: Scan the keyboard for cursor key or joystick movement
27353               *
27354               * ------------------------------------------------------------------------------
27355               *
27356               * Scan the keyboard and joystick for cursor key or stick movement, and return
27357               * the result as deltas (changes) in x- and y-coordinates as follows:
27358               *
27359               * * For joystick, X and Y are integers between -2 and +2 depending on how far
27360               * the stick has moved
27361               *
27362               * * For keyboard, X and Y are integers between -1 and +1 depending on which
27363               * keys are pressed
27364               *
27365               * ------------------------------------------------------------------------------
27366               *
27367               * Returns:
27368               *
27369               * A                   The key pressed, if the arrow keys were used
27370               *
27371               * X                   Change in the x-coordinate according to the cursor keys
27372               * being pressed or joystick movement, as an integer (see
27373               * above)
27374               *
27375               * Y                   Change in the y-coordinate according to the cursor keys
27376               * being pressed or joystick movement, as an integer (see
27377               * above)
27378               *
27379               * ******************************************************************************
27380               
27381               TT17:
27382 BB94 0200  20        li   rtmp,DOKEY                 ; JSR DOKEY         ; Scan the keyboard for flight controls and pause keys,
     BB96 CD0A     
27383 BB98 06A0  32        bl   @jsr                       ;
     BB9A FE1E     
27384                                                                          ; (or the equivalent on joystick) and update the key
27385                                                                          ; logger, setting KL to the key pressed
27386               
27387 BB9C D360  30        movb @JSTK,ra                   ; LDA JSTK          ; If the joystick is not configured, jump down to TJ1,
     BB9E 0F50     
27388 BBA0 132D  14        jeq  TJ1                        ; BEQ TJ1           ; otherwise we move the cursor with the joystick
27389               
27390 BBA2 D360  30        movb @JSTX,ra                   ; LDA JSTX          ; Fetch the joystick roll, ranging from 1 to 255 with
     BBA4 009C     
27391                                                                          ; 128 as the centre point
27392               
27393                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the sign so A = -JSTX, because the joystick roll
     **** ****     > EOI
0001 BBA6 0200  20        li   rtmp,(>FF*256)
     BBA8 FF00     
0002 BBAA 2B40  18        xor  rtmp,ra
                   < elite.a99
27394                                                                          ; works in the opposite way to moving a cursor on-screen
27395                                                                          ; in terms of left and right
27396               
27397 BBAC 0200  20        li   rtmp,TJS1                  ; JSR TJS1          ; Call TJS1 just below to set A to a value between -2
     BBAE BBBC     
27398 BBB0 06A0  32        bl   @jsr                       ;
     BBB2 FE1E     
27399                                                                          ; and +2 depending on the joystick roll value (moving
27400                                                                          ; the stick sideways)
27401               
27402 BBB4 D34F  18        movb ry,ra                      ; TYA               ; Copy Y to A
27403               
27404 BBB6 D38D  18        movb ra,rx                      ; TAX               ; Copy A to X, so X contains the joystick roll value
27405               
27406 BBB8 D360  30        movb @JSTY,ra                   ; LDA JSTY          ; Fetch the joystick pitch, ranging from 1 to 255 with
     BBBA 009D     
27407                                                                          ; 128 as the centre point, and fall through into TJS1 to
27408                                                                          ; set Y to the joystick pitch value (moving the stick up
27409                                                                          ; and down)
27410               
27411               TJS1:
27412 BBBC D3CD  18        movb ra,ry                      ; TAY               ; Store A in Y
27413               
27414 BBBE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the result, A = 0
     BBC0 0000     
27415               
27416 BBC2 028F  22        ci   ry,>10*256                 ; CPY #16           ; If Y >= 16 set the C flag, so A = A - 1
     BBC4 1000     
27417                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 BBC6 1801  14        joc  !
0002 BBC8 7347  18        sb   rone,ra
0003               !:
0004 BBCA 022D  22        ai   ra,-(>00*256)
     BBCC 0000     
                   < elite.a99
27418               
27419               * CPY #&20               \ These instructions are commented out in the original
27420               * SBC #0                 \ source, but they would make the joystick move the
27421                                                                          ; cursor faster by increasing the range of Y by -1 to +1
27422               
27423 BBCE 028F  22        ci   ry,>40*256                 ; CPY #64           ; If Y >= 64 set the C flag, so A = A - 1
     BBD0 4000     
27424                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 BBD2 1801  14        joc  !
0002 BBD4 7347  18        sb   rone,ra
0003               !:
0004 BBD6 022D  22        ai   ra,-(>00*256)
     BBD8 0000     
                   < elite.a99
27425               
27426 BBDA 028F  22        ci   ry,>c0*256                 ; CPY #192          ; If Y >= 192 set the C flag, so A = A + 1
     BBDC C000     
27427                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BBDE 1701  14        jnc  !
0002 BBE0 B347  18        ab   rone,ra
0003               !:
0004 BBE2 022D  22        ai   ra,(>00*256)
     BBE4 0000     
                   < elite.a99
27428               
27429 BBE6 028F  22        ci   ry,>e0*256                 ; CPY #224          ; If Y >= 224 set the C flag, so A = A + 1
     BBE8 E000     
27430                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BBEA 1701  14        jnc  !
0002 BBEC B347  18        ab   rone,ra
0003               !:
0004 BBEE 022D  22        ai   ra,(>00*256)
     BBF0 0000     
                   < elite.a99
27431               
27432               * CPY #&F0               \ These instructions are commented out in the original
27433               * ADC #0                 \ source, but they would make the joystick move the
27434                                                                          ; cursor faster by increasing the range of Y by -1 to +1
27435               
27436 BBF2 D3CD  18        movb ra,ry                      ; TAY               ; Copy the value of A into Y
27437               
27438 BBF4 D360  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     BBF6 0041     
27439               
27440 BBF8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BBFA FE2A     
27441               
27442               TJ1:
27443 BBFC D360  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     BBFE 0041     
27444               
27445 BC00 020E  20        li   rx,>00*256                 ; LDX #0            ; Set the initial values for the results, X = Y = 0,
     BC02 0000     
27446 BC04 020F  20        li   ry,>00*256                 ; LDY #0            ; which we now increase or decrease appropriately
     BC06 0000     
27447               
27448 BC08 028D  22        ci   ra,>19*256                 ; CMP #&19          ; If left arrow was pressed, set X = X - 1
     BC0A 1900     
27449 BC0C 1601  14        jne  B82                        ; BNE B82
27450 BC0E 7387  18        sb   rone,rx                    ; DEX
27451               
27452               B82:
27453 BC10 028D  22        ci   ra,>79*256                 ; CMP #&79          ; If right arrow was pressed, set X = X + 1
     BC12 7900     
27454 BC14 1601  14        jne  B83                        ; BNE B83
27455 BC16 B387  18        ab   rone,rx                    ; INX
27456               
27457               B83:
27458 BC18 028D  22        ci   ra,>39*256                 ; CMP #&39          ; If up arrow was pressed, set Y = Y + 1
     BC1A 3900     
27459 BC1C 1601  14        jne  B84                        ; BNE B84
27460 BC1E B3C7  18        ab   rone,ry                    ; INY
27461               
27462               B84:
27463 BC20 028D  22        ci   ra,>29*256                 ; CMP #&29          ; If down arrow was pressed, set Y = Y - 1
     BC22 2900     
27464 BC24 1601  14        jne  B85                        ; BNE B85
27465 BC26 73C7  18        sb   rone,ry                    ; DEY
27466               
27467               B85:
27468 BC28 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC2A FE2A     
27469               
27470               * ******************************************************************************
27471               *
27472               * Name: ping
27473               * Type: Subroutine
27474               * Category: Universe
27475               * Summary: Set the selected system to the current system
27476               *
27477               * ******************************************************************************
27478               
27479               ping_:
27480 BC2C 020E  20        li   rx,>01*256                 ; LDX #1            ; We want to copy the X- and Y-coordinates of the
     BC2E 0100     
27481                                                                          ; current system in (QQ0, QQ1) to the selected system's
27482                                                                          ; coordinates in (QQ9, QQ10), so set up a counter to
27483                                                                          ; copy two bytes
27484               
27485               pl1_:
27486 BC30 D36E  34        movb @QQ0(rx),ra                ; LDA QQ0,X         ; Load byte X from the current system in QQ0/QQ1
     BC32 0301     
27487               
27488 BC34 DB8D  38        movb ra,@QQ9(rx)                ; STA QQ9,X         ; Store byte X in the selected system in QQ9/QQ10
     BC36 0F31     
27489               
27490 BC38 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
27491               
27492 BC3A 15FA  14        jgt  pl1_                       ; BPL pl1           ; Loop back for the next byte to copy
27493               
27494 BC3C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC3E FE2A     
27495               
27496               * ******************************************************************************
27497               *
27498               * Save ELTE.bin
27499               *
27500               * ******************************************************************************
27501               
27502                      ; PRINT "ELITE E"
27503                      ; PRINT "Assembled at ", ~CODE_E%
27504                      ; PRINT "Ends at ", ~P%
27505                      ; PRINT "Code size is ", ~(P% - CODE_E%)
27506                      ; PRINT "Execute at ", ~LOAD%
27507                      ; PRINT "Reload at ", ~LOAD_E%
27508               
27509                      ; PRINT "S.ELTE ", ~CODE_E%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_E%
27510                      ; SAVE "3-assembled-output/ELTE.bin", CODE_E%, P%, LOAD%
27511               
27512               * ******************************************************************************
27513               *
27514               * ELITE F FILE
27515               *
27516               * Produces the binary file ELTF.bin that gets loaded by elite-bcfs.asm.
27517               *
27518               * ******************************************************************************
27519               
27520               CODE_F.:
27521                      equ $
27522               
27523               LOAD_F.:
27524                      equ LOAD. + $ - CODE.
27525               
27526               * ******************************************************************************
27527               *
27528               * Name: KS3
27529               * Type: Subroutine
27530               * Category: Universe
27531               * Summary: Set the SLSP ship line heap pointer after shuffling ship slots
27532               *
27533               * ------------------------------------------------------------------------------
27534               *
27535               * The final part of the KILLSHP routine, called after we have shuffled the ship
27536               * slots and sorted out our missiles. This simply sets SLSP to the new bottom of
27537               * the ship line heap.
27538               *
27539               * ------------------------------------------------------------------------------
27540               *
27541               * Arguments:
27542               *
27543               * P(1 0)              Points to the ship line heap of the ship in the last
27544               * occupied slot (i.e. it points to the bottom of the
27545               * descending heap)
27546               *
27547               * ******************************************************************************
27548               
27549               KS3:
27550 BC40 D360  30        movb @P,ra                      ; LDA P             ; After shuffling the ship slots, P(1 0) will point to
     BC42 001B     
27551 BC44 D80D  30        movb ra,@SLSP                   ; STA SLSP          ; the new bottom of the ship line heap, so store this in
     BC46 0F1E     
27552 BC48 D360  30        movb @P+1,ra                    ; LDA P+1           ; SLSP(1 0), which stores the bottom of the heap
     BC4A 001C     
27553 BC4C D80D  30        movb ra,@SLSP+1                 ; STA SLSP+1
     BC4E 0F1F     
27554               
27555 BC50 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC52 FE2A     
27556               
27557               * ******************************************************************************
27558               *
27559               * Name: KS1
27560               * Type: Subroutine
27561               * Category: Universe
27562               * Summary: Remove the current ship from our local bubble of universe
27563               *
27564               * ------------------------------------------------------------------------------
27565               *
27566               * Part 12 of the main flight loop calls this routine to remove the ship that is
27567               * currently being analysed by the flight loop. Once the ship is removed, it
27568               * jumps back to MAL1 to rejoin the main flight loop, with X pointing to the
27569               * same slot that we just cleared (and which now contains the next ship in the
27570               * local bubble of universe).
27571               *
27572               * ------------------------------------------------------------------------------
27573               *
27574               * Arguments:
27575               *
27576               * XX0                 The address of the blueprint for this ship
27577               *
27578               * INF                 The address of the data block for this ship
27579               *
27580               * ******************************************************************************
27581               
27582               KS1:
27583 BC54 D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Store the current ship's slot number in XSAV
     BC56 0093     
27584               
27585 BC58 0200  20        li   rtmp,KILLSHP               ; JSR KILLSHP       ; Call KILLSHP to remove the ship in slot X from our
     BC5A BD1C     
27586 BC5C 06A0  32        bl   @jsr                       ;
     BC5E FE1E     
27587                                                                          ; local bubble of universe
27588               
27589 BC60 D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the current ship's slot number from XSAV,
     BC62 0093     
27590                                                                          ; which now points to the next ship in the bubble
27591               
27592 BC64 0460  24        b    @MAL1                      ; JMP MAL1          ; Jump to MAL1 to rejoin the main flight loop at the
     BC66 118C     
27593                                                                          ; start of the ship analysis loop
27594               
27595               * ******************************************************************************
27596               *
27597               * Name: KS4
27598               * Type: Subroutine
27599               * Category: Universe
27600               * Summary: Remove the space station and replace it with the sun
27601               *
27602               * ******************************************************************************
27603               
27604               KS4:
27605 BC68 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     BC6A BFC0     
27606 BC6C 06A0  32        bl   @jsr                       ;
     BC6E FE1E     
27607               
27608 BC70 0200  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Reset the LSO block, returns with A = 0
     BC72 ACA6     
27609 BC74 06A0  32        bl   @jsr                       ;
     BC76 FE1E     
27610               
27611 BC78 D80D  30        movb ra,@FRIN+1                 ; STA FRIN+1        ; Set the second slot in the FRIN table to 0, which
     BC7A 0D41     
27612                                                                          ; sets this slot to empty, so when we call NWSHP below
27613                                                                          ; the new sun that gets created will go into FRIN+1
27614               
27615 BC7C D80D  30        movb ra,@SSPR                   ; STA SSPR          ; Set the "space station present" flag to 0, as we are
     BC7E 0D55     
27616                                                                          ; no longer in the space station's safe zone
27617               
27618 BC80 0200  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Call SPBLB to redraw the space station bulb, which
     BC82 B0E2     
27619 BC84 06A0  32        bl   @jsr                       ;
     BC86 FE1E     
27620                                                                          ; will erase it from the dashboard
27621               
27622 BC88 020D  20        li   ra,>06*256                 ; LDA #6            ; Set the sun's y_sign to 6
     BC8A 0600     
27623 BC8C D80D  30        movb ra,@INWK+5                 ; STA INWK+5
     BC8E 0058     
27624               
27625 BC90 020D  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     BC92 8100     
27626               
27627 BC94 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Call NWSHP to set up the sun's data block and add it
     BC96 AF7A     
27628                                                                          ; to FRIN, where it will get put in the second slot as
27629                                                                          ; we just cleared out the second slot, and the first
27630                                                                          ; slot is already taken by the planet
27631               
27632               * ******************************************************************************
27633               *
27634               * Name: KS2
27635               * Type: Subroutine
27636               * Category: Universe
27637               * Summary: Check the local bubble for missiles with target lock
27638               *
27639               * ------------------------------------------------------------------------------
27640               *
27641               * Check the local bubble of universe to see if there are any missiles with
27642               * target lock in the vicinity. If there are, then check their targets; if we
27643               * just removed their target in the KILLSHP routine, then switch off their AI so
27644               * they just drift in space, otherwise update their targets to reflect the newly
27645               * shuffled slot numbers.
27646               *
27647               * This is called from KILLSHP once the slots have been shuffled down, following
27648               * the removal of a ship.
27649               *
27650               * ------------------------------------------------------------------------------
27651               *
27652               * Arguments:
27653               *
27654               * XX4                 The slot number of the ship we removed just before
27655               * calling this routine
27656               *
27657               * ******************************************************************************
27658               
27659               KS2:
27660 BC98 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; We want to go through the ships in our local bubble
     BC9A FF00     
27661                                                                          ; and pick out all the missiles, so set X to &FF to
27662                                                                          ; use as a counter
27663               
27664               KSL4:
27665 BC9C B387  18        ab   rone,rx                    ; INX               ; Increment the counter (so it starts at 0 on the first
27666                                                                          ; iteration)
27667               
27668 BC9E D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; If slot X is empty then we have worked our way through
     BCA0 0D40     
27669 BCA2 13CE  14        jeq  KS3                        ; BEQ KS3           ; all the slots, so jump to KS3 to stop looking
27670               
27671 BCA4 028D  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If the slot does not contain a missile, loop back to
     BCA6 0900     
27672 BCA8 16F9  14        jne  KSL4                       ; BNE KSL4          ; KSL4 to check the next slot
27673               
27674                                                                          ; We have found a slot containing a missile, so now we
27675                                                                          ; want to check whether it has target lock
27676               
27677 BCAA D34E  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 and fetch the Y-th address from UNIV
27678                      .asla                           ; ASL A             ; and store it in SC and SC+1 - in other words, set
     **** ****     > ASLA
0001 BCAC 024D  22        andi ra,>ff00
     BCAE FF00     
0002 BCB0 0A1D  18        sla  ra,1
                   < elite.a99
27679 BCB2 D3CD  18        movb ra,ry                      ; TAY               ; SC(1 0) to point to the missile's ship data block
27680 BCB4 D36F  34        movb @UNIV(ry),ra               ; LDA UNIV,Y
     BCB6 221F     
27681 BCB8 D80D  30        movb ra,@SC                     ; STA SC
     BCBA 0007     
27682 BCBC D36F  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     BCBE 2220     
27683 BCC0 D80D  30        movb ra,@SC+1                   ; STA SC+1
     BCC2 0008     
27684               
27685 BCC4 020F  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 from the missile's ship data (AI)
     BCC6 2000     
27686                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y
     **** ****     > LD_IND_Y_IDX
0001 BCC8 D820  50        movb @SC,@rtmplb
     BCCA 0007     
     BCCC 206D     
0002 BCCE D020  30        movb @SC+1,rtmp
     BCD0 0008     
0003 BCD2 A00F  18        a    ry,rtmp
0004 BCD4 D350  26        movb *rtmp,RA
                   < elite.a99
27687               
27688 BCD6 15E2  14        jgt  KSL4                       ; BPL KSL4          ; If bit 7 of byte #32 is clear, then the missile is
27689                                                                          ; dumb and has no AI, so loop back to KSL4 to move on
27690                                                                          ; to the next slot
27691               
27692 BCD8 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Otherwise this missile has AI, so clear bit 7 and
     BCDA 7F00     
27693 BCDC 091D  18        srl  ra,1                       ; LSR A             ; shift right to set the C flag to the missile's "is
27694                                                                          ; locked" flag, and A to the target's slot number
27695               
27696 BCDE 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If this missile's target is less than XX4, then the
     BCE0 00A7     
27697 BCE2 17DC  14        jnc  KSL4                       ; BCC KSL4          ; target's slot isn't being shuffled down, so jump to
27698                                                                          ; KSL4 to move on to the next slot
27699               
27700 BCE4 1311  14        jeq  KS6                        ; BEQ KS6           ; If this missile was locked onto the ship that we just
27701                                                                          ; removed in KILLSHP, jump to KS6 to stop the missile
27702                                                                          ; from continuing to hunt it down
27703               
27704                      .sbi (>01*256)                  ; SBC #1            ; Otherwise this missile is locked and has AI enabled,
     **** ****     > SBI
0001 BCE6 1801  14        joc  !
0002 BCE8 7347  18        sb   rone,ra
0003               !:
0004 BCEA 022D  22        ai   ra,-(>01*256)
     BCEC FF00     
                   < elite.a99
27705                                                                          ; and its target will have moved down a slot, so
27706                                                                          ; subtract 1 from the target number (we know C is set
27707                                                                          ; from the BCC above)
27708               
27709                      .asla                           ; ASL A             ; Shift the target number left by 1, so it's in bits
     **** ****     > ASLA
0001 BCEE 024D  22        andi ra,>ff00
     BCF0 FF00     
0002 BCF2 0A1D  18        sla  ra,1
                   < elite.a99
27710                                                                          ; 1-6 once again, and also set bit 0 to 1, as the C
27711                                                                          ; flag is still set, so this makes sure the missile is
27712                                                                          ; still set to being locked
27713               
27714 BCF4 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7, so the missile's AI is enabled
     BCF6 8000     
27715               
27716                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Update the missile's AI flag to the value in A
     **** ****     > ST_IND_Y_IDX
0001 BCF8 D820  50        movb @SC,@rtmplb
     BCFA 0007     
     BCFC 206D     
0002 BCFE D020  30        movb @SC+1,rtmp
     BD00 0008     
0003 BD02 A00F  18        a    ry,rtmp
0004 BD04 D40D  30        movb RA,*rtmp
                   < elite.a99
27717               
27718 BD06 16CA  14        jne  KSL4                       ; BNE KSL4          ; Loop back to KSL4 to move on to the next slot (this
27719                                                                          ; BNE is effectively a JMP as A will never be zero)
27720               
27721               KS6:
27722 BD08 020D  20        li   ra,>00*256                 ; LDA #0            ; The missile's target lock just got removed, so set the
     BD0A 0000     
27723                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; AI flag to 0 to make it dumb and not locked
     **** ****     > ST_IND_Y_IDX
0001 BD0C D820  50        movb @SC,@rtmplb
     BD0E 0007     
     BD10 206D     
0002 BD12 D020  30        movb @SC+1,rtmp
     BD14 0008     
0003 BD16 A00F  18        a    ry,rtmp
0004 BD18 D40D  30        movb RA,*rtmp
                   < elite.a99
27724               
27725 BD1A 13C0  14        jeq  KSL4                       ; BEQ KSL4          ; Loop back to KSL4 to move on to the next slot (this
27726                                                                          ; BEQ is effectively a JMP as A is always zero)
27727               
27728               * ******************************************************************************
27729               *
27730               * Name: KILLSHP
27731               * Type: Subroutine
27732               * Category: Universe
27733               * Summary: Remove a ship from our local bubble of universe
27734               *
27735               * ------------------------------------------------------------------------------
27736               *
27737               * Remove the ship in slot X from our local bubble of universe. This happens
27738               * when we kill a ship, collide with a ship and destroy it, or when a ship moves
27739               * outside our local bubble.
27740               *
27741               * We also use this routine when we move out of range of the space station, in
27742               * which case we replace it with the sun.
27743               *
27744               * When removing a ship, this creates a gap in the ship slots at FRIN, so we
27745               * shuffle all the later slots down to close the gap. We also shuffle the ship
27746               * data blocks at K% and ship line heap at WP, to reclaim all the memory that
27747               * the removed ship used to occupy.
27748               *
27749               * ------------------------------------------------------------------------------
27750               *
27751               * Arguments:
27752               *
27753               * X                   The slot number of the ship to remove
27754               *
27755               * XX0                 The address of the blueprint for the ship to remove
27756               *
27757               * INF                 The address of the data block for the ship to remove
27758               *
27759               * ******************************************************************************
27760               
27761               KILLSHP:
27762 BD1C D80E  30        movb rx,@XX4                    ; STX XX4           ; Store the slot number of the ship to remove in XX4
     BD1E 00A7     
27763               
27770               
27771 BD20 93A0  30        cb   @MSTG,rx                   ; CPX MSTG          ; Check whether this slot matches the slot number in
     BD22 0052     
27772                                                                          ; MSTG, which is the target of our missile lock
27773                                                                          ;
27774                                                                          ; This instructions saves two bytes of memory over the
27775                                                                          ; LDA and CMP-based code in the source disc version, as
27776                                                                          ; CPX MSTG is a two-byte opcode, while LDA MSTG and
27777                                                                          ; CMP XX4 take up four bytes between them (the code does
27778                                                                          ; the same thing)
27779               
27781               
27782 BD24 160C  14        jne  KS5                        ; BNE KS5           ; If our missile is not locked on this ship, jump to KS5
27783               
27784 BD26 020F  20        li   ry,>ee*256                 ; LDY #&EE          ; Otherwise we need to remove our missile lock, so call
     BD28 EE00     
27785 BD2A 0200  20        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     BD2C B0A2     
27786 BD2E 06A0  32        bl   @jsr                       ;
     BD30 FE1E     
27787                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
27788               
27789 BD32 020D  20        li   ra,>c8*256                 ; LDA #200          ; Print recursive token 40 ("TARGET LOST") as an
     BD34 C800     
27790 BD36 0200  20        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     BD38 CE5E     
27791 BD3A 06A0  32        bl   @jsr                       ;
     BD3C FE1E     
27792               
27793               KS5:
27794 BD3E D3E0  30        movb @XX4,ry                    ; LDY XX4           ; Restore the slot number of the ship to remove into Y
     BD40 00A7     
27795               
27796 BD42 D3AF  34        movb @FRIN(ry),rx               ; LDX FRIN,Y        ; Fetch the contents of the slot, which contains the
     BD44 0D40     
27797                                                                          ; ship type
27798               
27799 BD46 028E  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is the space station, then jump to KS4 to
     BD48 0800     
27800 BD4A 138E  14        jeq  KS4                        ; BEQ KS4           ; replace the space station with the sun
27801               
27802 BD4C 7347  18        sb   rone,ra                    ; DEC MANY,X        ; Decrease the number of this type of ship in our little
27803                                                                          ; bubble, which is stored in MANY+X (where X is the ship
27804                                                                          ; type)
27805               
27806 BD4E D3A0  30        movb @XX4,rx                    ; LDX XX4           ; Restore the slot number of the ship to remove into X
     BD50 00A7     
27807               
27808                                                                          ; We now want to remove this ship and reclaim all the
27809                                                                          ; memory that it uses. Removing the ship will leave a
27810                                                                          ; gap in three places, which we need to close up:
27811                                                                          ;
27812                                                                          ; * The ship slots in FRIN
27813                                                                          ;
27814                                                                          ; * The ship data blocks in K%
27815                                                                          ;
27816                                                                          ; * The descending ship line heap at WP down
27817                                                                          ;
27818                                                                          ; The rest of this routine closes up these gaps by
27819                                                                          ; looping through all the occupied ship slots after the
27820                                                                          ; slot we are removing, one by one, and shuffling each
27821                                                                          ; ship's slot, data block and line heap down to close
27822                                                                          ; up the gaps left by the removed ship. As part of this,
27823                                                                          ; we have to make sure we update any address pointers
27824                                                                          ; so they point to the newly shuffled data blocks and
27825                                                                          ; line heaps
27826                                                                          ;
27827                                                                          ; In the following, when shuffling a ship's data down
27828                                                                          ; into the preceding empty slot, we call the ship that
27829                                                                          ; we are shuffling down the "source", and we call the
27830                                                                          ; empty slot we are shuffling it into the "destination"
27831                                                                          ;
27832                                                                          ; Before we start looping through the ships we need to
27833                                                                          ; shuffle down, we need to set up some variables to
27834                                                                          ; point to the source and destination line heaps
27835               
27836 BD52 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the removed ship's blueprint into A,
     BD54 0500     
27837                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; which gives the ship's maximum heap size for the ship
     **** ****     > LD_IND_Y_IDX
0001 BD56 D820  50        movb @XX0,@rtmplb
     BD58 001E     
     BD5A 206D     
0002 BD5C D020  30        movb @XX0+1,rtmp
     BD5E 001F     
0003 BD60 A00F  18        a    ry,rtmp
0004 BD62 D350  26        movb *rtmp,RA
                   < elite.a99
27838                                                                          ; we are removing (i.e. the size of the gap in the heap
27839                                                                          ; created by the ship removal)
27840               
27841                                                                          ; INF currently contains the ship data for the ship we
27842                                                                          ; are removing, and INF(34 33) contains the address of
27843                                                                          ; the bottom of the ship's heap, so we can calculate
27844                                                                          ; the address of the top of the heap by adding the heap
27845                                                                          ; size to this address
27846               
27847 BD64 020F  20        li   ry,>21*256                 ; LDY #33           ; First we add A and the address in INF+33, to get the
     BD66 2100     
27848                      .clc                            ; CLC               ; low byte of the top of the heap, which we store in P
     **** ****     > CLC
0001 BD68 0A16  18        sla  rzero,1
                   < elite.a99
27849                      .adc_ind_y_idx @INF,ra          ; ADC (INF),Y
     **** ****     > ADC_IND_Y_IDX
0001 BD6A 04CD  14        clr  ra
0002 BD6C 1701  14        jnc  !
0003 BD6E B347  18        ab   rone,ra
0004               !:
0005 BD70 D820  50        movb @INF,@rtmplb
     BD72 0020     
     BD74 206D     
0006 BD76 D020  30        movb @INF+1,rtmp
     BD78 0021     
0007 BD7A A00F  18        a    ry,rtmp
0008 BD7C B350  26        ab   *rtmp,ra
                   < elite.a99
27850 BD7E D80D  30        movb ra,@P                      ; STA P
     BD80 001B     
27851               
27852 BD82 B3C7  18        ab   rone,ry                    ; INY               ; And next we add A and the address in INF+34, with any
27853                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; carry from the previous addition, to get the high byte
     **** ****     > LD_IND_Y_IDX
0001 BD84 D820  50        movb @INF,@rtmplb
     BD86 0020     
     BD88 206D     
0002 BD8A D020  30        movb @INF+1,rtmp
     BD8C 0021     
0003 BD8E A00F  18        a    ry,rtmp
0004 BD90 D350  26        movb *rtmp,RA
                   < elite.a99
27854                      .adi (>00*256)                  ; ADC #0            ; of the top of the heap, which we store in P+1, so
     **** ****     > ADI
0001 BD92 1701  14        jnc  !
0002 BD94 B347  18        ab   rone,ra
0003               !:
0004 BD96 022D  22        ai   ra,(>00*256)
     BD98 0000     
                   < elite.a99
27855 BD9A D80D  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) points to the top of this ship's heap
     BD9C 001C     
27856               
27857                                                                          ; Now, we're ready to start looping through the ships
27858                                                                          ; we want to move, moving the slots, data blocks and
27859                                                                          ; line heap from the source to the destination. In the
27860                                                                          ; following, we set up SC to point to the source data,
27861                                                                          ; and INF (which currently points to the removed ship's
27862                                                                          ; data that we can now overwrite) points to the
27863                                                                          ; destination
27864                                                                          ;
27865                                                                          ; So P(1 0) now points to the top of the line heap for
27866                                                                          ; the destination
27867               
27868               KSL1:
27869 BD9E B387  18        ab   rone,rx                    ; INX               ; On entry, X points to the empty slot we want to
27870                                                                          ; shuffle the next ship into (the destination), so
27871                                                                          ; this increment points X to the next slot - i.e. the
27872                                                                          ; source slot we want to shuffle down
27873               
27874 BDA0 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Copy the contents of the source slot into the
     BDA2 0D40     
27875 BDA4 DB8D  38        movb ra,@FRIN-1(rx)             ; STA FRIN-1,X      ; destination slot
     BDA6 0D3F     
27876               
27877 BDA8 1602  14        jne  FIX009                     ; BNE FIX009        ; If the slot we just shuffled down contains 0, then
27878 BDAA 0460  28        b    @KS2                       ; JMP KS2           ; the source slot is empty and we are done shuffling,
     BDAC BC98     
27879                                                                          ; so jump to KS2 to move on to processing missiles
27880               FIX009:
27881                      .asla                           ; ASL A             ; Otherwise we have a source ship to shuffle down into
     **** ****     > ASLA
0001 BDAE 024D  22        andi ra,>ff00
     BDB0 FF00     
0002 BDB2 0A1D  18        sla  ra,1
                   < elite.a99
27882 BDB4 D3CD  18        movb ra,ry                      ; TAY               ; the destination, so set Y = A * 2 so it can act as an
27883                                                                          ; index into the two-byte ship blueprint lookup table
27884                                                                          ; at XX21 for the source ship
27885               
27886 BDB6 D36F  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; Set SC(0 1) to point to the blueprint data for the
     BDB8 E7E0     
27887 BDBA D80D  30        movb ra,@SC                     ; STA SC            ; source ship
     BDBC 0007     
27888 BDBE D36F  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y
     BDC0 E7E1     
27889 BDC2 D80D  30        movb ra,@SC+1                   ; STA SC+1
     BDC4 0008     
27890               
27891 BDC6 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch blueprint byte #5 for the source ship, which
     BDC8 0500     
27892                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; gives us its maximum heap size, and store it in T
     **** ****     > LD_IND_Y_IDX
0001 BDCA D820  50        movb @SC,@rtmplb
     BDCC 0007     
     BDCE 206D     
0002 BDD0 D020  30        movb @SC+1,rtmp
     BDD2 0008     
0003 BDD4 A00F  18        a    ry,rtmp
0004 BDD6 D350  26        movb *rtmp,RA
                   < elite.a99
27893 BDD8 D80D  30        movb ra,@T                      ; STA T
     BDDA 00D1     
27894               
27895                                                                          ; We now subtract T from P(1 0), so P(1 0) will point to
27896                                                                          ; the bottom of the line heap for the destination
27897                                                                          ; (which we will use later when closing up the gap in
27898                                                                          ; the heap space)
27899               
27900 BDDC D360  30        movb @P,ra                      ; LDA P             ; First, we subtract the low bytes
     BDDE 001B     
27901                      .sec                            ; SEC
     **** ****     > SEC
0001 BDE0 0A18  18        sla  rmone,1
                   < elite.a99
27902                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 BDE2 1801  14        joc  !
0002 BDE4 7347  18        sb   rone,ra
0003               !:
0004 BDE6 7360  30        sb   @T,ra
     BDE8 00D1     
                   < elite.a99
27903 BDEA D80D  30        movb ra,@P                      ; STA P
     BDEC 001B     
27904               
27905 BDEE D360  30        movb @P+1,ra                    ; LDA P+1           ; And then we do the high bytes, for which we subtract
     BDF0 001C     
27906                      .sbi (>00*256)                  ; SBC #0            ; 0 to include any carry, so this is effectively doing
     **** ****     > SBI
0001 BDF2 1801  14        joc  !
0002 BDF4 7347  18        sb   rone,ra
0003               !:
0004 BDF6 022D  22        ai   ra,-(>00*256)
     BDF8 0000     
                   < elite.a99
27907 BDFA D80D  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) = P(1 0) - (0 T)
     BDFC 001C     
27908               
27909                                                                          ; Next, we want to set SC(1 0) to point to the source
27910                                                                          ; ship's data block
27911               
27912 BDFE D34E  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 so it can act as an index into the
27913                      .asla                           ; ASL A             ; two-byte lookup table at UNIV, which contains the
     **** ****     > ASLA
0001 BE00 024D  22        andi ra,>ff00
     BE02 FF00     
0002 BE04 0A1D  18        sla  ra,1
                   < elite.a99
27914 BE06 D3CD  18        movb ra,ry                      ; TAY               ; addresses of the ship data blocks. In this case we are
27915                                                                          ; multiplying X by 2, and X contains the source ship's
27916                                                                          ; slot number so Y is now an index for the source ship's
27917                                                                          ; entry in UNIV
27918               
27919 BE08 D36F  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Set SC(1 0) to the address of the data block for the
     BE0A 221F     
27920 BE0C D80D  30        movb ra,@SC                     ; STA SC            ; source ship
     BE0E 0007     
27921 BE10 D36F  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     BE12 2220     
27922 BE14 D80D  30        movb ra,@SC+1                   ; STA SC+1
     BE16 0008     
27923               
27924                                                                          ; We have now set up our variables as follows:
27925                                                                          ;
27926                                                                          ; SC(1 0) points to the source's ship data block
27927                                                                          ;
27928                                                                          ; INF(1 0) points to the destination's ship data block
27929                                                                          ;
27930                                                                          ; P(1 0) points to the destination's line heap
27931                                                                          ;
27932                                                                          ; so let's start copying data from the source to the
27933                                                                          ; destination
27934               
27935 BE18 020F  20        li   ry,>23*256                 ; LDY #35           ; We are going to be using Y as a counter for the 36
     BE1A 2300     
27936                                                                          ; bytes of ship data we want to copy from the source
27937                                                                          ; to the destination, so we set it to 35 to start things
27938                                                                          ; off, and will decrement Y for each byte we copy
27939               
27940                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Fetch byte #35 of the source's ship data block at SC,
     **** ****     > LD_IND_Y_IDX
0001 BE1C D820  50        movb @SC,@rtmplb
     BE1E 0007     
     BE20 206D     
0002 BE22 D020  30        movb @SC+1,rtmp
     BE24 0008     
0003 BE26 A00F  18        a    ry,rtmp
0004 BE28 D350  26        movb *rtmp,RA
                   < elite.a99
27941                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; and store it in byte #35 of the destination's block
     **** ****     > ST_IND_Y_IDX
0001 BE2A D820  50        movb @INF,@rtmplb
     BE2C 0020     
     BE2E 206D     
0002 BE30 D020  30        movb @INF+1,rtmp
     BE32 0021     
0003 BE34 A00F  18        a    ry,rtmp
0004 BE36 D40D  30        movb RA,*rtmp
                   < elite.a99
27942                                                                          ; at INF, so that's the ship's energy copied from the
27943                                                                          ; source to the destination. One down, quite a few to
27944                                                                          ; go...
27945               
27946 BE38 73C7  18        sb   rone,ry                    ; DEY               ; Fetch byte #34 of the source ship, which is the
27947                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; high byte of the source ship's line heap, and store
     **** ****     > LD_IND_Y_IDX
0001 BE3A D820  50        movb @SC,@rtmplb
     BE3C 0007     
     BE3E 206D     
0002 BE40 D020  30        movb @SC+1,rtmp
     BE42 0008     
0003 BE44 A00F  18        a    ry,rtmp
0004 BE46 D350  26        movb *rtmp,RA
                   < elite.a99
27948 BE48 D80D  30        movb ra,@K+1                    ; STA K+1           ; in K+1
     BE4A 003E     
27949               
27950 BE4C D360  30        movb @P+1,ra                    ; LDA P+1           ; Set the low byte of the destination's heap pointer
     BE4E 001C     
27951                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P+1
     **** ****     > ST_IND_Y_IDX
0001 BE50 D820  50        movb @INF,@rtmplb
     BE52 0020     
     BE54 206D     
0002 BE56 D020  30        movb @INF+1,rtmp
     BE58 0021     
0003 BE5A A00F  18        a    ry,rtmp
0004 BE5C D40D  30        movb RA,*rtmp
                   < elite.a99
27952               
27953 BE5E 73C7  18        sb   rone,ry                    ; DEY               ; Fetch byte #33 of the source ship, which is the
27954                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; low byte of the source ship's heap, and store in K
     **** ****     > LD_IND_Y_IDX
0001 BE60 D820  50        movb @SC,@rtmplb
     BE62 0007     
     BE64 206D     
0002 BE66 D020  30        movb @SC+1,rtmp
     BE68 0008     
0003 BE6A A00F  18        a    ry,rtmp
0004 BE6C D350  26        movb *rtmp,RA
                   < elite.a99
27955 BE6E D80D  30        movb ra,@K                      ; STA K             ; so now we have the following:
     BE70 003D     
27956                                                                          ;
27957                                                                          ; K(1 0) points to the source's line heap
27958               
27959 BE72 D360  30        movb @P,ra                      ; LDA P             ; Set the low byte of the destination's heap pointer
     BE74 001B     
27960                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P, so now the destination's heap pointer is to
     **** ****     > ST_IND_Y_IDX
0001 BE76 D820  50        movb @INF,@rtmplb
     BE78 0020     
     BE7A 206D     
0002 BE7C D020  30        movb @INF+1,rtmp
     BE7E 0021     
0003 BE80 A00F  18        a    ry,rtmp
0004 BE82 D40D  30        movb RA,*rtmp
                   < elite.a99
27961                                                                          ; P(1 0), so that's the heap pointer in bytes #33 and
27962                                                                          ; #34 done
27963               
27964 BE84 73C7  18        sb   rone,ry                    ; DEY               ; Luckily, we can just copy the rest of the source's
27965                                                                          ; ship data block into the destination, as there are no
27966                                                                          ; more address pointers, so first we decrement our
27967                                                                          ; counter in Y to point to the next byte (the AI flag)
27968                                                                          ; in byte #32) and then start looping
27969               
27970               KSL2:
27971                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Copy the Y-th byte of the source to the Y-th byte of
     **** ****     > LD_IND_Y_IDX
0001 BE86 D820  50        movb @SC,@rtmplb
     BE88 0007     
     BE8A 206D     
0002 BE8C D020  30        movb @SC+1,rtmp
     BE8E 0008     
0003 BE90 A00F  18        a    ry,rtmp
0004 BE92 D350  26        movb *rtmp,RA
                   < elite.a99
27972                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the destination
     **** ****     > ST_IND_Y_IDX
0001 BE94 D820  50        movb @INF,@rtmplb
     BE96 0020     
     BE98 206D     
0002 BE9A D020  30        movb @INF+1,rtmp
     BE9C 0021     
0003 BE9E A00F  18        a    ry,rtmp
0004 BEA0 D40D  30        movb RA,*rtmp
                   < elite.a99
27973               
27974 BEA2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
27975               
27976 BEA4 15F0  14        jgt  KSL2                       ; BPL KSL2          ; Loop back to KSL2 to copy the next byte until we have
27977                                                                          ; copied the whole block
27978               
27979                                                                          ; We have now shuffled the ship's slot and the ship's
27980                                                                          ; data block, so we only have the heap data itself to do
27981               
27982 BEA6 D360  30        movb @SC,ra                     ; LDA SC            ; First, we copy SC into INF, so when we loop round
     BEA8 0007     
27983 BEAA D80D  30        movb ra,@INF                    ; STA INF           ; again, INF will correctly point to the destination for
     BEAC 0020     
27984 BEAE D360  30        movb @SC+1,ra                   ; LDA SC+1          ; the next iteration
     BEB0 0008     
27985 BEB2 D80D  30        movb ra,@INF+1                  ; STA INF+1
     BEB4 0021     
27986               
27987 BEB6 D3E0  30        movb @T,ry                      ; LDY T             ; Now we want to move the contents of the heap, as all
     BEB8 00D1     
27988                                                                          ; we did above was to update the pointers, so first
27989                                                                          ; we set a counter in Y that is initially set to T
27990                                                                          ; (which we set above to the maximum heap size for the
27991                                                                          ; source ship)
27992                                                                          ;
27993                                                                          ; As a reminder, we have already set the following:
27994                                                                          ;
27995                                                                          ; K(1 0) points to the source's line heap
27996                                                                          ;
27997                                                                          ; P(1 0) points to the destination's line heap
27998                                                                          ;
27999                                                                          ; so we can move the heap data by simply copying the
28000                                                                          ; correct number of bytes from K(1 0) to P(1 0)
28001               KSL3:
28002 BEBA 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
28003               
28004                      .ld_ind_y_idx @K,ra             ; LDA (K),Y         ; Copy the Y-th byte of the source heap at K(1 0) to
     **** ****     > LD_IND_Y_IDX
0001 BEBC D820  50        movb @K,@rtmplb
     BEBE 003D     
     BEC0 206D     
0002 BEC2 D020  30        movb @K+1,rtmp
     BEC4 003E     
0003 BEC6 A00F  18        a    ry,rtmp
0004 BEC8 D350  26        movb *rtmp,RA
                   < elite.a99
28005                      .st_ind_y_idx @P,ra             ; STA (P),Y         ; the destination heap at P(1 0)
     **** ****     > ST_IND_Y_IDX
0001 BECA D820  50        movb @P,@rtmplb
     BECC 001B     
     BECE 206D     
0002 BED0 D020  30        movb @P+1,rtmp
     BED2 001C     
0003 BED4 A00F  18        a    ry,rtmp
0004 BED6 D40D  30        movb RA,*rtmp
                   < elite.a99
28006               
28007 BED8 D34F  18        movb ry,ra                      ; TYA               ; Loop back to KSL3 to copy the next byte, until we
28008 BEDA 16EF  14        jne  KSL3                       ; BNE KSL3          ; have done them all
28009               
28010 BEDC 1602  14        jne  FIX010                     ; BNE FIX010        ; We have now shuffled everything down one slot, so
28011 BEDE 0460  28        b    @KSL1                      ; JMP KSL1          ; jump back up to KSL1 to see if there is another slot
     BEE0 BD9E     
28012                                                                          ; that needs shuffling down (this BEQ is effectively a
28013                                                                          ; JMP as A will always be zero)
28014               FIX010:
28015               * ******************************************************************************
28016               *
28017               * Name: SFX
28018               * Type: Variable
28019               * Category: Sound
28020               * Summary: Sound data
28021               *
28022               * ------------------------------------------------------------------------------
28023               *
28024               * Sound data. To make a sound, the NOS1 routine copies the four relevant sound
28025               * bytes to XX16, and NO3 then makes the sound. The sound numbers are shown in
28026               * the table, and are always multiples of 8. Generally, sounds are made by
28027               * calling the NOISE routine with the sound number in A.
28028               *
28029               * These bytes are passed to OSWORD 7, and are the equivalents to the parameters
28030               * passed to the SOUND keyword in BASIC. The parameters therefore have these
28031               * meanings:
28032               *
28033               * channel/flush, amplitude (or envelope number if 1-4), pitch, duration
28034               *
28035               * For the channel/flush parameter, the high nibble of the low byte is the flush
28036               * control (where a flush control of 0 queues the sound, and a flush control of
28037               * 1 makes the sound instantly), while the low nibble of the low byte is the
28038               * channel number. When written in hexadecimal, the first figure gives the flush
28039               * control, while the second is the channel (so &13 indicates flush control = 1
28040               * and channel = 3).
28041               *
28042               * So when we call NOISE with A = 40 to make a long, low beep, then this is
28043               * effectively what the NOISE routine does:
28044               *
28045               * SOUND &13, &F4, &0C, &08
28046               *
28047               * which makes a sound with flush control 1 on channel 3, and with amplitude &F4
28048               * (-12), pitch &0C (2) and duration &08 (8). Meanwhile, to make the hyperspace
28049               * sound, the NOISE routine does this:
28050               *
28051               * SOUND &10, &02, &60, &10
28052               *
28053               * which makes a sound with flush control 1 on channel 0, using envelope 2,
28054               * and with pitch &60 (96) and duration &10 (16). The four sound envelopes (1-4)
28055               * are set up by the loading process.
28056               *
28057               * ******************************************************************************
28058                      equ  $
28059               SFX:
28060 BEE2 1201            byte >12,>01,>00,>10                                ; 0  - Lasers fired by us
     BEE4 0010     
28061 BEE6 1202            byte >12,>02,>2c,>08                                ; 8  - We're being hit by lasers
     BEE8 2C08     
28062 BEEA 1103            byte >11,>03,>f0,>18                                ; 16 - We died 1 / We made a hit or kill 2
     BEEC F018     
28063 BEEE 10F1            byte >10,>f1,>07,>1a                                ; 24 - We died 2 / We made a hit or kill 1
     BEF0 071A     
28064 BEF2 03F1            byte >03,>f1,>bc,>01                                ; 32 - Short, high beep
     BEF4 BC01     
28065 BEF6 13F4            byte >13,>f4,>0c,>08                                ; 40 - Long, low beep
     BEF8 0C08     
28066 BEFA 10F1            byte >10,>f1,>06,>0c                                ; 48 - Missile launched / Ship launched from station
     BEFC 060C     
28067 BEFE 1002            byte >10,>02,>60,>10                                ; 56 - Hyperspace drive engaged
     BF00 6010     
28068 BF02 1304            byte >13,>04,>c2,>ff                                ; 64 - E.C.M. on
     BF04 C2FF     
28069 BF06 1300            byte >13,>00,>00,>00                                ; 72 - E.C.M. off
     BF08 0000     
28070               
28071               * ******************************************************************************
28072               *
28073               * Name: RESET
28074               * Type: Subroutine
28075               * Category: Start and end
28076               * Summary: Reset most variables
28077               *
28078               * ------------------------------------------------------------------------------
28079               *
28080               * Reset our ship and various controls, recharge shields and energy, and then
28081               * fall through into RES2 to reset the stardust and the ship workspace at INWK.
28082               *
28083               * In this subroutine, this means zero-filling the following locations:
28084               *
28085               * * Pages &9, &A, &B, &C and &D
28086               *
28087               * * BETA to BETA+6, which covers the following:
28088               *
28089               * * BETA, BET1 - Set pitch to 0
28090               *
28091               * * XC, YC - Set text cursor to (0, 0)
28092               *
28093               * * QQ22 - Set hyperspace counters to 0
28094               *
28095               * * ECMA - Turn E.C.M. off
28096               *
28097               * It also sets QQ12 to &FF, to indicate we are docked, recharges the shields and
28098               * energy banks, and then falls through into RES2.
28099               *
28100               * ------------------------------------------------------------------------------
28101               *
28102               * Other entry points:
28103               *
28104               * RES4                Reset the shields and energy banks, then fall through
28105               * into RES2 to reset the stardust and the ship workspace
28106               * at INWK
28107               *
28108               * ******************************************************************************
28109               
28110               RESET:
28111 BF0A 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     BF0C C80A     
28112 BF0E 06A0  32        bl   @jsr                       ;
     BF10 FE1E     
28113                                                                          ; the ship data blocks, the ship line heap, the ship
28114                                                                          ; slots for the local bubble of universe, and various
28115                                                                          ; flight and ship status variables
28116               
28117 BF12 020E  20        li   rx,>06*256                 ; LDX #6            ; Set up a counter for zeroing BETA through BETA+6
     BF14 0600     
28118               
28119               SAL3:
28120 BF16 DB8D  38        movb ra,@BETA(rx)               ; STA BETA,X        ; Zero the X-th byte after BETA
     BF18 002A     
28121               
28122 BF1A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28123               
28124 BF1C 15FC  14        jgt  SAL3                       ; BPL SAL3          ; Loop back for the next byte to zero
28125               
28126 BF1E D80E  30        movb rx,@QQ12                   ; STX QQ12          ; X is now negative - i.e. &FF - so this sets QQ12 to
     BF20 009F     
28127                                                                          ; &FF to indicate we are docked
28128               
28129                                                                          ; We now fall through into RES4 to restore shields and
28130                                                                          ; energy, and reset the stardust and ship workspace at
28131                                                                          ; INWK
28132               
28133               RES4:
28134 BF22 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can fill up the shields and energy
     BF24 FF00     
28135                                                                          ; bars with a full charge
28136               
28137 BF26 020E  20        li   rx,>02*256                 ; LDX #2            ; We're now going to recharge both shields and the
     BF28 0200     
28138                                                                          ; energy bank, which live in the three bytes at FSH,
28139                                                                          ; ASH (FSH+1) and ENERGY (FSH+2), so set a loop counter
28140                                                                          ; in X for 3 bytes
28141               
28142               REL5:
28143 BF2A DB8D  38        movb ra,@FSH(rx)                ; STA FSH,X         ; Set the X-th byte of FSH to &FF to charge up that
     BF2C 0F11     
28144                                                                          ; shield/bank
28145               
28146 BF2E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28147               
28148 BF30 15FC  14        jgt  REL5                       ; BPL REL5          ; Loop back to REL5 until we have recharged both shields
28149                                                                          ; and the energy bank
28150               
28151                                                                          ; Fall through into RES2 to reset the stardust and ship
28152                                                                          ; workspace at INWK
28153               
28154               * ******************************************************************************
28155               *
28156               * Name: RES2
28157               * Type: Subroutine
28158               * Category: Start and end
28159               * Summary: Reset a number of flight variables and workspaces
28160               *
28161               * ------------------------------------------------------------------------------
28162               *
28163               * This is called after we launch from a space station, arrive in a new system
28164               * after hyperspace, launch an escape pod, or die a cold, lonely death in the
28165               * depths of space.
28166               *
28167               * ------------------------------------------------------------------------------
28168               *
28169               * Returns:
28170               *
28171               * Y                   Y is set to &FF
28172               *
28173               * ******************************************************************************
28174               
28175               RES2:
28176 BF32 020D  20        li   ra,(NOST)*256              ; LDA #NOST         ; Reset NOSTM, the number of stardust particles, to the
     BF34 1200     
28177 BF36 D80D  30        movb ra,@NOSTM                  ; STA NOSTM         ; maximum allowed (18)
     BF38 0F33     
28178               
28179 BF3A 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Reset LSX2 and LSY2, the ball line heaps used by the
     BF3C FF00     
28180 BF3E D80E  30        movb rx,@LSX2                   ; STX LSX2          ; BLINE routine for drawing circles, to &FF, to set the
     BF40 0E26     
28181 BF42 D80E  30        movb rx,@LSY2                   ; STX LSY2          ; heap to empty
     BF44 0E74     
28182               
28183 BF46 D80E  30        movb rx,@MSTG                   ; STX MSTG          ; Reset MSTG, the missile target, to &FF (no target)
     BF48 0052     
28184               
28185 BF4A 020D  20        li   ra,>80*256                 ; LDA #128          ; Set the current pitch rate to the mid-point, 128
     BF4C 8000     
28186 BF4E D80D  30        movb ra,@JSTY                   ; STA JSTY
     BF50 009D     
28187               
28188 BF52 D80D  30        movb ra,@ALP2                   ; STA ALP2          ; Reset ALP2 (roll sign) and BET2 (pitch sign)
     BF54 0088     
28189 BF56 D80D  30        movb ra,@BET2                   ; STA BET2          ; to negative, i.e. pitch and roll negative
     BF58 008A     
28190               
28191                      .asla                           ; ASL A             ; This sets A to 0
     **** ****     > ASLA
0001 BF5A 024D  22        andi ra,>ff00
     BF5C FF00     
0002 BF5E 0A1D  18        sla  ra,1
                   < elite.a99
28192               
28193 BF60 D80D  30        movb ra,@ALP2+1                 ; STA ALP2+1        ; Reset ALP2+1 (flipped roll sign) and BET2+1 (flipped
     BF62 0089     
28194 BF64 D80D  30        movb ra,@BET2+1                 ; STA BET2+1        ; pitch sign) to positive, i.e. pitch and roll negative
     BF66 008B     
28195               
28196 BF68 D80D  30        movb ra,@MCNT                   ; STA MCNT          ; Reset MCNT (the main loop counter) to 0
     BF6A 0099     
28197               
28198 BF6C 020D  20        li   ra,>03*256                 ; LDA #3            ; Reset DELTA (speed) to 3
     BF6E 0300     
28199 BF70 D80D  30        movb ra,@DELTA                  ; STA DELTA
     BF72 008C     
28200               
28201 BF74 D80D  30        movb ra,@ALPHA                  ; STA ALPHA         ; Reset ALPHA (roll angle alpha) to 3
     BF76 009E     
28202               
28203 BF78 D80D  30        movb ra,@ALP1                   ; STA ALP1          ; Reset ALP1 (magnitude of roll angle alpha) to 3
     BF7A 0087     
28204               
28205 BF7C D360  30        movb @SSPR,ra                   ; LDA SSPR          ; Fetch the "space station present" flag, and if we are
     BF7E 0D55     
28206 BF80 1304  14        jeq  B86                        ; BEQ B86           ; not inside the safe zone, skip the next instruction
28207               
28208 BF82 0200  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     BF84 B0E2     
28209 BF86 06A0  32        bl   @jsr                       ;
     BF88 FE1E     
28210               
28211               B86:
28212 BF8A D360  30        movb @ECMA,ra                   ; LDA ECMA          ; Fetch the E.C.M. status flag, and if E.C.M. is off,
     BF8C 0030     
28213 BF8E 1304  14        jeq  yu_                        ; BEQ yu            ; skip the next instruction
28214               
28215 BF90 0200  20        li   rtmp,ECMOF                 ; JSR ECMOF         ; Turn off the E.C.M. sound
     BF92 CB14     
28216 BF94 06A0  32        bl   @jsr                       ;
     BF96 FE1E     
28217               
28218               yu_:
28219 BF98 0200  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all ships from the scanner
     BF9A AC30     
28220 BF9C 06A0  32        bl   @jsr                       ;
     BF9E FE1E     
28221               
28222 BFA0 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     BFA2 C80A     
28223 BFA4 06A0  32        bl   @jsr                       ;
     BFA6 FE1E     
28224                                                                          ; the ship data blocks, the ship line heap, the ship
28225                                                                          ; slots for the local bubble of universe, and various
28226                                                                          ; flight and ship status variables
28227               
28228 BFA8 020D  20        li   ra,((WP.-1)%256)*256       ; LDA #LO(WP%-1)    ; We have reset the ship line heap, so we now point
     BFAA 3F00     
28229 BFAC D80D  30        movb ra,@SLSP                   ; STA SLSP          ; SLSP to the byte before the WP workspace to indicate
     BFAE 0F1E     
28230 BFB0 020D  20        li   ra,((WP.-1)/256)*256       ; LDA #HI(WP%-1)    ; that the heap is empty
     BFB2 0D00     
28231 BFB4 D80D  30        movb ra,@SLSP+1                 ; STA SLSP+1
     BFB6 0F1F     
28232               
28233 BFB8 0200  20        li   rtmp,DIALS                 ; JSR DIALS         ; Update the dashboard
     BFBA 3272     
28234 BFBC 06A0  32        bl   @jsr                       ;
     BFBE FE1E     
28235               
28236                                                                          ; Finally, fall through into ZINF to reset the INWK
28237                                                                          ; ship workspace
28238               
28239               * ******************************************************************************
28240               *
28241               * Name: ZINF
28242               * Type: Subroutine
28243               * Category: Universe
28244               * Summary: Reset the INWK workspace and orientation vectors
28245               * Deep dive: Orientation vectors
28246               *
28247               * ------------------------------------------------------------------------------
28248               *
28249               * Zero-fill the INWK ship workspace and reset the orientation vectors, with
28250               * nosev pointing out of the screen, towards us.
28251               *
28252               * ------------------------------------------------------------------------------
28253               *
28254               * Returns:
28255               *
28256               * Y                   Y is set to &FF
28257               *
28258               * ******************************************************************************
28259               
28260               ZINF:
28261 BFC0 020F  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in the INWK workspace, so set a
     BFC2 2300     
28262                                                                          ; counter in Y so we can loop through them
28263               
28264 BFC4 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the workspace
     BFC6 0000     
28265               
28266               ZI1:
28267 BFC8 DBCD  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; Zero the Y-th byte of the INWK workspace
     BFCA 0053     
28268               
28269 BFCC 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
28270               
28271 BFCE 15FC  14        jgt  ZI1                        ; BPL ZI1           ; Loop back for the next byte, ending when we have
28272                                                                          ; zero-filled the last byte at INWK, which leaves Y
28273                                                                          ; with a value of &FF
28274               
28275                                                                          ; Finally, we reset the orientation vectors as follows:
28276                                                                          ;
28277                                                                          ; sidev = (1,  0,  0)
28278                                                                          ; roofv = (0,  1,  0)
28279                                                                          ; nosev = (0,  0, -1)
28280                                                                          ;
28281                                                                          ; 96 * 256 (&6000) represents 1 in the orientation
28282                                                                          ; vectors, while -96 * 256 (&E000) represents -1. We
28283                                                                          ; already set the vectors to zero above, so we just
28284                                                                          ; need to set up the high bytes of the diagonal values
28285                                                                          ; and we're done. The negative nosev makes the ship
28286                                                                          ; point towards us, as the z-axis points into the screen
28287               
28288 BFD0 020D  20        li   ra,>60*256                 ; LDA #96           ; Set A to represent a 1 (in vector terms)
     BFD2 6000     
28289               
28290 BFD4 D80D  30        movb ra,@INWK+18                ; STA INWK+18       ; Set byte #18 = roofv_y_hi = 96 = 1
     BFD6 0065     
28291               
28292 BFD8 D80D  30        movb ra,@INWK+22                ; STA INWK+22       ; Set byte #22 = sidev_x_hi = 96 = 1
     BFDA 0069     
28293               
28294 BFDC 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Flip the sign of A to represent a -1
     BFDE 8000     
28295               
28296 BFE0 D80D  30        movb ra,@INWK+14                ; STA INWK+14       ; Set byte #14 = nosev_z_hi = -96 = -1
     BFE2 0061     
28297               
28298 BFE4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BFE6 FE2A     
28299               
28300               * ******************************************************************************
28301               *
28302               * Name: msblob
28303               * Type: Subroutine
28304               * Category: Dashboard
28305               * Summary: Display the dashboard's missile indicators in green
28306               *
28307               * ------------------------------------------------------------------------------
28308               *
28309               * Display the dashboard's missile indicators, with all the missiles reset to
28310               * green/cyan (i.e. not armed or locked).
28311               *
28312               * ******************************************************************************
28313               
28314               msblob_:
28315 BFE8 020E  20        li   rx,>04*256                 ; LDX #4            ; Set up a loop counter in X to count through all four
     BFEA 0400     
28316                                                                          ; missile indicators
28317               
28318               ss_:
28319 BFEC 93A0  30        cb   @NOMSL,rx                  ; CPX NOMSL         ; If the counter is equal to the number of missiles,
     BFEE 0333     
28320 BFF0 130A  14        jeq  SAL8                       ; BEQ SAL8          ; jump down to SAL8 to draw the remaining missiles, as
28321                                                                          ; the rest of them are present and should be drawn in
28322                                                                          ; green/cyan
28323               
28324 BFF2 020F  20        li   ry,>00*256                 ; LDY #0            ; Draw the missile indicator at position X in black
     BFF4 0000     
28325 BFF6 0200  20        li   rtmp,MSBAR                 ; JSR MSBAR
     BFF8 B10E     
28326 BFFA 06A0  32        bl   @jsr                       ;
     BFFC FE1E     
28327               
28328 BFFE 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28329               
28330 C000 16F5  14        jne  ss_                        ; BNE ss            ; Loop back to ss if we still have missiles to draw
28331               
28332 C002 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C004 FE2A     
28333               
28334               SAL8:
28335 C006 020F  20        li   ry,>ee*256                 ; LDY #&EE          ; Draw the missile indicator at position X in green/cyan
     C008 EE00     
28336 C00A 0200  20        li   rtmp,MSBAR                 ; JSR MSBAR
     C00C B10E     
28337 C00E 06A0  32        bl   @jsr                       ;
     C010 FE1E     
28338               
28339 C012 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28340               
28341 C014 16F8  14        jne  SAL8                       ; BNE SAL8          ; Loop back to SAL8 if we still have missiles to draw
28342               
28343 C016 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C018 FE2A     
28344               
28345               * ******************************************************************************
28346               *
28347               * Name: me2
28348               * Type: Subroutine
28349               * Category: Flight
28350               * Summary: Remove an in-flight message from the space view
28351               *
28352               * ******************************************************************************
28353               
28354               me2_:
28355 C01A D360  30        movb @MCH,ra                    ; LDA MCH           ; Fetch the token number of the current message into A
     C01C 0F10     
28356               
28357 C01E 0200  20        li   rtmp,MESS                  ; JSR MESS          ; Call MESS to print the token, which will remove it
     C020 CE5E     
28358 C022 06A0  32        bl   @jsr                       ;
     C024 FE1E     
28359                                                                          ; from the screen as printing uses EOR logic
28360               
28361 C026 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the delay in DLY to 0, so any new in-flight
     C028 0000     
28362 C02A D80D  30        movb ra,@DLY                    ; STA DLY           ; messages will be shown instantly
     C02C 0D64     
28363               
28364 C02E 0460  28        b    @me3_                      ; JMP me3           ; Jump back into the main spawning loop at me3
     C030 C0EA     
28365               
28366               * ******************************************************************************
28367               *
28368               * Name: Ze
28369               * Type: Subroutine
28370               * Category: Universe
28371               * Summary: Initialise the INWK workspace to a hostile ship
28372               * Deep dive: Fixing ship positions
28373               *
28374               * ------------------------------------------------------------------------------
28375               *
28376               * Specifically, this routine does the following:
28377               *
28378               * * Reset the INWK ship workspace
28379               *
28380               * * Set the ship to a fair distance away in all axes, in front of us but
28381               * randomly up or down, left or right
28382               *
28383               * * Give the ship a 4% chance of having E.C.M.
28384               *
28385               * * Set the ship to hostile, with AI enabled
28386               *
28387               * This routine also sets A, X, T1 and the C flag to random values.
28388               *
28389               * Note that because this routine uses the value of X returned by DORND, and X
28390               * contains the value of A returned by the previous call to DORND, this routine
28391               * does not necessarily set the new ship to a totally random location. See the
28392               * deep dive on "Fixing ship positions" for details.
28393               *
28394               * ******************************************************************************
28395               
28396               Ze:
28397 C032 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     C034 BFC0     
28398 C036 06A0  32        bl   @jsr                       ;
     C038 FE1E     
28399               
28400 C03A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C03C C07C     
28401 C03E 06A0  32        bl   @jsr                       ;
     C040 FE1E     
28402               
28403 C042 D80D  30        movb ra,@T1                     ; STA T1            ; Store A in T1
     C044 0006     
28404               
28405 C046 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign of A and store in x_sign
     C048 8000     
28406 C04A D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     C04C 0055     
28407               
28408 C04E D34E  18        movb rx,ra                      ; TXA               ; Extract the sign of X and store in y_sign
28409 C050 024D  22        andi ra,>80*256                 ; AND #%10000000
     C052 8000     
28410 C054 D80D  30        movb ra,@INWK+5                 ; STA INWK+5
     C056 0058     
28411               
28412 C058 020D  20        li   ra,>20*256                 ; LDA #32           ; Set x_hi = y_hi = z_hi = 32, a fair distance away
     C05A 2000     
28413 C05C D80D  30        movb ra,@INWK+1                 ; STA INWK+1
     C05E 0054     
28414 C060 D80D  30        movb ra,@INWK+4                 ; STA INWK+4
     C062 0057     
28415 C064 D80D  30        movb ra,@INWK+7                 ; STA INWK+7
     C066 005A     
28416               
28417 C068 D34E  18        movb rx,ra                      ; TXA               ; Set the C flag if X >= 245 (4% chance)
28418 C06A 028D  22        ci   ra,>f5*256                 ; CMP #245
     C06C F500     
28419               
28420 C06E 06A0  32        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 4%
     C070 FE34     
28421                                                                          ; chance of this ship having E.C.M.)
28422               
28423 C072 026D  22        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6
     C074 C000     
28424                                                                          ; and has AI (bit 7)
28425               
28426 C076 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     C078 0073     
28427               
28428                                                                          ; Fall through into DORND2 to set A, X and the C flag
28429                                                                          ; randomly
28430               
28431               * ******************************************************************************
28432               *
28433               * Name: DORND
28434               * Type: Subroutine
28435               * Category: Maths (Arithmetic)
28436               * Summary: Generate random numbers
28437               * Deep dive: Generating random numbers
28438               * Fixing ship positions
28439               *
28440               * ------------------------------------------------------------------------------
28441               *
28442               * Set A and X to random numbers (though note that X is set to the random number
28443               * that was returned in A the last time DORND was called).
28444               *
28445               * The C and V flags are also set randomly.
28446               *
28447               * If we want to generate a repeatable sequence of random numbers, when
28448               * generating explosion clouds, for example, then we call DORND2 to ensure that
28449               * the value of the C flag on entry doesn't affect the outcome, as otherwise we
28450               * might not get the same sequence of numbers if the C flag changes.
28451               *
28452               * ------------------------------------------------------------------------------
28453               *
28454               * Other entry points:
28455               *
28456               * DORND2              Make sure the C flag doesn't affect the outcome
28457               *
28458               * ******************************************************************************
28459               
28460               DORND2:
28461                      .clc                            ; CLC               ; Clear the C flag so the value of the C flag on entry
     **** ****     > CLC
0001 C07A 0A16  18        sla  rzero,1
                   < elite.a99
28462                                                                          ; doesn't affect the outcome
28463               
28464               DORND:
28465 C07C D360  30        movb @RAND,ra                   ; LDA RAND          ; Calculate the next two values f2 and f3 in the feeder
     C07E 0000     
28466 C080 06A0  32        bl   @rola                      ; ROL A             ; sequence:
     C082 FE34     
28467 C084 D38D  18        movb ra,rx                      ; TAX               ;
28468                      .adc @RAND+2,ra                 ; ADC RAND+2        ; * f2 = (f1 << 1) mod 256 + C flag on entry
     **** ****     > ADC
0001 C086 1701  14        jnc  !
0002 C088 B347  18        ab   rone,ra
0003               !:
0004 C08A B360  30        ab   @RAND+2,ra
     C08C 0002     
                   < elite.a99
28469 C08E D80D  30        movb ra,@RAND                   ; STA RAND          ; * f3 = f0 + f2 + (1 if bit 7 of f1 is set)
     C090 0000     
28470 C092 D80E  30        movb rx,@RAND+2                 ; STX RAND+2        ; * C flag is set according to the f3 calculation
     C094 0002     
28471               
28472 C096 D360  30        movb @RAND+1,ra                 ; LDA RAND+1        ; Calculate the next value m2 in the main sequence:
     C098 0001     
28473 C09A D38D  18        movb ra,rx                      ; TAX               ;
28474                      .adc @RAND+3,ra                 ; ADC RAND+3        ; * A = m2 = m0 + m1 + C flag from feeder calculation
     **** ****     > ADC
0001 C09C 1701  14        jnc  !
0002 C09E B347  18        ab   rone,ra
0003               !:
0004 C0A0 B360  30        ab   @RAND+3,ra
     C0A2 0003     
                   < elite.a99
28475 C0A4 D80D  30        movb ra,@RAND+1                 ; STA RAND+1        ; * X = m1
     C0A6 0001     
28476 C0A8 D80E  30        movb rx,@RAND+3                 ; STX RAND+3        ; * C and V flags set according to the m2 calculation
     C0AA 0003     
28477               
28478 C0AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C0AE FE2A     
28479               
28480               * ******************************************************************************
28481               *
28482               * Name: Main game loop (Part 1 of 6)
28483               * Type: Subroutine
28484               * Category: Main loop
28485               * Summary: Spawn a trader (a peaceful Cobra Mk III)
28486               * Deep dive: Program flow of the main game loop
28487               * Ship data blocks
28488               *
28489               * ------------------------------------------------------------------------------
28490               *
28491               * This is part of the main game loop. This is where the core loop of the game
28492               * lives, and it's in two parts. The shorter loop (just parts 5 and 6) is
28493               * iterated when we are docked, while the entire loop from part 1 to 6 iterates
28494               * if we are in space.
28495               *
28496               * This section covers the following:
28497               *
28498               * * Spawn a trader, i.e. a Cobra Mk III that isn't hostile, with a 50% chance
28499               * of it having a missile, a 50% chance of it having an E.C.M., a speed
28500               * between 16 and 31, and a gentle clockwise roll
28501               *
28502               * We call this from within the main loop, with A set to a random number.
28503               *
28504               * ******************************************************************************
28505               
28506               MTT4:
28507 C0B0 091D  18        srl  ra,1                       ; LSR A             ; Clear bit 7 of our random number in A and set the C
28508                                                                          ; flag to bit 0 of A, which is random
28509               
28510 C0B2 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; Store this in the ship's AI flag, so this ship does
     C0B4 0073     
28511                                                                          ; not have AI
28512               
28513 C0B6 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; Store A in the ship's roll counter, giving it a
     C0B8 0070     
28514                                                                          ; clockwise roll (as bit 7 is clear), and a 1 in 127
28515                                                                          ; chance of it having no damping
28516               
28517 C0BA 0204  20        li   rarg1,INWK+31              ; ROL INWK+31       ; Set bit 0 of the ship's missile count randomly (as the
     C0BC 0072     
28518 C0BE 06A0  32        bl   @rol                       ;
     C0C0 FE44     
28519                                                                          ; C flag was set), giving the ship either no missiles or
28520                                                                          ; one missile
28521               
28522 C0C2 024D  22        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     C0C4 1F00     
28523 C0C6 026D  22        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     C0C8 1000     
28524 C0CA D80D  30        movb ra,@INWK+27                ; STA INWK+27
     C0CC 006E     
28525               
28526 C0CE 020D  20        li   ra,(CYL)*256               ; LDA #CYL          ; Add a new Cobra Mk III to the local bubble and fall
     C0D0 0700     
28527 C0D2 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; through into the main game loop again
     C0D4 AF7A     
28528 C0D6 06A0  32        bl   @jsr                       ;
     C0D8 FE1E     
28529               
28530               * ******************************************************************************
28531               *
28532               * Name: Main game loop (Part 2 of 6)
28533               * Type: Subroutine
28534               * Category: Main loop
28535               * Summary: Call the main flight loop, and potentially spawn a trader, an
28536               * asteroid, or a cargo canister
28537               * Deep dive: Program flow of the main game loop
28538               * Ship data blocks
28539               * Fixing ship positions
28540               *
28541               * ------------------------------------------------------------------------------
28542               *
28543               * This section covers the following:
28544               *
28545               * * Call M% to do the main flight loop
28546               *
28547               * * Potentially spawn a trader, asteroid or cargo canister
28548               *
28549               * ------------------------------------------------------------------------------
28550               *
28551               * Other entry points:
28552               *
28553               * TT100               The entry point for the start of the main game loop,
28554               * which calls the main flight loop and the moves into the
28555               * spawning routine
28556               *
28557               * me3                 Used by me2 to jump back into the main game loop after
28558               * printing an in-flight message
28559               *
28560               * ******************************************************************************
28561               
28562               TT100:
28563 C0DA 0200  20        li   rtmp,M.                    ; JSR M%            ; Call M% to iterate through the main flight loop
     C0DC 0F52     
28564 C0DE 06A0  32        bl   @jsr                       ;
     C0E0 FE1E     
28565               
28566 C0E2 7347  18        sb   rone,ra                    ; DEC DLY           ; Decrement the delay counter in DLY, so any in-flight
28567                                                                          ; messages get removed once the counter reaches zero
28568               
28569 C0E4 139A  14        jeq  me2_                       ; BEQ me2           ; If DLY is now 0, jump to me2 to remove any in-flight
28570                                                                          ; message from the space view, and once done, return to
28571                                                                          ; me3 below, skipping the following two instructions
28572               
28573 C0E6 1501  14        jgt  me3_                       ; BPL me3           ; If DLY is positive, jump to me3 to skip the next
28574                                                                          ; instruction
28575               
28576 C0E8 B347  18        ab   rone,ra                    ; INC DLY           ; If we get here, DLY is negative, so we have gone too
28577                                                                          ; and need to increment DLY back to 0
28578               
28579               me3_:
28580 C0EA 7347  18        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter in MCNT
28581               
28582 C0EC 1302  14        jeq  B87                        ; BEQ B87           ; If the counter has reached zero, which it will do
28583                                                                          ; every 256 main loops, skip the next JMP instruction
28584                                                                          ; (or to put it another way, if the counter hasn't
28585                                                                          ; reached zero, jump down to MLOOP, skipping all the
28586                                                                          ; following checks)
28587               
28588               ytq_:
28589 C0EE 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP to do some end-of-loop tidying and
     C0F0 C276     
28590                                                                          ; restart the main loop
28591               
28592                                                                          ; We only get here once every 256 iterations of the
28593                                                                          ; main loop. If we aren't in witchspace and don't
28594                                                                          ; already have 3 or more asteroids in our local bubble,
28595                                                                          ; then this section has a 13% chance of spawning
28596                                                                          ; something benign (the other 87% of the time we jump
28597                                                                          ; down to consider spawning cops, pirates and bounty
28598                                                                          ; hunters)
28599                                                                          ;
28600                                                                          ; If we are in that 13%, then 50% of the time this will
28601                                                                          ; be a Cobra Mk III trader, and the other 50% of the
28602                                                                          ; time it will either be an asteroid (98.5% chance) or,
28603                                                                          ; very rarely, a cargo canister (1.5% chance)
28604               
28605               B87:
28606 C0F2 D360  30        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace following a mis-jump, skip the
     C0F4 0D5C     
28607 C0F6 16FB  14        jne  ytq_                       ; BNE ytq           ; following by jumping down to MLOOP (via ytq above)
28608               
28609 C0F8 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C0FA C07C     
28610 C0FC 06A0  32        bl   @jsr                       ;
     C0FE FE1E     
28611               
28612 C100 028D  22        ci   ra,>23*256                 ; CMP #35           ; If A >= 35 (87% chance), jump down to MTT1 to skip
     C102 2300     
28613 C104 184F  14        joc  MTT1                       ; BCS MTT1          ; the spawning of an asteroid or cargo canister and
28614                                                                          ; potentially spawn something else
28615               
28616 C106 D360  30        movb @MANY+AST,ra               ; LDA MANY+AST      ; If we already have 3 or more asteroids in the local
     C108 0D57     
28617 C10A 028D  22        ci   ra,>03*256                 ; CMP #3            ; bubble, jump down to MTT1 to skip the following and
     C10C 0300     
28618 C10E 184A  14        joc  MTT1                       ; BCS MTT1          ; potentially spawn something else
28619               
28620 C110 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     C112 BFC0     
28621 C114 06A0  32        bl   @jsr                       ;
     C116 FE1E     
28622               
28623 C118 020D  20        li   ra,>26*256                 ; LDA #38           ; Set z_hi = 38 (far away)
     C11A 2600     
28624 C11C D80D  30        movb ra,@INWK+7                 ; STA INWK+7
     C11E 005A     
28625               
28626 C120 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and C flag to random numbers
     C122 C07C     
28627 C124 06A0  32        bl   @jsr                       ;
     C126 FE1E     
28628               
28629 C128 D80D  30        movb ra,@INWK                   ; STA INWK          ; Set x_lo = random
     C12A 0053     
28630               
28631 C12C D80E  30        movb rx,@INWK+3                 ; STX INWK+3        ; Set y_lo = random
     C12E 0056     
28632                                                                          ;
28633                                                                          ; Note that because we use the value of X returned by
28634                                                                          ; DORND, and X contains the value of A returned by the
28635                                                                          ; previous call to DORND, this does not set the new ship
28636                                                                          ; to a totally random location. See the deep dive on
28637                                                                          ; "Fixing ship positions" for details
28638               
28639 C130 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Set x_sign = bit 7 of x_lo
     C132 8000     
28640 C134 D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     C136 0055     
28641               
28642 C138 D34E  18        movb rx,ra                      ; TXA               ; Set y_sign = bit 7 of y_lo
28643 C13A 024D  22        andi ra,>80*256                 ; AND #%10000000
     C13C 8000     
28644 C13E D80D  30        movb ra,@INWK+5                 ; STA INWK+5
     C140 0058     
28645               
28646 C142 0204  20        li   rarg1,INWK+1               ; ROL INWK+1        ; Set bit 1 of x_hi to the C flag, which is random, so
     C144 0054     
28647 C146 06A0  32        bl   @rol                       ;
     C148 FE44     
28648 C14A 0204  20        li   rarg1,INWK+1               ; ROL INWK+1        ; this randomly moves us off-centre by 512 (as if x_hi
     C14C 0054     
28649 C14E 06A0  32        bl   @rol                       ;
     C150 FE44     
28650                                                                          ; is %00000010, then (x_hi x_lo) is 512 + x_lo)
28651               
28652 C152 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and V flag to random numbers
     C154 C07C     
28653 C156 06A0  32        bl   @jsr                       ;
     C158 FE1E     
28654               
28655                      .bvs MTT4                       ; BVS MTT4          ; If V flag is set (50% chance), jump up to MTT4 to
     **** ****     > BVS
0001 C15A 1801  14        joc  !
0002 C15C 10A9  14        jmp  MTT4
0003               !:
                   < elite.a99
28656                                                                          ; spawn a trader
28657               
28658 C15E 026D  22        ori  ra,>6f*256                 ; ORA #%01101111    ; Take the random number in A and set bits 0-3 and 5-6,
     C160 6F00     
28659 C162 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; so the result has a 50% chance of being positive or
     C164 0070     
28660                                                                          ; negative, and a 50% chance of bits 0-6 being 127.
28661                                                                          ; Storing this number in the roll counter therefore
28662                                                                          ; gives our new ship a fast roll speed with a 50%
28663                                                                          ; chance of having no damping, plus a 50% chance of
28664                                                                          ; rolling clockwise or anti-clockwise
28665               
28666 C166 D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump
     C168 0D55     
28667 C16A 161C  14        jne  MTT1                       ; BNE MTT1          ; down to MTT1 to skip the following and potentially
28668                                                                          ; spawn something else
28669               
28670 C16C D34E  18        movb rx,ra                      ; TXA               ; Set A to the random X we set above, which we haven't
28671 C16E 1807  14        joc  MTT2                       ; BCS MTT2          ; used yet, and if the C flag is set (50% chance) jump
28672                                                                          ; down to MTT2 to skip the following
28673               
28674 C170 024D  22        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     C172 1F00     
28675 C174 026D  22        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     C176 1000     
28676 C178 D80D  30        movb ra,@INWK+27                ; STA INWK+27
     C17A 006E     
28677               
28678 C17C 1704  14        jnc  MTT3                       ; BCC MTT3          ; Jump down to MTT3, skipping the following (this BCC
28679                                                                          ; is effectively a JMP as we know the C flag is clear,
28680                                                                          ; having passed through the BCS above)
28681               
28682               MTT2:
28683 C17E 026D  22        ori  ra,>7f*256                 ; ORA #%01111111    ; Set bits 0-6 of A to 127, leaving bit 7 as random, so
     C180 7F00     
28684 C182 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; storing this number in the pitch counter means we have
     C184 0071     
28685                                                                          ; full pitch with no damping, with a 50% chance of
28686                                                                          ; pitching up or down
28687               
28688               MTT3:
28689 C186 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C188 C07C     
28690 C18A 06A0  32        bl   @jsr                       ;
     C18C FE1E     
28691               
28692 C18E 028D  22        ci   ra,>05*256                 ; CMP #5            ; Set A to the ship number of an asteroid, and keep
     C190 0500     
28693 C192 020D  20        li   ra,(AST)*256               ; LDA #AST          ; this value for 98.5% of the time (i.e. if random
     C194 0A00     
28694 C196 1802  14        joc  B88                        ; BCS B88           ; A >= 5 then skip the following instruction)
28695               
28696 C198 020D  20        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship number of a cargo canister
     C19A 0B00     
28697               
28698               B88:
28699 C19C 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add our new asteroid or canister to the universe
     C19E AF7A     
28700 C1A0 06A0  32        bl   @jsr                       ;
     C1A2 FE1E     
28701               
28702               * ******************************************************************************
28703               *
28704               * Name: Main game loop (Part 3 of 6)
28705               * Type: Subroutine
28706               * Category: Main loop
28707               * Summary: Potentially spawn a cop, particularly if we've been bad
28708               * Deep dive: Program flow of the main game loop
28709               * Ship data blocks
28710               * Fixing ship positions
28711               *
28712               * ------------------------------------------------------------------------------
28713               *
28714               * This section covers the following:
28715               *
28716               * * Potentially spawn a cop (in a Viper), very rarely if we have been good,
28717               * more often if have been naughty, and very often if we have been properly
28718               * bad
28719               *
28720               * ******************************************************************************
28721               
28722               MTT1:
28723 C1A4 D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station's safe zone, jump
     C1A6 0D55     
28724 C1A8 1666  14        jne  MLOOP                      ; BNE MLOOP         ; to MLOOP to skip the following
28725               
28726 C1AA 0200  20        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     C1AC C436     
28727 C1AE 06A0  32        bl   @jsr                       ;
     C1B0 FE1E     
28728                                                                          ; are carrying in our hold (A is up to 40 for a
28729                                                                          ; standard hold crammed with contraband, up to 70 for
28730                                                                          ; an extended cargo hold full of narcotics and slaves)
28731               
28732                      .asla                           ; ASL A             ; Double A to a maximum of 80 or 140
     **** ****     > ASLA
0001 C1B2 024D  22        andi ra,>ff00
     C1B4 FF00     
0002 C1B6 0A1D  18        sla  ra,1
                   < elite.a99
28733               
28734 C1B8 D3A0  30        movb @MANY+COPS,rx              ; LDX MANY+COPS     ; If there are no cops in the local bubble, skip the
     C1BA 0D4F     
28735 C1BC 1302  14        jeq  B89                        ; BEQ B89           ; next instruction
28736               
28737 C1BE F360  30        socb @FIST,ra                   ; ORA FIST          ; There are cops in the vicinity and we've got a hold
     C1C0 0334     
28738                                                                          ; full of jail time, so OR the value in A with FIST to
28739                                                                          ; get a new value that is at least as high as both
28740                                                                          ; values, to reflect the fact that they have almost
28741                                                                          ; certainly scanned our ship
28742               
28743               B89:
28744 C1C2 D80D  30        movb ra,@T                      ; STA T             ; Store our badness level in T
     C1C4 00D1     
28745               
28746 C1C6 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C1C8 C032     
28747 C1CA 06A0  32        bl   @jsr                       ;
     C1CC FE1E     
28748                                                                          ; ship, and set A and X to random values
28749                                                                          ;
28750                                                                          ; Note that because Ze uses the value of X returned by
28751                                                                          ; DORND, and X contains the value of A returned by the
28752                                                                          ; previous call to DORND, this does not set the new ship
28753                                                                          ; to a totally random location. See the deep dive on
28754                                                                          ; "Fixing ship positions" for details
28755               
28756 C1CE 9360  30        cb   @T,ra                      ; CMP T             ; If the random value in A >= our badness level, which
     C1D0 00D1     
28757 C1D2 1806  14        joc  B90                        ; BCS B90           ; will be the case unless we have been really, really
28758                                                                          ; bad, then skip the following two instructions (so
28759                                                                          ; if we are really bad, there's a higher chance of
28760                                                                          ; spawning a cop, otherwise we got away with it, for
28761                                                                          ; now)
28762               
28763 C1D4 020D  20        li   ra,(COPS)*256              ; LDA #COPS         ; Add a new police ship to the local bubble
     C1D6 0200     
28764 C1D8 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP
     C1DA AF7A     
28765 C1DC 06A0  32        bl   @jsr                       ;
     C1DE FE1E     
28766               
28767               B90:
28768 C1E0 D360  30        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; If we now have at least one cop in the local bubble,
     C1E2 0D4F     
28769 C1E4 1648  14        jne  MLOOP                      ; BNE MLOOP         ; jump down to MLOOP, otherwise fall through into the
28770                                                                          ; next part to look at spawning something else
28771               
28772               * ******************************************************************************
28773               *
28774               * Name: Main game loop (Part 4 of 6)
28775               * Type: Subroutine
28776               * Category: Main loop
28777               * Summary: Potentially spawn a lone bounty hunter, a Thargoid, or up to four
28778               * pirates
28779               * Deep dive: Program flow of the main game loop
28780               * Ship data blocks
28781               * Fixing ship positions
28782               *
28783               * ------------------------------------------------------------------------------
28784               *
28785               * This section covers the following:
28786               *
28787               * * Potentially spawn (35% chance) either a lone bounty hunter (a Mamba,
28788               * Python or Cobra Mk III), a Thargoid, or a group of up to 4 pirates
28789               * (Sidewinders and/or Mambas)
28790               *
28791               * ******************************************************************************
28792               
28793 C1E6 7347  18        sb   rone,ra                    ; DEC EV            ; Decrement EV, the extra vessels spawning delay, and
28794 C1E8 1546  14        jgt  MLOOP                      ; BPL MLOOP         ; jump to MLOOP if it is still positive, so we only
28795                                                                          ; do the following when the EV counter runs down
28796               
28797 C1EA B347  18        ab   rone,ra                    ; INC EV            ; EV is negative, so bump it up again, setting it back
28798                                                                          ; to 0
28799               
28800 C1EC 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C1EE C07C     
28801 C1F0 06A0  32        bl   @jsr                       ;
     C1F2 FE1E     
28802               
28803 C1F4 D3E0  30        movb @gov_,ry                   ; LDY gov           ; If the government of this system is 0 (anarchy), jump
     C1F6 0F1C     
28804 C1F8 1308  14        jeq  LABEL_2                    ; BEQ LABEL_2       ; straight to LABEL_2 to start spawning pirates or a
28805                                                                          ; lone bounty hunter
28806               
28807 C1FA 028D  22        ci   ra,>5a*256                 ; CMP #90           ; If the random number in A >= 90 (65% chance), jump to
     C1FC 5A00     
28808 C1FE 183B  14        joc  MLOOP                      ; BCS MLOOP         ; MLOOP to stop spawning (so there's a 35% chance of
28809                                                                          ; spawning pirates or a lone bounty hunter)
28810               
28811 C200 024D  22        andi ra,>07*256                 ; AND #7            ; Reduce the random number in A to the range 0-7, and
     C202 0700     
28812 C204 9360  30        cb   @gov_,ra                   ; CMP gov           ; if A is less than government of this system, jump
     C206 0F1C     
28813 C208 1736  14        jnc  MLOOP                      ; BCC MLOOP         ; to MLOOP to stop spawning (so safer governments with
28814                                                                          ; larger gov numbers have a greater chance of jumping
28815                                                                          ; out, which is another way of saying that more
28816                                                                          ; dangerous systems spawn pirates and bounty hunters
28817                                                                          ; more often)
28818               
28819               LABEL_2:
28820                                                                          ; Now to spawn a lone bounty hunter, a Thargoid or a
28821                                                                          ; group of pirates
28822 C20A 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C20C C032     
28823 C20E 06A0  32        bl   @jsr                       ;
     C210 FE1E     
28824                                                                          ; ship, and set A and X to random values
28825                                                                          ;
28826                                                                          ; Note that because Ze uses the value of X returned by
28827                                                                          ; DORND, and X contains the value of A returned by the
28828                                                                          ; previous call to DORND, this does not set the new ship
28829                                                                          ; to a totally random location. See the deep dive on
28830                                                                          ; "Fixing ship positions" for details
28831               
28832 C212 028D  22        ci   ra,>c8*256                 ; CMP #200          ; If the random number in A >= 200 (13% chance), jump
     C214 C800     
28833 C216 181B  14        joc  mt1_                       ; BCS mt1           ; to mt1 to spawn pirates, otherwise keep going to
28834                                                                          ; spawn a lone bounty hunter or a Thargoid
28835               
28836 C218 B347  18        ab   rone,ra                    ; INC EV            ; Increase the extra vessels spawning counter, to
28837                                                                          ; prevent the next attempt to spawn extra vessels
28838               
28839 C21A 024D  22        andi ra,>03*256                 ; AND #3            ; Set A = Y = random number in the range 3-6, which
     C21C 0300     
28840                      .adi (>03*256)                  ; ADC #3            ; we will use to determine the type of ship
     **** ****     > ADI
0001 C21E 1701  14        jnc  !
0002 C220 B347  18        ab   rone,ra
0003               !:
0004 C222 022D  22        ai   ra,(>03*256)
     C224 0300     
                   < elite.a99
28841 C226 D3CD  18        movb ra,ry                      ; TAY
28842               
28843                                                                          ; We now build the AI flag for this ship in A
28844               
28845 C228 D34E  18        movb rx,ra                      ; TXA               ; First, copy the random number in X to A
28846               
28847 C22A 028D  22        ci   ra,>c8*256                 ; CMP #200          ; First, set the C flag if X >= 200 (22% chance)
     C22C C800     
28848               
28849 C22E 06A0  32        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 22%
     C230 FE34     
28850                                                                          ; chance of this ship having E.C.M.)
28851               
28852 C232 026D  22        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6)
     C234 C000     
28853                                                                          ; and has AI (bit 7)
28854               
28855 C236 028F  22        ci   ry,>06*256                 ; CPY #6            ; If Y = 6 (i.e. a Thargoid), jump down to the tha
     C238 0600     
28856 C23A 1347  14        jeq  tha_                       ; BEQ tha           ; routine in part 6 to decide whether or not to spawn it
28857                                                                          ; (where there's a 22% chance of this happening)
28858               
28859 C23C D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     C23E 0073     
28860               
28861 C240 D34F  18        movb ry,ra                      ; TYA               ; Add a new ship of type Y to the local bubble, so
28862 C242 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; that's a Mamba, Cobra Mk III or Python
     C244 AF7A     
28863 C246 06A0  32        bl   @jsr                       ;
     C248 FE1E     
28864               
28865               mj1_:
28866 C24A 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP, as we are done spawning ships
     C24C C276     
28867               
28868               mt1_:
28869 C24E 024D  22        andi ra,>03*256                 ; AND #3            ; It's time to spawn a group of pirates, so set A to a
     C250 0300     
28870                                                                          ; random number in the range 0-3, which will be the
28871                                                                          ; loop counter for spawning pirates below (so we will
28872                                                                          ; spawn 1-4 pirates)
28873               
28874 C252 D80D  30        movb ra,@EV                     ; STA EV            ; Delay further spawnings by this number
     C254 0D63     
28875               
28876 C256 D80D  30        movb ra,@XX13                   ; STA XX13          ; Store the number in XX13, the pirate counter
     C258 0098     
28877               
28878               mt3_:
28879 C25A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C25C C07C     
28880 C25E 06A0  32        bl   @jsr                       ;
     C260 FE1E     
28881               
28882 C262 024D  22        andi ra,>03*256                 ; AND #3            ; Set A to a random number in the range 0-3
     C264 0300     
28883               
28884 C266 026D  22        ori  ra,>01*256                 ; ORA #1            ; Set A to %01 or %11 (Sidewinder or Mamba)
     C268 0100     
28885               
28886 C26A 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Try adding a new ship of type A to the local bubble
     C26C AF7A     
28887 C26E 06A0  32        bl   @jsr                       ;
     C270 FE1E     
28888               
28889 C272 7347  18        sb   rone,ra                    ; DEC XX13          ; Decrement the pirate counter
28890               
28891 C274 15F2  14        jgt  mt3_                       ; BPL mt3           ; If we need more pirates, loop back up to mt3,
28892                                                                          ; otherwise we are done spawning, so fall through into
28893                                                                          ; the end of the main loop at MLOOP
28894               
28895               * ******************************************************************************
28896               *
28897               * Name: Main game loop (Part 5 of 6)
28898               * Type: Subroutine
28899               * Category: Main loop
28900               * Summary: Cool down lasers, make calls to update the dashboard
28901               * Deep dive: Program flow of the main game loop
28902               * The dashboard indicators
28903               *
28904               * ------------------------------------------------------------------------------
28905               *
28906               * This is the first half of the minimal game loop, which we iterate when we are
28907               * docked. This section covers the following:
28908               *
28909               * * Cool down lasers
28910               *
28911               * * Make calls to update the dashboard
28912               *
28913               * ------------------------------------------------------------------------------
28914               *
28915               * Other entry points:
28916               *
28917               * MLOOP               The entry point for the main game loop. This entry point
28918               * comes after the call to the main flight loop and
28919               * spawning routines, so it marks the start of the main
28920               * game loop for when we are docked (as we don't need to
28921               * call the main flight loop or spawning routines if we
28922               * aren't in space)
28923               *
28924               * ******************************************************************************
28925               
28926               MLOOP:
28927 C276 020D  20        li   ra,>01*256                 ; LDA #%00000001    ; Set 6522 System VIA interrupt enable register IER
     C278 0100     
28928 C27A D80D  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. disable the CA2 interrupt,
     C27C FE4E     
28929                                                                          ; which comes from the keyboard)
28930               
28931 C27E 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     C280 FF00     
28932 C282 D80E  38        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     C284 2081     
28933                                                                          ; effectively resets the stack
28934               
28935 C286 D3A0  30        movb @GNTMP,rx                  ; LDX GNTMP         ; If the laser temperature in GNTMP is non-zero,
     C288 0D61     
28936 C28A 1301  14        jeq  EE20                       ; BEQ EE20          ; decrement it (i.e. cool it down a bit)
28937 C28C 7347  18        sb   rone,ra                    ; DEC GNTMP
28938               
28939               EE20:
28940 C28E 0200  20        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     C290 3272     
28941 C292 06A0  32        bl   @jsr                       ;
     C294 FE1E     
28942               
28943 C296 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, skip the following four
     C298 0096     
28944 C29A 130A  14        jeq  B91                        ; BEQ B91           ; instructions (i.e. jump to JSR TT17 below)
28945               
28946                      .and @PATG                      ; AND PATG          ; If PATG = &FF (author names are shown on start-up)
     **** ****     > AND
0001 C29C D020  30        movb @PATG,rtmp
     C29E 0F4C     
0002 C2A0 0540  14        inv  rtmp
0003 C2A2 5340  18        szcb rtmp,ra
                   < elite.a99
28947 C2A4 091D  18        srl  ra,1                       ; LSR A             ; and bit 0 of QQ11 is 1 (the current view is type 1),
28948 C2A6 1804  14        joc  B91                        ; BCS B91           ; then skip the following instruction
28949               
28950 C2A8 0200  20        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds), to
     C2AA 4BFB     
28951 C2AC 06A0  32        bl   @jsr                       ;
     C2AE FE1E     
28952                                                                          ; slow the main loop down a bit
28953               
28954               B91:
28955 C2B0 0200  20        li   rtmp,TT17                  ; JSR TT17          ; Scan the keyboard for the cursor keys or joystick,
     C2B2 BB94     
28956 C2B4 06A0  32        bl   @jsr                       ;
     C2B6 FE1E     
28957                                                                          ; returning the cursor's delta values in X and Y and
28958                                                                          ; the key pressed in A
28959               
28960               * ******************************************************************************
28961               *
28962               * Name: Main game loop (Part 6 of 6)
28963               * Type: Subroutine
28964               * Category: Main loop
28965               * Summary: Process non-flight key presses (red function keys, docked keys)
28966               * Deep dive: Program flow of the main game loop
28967               *
28968               * ------------------------------------------------------------------------------
28969               *
28970               * This is the second half of the minimal game loop, which we iterate when we are
28971               * docked. This section covers the following:
28972               *
28973               * * Process more key presses (red function keys, docked keys etc.)
28974               *
28975               * It also supports joining the main loop with a key already "pressed", so we can
28976               * jump into the main game loop to perform a specific action. In practice, this
28977               * is used when we enter the docking bay in BAY to display Status Mode (red key
28978               * f8), and when we finish buying or selling cargo in BAY2 to jump to the
28979               * Inventory (red key f9).
28980               *
28981               * ------------------------------------------------------------------------------
28982               *
28983               * Other entry points:
28984               *
28985               * FRCE                The entry point for the main game loop if we want to
28986               * jump straight to a specific screen, by pretending to
28987               * "press" a key, in which case A contains the internal key
28988               * number of the key we want to "press"
28989               *
28990               * tha                 Consider spawning a Thargoid (22% chance)
28991               *
28992               * ******************************************************************************
28993               
28994               FRCE:
28995 C2B8 0200  20        li   rtmp,TT102                 ; JSR TT102         ; Call TT102 to process the key pressed in A
     C2BA C2E4     
28996 C2BC 06A0  32        bl   @jsr                       ;
     C2BE FE1E     
28997               
28998 C2C0 D360  30        movb @QQ12,ra                   ; LDA QQ12          ; Fetch the docked flag from QQ12 into A
     C2C2 009F     
28999               
29000 C2C4 16D8  14        jne  MLOOP                      ; BNE MLOOP         ; If we are docked, loop back up to MLOOP just above
29001                                                                          ; to restart the main loop, but skipping all the flight
29002                                                                          ; and spawning code in the top part of the main loop
29003               
29004 C2C6 0460  28        b    @TT100                     ; JMP TT100         ; Otherwise jump to TT100 to restart the main loop from
     C2C8 C0DA     
29005                                                                          ; the start
29006               
29007               tha_:
29008 C2CA 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C2CC C07C     
29009 C2CE 06A0  32        bl   @jsr                       ;
     C2D0 FE1E     
29010               
29011 C2D2 028D  22        ci   ra,>c8*256                 ; CMP #200          ; If A < 200 (78% chance), skip the next instruction
     C2D4 C800     
29012 C2D6 1704  14        jnc  B92                        ; BCC B92
29013               
29014 C2D8 0200  20        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     C2DA A000     
29015 C2DC 06A0  32        bl   @jsr                       ;
     C2DE FE1E     
29016                                                                          ; companion
29017               
29018               B92:
29019 C2E0 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump back into the main loop at MLOOP, which is just
     C2E2 C276     
29020                                                                          ; after the ship-spawning section
29021               
29022               * ******************************************************************************
29023               *
29024               * Name: TT102
29025               * Type: Subroutine
29026               * Category: Keyboard
29027               * Summary: Process function key, save key, hyperspace and chart key presses
29028               * and update the hyperspace counter
29029               *
29030               * ------------------------------------------------------------------------------
29031               *
29032               * Process function key presses, plus "@" (save commander), "H" (hyperspace),
29033               * "D" (show distance to system) and "O" (move chart cursor back to current
29034               * system). We can also pass cursor position deltas in X and Y to indicate that
29035               * the cursor keys or joystick have been used (i.e. the values that are returned
29036               * by routine TT17).
29037               *
29038               * ------------------------------------------------------------------------------
29039               *
29040               * Arguments:
29041               *
29042               * A                   The internal key number of the key pressed (see p.142 of
29043               * the Advanced User Guide for a list of internal key
29044               * numbers)
29045               *
29046               * X                   The amount to move the crosshairs in the x-axis
29047               *
29048               * Y                   The amount to move the crosshairs in the y-axis
29049               *
29050               * ------------------------------------------------------------------------------
29051               *
29052               * Other entry points:
29053               *
29054               * T95                 Print the distance to the selected system
29055               *
29056               * ******************************************************************************
29057               
29058               TT102:
29059 C2E4 028D  22        ci   ra,(f8_)*256               ; CMP #f8           ; If red key f8 was pressed, jump to STATUS to show the
     C2E6 7600     
29060 C2E8 1602  14        jne  B93                        ; BNE B93           ; Status Mode screen, returning from the subroutine
29061 C2EA 0460  28        b    @STATUS                    ; JMP STATUS        ; using a tail call
     C2EC 2E26     
29062               
29063               B93:
29064 C2EE 028D  22        ci   ra,(f4_)*256               ; CMP #f4           ; If red key f4 was pressed, jump to TT22 to show the
     C2F0 1400     
29065 C2F2 1602  14        jne  B94                        ; BNE B94           ; Long-range Chart, returning from the subroutine using
29066 C2F4 0460  28        b    @TT22                      ; JMP TT22          ; a tail call
     C2F6 5272     
29067               
29068               B94:
29069 C2F8 028D  22        ci   ra,(f5_)*256               ; CMP #f5           ; If red key f5 was pressed, jump to TT23 to show the
     C2FA 7400     
29070 C2FC 1602  14        jne  B95                        ; BNE B95           ; Short-range Chart, returning from the subroutine using
29071 C2FE 0460  28        b    @TT23                      ; JMP TT23          ; a tail call
     C300 592A     
29072               
29073               B95:
29074 C302 028D  22        ci   ra,(f6_)*256               ; CMP #f6           ; If red key f6 was pressed, call TT111 to select the
     C304 7500     
29075 C306 1606  14        jne  TT92                       ; BNE TT92          ; system nearest to galactic coordinates (QQ9, QQ10)
29076 C308 0200  20        li   rtmp,TT111                 ; JSR TT111         ; (the location of the chart crosshairs) and jump to
     C30A 5AB8     
29077 C30C 06A0  32        bl   @jsr                       ;
     C30E FE1E     
29078 C310 0460  28        b    @TT25                      ; JMP TT25          ; TT25 to show the Data on System screen, returning
     C312 4F0A     
29079                                                                          ; from the subroutine using a tail call
29080               
29081               TT92:
29082 C314 028D  22        ci   ra,(f9_)*256               ; CMP #f9           ; If red key f9 was pressed, jump to TT213 to show the
     C316 7700     
29083 C318 1602  14        jne  B96                        ; BNE B96           ; Inventory screen, returning from the subroutine
29084 C31A 0460  28        b    @TT213                     ; JMP TT213         ; using a tail call
     C31C 5778     
29085               
29086               B96:
29087 C31E 028D  22        ci   ra,(f7_)*256               ; CMP #f7           ; If red key f7 was pressed, jump to TT167 to show the
     C320 1600     
29088 C322 1602  14        jne  B97                        ; BNE B97           ; Market Price screen, returning from the subroutine
29089 C324 0460  28        b    @TT167                     ; JMP TT167         ; using a tail call
     C326 5E9C     
29090               
29091               B97:
29092 C328 028D  22        ci   ra,(f0_)*256               ; CMP #f0           ; If red key f0 was pressed, jump to TT110 to launch our
     C32A 2000     
29093 C32C 1602  14        jne  fvw_                       ; BNE fvw           ; ship (if docked), returning from the subroutine using
29094 C32E 0460  28        b    @TT110                     ; JMP TT110         ; a tail call
     C330 A10A     
29095               
29096               fvw_:
29097                      .bit @QQ12                      ; BIT QQ12          ; If bit 7 of QQ12 is clear (i.e. we are not docked, but
     **** ****     > BIT
0001 C332 D020  30        movb @QQ12,rtmp
     C334 009F     
0002 C336 0540  14        inv  rtmp
0003 C338 D047  18        movb rone,rtmp2
0004 C33A 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
29098 C33C 1514  14        jgt  INSP                       ; BPL INSP          ; in space), jump to INSP to skip the following checks
29099                                                                          ; for f1-f3 and "@" (save commander file) key presses
29100               
29101 C33E 028D  22        ci   ra,(f3_)*256               ; CMP #f3           ; If red key f3 was pressed, jump to EQSHP to show the
     C340 7300     
29102 C342 1602  14        jne  B98                        ; BNE B98           ; Equip Ship screen, returning from the subroutine using
29103 C344 0460  28        b    @EQSHP                     ; JMP EQSHP         ; a tail call
     C346 A23C     
29104               
29105               B98:
29106 C348 028D  22        ci   ra,(f1_)*256               ; CMP #f1           ; If red key f1 was pressed, jump to TT219 to show the
     C34A 7100     
29107 C34C 1602  14        jne  B99                        ; BNE B99           ; Buy Cargo screen, returning from the subroutine using
29108 C34E 0460  28        b    @TT219                     ; JMP TT219         ; a tail call
     C350 5476     
29109               
29110               B99:
29111 C352 028D  22        ci   ra,>47*256                 ; CMP #&47          ; If "@" was pressed, jump to SVE to save the commander
     C354 4700     
29112 C356 1602  14        jne  B100                       ; BNE B100          ; file, returning from the subroutine using a tail call
29113 C358 0460  28        b    @SVE                       ; JMP SVE
     C35A C844     
29114               
29115               B100:
29116 C35C 028D  22        ci   ra,(f2_)*256               ; CMP #f2           ; If red key f2 was pressed, jump to TT208 to show the
     C35E 7200     
29117 C360 160D  14        jne  LABEL_3                    ; BNE LABEL_3       ; Sell Cargo screen, returning from the subroutine using
29118 C362 0460  28        b    @TT208                     ; JMP TT208         ; a tail call
     C364 5654     
29119               
29120               INSP:
29121 C366 028D  22        ci   ra,(f1_)*256               ; CMP #f1           ; If the key pressed is < red key f1 or > red key f3,
     C368 7100     
29122 C36A 1708  14        jnc  LABEL_3                    ; BCC LABEL_3       ; jump to LABEL_3 (so only do the following if the key
29123 C36C 028D  22        ci   ra,(f3_+1)*256             ; CMP #f3+1         ; pressed is f1, f2 or f3)
     C36E 7400     
29124 C370 1805  14        joc  LABEL_3                    ; BCS LABEL_3
29125               
29126 C372 024D  22        andi ra,>03*256                 ; AND #3            ; If we get here then we are either in space, or we are
     C374 0300     
29127 C376 D38D  18        movb ra,rx                      ; TAX               ; docked and none of f1-f3 were pressed, so we can now
29128 C378 0460  28        b    @LOOK1                     ; JMP LOOK1         ; process f1-f3 with their in-flight functions, i.e.
     C37A 4AC4     
29129                                                                          ; switching space views
29130                                                                          ;
29131                                                                          ; A will contain &71, &72 or &73 (for f1, f2 or f3), so
29132                                                                          ; set X to the last digit (1, 2 or 3) and jump to LOOK1
29133                                                                          ; to switch to view X (rear, left or right), returning
29134                                                                          ; from the subroutine using a tail call
29135               
29136               LABEL_3:
29137 C37C 028D  22        ci   ra,>54*256                 ; CMP #&54          ; If "H" was pressed, jump to hyp to do a hyperspace
     C37E 5400     
29138 C380 1602  14        jne  B101                       ; BNE B101          ; jump (if we are in space), returning from the
29139 C382 0460  28        b    @hyp_                      ; JMP hyp           ; subroutine using a tail call
     C384 5C2C     
29140               
29141               B101:
29142 C386 028D  22        ci   ra,>32*256                 ; CMP #&32          ; If "D" was pressed, jump to T95 to print the distance
     C388 3200     
29143 C38A 133B  14        jeq  T95                        ; BEQ T95           ; to a system (if we are in one of the chart screens)
29144               
29145 C38C D80D  30        movb ra,@T1                     ; STA T1            ; Store A (the key that's been pressed) in T1
     C38E 0006     
29146               
29147 C390 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     C392 0096     
29148 C394 024D  22        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise jump down to TT107 to skip the
     C396 C000     
29149 C398 1318  14        jeq  TT107                      ; BEQ TT107         ; following
29150               
29151 C39A D360  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is non-zero,
     C39C 002F     
29152 C39E 1615  14        jne  TT107                      ; BNE TT107         ; then we are already counting down, so jump to TT107
29153                                                                          ; to skip the following
29154               
29155 C3A0 D360  30        movb @T1,ra                     ; LDA T1            ; Restore the original value of A (the key that's been
     C3A2 0006     
29156                                                                          ; pressed) from T1
29157               
29158 C3A4 028D  22        ci   ra,>36*256                 ; CMP #&36          ; If "O" was pressed, do the following three jumps,
     C3A6 3600     
29159 C3A8 160C  14        jne  ee2_                       ; BNE ee2           ; otherwise skip to ee2 to continue
29160               
29161 C3AA 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     C3AC 5872     
29162 C3AE 06A0  32        bl   @jsr                       ;
     C3B0 FE1E     
29163                                                                          ; which will erase the crosshairs currently there
29164               
29165 C3B2 0200  20        li   rtmp,ping_                 ; JSR ping          ; Set the target system to the current system (which
     C3B4 BC2C     
29166 C3B6 06A0  32        bl   @jsr                       ;
     C3B8 FE1E     
29167                                                                          ; will move the location in (QQ9, QQ10) to the current
29168                                                                          ; home system
29169               
29170 C3BA 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     C3BC 5872     
29171 C3BE 06A0  32        bl   @jsr                       ;
     C3C0 FE1E     
29172                                                                          ; which will draw the crosshairs at our current home
29173                                                                          ; system
29174               
29175               ee2_:
29176 C3C2 0200  20        li   rtmp,TT16                  ; JSR TT16          ; Call TT16 to move the crosshairs by the amount in X
     C3C4 580E     
29177 C3C6 06A0  32        bl   @jsr                       ;
     C3C8 FE1E     
29178                                                                          ; and Y, which were passed to this subroutine as
29179                                                                          ; arguments
29180               
29181               TT107:
29182 C3CA D360  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is zero, return
     C3CC 002F     
29183 C3CE 1317  14        jeq  t95_                       ; BEQ t95           ; from the subroutine (as t95 contains an RTS), as we
29184                                                                          ; are not currently counting down to a hyperspace jump
29185               
29186 C3D0 7347  18        sb   rone,ra                    ; DEC QQ22          ; Decrement the internal hyperspace counter
29187               
29188 C3D2 1615  14        jne  t95_                       ; BNE t95           ; If the internal hyperspace counter is still non-zero,
29189                                                                          ; then we are still counting down, so return from the
29190                                                                          ; subroutine (as t95 contains an RTS)
29191               
29192                                                                          ; If we get here then the internal hyperspace counter
29193                                                                          ; has just reached zero and it wasn't zero before, so
29194                                                                          ; we need to reduce the on-screen counter and update
29195                                                                          ; the screen. We do this by first printing the next
29196                                                                          ; number in the countdown sequence, and then printing
29197                                                                          ; the old number, which will erase the old number
29198                                                                          ; and display the new one because printing uses EOR
29199                                                                          ; logic
29200               
29201 C3D4 D3A0  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter - 1
     C3D6 002F     
29202 C3D8 7387  18        sb   rone,rx                    ; DEX               ; (i.e. the next number in the sequence)
29203               
29204 C3DA 0200  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1)
     C3DC 5D36     
29205 C3DE 06A0  32        bl   @jsr                       ;
     C3E0 FE1E     
29206               
29207 C3E2 020D  20        li   ra,>05*256                 ; LDA #5            ; Reset the internal hyperspace counter to 5
     C3E4 0500     
29208 C3E6 D80D  30        movb ra,@QQ22                   ; STA QQ22
     C3E8 002E     
29209               
29210 C3EA D3A0  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter (i.e. the
     C3EC 002F     
29211                                                                          ; current number in the sequence, which is already
29212                                                                          ; shown on-screen)
29213               
29214 C3EE 0200  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     C3F0 5D36     
29215 C3F2 06A0  32        bl   @jsr                       ;
     C3F4 FE1E     
29216                                                                          ; i.e. print the hyperspace countdown in the top-left
29217                                                                          ; corner
29218               
29219 C3F6 7347  18        sb   rone,ra                    ; DEC QQ22+1        ; Decrement the on-screen hyperspace countdown
29220               
29221 C3F8 1602  14        jne  t95_                       ; BNE t95           ; If the countdown is not yet at zero, return from the
29222                                                                          ; subroutine (as t95 contains an RTS)
29223               
29224 C3FA 0460  28        b    @TT18                      ; JMP TT18          ; Otherwise the countdown has finished, so jump to TT18
     C3FC A088     
29225                                                                          ; to do a hyperspace jump, returning from the subroutine
29226                                                                          ; using a tail call
29227               
29228               t95_:
29229 C3FE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C400 FE2A     
29230               
29231               T95:
29232                                                                          ; If we get here, "D" was pressed, so we need to show
29233                                                                          ; the distance to the selected system (if we are in a
29234                                                                          ; chart view)
29235 C402 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     C404 0096     
29236 C406 024D  22        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise return from the subroutine (as
     C408 C000     
29237 C40A 13F9  14        jeq  t95_                       ; BEQ t95           ; t95 contains an RTS)
29238               
29239 C40C 0200  20        li   rtmp,hm_                   ; JSR hm            ; Call hm to move the crosshairs to the target system
     C40E 4C10     
29240 C410 06A0  32        bl   @jsr                       ;
     C412 FE1E     
29241                                                                          ; in (QQ9, QQ10), returning with A = 0
29242               
29243 C414 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     C416 007E     
29244               
29245 C418 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Print control code 3 (the selected system name)
     C41A A5C4     
29246 C41C 06A0  32        bl   @jsr                       ;
     C41E FE1E     
29247               
29248 C420 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     C422 8000     
29249 C424 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     C426 007E     
29250               
29251 C428 020D  20        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1 and down one line
     C42A 0100     
29252 C42C D80D  30        movb ra,@XC                     ; STA XC            ; (in other words, to the start of the next line)
     C42E 002C     
29253 C430 B347  18        ab   rone,ra                    ; INC YC
29254               
29255 C432 0460  28        b    @TT146                     ; JMP TT146         ; Print the distance to the selected system and return
     C434 4EA2     
29256                                                                          ; from the subroutine using a tail call
29257               
29258               * ******************************************************************************
29259               *
29260               * Name: BAD
29261               * Type: Subroutine
29262               * Category: Status
29263               * Summary: Calculate how bad we have been
29264               *
29265               * ------------------------------------------------------------------------------
29266               *
29267               * Work out how bad we are from the amount of contraband in our hold. The
29268               * formula is:
29269               *
29270               * (slaves + narcotics) * 2 + firearms
29271               *
29272               * so slaves and narcotics are twice as illegal as firearms. The value in FIST
29273               * (our legal status) is set to at least this value whenever we launch from a
29274               * space station, and a FIST of 50 or more gives us fugitive status, so leaving a
29275               * station carrying 25 tonnes of slaves/narcotics, or 50 tonnes of firearms
29276               * across multiple trips, is enough to make us a fugitive.
29277               *
29278               * ------------------------------------------------------------------------------
29279               *
29280               * Returns:
29281               *
29282               * A                   A value that determines how bad we are from the amount
29283               * of contraband in our hold
29284               *
29285               * ******************************************************************************
29286               
29287               BAD:
29288 C436 D360  30        movb @QQ20+3,ra                 ; LDA QQ20+3        ; Set A to the number of tonnes of slaves in the hold
     C438 031A     
29289               
29290                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 C43A 0A16  18        sla  rzero,1
                   < elite.a99
29291                                                                          ; C flag affecting the result
29292               
29293                      .adc @QQ20+6,ra                 ; ADC QQ20+6        ; Add the number of tonnes of narcotics in the hold
     **** ****     > ADC
0001 C43C 1701  14        jnc  !
0002 C43E B347  18        ab   rone,ra
0003               !:
0004 C440 B360  30        ab   @QQ20+6,ra
     C442 031D     
                   < elite.a99
29294               
29295                      .asla                           ; ASL A             ; Double the result and add the number of tonnes of
     **** ****     > ASLA
0001 C444 024D  22        andi ra,>ff00
     C446 FF00     
0002 C448 0A1D  18        sla  ra,1
                   < elite.a99
29296                      .adc @QQ20+10,ra                ; ADC QQ20+10       ; firearms in the hold
     **** ****     > ADC
0001 C44A 1701  14        jnc  !
0002 C44C B347  18        ab   rone,ra
0003               !:
0004 C44E B360  30        ab   @QQ20+10,ra
     C450 0321     
                   < elite.a99
29297               
29298 C452 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C454 FE2A     
29299               
29300               * ******************************************************************************
29301               *
29302               * Name: FAROF
29303               * Type: Subroutine
29304               * Category: Maths (Geometry)
29305               * Summary: Compare x_hi, y_hi and z_hi with 224
29306               *
29307               * ------------------------------------------------------------------------------
29308               *
29309               * Compare x_hi, y_hi and z_hi with 224, and set the C flag if all three <= 224,
29310               * otherwise clear the C flag.
29311               *
29312               * ------------------------------------------------------------------------------
29313               *
29314               * Returns:
29315               *
29316               * C flag              Set if x_hi <= 224 and y_hi <= 224 and z_hi <= 224
29317               *
29318               * Clear otherwise (i.e. if any one of them are bigger than
29319               * 224)
29320               *
29321               * ******************************************************************************
29322               
29323               FAROF:
29324 C456 020D  20        li   ra,>e0*256                 ; LDA #224          ; Set A = 224 and fall through into FAROF2 to do the
     C458 E000     
29325                                                                          ; comparison
29326               
29327               * ******************************************************************************
29328               *
29329               * Name: FAROF2
29330               * Type: Subroutine
29331               * Category: Maths (Geometry)
29332               * Summary: Compare x_hi, y_hi and z_hi with A
29333               *
29334               * ------------------------------------------------------------------------------
29335               *
29336               * Compare x_hi, y_hi and z_hi with A, and set the C flag if all three <= A,
29337               * otherwise clear the C flag.
29338               *
29339               * ------------------------------------------------------------------------------
29340               *
29341               * Returns:
29342               *
29343               * C flag              Set if x_hi <= A and y_hi <= A and z_hi <= A
29344               *
29345               * Clear otherwise (i.e. if any one of them are bigger than
29346               * A)
29347               *
29348               * ******************************************************************************
29349               
29350               FAROF2:
29351 C45A 9360  30        cb   @INWK+1,ra                 ; CMP INWK+1        ; If A < x_hi, C will be clear so jump to MA34 to
     C45C 0054     
29352 C45E 1705  14        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29353                                                                          ; C will be set so move on to the next one
29354               
29355 C460 9360  30        cb   @INWK+4,ra                 ; CMP INWK+4        ; If A < y_hi, C will be clear so jump to MA34 to
     C462 0057     
29356 C464 1702  14        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29357                                                                          ; C will be set so move on to the next one
29358               
29359 C466 9360  30        cb   @INWK+7,ra                 ; CMP INWK+7        ; If A < z_hi, C will be clear, otherwise C will be set
     C468 005A     
29360               
29361               MA34:
29362 C46A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C46C FE2A     
29363               
29364               * ******************************************************************************
29365               *
29366               * Name: MAS4
29367               * Type: Subroutine
29368               * Category: Maths (Geometry)
29369               * Summary: Calculate a cap on the maximum distance to a ship
29370               *
29371               * ------------------------------------------------------------------------------
29372               *
29373               * Logical OR the value in A with the high bytes of the ship's position (x_hi,
29374               * y_hi and z_hi).
29375               *
29376               * ------------------------------------------------------------------------------
29377               *
29378               * Returns:
29379               *
29380               * A                   A OR x_hi OR y_hi OR z_hi
29381               *
29382               * ******************************************************************************
29383               
29384               MAS4:
29385 C46E F360  30        socb @INWK+1,ra                 ; ORA INWK+1        ; OR A with x_hi, y_hi and z_hi
     C470 0054     
29386 C472 F360  30        socb @INWK+4,ra                 ; ORA INWK+4
     C474 0057     
29387 C476 F360  30        socb @INWK+7,ra                 ; ORA INWK+7
     C478 005A     
29388               
29389 C47A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C47C FE2A     
29390               
29391               * ******************************************************************************
29392               *
29393               * Name: DEATH
29394               * Type: Subroutine
29395               * Category: Start and end
29396               * Summary: Display the death screen
29397               *
29398               * ------------------------------------------------------------------------------
29399               *
29400               * We have been killed, so display the chaos of our destruction above a "GAME
29401               * OVER" sign, and clean up the mess ready for the next attempt.
29402               *
29403               * ******************************************************************************
29404               
29405               DEATH:
29406 C47E 0200  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of us dying
     C480 CB2E     
29407 C482 06A0  32        bl   @jsr                       ;
     C484 FE1E     
29408               
29409 C486 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     C488 BF32     
29410 C48A 06A0  32        bl   @jsr                       ;
     C48C FE1E     
29411               
29412                      .asl @DELTA                     ; ASL DELTA         ; Divide our speed in DELTA by 4
     **** ****     > ASL
0001 C48E D020  30        movb @DELTA,rtmp
     C490 008C     
0002 C492 0240  22        andi rtmp,>ff00
     C494 FF00     
0003 C496 0A10  18        sla  rtmp,1
0004 C498 D800  30        movb rtmp,@DELTA
     C49A 008C     
                   < elite.a99
29413                      .asl @DELTA                     ; ASL DELTA
     **** ****     > ASL
0001 C49C D020  30        movb @DELTA,rtmp
     C49E 008C     
0002 C4A0 0240  22        andi rtmp,>ff00
     C4A2 FF00     
0003 C4A4 0A10  18        sla  rtmp,1
0004 C4A6 D800  30        movb rtmp,@DELTA
     C4A8 008C     
                   < elite.a99
29414               
29415 C4AA 020E  20        li   rx,>18*256                 ; LDX #24           ; Set the screen to only show 24 text rows, which hides
     C4AC 1800     
29416 C4AE 0200  20        li   rtmp,DET1                  ; JSR DET1          ; the dashboard, setting A to 6 in the process
     C4B0 ACC0     
29417 C4B2 06A0  32        bl   @jsr                       ;
     C4B4 FE1E     
29418               
29419 C4B6 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     C4B8 4B2A     
29420 C4BA 06A0  32        bl   @jsr                       ;
     C4BC FE1E     
29421                                                                          ; and set the current view type in QQ11 to 6 (death
29422                                                                          ; screen)
29423               
29424 C4BE 0200  20        li   rtmp,BOX                   ; JSR BOX           ; Call BOX to redraw the same white border (BOX is part
     C4C0 4B6A     
29425 C4C2 06A0  32        bl   @jsr                       ;
     C4C4 FE1E     
29426                                                                          ; of TT66), which removes the border as it is drawn
29427                                                                          ; using EOR logic
29428               
29429 C4C6 0200  20        li   rtmp,nWq                   ; JSR nWq           ; Create a cloud of stardust containing the correct
     C4C8 ABEC     
29430 C4CA 06A0  32        bl   @jsr                       ;
     C4CC FE1E     
29431                                                                          ; number of dust particles (i.e. NOSTM of them)
29432               
29433 C4CE 020D  20        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12 on row 12
     C4D0 0C00     
29434 C4D2 D80D  30        movb ra,@YC                     ; STA YC
     C4D4 002D     
29435 C4D6 D80D  30        movb ra,@XC                     ; STA XC
     C4D8 002C     
29436               
29437 C4DA 020D  20        li   ra,>92*256                 ; LDA #146          ; Print recursive token 146 ("{all caps}GAME OVER")
     C4DC 9200     
29438 C4DE 0200  20        li   rtmp,ex_                   ; JSR ex
     C4E0 A802     
29439 C4E2 06A0  32        bl   @jsr                       ;
     C4E4 FE1E     
29440               
29441               D1:
29442 C4E6 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C4E8 C032     
29443 C4EA 06A0  32        bl   @jsr                       ;
     C4EC FE1E     
29444                                                                          ; ship, and set A and X to random values
29445               
29446 C4EE 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 4, so A is now between 0 and 63, and
29447 C4F0 091D  18        srl  ra,1                       ; LSR A             ; store in byte #0 (x_lo)
29448 C4F2 D80D  30        movb ra,@INWK                   ; STA INWK
     C4F4 0053     
29449               
29450 C4F6 020F  20        li   ry,>00*256                 ; LDY #0            ; Set the following to 0: the current view in QQ11
     C4F8 0000     
29451 C4FA D80F  30        movb ry,@QQ11                   ; STY QQ11          ; (space view), x_hi, y_hi, z_hi and the AI flag (no AI
     C4FC 0096     
29452 C4FE D80F  30        movb ry,@INWK+1                 ; STY INWK+1        ; or E.C.M. and not hostile)
     C500 0054     
29453 C502 D80F  30        movb ry,@INWK+4                 ; STY INWK+4
     C504 0057     
29454 C506 D80F  30        movb ry,@INWK+7                 ; STY INWK+7
     C508 005A     
29455 C50A D80F  30        movb ry,@INWK+32                ; STY INWK+32
     C50C 0073     
29456               
29457 C50E 73C7  18        sb   rone,ry                    ; DEY               ; Set Y = 255
29458               
29459 C510 D80F  30        movb ry,@MCNT                   ; STY MCNT          ; Reset the main loop counter to 255, so all timer-based
     C512 0099     
29460                                                                          ; calls will be stopped
29461               
29462 C514 D80F  30        movb ry,@LASCT                  ; STY LASCT         ; Set the laser count to 255 to act as a counter in the
     C516 0D60     
29463                                                                          ; D2 loop below, so this setting determines how long the
29464                                                                          ; death animation lasts (it's 5.1 seconds, as LASCT is
29465                                                                          ; decremented every vertical sync, or 50 times a second,
29466                                                                          ; and 255 / 50 = 5.1)
29467               
29468                      .eoi (>2a*256)                  ; EOR #%00101010    ; Flip bits 1, 3 and 5 in A (x_lo) to get another number
     **** ****     > EOI
0001 C518 0200  20        li   rtmp,(>2A*256)
     C51A 2A00     
0002 C51C 2B40  18        xor  rtmp,ra
                   < elite.a99
29469 C51E D80D  30        movb ra,@INWK+3                 ; STA INWK+3        ; between 48 and 63, and store in byte #3 (y_lo)
     C520 0056     
29470               
29471 C522 026D  22        ori  ra,>50*256                 ; ORA #%01010000    ; Set bits 4 and 6 of A to bump it up to between 112 and
     C524 5000     
29472 C526 D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; 127, and store in byte #6 (z_lo)
     C528 0059     
29473               
29474 C52A D34E  18        movb rx,ra                      ; TXA               ; Set A to the random number in X and keep bits 0-3 and
29475 C52C 024D  22        andi ra,>8f*256                 ; AND #%10001111    ; the sign in bit 7 to get a number between -15 and +15,
     C52E 8F00     
29476 C530 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; and store in byte #29 (roll counter) to give our ship
     C532 0070     
29477                                                                          ; a gentle roll with damping
29478               
29479 C534 06A0  32        bl   @rora                      ; ROR A             ; The C flag is randomly set from the above call to Ze,
     C536 FE58     
29480 C538 024D  22        andi ra,>87*256                 ; AND #%10000111    ; so this sets A to a number between -7 and +7, which
     C53A 8700     
29481 C53C D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; we store in byte #30 (the pitch counter) to give our
     C53E 0071     
29482                                                                          ; ship a very gentle pitch with damping
29483               
29484                      .php                            ; PHP               ; Store the processor flags
     **** ****     > PHP
0001 C540 02C0  12        stst rtmp
0002 C542 D680  30        movb rtmp,*rsp
0003 C544 060A  14        dec  rsp
                   < elite.a99
29485               
29486 C546 020E  20        li   rx,(OIL)*256               ; LDX #OIL          ; Call fq1 with X set to #OIL, which adds a new cargo
     C548 0B00     
29487 C54A 0200  20        li   rtmp,fq1_                  ; JSR fq1           ; canister to our local bubble of universe and points it
     C54C 3C08     
29488 C54E 06A0  32        bl   @jsr                       ;
     C550 FE1E     
29489                                                                          ; away from us with double DELTA speed (i.e. 6, as DELTA
29490                                                                          ; was set to 3 by the call to RES2 above). INF is set to
29491                                                                          ; point to the canister's ship data block in K%
29492               
29493                      .plp                            ; PLP               ; Restore the processor flags, including our random C
     **** ****     > PLP
0001 C552 058A  14        INC  rsp
0002 C554 D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
29494                                                                          ; flag from before
29495               
29496 C556 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to our random C flag and store in byte
     C558 0000     
29497 C55A 06A0  32        bl   @rora                      ; ROR A             ; #31 of the ship's data block, so this has a 50% chance
     C55C FE58     
29498 C55E 020F  20        li   ry,>1f*256                 ; LDY #31           ; of marking our new canister as being killed (so it
     C560 1F00     
29499                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; will explode)
     **** ****     > ST_IND_Y_IDX
0001 C562 D820  50        movb @INF,@rtmplb
     C564 0020     
     C566 206D     
0002 C568 D020  30        movb @INF+1,rtmp
     C56A 0021     
0003 C56C A00F  18        a    ry,rtmp
0004 C56E D40D  30        movb RA,*rtmp
                   < elite.a99
29500               
29501 C570 D360  30        movb @FRIN+3,ra                 ; LDA FRIN+3        ; The call we made to RES2 before we entered the loop at
     C572 0D43     
29502 C574 13B8  14        jeq  D1                         ; BEQ D1            ; D1 will have reset all the ship slots at FRIN, so this
29503                                                                          ; checks to see if the fourth slot is empty, and if it
29504                                                                          ; is we loop back to D1 to add another canister, until
29505                                                                          ; we have added four of them
29506               
29507 C576 0200  20        li   rtmp,U.                    ; JSR U%            ; Clear the key logger, which also sets A = 0
     C578 CCF6     
29508 C57A 06A0  32        bl   @jsr                       ;
     C57C FE1E     
29509               
29510 C57E D80D  30        movb ra,@DELTA                  ; STA DELTA         ; Set our speed in DELTA to 0, as we aren't going
     C580 008C     
29511                                                                          ; anywhere any more
29512               
29513               D2:
29514 C582 0200  20        li   rtmp,M.                    ; JSR M%            ; Call the M% routine to do the main flight loop once,
     C584 0F52     
29515 C586 06A0  32        bl   @jsr                       ;
     C588 FE1E     
29516                                                                          ; which will display our exploding canister scene and
29517                                                                          ; move everything about
29518               
29519 C58A D360  30        movb @LASCT,ra                  ; LDA LASCT         ; Loop back to D2 to run the main flight loop until
     C58C 0D60     
29520 C58E 16F9  14        jne  D2                         ; BNE D2            ; LASCT reaches zero (which will take 5.1 seconds, as
29521                                                                          ; explained above)
29522               
29523 C590 020E  20        li   rx,>1f*256                 ; LDX #31           ; Set the screen to show all 31 text rows, which shows
     C592 1F00     
29524 C594 0200  20        li   rtmp,DET1                  ; JSR DET1          ; the dashboard
     C596 ACC0     
29525 C598 06A0  32        bl   @jsr                       ;
     C59A FE1E     
29526               
29527                                                                          ; Fall through into DEATH2 to reset and restart the game
29528               
29529               * ******************************************************************************
29530               *
29531               * Name: DEATH2
29532               * Type: Subroutine
29533               * Category: Start and end
29534               * Summary: Reset most of the game and restart from the title screen
29535               *
29536               * ------------------------------------------------------------------------------
29537               *
29538               * This routine is called following death, and when the game is quit by pressing
29539               * ESCAPE when paused.
29540               *
29541               * ******************************************************************************
29542               
29543               DEATH2:
29544 C59C 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     C59E BF32     
29545 C5A0 06A0  32        bl   @jsr                       ;
     C5A2 FE1E     
29546                                                                          ; and fall through into the entry code for the game
29547                                                                          ; to restart from the title screen
29548               
29549               * ******************************************************************************
29550               *
29551               * Name: TT170
29552               * Type: Subroutine
29553               * Category: Start and end
29554               * Summary: Main entry point for the Elite game code
29555               * Deep dive: Program flow of the main game loop
29556               *
29557               * ------------------------------------------------------------------------------
29558               *
29559               * This is the main entry point for the main game code.
29560               *
29561               * ******************************************************************************
29562               
29563               TT170:
29564 C5A4 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     C5A6 FF00     
29565 C5A8 D80E  38        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     C5AA 2081     
29566                                                                          ; effectively resets the stack. We need to do this
29567                                                                          ; because the loader code in elite-loader.asm pushes
29568                                                                          ; code onto the stack, and this effectively removes that
29569                                                                          ; code so we start afresh
29570               
29571                                                                          ; Fall through into BR1 to start the game
29572               
29573               * ******************************************************************************
29574               *
29575               * Name: BR1 (Part 1 of 2)
29576               * Type: Subroutine
29577               * Category: Start and end
29578               * Summary: Show the "Load New Commander (Y/N)?" screen and start the game
29579               *
29580               * ------------------------------------------------------------------------------
29581               *
29582               * BRKV is set to point to BR1 by the loading process.
29583               *
29584               * ******************************************************************************
29585               
29586               BR1:
29587 C5AC 020E  20        li   rx,>03*256                 ; LDX #3            ; Set XC = 3 (set text cursor to column 3)
     C5AE 0300     
29588 C5B0 D80E  30        movb rx,@XC                     ; STX XC
     C5B2 002C     
29589               
29590 C5B4 0200  20        li   rtmp,FX200                 ; JSR FX200         ; Disable the ESCAPE key and clear memory if the BREAK
     C5B6 C96A     
29591 C5B8 06A0  32        bl   @jsr                       ;
     C5BA FE1E     
29592                                                                          ; key is pressed (*FX 200,3)
29593               
29594 C5BC 020E  20        li   rx,(CYL)*256               ; LDX #CYL          ; Call TITLE to show a rotating Cobra Mk III (#CYL) and
     C5BE 0700     
29595 C5C0 020D  20        li   ra,>80*256                 ; LDA #128          ; token 128 ("  LOAD NEW COMMANDER (Y/N)?{crlf}{crlf}"),
     C5C2 8000     
29596 C5C4 0200  20        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     C5C6 C66C     
29597 C5C8 06A0  32        bl   @jsr                       ;
     C5CA FE1E     
29598                                                                          ; in A
29599               
29600 C5CC 028D  22        ci   ra,>44*256                 ; CMP #&44          ; Did we press "Y"? If not, jump to QU5, otherwise
     C5CE 4400     
29601 C5D0 1610  14        jne  QU5                        ; BNE QU5           ; continue on to load a new commander
29602               
29603               * BR1                    \ These instructions are commented out in the original
29604               * LDX #3                 \ source. This block starts with the same *FX call as
29605               * STX XC                 \ above, then clears the screen, calls a routine to
29606               * JSR FX200              \ flush the keyboard buffer (FLKB) that isn't present
29607               * LDA #1                 \ in the cassette version but is in other versions,
29608               * JSR TT66               \ and then it displays "LOAD NEW COMMANDER (Y/N)?" and
29609               * JSR FLKB               \ lists the current cargo, before falling straight into
29610               * LDA #14                \ the load routine below, whether or not we have
29611               * JSR TT214              \ pressed "Y". This may be a bit of testing code, as the
29612               * BCC QU5                \ first line is a commented label, BR1, which is where
29613                                                                          ; BRKV points, so when this is uncommented, pressing
29614                                                                          ; the BREAK key should jump straight to the load screen
29615               
29616 C5D2 0200  20        li   rtmp,GTNME                 ; JSR GTNME         ; We want to load a new commander, so we need to get
     C5D4 C7B0     
29617 C5D6 06A0  32        bl   @jsr                       ;
     C5D8 FE1E     
29618                                                                          ; the commander name to load
29619               
29620 C5DA 0200  20        li   rtmp,LOD                   ; JSR LOD           ; We then call the LOD subroutine to load the commander
     C5DC C924     
29621 C5DE 06A0  32        bl   @jsr                       ;
     C5E0 FE1E     
29622                                                                          ; file to address NA%+8, which is where we store the
29623                                                                          ; commander save file
29624               
29625 C5E2 0200  20        li   rtmp,TRNME                 ; JSR TRNME         ; Once loaded, we copy the commander name to NA%
     C5E4 C78C     
29626 C5E6 06A0  32        bl   @jsr                       ;
     C5E8 FE1E     
29627               
29628 C5EA 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; And we clear the top part of the screen and draw a
     C5EC 4B2E     
29629 C5EE 06A0  32        bl   @jsr                       ;
     C5F0 FE1E     
29630                                                                          ; white border
29631               
29632               * ******************************************************************************
29633               *
29634               * Name: QU5
29635               * Type: Subroutine
29636               * Category: Start and end
29637               * Summary: Reset the current commander data block to the last saved commander
29638               *
29639               * ******************************************************************************
29640               
29641               QU5:
29642                                                                          ; By the time we get here, the correct commander name
29643                                                                          ; is at NA% and the correct commander data is at NA%+8.
29644                                                                          ; Specifically:
29645                                                                          ;
29646                                                                          ; * If we loaded a commander file, then the name and
29647                                                                          ; data from that file will be at NA% and NA%+8
29648                                                                          ;
29649                                                                          ; * If this is a brand new game, then NA% will contain
29650                                                                          ; the default starting commander name ("JAMESON")
29651                                                                          ; and NA%+8 will contain the default commander data
29652                                                                          ;
29653                                                                          ; * If this is not a new game (because they died or
29654                                                                          ; quit) and we didn't want to load a commander file,
29655                                                                          ; then NA% will contain the last saved commander
29656                                                                          ; name, and NA%+8 the last saved commander data. If
29657                                                                          ; the game has never been saved, this will still be
29658                                                                          ; the default commander
29659               * JSR TTX66              \ This instruction is commented out in the original
29660                                                                          ; source; it clears the screen and draws a border
29661 C5F2 020E  20        li   rx,(NT.)*256               ; LDX #NT%          ; The size of the commander data block is NT% bytes,
     C5F4 4B00     
29662                                                                          ; and it starts at NA%+8, so we need to copy the data
29663                                                                          ; from the "last saved" buffer at NA%+8 to the current
29664                                                                          ; commander workspace at TP. So we set up a counter in X
29665                                                                          ; for the NT% bytes that we want to copy
29666               
29667               QUL1:
29668 C5F6 D36E  34        movb @NA.+7(rx),ra              ; LDA NA%+7,X       ; Copy the X-th byte of NA%+7 to the X-th byte of TP-1,
     C5F8 21CF     
29669 C5FA DB8D  38        movb ra,@TP-1(rx)               ; STA TP-1,X        ; (the -1 is because X is counting down from NT% to 1)
     C5FC 02FF     
29670               
29671 C5FE 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
29672               
29673 C600 16FA  14        jne  QUL1                       ; BNE QUL1          ; Loop back for the next byte of the commander data
29674                                                                          ; block
29675               
29676 C602 D80E  30        movb rx,@QQ11                   ; STX QQ11          ; X is 0 by the end of the above loop, so this sets QQ11
     C604 0096     
29677                                                                          ; to 0, which means we will be showing a view without a
29678                                                                          ; boxed title at the top (i.e. we're going to use the
29679                                                                          ; screen layout of a space view in the following)
29680               
29681                                                                          ; If the commander check below fails, we keep jumping
29682                                                                          ; back to here to crash the game with an infinite loop
29683               
29684               B102:
29685 C606 0200  20        li   rtmp,CHECK                 ; JSR CHECK         ; Call the CHECK subroutine to calculate the checksum
     C608 C76E     
29686 C60A 06A0  32        bl   @jsr                       ;
     C60C FE1E     
29687                                                                          ; for the current commander block at NA%+8 and put it
29688                                                                          ; in A
29689               
29690 C60E 9360  34        cb   @CHK,ra                    ; CMP CHK           ; Test the calculated checksum against CHK
     C610 221E     
29691               
29693               
29694 C612 1000  14        nop                             ; NOP               ; If we have disabled checksums, then ignore the result
29695 C614 1000  14        nop                             ; NOP               ; of the comparison and fall through into the next part
29696               
29705               
29706                                                                          ; The checksum CHK is correct, so now we check whether
29707                                                                          ; CHK2 = CHK EOR A9, and if this check fails, bit 7 of
29708                                                                          ; the competition flags at COK gets set, to indicate
29709                                                                          ; to Acornsoft via the competition code that there has
29710                                                                          ; been some hacking going on with this competition entry
29711               
29712                      .eoi (>a9*256)                  ; EOR #&A9          ; X = checksum EOR &A9
     **** ****     > EOI
0001 C616 0200  20        li   rtmp,(>A9*256)
     C618 A900     
0002 C61A 2B40  18        xor  rtmp,ra
                   < elite.a99
29713 C61C D38D  18        movb ra,rx                      ; TAX
29714               
29715 C61E D360  30        movb @COK,ra                    ; LDA COK           ; Set A to the competition flags in COK
     C620 030E     
29716               
29717 C622 93A0  34        cb   @CHK2,rx                   ; CPX CHK2          ; If X = CHK2, then skip the next instruction
     C624 221D     
29718 C626 1302  14        jeq  tZ                         ; BEQ tZ
29719               
29720 C628 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A to indicate this commander file has
     C62A 8000     
29721                                                                          ; been tampered with
29722               
29723               tZ:
29724 C62C 026D  22        ori  ra,>02*256                 ; ORA #%00000010    ; Set bit 1 of A to denote that this is the cassette
     C62E 0200     
29725                                                                          ; version
29726               
29727 C630 D80D  30        movb ra,@COK                    ; STA COK           ; Store the updated competition flags in COK
     C632 030E     
29728               
29729               * ******************************************************************************
29730               *
29731               * Name: BR1 (Part 2 of 2)
29732               * Type: Subroutine
29733               * Category: Start and end
29734               * Summary: Show the "Press Fire or Space, Commander" screen and start the
29735               * game
29736               *
29737               * ------------------------------------------------------------------------------
29738               *
29739               * BRKV is set to point to BR1 by the loading process.
29740               *
29741               * ******************************************************************************
29742               
29743 C634 0200  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     C636 BFE8     
29744 C638 06A0  32        bl   @jsr                       ;
     C63A FE1E     
29745                                                                          ; them are targeted
29746               
29747 C63C 020D  20        li   ra,>93*256                 ; LDA #147          ; Call TITLE to show a rotating Mamba (#3) and token
     C63E 9300     
29748 C640 020E  20        li   rx,>03*256                 ; LDX #3            ; 147 ("PRESS FIRE OR SPACE,COMMANDER.{crlf}{crlf}"),
     C642 0300     
29749 C644 0200  20        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     C646 C66C     
29750 C648 06A0  32        bl   @jsr                       ;
     C64A FE1E     
29751                                                                          ; in A
29752               
29753 C64C 0200  20        li   rtmp,ping_                 ; JSR ping          ; Set the target system coordinates (QQ9, QQ10) to the
     C64E BC2C     
29754 C650 06A0  32        bl   @jsr                       ;
     C652 FE1E     
29755                                                                          ; current system coordinates (QQ0, QQ1) we just loaded
29756               
29757 C654 0200  20        li   rtmp,hyp1_                 ; JSR hyp1          ; Arrive in the system closest to (QQ9, QQ10)
     C656 5F28     
29758 C658 06A0  32        bl   @jsr                       ;
     C65A FE1E     
29759               
29760                                                                          ; Fall through into the docking bay routine below
29761               
29762               * ******************************************************************************
29763               *
29764               * Name: BAY
29765               * Type: Subroutine
29766               * Category: Status
29767               * Summary: Go to the docking bay (i.e. show the Status Mode screen)
29768               *
29769               * ------------------------------------------------------------------------------
29770               *
29771               * We end up here after the start-up process (load commander etc.), as well as
29772               * after a successful save, an escape pod launch, a successful docking, the end
29773               * of a cargo sell, and various errors (such as not having enough cash, entering
29774               * too many items when buying, trying to fit an item to your ship when you
29775               * already have it, running out of cargo space, and so on).
29776               *
29777               * ******************************************************************************
29778               
29779               BAY:
29780 C65C 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set QQ12 = &FF (the docked flag) to indicate that we
     C65E FF00     
29781 C660 D80D  30        movb ra,@QQ12                   ; STA QQ12          ; are docked
     C662 009F     
29782               
29783 C664 020D  20        li   ra,(f8_)*256               ; LDA #f8           ; Jump into the main loop at FRCE, setting the key
     C666 7600     
29784 C668 0460  28        b    @FRCE                      ; JMP FRCE          ; that's "pressed" to red key f8 (so we show the Status
     C66A C2B8     
29785                                                                          ; Mode screen)
29786               
29787               * ******************************************************************************
29788               *
29789               * Name: TITLE
29790               * Type: Subroutine
29791               * Category: Start and end
29792               * Summary: Display a title screen with a rotating ship and prompt
29793               *
29794               * ------------------------------------------------------------------------------
29795               *
29796               * Display the title screen, with a rotating ship and a text token at the bottom
29797               * of the screen.
29798               *
29799               * ------------------------------------------------------------------------------
29800               *
29801               * Arguments:
29802               *
29803               * A                   The number of the recursive token to show below the
29804               * rotating ship (see variable QQ18 for details of
29805               * recursive tokens)
29806               *
29807               * X                   The type of the ship to show (see variable XX21 for a
29808               * list of ship types)
29809               *
29810               * ------------------------------------------------------------------------------
29811               *
29812               * Returns:
29813               *
29814               * X                   If a key is being pressed, X contains the internal key
29815               * number, otherwise it contains 0
29816               *
29817               * ******************************************************************************
29818               
29819               TITLE:
29820                      .pha                            ; PHA               ; Store the token number on the stack for later
     **** ****     > PHA
0001 C66C D68D  30        movb ra,*rsp
0002 C66E 060A  14        dec  rsp
                   < elite.a99
29821               
29822 C670 D80E  30        movb rx,@TYPE                   ; STX TYPE          ; Store the ship type in location TYPE
     C672 009B     
29823               
29824 C674 0200  20        li   rtmp,RESET                 ; JSR RESET         ; Reset our ship so we can use it for the rotating
     C676 BF0A     
29825 C678 06A0  32        bl   @jsr                       ;
     C67A FE1E     
29826                                                                          ; title ship
29827               
29828 C67C 020D  20        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     C67E 0100     
29829 C680 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     C682 4B2A     
29830 C684 06A0  32        bl   @jsr                       ;
     C686 FE1E     
29831               
29832 C688 7347  18        sb   rone,ra                    ; DEC QQ11          ; Decrement QQ11 to 0, so from here on we are using a
29833                                                                          ; space view
29834               
29835 C68A 020D  20        li   ra,>60*256                 ; LDA #96           ; Set nosev_z hi = 96 (96 is the value of unity in the
     C68C 6000     
29836 C68E D80D  30        movb ra,@INWK+14                ; STA INWK+14       ; rotation vector)
     C690 0061     
29837               
29838               * LSR A                  \ This instruction is commented out in the original
29839                                                                          ; source. It would halve the value of z_hi to 48, so the
29840                                                                          ; ship would start off closer to the viewer
29841               
29842 C692 D80D  30        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi, the high byte of the ship's z-coordinate,
     C694 005A     
29843                                                                          ; to 96, which is the distance at which the rotating
29844                                                                          ; ship starts out before coming towards us
29845               
29846 C696 020E  20        li   rx,>7f*256                 ; LDX #127          ; Set roll counter = 127, so don't dampen the roll and
     C698 7F00     
29847 C69A D80E  30        movb rx,@INWK+29                ; STX INWK+29       ; make the roll direction clockwise
     C69C 0070     
29848               
29849 C69E D80E  30        movb rx,@INWK+30                ; STX INWK+30       ; Set pitch counter = 127, so don't dampen the pitch and
     C6A0 0071     
29850                                                                          ; set the pitch direction to dive
29851               
29852 C6A2 B387  18        ab   rone,rx                    ; INX               ; Set QQ17 to 128 (so bit 7 is set) to switch to
29853 C6A4 D80E  30        movb rx,@QQ17                   ; STX QQ17          ; Sentence Case, with the next letter printing in upper
     C6A6 007E     
29854                                                                          ; case
29855               
29856 C6A8 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Set up a new ship, using the ship type in TYPE
     C6AA 009B     
29857 C6AC 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP
     C6AE AF7A     
29858 C6B0 06A0  32        bl   @jsr                       ;
     C6B2 FE1E     
29859               
29860 C6B4 020F  20        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6
     C6B6 0600     
29861 C6B8 D80F  30        movb ry,@XC                     ; STY XC
     C6BA 002C     
29862               
29863 C6BC 0200  20        li   rtmp,DELAY                 ; JSR DELAY         ; Delay for 6 vertical syncs (6/50 = 0.12 seconds)
     C6BE 4C00     
29864 C6C0 06A0  32        bl   @jsr                       ;
     C6C2 FE1E     
29865               
29866 C6C4 020D  20        li   ra,>1e*256                 ; LDA #30           ; Print recursive token 144 ("---- E L I T E ----")
     C6C6 1E00     
29867 C6C8 0200  20        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     C6CA A6D0     
29868 C6CC 06A0  32        bl   @jsr                       ;
     C6CE FE1E     
29869               
29870 C6D0 020F  20        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6 again
     C6D2 0600     
29871 C6D4 D80F  30        movb ry,@XC                     ; STY XC
     C6D6 002C     
29872               
29873 C6D8 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row
29874               
29875 C6DA D360  30        movb @PATG,ra                   ; LDA PATG          ; If PATG = 0, skip the following two lines, which
     C6DC 0F4C     
29876 C6DE 1306  14        jeq  awe_                       ; BEQ awe           ; print the author credits (PATG can be toggled by
29877                                                                          ; pausing the game and pressing "X")
29878               
29879 C6E0 020D  20        li   ra,>fe*256                 ; LDA #254          ; Print recursive token 94 ("BY D.BRABEN & I.BELL")
     C6E2 FE00     
29880 C6E4 0200  20        li   rtmp,TT27                  ; JSR TT27
     C6E6 A6E8     
29881 C6E8 06A0  32        bl   @jsr                       ;
     C6EA FE1E     
29882               
29883               awe_:
29884 C6EC 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     C6EE 4C2E     
29885 C6F0 06A0  32        bl   @jsr                       ;
     C6F2 FE1E     
29886                                                                          ; and move the text cursor to column 1 on row 21, i.e.
29887                                                                          ; the start of the top row of the three bottom rows.
29888                                                                          ; It also returns with Y = 0
29889               
29890 C6F4 D80F  30        movb ry,@DELTA                  ; STY DELTA         ; Set DELTA = 0 (i.e. ship speed = 0)
     C6F6 008C     
29891               
29892 C6F8 D80F  30        movb ry,@JSTK                   ; STY JSTK          ; Set JSTK = 0 (i.e. keyboard, not joystick)
     C6FA 0F50     
29893               
29894                      .pla                            ; PLA               ; Restore the recursive token number we stored on the
     **** ****     > PLA
0001 C6FC 058A  14        inc  rsp
0002 C6FE D35A  26        movb *rsp,ra
                   < elite.a99
29895 C700 0200  20        li   rtmp,ex_                   ; JSR ex            ; stack at the start of this subroutine, and print that
     C702 A802     
29896 C704 06A0  32        bl   @jsr                       ;
     C706 FE1E     
29897                                                                          ; token
29898               
29899 C708 020D  20        li   ra,>94*256                 ; LDA #148          ; Set A to recursive token 148
     C70A 9400     
29900               
29901 C70C 020E  20        li   rx,>07*256                 ; LDX #7            ; Move the text cursor to column 7
     C70E 0700     
29902 C710 D80E  30        movb rx,@XC                     ; STX XC
     C712 002C     
29903               
29904 C714 0200  20        li   rtmp,ex_                   ; JSR ex            ; Print recursive token 148 ("(C) ACORNSOFT 1984")
     C716 A802     
29905 C718 06A0  32        bl   @jsr                       ;
     C71A FE1E     
29906               
29907               TLL2:
29908 C71C D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi (the ship's distance) is 1, jump to TL1 to
     C71E 005A     
29909 C720 028D  22        ci   ra,>01*256                 ; CMP #1            ; skip the following decrement
     C722 0100     
29910 C724 1301  14        jeq  TL1                        ; BEQ TL1
29911               
29912 C726 7347  18        sb   rone,ra                    ; DEC INWK+7        ; Decrement the ship's distance, to bring the ship
29913                                                                          ; a bit closer to us
29914               
29915               TL1:
29916 C728 0200  20        li   rtmp,MVEIT                 ; JSR MVEIT         ; Move the ship in space according to the orientation
     C72A 17E2     
29917 C72C 06A0  32        bl   @jsr                       ;
     C72E FE1E     
29918                                                                          ; vectors and the new value in z_hi
29919               
29920 C730 020D  20        li   ra,>80*256                 ; LDA #128          ; Set z_lo = 128, so the closest the ship gets to us is
     C732 8000     
29921 C734 D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; z_hi = 1, z_lo = 128, or 256 + 128 = 384
     C736 0059     
29922               
29923                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 C738 024D  22        andi ra,>ff00
     C73A FF00     
0002 C73C 0A1D  18        sla  ra,1
                   < elite.a99
29924               
29925 C73E D80D  30        movb ra,@INWK                   ; STA INWK          ; Set x_lo = 0, so the ship remains in the screen centre
     C740 0053     
29926               
29927 C742 D80D  30        movb ra,@INWK+3                 ; STA INWK+3        ; Set y_lo = 0, so the ship remains in the screen centre
     C744 0056     
29928               
29929 C746 0200  20        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to display the ship
     C748 D4B4     
29930 C74A 06A0  32        bl   @jsr                       ;
     C74C FE1E     
29931               
29932 C74E 7347  18        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter
29933               
29934 C750 D360  34        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     C752 FE40     
29935               
29936 C754 024D  22        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     C756 1000     
29937                                                                          ; button is pressed, otherwise it is set, so AND'ing
29938                                                                          ; the value of IRB with %10000 extracts this bit
29939               
29940               * TAX                    \ This instruction is commented out in the original
29941                                                                          ; source; it would have no effect, as the comparison
29942                                                                          ; flags are already set by the AND, and the value of X
29943                                                                          ; is not used anywhere
29944               
29945 C758 1307  14        jeq  TL2                        ; BEQ TL2           ; If the joystick fire button is pressed, jump to TL2
29946               
29947 C75A 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press
     C75C CAF4     
29948 C75E 06A0  32        bl   @jsr                       ;
     C760 FE1E     
29949               
29950 C762 13DC  14        jeq  TLL2                       ; BEQ TLL2          ; If no key was pressed, loop back up to move/rotate
29951                                                                          ; the ship and check again for a key press
29952               
29953 C764 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C766 FE2A     
29954               
29955               TL2:
29956 C768 7347  18        sb   rone,ra                    ; DEC JSTK          ; Joystick fire button was pressed, so set JSTK to &FF
29957                                                                          ; (it was set to 0 above), to disable keyboard and
29958                                                                          ; enable joysticks
29959               
29960 C76A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C76C FE2A     
29961               
29962               * ******************************************************************************
29963               *
29964               * Name: CHECK
29965               * Type: Subroutine
29966               * Category: Save and load
29967               * Summary: Calculate the checksum for the last saved commander data block
29968               * Deep dive: Commander save files
29969               *
29970               * ------------------------------------------------------------------------------
29971               *
29972               * The checksum for the last saved commander data block is saved as part of the
29973               * commander file, in two places (CHK AND CHK2), to protect against file
29974               * tampering. This routine calculates the checksum and returns it in A.
29975               *
29976               * This algorithm is also implemented in elite-checksum.py.
29977               *
29978               * ------------------------------------------------------------------------------
29979               *
29980               * Returns:
29981               *
29982               * A                   The checksum for the last saved commander data block
29983               *
29984               * ******************************************************************************
29985               
29986               CHECK:
29987 C76E 020E  20        li   rx,(NT.-2)*256             ; LDX #NT%-2        ; Set X to the size of the commander data block, less
     C770 4900     
29988                                                                          ; 2 (to omit the checksum bytes and the save count)
29989               
29990                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 C772 0A16  18        sla  rzero,1
                   < elite.a99
29991                                                                          ; C flag affecting the result
29992               
29993 C774 D34E  18        movb rx,ra                      ; TXA               ; Seed the checksum calculation by setting A to the
29994                                                                          ; size of the commander data block, less 2
29995               
29996                                                                          ; We now loop through the commander data block,
29997                                                                          ; starting at the end and looping down to the start
29998                                                                          ; (so at the start of this loop, the X-th byte is the
29999                                                                          ; last byte of the commander data block, i.e. the save
30000                                                                          ; count)
30001               
30002               QUL2:
30003                      .adc @NA.+7(rx),ra              ; ADC NA%+7,X       ; Add the X-1-th byte of the data block to A, plus the
     **** ****     > ADC
0001 C776 1701  14        jnc  !
0002 C778 B347  18        ab   rone,ra
0003               !:
0004 C77A B36E  34        ab   @NA.+7(RX),ra
     C77C 21CF     
                   < elite.a99
30004                                                                          ; C flag
30005               
30006                      .eor @NA.+8(rx)                 ; EOR NA%+8,X       ; EOR A with the X-th byte of the data block
     **** ****     > EOR
0001 C77E D02E  34        movb @NA.+8(RX),rtmp
     C780 21D0     
0002 C782 2B40  18        xor  rtmp,ra
                   < elite.a99
30007               
30008 C784 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30009               
30010 C786 16F7  14        jne  QUL2                       ; BNE QUL2          ; Loop back for the next byte in the calculation, until
30011                                                                          ; we have added byte #0 and EOR'd with byte #1 of the
30012                                                                          ; data block
30013               
30014 C788 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C78A FE2A     
30015               
30016               * ******************************************************************************
30017               *
30018               * Name: TRNME
30019               * Type: Subroutine
30020               * Category: Save and load
30021               * Summary: Copy the last saved commander's name from INWK to NA%
30022               *
30023               * ******************************************************************************
30024               
30025               TRNME:
30026 C78C 020E  20        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     C78E 0700     
30027                                                                          ; characters, and is terminated by a carriage return,
30028                                                                          ; so set up a counter in X to copy 8 characters
30029               
30030               GTL1:
30031 C790 D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte of INWK to the X-th byte of NA%
     C792 0053     
30032 C794 DB8D  38        movb ra,@NA.(rx)                ; STA NA%,X
     C796 21C8     
30033               
30034 C798 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30035               
30036 C79A 15FA  14        jgt  GTL1                       ; BPL GTL1          ; Loop back until we have copied all 8 bytes
30037               
30038                                                                          ; Fall through into TR1 to copy the name back from NA%
30039                                                                          ; to INWK. This isn't necessary as the name is already
30040                                                                          ; there, but it does save one byte, as we don't need an
30041                                                                          ; RTS here
30042               
30043               * ******************************************************************************
30044               *
30045               * Name: TR1
30046               * Type: Subroutine
30047               * Category: Save and load
30048               * Summary: Copy the last saved commander's name from NA% to INWK
30049               *
30050               * ******************************************************************************
30051               
30052               TR1:
30053 C79C 020E  20        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     C79E 0700     
30054                                                                          ; characters, and is terminated by a carriage return,
30055                                                                          ; so set up a counter in X to copy 8 characters
30056               
30057               GTL2:
30058 C7A0 D36E  34        movb @NA.(rx),ra                ; LDA NA%,X         ; Copy the X-th byte of NA% to the X-th byte of INWK
     C7A2 21C8     
30059 C7A4 DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X
     C7A6 0053     
30060               
30061 C7A8 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30062               
30063 C7AA 15FA  14        jgt  GTL2                       ; BPL GTL2          ; Loop back until we have copied all 8 bytes
30064               
30065 C7AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C7AE FE2A     
30066               
30067               * ******************************************************************************
30068               *
30069               * Name: GTNME
30070               * Type: Subroutine
30071               * Category: Save and load
30072               * Summary: Fetch the name of a commander file to save or load
30073               *
30074               * ------------------------------------------------------------------------------
30075               *
30076               * Get the commander's name for loading or saving a commander file. The name is
30077               * stored in the INWK workspace and is terminated by a return character (13).
30078               *
30079               * If ESCAPE is pressed or a blank name is entered, then the name stored is set
30080               * to the name from the last saved commander block.
30081               *
30082               * ------------------------------------------------------------------------------
30083               *
30084               * Returns:
30085               *
30086               * INWK                The commander name entered, terminated by a return
30087               * character (13)
30088               *
30089               * ******************************************************************************
30090               
30091               GTNME:
30092 C7B0 020D  20        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     C7B2 0100     
30093 C7B4 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     C7B6 4B2A     
30094 C7B8 06A0  32        bl   @jsr                       ;
     C7BA FE1E     
30095               
30096 C7BC 020D  20        li   ra,>7b*256                 ; LDA #123          ; Print recursive token 123 ("{crlf}COMMANDER'S NAME? ")
     C7BE 7B00     
30097 C7C0 0200  20        li   rtmp,TT27                  ; JSR TT27
     C7C2 A6E8     
30098 C7C4 06A0  32        bl   @jsr                       ;
     C7C6 FE1E     
30099               
30100 C7C8 0200  20        li   rtmp,DEL8                  ; JSR DEL8          ; Wait for 8/50 of a second (0.16 seconds)
     C7CA 4BFC     
30101 C7CC 06A0  32        bl   @jsr                       ;
     C7CE FE1E     
30102               
30103 C7D0 020D  20        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     C7D2 8100     
30104 C7D4 D80D  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     C7D6 FE4E     
30105                                                                          ; which comes from the keyboard)
30106               
30107 C7D8 020D  20        li   ra,>0f*256                 ; LDA #15           ; Call OSBYTE with A = 15 (flush all buffers)
     C7DA 0F00     
30108 C7DC D38D  18        movb ra,rx                      ; TAX
30109 C7DE 0200  20        li   rtmp,OSBYTE                ; JSR OSBYTE
     C7E0 FE18     
30110 C7E2 06A0  32        bl   @jsr                       ;
     C7E4 FE1E     
30111               
30112 C7E6 020E  20        li   rx,((RLINE)%256)*256       ; LDX #LO(RLINE)    ; Set (Y X) to point to the RLINE parameter block
     C7E8 FC00     
30113 C7EA 020F  20        li   ry,((RLINE)/256)*256       ; LDY #HI(RLINE)    ; configuration block below
     C7EC C900     
30114               
30115 C7EE 020D  20        li   ra,>00*256                 ; LDA #0            ; Call OSWORD with A = 0 to read a line from the current
     C7F0 0000     
30116 C7F2 0200  20        li   rtmp,OSWORD                ; JSR OSWORD        ; input stream (i.e. the keyboard)
     C7F4 FE1A     
30117 C7F6 06A0  32        bl   @jsr                       ;
     C7F8 FE1E     
30118               
30119               * LDA #%00000001         \ These instructions are commented out in the original
30120               * STA VIA+&4E            \ source, but they would set 6522 System VIA interrupt
30121                                                                          ; enable register IER (SHEILA &4E) bit 1 (i.e. disable
30122                                                                          ; the CA2 interrupt, which comes from the keyboard)
30123               
30124 C7FA 18D0  14        joc  TR1                        ; BCS TR1           ; The C flag will be set if we pressed ESCAPE when
30125                                                                          ; entering the name, in which case jump to TR1 to copy
30126                                                                          ; the last saved commander's name from NA% to INWK
30127                                                                          ; and return from the subroutine there
30128               
30129 C7FC D34F  18        movb ry,ra                      ; TYA               ; The OSWORD call returns the length of the commander's
30130                                                                          ; name in Y, so transfer this to A
30131               
30132 C7FE 13CE  14        jeq  TR1                        ; BEQ TR1           ; If A = 0, no name was entered, so jump to TR1 to copy
30133                                                                          ; the last saved commander's name from NA% to INWK
30134                                                                          ; and return from the subroutine there
30135               
30136 C800 0460  28        b    @TT67                      ; JMP TT67          ; We have a name, so jump to TT67 to print a newline
     C802 4EE6     
30137                                                                          ; and return from the subroutine using a tail call
30138               
30139               * ******************************************************************************
30140               *
30141               * Name: RLINE
30142               * Type: Variable
30143               * Category: Text
30144               * Summary: The OSWORD configuration block used to fetch a line of text from
30145               * the keyboard
30146               *
30147               * ******************************************************************************
30148               
30149               RLINE:
30150 C804 0053            data INWK                                           ; The address to store the input, so the commander's
30151                                                                          ; name will be stored in INWK as it is typed
30152               
30153 C806 07              byte >07                                            ; Maximum line length = 7, as that's the maximum size
30154                                                                          ; for a commander's name
30155               
30156 C807   21            byte '!'                                            ; Allow ASCII characters from "!" through to "z" in
30157 C808 7A              byte 'z'                                            ; the name
30158               
30159               * ******************************************************************************
30160               *
30161               * Name: ZERO
30162               * Type: Subroutine
30163               * Category: Utility routines
30164               * Summary: Zero-fill pages &9, &A, &B, &C and &D
30165               *
30166               * ------------------------------------------------------------------------------
30167               *
30168               * This resets the following workspaces to zero:
30169               *
30170               * * The ship data blocks ascending from K% at &0900
30171               *
30172               * * The ship line heap descending from WP at &0D40
30173               *
30174               * * WP workspace variables from FRIN to de, which include the ship slots for
30175               * the local bubble of universe, and various flight and ship status variables
30176               * (only a portion of the LSX/LSO sun line heap is cleared)
30177               *
30178               * ******************************************************************************
30179               
30180               ZERO:
30181 C80A 020E  20        li   rx,>0d*256                 ; LDX #&D           ; Point X to page &D
     C80C 0D00     
30182               
30183               ZEL:
30184 C80E 0200  20        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X
     C810 C81E     
30185 C812 06A0  32        bl   @jsr                       ;
     C814 FE1E     
30186               
30187 C816 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to point to the next page
30188               
30189 C818 028E  22        ci   rx,>09*256                 ; CPX #9            ; If X is > 9 (i.e. is &A, &B or &C), then loop back
     C81A 0900     
30190 C81C 16F8  14        jne  ZEL                        ; BNE ZEL           ; up to clear the next page
30191               
30192                                                                          ; Then fall through into ZES1 with X set to 9, so we
30193                                                                          ; clear page &9 too
30194               
30195               * ******************************************************************************
30196               *
30197               * Name: ZES1
30198               * Type: Subroutine
30199               * Category: Utility routines
30200               * Summary: Zero-fill the page whose number is in X
30201               *
30202               * ------------------------------------------------------------------------------
30203               *
30204               * Arguments:
30205               *
30206               * X                   The page we want to zero-fill
30207               *
30208               * ******************************************************************************
30209               
30210               ZES1:
30211 C81E 020F  20        li   ry,>00*256                 ; LDY #0            ; If we set Y = SC = 0 and fall through into ZES2
     C820 0000     
30212 C822 D80F  30        movb ry,@SC                     ; STY SC            ; below, then we will zero-fill 255 bytes starting from
     C824 0007     
30213                                                                          ; SC - in other words, we will zero-fill the whole of
30214                                                                          ; page X
30215               
30216               * ******************************************************************************
30217               *
30218               * Name: ZES2
30219               * Type: Subroutine
30220               * Category: Utility routines
30221               * Summary: Zero-fill a specific page
30222               *
30223               * ------------------------------------------------------------------------------
30224               *
30225               * Zero-fill from address (X SC) + Y to (X SC) + &FF.
30226               *
30227               * ------------------------------------------------------------------------------
30228               *
30229               * Arguments:
30230               *
30231               * X                   The high byte (i.e. the page) of the starting point of
30232               * the zero-fill
30233               *
30234               * Y                   The offset from (X SC) where we start zeroing, counting
30235               * up to &FF
30236               *
30237               * SC                  The low byte (i.e. the offset into the page) of the
30238               * starting point of the zero-fill
30239               *
30240               * ------------------------------------------------------------------------------
30241               *
30242               * Returns:
30243               *
30244               * Z flag              Z flag is set
30245               *
30246               * ******************************************************************************
30247               
30248               ZES2:
30249 C826 020D  20        li   ra,>00*256                 ; LDA #0            ; Load A with the byte we want to fill the memory block
     C828 0000     
30250                                                                          ; with - i.e. zero
30251               
30252 C82A D80E  30        movb rx,@SC+1                   ; STX SC+1          ; We want to zero-fill page X, so store this in the
     C82C 0008     
30253                                                                          ; high byte of SC, so the 16-bit address in SC and
30254                                                                          ; SC+1 is now pointing to the SC-th byte of page X
30255               
30256               ZEL1:
30257                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Zero the Y-th byte of the block pointed to by SC,
     **** ****     > ST_IND_Y_IDX
0001 C82E D820  50        movb @SC,@rtmplb
     C830 0007     
     C832 206D     
0002 C834 D020  30        movb @SC+1,rtmp
     C836 0008     
0003 C838 A00F  18        a    ry,rtmp
0004 C83A D40D  30        movb RA,*rtmp
                   < elite.a99
30258                                                                          ; so that's effectively the Y-th byte before SC
30259               
30260 C83C B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter
30261               
30262 C83E 16F7  14        jne  ZEL1                       ; BNE ZEL1          ; Loop back to zero the next byte
30263               
30264 C840 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C842 FE2A     
30265               
30266               * ******************************************************************************
30267               *
30268               * Name: SVE
30269               * Type: Subroutine
30270               * Category: Save and load
30271               * Summary: Save the commander file
30272               * Deep dive: Commander save files
30273               * The competition code
30274               *
30275               * ******************************************************************************
30276               
30277               SVE:
30278 C844 0200  20        li   rtmp,GTNME                 ; JSR GTNME         ; Clear the screen and ask for the commander filename
     C846 C7B0     
30279 C848 06A0  32        bl   @jsr                       ;
     C84A FE1E     
30280                                                                          ; to save, storing the name at INWK
30281               
30282 C84C 0200  20        li   rtmp,TRNME                 ; JSR TRNME         ; Transfer the commander filename from INWK to NA%
     C84E C78C     
30283 C850 06A0  32        bl   @jsr                       ;
     C852 FE1E     
30284               
30285 C854 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     C856 C80A     
30286 C858 06A0  32        bl   @jsr                       ;
     C85A FE1E     
30287                                                                          ; the ship data blocks, the ship line heap, the ship
30288                                                                          ; slots for the local bubble of universe, and various
30289                                                                          ; flight and ship status variables
30290               
30291                      .lsr @SVC                       ; LSR SVC           ; Halve the save count value in SVC
     **** ****     > LSR
0001 C85C D020  30        movb @SVC,rtmp
     C85E 0349     
0002 C860 0910  18        srl  rtmp,1
0003 C862 D800  30        movb rtmp,@SVC
     C864 0349     
                   < elite.a99
30292               
30293 C866 020E  20        li   rx,(NT.)*256               ; LDX #NT%          ; We now want to copy the current commander data block
     C868 4B00     
30294                                                                          ; from location TP to the last saved commander block at
30295                                                                          ; NA%+8, so set a counter in X to copy the NT% bytes in
30296                                                                          ; the commander data block
30297                                                                          ;
30298                                                                          ; We also want to copy the data block to another
30299                                                                          ; location &0B00, which is normally used for the ship
30300                                                                          ; lines heap
30301               
30302               SVL1:
30303 C86A D36E  34        movb @TP(rx),ra                 ; LDA TP,X          ; Copy the X-th byte of TP to the X-th byte of &0B00
     C86C 0300     
30304 C86E DB8D  38        movb ra,@>0B00(rx)              ; STA &0B00,X       ; and NA%+8
     C870 0B00     
30305 C872 DB8D  38        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     C874 21D0     
30306               
30307 C876 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30308               
30309 C878 15F8  14        jgt  SVL1                       ; BPL SVL1          ; Loop back until we have copied all the bytes in the
30310                                                                          ; commander data block
30311               
30312 C87A 0200  20        li   rtmp,CHECK                 ; JSR CHECK         ; Call CHECK to calculate the checksum for the last
     C87C C76E     
30313 C87E 06A0  32        bl   @jsr                       ;
     C880 FE1E     
30314                                                                          ; saved commander and return it in A
30315               
30316 C882 D80D  38        movb ra,@CHK                    ; STA CHK           ; Store the checksum in CHK, which is at the end of the
     C884 221E     
30317                                                                          ; last saved commander block
30318               
30319                      .pha                            ; PHA               ; Store the checksum on the stack
     **** ****     > PHA
0001 C886 D68D  30        movb ra,*rsp
0002 C888 060A  14        dec  rsp
                   < elite.a99
30320               
30321 C88A 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set K = checksum with bit 7 set
     C88C 8000     
30322 C88E D80D  30        movb ra,@K                      ; STA K
     C890 003D     
30323               
30324                      .eor @COK                       ; EOR COK           ; Set K+2 = K EOR COK (the competition flags)
     **** ****     > EOR
0001 C892 D020  30        movb @COK,rtmp
     C894 030E     
0002 C896 2B40  18        xor  rtmp,ra
                   < elite.a99
30325 C898 D80D  30        movb ra,@K+2                    ; STA K+2
     C89A 003F     
30326               
30327                      .eor @CASH+2                    ; EOR CASH+2        ; Set K+1 = K+2 EOR CASH+2 (the third cash byte)
     **** ****     > EOR
0001 C89C D020  30        movb @CASH+2,rtmp
     C89E 030B     
0002 C8A0 2B40  18        xor  rtmp,ra
                   < elite.a99
30328 C8A2 D80D  30        movb ra,@K+1                    ; STA K+1
     C8A4 003E     
30329               
30330                      .eoi (>5a*256)                  ; EOR #&5A          ; Set K+3 = K+1 EOR &5A EOR TALLY+1 (the high byte of
     **** ****     > EOI
0001 C8A6 0200  20        li   rtmp,(>5A*256)
     C8A8 5A00     
0002 C8AA 2B40  18        xor  rtmp,ra
                   < elite.a99
30331                      .eor @TALLY+1                   ; EOR TALLY+1       ; the kill tally)
     **** ****     > EOR
0001 C8AC D020  30        movb @TALLY+1,rtmp
     C8AE 0348     
0002 C8B0 2B40  18        xor  rtmp,ra
                   < elite.a99
30332 C8B2 D80D  30        movb ra,@K+3                    ; STA K+3
     C8B4 0040     
30333               
30334 C8B6 0200  20        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the competition number stored in K to K+3. The
     C8B8 2FCC     
30335 C8BA 06A0  32        bl   @jsr                       ;
     C8BC FE1E     
30336                                                                          ; value of U might affect how this is printed, and as
30337                                                                          ; it's a temporary variable in zero page that isn't
30338                                                                          ; reset by ZERO, it might have any value, but as the
30339                                                                          ; competition code is a 10-digit number, this just means
30340                                                                          ; it may or may not have an extra space of padding
30341               
30342 C8BE 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Call TT67 twice to print two newlines
     C8C0 4EE6     
30343 C8C2 06A0  32        bl   @jsr                       ;
     C8C4 FE1E     
30344 C8C6 0200  20        li   rtmp,TT67                  ; JSR TT67
     C8C8 4EE6     
30345 C8CA 06A0  32        bl   @jsr                       ;
     C8CC FE1E     
30346               
30347                      .pla                            ; PLA               ; Restore the checksum from the stack
     **** ****     > PLA
0001 C8CE 058A  14        inc  rsp
0002 C8D0 D35A  26        movb *rsp,ra
                   < elite.a99
30348               
30349 C8D2 D80D  30        movb ra,@>0B00+NT.              ; STA &0B00+NT%     ; Store the checksum in the last byte of the save file
     C8D4 0B4B     
30350                                                                          ; at &0B00 (the equivalent of CHK in the last saved
30351                                                                          ; block)
30352               
30353                      .eoi (>a9*256)                  ; EOR #&A9          ; Store the checksum EOR &A9 in CHK2, the penultimate
     **** ****     > EOI
0001 C8D6 0200  20        li   rtmp,(>A9*256)
     C8D8 A900     
0002 C8DA 2B40  18        xor  rtmp,ra
                   < elite.a99
30354 C8DC D80D  38        movb ra,@CHK2                   ; STA CHK2          ; byte of the last saved commander block
     C8DE 221D     
30355               
30356 C8E0 D80D  30        movb ra,@>0AFF+NT.              ; STA &0AFF+NT%     ; Store the checksum EOR &A9 in the penultimate byte of
     C8E2 0B4A     
30357                                                                          ; the save file at &0B00 (the equivalent of CHK2 in the
30358                                                                          ; last saved block)
30359               
30360 C8E4 020F  20        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     C8E6 0B00     
30361 C8E8 D80F  30        movb ry,@>0C0B                  ; STY &0C0B         ;
     C8EA 0C0B     
30362 C8EC B3C7  18        ab   rone,ry                    ; INY               ; Start address for save = &00000B00 in &0C0A to &0C0D
30363 C8EE D80F  30        movb ry,@>0C0F                  ; STY &0C0F         ;
     C8F0 0C0F     
30364                                                                          ; End address for save = &00000C00 in &0C0E to &0C11
30365                                                                          ;
30366                                                                          ; Y is left containing &C which we use below
30367               
30368 C8F2 020D  20        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     C8F4 8100     
30369 C8F6 D80D  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     C8F8 FE4E     
30370                                                                          ; which comes from the keyboard)
30371               
30372 C8FA B347  18        ab   rone,ra                    ; INC SVN           ; Increment SVN to indicate we are about to start saving
30373               
30374 C8FC 020D  20        li   ra,>00*256                 ; LDA #0            ; Call QUS1 with A = 0, Y = &C to save the commander
     C8FE 0000     
30375 C900 0200  20        li   rtmp,QUS1                  ; JSR QUS1          ; file with the filename we copied to INWK at the start
     C902 C914     
30376 C904 06A0  32        bl   @jsr                       ;
     C906 FE1E     
30377                                                                          ; of this routine
30378               
30379 C908 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0 for storing in SVN below
     C90A 0000     
30380               
30381               * STX VIA+&4E            \ This instruction is commented out in the original
30382                                                                          ; source. It would affect the 6522 System VIA interrupt
30383                                                                          ; enable register IER (SHEILA &4E) if any of bits 0-6
30384                                                                          ; of X were set, but they aren't, so this instruction
30385                                                                          ; would have no effect anyway
30386               
30387               * DEX                    \ This instruction is commented out in the original
30388                                                                          ; source. It would end up setting SVN to &FF, which
30389                                                                          ; affects the logic in the IRQ1 handler
30390               
30391 C90C D80E  38        movb rx,@SVN                    ; STX SVN           ; Set SVN to 0 to indicate we are done saving
     C90E F2BD     
30392               
30393 C910 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show Status Mode)
     C912 C65C     
30394               
30395               * ******************************************************************************
30396               *
30397               * Name: QUS1
30398               * Type: Subroutine
30399               * Category: Save and load
30400               * Summary: Save or load the commander file
30401               * Deep dive: Commander save files
30402               *
30403               * ------------------------------------------------------------------------------
30404               *
30405               * The filename should be stored at INWK, terminated with a carriage return (13).
30406               * The routine should be called with Y set to &C.
30407               *
30408               * ------------------------------------------------------------------------------
30409               *
30410               * Arguments:
30411               *
30412               * A                   File operation to be performed. Can be one of the
30413               * following:
30414               *
30415               * * 0 (save file)
30416               *
30417               * * &FF (load file)
30418               *
30419               * Y                   Points to the page number containing the OSFILE block,
30420               * which must be &C because that's where the pointer to the
30421               * filename in INWK is stored below (by the STX &0C00
30422               * instruction)
30423               *
30424               * ******************************************************************************
30425               
30426               QUS1:
30427 C914 020E  20        li   rx,(INWK)*256              ; LDX #INWK         ; Store a pointer to INWK at the start of the block at
     C916 5300     
30428 C918 D80E  30        movb rx,@>0C00                  ; STX &0C00         ; &0C00, storing #INWK in the low byte because INWK is
     C91A 0C00     
30429                                                                          ; in zero page
30430               
30431 C91C 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X to 0 so (Y X) = &0C00
     C91E 0000     
30432               
30433 C920 0460  28        b    @OSFILE                    ; JMP OSFILE        ; Jump to OSFILE to do the file operation specified in
     C922 FE1C     
30434                                                                          ; &0C00 (i.e. save or load a file depending on the value
30435                                                                          ; of A), returning from the subroutine using a tail call
30436               
30437               * ******************************************************************************
30438               *
30439               * Name: LOD
30440               * Type: Subroutine
30441               * Category: Save and load
30442               * Summary: Load a commander file
30443               *
30444               * ------------------------------------------------------------------------------
30445               *
30446               * The filename should be stored at INWK, terminated with a carriage return (13).
30447               *
30448               * ******************************************************************************
30449               
30450               LOD:
30451 C924 020E  20        li   rx,>02*256                 ; LDX #2            ; Enable the ESCAPE key and clear memory if the BREAK
     C926 0200     
30452 C928 0200  20        li   rtmp,FX200                 ; JSR FX200         ; key is pressed (*FX 200,2)
     C92A C96A     
30453 C92C 06A0  32        bl   @jsr                       ;
     C92E FE1E     
30454               
30455 C930 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     C932 C80A     
30456 C934 06A0  32        bl   @jsr                       ;
     C936 FE1E     
30457                                                                          ; the ship data blocks, the ship line heap, the ship
30458                                                                          ; slots for the local bubble of universe, and various
30459                                                                          ; flight and ship status variables
30460               
30461 C938 020F  20        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     C93A 0B00     
30462 C93C D80F  30        movb ry,@>0C03                  ; STY &0C03         ;
     C93E 0C03     
30463 C940 B347  18        ab   rone,ra                    ; INC &0C0B         ; Load address = &00000B00 in &0C02 to &0C05
30464                                                                          ;
30465                                                                          ; Length of file = &00000100 in &0C0A to &0C0D
30466               
30467 C942 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to &C, which we use next
30468               
30469 C944 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Call QUS1 with A = &FF, Y = &C to load the commander
     C946 FF00     
30470 C948 0200  20        li   rtmp,QUS1                  ; JSR QUS1          ; file to address &0B00
     C94A C914     
30471 C94C 06A0  32        bl   @jsr                       ;
     C94E FE1E     
30472               
30473 C950 D360  30        movb @>0B00,ra                  ; LDA &0B00         ; If the first byte of the loaded file has bit 7 set,
     C952 0B00     
30474 C954 1112  14        jlt  SPS1+1                     ; BMI SPS1+1        ; jump to SPS+1, which is the second byte of an LDA #0
30475                                                                          ; instruction, i.e. a BRK instruction, which will force
30476                                                                          ; an interrupt to call the address in BRKV, which is set
30477                                                                          ; to BR1... so this instruction restarts the game from
30478                                                                          ; the title screen. Valid commander files for the
30479                                                                          ; cassette version of Elite only have 0 for the first
30480                                                                          ; byte, as there are no missions in this version, so
30481                                                                          ; having bit 7 set is invalid anyway
30482               
30483 C956 020E  20        li   rx,(NT.)*256               ; LDX #NT%          ; We have successfully loaded the commander file at
     C958 4B00     
30484                                                                          ; &0B00, so now we want to copy it to the last saved
30485                                                                          ; commander data block at NA%+8, so we set up a counter
30486                                                                          ; in X to copy NT% bytes
30487               
30488               LOL1:
30489 C95A D36E  34        movb @>0B00(rx),ra              ; LDA &0B00,X       ; Copy the X-th byte of &0B00 to the X-th byte of NA%+8
     C95C 0B00     
30490 C95E DB8D  38        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     C960 21D0     
30491               
30492 C962 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30493               
30494 C964 15FA  14        jgt  LOL1                       ; BPL LOL1          ; Loop back until we have copied all NT% bytes
30495               
30496 C966 020E  20        li   rx,>03*256                 ; LDX #3            ; Fall through into FX200 to disable the ESCAPE key and
     C968 0300     
30497                                                                          ; clear memory if the BREAK key is pressed (*FX 200,3)
30498                                                                          ; and return from the subroutine there
30499               
30500               * ******************************************************************************
30501               *
30502               * Name: FX200
30503               * Type: Subroutine
30504               * Category: Utility routines
30505               * Summary: Set the behaviour of the ESCAPE and BREAK keys
30506               *
30507               * ------------------------------------------------------------------------------
30508               *
30509               * This is the equivalent of a *FX 200 command, which controls the behaviour of
30510               * the ESCAPE and BREAK keys.
30511               *
30512               * ------------------------------------------------------------------------------
30513               *
30514               * Arguments:
30515               *
30516               * X                   Controls the behaviour as follows:
30517               *
30518               * * 0 = Enable ESCAPE key
30519               * Normal BREAK key action
30520               *
30521               * * 1 = Disable ESCAPE key
30522               * Normal BREAK key action
30523               *
30524               * * 2 = Enable ESCAPE key
30525               * Clear memory if the BREAK key is pressed
30526               *
30527               * * 3 = Disable ESCAPE key
30528               * Clear memory if the BREAK key is pressed
30529               *
30530               * ******************************************************************************
30531               
30532               FX200:
30533 C96A 020F  20        li   ry,>00*256                 ; LDY #0            ; Call OSBYTE 200 with Y = 0, so the new value is set to
     C96C 0000     
30534 C96E 020D  20        li   ra,>c8*256                 ; LDA #200          ; X, and return from the subroutine using a tail call
     C970 C800     
30535 C972 0460  28        b    @OSBYTE                    ; JMP OSBYTE
     C974 FE18     
30536               
30537 C976 0460  28        b    @rts                       ; RTS               ; This instruction has no effect, as we already returned
     C978 FE2A     
30538                                                                          ; from the subroutine
30539               
30540               * ******************************************************************************
30541               *
30542               * Name: SPS1
30543               * Type: Subroutine
30544               * Category: Maths (Geometry)
30545               * Summary: Calculate the vector to the planet and store it in XX15
30546               *
30547               * ------------------------------------------------------------------------------
30548               *
30549               * Other entry points:
30550               *
30551               * SPS1+1              A BRK instruction
30552               *
30553               * ******************************************************************************
30554               
30555               SPS1:
30556 C97A 020E  20        li   rx,>00*256                 ; LDX #0            ; Copy the two high bytes of the planet's x-coordinate
     C97C 0000     
30557 C97E 0200  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(2 1 0), separating out the sign bit into K3+2
     C980 AEE8     
30558 C982 06A0  32        bl   @jsr                       ;
     C984 FE1E     
30559               
30560 C986 020E  20        li   rx,>03*256                 ; LDX #3            ; Copy the two high bytes of the planet's y-coordinate
     C988 0300     
30561 C98A 0200  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(5 4 3), separating out the sign bit into K3+5
     C98C AEE8     
30562 C98E 06A0  32        bl   @jsr                       ;
     C990 FE1E     
30563               
30564 C992 020E  20        li   rx,>06*256                 ; LDX #6            ; Copy the two high bytes of the planet's z-coordinate
     C994 0600     
30565 C996 0200  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(8 7 6), separating out the sign bit into K3+8
     C998 AEE8     
30566 C99A 06A0  32        bl   @jsr                       ;
     C99C FE1E     
30567               
30568                                                                          ; Fall through into TAS2 to build XX15 from K3
30569               
30570               * ******************************************************************************
30571               *
30572               * Name: TAS2
30573               * Type: Subroutine
30574               * Category: Maths (Geometry)
30575               * Summary: Normalise the three-coordinate vector in K3
30576               *
30577               * ------------------------------------------------------------------------------
30578               *
30579               * Normalise the vector in K3, which has 16-bit values and separate sign bits,
30580               * and store the normalised version in XX15 as a signed 8-bit vector.
30581               *
30582               * A normalised vector (also known as a unit vector) has length 1, so this
30583               * routine takes an existing vector in K3 and scales it so the length of the
30584               * new vector is 1. This is used in two places: when drawing the compass, and
30585               * when applying AI tactics to ships.
30586               *
30587               * We do this in two stages. This stage shifts the 16-bit vector coordinates in
30588               * K3 to the left as far as they will go without losing any bits off the end, so
30589               * we can then take the high bytes and use them as the most accurate 8-bit vector
30590               * to normalise. Then the next stage (in routine NORM) does the normalisation.
30591               *
30592               * ------------------------------------------------------------------------------
30593               *
30594               * Arguments:
30595               *
30596               * K3(2 1 0)           The 16-bit x-coordinate as (x_sign x_hi x_lo), where
30597               * x_sign is just bit 7
30598               *
30599               * K3(5 4 3)           The 16-bit y-coordinate as (y_sign y_hi y_lo), where
30600               * y_sign is just bit 7
30601               *
30602               * K3(8 7 6)           The 16-bit z-coordinate as (z_sign z_hi z_lo), where
30603               * z_sign is just bit 7
30604               *
30605               * ------------------------------------------------------------------------------
30606               *
30607               * Returns:
30608               *
30609               * XX15                The normalised vector, with:
30610               *
30611               * * The x-coordinate in XX15
30612               *
30613               * * The y-coordinate in XX15+1
30614               *
30615               * * The z-coordinate in XX15+2
30616               *
30617               * ------------------------------------------------------------------------------
30618               *
30619               * Other entry points:
30620               *
30621               * TA2                 Calculate the length of the vector in XX15 (ignoring the
30622               * low coordinates), returning it in Q
30623               *
30624               * ******************************************************************************
30625               
30626               TAS2:
30627 C99E D360  30        movb @K3,ra                     ; LDA K3            ; OR the three low bytes and 1 to get a byte that has
     C9A0 00D2     
30628 C9A2 F360  30        socb @K3+3,ra                   ; ORA K3+3          ; a 1 wherever any of the three low bytes has a 1
     C9A4 00D5     
30629 C9A6 F360  30        socb @K3+6,ra                   ; ORA K3+6          ; (as well as always having bit 0 set), and store in
     C9A8 00D8     
30630 C9AA 026D  22        ori  ra,>01*256                 ; ORA #1            ; K3+9
     C9AC 0100     
30631 C9AE D80D  30        movb ra,@K3+9                   ; STA K3+9
     C9B0 00DB     
30632               
30633 C9B2 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; OR the three high bytes to get a byte in A that has a
     C9B4 00D3     
30634 C9B6 F360  30        socb @K3+4,ra                   ; ORA K3+4          ; 1 wherever any of the three high bytes has a 1
     C9B8 00D6     
30635 C9BA F360  30        socb @K3+7,ra                   ; ORA K3+7
     C9BC 00D9     
30636               
30637                                                                          ; (A K3+9) now has a 1 wherever any of the 16-bit
30638                                                                          ; values in K3 has a 1
30639               TAL2:
30640                      .asl @K3+9                      ; ASL K3+9          ; Shift (A K3+9) to the left, so bit 7 of the high byte
     **** ****     > ASL
0001 C9BE D020  30        movb @K3+9,rtmp
     C9C0 00DB     
0002 C9C2 0240  22        andi rtmp,>ff00
     C9C4 FF00     
0003 C9C6 0A10  18        sla  rtmp,1
0004 C9C8 D800  30        movb rtmp,@K3+9
     C9CA 00DB     
                   < elite.a99
30641 C9CC 06A0  32        bl   @rola                      ; ROL A             ; goes into the C flag
     C9CE FE34     
30642               
30643 C9D0 1822  14        joc  TA2                        ; BCS TA2           ; If the left shift pushed a 1 out of the end, then we
30644                                                                          ; know that at least one of the coordinates has a 1 in
30645                                                                          ; this position, so jump to TA2 as we can't shift the
30646                                                                          ; values in K3 any further to the left
30647               
30648                      .asl @K3                        ; ASL K3            ; Shift K3(1 0), the x-coordinate, to the left
     **** ****     > ASL
0001 C9D2 D020  30        movb @K3,rtmp
     C9D4 00D2     
0002 C9D6 0240  22        andi rtmp,>ff00
     C9D8 FF00     
0003 C9DA 0A10  18        sla  rtmp,1
0004 C9DC D800  30        movb rtmp,@K3
     C9DE 00D2     
                   < elite.a99
30649 C9E0 0204  20        li   rarg1,K3+1                 ; ROL K3+1
     C9E2 00D3     
30650 C9E4 06A0  32        bl   @rol                       ;
     C9E6 FE44     
30651               
30652                      .asl @K3+3                      ; ASL K3+3          ; Shift K3(4 3), the y-coordinate, to the left
     **** ****     > ASL
0001 C9E8 D020  30        movb @K3+3,rtmp
     C9EA 00D5     
0002 C9EC 0240  22        andi rtmp,>ff00
     C9EE FF00     
0003 C9F0 0A10  18        sla  rtmp,1
0004 C9F2 D800  30        movb rtmp,@K3+3
     C9F4 00D5     
                   < elite.a99
30653 C9F6 0204  20        li   rarg1,K3+4                 ; ROL K3+4
     C9F8 00D6     
30654 C9FA 06A0  32        bl   @rol                       ;
     C9FC FE44     
30655               
30656                      .asl @K3+6                      ; ASL K3+6          ; Shift K3(6 7), the z-coordinate, to the left
     **** ****     > ASL
0001 C9FE D020  30        movb @K3+6,rtmp
     CA00 00D8     
0002 CA02 0240  22        andi rtmp,>ff00
     CA04 FF00     
0003 CA06 0A10  18        sla  rtmp,1
0004 CA08 D800  30        movb rtmp,@K3+6
     CA0A 00D8     
                   < elite.a99
30657 CA0C 0204  20        li   rarg1,K3+7                 ; ROL K3+7
     CA0E 00D9     
30658 CA10 06A0  32        bl   @rol                       ;
     CA12 FE44     
30659               
30660 CA14 17D4  14        jnc  TAL2                       ; BCC TAL2          ; Jump back to TAL2 to do another shift left (this BCC
30661                                                                          ; is effectively a JMP as we know bit 7 of K3+7 is not a
30662                                                                          ; 1, as otherwise bit 7 of A would have been a 1 and we
30663                                                                          ; would have taken the BCS above)
30664               
30665               TA2:
30666 CA16 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Fetch the high byte of the x-coordinate from our left-
     CA18 00D3     
30667 CA1A 091D  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30668 CA1C F360  30        socb @K3+2,ra                   ; ORA K3+2          ; sign bit in there from the x_sign part of K3, and
     CA1E 00D4     
30669 CA20 D80D  30        movb ra,@XX15                   ; STA XX15          ; store the resulting signed 8-bit x-coordinate in XX15
     CA22 0031     
30670               
30671 CA24 D360  30        movb @K3+4,ra                   ; LDA K3+4          ; Fetch the high byte of the y-coordinate from our left-
     CA26 00D6     
30672 CA28 091D  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30673 CA2A F360  30        socb @K3+5,ra                   ; ORA K3+5          ; sign bit in there from the y_sign part of K3, and
     CA2C 00D7     
30674 CA2E D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; store the resulting signed 8-bit y-coordinate in
     CA30 0032     
30675                                                                          ; XX15+1
30676               
30677 CA32 D360  30        movb @K3+7,ra                   ; LDA K3+7          ; Fetch the high byte of the z-coordinate from our left-
     CA34 00D9     
30678 CA36 091D  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
30679 CA38 F360  30        socb @K3+8,ra                   ; ORA K3+8          ; sign bit in there from the z_sign part of K3, and
     CA3A 00DA     
30680 CA3C D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; store the resulting signed 8-bit  z-coordinate in
     CA3E 0033     
30681                                                                          ; XX15+2
30682               
30683                                                                          ; Now we have a signed 8-bit version of the vector K3 in
30684                                                                          ; XX15, so fall through into NORM to normalise it
30685               
30686               * ******************************************************************************
30687               *
30688               * Name: NORM
30689               * Type: Subroutine
30690               * Category: Maths (Geometry)
30691               * Summary: Normalise the three-coordinate vector in XX15
30692               * Deep dive: Tidying orthonormal vectors
30693               * Orientation vectors
30694               *
30695               * ------------------------------------------------------------------------------
30696               *
30697               * We do this by dividing each of the three coordinates by the length of the
30698               * vector, which we can calculate using Pythagoras. Once normalised, 96 (&60) is
30699               * used to represent a value of 1, and 96 with bit 7 set (&E0) is used to
30700               * represent -1. This enables us to represent fractional values of less than 1
30701               * using integers.
30702               *
30703               * ------------------------------------------------------------------------------
30704               *
30705               * Arguments:
30706               *
30707               * XX15                The vector to normalise, with:
30708               *
30709               * * The x-coordinate in XX15
30710               *
30711               * * The y-coordinate in XX15+1
30712               *
30713               * * The z-coordinate in XX15+2
30714               *
30715               * ------------------------------------------------------------------------------
30716               *
30717               * Returns:
30718               *
30719               * XX15                The normalised vector
30720               *
30721               * Q                   The length of the original XX15 vector
30722               *
30723               * ------------------------------------------------------------------------------
30724               *
30725               * Other entry points:
30726               *
30727               * NO1                 Contains an RTS
30728               *
30729               * ******************************************************************************
30730               
30731               NORM:
30732 CA40 D360  30        movb @XX15,ra                   ; LDA XX15          ; Fetch the x-coordinate into A
     CA42 0031     
30733               
30734 CA44 0200  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = x^2
     CA46 42B6     
30735 CA48 06A0  32        bl   @jsr                       ;
     CA4A FE1E     
30736               
30737 CA4C D80D  30        movb ra,@R                      ; STA R             ; Set (R Q) = (A P) = x^2
     CA4E 0091     
30738 CA50 D360  30        movb @P,ra                      ; LDA P
     CA52 001B     
30739 CA54 D80D  30        movb ra,@Q                      ; STA Q
     CA56 0090     
30740               
30741 CA58 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Fetch the y-coordinate into A
     CA5A 0032     
30742               
30743 CA5C 0200  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = y^2
     CA5E 42B6     
30744 CA60 06A0  32        bl   @jsr                       ;
     CA62 FE1E     
30745               
30746 CA64 D80D  30        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = y^2
     CA66 00D1     
30747               
30748 CA68 D360  30        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2
     CA6A 001B     
30749                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 CA6C 1701  14        jnc  !
0002 CA6E B347  18        ab   rone,ra
0003               !:
0004 CA70 B360  30        ab   @Q,ra
     CA72 0090     
                   < elite.a99
30750 CA74 D80D  30        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     CA76 0090     
30751               
30752 CA78 D360  30        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     CA7A 00D1     
30753                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 CA7C 1701  14        jnc  !
0002 CA7E B347  18        ab   rone,ra
0003               !:
0004 CA80 B360  30        ab   @R,ra
     CA82 0091     
                   < elite.a99
30754 CA84 D80D  30        movb ra,@R                      ; STA R
     CA86 0091     
30755               
30756 CA88 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Fetch the z-coordinate into A
     CA8A 0033     
30757               
30758 CA8C 0200  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = z^2
     CA8E 42B6     
30759 CA90 06A0  32        bl   @jsr                       ;
     CA92 FE1E     
30760               
30761 CA94 D80D  30        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = z^2
     CA96 00D1     
30762               
30763 CA98 D360  30        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2 + z^2
     CA9A 001B     
30764                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 CA9C 1701  14        jnc  !
0002 CA9E B347  18        ab   rone,ra
0003               !:
0004 CAA0 B360  30        ab   @Q,ra
     CAA2 0090     
                   < elite.a99
30765 CAA4 D80D  30        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     CAA6 0090     
30766               
30767 CAA8 D360  30        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     CAAA 00D1     
30768                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 CAAC 1701  14        jnc  !
0002 CAAE B347  18        ab   rone,ra
0003               !:
0004 CAB0 B360  30        ab   @R,ra
     CAB2 0091     
                   < elite.a99
30769 CAB4 D80D  30        movb ra,@R                      ; STA R
     CAB6 0091     
30770               
30771 CAB8 0200  20        li   rtmp,LL5                   ; JSR LL5           ; We now have the following:
     CABA D2B6     
30772 CABC 06A0  32        bl   @jsr                       ;
     CABE FE1E     
30773                                                                          ;
30774                                                                          ; (R Q) = x^2 + y^2 + z^2
30775                                                                          ;
30776                                                                          ; so we can call LL5 to use Pythagoras to get:
30777                                                                          ;
30778                                                                          ; Q = SQRT(R Q)
30779                                                                          ; = SQRT(x^2 + y^2 + z^2)
30780                                                                          ;
30781                                                                          ; So Q now contains the length of the vector (x, y, z),
30782                                                                          ; and we can normalise the vector by dividing each of
30783                                                                          ; the coordinates by this value, which we do by calling
30784                                                                          ; routine TIS2. TIS2 returns the divided figure, using
30785                                                                          ; 96 to represent 1 and 96 with bit 7 set for -1
30786               
30787 CAC0 D360  30        movb @XX15,ra                   ; LDA XX15          ; Call TIS2 to divide the x-coordinate in XX15 by Q,
     CAC2 0031     
30788 CAC4 0200  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     CAC6 D0CA     
30789 CAC8 06A0  32        bl   @jsr                       ;
     CACA FE1E     
30790 CACC D80D  30        movb ra,@XX15                   ; STA XX15
     CACE 0031     
30791               
30792 CAD0 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Call TIS2 to divide the y-coordinate in XX15+1 by Q,
     CAD2 0032     
30793 CAD4 0200  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     CAD6 D0CA     
30794 CAD8 06A0  32        bl   @jsr                       ;
     CADA FE1E     
30795 CADC D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     CADE 0032     
30796               
30797 CAE0 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Call TIS2 to divide the z-coordinate in XX15+2 by Q,
     CAE2 0033     
30798 CAE4 0200  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     CAE6 D0CA     
30799 CAE8 06A0  32        bl   @jsr                       ;
     CAEA FE1E     
30800 CAEC D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     CAEE 0033     
30801               
30802               NO1:
30803 CAF0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CAF2 FE2A     
30804               
30805               * ******************************************************************************
30806               *
30807               * Name: RDKEY
30808               * Type: Subroutine
30809               * Category: Keyboard
30810               * Summary: Scan the keyboard for key presses
30811               *
30812               * ------------------------------------------------------------------------------
30813               *
30814               * Scan the keyboard, starting with internal key number 16 ("Q") and working
30815               * through the set of internal key numbers (see p.142 of the Advanced User Guide
30816               * for a list of internal key numbers).
30817               *
30818               * This routine is effectively the same as OSBYTE 122, though the OSBYTE call
30819               * preserves A, unlike this routine.
30820               *
30821               * ------------------------------------------------------------------------------
30822               *
30823               * Returns:
30824               *
30825               * X                   If a key is being pressed, X contains the internal key
30826               * number, otherwise it contains 0
30827               *
30828               * A                   Contains the same as X
30829               *
30830               * ******************************************************************************
30831               
30832               RDKEY:
30833 CAF4 020E  20        li   rx,>10*256                 ; LDX #16           ; Start the scan with internal key number 16 ("Q")
     CAF6 1000     
30834               
30835               Rd1:
30836 CAF8 0200  20        li   rtmp,DKS4                  ; JSR DKS4          ; Scan the keyboard to see if the key in X is currently
     CAFA CC28     
30837 CAFC 06A0  32        bl   @jsr                       ;
     CAFE FE1E     
30838                                                                          ; being pressed, returning the result in A and X
30839               
30840 CB00 1103  14        jlt  Rd2                        ; BMI Rd2           ; Jump to Rd2 if this key is being pressed (in which
30841                                                                          ; case DKS4 will have returned the key number with bit
30842                                                                          ; 7 set, which is negative)
30843               
30844 CB02 B387  18        ab   rone,rx                    ; INX               ; Increment the key number, which was unchanged by the
30845                                                                          ; above call to DKS4
30846               
30847 CB04 15F9  14        jgt  Rd1                        ; BPL Rd1           ; Loop back to test the next key, ending the loop when
30848                                                                          ; X is negative (i.e. 128)
30849               
30850 CB06 D34E  18        movb rx,ra                      ; TXA               ; If we get here, nothing is being pressed, so copy X
30851                                                                          ; into A so that X = A = 128 = %10000000
30852               
30853               Rd2:
30854                      .eoi (>80*256)                  ; EOR #%10000000    ; EOR A with #%10000000 to flip bit 7, so A now contains
     **** ****     > EOI
0001 CB08 0200  20        li   rtmp,(>80*256)
     CB0A 8000     
0002 CB0C 2B40  18        xor  rtmp,ra
                   < elite.a99
30855                                                                          ; 0 if no key has been pressed, or the internal key
30856                                                                          ; number if a key has been pressed
30857               
30858 CB0E D38D  18        movb ra,rx                      ; TAX               ; Copy A into X
30859               
30860 CB10 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CB12 FE2A     
30861               
30862               * ******************************************************************************
30863               *
30864               * Name: ECMOF
30865               * Type: Subroutine
30866               * Category: Sound
30867               * Summary: Switch off the E.C.M.
30868               *
30869               * ------------------------------------------------------------------------------
30870               *
30871               * Switch the E.C.M. off, turn off the dashboard bulb and make the sound of the
30872               * E.C.M. switching off).
30873               *
30874               * ******************************************************************************
30875               
30876               ECMOF:
30877 CB14 020D  20        li   ra,>00*256                 ; LDA #0            ; Set ECMA and ECMP to 0 to indicate that no E.C.M. is
     CB16 0000     
30878 CB18 D80D  30        movb ra,@ECMA                   ; STA ECMA          ; currently running
     CB1A 0030     
30879 CB1C D80D  30        movb ra,@ECMP                   ; STA ECMP
     CB1E 0D5B     
30880               
30881 CB20 0200  20        li   rtmp,ECBLB                 ; JSR ECBLB         ; Update the E.C.M. indicator bulb on the dashboard
     CB22 B0D4     
30882 CB24 06A0  32        bl   @jsr                       ;
     CB26 FE1E     
30883               
30884 CB28 020D  20        li   ra,>48*256                 ; LDA #72           ; Call the NOISE routine with A = 72 to make the sound
     CB2A 4800     
30885 CB2C 1641  14        jne  NOISE                      ; BNE NOISE         ; of the E.C.M. being turned off and return from the
30886                                                                          ; subroutine using a tail call (this BNE is effectively
30887                                                                          ; a JMP as A will never be zero)
30888               
30889               * ******************************************************************************
30890               *
30891               * Name: EXNO3
30892               * Type: Subroutine
30893               * Category: Sound
30894               * Summary: Make an explosion sound
30895               *
30896               * ------------------------------------------------------------------------------
30897               *
30898               * Make the sound of death in the cold, hard vacuum of space. Apparently, in
30899               * Elite space, everyone can hear you scream.
30900               *
30901               * This routine also makes the sound of a destroyed cargo canister if we don't
30902               * get scooping right, the sound of us colliding with another ship, and the sound
30903               * of us being hit with depleted shields. It is not a good sound to hear.
30904               *
30905               * ******************************************************************************
30906               
30907               EXNO3:
30908 CB2E 020D  20        li   ra,>10*256                 ; LDA #16           ; Call the NOISE routine with A = 16 to make the first
     CB30 1000     
30909 CB32 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; death sound
     CB34 CBB0     
30910 CB36 06A0  32        bl   @jsr                       ;
     CB38 FE1E     
30911               
30912 CB3A 020D  20        li   ra,>18*256                 ; LDA #24           ; Call the NOISE routine with A = 24 to make the second
     CB3C 1800     
30913 CB3E 1638  14        jne  NOISE                      ; BNE NOISE         ; death sound and return from the subroutine using a
30914                                                                          ; tail call (this BNE is effectively a JMP as A will
30915                                                                          ; never be zero)
30916               
30917               * ******************************************************************************
30918               *
30919               * Name: SFRMIS
30920               * Type: Subroutine
30921               * Category: Tactics
30922               * Summary: Add an enemy missile to our local bubble of universe
30923               *
30924               * ------------------------------------------------------------------------------
30925               *
30926               * An enemy has fired a missile, so add the missile to our universe if there is
30927               * room, and if there is, make the appropriate warnings and noises.
30928               *
30929               * ******************************************************************************
30930               
30931               SFRMIS:
30932 CB40 020E  20        li   rx,(MSL)*256               ; LDX #MSL          ; Set X to the ship type of a missile, and call SFS1-2
     CB42 0900     
30933 CB44 0200  20        li   rtmp,SFS1-2                ; JSR SFS1-2        ; to add the missile to our universe with an AI flag
     CB46 3D00     
30934 CB48 06A0  32        bl   @jsr                       ;
     CB4A FE1E     
30935                                                                          ; of %11111110 (AI enabled, hostile, no E.C.M.)
30936               
30937 CB4C 17D1  14        jnc  NO1                        ; BCC NO1           ; The C flag will be set if the call to SFS1-2 was a
30938                                                                          ; success, so if it's clear, jump to NO1 to return from
30939                                                                          ; the subroutine (as NO1 contains an RTS)
30940               
30941 CB4E 020D  20        li   ra,>78*256                 ; LDA #120          ; Print recursive token 120 ("INCOMING MISSILE") as an
     CB50 7800     
30942 CB52 0200  20        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     CB54 CE5E     
30943 CB56 06A0  32        bl   @jsr                       ;
     CB58 FE1E     
30944               
30945 CB5A 020D  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     CB5C 3000     
30946 CB5E 1628  14        jne  NOISE                      ; BNE NOISE         ; of the missile being launched and return from the
30947                                                                          ; subroutine using a tail call (this BNE is effectively
30948                                                                          ; a JMP as A will never be zero)
30949               
30950               * ******************************************************************************
30951               *
30952               * Name: EXNO2
30953               * Type: Subroutine
30954               * Category: Status
30955               * Summary: Process us making a kill
30956               * Deep dive: Combat rank
30957               *
30958               * ------------------------------------------------------------------------------
30959               *
30960               * We have killed a ship, so increase the kill tally, displaying an iconic
30961               * message of encouragement if the kill total is a multiple of 256, and then
30962               * make a nearby explosion sound.
30963               *
30964               * ******************************************************************************
30965               
30966               EXNO2:
30967 CB60 B347  18        ab   rone,ra                    ; INC TALLY         ; Increment the low byte of the kill count in TALLY
30968               
30969 CB62 1608  14        jne  EXNO-2                     ; BNE EXNO-2        ; If there is no carry, jump to the LDX #7 below (at
30970                                                                          ; EXNO-2)
30971               
30972 CB64 B347  18        ab   rone,ra                    ; INC TALLY+1       ; Increment the high byte of the kill count in TALLY
30973               
30974 CB66 020D  20        li   ra,>65*256                 ; LDA #101          ; The kill total is a multiple of 256, so it's time
     CB68 6500     
30975 CB6A 0200  20        li   rtmp,MESS                  ; JSR MESS          ; for a pat on the back, so print recursive token 101
     CB6C CE5E     
30976 CB6E 06A0  32        bl   @jsr                       ;
     CB70 FE1E     
30977                                                                          ; ("RIGHT ON COMMANDER!") as an in-flight message
30978               
30979 CB72 020E  20        li   rx,>07*256                 ; LDX #7            ; Set X = 7 and fall through into EXNO to make the
     CB74 0700     
30980                                                                          ; sound of a ship exploding
30981               
30982               * ******************************************************************************
30983               *
30984               * Name: EXNO
30985               * Type: Subroutine
30986               * Category: Sound
30987               * Summary: Make the sound of a laser strike or ship explosion
30988               *
30989               * ------------------------------------------------------------------------------
30990               *
30991               * Make the two-part explosion sound of us making a laser strike, or of another
30992               * ship exploding.
30993               *
30994               * The volume of the first explosion is affected by the distance of the ship
30995               * being hit, with more distant ships being quieter. The value in X also affects
30996               * the volume of the first explosion, with a higher X giving a quieter sound
30997               * (so X can be used to differentiate a laser strike from an explosion).
30998               *
30999               * ------------------------------------------------------------------------------
31000               *
31001               * Arguments:
31002               *
31003               * X                   The larger the value of X, the fainter the explosion.
31004               * Allowed values are:
31005               *
31006               * * 7  = explosion is louder (i.e. the ship has just
31007               * exploded)
31008               *
31009               * * 15 = explosion is quieter (i.e. this is just a laser
31010               * strike)
31011               *
31012               * ------------------------------------------------------------------------------
31013               *
31014               * Other entry points:
31015               *
31016               * EXNO-2              Set X = 7 and fall through into EXNO to make the sound
31017               * of a ship exploding
31018               *
31019               * ******************************************************************************
31020               
31021               EXNO:
31022 CB76 D80E  30        movb rx,@T                      ; STX T             ; Store the distance in T
     CB78 00D1     
31023               
31024 CB7A 020D  20        li   ra,>18*256                 ; LDA #24           ; Set A = 24 to denote the sound of us making a hit or
     CB7C 1800     
31025 CB7E 0200  20        li   rtmp,NOS1                  ; JSR NOS1          ; kill (part 1 of the explosion), and call NOS1 to set
     CB80 CBCE     
31026 CB82 06A0  32        bl   @jsr                       ;
     CB84 FE1E     
31027                                                                          ; up the sound block in XX16
31028               
31029 CB86 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Fetch z_hi, the distance of the ship being hit in
     CB88 005A     
31030 CB8A 091D  18        srl  ra,1                       ; LSR A             ; terms of the z-axis (in and out of the screen), and
31031 CB8C 091D  18        srl  ra,1                       ; LSR A             ; divide by 4. If z_hi has either bit 6 or 7 set then
31032                                                                          ; that ship is too far away to be shown on the scanner
31033                                                                          ; (as per the SCAN routine), so we know the maximum
31034                                                                          ; z_hi at this point is %00111111, and shifting z_hi
31035                                                                          ; to the right twice gives us a maximum value of
31036                                                                          ; %00001111
31037               
31038                      .and @T                         ; AND T             ; This reduces A to a maximum of X; X can be either
     **** ****     > AND
0001 CB8E D020  30        movb @T,rtmp
     CB90 00D1     
0002 CB92 0540  14        inv  rtmp
0003 CB94 5340  18        szcb rtmp,ra
                   < elite.a99
31039                                                                          ; 7 = %0111 or 15 = %1111, so AND'ing with 15 will
31040                                                                          ; not affect A, while AND'ing with 7 will clear bit
31041                                                                          ; 3, reducing the maximum value in A to 7
31042               
31043 CB96 026D  22        ori  ra,>f1*256                 ; ORA #%11110001    ; The SOUND statement's amplitude ranges from 0 (for no
     CB98 F100     
31044                                                                          ; sound) to -15 (full volume), so we can set bits 0 and
31045                                                                          ; 4-7 in A, and keep bits 1-3 from the above to get
31046                                                                          ; a value between -15 (%11110001) and -1 (%11111111),
31047                                                                          ; with lower values of z_hi and argument X leading
31048                                                                          ; to a more negative, or quieter number (so the closer
31049                                                                          ; the ship, i.e. the smaller the value of X, the louder
31050                                                                          ; the sound)
31051               
31052 CB9A D80D  30        movb ra,@XX16+2                 ; STA XX16+2        ; The amplitude byte of the sound block in XX16 is in
     CB9C 000B     
31053                                                                          ; byte #3 (where it's the low byte of the amplitude), so
31054                                                                          ; this sets the amplitude to the value in A
31055               
31056 CB9E 0200  20        li   rtmp,NO3                   ; JSR NO3           ; Make the sound from our updated sound block in XX16
     CBA0 CBB8     
31057 CBA2 06A0  32        bl   @jsr                       ;
     CBA4 FE1E     
31058               
31059 CBA6 020D  20        li   ra,>10*256                 ; LDA #16           ; Set A = 16 to denote we have made a hit or kill
     CBA8 1000     
31060                                                                          ; (part 2 of the explosion), and fall through into NOISE
31061                                                                          ; to make the sound
31062               
31063 CBAA 2C              byte >2c                                            ; Skip the next instruction by turning it into
31064                                                                          ; &2C &A9 &20, or BIT &20A9, which does nothing apart
31065                                                                          ; from affect the flags
31066               
31067               * ******************************************************************************
31068               *
31069               * Name: BEEP
31070               * Type: Subroutine
31071               * Category: Sound
31072               * Summary: Make a short, high beep
31073               *
31074               * ******************************************************************************
31075               
31076               BEEP:
31077 CBAC 020D  20        li   ra,>20*256                 ; LDA #32           ; Set A = 32 to denote a short, high beep, and fall
     CBAE 2000     
31078                                                                          ; through into the NOISE routine to make the sound
31079               
31080               * ******************************************************************************
31081               *
31082               * Name: NOISE
31083               * Type: Subroutine
31084               * Category: Sound
31085               * Summary: Make the sound whose number is in A
31086               *
31087               * ------------------------------------------------------------------------------
31088               *
31089               * Arguments:
31090               *
31091               * A                   The number of the sound to be made. See the
31092               * documentation for variable SFX for a list of sound
31093               * numbers
31094               *
31095               * ******************************************************************************
31096               
31097               NOISE:
31098 CBB0 0200  20        li   rtmp,NOS1                  ; JSR NOS1          ; Set up the sound block in XX16 for the sound in A and
     CBB2 CBCE     
31099 CBB4 06A0  32        bl   @jsr                       ;
     CBB6 FE1E     
31100                                                                          ; fall through into NO3 to make the sound
31101               
31102               * ******************************************************************************
31103               *
31104               * Name: NO3
31105               * Type: Subroutine
31106               * Category: Sound
31107               * Summary: Make a sound from a prepared sound block
31108               *
31109               * ------------------------------------------------------------------------------
31110               *
31111               * Make a sound from a prepared sound block in XX16 (if sound is enabled). See
31112               * routine NOS1 for details of preparing the XX16 sound block.
31113               *
31114               * ******************************************************************************
31115               
31116               NO3:
31117 CBB8 D3A0  30        movb @DNOIZ,rx                  ; LDX DNOIZ         ; Set X to the DNOIZ configuration setting
     CBBA 0F49     
31118               
31119 CBBC 1699  14        jne  NO1                        ; BNE NO1           ; If DNOIZ is non-zero, then sound is disabled, so
31120                                                                          ; return from the subroutine (as NO1 contains an RTS)
31121               
31122 CBBE 020E  20        li   rx,((XX16)%256)*256        ; LDX #LO(XX16)     ; Otherwise set (Y X) to point to the sound block in
     CBC0 0900     
31123 CBC2 020F  20        li   ry,((XX16)/256)*256        ; LDY #HI(XX16)     ; XX16
     CBC4 0000     
31124               
31125 CBC6 020D  20        li   ra,>07*256                 ; LDA #7            ; Call OSWORD 7 to makes the sound, as described in the
     CBC8 0700     
31126 CBCA 0460  28        b    @OSWORD                    ; JMP OSWORD        ; documentation for variable SFX, and return from the
     CBCC FE1A     
31127                                                                          ; subroutine using a tail call
31128               
31129               * ******************************************************************************
31130               *
31131               * Name: NOS1
31132               * Type: Subroutine
31133               * Category: Sound
31134               * Summary: Prepare a sound block
31135               *
31136               * ------------------------------------------------------------------------------
31137               *
31138               * Copy four sound bytes from SFX into XX16, interspersing them with null bytes,
31139               * with Y indicating the sound number to copy (from the values in the sound
31140               * table at SFX). So, for example, if we call this routine with A = 40 (long,
31141               * low beep), the following bytes will be set in XX16 to XX16+7:
31142               *
31143               * &13 &00 &F4 &00 &0C &00 &08 &00
31144               *
31145               * This block will be passed to OSWORD 7 to make the sound, which expects the
31146               * four sound attributes as 16-bit big-endian values - in other words, with the
31147               * low byte first. So the above block would pass the values &0013, &00F4, &000C
31148               * and &0008 to the SOUND statement when used with OSWORD 7, or:
31149               *
31150               * SOUND &13, &F4, &0C, &08
31151               *
31152               * as the high bytes are always zero.
31153               *
31154               * ------------------------------------------------------------------------------
31155               *
31156               * Arguments:
31157               *
31158               * A                   The sound number to copy from SFX to XX16, which is
31159               * always a multiple of 8
31160               *
31161               * ******************************************************************************
31162               
31163               NOS1:
31164 CBCE 091D  18        srl  ra,1                       ; LSR A             ; Divide A by 2, and also clear the C flag, as bit 0 of
31165                                                                          ; A is always zero (as A is a multiple of 8)
31166               
31167                      .adi (>03*256)                  ; ADC #3            ; Set Y = A + 3, so Y now points to the last byte of
     **** ****     > ADI
0001 CBD0 1701  14        jnc  !
0002 CBD2 B347  18        ab   rone,ra
0003               !:
0004 CBD4 022D  22        ai   ra,(>03*256)
     CBD6 0300     
                   < elite.a99
31168 CBD8 D3CD  18        movb ra,ry                      ; TAY               ; four within the block of four-byte values
31169               
31170 CBDA 020E  20        li   rx,>07*256                 ; LDX #7            ; We want to copy four bytes, spread out into an 8-byte
     CBDC 0700     
31171                                                                          ; block, so set a counter in Y to cover 8 bytes
31172               
31173               NOL1:
31174 CBDE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the X-th byte of XX16 to 0
     CBE0 0000     
31175 CBE2 DB8D  38        movb ra,@XX16(rx)               ; STA XX16,X
     CBE4 0009     
31176               
31177 CBE6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer
31178               
31179 CBE8 D36F  34        movb @SFX(ry),ra                ; LDA SFX,Y         ; Set the X-th byte of XX16 to the value from SFX+Y
     CBEA BEE2     
31180 CBEC DB8D  38        movb ra,@XX16(rx)               ; STA XX16,X
     CBEE 0009     
31181               
31182 CBF0 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the source byte pointer again
31183               
31184 CBF2 7387  18        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer again
31185               
31186 CBF4 15F4  14        jgt  NOL1                       ; BPL NOL1          ; Loop back for the next source byte
31187               
31188 CBF6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CBF8 FE2A     
31189               
31190               * ******************************************************************************
31191               *
31192               * Name: KYTB
31193               * Type: Variable
31194               * Category: Keyboard
31195               * Summary: Lookup table for in-flight keyboard controls
31196               * Deep dive: The key logger
31197               *
31198               * ------------------------------------------------------------------------------
31199               *
31200               * Keyboard table for in-flight controls. This table contains the internal key
31201               * codes for the flight keys (see p.142 of the Advanced User Guide for a list of
31202               * internal key numbers).
31203               *
31204               * The pitch, roll, speed and laser keys (i.e. the seven primary flight
31205               * control keys) have bit 7 set, so they have 128 added to their internal
31206               * values. This doesn't appear to be used anywhere.
31207               *
31208               * ******************************************************************************
31209               
31210               KYTB:                                                      ; Point KYTB to the byte before the start of the table
31211                      equ $ - 1
31212               
31213                                                                          ; These are the primary flight controls (pitch, roll,
31214                                                                          ; speed and lasers):
31215               
31216 CBFA E8              byte >68 + 128                                      ; ?         KYTB+1      Slow down
31217 CBFB   E2            byte >62 + 128                                      ; Space     KYTB+2      Speed up
31218 CBFC E6              byte >66 + 128                                      ; <         KYTB+3      Roll left
31219 CBFD   E7            byte >67 + 128                                      ; >         KYTB+4      Roll right
31220 CBFE C2              byte >42 + 128                                      ; X         KYTB+5      Pitch up
31221 CBFF   D1            byte >51 + 128                                      ; S         KYTB+6      Pitch down
31222 CC00 C1              byte >41 + 128                                      ; A         KYTB+7      Fire lasers
31223               
31224                                                                          ; These are the secondary flight controls:
31225               
31226 CC01   60            byte >60                                            ; TAB       KYTB+8      Energy bomb
31227 CC02 70              byte >70                                            ; ESCAPE    KYTB+9      Launch escape pod
31228 CC03   23            byte >23                                            ; T         KYTB+10     Arm missile
31229 CC04 35              byte >35                                            ; U         KYTB+11     Unarm missile
31230 CC05   65            byte >65                                            ; M         KYTB+12     Fire missile
31231 CC06 22              byte >22                                            ; E         KYTB+13     E.C.M.
31232 CC07   45            byte >45                                            ; J         KYTB+14     In-system jump
31233 CC08 52              byte >52                                            ; C         KYTB+15     Docking computer
31234               
31235               * ******************************************************************************
31236               *
31237               * Name: DKS1
31238               * Type: Subroutine
31239               * Category: Keyboard
31240               * Summary: Scan the keyboard for a flight key
31241               * Deep dive: The key logger
31242               *
31243               * ------------------------------------------------------------------------------
31244               *
31245               * Scan the keyboard for the flight key given in register Y, where Y is the
31246               * offset into the KYTB table above (so we can scan for Space by setting Y to
31247               * 2, for example). If the key is pressed, set the corresponding byte in the
31248               * key logger at KL to &FF.
31249               *
31250               * ------------------------------------------------------------------------------
31251               *
31252               * Arguments:
31253               *
31254               * Y                   The offset into the KYTB table above of the key that we
31255               * want to scan on the keyboard
31256               *
31257               * ******************************************************************************
31258               
31259               DKS1:
31260 CC0A D3AF  34        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number from the Y-th byte of the
     CC0C CBF9     
31261                                                                          ; KYTB table above
31262               
31263 CC0E 0200  20        li   rtmp,DKS4                  ; JSR DKS4          ; Call DKS4, which will set A and X to a negative value
     CC10 CC28     
31264 CC12 06A0  32        bl   @jsr                       ;
     CC14 FE1E     
31265                                                                          ; if the key is being pressed
31266               
31267 CC16 151E  14        jgt  DKS2-1                     ; BPL DKS2-1        ; The key is not being pressed, so return from the
31268                                                                          ; subroutine (as DKS2-1 contains an RTS)
31269               
31270 CC18 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Store &FF in the Y-th byte of the key logger at KL
     CC1A FF00     
31271 CC1C DBCE  38        movb rx,@KL(ry)                 ; STX KL,Y
     CC1E 0041     
31272               
31273 CC20 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CC22 FE2A     
31274               
31275               * ******************************************************************************
31276               *
31277               * Name: CTRL
31278               * Type: Subroutine
31279               * Category: Keyboard
31280               * Summary: Scan the keyboard to see if CTRL is currently pressed
31281               *
31282               * ------------------------------------------------------------------------------
31283               *
31284               * Returns:
31285               *
31286               * X                   X = %10000001 (i.e. 129 or -127) if CTRL is being
31287               * pressed
31288               *
31289               * X = 1 if CTRL is not being pressed
31290               *
31291               * A                   Contains the same as X
31292               *
31293               * ******************************************************************************
31294               
31295               CTRL:
31296 CC24 020E  20        li   rx,>01*256                 ; LDX #1            ; Set X to the internal key number for CTRL and fall
     CC26 0100     
31297                                                                          ; through to DKS4 to scan the keyboard
31298               
31299               * ******************************************************************************
31300               *
31301               * Name: DKS4
31302               * Type: Subroutine
31303               * Category: Keyboard
31304               * Summary: Scan the keyboard to see if a specific key is being pressed
31305               * Deep dive: The key logger
31306               *
31307               * ------------------------------------------------------------------------------
31308               *
31309               * Arguments:
31310               *
31311               * X                   The internal number of the key to check (see p.142 of
31312               * the Advanced User Guide for a list of internal key
31313               * numbers)
31314               *
31315               * ------------------------------------------------------------------------------
31316               *
31317               * Returns:
31318               *
31319               * A                   If the key in A is being pressed, A contains the
31320               * original argument A, but with bit 7 set (i.e. A + 128).
31321               * If the key in A is not being pressed, the value in A is
31322               * unchanged
31323               *
31324               * X                   Contains the same as A
31325               *
31326               * ******************************************************************************
31327               
31328               DKS4:
31329 CC28 020D  20        li   ra,>03*256                 ; LDA #%00000011    ; Set A to %00000011, so it's ready to send to SHEILA
     CC2A 0300     
31330                                                                          ; once interrupts have been disabled
31331               
31332 CC2C 0300  22        limi 0                          ; SEI               ; Disable interrupts so we can scan the keyboard
     CC2E 0000     
31333                                                                          ; without being hijacked
31334               
31335 CC30 D80D  38        movb ra,@VIA+>40                ; STA VIA+&40       ; Set 6522 System VIA output register ORB (SHEILA &40)
     CC32 FE40     
31336                                                                          ; to %00000011 to stop auto scan of keyboard
31337               
31338 CC34 020D  20        li   ra,>7f*256                 ; LDA #%01111111    ; Set 6522 System VIA data direction register DDRA
     CC36 7F00     
31339 CC38 D80D  38        movb ra,@VIA+>43                ; STA VIA+&43       ; (SHEILA &43) to %01111111. This sets the A registers
     CC3A FE43     
31340                                                                          ; (IRA and ORA) so that:
31341                                                                          ;
31342                                                                          ; * Bits 0-6 of ORA will be sent to the keyboard
31343                                                                          ;
31344                                                                          ; * Bit 7 of IRA will be read from the keyboard
31345               
31346 CC3C D80E  38        movb rx,@VIA+>4F                ; STX VIA+&4F       ; Set 6522 System VIA output register ORA (SHEILA &4F)
     CC3E FE4F     
31347                                                                          ; to X, the key we want to scan for; bits 0-6 will be
31348                                                                          ; sent to the keyboard, of which bits 0-3 determine the
31349                                                                          ; keyboard column, and bits 4-6 the keyboard row
31350               
31351 CC40 D3A0  34        movb @VIA+>4F,rx                ; LDX VIA+&4F       ; Read 6522 System VIA output register IRA (SHEILA &4F)
     CC42 FE4F     
31352                                                                          ; into X; bit 7 is the only bit that will have changed.
31353                                                                          ; If the key is pressed, then bit 7 will be set,
31354                                                                          ; otherwise it will be clear
31355               
31356 CC44 020D  20        li   ra,>0b*256                 ; LDA #%00001011    ; Set 6522 System VIA output register ORB (SHEILA &40)
     CC46 0B00     
31357 CC48 D80D  38        movb ra,@VIA+>40                ; STA VIA+&40       ; to %00001011 to restart auto scan of keyboard
     CC4A FE40     
31358               
31359 CC4C 0300  22        limi 2                          ; CLI               ; Allow interrupts again
     CC4E 0002     
31360               
31361 CC50 D34E  18        movb rx,ra                      ; TXA               ; Transfer X into A
31362               
31363 CC52 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CC54 FE2A     
31364               
31365               * ******************************************************************************
31366               *
31367               * Name: DKS2
31368               * Type: Subroutine
31369               * Category: Keyboard
31370               * Summary: Read the joystick position
31371               *
31372               * ------------------------------------------------------------------------------
31373               *
31374               * Return the value of ADC channel in X (used to read the joystick). The value
31375               * will be inverted if the game has been configured to reverse both joystick
31376               * channels (which can be done by pausing the game and pressing J).
31377               *
31378               * ------------------------------------------------------------------------------
31379               *
31380               * Arguments:
31381               *
31382               * X                   The ADC channel to read:
31383               *
31384               * * 1 = joystick X
31385               *
31386               * * 2 = joystick Y
31387               *
31388               * ------------------------------------------------------------------------------
31389               *
31390               * Returns:
31391               *
31392               * (A X)               The 16-bit value read from channel X, with the value
31393               * inverted if the game has been configured to reverse the
31394               * joystick
31395               *
31396               * ------------------------------------------------------------------------------
31397               *
31398               * Other entry points:
31399               *
31400               * DKS2-1              Contains an RTS
31401               *
31402               * ******************************************************************************
31403               
31404               DKS2:
31405 CC56 020D  20        li   ra,>80*256                 ; LDA #128          ; Call OSBYTE with A = 128 to fetch the 16-bit value
     CC58 8000     
31406 CC5A 0200  20        li   rtmp,OSBYTE                ; JSR OSBYTE        ; from ADC channel X, returning (Y X), i.e. the high
     CC5C FE18     
31407 CC5E 06A0  32        bl   @jsr                       ;
     CC60 FE1E     
31408                                                                          ; byte in Y and the low byte in X
31409                                                                          ;
31410                                                                          ; * Channel 1 is the x-axis: 0 = right, 65520 = left
31411                                                                          ;
31412                                                                          ; * Channel 2 is the y-axis: 0 = down,  65520 = up
31413               
31414 CC62 D34F  18        movb ry,ra                      ; TYA               ; Copy Y to A, so the result is now in (A X)
31415               
31416                      .eor @JSTE                      ; EOR JSTE          ; The high byte A is now EOR'd with the value in
     **** ****     > EOR
0001 CC64 D020  30        movb @JSTE,rtmp
     CC66 0F4F     
0002 CC68 2B40  18        xor  rtmp,ra
                   < elite.a99
31417                                                                          ; location JSTE, which contains &FF if both joystick
31418                                                                          ; channels are reversed and 0 otherwise (so A now
31419                                                                          ; contains the high byte but inverted, if that's what
31420                                                                          ; the current settings say)
31421               
31422 CC6A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CC6C FE2A     
31423               
31424               * ******************************************************************************
31425               *
31426               * Name: DKS3
31427               * Type: Subroutine
31428               * Category: Keyboard
31429               * Summary: Toggle a configuration setting and emit a beep
31430               *
31431               * ------------------------------------------------------------------------------
31432               *
31433               * This is called when the game is paused and a key is pressed that changes the
31434               * game's configuration.
31435               *
31436               * Specifically, this routine toggles the configuration settings for the
31437               * following keys:
31438               *
31439               * * CAPS LOCK toggles keyboard flight damping (&40)
31440               * * A toggles keyboard auto-recentre (&41)
31441               * * X toggles author names on start-up screen (&42)
31442               * * F toggles flashing console bars (&43)
31443               * * Y toggles reverse joystick Y channel (&44)
31444               * * J toggles reverse both joystick channels (&45)
31445               * * K toggles keyboard and joystick (&46)
31446               *
31447               * The numbers in brackets are the internal key numbers (see p.142 of the
31448               * Advanced User Guide for a list of internal key numbers). We pass the key that
31449               * has been pressed in X, and the configuration option to check it against in Y,
31450               * so this routine is typically called in a loop that loops through the various
31451               * configuration options.
31452               *
31453               * ------------------------------------------------------------------------------
31454               *
31455               * Arguments:
31456               *
31457               * X                   The internal number of the key that's been pressed
31458               *
31459               * Y                   The internal number of the configuration key to check
31460               * against, from the list above (i.e. Y must be from &40 to
31461               * &46)
31462               *
31463               * ******************************************************************************
31464               
31465               DKS3:
31466 CC6E D80F  30        movb ry,@T                      ; STY T             ; Store the configuration key argument in T
     CC70 00D1     
31467               
31468 CC72 93A0  30        cb   @T,rx                      ; CPX T             ; If X <> Y, jump to Dk3 to return from the subroutine
     CC74 00D1     
31469 CC76 1611  14        jne  Dk3                        ; BNE Dk3
31470               
31471                                                                          ; We have a match between X and Y, so now to toggle
31472                                                                          ; the relevant configuration byte. CAPS LOCK has a key
31473                                                                          ; value of &40 and has its configuration byte at
31474                                                                          ; location DAMP, A has a value of &41 and has its byte
31475                                                                          ; at location DJD, which is DAMP+1, and so on. So we
31476                                                                          ; can toggle the configuration byte by changing the
31477                                                                          ; byte at DAMP + (X - &40), or to put it in indexing
31478                                                                          ; terms, DAMP-&40,X. It's no coincidence that the
31479                                                                          ; game's configuration bytes are set up in this order
31480                                                                          ; and with these keys (and this is also why the sound
31481                                                                          ; on/off keys are dealt with elsewhere, as the internal
31482                                                                          ; key for S and Q are &51 and &10, which don't fit
31483                                                                          ; nicely into this approach)
31484               
31485 CC78 D36E  34        movb @DAMP->40(rx),ra           ; LDA DAMP-&40,X    ; Fetch the byte from DAMP + (X - &40), invert it and
     CC7A 0F0A     
31486                      .eoi (>ff*256)                  ; EOR #&FF          ; put it back (0 means no and &FF means yes in the
     **** ****     > EOI
0001 CC7C 0200  20        li   rtmp,(>FF*256)
     CC7E FF00     
0002 CC80 2B40  18        xor  rtmp,ra
                   < elite.a99
31487 CC82 DB8D  38        movb ra,@DAMP->40(rx)           ; STA DAMP-&40,X    ; configuration bytes, so this toggles the setting)
     CC84 0F0A     
31488               
31489 CC86 0200  20        li   rtmp,BELL                  ; JSR BELL          ; Make a beep sound so we know something has happened
     CC88 316E     
31490 CC8A 06A0  32        bl   @jsr                       ;
     CC8C FE1E     
31491               
31492 CC8E 0200  20        li   rtmp,DELAY                 ; JSR DELAY         ; Wait for Y vertical syncs (Y is between 64 and 70, so
     CC90 4C00     
31493 CC92 06A0  32        bl   @jsr                       ;
     CC94 FE1E     
31494                                                                          ; this is always a bit longer than a second)
31495               
31496 CC96 D3E0  30        movb @T,ry                      ; LDY T             ; Restore the configuration key argument into Y
     CC98 00D1     
31497               
31498               Dk3:
31499 CC9A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CC9C FE2A     
31500               
31501               * ******************************************************************************
31502               *
31503               * Name: DKJ1
31504               * Type: Subroutine
31505               * Category: Keyboard
31506               * Summary: Read joystick and flight controls
31507               *
31508               * ------------------------------------------------------------------------------
31509               *
31510               * Specifically, scan the keyboard for the speed up and slow down keys, and read
31511               * the joystick's fire button and X and Y axes, storing the results in the key
31512               * logger and the joystick position variables.
31513               *
31514               * This routine is only called if joysticks are enabled (JSTK = non-zero).
31515               *
31516               * ******************************************************************************
31517               
31518               DKJ1:
31519 CC9E 020F  20        li   ry,>01*256                 ; LDY #1            ; Update the key logger for key 1 in the KYTB table, so
     CCA0 0100     
31520 CCA2 0200  20        li   rtmp,DKS1                  ; JSR DKS1          ; KY1 will be &FF if "?" (slow down) is being pressed
     CCA4 CC0A     
31521 CCA6 06A0  32        bl   @jsr                       ;
     CCA8 FE1E     
31522               
31523 CCAA B3C7  18        ab   rone,ry                    ; INY               ; Update the key logger for key 2 in the KYTB table, so
31524 CCAC 0200  20        li   rtmp,DKS1                  ; JSR DKS1          ; KY2 will be &FF if Space (speed up) is being pressed
     CCAE CC0A     
31525 CCB0 06A0  32        bl   @jsr                       ;
     CCB2 FE1E     
31526               
31527 CCB4 D360  34        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     CCB6 FE40     
31528               
31529 CCB8 D38D  18        movb ra,rx                      ; TAX               ; This instruction doesn't seem to have any effect, as
31530                                                                          ; X is overwritten in a few instructions. When the
31531                                                                          ; joystick is checked in a similar way in the TITLE
31532                                                                          ; subroutine for the "Press Fire Or Space,Commander."
31533                                                                          ; stage of the start-up screen, there's another
31534                                                                          ; unnecessary TAX instruction present, but there it's
31535                                                                          ; commented out
31536               
31537 CCBA 024D  22        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     CCBC 1000     
31538                                                                          ; button is pressed, otherwise it is set, so AND'ing
31539                                                                          ; the value of IRB with %10000 extracts this bit
31540               
31541                      .eoi (>10*256)                  ; EOR #%00010000    ; Flip bit 4 so that it's set if the fire button has
     **** ****     > EOI
0001 CCBE 0200  20        li   rtmp,(>10*256)
     CCC0 1000     
0002 CCC2 2B40  18        xor  rtmp,ra
                   < elite.a99
31542 CCC4 D80D  30        movb ra,@KY7                    ; STA KY7           ; been pressed, and store the result in the keyboard
     CCC6 0048     
31543                                                                          ; logger at location KY7, which is also where the A key
31544                                                                          ; (fire lasers) key is logged
31545               
31546 CCC8 020E  20        li   rx,>01*256                 ; LDX #1            ; Call DKS2 to fetch the value of ADC channel 1 (the
     CCCA 0100     
31547 CCCC 0200  20        li   rtmp,DKS2                  ; JSR DKS2          ; joystick X value) into (A X), and OR A with 1. This
     CCCE CC56     
31548 CCD0 06A0  32        bl   @jsr                       ;
     CCD2 FE1E     
31549 CCD4 026D  22        ori  ra,>01*256                 ; ORA #1            ; ensures that the high byte is at least 1, and then we
     CCD6 0100     
31550 CCD8 D80D  30        movb ra,@JSTX                   ; STA JSTX          ; store the result in JSTX
     CCDA 009C     
31551               
31552 CCDC 020E  20        li   rx,>02*256                 ; LDX #2            ; Call DKS2 to fetch the value of ADC channel 2 (the
     CCDE 0200     
31553 CCE0 0200  20        li   rtmp,DKS2                  ; JSR DKS2          ; joystick Y value) into (A X), and EOR A with JSTGY.
     CCE2 CC56     
31554 CCE4 06A0  32        bl   @jsr                       ;
     CCE6 FE1E     
31555                      .eor @JSTGY                     ; EOR JSTGY         ; JSTGY will be &FF if the game is configured to
     **** ****     > EOR
0001 CCE8 D020  30        movb @JSTGY,rtmp
     CCEA 0F4E     
0002 CCEC 2B40  18        xor  rtmp,ra
                   < elite.a99
31556 CCEE D80D  30        movb ra,@JSTY                   ; STA JSTY          ; reverse the joystick Y channel, so this EOR does
     CCF0 009D     
31557                                                                          ; exactly that, and then we store the result in JSTY
31558               
31559 CCF2 0460  28        b    @DK4                       ; JMP DK4           ; We are done scanning the joystick flight controls,
     CCF4 CD7A     
31560                                                                          ; so jump to DK4 to scan for other keys, using a tail
31561                                                                          ; call so we can return from the subroutine there
31562               
31563               * ******************************************************************************
31564               *
31565               * Name: U%
31566               * Type: Subroutine
31567               * Category: Keyboard
31568               * Summary: Clear the key logger
31569               *
31570               * ------------------------------------------------------------------------------
31571               *
31572               * Returns:
31573               *
31574               * A                   A is set to 0
31575               *
31576               * Y                   Y is set to 0
31577               *
31578               * ******************************************************************************
31579               
31580               U.:
31581 CCF6 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0, as this means "key not pressed" in the
     CCF8 0000     
31582                                                                          ; key logger at KL
31583               
31584 CCFA 020F  20        li   ry,>0f*256                 ; LDY #15           ; We want to clear the 15 key logger locations from
     CCFC 0F00     
31585                                                                          ; KY1 to KY19, so set a counter in Y
31586               
31587               DKL3:
31588 CCFE DBCD  38        movb ra,@KL(ry)                 ; STA KL,Y          ; Store 0 in the Y-th byte of the key logger
     CD00 0041     
31589               
31590 CD02 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
31591               
31592 CD04 16FC  14        jne  DKL3                       ; BNE DKL3          ; And loop back for the next key, until we have just
31593                                                                          ; KL+1. We don't want to clear the first key logger
31594                                                                          ; location at KL, as the keyboard table at KYTB starts
31595                                                                          ; with offset 1, not 0, so KL is not technically part of
31596                                                                          ; the key logger (it's actually used for logging keys
31597                                                                          ; that don't appear in the keyboard table, and which
31598                                                                          ; therefore don't use the key logger)
31599               
31600 CD06 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CD08 FE2A     
31601               
31602               * ******************************************************************************
31603               *
31604               * Name: DOKEY
31605               * Type: Subroutine
31606               * Category: Keyboard
31607               * Summary: Scan for the seven primary flight controls
31608               * Deep dive: The key logger
31609               * The docking computer
31610               *
31611               * ------------------------------------------------------------------------------
31612               *
31613               * Scan for the seven primary flight controls (or the equivalent on joystick),
31614               * pause and configuration keys, and secondary flight controls, and update the
31615               * key logger accordingly. Specifically:
31616               *
31617               * * If we are on keyboard configuration, clear the key logger and update it
31618               * for the seven primary flight controls, and update the pitch and roll
31619               * rates accordingly.
31620               *
31621               * * If we are on joystick configuration, clear the key logger and jump to
31622               * DKJ1, which reads the joystick equivalents of the primary flight
31623               * controls.
31624               *
31625               * Both options end up at DK4 to scan for other keys, beyond the seven primary
31626               * flight controls.
31627               *
31628               * ******************************************************************************
31629               
31630               DOKEY:
31631 CD0A 0200  20        li   rtmp,U.                    ; JSR U%            ; Call U% to clear the key logger
     CD0C CCF6     
31632 CD0E 06A0  32        bl   @jsr                       ;
     CD10 FE1E     
31633               
31634 CD12 D360  30        movb @JSTK,ra                   ; LDA JSTK          ; If JSTK is non-zero, then we are configured to use
     CD14 0F50     
31635 CD16 16C3  14        jne  DKJ1                       ; BNE DKJ1          ; the joystick rather than keyboard, so jump to DKJ1
31636                                                                          ; to read the joystick flight controls, before jumping
31637                                                                          ; to DK4 to scan for pause, configuration and secondary
31638                                                                          ; flight keys
31639               
31640 CD18 020F  20        li   ry,>07*256                 ; LDY #7            ; We're going to work our way through the primary flight
     CD1A 0700     
31641                                                                          ; control keys (pitch, roll, speed and laser), so set a
31642                                                                          ; counter in Y so we can loop through all 7
31643               
31644               DKL2:
31645 CD1C 0200  20        li   rtmp,DKS1                  ; JSR DKS1          ; Call DKS1 to see if the KYTB key at offset Y is being
     CD1E CC0A     
31646 CD20 06A0  32        bl   @jsr                       ;
     CD22 FE1E     
31647                                                                          ; pressed, and set the key logger accordingly
31648               
31649 CD24 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
31650               
31651 CD26 16FA  14        jne  DKL2                       ; BNE DKL2          ; Loop back for the next key, working our way from A at
31652                                                                          ; KYTB+7 down to ? at KYTB+1
31653               
31654 CD28 D3A0  30        movb @JSTX,rx                   ; LDX JSTX          ; Set X = JSTX, the current roll rate (as shown in the
     CD2A 009C     
31655                                                                          ; RL indicator on the dashboard)
31656               
31657 CD2C 020D  20        li   ra,>07*256                 ; LDA #7            ; Set A to 7, which is the amount we want to alter the
     CD2E 0700     
31658                                                                          ; roll rate by if the roll keys are being pressed
31659               
31660 CD30 D3E0  30        movb @KL+3,ry                   ; LDY KL+3          ; If the "<" key is being pressed, then call the BUMP2
     CD32 0044     
31661 CD34 1304  14        jeq  B103                       ; BEQ B103          ; routine to increase the roll rate in X by A
31662 CD36 0200  20        li   rtmp,BUMP2                 ; JSR BUMP2
     CD38 472E     
31663 CD3A 06A0  32        bl   @jsr                       ;
     CD3C FE1E     
31664               
31665               B103:
31666 CD3E D3E0  30        movb @KL+4,ry                   ; LDY KL+4          ; If the ">" key is being pressed, then call the REDU2
     CD40 0045     
31667 CD42 1304  14        jeq  B104                       ; BEQ B104          ; routine to decrease the roll rate in X by A, taking
31668 CD44 0200  20        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     CD46 4750     
31669 CD48 06A0  32        bl   @jsr                       ;
     CD4A FE1E     
31670               
31671               B104:
31672 CD4C D80E  30        movb rx,@JSTX                   ; STX JSTX          ; Store the updated roll rate in JSTX
     CD4E 009C     
31673               
31674                      .asla                           ; ASL A             ; Double the value of A, to 14
     **** ****     > ASLA
0001 CD50 024D  22        andi ra,>ff00
     CD52 FF00     
0002 CD54 0A1D  18        sla  ra,1
                   < elite.a99
31675               
31676 CD56 D3A0  30        movb @JSTY,rx                   ; LDX JSTY          ; Set X = JSTY, the current pitch rate (as shown in the
     CD58 009D     
31677                                                                          ; DC indicator on the dashboard)
31678               
31679 CD5A D3E0  30        movb @KL+5,ry                   ; LDY KL+5          ; If the "X" key is being pressed, then call the REDU2
     CD5C 0046     
31680 CD5E 1304  14        jeq  B105                       ; BEQ B105          ; routine to decrease the pitch rate in X by A, taking
31681 CD60 0200  20        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     CD62 4750     
31682 CD64 06A0  32        bl   @jsr                       ;
     CD66 FE1E     
31683               
31684               B105:
31685 CD68 D3E0  30        movb @KL+6,ry                   ; LDY KL+6          ; If the "S" key is being pressed, then call the BUMP2
     CD6A 0047     
31686 CD6C 1304  14        jeq  B106                       ; BEQ B106          ; routine to increase the pitch rate in X by A
31687 CD6E 0200  20        li   rtmp,BUMP2                 ; JSR BUMP2
     CD70 472E     
31688 CD72 06A0  32        bl   @jsr                       ;
     CD74 FE1E     
31689               
31690               B106:
31691 CD76 D80E  30        movb rx,@JSTY                   ; STX JSTY          ; Store the updated roll rate in JSTY
     CD78 009D     
31692               
31693                                                                          ; Fall through into DK4 to scan for other keys
31694               
31695               * ******************************************************************************
31696               *
31697               * Name: DK4
31698               * Type: Subroutine
31699               * Category: Keyboard
31700               * Summary: Scan for pause, configuration and secondary flight keys
31701               * Deep dive: The key logger
31702               *
31703               * ------------------------------------------------------------------------------
31704               *
31705               * Scan for pause and configuration keys, and if this is a space view, also scan
31706               * for secondary flight controls.
31707               *
31708               * Specifically:
31709               *
31710               * * Scan for the pause button (COPY) and if it's pressed, pause the game and
31711               * process any configuration key presses until the game is unpaused (DELETE)
31712               *
31713               * * If this is a space view, scan for secondary flight keys and update the
31714               * relevant bytes in the key logger
31715               *
31716               * ******************************************************************************
31717               
31718               DK4:
31719 CD7A 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     CD7C CAF4     
31720 CD7E 06A0  32        bl   @jsr                       ;
     CD80 FE1E     
31721                                                                          ; internal key number in X (or 0 for no key press)
31722               
31723 CD82 D80E  30        movb rx,@KL                     ; STX KL            ; Store X in KL, byte #0 of the key logger
     CD84 0041     
31724               
31725 CD86 028E  22        ci   rx,>69*256                 ; CPX #&69          ; If COPY is not being pressed, jump to DK2 below,
     CD88 6900     
31726 CD8A 1626  14        jne  DK2                        ; BNE DK2           ; otherwise let's process the configuration keys
31727               
31728               FREEZE:
31729                                                                          ; COPY is being pressed, so we enter a loop that
31730                                                                          ; listens for configuration keys, and we keep looping
31731                                                                          ; until we detect a DELETE key press. This effectively
31732                                                                          ; pauses the game when COPY is pressed, and unpauses
31733                                                                          ; it when DELETE is pressed
31734 CD8C 0200  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     CD8E 4DE2     
31735 CD90 06A0  32        bl   @jsr                       ;
     CD92 FE1E     
31736                                                                          ; screen gets drawn
31737               
31738 CD94 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     CD96 CAF4     
31739 CD98 06A0  32        bl   @jsr                       ;
     CD9A FE1E     
31740                                                                          ; internal key number in X (or 0 for no key press)
31741               
31742 CD9C 028E  22        ci   rx,>51*256                 ; CPX #&51          ; If "S" is not being pressed, skip to DK6
     CD9E 5100     
31743 CDA0 1604  14        jne  DK6                        ; BNE DK6
31744               
31745 CDA2 020D  20        li   ra,>00*256                 ; LDA #0            ; "S" is being pressed, so set DNOIZ to 0 to turn the
     CDA4 0000     
31746 CDA6 D80D  30        movb ra,@DNOIZ                  ; STA DNOIZ         ; sound on
     CDA8 0F49     
31747               
31748               DK6:
31749 CDAA 020F  20        li   ry,>40*256                 ; LDY #&40          ; We now want to loop through the keys that toggle
     CDAC 4000     
31750                                                                          ; various settings. These have internal key numbers
31751                                                                          ; between &40 (CAPS LOCK) and &46 ("K"), so we set up
31752                                                                          ; the first key number in Y to act as a loop counter.
31753                                                                          ; See subroutine DKS3 for more details on this
31754               
31755               DKL4:
31756 CDAE 0200  20        li   rtmp,DKS3                  ; JSR DKS3          ; Call DKS3 to scan for the key given in Y, and toggle
     CDB0 CC6E     
31757 CDB2 06A0  32        bl   @jsr                       ;
     CDB4 FE1E     
31758                                                                          ; the relevant setting if it is pressed
31759               
31760 CDB6 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next toggle key
31761               
31762 CDB8 028F  22        ci   ry,>47*256                 ; CPY #&47          ; The last toggle key is &46 (K), so check whether we
     CDBA 4700     
31763                                                                          ; have just done that one
31764               
31765 CDBC 16F8  14        jne  DKL4                       ; BNE DKL4          ; If not, loop back to check for the next toggle key
31766               
31767               DK55:
31768 CDBE 028E  22        ci   rx,>10*256                 ; CPX #&10          ; If "Q" is not being pressed, skip to DK7
     CDC0 1000     
31769 CDC2 1602  14        jne  DK7                        ; BNE DK7
31770               
31771 CDC4 D80E  30        movb rx,@DNOIZ                  ; STX DNOIZ         ; "Q" is being pressed, so set DNOIZ to X, which is
     CDC6 0F49     
31772                                                                          ; non-zero (&10), so this will turn the sound off
31773               
31774               DK7:
31775 CDC8 028E  22        ci   rx,>70*256                 ; CPX #&70          ; If ESCAPE is not being pressed, skip over the next
     CDCA 7000     
31776 CDCC 1602  14        jne  B107                       ; BNE B107          ; instruction
31777               
31778 CDCE 0460  28        b    @DEATH2                    ; JMP DEATH2        ; ESCAPE is being pressed, so jump to DEATH2 to end
     CDD0 C59C     
31779                                                                          ; the game
31780               
31781               B107:
31782 CDD2 028E  22        ci   rx,>59*256                 ; CPX #&59          ; If DELETE is not being pressed, we are still paused,
     CDD4 5900     
31783 CDD6 16DA  14        jne  FREEZE                     ; BNE FREEZE        ; so loop back up to keep listening for configuration
31784                                                                          ; keys, otherwise fall through into the rest of the
31785                                                                          ; key detection code, which unpauses the game
31786               
31787               DK2:
31788 CDD8 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is non-zero (i.e. not a space
     CDDA 0096     
31789 CDDC 160F  14        jne  DK5                        ; BNE DK5           ; view), return from the subroutine (as DK5 contains
31790                                                                          ; an RTS)
31791               
31792 CDDE 020F  20        li   ry,>0f*256                 ; LDY #15           ; This is a space view, so now we want to check for all
     CDE0 0F00     
31793                                                                          ; the secondary flight keys. The internal key numbers
31794                                                                          ; are in the keyboard table KYTB from KYTB+8 to
31795                                                                          ; KYTB+15, and their key logger locations are from KL+8
31796                                                                          ; to KL+15. So set a decreasing counter in Y for the
31797                                                                          ; index, starting at 15, so we can loop through them
31798               
31799 CDE2 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can store this in the keyboard
     CDE4 FF00     
31800                                                                          ; logger for keys that are being pressed
31801               
31802               DKL1:
31803 CDE6 D3AF  34        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number of the Y-th flight key
     CDE8 CBF9     
31804                                                                          ; the KYTB keyboard table
31805               
31806 CDEA 93A0  30        cb   @KL,rx                     ; CPX KL            ; We stored the key that's being pressed in KL above,
     CDEC 0041     
31807                                                                          ; so check to see if the Y-th flight key is being
31808                                                                          ; pressed
31809               
31810 CDEE 1602  14        jne  DK1                        ; BNE DK1           ; If it is not being pressed, skip to DK1 below
31811               
31812 CDF0 DBCD  38        movb ra,@KL(ry)                 ; STA KL,Y          ; The Y-th flight key is being pressed, so set that
     CDF2 0041     
31813                                                                          ; key's location in the key logger to &FF
31814               
31815               DK1:
31816 CDF4 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
31817               
31818 CDF6 028F  22        ci   ry,>07*256                 ; CPY #7            ; Have we just done the last key?
     CDF8 0700     
31819               
31820 CDFA 16F5  14        jne  DKL1                       ; BNE DKL1          ; If not, loop back to process the next key
31821               
31822               DK5:
31823 CDFC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CDFE FE2A     
31824               
31825               * ******************************************************************************
31826               *
31827               * Name: TT217
31828               * Type: Subroutine
31829               * Category: Keyboard
31830               * Summary: Scan the keyboard until a key is pressed
31831               *
31832               * ------------------------------------------------------------------------------
31833               *
31834               * Scan the keyboard until a key is pressed, and return the key's ASCII code.
31835               * If, on entry, a key is already being held down, then wait until that key is
31836               * released first (so this routine detects the first key down event following
31837               * the subroutine call).
31838               *
31839               * ------------------------------------------------------------------------------
31840               *
31841               * Returns:
31842               *
31843               * X                   The ASCII code of the key that was pressed
31844               *
31845               * A                   Contains the same as X
31846               *
31847               * Y                   Y is preserved
31848               *
31849               * ------------------------------------------------------------------------------
31850               *
31851               * Other entry points:
31852               *
31853               * out                 Contains an RTS
31854               *
31855               * ******************************************************************************
31856               
31857               TT217:
31858 CE00 D80F  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y in temporary storage, so we can restore it
     CE02 0094     
31859                                                                          ; later
31860               
31861               t_:
31862 CE04 0200  20        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds) so we
     CE06 4BFB     
31863 CE08 06A0  32        bl   @jsr                       ;
     CE0A FE1E     
31864                                                                          ; don't take up too much CPU time while looping round
31865               
31866 CE0C 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     CE0E CAF4     
31867 CE10 06A0  32        bl   @jsr                       ;
     CE12 FE1E     
31868                                                                          ; internal key number in X (or 0 for no key press)
31869               
31870 CE14 16F7  14        jne  t_                         ; BNE t             ; If a key was already being held down when we entered
31871                                                                          ; this routine, keep looping back up to t, until the
31872                                                                          ; key is released
31873               
31874               t2_:
31875 CE16 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Any pre-existing key press is now gone, so we can
     CE18 CAF4     
31876 CE1A 06A0  32        bl   @jsr                       ;
     CE1C FE1E     
31877                                                                          ; start scanning the keyboard again, returning the
31878                                                                          ; internal key number in X (or 0 for no key press)
31879               
31880 CE1E 13FB  14        jeq  t2_                        ; BEQ t2            ; Keep looping up to t2 until a key is pressed
31881               
31882 CE20 D3CD  18        movb ra,ry                      ; TAY               ; Copy A to Y, so Y contains the internal key number
31883                                                                          ; of the key pressed
31884               
31885                      .ld_ind_y_idx @TRTB.,ra         ; LDA (TRTB%),Y     ; The address in TRTB% points to the MOS key
     **** ****     > LD_IND_Y_IDX
0001 CE22 D820  50        movb @TRTB.,@rtmplb
     CE24 0004     
     CE26 206D     
0002 CE28 D020  30        movb @TRTB.+1,rtmp
     CE2A 0005     
0003 CE2C A00F  18        a    ry,rtmp
0004 CE2E D350  26        movb *rtmp,RA
                   < elite.a99
31886                                                                          ; translation table, which is used to translate
31887                                                                          ; internal key numbers to ASCII, so this fetches the
31888                                                                          ; key's ASCII code into A
31889               
31890 CE30 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore the original value of Y we stored above
     CE32 0094     
31891               
31892 CE34 D38D  18        movb ra,rx                      ; TAX               ; Copy A into X
31893               
31894               out_:
31895 CE36 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CE38 FE2A     
31896               
31897               * ******************************************************************************
31898               *
31899               * Name: me1
31900               * Type: Subroutine
31901               * Category: Flight
31902               * Summary: Erase an old in-flight message and display a new one
31903               *
31904               * ------------------------------------------------------------------------------
31905               *
31906               * Arguments:
31907               *
31908               * A                   The text token to be printed
31909               *
31910               * X                   Must be set to 0
31911               *
31912               * ******************************************************************************
31913               
31914               me1_:
31915 CE3A D80E  30        movb rx,@DLY                    ; STX DLY           ; Set the message delay in DLY to 0, so any new
     CE3C 0D64     
31916                                                                          ; in-flight messages will be shown instantly
31917               
31918                      .pha                            ; PHA               ; Store the new message token we want to print
     **** ****     > PHA
0001 CE3E D68D  30        movb ra,*rsp
0002 CE40 060A  14        dec  rsp
                   < elite.a99
31919               
31920 CE42 D360  30        movb @MCH,ra                    ; LDA MCH           ; Set A to the token number of the message that is
     CE44 0F10     
31921 CE46 0200  20        li   rtmp,mes9_                 ; JSR mes9          ; currently on-screen, and call mes9 to print it (which
     CE48 CE84     
31922 CE4A 06A0  32        bl   @jsr                       ;
     CE4C FE1E     
31923                                                                          ; will remove it from the screen, as printing is done
31924                                                                          ; using EOR logic)
31925               
31926                      .pla                            ; PLA               ; Restore the new message token
     **** ****     > PLA
0001 CE4E 058A  14        inc  rsp
0002 CE50 D35A  26        movb *rsp,ra
                   < elite.a99
31927               
31928 CE52 2C              byte >2c                                            ; Fall through into ou2 to print the new message, but
31929                                                                          ; skip the first instruction by turning it into
31930                                                                          ; &2C &A9 &6C, or BIT &6CA9, which does nothing apart
31931                                                                          ; from affect the flags
31932               
31933               * ******************************************************************************
31934               *
31935               * Name: ou2
31936               * Type: Subroutine
31937               * Category: Flight
31938               * Summary: Display "E.C.M.SYSTEM DESTROYED" as an in-flight message
31939               *
31940               * ******************************************************************************
31941               
31942               ou2_:
31943 CE54 020D  20        li   ra,>6c*256                 ; LDA #108          ; Set A to recursive token 108 ("E.C.M.SYSTEM")
     CE56 6C00     
31944               
31945 CE58 2C              byte >2c                                            ; Fall through into ou3 to print the new message, but
31946                                                                          ; skip the first instruction by turning it into
31947                                                                          ; &2C &A9 &6F, or BIT &6FA9, which does nothing apart
31948                                                                          ; from affect the flags
31949               
31950               * ******************************************************************************
31951               *
31952               * Name: ou3
31953               * Type: Subroutine
31954               * Category: Flight
31955               * Summary: Display "FUEL SCOOPS DESTROYED" as an in-flight message
31956               *
31957               * ******************************************************************************
31958               
31959               ou3_:
31960 CE5A 020D  20        li   ra,>6f*256                 ; LDA #111          ; Set A to recursive token 111 ("FUEL SCOOPS")
     CE5C 6F00     
31961               
31962               * ******************************************************************************
31963               *
31964               * Name: MESS
31965               * Type: Subroutine
31966               * Category: Flight
31967               * Summary: Display an in-flight message
31968               *
31969               * ------------------------------------------------------------------------------
31970               *
31971               * Display an in-flight message in capitals at the bottom of the space view,
31972               * erasing any existing in-flight message first.
31973               *
31974               * ------------------------------------------------------------------------------
31975               *
31976               * Arguments:
31977               *
31978               * A                   The text token to be printed
31979               *
31980               * ******************************************************************************
31981               
31982               MESS:
31983 CE5E 020E  20        li   rx,>00*256                 ; LDX #0            ; Set QQ17 = 0 to switch to ALL CAPS
     CE60 0000     
31984 CE62 D80E  30        movb rx,@QQ17                   ; STX QQ17
     CE64 007E     
31985               
31986 CE66 020F  20        li   ry,>09*256                 ; LDY #9            ; Move the text cursor to column 9, row 22, at the
     CE68 0900     
31987 CE6A D80F  30        movb ry,@XC                     ; STY XC            ; bottom middle of the screen, and set Y = 22
     CE6C 002C     
31988 CE6E 020F  20        li   ry,>16*256                 ; LDY #22
     CE70 1600     
31989 CE72 D80F  30        movb ry,@YC                     ; STY YC
     CE74 002D     
31990               
31991 CE76 93A0  30        cb   @DLY,rx                    ; CPX DLY           ; If the message delay in DLY is not zero, jump up to
     CE78 0D64     
31992 CE7A 16DF  14        jne  me1_                       ; BNE me1           ; me1 to erase the current message first (whose token
31993                                                                          ; number will be in MCH)
31994               
31995 CE7C D80F  30        movb ry,@DLY                    ; STY DLY           ; Set the message delay in DLY to 22
     CE7E 0D64     
31996               
31997 CE80 D80D  30        movb ra,@MCH                    ; STA MCH           ; Set MCH to the token we are about to display
     CE82 0F10     
31998               
31999                                                                          ; Fall through into mes9 to print the token in A
32000               
32001               * ******************************************************************************
32002               *
32003               * Name: mes9
32004               * Type: Subroutine
32005               * Category: Flight
32006               * Summary: Print a text token, possibly followed by " DESTROYED"
32007               *
32008               * ------------------------------------------------------------------------------
32009               *
32010               * Print a text token, followed by " DESTROYED" if the destruction flag is set
32011               * (for when a piece of equipment is destroyed).
32012               *
32013               * ******************************************************************************
32014               
32015               mes9_:
32016 CE84 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Call TT27 to print the text token in A
     CE86 A6E8     
32017 CE88 06A0  32        bl   @jsr                       ;
     CE8A FE1E     
32018               
32019                      .lsr @de_                       ; LSR de            ; If bit 0 of variable de is clear, return from the
     **** ****     > LSR
0001 CE8C D020  30        movb @DE_,rtmp
     CE8E 0D65     
0002 CE90 0910  18        srl  rtmp,1
0003 CE92 D800  30        movb rtmp,@DE_
     CE94 0D65     
                   < elite.a99
32020 CE96 17CF  14        jnc  out_                       ; BCC out           ; subroutine (as out contains an RTS)
32021               
32022 CE98 020D  20        li   ra,>fd*256                 ; LDA #253          ; Print recursive token 93 (" DESTROYED") and return
     CE9A FD00     
32023 CE9C 0460  28        b    @TT27                      ; JMP TT27          ; from the subroutine using a tail call
     CE9E A6E8     
32024               
32025               * ******************************************************************************
32026               *
32027               * Name: OUCH
32028               * Type: Subroutine
32029               * Category: Flight
32030               * Summary: Potentially lose cargo or equipment following damage
32031               *
32032               * ------------------------------------------------------------------------------
32033               *
32034               * Our shields are dead and we are taking damage, so there is a small chance of
32035               * losing cargo or equipment.
32036               *
32037               * ******************************************************************************
32038               
32039               OUCH:
32040 CEA0 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     CEA2 C07C     
32041 CEA4 06A0  32        bl   @jsr                       ;
     CEA6 FE1E     
32042               
32043 CEA8 11C6  14        jlt  out_                       ; BMI out           ; If A < 0 (50% chance), return from the subroutine
32044                                                                          ; (as out contains an RTS)
32045               
32046 CEAA 028E  22        ci   rx,>16*256                 ; CPX #22           ; If X >= 22 (91% chance), return from the subroutine
     CEAC 1600     
32047 CEAE 18C3  14        joc  out_                       ; BCS out           ; (as out contains an RTS)
32048               
32049 CEB0 D36E  34        movb @QQ20(rx),ra               ; LDA QQ20,X        ; If we do not have any of item QQ20+X, return from the
     CEB2 0317     
32050 CEB4 13C0  14        jeq  out_                       ; BEQ out           ; subroutine (as out contains an RTS). X is in the range
32051                                                                          ; 0-21, so this not only checks for cargo, but also for
32052                                                                          ; E.C.M., fuel scoops, energy bomb, energy unit and
32053                                                                          ; docking computer, all of which can be destroyed
32054               
32055 CEB6 D360  30        movb @DLY,ra                    ; LDA DLY           ; If there is already an in-flight message on-screen,
     CEB8 0D64     
32056 CEBA 16BD  14        jne  out_                       ; BNE out           ; return from the subroutine (as out contains an RTS)
32057               
32058 CEBC 020F  20        li   ry,>03*256                 ; LDY #3            ; Set bit 1 of de, the equipment destruction flag, so
     CEBE 0300     
32059 CEC0 D80F  30        movb ry,@de_                    ; STY de            ; that when we call MESS below, " DESTROYED" is appended
     CEC2 0D65     
32060                                                                          ; to the in-flight message
32061               
32062 CEC4 DB8D  38        movb ra,@QQ20(rx)               ; STA QQ20,X        ; A is 0 (as we didn't branch with the BNE above), so
     CEC6 0317     
32063                                                                          ; this sets QQ20+X to 0, which destroys any cargo or
32064                                                                          ; equipment we have of that type
32065               
32066 CEC8 028E  22        ci   rx,>11*256                 ; CPX #17           ; If X >= 17 then we just lost a piece of equipment, so
     CECA 1100     
32067 CECC 1806  14        joc  ou1_                       ; BCS ou1           ; jump to ou1 to print the relevant message
32068               
32069 CECE D34E  18        movb rx,ra                      ; TXA               ; Print recursive token 48 + A as an in-flight token,
32070                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 CED0 1701  14        jnc  !
0002 CED2 B347  18        ab   rone,ra
0003               !:
0004 CED4 022D  22        ai   ra,(>D0*256)
     CED6 D000     
                   < elite.a99
32071 CED8 16C2  14        jne  MESS                       ; BNE MESS          ; ITEMS") as the C flag is clear, so this prints the
32072                                                                          ; destroyed item's name, followed by " DESTROYED" (as we
32073                                                                          ; set bit 1 of the de flag above), and returns from the
32074                                                                          ; subroutine using a tail call
32075               
32076               ou1_:
32077 CEDA 13BC  14        jeq  ou2_                       ; BEQ ou2           ; If X = 17, jump to ou2 to print "E.C.M.SYSTEM
32078                                                                          ; DESTROYED" and return from the subroutine using a tail
32079                                                                          ; call
32080               
32081 CEDC 028E  22        ci   rx,>12*256                 ; CPX #18           ; If X = 18, jump to ou3 to print "FUEL SCOOPS
     CEDE 1200     
32082 CEE0 13BC  14        jeq  ou3_                       ; BEQ ou3           ; DESTROYED" and return from the subroutine using a tail
32083                                                                          ; call
32084               
32085 CEE2 D34E  18        movb rx,ra                      ; TXA               ; Otherwise X is in the range 19 to 21 and the C flag is
32086                      .adi ((113-20)*256)             ; ADC #113-20       ; set (as we got here via a BCS to ou1), so we set A as
     **** ****     > ADI
0001 CEE4 1701  14        jnc  !
0002 CEE6 B347  18        ab   rone,ra
0003               !:
0004 CEE8 022D  22        ai   ra,((113-20)*256)
     CEEA 5D00     
                   < elite.a99
32087                                                                          ; follows:
32088                                                                          ;
32089                                                                          ; A = 113 - 20 + X + C
32090                                                                          ; = 113 - 19 + X
32091                                                                          ; = 113 to 115
32092               
32093 CEEC 16B8  14        jne  MESS                       ; BNE MESS          ; Print recursive token A ("ENERGY BOMB", "ENERGY UNIT"
32094                                                                          ; or "DOCKING COMPUTERS") as an in-flight message,
32095                                                                          ; followed by " DESTROYED", and return from the
32096                                                                          ; subroutine using a tail call
32097               
32098               * ******************************************************************************
32099               *
32100               * Name: QQ16
32101               * Type: Variable
32102               * Category: Text
32103               * Summary: The two-letter token lookup table
32104               * Deep dive: Printing text tokens
32105               *
32106               * ------------------------------------------------------------------------------
32107               *
32108               * Two-letter token lookup table for tokens 128-159. See the deep dive on
32109               * "Printing text tokens" for details of how the two-letter token system works.
32110               *
32111               * ******************************************************************************
32112               
32113               QQ16:
32114 CEEE 414C            text 'AL'                                           ; Token 128
32115 CEF0 4C45            text 'LE'                                           ; Token 129
32116 CEF2 5845            text 'XE'                                           ; Token 130
32117 CEF4 4745            text 'GE'                                           ; Token 131
32118 CEF6 5A41            text 'ZA'                                           ; Token 132
32119 CEF8 4345            text 'CE'                                           ; Token 133
32120 CEFA 4249            text 'BI'                                           ; Token 134
32121 CEFC 534F            text 'SO'                                           ; Token 135
32122 CEFE 5553            text 'US'                                           ; Token 136
32123 CF00 4553            text 'ES'                                           ; Token 137
32124 CF02 4152            text 'AR'                                           ; Token 138
32125 CF04 4D41            text 'MA'                                           ; Token 139
32126 CF06 494E            text 'IN'                                           ; Token 140
32127 CF08 4449            text 'DI'                                           ; Token 141
32128 CF0A 5245            text 'RE'                                           ; Token 142
32129 CF0C 413F            text 'A?'                                           ; Token 143
32130 CF0E 4552            text 'ER'                                           ; Token 144
32131 CF10 4154            text 'AT'                                           ; Token 145
32132 CF12 454E            text 'EN'                                           ; Token 146
32133 CF14 4245            text 'BE'                                           ; Token 147
32134 CF16 5241            text 'RA'                                           ; Token 148
32135 CF18 4C41            text 'LA'                                           ; Token 149
32136 CF1A 5645            text 'VE'                                           ; Token 150
32137 CF1C 5449            text 'TI'                                           ; Token 151
32138 CF1E 4544            text 'ED'                                           ; Token 152
32139 CF20 4F52            text 'OR'                                           ; Token 153
32140 CF22 5155            text 'QU'                                           ; Token 154
32141 CF24 414E            text 'AN'                                           ; Token 155
32142 CF26 5445            text 'TE'                                           ; Token 156
32143 CF28 4953            text 'IS'                                           ; Token 157
32144 CF2A 5249            text 'RI'                                           ; Token 158
32145 CF2C 4F4E            text 'ON'                                           ; Token 159
32146               
32147               * ******************************************************************************
32148               *
32149               * Name: ITEM
32150               * Type: Macro
32151               * Category: Market
32152               * Summary: Macro definition for the market prices table
32153               * Deep dive: Market item prices and availability
32154               *
32155               * ------------------------------------------------------------------------------
32156               *
32157               * The following macro is used to build the market prices table:
32158               *
32159               * ITEM price, factor, units, quantity, mask
32160               *
32161               * It inserts an item into the market prices table at QQ23. See the deep dive on
32162               * "Market item prices and availability" for more information on how the market
32163               * system works.
32164               *
32165               * ------------------------------------------------------------------------------
32166               *
32167               * Arguments:
32168               *
32169               * price               Base price
32170               *
32171               * factor              Economic factor
32172               *
32173               * units               Units: "t", "g" or "k"
32174               *
32175               * quantity            Base quantity
32176               *
32177               * mask                Fluctuations mask
32178               *
32179               * ******************************************************************************
32180               
32181                      ; MACRO ITEM price, factor, units, quantity, mask
32182               
32183                      ; IF factor < 0                 ;
32184                      ; s = 1 << 7                    ;
32185                      ; ELSE                          ;
32186                      ; s = 0                         ;
32187                      ; ENDIF                         ;
32188               
32189                      ; IF units = 't'                ;
32190                      ; u = 0                         ;
32191                      ; ELIF units = 'k'              ;
32192                      ; u = 1 << 5                    ;
32193                      ; ELSE                          ;
32194                      ; u = 1 << 6                    ;
32195                      ; ENDIF                         ;
32196               
32197                      ; e = ABS(factor)               ;
32198               
32199                      ; EQUB price                    ;
32200                      ; EQUB s + u + e                ;
32201                      ; EQUB quantity                 ;
32202                      ; EQUB mask                     ;
32203               
32204                      ; ENDMACRO
32205               
32206               * ******************************************************************************
32207               *
32208               * Name: QQ23
32209               * Type: Variable
32210               * Category: Market
32211               * Summary: Market prices table
32212               *
32213               * ------------------------------------------------------------------------------
32214               *
32215               * Each item has four bytes of data, like this:
32216               *
32217               * Byte #0 = Base price
32218               * Byte #1 = Economic factor in bits 0-4, with the sign in bit 7
32219               * Unit in bits 5-6
32220               * Byte #2 = Base quantity
32221               * Byte #3 = Mask to control price fluctuations
32222               *
32223               * To make it easier for humans to follow, we've defined a macro called ITEM
32224               * that takes the following arguments and builds the four bytes for us:
32225               *
32226               * ITEM base price, economic factor, units, base quantity, mask
32227               *
32228               * So for food, we have the following:
32229               *
32230               * * Base price = 19
32231               * * Economic factor = -2
32232               * * Unit = tonnes
32233               * * Base quantity = 6
32234               * * Mask = %00000001
32235               *
32236               * ******************************************************************************
32237               
32238               QQ23:
32239 CF2E 1382            byte >13, >82, >06, >01                             ; 0 = Food
     CF30 0601     
32240 CF32 1481            byte >14, >81, >0a, >03                             ; 1 = Textiles
     CF34 0A03     
32241 CF36 4183            byte >41, >83, >02, >07                             ; 2 = Radioactives
     CF38 0207     
32242 CF3A 2885            byte >28, >85, >e2, >1f                             ; 3 = Slaves
     CF3C E21F     
32243 CF3E 5385            byte >53, >85, >fb, >0f                             ; 4 = Liquor/Wines
     CF40 FB0F     
32244 CF42 C408            byte >c4, >08, >36, >03                             ; 5 = Luxuries
     CF44 3603     
32245 CF46 EB1D            byte >eb, >1d, >08, >78                             ; 6 = Narcotics
     CF48 0878     
32246 CF4A 9A0E            byte >9a, >0e, >38, >03                             ; 7 = Computers
     CF4C 3803     
32247 CF4E 7506            byte >75, >06, >28, >07                             ; 8 = Machinery
     CF50 2807     
32248 CF52 4E01            byte >4e, >01, >11, >1f                             ; 9 = Alloys
     CF54 111F     
32249 CF56 7C0D            byte >7c, >0d, >1d, >07                             ; 10 = Firearms
     CF58 1D07     
32250 CF5A B089            byte >b0, >89, >dc, >3f                             ; 11 = Furs
     CF5C DC3F     
32251 CF5E 2081            byte >20, >81, >35, >03                             ; 12 = Minerals
     CF60 3503     
32252 CF62 61A1            byte >61, >a1, >42, >07                             ; 13 = Gold
     CF64 4207     
32253 CF66 ABA2            byte >ab, >a2, >37, >1f                             ; 14 = Platinum
     CF68 371F     
32254 CF6A 2DC1            byte >2d, >c1, >fa, >0f                             ; 15 = Gem-Stones
     CF6C FA0F     
32255 CF6E 350F            byte >35, >0f, >c0, >07                             ; 16 = Alien items
     CF70 C007     
32256               
32257               * ******************************************************************************
32258               *
32259               * Name: TIDY
32260               * Type: Subroutine
32261               * Category: Maths (Geometry)
32262               * Summary: Orthonormalise the orientation vectors for a ship
32263               * Deep dive: Tidying orthonormal vectors
32264               * Orientation vectors
32265               *
32266               * ------------------------------------------------------------------------------
32267               *
32268               * This routine orthonormalises the orientation vectors for a ship. This means
32269               * making the three orientation vectors orthogonal (perpendicular to each other),
32270               * and normal (so each of the vectors has length 1).
32271               *
32272               * We do this because we use the small angle approximation to rotate these
32273               * vectors in space. It is not completely accurate, so the three vectors tend
32274               * to get stretched over time, so periodically we tidy the vectors with this
32275               * routine to ensure they remain as orthonormal as possible.
32276               *
32277               * ******************************************************************************
32278               
32279               TI2:
32280                                                                          ; Called from below with A = 0, X = 0, Y = 4 when
32281                                                                          ; nosev_x and nosev_y are small, so we assume that
32282                                                                          ; nosev_z is big
32283 CF72 D34F  18        movb ry,ra                      ; TYA               ; A = Y = 4
32284 CF74 020F  20        li   ry,>02*256                 ; LDY #2
     CF76 0200     
32285 CF78 0200  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 2, A = 4, to set roofv_z =
     CF7A D132     
32286 CF7C 06A0  32        bl   @jsr                       ;
     CF7E FE1E     
32287 CF80 D80D  30        movb ra,@INWK+20                ; STA INWK+20       ; -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
     CF82 0067     
32288               
32289 CF84 0460  28        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     CF86 D002     
32290               
32291               TI1:
32292                                                                          ; Called from below with A = 0, Y = 4 when nosev_x is
32293                                                                          ; small
32294 CF88 D38D  18        movb ra,rx                      ; TAX               ; Set X = A = 0
32295               
32296 CF8A D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = nosev_y, and if the top two magnitude bits
     CF8C 0032     
32297 CF8E 024D  22        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI2 with A = 0, X = 0, Y = 4
     CF90 6000     
32298 CF92 13EF  14        jeq  TI2                        ; BEQ TI2
32299               
32300 CF94 020D  20        li   ra,>02*256                 ; LDA #2            ; Otherwise nosev_y is big, so set up the index values
     CF96 0200     
32301                                                                          ; to pass to TIS3
32302               
32303 CF98 0200  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 4, A = 2, to set roofv_y =
     CF9A D132     
32304 CF9C 06A0  32        bl   @jsr                       ;
     CF9E FE1E     
32305 CFA0 D80D  30        movb ra,@INWK+18                ; STA INWK+18       ; -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
     CFA2 0065     
32306               
32307 CFA4 0460  28        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     CFA6 D002     
32308               
32309               TIDY:
32310 CFA8 D360  30        movb @INWK+10,ra                ; LDA INWK+10       ; Set (XX15, XX15+1, XX15+2) = nosev
     CFAA 005D     
32311 CFAC D80D  30        movb ra,@XX15                   ; STA XX15
     CFAE 0031     
32312 CFB0 D360  30        movb @INWK+12,ra                ; LDA INWK+12
     CFB2 005F     
32313 CFB4 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     CFB6 0032     
32314 CFB8 D360  30        movb @INWK+14,ra                ; LDA INWK+14
     CFBA 0061     
32315 CFBC D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     CFBE 0033     
32316               
32317 CFC0 0200  20        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. nosev
     CFC2 CA40     
32318 CFC4 06A0  32        bl   @jsr                       ;
     CFC6 FE1E     
32319               
32320 CFC8 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set nosev = (XX15, XX15+1, XX15+2)
     CFCA 0031     
32321 CFCC D80D  30        movb ra,@INWK+10                ; STA INWK+10
     CFCE 005D     
32322 CFD0 D360  30        movb @XX15+1,ra                 ; LDA XX15+1
     CFD2 0032     
32323 CFD4 D80D  30        movb ra,@INWK+12                ; STA INWK+12
     CFD6 005F     
32324 CFD8 D360  30        movb @XX15+2,ra                 ; LDA XX15+2
     CFDA 0033     
32325 CFDC D80D  30        movb ra,@INWK+14                ; STA INWK+14
     CFDE 0061     
32326               
32327 CFE0 020F  20        li   ry,>04*256                 ; LDY #4            ; Set Y = 4
     CFE2 0400     
32328               
32329 CFE4 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = nosev_x, and if the top two magnitude bits
     CFE6 0031     
32330 CFE8 024D  22        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI1 with A = 0, Y = 4
     CFEA 6000     
32331 CFEC 13CD  14        jeq  TI1                        ; BEQ TI1
32332               
32333 CFEE 020E  20        li   rx,>02*256                 ; LDX #2            ; Otherwise nosev_x is big, so set up the index values
     CFF0 0200     
32334 CFF2 020D  20        li   ra,>00*256                 ; LDA #0            ; to pass to TIS3
     CFF4 0000     
32335               
32336 CFF6 0200  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 2, Y = 4, A = 0, to set roofv_x =
     CFF8 D132     
32337 CFFA 06A0  32        bl   @jsr                       ;
     CFFC FE1E     
32338 CFFE D80D  30        movb ra,@INWK+16                ; STA INWK+16       ; -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
     D000 0063     
32339               
32340               TI3:
32341 D002 D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set (XX15, XX15+1, XX15+2) = roofv
     D004 0063     
32342 D006 D80D  30        movb ra,@XX15                   ; STA XX15
     D008 0031     
32343 D00A D360  30        movb @INWK+18,ra                ; LDA INWK+18
     D00C 0065     
32344 D00E D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D010 0032     
32345 D012 D360  30        movb @INWK+20,ra                ; LDA INWK+20
     D014 0067     
32346 D016 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     D018 0033     
32347               
32348 D01A 0200  20        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. roofv
     D01C CA40     
32349 D01E 06A0  32        bl   @jsr                       ;
     D020 FE1E     
32350               
32351 D022 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set roofv = (XX15, XX15+1, XX15+2)
     D024 0031     
32352 D026 D80D  30        movb ra,@INWK+16                ; STA INWK+16
     D028 0063     
32353 D02A D360  30        movb @XX15+1,ra                 ; LDA XX15+1
     D02C 0032     
32354 D02E D80D  30        movb ra,@INWK+18                ; STA INWK+18
     D030 0065     
32355 D032 D360  30        movb @XX15+2,ra                 ; LDA XX15+2
     D034 0033     
32356 D036 D80D  30        movb ra,@INWK+20                ; STA INWK+20
     D038 0067     
32357               
32358 D03A D360  30        movb @INWK+12,ra                ; LDA INWK+12       ; Set Q = nosev_y
     D03C 005F     
32359 D03E D80D  30        movb ra,@Q                      ; STA Q
     D040 0090     
32360               
32361 D042 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     D044 0067     
32362               
32363 D046 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_y * roofv_z
     D048 445E     
32364 D04A 06A0  32        bl   @jsr                       ;
     D04C FE1E     
32365               
32366 D04E D3A0  30        movb @INWK+14,rx                ; LDX INWK+14       ; Set X = nosev_z
     D050 0061     
32367               
32368 D052 D360  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     D054 0065     
32369               
32370 D056 0200  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D058 4550     
32371 D05A 06A0  32        bl   @jsr                       ;
     D05C FE1E     
32372                                                                          ; = (-nosev_z * roofv_y + nosev_y * roofv_z) / 96
32373                                                                          ;
32374                                                                          ; This also sets Q = nosev_z
32375               
32376                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_x = -A
     **** ****     > EOI
0001 D05E 0200  20        li   rtmp,(>80*256)
     D060 8000     
0002 D062 2B40  18        xor  rtmp,ra
                   < elite.a99
32377 D064 D80D  30        movb ra,@INWK+22                ; STA INWK+22       ; = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
     D066 0069     
32378               
32379 D068 D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     D06A 0063     
32380               
32381 D06C 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_z * roofv_x
     D06E 445E     
32382 D070 06A0  32        bl   @jsr                       ;
     D072 FE1E     
32383               
32384 D074 D3A0  30        movb @INWK+10,rx                ; LDX INWK+10       ; Set X = nosev_x
     D076 005D     
32385               
32386 D078 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     D07A 0067     
32387               
32388 D07C 0200  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D07E 4550     
32389 D080 06A0  32        bl   @jsr                       ;
     D082 FE1E     
32390                                                                          ; = (-nosev_x * roofv_z + nosev_z * roofv_x) / 96
32391                                                                          ;
32392                                                                          ; This also sets Q = nosev_x
32393               
32394                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_y = -A
     **** ****     > EOI
0001 D084 0200  20        li   rtmp,(>80*256)
     D086 8000     
0002 D088 2B40  18        xor  rtmp,ra
                   < elite.a99
32395 D08A D80D  30        movb ra,@INWK+24                ; STA INWK+24       ; = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
     D08C 006B     
32396               
32397 D08E D360  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     D090 0065     
32398               
32399 D092 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_x * roofv_y
     D094 445E     
32400 D096 06A0  32        bl   @jsr                       ;
     D098 FE1E     
32401               
32402 D09A D3A0  30        movb @INWK+12,rx                ; LDX INWK+12       ; Set X = nosev_y
     D09C 005F     
32403               
32404 D09E D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     D0A0 0063     
32405               
32406 D0A2 0200  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D0A4 4550     
32407 D0A6 06A0  32        bl   @jsr                       ;
     D0A8 FE1E     
32408                                                                          ; = (-nosev_y * roofv_x + nosev_x * roofv_y) / 96
32409               
32410                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_z = -A
     **** ****     > EOI
0001 D0AA 0200  20        li   rtmp,(>80*256)
     D0AC 8000     
0002 D0AE 2B40  18        xor  rtmp,ra
                   < elite.a99
32411 D0B0 D80D  30        movb ra,@INWK+26                ; STA INWK+26       ; = (nosev_y * roofv_x - nosev_x * roofv_y) / 96
     D0B2 006D     
32412               
32413 D0B4 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can clear the low bytes of the
     D0B6 0000     
32414                                                                          ; orientation vectors
32415               
32416 D0B8 020E  20        li   rx,>0e*256                 ; LDX #14           ; We want to clear the low bytes, so start from sidev_y
     D0BA 0E00     
32417                                                                          ; at byte #9+14 (we clear all except sidev_z_lo, though
32418                                                                          ; I suspect this is in error and that X should be 16)
32419               
32420               TIL1:
32421 D0BC DB8D  38        movb ra,@INWK+9(rx)             ; STA INWK+9,X      ; Set the low byte in byte #9+X to zero
     D0BE 005C     
32422               
32423 D0C0 7387  18        sb   rone,rx                    ; DEX               ; Set X = X - 2 to jump down to the next low byte
32424 D0C2 7387  18        sb   rone,rx                    ; DEX
32425               
32426 D0C4 15FB  14        jgt  TIL1                       ; BPL TIL1          ; Loop back until we have zeroed all the low bytes
32427               
32428 D0C6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D0C8 FE2A     
32429               
32430               * ******************************************************************************
32431               *
32432               * Name: TIS2
32433               * Type: Subroutine
32434               * Category: Maths (Arithmetic)
32435               * Summary: Calculate A = A / Q
32436               * Deep dive: Shift-and-subtract division
32437               *
32438               * ------------------------------------------------------------------------------
32439               *
32440               * Calculate the following division, where A is a sign-magnitude number and Q is
32441               * a positive integer:
32442               *
32443               * A = A / Q
32444               *
32445               * The value of A is returned as a sign-magnitude number with 96 representing 1,
32446               * and the maximum value returned is 1 (i.e. 96). This routine is used when
32447               * normalising vectors, where we represent fractions using integers, so this
32448               * gives us an approximation to two decimal places.
32449               *
32450               * ******************************************************************************
32451               
32452               TIS2:
32453 D0CA D3CD  18        movb ra,ry                      ; TAY               ; Store the argument A in Y
32454               
32455 D0CC 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Strip the sign bit from the argument, so A = |A|
     D0CE 7F00     
32456               
32457 D0D0 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q then jump to TI4 to return a 1 with the
     D0D2 0090     
32458 D0D4 1827  14        joc  TI4                        ; BCS TI4           ; correct sign
32459               
32460 D0D6 020E  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set T to have bits 1-7 set, so we can rotate through 7
     D0D8 FE00     
32461 D0DA D80E  30        movb rx,@T                      ; STX T             ; loop iterations, getting a 1 each time, and then
     D0DC 00D1     
32462                                                                          ; getting a 0 on the 8th iteration... and we can also
32463                                                                          ; use T to catch our result bits into bit 0 each time
32464               
32465               TIL2:
32466                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 D0DE 024D  22        andi ra,>ff00
     D0E0 FF00     
0002 D0E2 0A1D  18        sla  ra,1
                   < elite.a99
32467               
32468 D0E4 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     D0E6 0090     
32469 D0E8 1704  14        jnc  B108                       ; BCC B108
32470               
32471                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D0EA 1801  14        joc  !
0002 D0EC 7347  18        sb   rone,ra
0003               !:
0004 D0EE 7360  30        sb   @Q,ra
     D0F0 0090     
                   < elite.a99
32472                                                                          ;
32473                                                                          ; Going into this subtraction we know the C flag is
32474                                                                          ; set as we passed through the BCC above, and we also
32475                                                                          ; know that A >= Q, so the C flag will still be set once
32476                                                                          ; we are done
32477               
32478               B108:
32479 D0F2 0204  20        li   rarg1,T                    ; ROL T             ; Rotate the counter in T to the left, and catch the
     D0F4 00D1     
32480 D0F6 06A0  32        bl   @rol                       ;
     D0F8 FE44     
32481                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32482                                                                          ; do the subtraction, or 1 if we did)
32483               
32484 D0FA 18F1  14        joc  TIL2                       ; BCS TIL2          ; If we still have set bits in T, loop back to TIL2 to
32485                                                                          ; do the next iteration of 7
32486               
32487                                                                          ; We've done the division and now have a result in the
32488                                                                          ; range 0-255 here, which we need to reduce to the range
32489                                                                          ; 0-96. We can do that by multiplying the result by 3/8,
32490                                                                          ; as 256 * 3/8 = 96
32491               
32492 D0FC D360  30        movb @T,ra                      ; LDA T             ; Set T = T / 4
     D0FE 00D1     
32493 D100 091D  18        srl  ra,1                       ; LSR A
32494 D102 091D  18        srl  ra,1                       ; LSR A
32495 D104 D80D  30        movb ra,@T                      ; STA T
     D106 00D1     
32496               
32497 D108 091D  18        srl  ra,1                       ; LSR A             ; Set T = T / 8 + T / 4
32498                      .adc @T,ra                      ; ADC T             ; = 3T / 8
     **** ****     > ADC
0001 D10A 1701  14        jnc  !
0002 D10C B347  18        ab   rone,ra
0003               !:
0004 D10E B360  30        ab   @T,ra
     D110 00D1     
                   < elite.a99
32499 D112 D80D  30        movb ra,@T                      ; STA T
     D114 00D1     
32500               
32501 D116 D34F  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
32502 D118 024D  22        andi ra,>80*256                 ; AND #%10000000
     D11A 8000     
32503               
32504 D11C F360  30        socb @T,ra                      ; ORA T             ; Apply the sign bit to T
     D11E 00D1     
32505               
32506 D120 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D122 FE2A     
32507               
32508               TI4:
32509 D124 D34F  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
32510 D126 024D  22        andi ra,>80*256                 ; AND #%10000000
     D128 8000     
32511               
32512 D12A 026D  22        ori  ra,>60*256                 ; ORA #96           ; Apply the sign bit to 96 (which represents 1)
     D12C 6000     
32513               
32514 D12E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D130 FE2A     
32515               
32516               * ******************************************************************************
32517               *
32518               * Name: TIS3
32519               * Type: Subroutine
32520               * Category: Maths (Arithmetic)
32521               * Summary: Calculate -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
32522               *
32523               * ------------------------------------------------------------------------------
32524               *
32525               * Calculate the following expression:
32526               *
32527               * A = -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
32528               *
32529               * where 1, 2 and 3 are x, y, or z, depending on the values of X, Y and A. This
32530               * routine is called with the following values:
32531               *
32532               * X = 0, Y = 2, A = 4 ->
32533               * A = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
32534               *
32535               * X = 0, Y = 4, A = 2 ->
32536               * A = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
32537               *
32538               * X = 2, Y = 4, A = 0 ->
32539               * A = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
32540               *
32541               * ------------------------------------------------------------------------------
32542               *
32543               * Arguments:
32544               *
32545               * X                   Index 1 (0 = x, 2 = y, 4 = z)
32546               *
32547               * Y                   Index 2 (0 = x, 2 = y, 4 = z)
32548               *
32549               * A                   Index 3 (0 = x, 2 = y, 4 = z)
32550               *
32551               * ******************************************************************************
32552               
32553               TIS3:
32554 D132 D80D  30        movb ra,@P+2                    ; STA P+2           ; Store P+2 in A for later
     D134 001D     
32555               
32556 D136 D36E  34        movb @INWK+10(rx),ra            ; LDA INWK+10,X     ; Set Q = nosev_x_hi (plus X)
     D138 005D     
32557 D13A D80D  30        movb ra,@Q                      ; STA Q
     D13C 0090     
32558               
32559 D13E D36E  34        movb @INWK+16(rx),ra            ; LDA INWK+16,X     ; Set A = roofv_x_hi (plus X)
     D140 0063     
32560               
32561 D142 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     D144 445E     
32562 D146 06A0  32        bl   @jsr                       ;
     D148 FE1E     
32563                                                                          ; = nosev_x_hi * roofv_x_hi
32564               
32565 D14A D3AF  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y     ; Set Q = nosev_x_hi (plus Y)
     D14C 005D     
32566 D14E D80E  30        movb rx,@Q                      ; STX Q
     D150 0090     
32567               
32568 D152 D36F  34        movb @INWK+16(ry),ra            ; LDA INWK+16,Y     ; Set A = roofv_x_hi (plus Y)
     D154 0063     
32569               
32570 D156 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     D158 44B2     
32571 D15A 06A0  32        bl   @jsr                       ;
     D15C FE1E     
32572                                                                          ; = (nosev_x,X * roofv_x,X) +
32573                                                                          ; (nosev_x,Y * roofv_x,Y)
32574               
32575 D15E D80E  30        movb rx,@P                      ; STX P             ; Store low byte of result in P, so result is now in
     D160 001B     
32576                                                                          ; (A P)
32577               
32578 D162 D3E0  30        movb @P+2,ry                    ; LDY P+2           ; Set Q = roofv_x_hi (plus argument A)
     D164 001D     
32579 D166 D3AF  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y
     D168 005D     
32580 D16A D80E  30        movb rx,@Q                      ; STX Q
     D16C 0090     
32581               
32582                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A
     **** ****     > EOI
0001 D16E 0200  20        li   rtmp,(>80*256)
     D170 8000     
0002 D172 2B40  18        xor  rtmp,ra
                   < elite.a99
32583               
32584                                                                          ; Fall through into DIVDT to do:
32585                                                                          ;
32586                                                                          ; (P+1 A) = (A P) / Q
32587                                                                          ;
32588                                                                          ; = -((nosev_x,X * roofv_x,X) +
32589                                                                          ; (nosev_x,Y * roofv_x,Y))
32590                                                                          ; / nosev_x,A
32591               
32592               * ******************************************************************************
32593               *
32594               * Name: DVIDT
32595               * Type: Subroutine
32596               * Category: Maths (Arithmetic)
32597               * Summary: Calculate (P+1 A) = (A P) / Q
32598               *
32599               * ------------------------------------------------------------------------------
32600               *
32601               * Calculate the following integer division between sign-magnitude numbers:
32602               *
32603               * (P+1 A) = (A P) / Q
32604               *
32605               * This uses the same shift-and-subtract algorithm as TIS2.
32606               *
32607               * ******************************************************************************
32608               
32609               DVIDT:
32610 D174 D80D  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = A, so P(1 0) = (A P)
     D176 001C     
32611               
32612                      .eor @Q                         ; EOR Q             ; Set T = the sign bit of A EOR Q, so it's 1 if A and Q
     **** ****     > EOR
0001 D178 D020  30        movb @Q,rtmp
     D17A 0090     
0002 D17C 2B40  18        xor  rtmp,ra
                   < elite.a99
32613 D17E 024D  22        andi ra,>80*256                 ; AND #%10000000    ; have different signs, i.e. it's the sign of the result
     D180 8000     
32614 D182 D80D  30        movb ra,@T                      ; STA T             ; of A / Q
     D184 00D1     
32615               
32616 D186 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a result
     D188 0000     
32617               
32618 D18A 020E  20        li   rx,>10*256                 ; LDX #16           ; Set a counter in X to count the 16 bits in P(1 0)
     D18C 1000     
32619               
32620                      .asl @P                         ; ASL P             ; Shift P(1 0) left
     **** ****     > ASL
0001 D18E D020  30        movb @P,rtmp
     D190 001B     
0002 D192 0240  22        andi rtmp,>ff00
     D194 FF00     
0003 D196 0A10  18        sla  rtmp,1
0004 D198 D800  30        movb rtmp,@P
     D19A 001B     
                   < elite.a99
32621 D19C 0204  20        li   rarg1,P+1                  ; ROL P+1
     D19E 001C     
32622 D1A0 06A0  32        bl   @rol                       ;
     D1A2 FE44     
32623               
32624                      .asl @Q                         ; ASL Q             ; Clear the sign bit of Q the C flag at the same time
     **** ****     > ASL
0001 D1A4 D020  30        movb @Q,rtmp
     D1A6 0090     
0002 D1A8 0240  22        andi rtmp,>ff00
     D1AA FF00     
0003 D1AC 0A10  18        sla  rtmp,1
0004 D1AE D800  30        movb rtmp,@Q
     D1B0 0090     
                   < elite.a99
32625                      .lsr @Q                         ; LSR Q
     **** ****     > LSR
0001 D1B2 D020  30        movb @Q,rtmp
     D1B4 0090     
0002 D1B6 0910  18        srl  rtmp,1
0003 D1B8 D800  30        movb rtmp,@Q
     D1BA 0090     
                   < elite.a99
32626               
32627               DVL2:
32628 D1BC 06A0  32        bl   @rola                      ; ROL A             ; Shift A to the left
     D1BE FE34     
32629               
32630 D1C0 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     D1C2 0090     
32631 D1C4 1704  14        jnc  B109                       ; BCC B109
32632               
32633                      .sbc @Q,ra                      ; SBC Q             ; Set A = A - Q
     **** ****     > SBC
0001 D1C6 1801  14        joc  !
0002 D1C8 7347  18        sb   rone,ra
0003               !:
0004 D1CA 7360  30        sb   @Q,ra
     D1CC 0090     
                   < elite.a99
32634                                                                          ;
32635                                                                          ; Going into this subtraction we know the C flag is
32636                                                                          ; set as we passed through the BCC above, and we also
32637                                                                          ; know that A >= Q, so the C flag will still be set once
32638                                                                          ; we are done
32639               
32640               B109:
32641 D1CE 0204  20        li   rarg1,P                    ; ROL P             ; Rotate P(1 0) to the left, and catch the result bit
     D1D0 001B     
32642 D1D2 06A0  32        bl   @rol                       ;
     D1D4 FE44     
32643 D1D6 0204  20        li   rarg1,P+1                  ; ROL P+1           ; into the C flag (which will be a 0 if we didn't
     D1D8 001C     
32644 D1DA 06A0  32        bl   @rol                       ;
     D1DC FE44     
32645                                                                          ; do the subtraction, or 1 if we did)
32646               
32647 D1DE 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
32648               
32649 D1E0 16ED  14        jne  DVL2                       ; BNE DVL2          ; Loop back for the next bit until we have done all 16
32650                                                                          ; bits of P(1 0)
32651               
32652 D1E2 D360  30        movb @P,ra                      ; LDA P             ; Set A = P so the low byte is in the result in A
     D1E4 001B     
32653               
32654 D1E6 F360  30        socb @T,ra                      ; ORA T             ; Set A to the correct sign bit that we set in T above
     D1E8 00D1     
32655               
32656 D1EA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D1EC FE2A     
32657               
32658               * ******************************************************************************
32659               *
32660               * Save ELTF.bin
32661               *
32662               * ******************************************************************************
32663               
32664                      ; PRINT "ELITE F"
32665                      ; PRINT "Assembled at ", ~CODE_F%
32666                      ; PRINT "Ends at ", ~P%
32667                      ; PRINT "Code size is ", ~(P% - CODE_F%)
32668                      ; PRINT "Execute at ", ~LOAD%
32669                      ; PRINT "Reload at ", ~LOAD_F%
32670               
32671                      ; PRINT "S.ELTF ", ~CODE_F%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_F%
32672                      ; SAVE "3-assembled-output/ELTF.bin", CODE_F%, P%, LOAD%
32673               
32674               * ******************************************************************************
32675               *
32676               * ELITE G FILE
32677               *
32678               * Produces the binary file ELTG.bin that gets loaded by elite-bcfs.asm.
32679               *
32680               * ******************************************************************************
32681               
32682               CODE_G.:
32683                      equ $
32684               
32685               LOAD_G.:
32686                      equ LOAD. + $ - CODE.
32687               
32688               * ******************************************************************************
32689               *
32690               * Name: SHPPT
32691               * Type: Subroutine
32692               * Category: Drawing ships
32693               * Summary: Draw a distant ship as a point rather than a full wireframe
32694               *
32695               * ******************************************************************************
32696               
32697               SHPPT:
32698 D1EE 0200  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship's wireframe from the
     D1F0 D588     
32699 D1F2 06A0  32        bl   @jsr                       ;
     D1F4 FE1E     
32700                                                                          ; screen, if there is one
32701               
32702 D1F6 0200  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the ship onto the screen, returning:
     D1F8 B15A     
32703 D1FA 06A0  32        bl   @jsr                       ;
     D1FC FE1E     
32704                                                                          ;
32705                                                                          ; * K3(1 0) = the screen x-coordinate
32706                                                                          ; * K4(1 0) = the screen y-coordinate
32707                                                                          ; * A = K4+1
32708               
32709 D1FE F360  30        socb @K3+1,ra                   ; ORA K3+1          ; If either of the high bytes of the screen coordinates
     D200 00D3     
32710 D202 1625  14        jne  nono_                      ; BNE nono          ; are non-zero, jump to nono as the ship is off-screen
32711               
32712 D204 D360  30        movb @K4,ra                     ; LDA K4            ; Set A = the y-coordinate of the dot
     D206 00E0     
32713               
32714 D208 028D  22        ci   ra,(Y*2-2)*256             ; CMP #Y*2-2        ; If the y-coordinate is bigger than the y-coordinate of
     D20A BE00     
32715 D20C 1820  14        joc  nono_                      ; BCS nono          ; the bottom of the screen, jump to nono as the ship's
32716                                                                          ; dot is off the bottom of the space view
32717               
32718 D20E 020F  20        li   ry,>02*256                 ; LDY #2            ; Call Shpt with Y = 2 to set up bytes 1-4 in the ship
     D210 0200     
32719 D212 0200  20        li   rtmp,Shpt                  ; JSR Shpt          ; lines space, aborting the call to LL9 if the dot is
     D214 D262     
32720 D216 06A0  32        bl   @jsr                       ;
     D218 FE1E     
32721                                                                          ; off the side of the screen. This call sets up the
32722                                                                          ; first row of the dot (i.e. a four-pixel dash)
32723               
32724 D21A 020F  20        li   ry,>06*256                 ; LDY #6            ; Set Y to 6 for the next call to Shpt
     D21C 0600     
32725               
32726 D21E D360  30        movb @K4,ra                     ; LDA K4            ; Set A = y-coordinate of dot + 1 (so this is the second
     D220 00E0     
32727                      .adi (>01*256)                  ; ADC #1            ; row of the two-pixel-high dot)
     **** ****     > ADI
0001 D222 1701  14        jnc  !
0002 D224 B347  18        ab   rone,ra
0003               !:
0004 D226 022D  22        ai   ra,(>01*256)
     D228 0100     
                   < elite.a99
32728                                                                          ;
32729                                                                          ; The addition works as the Shpt routine clears the C
32730                                                                          ; flag
32731               
32732 D22A 0200  20        li   rtmp,Shpt                  ; JSR Shpt          ; Call Shpt with Y = 6 to set up bytes 5-8 in the ship
     D22C D262     
32733 D22E 06A0  32        bl   @jsr                       ;
     D230 FE1E     
32734                                                                          ; lines space, aborting the call to LL9 if the dot is
32735                                                                          ; off the side of the screen. This call sets up the
32736                                                                          ; second row of the dot (i.e. another four-pixel dash,
32737                                                                          ; on the row below the first one)
32738               
32739 D232 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of the ship's byte #31 to record that we
     D234 0800     
32740 D236 F360  30        socb @XX1+31,ra                 ; ORA XX1+31        ; have now drawn something on-screen for this ship
     D238 0072     
32741 D23A D80D  30        movb ra,@XX1+31                 ; STA XX1+31
     D23C 0072     
32742               
32743 D23E 020D  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8 so when we call LL18+2 next, byte #0 of the
     D240 0800     
32744                                                                          ; heap gets set to 8, for the 8 bytes we just stuck on
32745                                                                          ; the heap
32746               
32747 D242 0460  28        b    @LL81+2                    ; JMP LL81+2        ; Call LL81+2 to draw the ship's dot, returning from the
     D244 E248     
32748                                                                          ; subroutine using a tail call
32749               
32750                      .pla                            ; PLA               ; Pull the return address from the stack, so the RTS
     **** ****     > PLA
0001 D246 058A  14        inc  rsp
0002 D248 D35A  26        movb *rsp,ra
                   < elite.a99
32751                      .pla                            ; PLA               ; below actually returns from the subroutine that called
     **** ****     > PLA
0001 D24A 058A  14        inc  rsp
0002 D24C D35A  26        movb *rsp,ra
                   < elite.a99
32752                                                                          ; LL9 (as we called SHPPT from LL9 with a JMP)
32753               
32754               nono_:
32755 D24E 020D  20        li   ra,>f7*256                 ; LDA #%11110111    ; Clear bit 3 of the ship's byte #31 to record that
     D250 F700     
32756                      .and @XX1+31                    ; AND XX1+31        ; nothing is being drawn on-screen for this ship
     **** ****     > AND
0001 D252 D020  30        movb @XX1+31,rtmp
     D254 0072     
0002 D256 0540  14        inv  rtmp
0003 D258 5340  18        szcb rtmp,ra
                   < elite.a99
32757 D25A D80D  30        movb ra,@XX1+31                 ; STA XX1+31
     D25C 0072     
32758               
32759 D25E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D260 FE2A     
32760               
32761               Shpt:
32762                                                                          ; This routine sets up four bytes in the ship line heap,
32763                                                                          ; from byte Y-1 to byte Y+2. If the ship's screen point
32764                                                                          ; turns out to be off-screen, then this routine aborts
32765                                                                          ; the entire call to LL9, exiting via nono. The four
32766                                                                          ; bytes define a horizontal 4-pixel dash, for either the
32767                                                                          ; top or the bottom of the ship's dot
32768                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in byte Y of the ship line heap (i.e. Y1)
     **** ****     > ST_IND_Y_IDX
0001 D262 D820  50        movb @XX19,@rtmplb
     D264 0074     
     D266 206D     
0002 D268 D020  30        movb @XX19+1,rtmp
     D26A 0075     
0003 D26C A00F  18        a    ry,rtmp
0004 D26E D40D  30        movb RA,*rtmp
                   < elite.a99
32769               
32770 D270 B3C7  18        ab   rone,ry                    ; INY               ; Store A in byte Y+2 of the ship line heap (i.e. Y2)
32771 D272 B3C7  18        ab   rone,ry                    ; INY
32772                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D274 D820  50        movb @XX19,@rtmplb
     D276 0074     
     D278 206D     
0002 D27A D020  30        movb @XX19+1,rtmp
     D27C 0075     
0003 D27E A00F  18        a    ry,rtmp
0004 D280 D40D  30        movb RA,*rtmp
                   < elite.a99
32773               
32774 D282 D360  30        movb @K3,ra                     ; LDA K3            ; Set A = screen x-coordinate of the ship dot
     D284 00D2     
32775               
32776 D286 73C7  18        sb   rone,ry                    ; DEY               ; Store A in byte Y+1 of the ship line heap (i.e. X2)
32777                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D288 D820  50        movb @XX19,@rtmplb
     D28A 0074     
     D28C 206D     
0002 D28E D020  30        movb @XX19+1,rtmp
     D290 0075     
0003 D292 A00F  18        a    ry,rtmp
0004 D294 D40D  30        movb RA,*rtmp
                   < elite.a99
32778               
32779                      .adi (>03*256)                  ; ADC #3            ; Set A = screen x-coordinate of the ship dot + 3
     **** ****     > ADI
0001 D296 1701  14        jnc  !
0002 D298 B347  18        ab   rone,ra
0003               !:
0004 D29A 022D  22        ai   ra,(>03*256)
     D29C 0300     
                   < elite.a99
32780               
32781 D29E 18D6  14        joc  nono_-2                    ; BCS nono-2        ; If the addition pushed the dot off the right side of
32782                                                                          ; the screen, jump to nono-2 to return from the parent
32783                                                                          ; subroutine early (i.e. LL9). This works because we
32784                                                                          ; called Shpt from above with a JSR, so nono-2 removes
32785                                                                          ; that return address from the stack, leaving the next
32786                                                                          ; return address exposed. LL9 called SHPPT with a JMP,
32787                                                                          ; so the next return address is the one that was put on
32788                                                                          ; the stack by the original call to LL9. So the RTS in
32789                                                                          ; nono will actually return us from the original call
32790                                                                          ; to LL9, thus aborting the entire drawing process
32791               
32792 D2A0 73C7  18        sb   rone,ry                    ; DEY               ; Store A in byte Y-1 of the ship line heap (i.e. X1)
32793 D2A2 73C7  18        sb   rone,ry                    ; DEY
32794                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D2A4 D820  50        movb @XX19,@rtmplb
     D2A6 0074     
     D2A8 206D     
0002 D2AA D020  30        movb @XX19+1,rtmp
     D2AC 0075     
0003 D2AE A00F  18        a    ry,rtmp
0004 D2B0 D40D  30        movb RA,*rtmp
                   < elite.a99
32795               
32796 D2B2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D2B4 FE2A     
32797               
32798               * ******************************************************************************
32799               *
32800               * Name: LL5
32801               * Type: Subroutine
32802               * Category: Maths (Arithmetic)
32803               * Summary: Calculate Q = SQRT(R Q)
32804               * Deep dive: Calculating square roots
32805               *
32806               * ------------------------------------------------------------------------------
32807               *
32808               * Calculate the following square root:
32809               *
32810               * Q = SQRT(R Q)
32811               *
32812               * ******************************************************************************
32813               
32814               LL5:
32815 D2B6 D3E0  30        movb @R,ry                      ; LDY R             ; Set (Y S) = (R Q)
     D2B8 0091     
32816 D2BA D360  30        movb @Q,ra                      ; LDA Q
     D2BC 0090     
32817 D2BE D80D  30        movb ra,@S                      ; STA S
     D2C0 0092     
32818               
32819                                                                          ; So now to calculate Q = SQRT(Y S)
32820               
32821 D2C2 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, to hold the remainder
     D2C4 0000     
32822               
32823 D2C6 D80E  30        movb rx,@Q                      ; STX Q             ; Set Q = 0, to hold the result
     D2C8 0090     
32824               
32825 D2CA 020D  20        li   ra,>08*256                 ; LDA #8            ; Set T = 8, to use as a loop counter
     D2CC 0800     
32826 D2CE D80D  30        movb ra,@T                      ; STA T
     D2D0 00D1     
32827               
32828               LL6:
32829 D2D2 93A0  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, jump to LL7
     D2D4 0090     
32830 D2D6 1710  14        jnc  LL7                        ; BCC LL7
32831               
32832 D2D8 1603  14        jne  LL8                        ; BNE LL8           ; If X > Q, jump to LL8
32833               
32834 D2DA 028F  22        ci   ry,>40*256                 ; CPY #64           ; If Y < 64, jump to LL7 with the C flag clear,
     D2DC 4000     
32835 D2DE 170C  14        jnc  LL7                        ; BCC LL7           ; otherwise fall through into LL8 with the C flag set
32836               
32837               LL8:
32838 D2E0 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y - 64
32839                      .sbi (>40*256)                  ; SBC #64           ;
     **** ****     > SBI
0001 D2E2 1801  14        joc  !
0002 D2E4 7347  18        sb   rone,ra
0003               !:
0004 D2E6 022D  22        ai   ra,-(>40*256)
     D2E8 C000     
                   < elite.a99
32840 D2EA D3CD  18        movb ra,ry                      ; TAY               ; This subtraction will work as we know C is set from
32841                                                                          ; the BCC above, and the result will not underflow as we
32842                                                                          ; already checked that Y >= 64, so the C flag is also
32843                                                                          ; set for the next subtraction
32844               
32845 D2EC D34E  18        movb rx,ra                      ; TXA               ; Set X = X - Q
32846                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 D2EE 1801  14        joc  !
0002 D2F0 7347  18        sb   rone,ra
0003               !:
0004 D2F2 7360  30        sb   @Q,ra
     D2F4 0090     
                   < elite.a99
32847 D2F6 D38D  18        movb ra,rx                      ; TAX
32848               
32849               LL7:
32850 D2F8 0204  20        li   rarg1,Q                    ; ROL Q             ; Shift the result in Q to the left, shifting the C flag
     D2FA 0090     
32851 D2FC 06A0  32        bl   @rol                       ;
     D2FE FE44     
32852                                                                          ; into bit 0 and bit 7 into the C flag
32853               
32854                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left, inserting
     **** ****     > ASL
0001 D300 D020  30        movb @S,rtmp
     D302 0092     
0002 D304 0240  22        andi rtmp,>ff00
     D306 FF00     
0003 D308 0A10  18        sla  rtmp,1
0004 D30A D800  30        movb rtmp,@S
     D30C 0092     
                   < elite.a99
32855 D30E D34F  18        movb ry,ra                      ; TYA               ; bit 7 from above into bit 0
32856 D310 06A0  32        bl   @rola                      ; ROL A
     D312 FE34     
32857 D314 D3CD  18        movb ra,ry                      ; TAY
32858               
32859 D316 D34E  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
32860 D318 06A0  32        bl   @rola                      ; ROL A
     D31A FE34     
32861 D31C D38D  18        movb ra,rx                      ; TAX
32862               
32863                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left
     **** ****     > ASL
0001 D31E D020  30        movb @S,rtmp
     D320 0092     
0002 D322 0240  22        andi rtmp,>ff00
     D324 FF00     
0003 D326 0A10  18        sla  rtmp,1
0004 D328 D800  30        movb rtmp,@S
     D32A 0092     
                   < elite.a99
32864 D32C D34F  18        movb ry,ra                      ; TYA
32865 D32E 06A0  32        bl   @rola                      ; ROL A
     D330 FE34     
32866 D332 D3CD  18        movb ra,ry                      ; TAY
32867               
32868 D334 D34E  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
32869 D336 06A0  32        bl   @rola                      ; ROL A
     D338 FE34     
32870 D33A D38D  18        movb ra,rx                      ; TAX
32871               
32872 D33C 7347  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
32873               
32874 D33E 16C9  14        jne  LL6                        ; BNE LL6           ; Loop back to LL6 until we have done 8 loops
32875               
32876 D340 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D342 FE2A     
32877               
32878               * ******************************************************************************
32879               *
32880               * Name: LL28
32881               * Type: Subroutine
32882               * Category: Maths (Arithmetic)
32883               * Summary: Calculate R = 256 * A / Q
32884               * Deep dive: Shift-and-subtract division
32885               *
32886               * ------------------------------------------------------------------------------
32887               *
32888               * Calculate the following, where A < Q:
32889               *
32890               * R = 256 * A / Q
32891               *
32892               * This is a sister routine to LL61, which does the division when A >= Q.
32893               *
32894               * If A >= Q then 255 is returned and the C flag is set to indicate an overflow
32895               * (the C flag is clear if the division was a success).
32896               *
32897               * The result is returned in one byte as the result of the division multiplied
32898               * by 256, so we can return fractional results using integers.
32899               *
32900               * This routine uses the same shift-and-subtract algorithm that's documented in
32901               * TIS2, but it leaves the fractional result in the integer range 0-255.
32902               *
32903               * ------------------------------------------------------------------------------
32904               *
32905               * Returns:
32906               *
32907               * C flag              Set if the answer is too big for one byte, clear if the
32908               * division was a success
32909               *
32910               * ------------------------------------------------------------------------------
32911               *
32912               * Other entry points:
32913               *
32914               * LL28+4              Skips the A >= Q check and always returns with C flag
32915               * cleared, so this can be called if we know the division
32916               * will work
32917               *
32918               * LL31                Skips the A >= Q check and does not set the R counter,
32919               * so this can be used for jumping straight into the
32920               * division loop if R is already set to 254 and we know the
32921               * division will work
32922               *
32923               * ******************************************************************************
32924               
32925               LL28:
32926 D344 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, then the answer will not fit in one byte,
     D346 0090     
32927 D348 1822  14        joc  LL2                        ; BCS LL2           ; so jump to LL2 to return 255
32928               
32929 D34A 020E  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set R to have bits 1-7 set, so we can rotate through 7
     D34C FE00     
32930 D34E D80E  30        movb rx,@R                      ; STX R             ; loop iterations, getting a 1 each time, and then
     D350 0091     
32931                                                                          ; getting a 0 on the 8th iteration... and we can also
32932                                                                          ; use R to catch our result bits into bit 0 each time
32933               
32934               LL31:
32935                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 D352 024D  22        andi ra,>ff00
     D354 FF00     
0002 D356 0A1D  18        sla  ra,1
                   < elite.a99
32936               
32937 D358 180E  14        joc  LL29                       ; BCS LL29          ; If bit 7 of A was set, then jump straight to the
32938                                                                          ; subtraction
32939               
32940 D35A 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     D35C 0090     
32941 D35E 1704  14        jnc  B110                       ; BCC B110
32942               
32943                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D360 1801  14        joc  !
0002 D362 7347  18        sb   rone,ra
0003               !:
0004 D364 7360  30        sb   @Q,ra
     D366 0090     
                   < elite.a99
32944               
32945               B110:
32946 D368 0204  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     D36A 0091     
32947 D36C 06A0  32        bl   @rol                       ;
     D36E FE44     
32948                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32949                                                                          ; do the subtraction, or 1 if we did)
32950               
32951 D370 18F0  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
32952                                                                          ; do the next iteration of 7
32953               
32954 D372 0460  28        b    @rts                       ; RTS               ; R left with remainder of division
     D374 FE2A     
32955               
32956               LL29:
32957                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D376 1801  14        joc  !
0002 D378 7347  18        sb   rone,ra
0003               !:
0004 D37A 7360  30        sb   @Q,ra
     D37C 0090     
                   < elite.a99
32958               
32959                      .sec                            ; SEC               ; Set the C flag to rotate into the result in R
     **** ****     > SEC
0001 D37E 0A18  18        sla  rmone,1
                   < elite.a99
32960               
32961 D380 0204  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     D382 0091     
32962 D384 06A0  32        bl   @rol                       ;
     D386 FE44     
32963                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
32964                                                                          ; do the subtraction, or 1 if we did)
32965               
32966 D388 18E4  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
32967                                                                          ; do the next iteration of 7
32968               
32969 D38A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine with R containing the
     D38C FE2A     
32970                                                                          ; remainder of the division
32971               
32972               LL2:
32973 D38E 020D  20        li   ra,>ff*256                 ; LDA #255          ; The division is very close to 1, so return the closest
     D390 FF00     
32974 D392 D80D  30        movb ra,@R                      ; STA R             ; possible answer to 256, i.e. R = 255
     D394 0091     
32975               
32976 D396 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D398 FE2A     
32977               
32978               * ******************************************************************************
32979               *
32980               * Name: LL38
32981               * Type: Subroutine
32982               * Category: Maths (Arithmetic)
32983               * Summary: Calculate (S A) = (S R) + (A Q)
32984               *
32985               * ------------------------------------------------------------------------------
32986               *
32987               * Calculate the following between sign-magnitude numbers:
32988               *
32989               * (S A) = (S R) + (A Q)
32990               *
32991               * where the sign bytes only contain the sign bits, not magnitudes.
32992               *
32993               * ------------------------------------------------------------------------------
32994               *
32995               * Returns:
32996               *
32997               * C flag              Set if the addition overflowed, clear otherwise
32998               *
32999               * ******************************************************************************
33000               
33001               LL38:
33002                      .eor @S                         ; EOR S             ; If the sign of A * S is negative, skip to LL35, as
     **** ****     > EOR
0001 D39A D020  30        movb @S,rtmp
     D39C 0092     
0002 D39E 2B40  18        xor  rtmp,ra
                   < elite.a99
33003 D3A0 1109  14        jlt  LL39                       ; BMI LL39          ; A and S have different signs so we need to subtract
33004               
33005 D3A2 D360  30        movb @Q,ra                      ; LDA Q             ; Otherwise set A = R + Q, which is the result we need,
     D3A4 0090     
33006                      .clc                            ; CLC               ; as S already contains the correct sign
     **** ****     > CLC
0001 D3A6 0A16  18        sla  rzero,1
                   < elite.a99
33007                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 D3A8 1701  14        jnc  !
0002 D3AA B347  18        ab   rone,ra
0003               !:
0004 D3AC B360  30        ab   @R,ra
     D3AE 0091     
                   < elite.a99
33008               
33009 D3B0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D3B2 FE2A     
33010               
33011               LL39:
33012 D3B4 D360  30        movb @R,ra                      ; LDA R             ; Set A = R - Q
     D3B6 0091     
33013                      .sec                            ; SEC
     **** ****     > SEC
0001 D3B8 0A18  18        sla  rmone,1
                   < elite.a99
33014                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 D3BA 1801  14        joc  !
0002 D3BC 7347  18        sb   rone,ra
0003               !:
0004 D3BE 7360  30        sb   @Q,ra
     D3C0 0090     
                   < elite.a99
33015               
33016 D3C2 1701  14        jnc  B111                       ; BCC B111          ; If the subtraction underflowed, skip the next two
33017                                                                          ; instructions so we can negate the result
33018               
33019                      .clc                            ; CLC               ; Otherwise the result is correct, and S contains the
     **** ****     > CLC
0001 D3C4 0A16  18        sla  rzero,1
                   < elite.a99
33020                                                                          ; correct sign of the result as R is the dominant side
33021                                                                          ; of the subtraction, so clear the C flag
33022               
33023               B111:
33024 D3C6 0460  28        b    @rts                       ; RTS               ; And return from the subroutine
     D3C8 FE2A     
33025               
33026                                                                          ; If we get here we need to negate both the result and
33027                                                                          ; the sign in S, as both are the wrong sign
33028               
33029                      .pha                            ; PHA               ; Store the result of the subtraction on the stack
     **** ****     > PHA
0001 D3CA D68D  30        movb ra,*rsp
0002 D3CC 060A  14        dec  rsp
                   < elite.a99
33030               
33031 D3CE D360  30        movb @S,ra                      ; LDA S             ; Flip the sign of S
     D3D0 0092     
33032                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 D3D2 0200  20        li   rtmp,(>80*256)
     D3D4 8000     
0002 D3D6 2B40  18        xor  rtmp,ra
                   < elite.a99
33033 D3D8 D80D  30        movb ra,@S                      ; STA S
     D3DA 0092     
33034               
33035                      .pla                            ; PLA               ; Restore the subtraction result into A
     **** ****     > PLA
0001 D3DC 058A  14        inc  rsp
0002 D3DE D35A  26        movb *rsp,ra
                   < elite.a99
33036               
33037                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A using two's complement, i.e.
     **** ****     > EOI
0001 D3E0 0200  20        li   rtmp,(>FF*256)
     D3E2 FF00     
0002 D3E4 2B40  18        xor  rtmp,ra
                   < elite.a99
33038                      .adi (>01*256)                  ; ADC #1            ; set A = ~A + 1
     **** ****     > ADI
0001 D3E6 1701  14        jnc  !
0002 D3E8 B347  18        ab   rone,ra
0003               !:
0004 D3EA 022D  22        ai   ra,(>01*256)
     D3EC 0100     
                   < elite.a99
33039               
33040 D3EE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D3F0 FE2A     
33041               
33042               * ******************************************************************************
33043               *
33044               * Name: LL51
33045               * Type: Subroutine
33046               * Category: Maths (Geometry)
33047               * Summary: Calculate the dot product of XX15 and XX16
33048               *
33049               * ------------------------------------------------------------------------------
33050               *
33051               * Calculate the following dot products:
33052               *
33053               * XX12(1 0) = XX15(5 0) . XX16(5 0)
33054               * XX12(3 2) = XX15(5 0) . XX16(11 6)
33055               * XX12(5 4) = XX15(5 0) . XX16(12 17)
33056               *
33057               * storing the results as sign-magnitude numbers in XX12 through XX12+5.
33058               *
33059               * When called from part 5 of LL9, XX12 contains the vector [x y z] to the ship
33060               * we're drawing, and XX16 contains the orientation vectors, so it returns:
33061               *
33062               * [ x ]   [ sidev_x ]         [ x ]   [ roofv_x ]         [ x ]   [ nosev_x ]
33063               * [ y ] . [ sidev_y ]         [ y ] . [ roofv_y ]         [ y ] . [ nosev_y ]
33064               * [ z ]   [ sidev_z ]         [ z ]   [ roofv_z ]         [ z ]   [ nosev_z ]
33065               *
33066               * When called from part 6 of LL9, XX12 contains the vector [x y z] of the vertex
33067               * we're analysing, and XX16 contains the transposed orientation vectors with
33068               * each of them containing the x, y and z elements of the original vectors, so it
33069               * ------------------------------------------------------------------------------
33070               *
33071               * Returns:
33072               *
33073               * [ x ]   [ sidev_x ]         [ x ]   [ sidev_y ]         [ x ]   [ sidev_z ]
33074               * [ y ] . [ roofv_x ]         [ y ] . [ roofv_y ]         [ y ] . [ roofv_z ]
33075               * [ z ]   [ nosev_x ]         [ z ]   [ nosev_y ]         [ z ]   [ nosev_z ]
33076               *
33077               * ------------------------------------------------------------------------------
33078               *
33079               * Arguments:
33080               *
33081               * XX15(1 0)           The ship (or vertex)'s x-coordinate as (x_sign x_lo)
33082               *
33083               * XX15(3 2)           The ship (or vertex)'s y-coordinate as (y_sign y_lo)
33084               *
33085               * XX15(5 4)           The ship (or vertex)'s z-coordinate as (z_sign z_lo)
33086               *
33087               * XX16 to XX16+5      The scaled sidev (or _x) vector, with:
33088               *
33089               * * x, y, z magnitudes in XX16, XX16+2, XX16+4
33090               *
33091               * * x, y, z signs in XX16+1, XX16+3, XX16+5
33092               *
33093               * XX16+6 to XX16+11   The scaled roofv (or _y) vector, with:
33094               *
33095               * * x, y, z magnitudes in XX16+6, XX16+8, XX16+10
33096               *
33097               * * x, y, z signs in XX16+7, XX16+9, XX16+11
33098               *
33099               * XX16+12 to XX16+17  The scaled nosev (or _z) vector, with:
33100               *
33101               * * x, y, z magnitudes in XX16+12, XX16+14, XX16+16
33102               *
33103               * * x, y, z signs in XX16+13, XX16+15, XX16+17
33104               *
33105               * ------------------------------------------------------------------------------
33106               *
33107               * Returns:
33108               *
33109               * XX12(1 0)           The dot product of [x y z] vector with the sidev (or _x)
33110               * vector, with the sign in XX12+1 and magnitude in XX12
33111               *
33112               * XX12(3 2)           The dot product of [x y z] vector with the roofv (or _y)
33113               * vector, with the sign in XX12+3 and magnitude in XX12+2
33114               *
33115               * XX12(5 4)           The dot product of [x y z] vector with the nosev (or _z)
33116               * vector, with the sign in XX12+5 and magnitude in XX12+4
33117               *
33118               * ******************************************************************************
33119               
33120               LL51:
33121 D3F2 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, which will contain the offset of the vector
     D3F4 0000     
33122                                                                          ; to use in the calculation, increasing by 6 for each
33123                                                                          ; new vector
33124               
33125 D3F6 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, which will contain the offset of the
     D3F8 0000     
33126                                                                          ; result bytes in XX12, increasing by 2 for each new
33127                                                                          ; result
33128               
33129               ll51_:
33130 D3FA D360  30        movb @XX15,ra                   ; LDA XX15          ; Set Q = x_lo
     D3FC 0031     
33131 D3FE D80D  30        movb ra,@Q                      ; STA Q
     D400 0090     
33132               
33133 D402 D36E  34        movb @XX16(rx),ra               ; LDA XX16,X        ; Set A = |sidev_x|
     D404 0009     
33134               
33135 D406 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     D408 4338     
33136 D40A 06A0  32        bl   @jsr                       ;
     D40C FE1E     
33137 D40E D80D  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo / 256
     D410 00D1     
33138               
33139 D412 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set S to the sign of x_sign * sidev_x
     D414 0032     
33140                      .eor @XX16+1(rx)                ; EOR XX16+1,X
     **** ****     > EOR
0001 D416 D02E  34        movb @XX16+1(RX),rtmp
     D418 000A     
0002 D41A 2B40  18        xor  rtmp,ra
                   < elite.a99
33141 D41C D80D  30        movb ra,@S                      ; STA S
     D41E 0092     
33142               
33143 D420 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Q = y_lo
     D422 0033     
33144 D424 D80D  30        movb ra,@Q                      ; STA Q
     D426 0090     
33145               
33146 D428 D36E  34        movb @XX16+2(rx),ra             ; LDA XX16+2,X      ; Set A = |sidev_y|
     D42A 000B     
33147               
33148 D42C 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     D42E 4338     
33149 D430 06A0  32        bl   @jsr                       ;
     D432 FE1E     
33150 D434 D80D  30        movb ra,@Q                      ; STA Q             ; = |sidev_y| * y_lo / 256
     D436 0090     
33151               
33152 D438 D360  30        movb @T,ra                      ; LDA T             ; Set R = T
     D43A 00D1     
33153 D43C D80D  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo / 256
     D43E 0091     
33154               
33155 D440 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A to the sign of y_sign * sidev_y
     D442 0034     
33156                      .eor @XX16+3(rx)                ; EOR XX16+3,X
     **** ****     > EOR
0001 D444 D02E  34        movb @XX16+3(RX),rtmp
     D446 000C     
0002 D448 2B40  18        xor  rtmp,ra
                   < elite.a99
33157               
33158 D44A 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     D44C D39A     
33159 D44E 06A0  32        bl   @jsr                       ;
     D450 FE1E     
33160 D452 D80D  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     D454 00D1     
33161               
33162 D456 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set Q = z_lo
     D458 0035     
33163 D45A D80D  30        movb ra,@Q                      ; STA Q
     D45C 0090     
33164               
33165 D45E D36E  34        movb @XX16+4(rx),ra             ; LDA XX16+4,X      ; Set A = |sidev_z|
     D460 000D     
33166               
33167 D462 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     D464 4338     
33168 D466 06A0  32        bl   @jsr                       ;
     D468 FE1E     
33169 D46A D80D  30        movb ra,@Q                      ; STA Q             ; = |sidev_z| * z_lo / 256
     D46C 0090     
33170               
33171 D46E D360  30        movb @T,ra                      ; LDA T             ; Set R = T
     D470 00D1     
33172 D472 D80D  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     D474 0091     
33173               
33174 D476 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A to the sign of z_sign * sidev_z
     D478 0036     
33175                      .eor @XX16+5(rx)                ; EOR XX16+5,X
     **** ****     > EOR
0001 D47A D02E  34        movb @XX16+5(RX),rtmp
     D47C 000E     
0002 D47E 2B40  18        xor  rtmp,ra
                   < elite.a99
33176               
33177 D480 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     D482 D39A     
33178 D484 06A0  32        bl   @jsr                       ;
     D486 FE1E     
33179                                                                          ; = |sidev_x| * x_lo + |sidev_y| * y_lo
33180                                                                          ; + |sidev_z| * z_lo
33181               
33182 D488 DBCD  38        movb ra,@XX12(ry)               ; STA XX12,Y        ; Store the result in XX12+Y(1 0)
     D48A 0037     
33183 D48C D360  30        movb @S,ra                      ; LDA S
     D48E 0092     
33184 D490 DBCD  38        movb ra,@XX12+1(ry)             ; STA XX12+1,Y
     D492 0038     
33185               
33186 D494 B3C7  18        ab   rone,ry                    ; INY               ; Set Y = Y + 2
33187 D496 B3C7  18        ab   rone,ry                    ; INY
33188               
33189 D498 D34E  18        movb rx,ra                      ; TXA               ; Set X = X + 6
33190                      .clc                            ; CLC
     **** ****     > CLC
0001 D49A 0A16  18        sla  rzero,1
                   < elite.a99
33191                      .adi (>06*256)                  ; ADC #6
     **** ****     > ADI
0001 D49C 1701  14        jnc  !
0002 D49E B347  18        ab   rone,ra
0003               !:
0004 D4A0 022D  22        ai   ra,(>06*256)
     D4A2 0600     
                   < elite.a99
33192 D4A4 D38D  18        movb ra,rx                      ; TAX
33193               
33194 D4A6 028D  22        ci   ra,>11*256                 ; CMP #17           ; If X < 17, loop back to ll51 for the next vector
     D4A8 1100     
33195 D4AA 17A7  14        jnc  ll51_                      ; BCC ll51
33196               
33197 D4AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D4AE FE2A     
33198               
33199               * ******************************************************************************
33200               *
33201               * Name: LL9 (Part 1 of 12)
33202               * Type: Subroutine
33203               * Category: Drawing ships
33204               * Summary: Draw ship: Check if ship is exploding, check if ship is in front
33205               * Deep dive: Drawing ships
33206               *
33207               * ------------------------------------------------------------------------------
33208               *
33209               * This routine draws the current ship on the screen. This part checks to see if
33210               * the ship is exploding, or if it should start exploding, and if it does it sets
33211               * things up accordingly.
33212               *
33213               * It also does some basic checks to see if we can see the ship, and if not it
33214               * removes it from the screen.
33215               *
33216               * In this code, XX1 is used to point to the current ship's data block at INWK
33217               * (the two labels are interchangeable).
33218               *
33219               * ------------------------------------------------------------------------------
33220               *
33221               * Arguments:
33222               *
33223               * XX1                 XX1 shares its location with INWK, which contains the
33224               * zero-page copy of the data block for this ship from the
33225               * K% workspace
33226               *
33227               * INF                 The address of the data block for this ship in workspace
33228               * K%
33229               *
33230               * XX19(1 0)           XX19(1 0) shares its location with INWK(34 33), which
33231               * contains the ship line heap address pointer
33232               *
33233               * XX0                 The address of the blueprint for this ship
33234               *
33235               * ------------------------------------------------------------------------------
33236               *
33237               * Other entry points:
33238               *
33239               * EE51                Remove the current ship from the screen, called from
33240               * SHPPT before drawing the ship as a point
33241               *
33242               * ******************************************************************************
33243               
33244               LL25:
33245 D4B0 0460  28        b    @PLANET                    ; JMP PLANET        ; Jump to the PLANET routine, returning from the
     D4B2 B1EE     
33246                                                                          ; subroutine using a tail call
33247               
33248               LL9:
33249 D4B4 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     D4B6 009B     
33250 D4B8 11FB  14        jlt  LL25                       ; BMI LL25          ; planet or sun, so jump to PLANET via LL25 above
33251               
33252 D4BA 020D  20        li   ra,>1f*256                 ; LDA #31           ; Set XX4 = 31 to store the ship's distance for later
     D4BC 1F00     
33253 D4BE D80D  30        movb ra,@XX4                    ; STA XX4           ; comparison with the visibility distance. We will
     D4C0 00A7     
33254                                                                          ; update this value below with the actual ship's
33255                                                                          ; distance if it turns out to be visible on-screen
33256               
33257 D4C2 020D  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the ship
     D4C4 2000     
33258                      .bit @XX1+31                    ; BIT XX1+31        ; is currently exploding, so jump down to EE28
     **** ****     > BIT
0001 D4C6 D020  30        movb @XX1+31,rtmp
     D4C8 0072     
0002 D4CA 0540  14        inv  rtmp
0003 D4CC D047  18        movb rone,rtmp2
0004 D4CE 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
33259 D4D0 164B  14        jne  EE28                       ; BNE EE28
33260               
33261 D4D2 154A  14        jgt  EE28                       ; BPL EE28          ; If bit 7 of the ship's byte #31 is clear then the ship
33262                                                                          ; has not just been killed, so jump down to EE28
33263               
33264                                                                          ; Otherwise bit 5 is clear and bit 7 is set, so the ship
33265                                                                          ; is not yet exploding but it has been killed, so we
33266                                                                          ; need to start an explosion
33267               
33268 D4D4 F360  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Clear bits 6 and 7 of the ship's byte #31, to stop the
     D4D6 0072     
33269 D4D8 024D  22        andi ra,>3f*256                 ; AND #%00111111    ; ship from firing its laser and to mark it as no longer
     D4DA 3F00     
33270 D4DC D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; having just been killed
     D4DE 0072     
33271               
33272 D4E0 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the ship's acceleration in byte #31 to 0, updating
     D4E2 0000     
33273 D4E4 020F  20        li   ry,>1c*256                 ; LDY #28           ; the byte in the workspace K% data block so we don't
     D4E6 1C00     
33274                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; have to copy it back from INWK later
     **** ****     > ST_IND_Y_IDX
0001 D4E8 D820  50        movb @INF,@rtmplb
     D4EA 0020     
     D4EC 206D     
0002 D4EE D020  30        movb @INF+1,rtmp
     D4F0 0021     
0003 D4F2 A00F  18        a    ry,rtmp
0004 D4F4 D40D  30        movb RA,*rtmp
                   < elite.a99
33275               
33276 D4F6 020F  20        li   ry,>1e*256                 ; LDY #30           ; Set the ship's pitch counter in byte #30 to 0, to stop
     D4F8 1E00     
33277                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the ship from pitching
     **** ****     > ST_IND_Y_IDX
0001 D4FA D820  50        movb @INF,@rtmplb
     D4FC 0020     
     D4FE 206D     
0002 D500 D020  30        movb @INF+1,rtmp
     D502 0021     
0003 D504 A00F  18        a    ry,rtmp
0004 D506 D40D  30        movb RA,*rtmp
                   < elite.a99
33278               
33279 D508 0200  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship from the screen
     D50A D588     
33280 D50C 06A0  32        bl   @jsr                       ;
     D50E FE1E     
33281               
33282                                                                          ; We now need to set up a new explosion cloud. We
33283                                                                          ; initialise it with a size of 18 (which gets increased
33284                                                                          ; by 4 every time the cloud gets redrawn), and the
33285                                                                          ; explosion count (i.e. the number of particles in the
33286                                                                          ; explosion), which go into bytes 1 and 2 of the ship
33287                                                                          ; line heap. See DOEXP for more details of explosion
33288                                                                          ; clouds
33289               
33290 D510 020F  20        li   ry,>01*256                 ; LDY #1            ; Set byte #1 of the ship line heap to 18, the initial
     D512 0100     
33291 D514 020D  20        li   ra,>12*256                 ; LDA #18           ; size of the explosion cloud
     D516 1200     
33292                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 D518 D820  50        movb @XX19,@rtmplb
     D51A 0074     
     D51C 206D     
0002 D51E D020  30        movb @XX19+1,rtmp
     D520 0075     
0003 D522 A00F  18        a    ry,rtmp
0004 D524 D40D  30        movb RA,*rtmp
                   < elite.a99
33293               
33294 D526 020F  20        li   ry,>07*256                 ; LDY #7            ; Fetch byte #7 from the ship's blueprint, which
     D528 0700     
33295                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; determines the explosion count (i.e. the number of
     **** ****     > LD_IND_Y_IDX
0001 D52A D820  50        movb @XX0,@rtmplb
     D52C 001E     
     D52E 206D     
0002 D530 D020  30        movb @XX0+1,rtmp
     D532 001F     
0003 D534 A00F  18        a    ry,rtmp
0004 D536 D350  26        movb *rtmp,RA
                   < elite.a99
33296 D538 020F  20        li   ry,>02*256                 ; LDY #2            ; vertices used as origins for explosion clouds), and
     D53A 0200     
33297                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; store it in byte #2 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 D53C D820  50        movb @XX19,@rtmplb
     D53E 0074     
     D540 206D     
0002 D542 D020  30        movb @XX19+1,rtmp
     D544 0075     
0003 D546 A00F  18        a    ry,rtmp
0004 D548 D40D  30        movb RA,*rtmp
                   < elite.a99
33298               
33299               * LDA XX1+32             \ These instructions are commented out in the original
33300               * AND #&7F               \ source
33301               
33302                                                                          ; The following loop sets bytes 3-6 of the of the ship
33303                                                                          ; line heap to random numbers
33304               
33305               EE55:
33306 D54A B3C7  18        ab   rone,ry                    ; INY               ; Increment Y (so the loop starts at 3)
33307               
33308 D54C 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     D54E C07C     
33309 D550 06A0  32        bl   @jsr                       ;
     D552 FE1E     
33310               
33311                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in the Y-th byte of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 D554 D820  50        movb @XX19,@rtmplb
     D556 0074     
     D558 206D     
0002 D55A D020  30        movb @XX19+1,rtmp
     D55C 0075     
0003 D55E A00F  18        a    ry,rtmp
0004 D560 D40D  30        movb RA,*rtmp
                   < elite.a99
33312               
33313 D562 028F  22        ci   ry,>06*256                 ; CPY #6            ; Loop back until we have randomised the 6th byte
     D564 0600     
33314 D566 16F1  14        jne  EE55                       ; BNE EE55
33315               
33316               EE28:
33317 D568 D360  30        movb @XX1+8,ra                  ; LDA XX1+8         ; Set A = z_sign
     D56A 005B     
33318               
33319               EE49:
33320 D56C 151E  14        jgt  LL10                       ; BPL LL10          ; If A is positive, i.e. the ship is in front of us,
33321                                                                          ; jump down to LL10
33322               
33323               LL14:
33324                                                                          ; The following removes the ship from the screen by
33325                                                                          ; redrawing it (or, if it is exploding, by redrawing the
33326                                                                          ; explosion cloud). We call it when the ship is no
33327                                                                          ; longer on-screen, is too far away to be fully drawn,
33328                                                                          ; and so on
33329 D56E D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     D570 0072     
33330 D572 024D  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE51
     D574 2000     
33331 D576 1308  14        jeq  EE51                       ; BEQ EE51          ; to redraw its wireframe
33332               
33333 D578 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so clear bit 3 of the ship's
     D57A 0072     
33334 D57C 024D  22        andi ra,>f7*256                 ; AND #%11110111    ; byte #31 to denote that the ship is no longer being
     D57E F700     
33335 D580 D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; drawn on-screen
     D582 0072     
33336               
33337 D584 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud, which
     D586 A8A0     
33338                                                                          ; will remove it from the screen, returning from the
33339                                                                          ; subroutine using a tail call
33340               
33341               EE51:
33342 D588 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     D58A 0800     
33343                      .bit @XX1+31                    ; BIT XX1+31        ; is already nothing being shown for this ship, so
     **** ****     > BIT
0001 D58C D020  30        movb @XX1+31,rtmp
     D58E 0072     
0002 D590 0540  14        inv  rtmp
0003 D592 D047  18        movb rone,rtmp2
0004 D594 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
33344 D596 1308  14        jeq  LL10-1                     ; BEQ LL10-1        ; return from the subroutine (as LL10-1 contains an RTS)
33345               
33346                      .eor @XX1+31                    ; EOR XX1+31        ; Otherwise flip bit 3 of byte #31 and store it (which
     **** ****     > EOR
0001 D598 D020  30        movb @XX1+31,rtmp
     D59A 0072     
0002 D59C 2B40  18        xor  rtmp,ra
                   < elite.a99
33347 D59E D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; clears bit 3 as we know it was set before the EOR), so
     D5A0 0072     
33348                                                                          ; this sets this ship as no longer being drawn on-screen
33349               
33350 D5A2 0460  28        b    @LL155                     ; JMP LL155         ; Jump to LL155 to draw the ship, which removes it from
     D5A4 E25C     
33351                                                                          ; the screen, returning from the subroutine using a
33352                                                                          ; tail call
33353               
33354               * .LL24                  \ This label is commented out in the original source,
33355                                                                          ; and was presumably used to label the RTS which is
33356                                                                          ; actually called by LL10-1 above, not LL24
33357               
33358 D5A6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D5A8 FE2A     
33359               
33360               * ******************************************************************************
33361               *
33362               * Name: LL9 (Part 2 of 12)
33363               * Type: Subroutine
33364               * Category: Drawing ships
33365               * Summary: Draw ship: Check if ship is in field of view, close enough to draw
33366               * Deep dive: Drawing ships
33367               *
33368               * ------------------------------------------------------------------------------
33369               *
33370               * This part checks whether the ship is in our field of view, and whether it is
33371               * close enough to be fully drawn (if not, we jump to SHPPT to draw it as a dot).
33372               *
33373               * ------------------------------------------------------------------------------
33374               *
33375               * Other entry points:
33376               *
33377               * LL10-1              Contains an RTS
33378               *
33379               * ******************************************************************************
33380               
33381               LL10:
33382 D5AA D360  30        movb @XX1+7,ra                  ; LDA XX1+7         ; Set A = z_hi
     D5AC 005A     
33383               
33384 D5AE 028D  22        ci   ra,>c0*256                 ; CMP #192          ; If A >= 192 then the ship is a long way away, so jump
     D5B0 C000     
33385 D5B2 18DD  14        joc  LL14                       ; BCS LL14          ; to LL14 to remove the ship from the screen
33386               
33387 D5B4 D360  30        movb @XX1,ra                    ; LDA XX1           ; If x_lo >= z_lo, set the C flag, otherwise clear it
     D5B6 0053     
33388 D5B8 9360  30        cb   @XX1+6,ra                  ; CMP XX1+6
     D5BA 0059     
33389               
33390 D5BC D360  30        movb @XX1+1,ra                  ; LDA XX1+1         ; Set A = x_hi - z_hi using the carry from the low
     D5BE 0054     
33391                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 D5C0 1801  14        joc  !
0002 D5C2 7347  18        sb   rone,ra
0003               !:
0004 D5C4 7360  30        sb   @XX1+7,ra
     D5C6 005A     
                   < elite.a99
33392                                                                          ; two-byte subtraction (x_hi x_lo) - (z_hi z_lo)
33393               
33394 D5C8 18D2  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then x >= z, so the ship is
33395                                                                          ; further to the side than it is in front of us, so it's
33396                                                                          ; outside our viewing angle of 45 degrees, and we jump
33397                                                                          ; to LL14 to remove it from the screen
33398               
33399 D5CA D360  30        movb @XX1+3,ra                  ; LDA XX1+3         ; If y_lo >= z_lo, set the C flag, otherwise clear it
     D5CC 0056     
33400 D5CE 9360  30        cb   @XX1+6,ra                  ; CMP XX1+6
     D5D0 0059     
33401               
33402 D5D2 D360  30        movb @XX1+4,ra                  ; LDA XX1+4         ; Set A = y_hi - z_hi using the carry from the low
     D5D4 0057     
33403                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 D5D6 1801  14        joc  !
0002 D5D8 7347  18        sb   rone,ra
0003               !:
0004 D5DA 7360  30        sb   @XX1+7,ra
     D5DC 005A     
                   < elite.a99
33404                                                                          ; two-byte subtraction (y_hi y_lo) - (z_hi z_lo)
33405               
33406 D5DE 18C7  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then y >= z, so the ship is
33407                                                                          ; further above us than it is in front of us, so it's
33408                                                                          ; outside our viewing angle of 45 degrees, and we jump
33409                                                                          ; to LL14 to remove it from the screen
33410               
33411 D5E0 020F  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 from the ship's blueprint into X, which
     D5E2 0600     
33412                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; is the number * 4 of the vertex used for the ship's
     **** ****     > LD_IND_Y_IDX
0001 D5E4 D820  50        movb @XX0,@rtmplb
     D5E6 001E     
     D5E8 206D     
0002 D5EA D020  30        movb @XX0+1,rtmp
     D5EC 001F     
0003 D5EE A00F  18        a    ry,rtmp
0004 D5F0 D350  26        movb *rtmp,RA
                   < elite.a99
33413 D5F2 D38D  18        movb ra,rx                      ; TAX               ; laser
33414               
33415 D5F4 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set bytes X and X+1 of the XX3 heap to 255. We're
     D5F6 FF00     
33416 D5F8 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; going to use XX3 to store the screen coordinates of
     D5FA 0100     
33417 D5FC DB8D  38        movb ra,@XX3+1(rx)              ; STA XX3+1,X       ; all the visible vertices of this ship, so setting the
     D5FE 0101     
33418                                                                          ; laser vertex to 255 means that if we don't update this
33419                                                                          ; vertex with its screen coordinates in parts 6 and 7,
33420                                                                          ; this vertex's entry in the XX3 heap will still be 255,
33421                                                                          ; which we can check in part 9 to see if the laser
33422                                                                          ; vertex is visible (and therefore whether we should
33423                                                                          ; draw laser lines if the ship is firing on us)
33424               
33425 D600 D360  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (A T) = (z_hi z_lo)
     D602 0059     
33426 D604 D80D  30        movb ra,@T                      ; STA T
     D606 00D1     
33427 D608 D360  30        movb @XX1+7,ra                  ; LDA XX1+7
     D60A 005A     
33428               
33429 D60C 091D  18        srl  ra,1                       ; LSR A             ; Set (A T) = (A T) / 8
33430 D60E 0204  20        li   rarg1,T                    ; ROR T
     D610 00D1     
33431 D612 06A0  32        bl   @ror                       ;
     D614 FE70     
33432 D616 091D  18        srl  ra,1                       ; LSR A
33433 D618 0204  20        li   rarg1,T                    ; ROR T
     D61A 00D1     
33434 D61C 06A0  32        bl   @ror                       ;
     D61E FE70     
33435 D620 091D  18        srl  ra,1                       ; LSR A
33436 D622 0204  20        li   rarg1,T                    ; ROR T
     D624 00D1     
33437 D626 06A0  32        bl   @ror                       ;
     D628 FE70     
33438               
33439 D62A 091D  18        srl  ra,1                       ; LSR A             ; If A >> 4 is non-zero, i.e. z_hi >= 16, jump to LL13
33440 D62C 160A  14        jne  LL13                       ; BNE LL13          ; as the ship is possibly far away enough to be shown as
33441                                                                          ; a dot
33442               
33443 D62E D360  30        movb @T,ra                      ; LDA T             ; Otherwise the C flag contains the previous bit 0 of A,
     D630 00D1     
33444 D632 06A0  32        bl   @rora                      ; ROR A             ; which could have been set, so rotate A right four
     D634 FE58     
33445 D636 091D  18        srl  ra,1                       ; LSR A             ; times so it's in the form %000xxxxx, i.e. z_hi reduced
33446 D638 091D  18        srl  ra,1                       ; LSR A             ; to a maximum value of 31
33447 D63A 091D  18        srl  ra,1                       ; LSR A
33448               
33449 D63C D80D  30        movb ra,@XX4                    ; STA XX4           ; Store A in XX4, which is now the distance of the ship
     D63E 00A7     
33450                                                                          ; we can use for visibility testing
33451               
33452 D640 1515  14        jgt  LL17                       ; BPL LL17          ; Jump down to LL17 (this BPL is effectively a JMP as we
33453                                                                          ; know bit 7 of A is definitely clear)
33454               
33455               LL13:
33456                                                                          ; If we get here then the ship is possibly far enough
33457                                                                          ; away to be shown as a dot
33458 D642 020F  20        li   ry,>0d*256                 ; LDY #13           ; Fetch byte #13 from the ship's blueprint, which gives
     D644 0D00     
33459                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the ship's visibility distance, beyond which we show
     **** ****     > LD_IND_Y_IDX
0001 D646 D820  50        movb @XX0,@rtmplb
     D648 001E     
     D64A 206D     
0002 D64C D020  30        movb @XX0+1,rtmp
     D64E 001F     
0003 D650 A00F  18        a    ry,rtmp
0004 D652 D350  26        movb *rtmp,RA
                   < elite.a99
33460                                                                          ; the ship as a dot
33461               
33462 D654 9360  30        cb   @XX1+7,ra                  ; CMP XX1+7         ; If z_hi <= the visibility distance, skip to LL17 to
     D656 005A     
33463 D658 1809  14        joc  LL17                       ; BCS LL17          ; draw the ship fully, rather than as a dot, as it is
33464                                                                          ; closer than the visibility distance
33465               
33466 D65A 020D  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the
     D65C 2000     
33467                      .and @XX1+31                    ; AND XX1+31        ; ship is currently exploding, so skip to LL17 to draw
     **** ****     > AND
0001 D65E D020  30        movb @XX1+31,rtmp
     D660 0072     
0002 D662 0540  14        inv  rtmp
0003 D664 5340  18        szcb rtmp,ra
                   < elite.a99
33468 D666 1602  14        jne  LL17                       ; BNE LL17          ; the ship's explosion cloud
33469               
33470 D668 0460  28        b    @SHPPT                     ; JMP SHPPT         ; Otherwise jump to SHPPT to draw the ship as a dot,
     D66A D1EE     
33471                                                                          ; returning from the subroutine using a tail call
33472               
33473               * ******************************************************************************
33474               *
33475               * Name: LL9 (Part 3 of 12)
33476               * Type: Subroutine
33477               * Category: Drawing ships
33478               * Summary: Draw ship: Set up orientation vector, ship coordinate variables
33479               * Deep dive: Drawing ships
33480               *
33481               * ------------------------------------------------------------------------------
33482               *
33483               * This part sets up the following variable blocks:
33484               *
33485               * * XX16 contains the orientation vectors, divided to normalise them
33486               *
33487               * * XX18 contains the ship's x, y and z coordinates in space
33488               *
33489               * ******************************************************************************
33490               
33491               LL17:
33492 D66C 020E  20        li   rx,>05*256                 ; LDX #5            ; First we copy the three orientation vectors into XX16,
     D66E 0500     
33493                                                                          ; so set up a counter in X for the 6 bytes in each
33494                                                                          ; vector
33495               
33496               LL15:
33497 D670 D36E  34        movb @XX1+21(rx),ra             ; LDA XX1+21,X      ; Copy the X-th byte of sidev to the X-th byte of XX16
     D672 0068     
33498 D674 DB8D  38        movb ra,@XX16(rx)               ; STA XX16,X
     D676 0009     
33499               
33500 D678 D36E  34        movb @XX1+15(rx),ra             ; LDA XX1+15,X      ; Copy the X-th byte of roofv to XX16+6 to the X-th byte
     D67A 0062     
33501 D67C DB8D  38        movb ra,@XX16+6(rx)             ; STA XX16+6,X      ; of XX16+6
     D67E 000F     
33502               
33503 D680 D36E  34        movb @XX1+9(rx),ra              ; LDA XX1+9,X       ; Copy the X-th byte of nosev to XX16+12 to the X-th
     D682 005C     
33504 D684 DB8D  38        movb ra,@XX16+12(rx)            ; STA XX16+12,X     ; byte of XX16+12
     D686 0015     
33505               
33506 D688 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
33507               
33508 D68A 15F2  14        jgt  LL15                       ; BPL LL15          ; Loop back to copy the next byte of each vector, until
33509                                                                          ; we have the following:
33510                                                                          ;
33511                                                                          ; * XX16(1 0) = sidev_x
33512                                                                          ; * XX16(3 2) = sidev_y
33513                                                                          ; * XX16(5 4) = sidev_z
33514                                                                          ;
33515                                                                          ; * XX16(7 6) = roofv_x
33516                                                                          ; * XX16(9 8) = roofv_y
33517                                                                          ; * XX16(11 10) = roofv_z
33518                                                                          ;
33519                                                                          ; * XX16(13 12) = nosev_x
33520                                                                          ; * XX16(15 14) = nosev_y
33521                                                                          ; * XX16(17 16) = nosev_z
33522               
33523 D68C 020D  20        li   ra,>c5*256                 ; LDA #197          ; Set Q = 197
     D68E C500     
33524 D690 D80D  30        movb ra,@Q                      ; STA Q
     D692 0090     
33525               
33526 D694 020F  20        li   ry,>10*256                 ; LDY #16           ; Set Y to be a counter that counts down by 2 each time,
     D696 1000     
33527                                                                          ; starting with 16, then 14, 12 and so on. We use this
33528                                                                          ; to work through each of the coordinates in each of the
33529                                                                          ; orientation vectors
33530               
33531               LL21:
33532 D698 D36F  34        movb @XX16(ry),ra               ; LDA XX16,Y        ; Set A = the low byte of the vector coordinate, e.g.
     D69A 0009     
33533                                                                          ; nosev_z_lo when Y = 16
33534               
33535                      .asla                           ; ASL A             ; Shift bit 7 into the C flag
     **** ****     > ASLA
0001 D69C 024D  22        andi ra,>ff00
     D69E FF00     
0002 D6A0 0A1D  18        sla  ra,1
                   < elite.a99
33536               
33537 D6A2 D36F  34        movb @XX16+1(ry),ra             ; LDA XX16+1,Y      ; Set A = the high byte of the vector coordinate, e.g.
     D6A4 000A     
33538                                                                          ; nosev_z_hi when Y = 16
33539               
33540 D6A6 06A0  32        bl   @rola                      ; ROL A             ; Rotate A left, incorporating the C flag, so A now
     D6A8 FE34     
33541                                                                          ; contains the original high byte, doubled, and without
33542                                                                          ; a sign bit, e.g. A = |nosev_z_hi| * 2
33543               
33544 D6AA 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     D6AC D344     
33545 D6AE 06A0  32        bl   @jsr                       ;
     D6B0 FE1E     
33546                                                                          ;
33547                                                                          ; R = 256 * A / Q
33548                                                                          ;
33549                                                                          ; so, for nosev, this would be:
33550                                                                          ;
33551                                                                          ; R = 256 * |nosev_z_hi| * 2 / 197
33552                                                                          ; = 2.6 * |nosev_z_hi|
33553               
33554 D6B2 D3A0  30        movb @R,rx                      ; LDX R             ; Store R in the low byte's location, so we can keep the
     D6B4 0091     
33555 D6B6 DBCE  38        movb rx,@XX16(ry)               ; STX XX16,Y        ; old, unscaled high byte intact for the sign
     D6B8 0009     
33556               
33557 D6BA 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter twice
33558 D6BC 73C7  18        sb   rone,ry                    ; DEY
33559               
33560 D6BE 15EC  14        jgt  LL21                       ; BPL LL21          ; Loop back for the next vector coordinate until we have
33561                                                                          ; divided them all
33562               
33563                                                                          ; By this point, the vectors have been turned into
33564                                                                          ; scaled magnitudes, so we have the following:
33565                                                                          ;
33566                                                                          ; * XX16   = scaled |sidev_x|
33567                                                                          ; * XX16+2 = scaled |sidev_y|
33568                                                                          ; * XX16+4 = scaled |sidev_z|
33569                                                                          ;
33570                                                                          ; * XX16+6  = scaled |roofv_x|
33571                                                                          ; * XX16+8  = scaled |roofv_y|
33572                                                                          ; * XX16+10 = scaled |roofv_z|
33573                                                                          ;
33574                                                                          ; * XX16+12 = scaled |nosev_x|
33575                                                                          ; * XX16+14 = scaled |nosev_y|
33576                                                                          ; * XX16+16 = scaled |nosev_z|
33577               
33578 D6C0 020E  20        li   rx,>08*256                 ; LDX #8            ; Next we copy the ship's coordinates into XX18, so set
     D6C2 0800     
33579                                                                          ; up a counter in X for 9 bytes
33580               
33581               ll91_:
33582 D6C4 D36E  34        movb @XX1(rx),ra                ; LDA XX1,X         ; Copy the X-th byte from XX1 to XX18
     D6C6 0053     
33583 D6C8 DB8D  38        movb ra,@XX18(rx)               ; STA XX18,X
     D6CA 007E     
33584               
33585 D6CC 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
33586               
33587 D6CE 15FA  14        jgt  ll91_                      ; BPL ll91          ; Loop back for the next byte until we have copied all
33588                                                                          ; three coordinates
33589               
33590                                                                          ; So we now have the following:
33591                                                                          ;
33592                                                                          ; * XX18(2 1 0) = (x_sign x_hi x_lo)
33593                                                                          ;
33594                                                                          ; * XX18(5 4 3) = (y_sign y_hi y_lo)
33595                                                                          ;
33596                                                                          ; * XX18(8 7 6) = (z_sign z_hi z_lo)
33597               
33598 D6D0 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set the 15th byte of XX2 to 255, so that face 15 is
     D6D2 FF00     
33599 D6D4 D80D  30        movb ra,@XX2+15                 ; STA XX2+15        ; always visible. No ship definitions actually have this
     D6D6 00E1     
33600                                                                          ; number of faces, but this allows us to force a vertex
33601                                                                          ; to always be visible by associating it with face 15
33602                                                                          ; (see the ship blueprints for the Cobra Mk III at
33603                                                                          ; SHIP_COBRA_MK_3 and the asteroid at SHIP_ASTEROID for
33604                                                                          ; examples of vertices that are associated with face 15)
33605               
33606 D6D8 020F  20        li   ry,>0c*256                 ; LDY #12           ; Set Y = 12 to point to the ship blueprint byte #12,
     D6DA 0C00     
33607               
33608 D6DC D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     D6DE 0072     
33609 D6E0 024D  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE29
     D6E2 2000     
33610 D6E4 1315  14        jeq  EE29                       ; BEQ EE29          ; to skip the following
33611               
33612                                                                          ; Otherwise we fall through to set up the visibility
33613                                                                          ; block for an exploding ship
33614               
33615               * ******************************************************************************
33616               *
33617               * Name: LL9 (Part 4 of 12)
33618               * Type: Subroutine
33619               * Category: Drawing ships
33620               * Summary: Draw ship: Set visibility for exploding ship (all faces visible)
33621               * Deep dive: Drawing ships
33622               *
33623               * ------------------------------------------------------------------------------
33624               *
33625               * This part sets up the visibility block in XX2 for a ship that is exploding.
33626               *
33627               * The XX2 block consists of one byte for each face in the ship's blueprint,
33628               * which holds the visibility of that face. Because the ship is exploding, we
33629               * want to set all the faces to be visible. A value of 255 in the visibility
33630               * table means the face is visible, so the following code sets each face to 255
33631               * and then skips over the face visibility calculations that we would apply to a
33632               * non-exploding ship.
33633               *
33634               * ******************************************************************************
33635               
33636                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Fetch byte #12 of the ship's blueprint, which contains
     **** ****     > LD_IND_Y_IDX
0001 D6E6 D820  50        movb @XX0,@rtmplb
     D6E8 001E     
     D6EA 206D     
0002 D6EC D020  30        movb @XX0+1,rtmp
     D6EE 001F     
0003 D6F0 A00F  18        a    ry,rtmp
0004 D6F2 D350  26        movb *rtmp,RA
                   < elite.a99
33637                                                                          ; the number of faces * 4
33638               
33639 D6F4 091D  18        srl  ra,1                       ; LSR A             ; Set X = A / 4
33640 D6F6 091D  18        srl  ra,1                       ; LSR A             ; = the number of faces
33641 D6F8 D38D  18        movb ra,rx                      ; TAX
33642               
33643 D6FA 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set A = 255
     D6FC FF00     
33644               
33645               EE30:
33646 D6FE DB8D  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Set the X-th byte of XX2 to 255
     D700 00D2     
33647               
33648 D702 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
33649               
33650 D704 15FC  14        jgt  EE30                       ; BPL EE30          ; Loop back for the next byte until there is one byte
33651                                                                          ; set to 255 for each face
33652               
33653 D706 B387  18        ab   rone,rx                    ; INX               ; Set XX4 = 0 for the distance value we use to test
33654 D708 D80E  30        movb rx,@XX4                    ; STX XX4           ; for visibility, so we always shows everything
     D70A 00A7     
33655               
33656               LL41:
33657 D70C 0460  28        b    @LL42                      ; JMP LL42          ; Jump to LL42 to skip the face visibility calculations
     D70E DA94     
33658                                                                          ; as we don't need to do them now we've set up the XX2
33659                                                                          ; block for the explosion
33660               
33661               * ******************************************************************************
33662               *
33663               * Name: LL9 (Part 5 of 12)
33664               * Type: Subroutine
33665               * Category: Drawing ships
33666               * Summary: Draw ship: Calculate the visibility of each of the ship's faces
33667               * Deep dive: Drawing ships
33668               * Back-face culling
33669               *
33670               * ******************************************************************************
33671               
33672               EE29:
33673                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; We set Y to 12 above before jumping down to EE29, so
     **** ****     > LD_IND_Y_IDX
0001 D710 D820  50        movb @XX0,@rtmplb
     D712 001E     
     D714 206D     
0002 D716 D020  30        movb @XX0+1,rtmp
     D718 001F     
0003 D71A A00F  18        a    ry,rtmp
0004 D71C D350  26        movb *rtmp,RA
                   < elite.a99
33674                                                                          ; this fetches byte #12 of the ship's blueprint, which
33675                                                                          ; contains the number of faces * 4
33676               
33677 D71E 13F6  14        jeq  LL41                       ; BEQ LL41          ; If there are no faces in this ship, jump to LL42 (via
33678                                                                          ; LL41) to skip the face visibility calculations
33679               
33680 D720 D80D  30        movb ra,@XX20                   ; STA XX20          ; Set A = the number of faces * 4
     D722 00A8     
33681               
33682 D724 020F  20        li   ry,>12*256                 ; LDY #18           ; Fetch byte #18 of the ship's blueprint, which contains
     D726 1200     
33683                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the factor by which we scale the face normals, into X
     **** ****     > LD_IND_Y_IDX
0001 D728 D820  50        movb @XX0,@rtmplb
     D72A 001E     
     D72C 206D     
0002 D72E D020  30        movb @XX0+1,rtmp
     D730 001F     
0003 D732 A00F  18        a    ry,rtmp
0004 D734 D350  26        movb *rtmp,RA
                   < elite.a99
33684 D736 D38D  18        movb ra,rx                      ; TAX
33685               
33686 D738 D360  30        movb @XX18+7,ra                 ; LDA XX18+7        ; Set A = z_hi
     D73A 0085     
33687               
33688               LL90:
33689 D73C D3CD  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
33690               
33691 D73E 131A  14        jeq  LL91                       ; BEQ LL91          ; If z_hi = 0 then jump to LL91
33692               
33693                                                                          ; The following is a loop that jumps back to LL90+3,
33694                                                                          ; i.e. here. LL90 is only used for this loop, so it's a
33695                                                                          ; bit of a strange use of the label here
33696               
33697 D740 B387  18        ab   rone,rx                    ; INX               ; Increment the scale factor in X
33698               
33699                      .lsr @XX18+4                    ; LSR XX18+4        ; Divide (y_hi y_lo) by 2
     **** ****     > LSR
0001 D742 D020  30        movb @XX18+4,rtmp
     D744 0082     
0002 D746 0910  18        srl  rtmp,1
0003 D748 D800  30        movb rtmp,@XX18+4
     D74A 0082     
                   < elite.a99
33700 D74C 0204  20        li   rarg1,XX18+3               ; ROR XX18+3
     D74E 0081     
33701 D750 06A0  32        bl   @ror                       ;
     D752 FE70     
33702               
33703                      .lsr @XX18+1                    ; LSR XX18+1        ; Divide (x_hi x_lo) by 2
     **** ****     > LSR
0001 D754 D020  30        movb @XX18+1,rtmp
     D756 007F     
0002 D758 0910  18        srl  rtmp,1
0003 D75A D800  30        movb rtmp,@XX18+1
     D75C 007F     
                   < elite.a99
33704 D75E 0204  20        li   rarg1,XX18                 ; ROR XX18
     D760 007E     
33705 D762 06A0  32        bl   @ror                       ;
     D764 FE70     
33706               
33707 D766 091D  18        srl  ra,1                       ; LSR A             ; Divide (z_hi z_lo) by 2 (as A contains z_hi)
33708 D768 0204  20        li   rarg1,XX18+6               ; ROR XX18+6
     D76A 0084     
33709 D76C 06A0  32        bl   @ror                       ;
     D76E FE70     
33710               
33711 D770 D3CD  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
33712               
33713 D772 16E5  14        jne  LL90+3                     ; BNE LL90+3        ; If Y is non-zero, loop back to LL90+3 to divide the
33714                                                                          ; three coordinates until z_hi is 0
33715               
33716               LL91:
33717                                                                          ; By this point z_hi is 0 and X contains the number of
33718                                                                          ; right shifts we had to do, plus the scale factor from
33719                                                                          ; the blueprint
33720 D774 D80E  30        movb rx,@XX17                   ; STX XX17          ; Store the updated scale factor in XX17
     D776 0095     
33721               
33722 D778 D360  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set XX15+5 = z_sign
     D77A 0086     
33723 D77C D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     D77E 0036     
33724               
33725 D780 D360  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = (x_sign x_lo)
     D782 007E     
33726 D784 D80D  30        movb ra,@XX15                   ; STA XX15
     D786 0031     
33727 D788 D360  30        movb @XX18+2,ra                 ; LDA XX18+2
     D78A 0080     
33728 D78C D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D78E 0032     
33729               
33730 D790 D360  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = (y_sign y_lo)
     D792 0081     
33731 D794 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     D796 0033     
33732 D798 D360  30        movb @XX18+5,ra                 ; LDA XX18+5
     D79A 0083     
33733 D79C D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     D79E 0034     
33734               
33735 D7A0 D360  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15+4 = z_lo, so now XX15(5 4) = (z_sign z_lo)
     D7A2 0084     
33736 D7A4 D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     D7A6 0035     
33737               
33738 D7A8 0200  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     D7AA D3F2     
33739 D7AC 06A0  32        bl   @jsr                       ;
     D7AE FE1E     
33740                                                                          ; XX16, which we'll call dot_sidev, dot_roofv and
33741                                                                          ; dot_nosev:
33742                                                                          ;
33743                                                                          ; XX12(1 0) = [x y z] . sidev
33744                                                                          ; = (dot_sidev_sign dot_sidev_lo)
33745                                                                          ; = dot_sidev
33746                                                                          ;
33747                                                                          ; XX12(3 2) = [x y z] . roofv
33748                                                                          ; = (dot_roofv_sign dot_roofv_lo)
33749                                                                          ; = dot_roofv
33750                                                                          ;
33751                                                                          ; XX12(5 4) = [x y z] . nosev
33752                                                                          ; = (dot_nosev_sign dot_nosev_lo)
33753                                                                          ; = dot_nosev
33754               
33755 D7B0 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set XX18(2 0) = dot_sidev
     D7B2 0037     
33756 D7B4 D80D  30        movb ra,@XX18                   ; STA XX18
     D7B6 007E     
33757 D7B8 D360  30        movb @XX12+1,ra                 ; LDA XX12+1
     D7BA 0038     
33758 D7BC D80D  30        movb ra,@XX18+2                 ; STA XX18+2
     D7BE 0080     
33759               
33760 D7C0 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX18(5 3) = dot_roofv
     D7C2 0039     
33761 D7C4 D80D  30        movb ra,@XX18+3                 ; STA XX18+3
     D7C6 0081     
33762 D7C8 D360  30        movb @XX12+3,ra                 ; LDA XX12+3
     D7CA 003A     
33763 D7CC D80D  30        movb ra,@XX18+5                 ; STA XX18+5
     D7CE 0083     
33764               
33765 D7D0 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set XX18(8 6) = dot_nosev
     D7D2 003B     
33766 D7D4 D80D  30        movb ra,@XX18+6                 ; STA XX18+6
     D7D6 0084     
33767 D7D8 D360  30        movb @XX12+5,ra                 ; LDA XX12+5
     D7DA 003C     
33768 D7DC D80D  30        movb ra,@XX18+8                 ; STA XX18+8
     D7DE 0086     
33769               
33770 D7E0 020F  20        li   ry,>04*256                 ; LDY #4            ; Fetch byte #4 of the ship's blueprint, which contains
     D7E2 0400     
33771                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the low byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 D7E4 D820  50        movb @XX0,@rtmplb
     D7E6 001E     
     D7E8 206D     
0002 D7EA D020  30        movb @XX0+1,rtmp
     D7EC 001F     
0003 D7EE A00F  18        a    ry,rtmp
0004 D7F0 D350  26        movb *rtmp,RA
                   < elite.a99
33772               
33773                      .clc                            ; CLC               ; Set V = low byte faces offset + XX0
     **** ****     > CLC
0001 D7F2 0A16  18        sla  rzero,1
                   < elite.a99
33774                      .adc @XX0,ra                    ; ADC XX0
     **** ****     > ADC
0001 D7F4 1701  14        jnc  !
0002 D7F6 B347  18        ab   rone,ra
0003               !:
0004 D7F8 B360  30        ab   @XX0,ra
     D7FA 001E     
                   < elite.a99
33775 D7FC D80D  30        movb ra,@V                      ; STA V
     D7FE 0022     
33776               
33777 D800 020F  20        li   ry,>11*256                 ; LDY #17           ; Fetch byte #17 of the ship's blueprint, which contains
     D802 1100     
33778                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 D804 D820  50        movb @XX0,@rtmplb
     D806 001E     
     D808 206D     
0002 D80A D020  30        movb @XX0+1,rtmp
     D80C 001F     
0003 D80E A00F  18        a    ry,rtmp
0004 D810 D350  26        movb *rtmp,RA
                   < elite.a99
33779               
33780                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte faces offset + XX0+1
     **** ****     > ADC
0001 D812 1701  14        jnc  !
0002 D814 B347  18        ab   rone,ra
0003               !:
0004 D816 B360  30        ab   @XX0+1,ra
     D818 001F     
                   < elite.a99
33781 D81A D80D  30        movb ra,@V+1                    ; STA V+1           ;
     D81C 0023     
33782                                                                          ; So V(1 0) now points to the start of the faces data
33783                                                                          ; for this ship
33784               
33785 D81E 020F  20        li   ry,>00*256                 ; LDY #0            ; We're now going to loop through all the faces for this
     D820 0000     
33786                                                                          ; ship, so set a counter in Y, starting from 0, which we
33787                                                                          ; will increment by 4 each loop to step through the
33788                                                                          ; four bytes of data for each face
33789               
33790               LL86:
33791                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this face into A, so:
     **** ****     > LD_IND_Y_IDX
0001 D822 D820  50        movb @V,@rtmplb
     D824 0022     
     D826 206D     
0002 D828 D020  30        movb @V+1,rtmp
     D82A 0023     
0003 D82C A00F  18        a    ry,rtmp
0004 D82E D350  26        movb *rtmp,RA
                   < elite.a99
33792                                                                          ;
33793                                                                          ; A = %xyz vvvvv, where:
33794                                                                          ;
33795                                                                          ; * Bits 0-4 = visibility distance, beyond which the
33796                                                                          ; face is always shown
33797                                                                          ;
33798                                                                          ; * Bits 7-5 = the sign bits of normal_x, normal_y
33799                                                                          ; and normal_z
33800               
33801 D830 D80D  30        movb ra,@XX12+1                 ; STA XX12+1        ; Store byte #0 in XX12+1, so XX12+1 now has the sign of
     D832 0038     
33802                                                                          ; normal_x
33803               
33804 D834 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to give the visibility distance
     D836 1F00     
33805               
33806 D838 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 <= the visibility distance, where XX4 contains
     D83A 00A7     
33807 D83C 1810  14        joc  LL87                       ; BCS LL87          ; the ship's z-distance reduced to 0-31 (which we set in
33808                                                                          ; part 2), skip to LL87 as this face is close enough
33809                                                                          ; that we have to test its visibility using the face
33810                                                                          ; normals
33811               
33812                                                                          ; Otherwise this face is within range and is therefore
33813                                                                          ; always shown
33814               
33815 D83E D34F  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
33816 D840 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
33817 D842 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face
33818 D844 D38D  18        movb ra,rx                      ; TAX
33819               
33820 D846 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set the X-th byte of XX2 to 255 to denote that this
     D848 FF00     
33821 D84A DB8D  38        movb ra,@XX2(rx)                ; STA XX2,X         ; face is visible
     D84C 00D2     
33822               
33823 D84E D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y + 4 to point to the next face
33824                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 D850 1701  14        jnc  !
0002 D852 B347  18        ab   rone,ra
0003               !:
0004 D854 022D  22        ai   ra,(>04*256)
     D856 0400     
                   < elite.a99
33825 D858 D3CD  18        movb ra,ry                      ; TAY
33826               
33827 D85A 0460  28        b    @LL88                      ; JMP LL88          ; Jump down to LL88 to skip the following, as we don't
     D85C DA8A     
33828                                                                          ; need to test the face normals
33829               
33830               LL87:
33831 D85E D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Fetch byte #0 for this face into A
     D860 0038     
33832               
33833                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+3 now has the sign
     **** ****     > ASLA
0001 D862 024D  22        andi ra,>ff00
     D864 FF00     
0002 D866 0A1D  18        sla  ra,1
                   < elite.a99
33834 D868 D80D  30        movb ra,@XX12+3                 ; STA XX12+3        ; of normal_y
     D86A 003A     
33835               
33836                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+5 now has the sign
     **** ****     > ASLA
0001 D86C 024D  22        andi ra,>ff00
     D86E FF00     
0002 D870 0A1D  18        sla  ra,1
                   < elite.a99
33837 D872 D80D  30        movb ra,@XX12+5                 ; STA XX12+5        ; of normal_z
     D874 003C     
33838               
33839 D876 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
33840               
33841                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this face and store in XX12, so
     **** ****     > LD_IND_Y_IDX
0001 D878 D820  50        movb @V,@rtmplb
     D87A 0022     
     D87C 206D     
0002 D87E D020  30        movb @V+1,rtmp
     D880 0023     
0003 D882 A00F  18        a    ry,rtmp
0004 D884 D350  26        movb *rtmp,RA
                   < elite.a99
33842 D886 D80D  30        movb ra,@XX12                   ; STA XX12          ; XX12 = normal_x
     D888 0037     
33843               
33844 D88A B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
33845               
33846                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this face and store in XX12+2, so
     **** ****     > LD_IND_Y_IDX
0001 D88C D820  50        movb @V,@rtmplb
     D88E 0022     
     D890 206D     
0002 D892 D020  30        movb @V+1,rtmp
     D894 0023     
0003 D896 A00F  18        a    ry,rtmp
0004 D898 D350  26        movb *rtmp,RA
                   < elite.a99
33847 D89A D80D  30        movb ra,@XX12+2                 ; STA XX12+2        ; XX12+2 = normal_y
     D89C 0039     
33848               
33849 D89E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
33850               
33851                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this face and store in XX12+4, so
     **** ****     > LD_IND_Y_IDX
0001 D8A0 D820  50        movb @V,@rtmplb
     D8A2 0022     
     D8A4 206D     
0002 D8A6 D020  30        movb @V+1,rtmp
     D8A8 0023     
0003 D8AA A00F  18        a    ry,rtmp
0004 D8AC D350  26        movb *rtmp,RA
                   < elite.a99
33852 D8AE D80D  30        movb ra,@XX12+4                 ; STA XX12+4        ; XX12+4 = normal_z
     D8B0 003B     
33853               
33854                                                                          ; So we now have:
33855                                                                          ;
33856                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
33857                                                                          ;
33858                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
33859                                                                          ;
33860                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
33861               
33862 D8B2 D3A0  30        movb @XX17,rx                   ; LDX XX17          ; If XX17 < 4 then jump to LL92, otherwise we stored a
     D8B4 0095     
33863 D8B6 028E  22        ci   rx,>04*256                 ; CPX #4            ; larger scale factor above
     D8B8 0400     
33864 D8BA 172B  14        jnc  LL92                       ; BCC LL92
33865               
33866               LL143:
33867 D8BC D360  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = XX18(2 0)
     D8BE 007E     
33868 D8C0 D80D  30        movb ra,@XX15                   ; STA XX15          ; = dot_sidev
     D8C2 0031     
33869 D8C4 D360  30        movb @XX18+2,ra                 ; LDA XX18+2
     D8C6 0080     
33870 D8C8 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D8CA 0032     
33871               
33872 D8CC D360  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = XX18(5 3)
     D8CE 0081     
33873 D8D0 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; = dot_roofv
     D8D2 0033     
33874 D8D4 D360  30        movb @XX18+5,ra                 ; LDA XX18+5
     D8D6 0083     
33875 D8D8 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     D8DA 0034     
33876               
33877 D8DC D360  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15(5 4) = XX18(8 6)
     D8DE 0084     
33878 D8E0 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; = dot_nosev
     D8E2 0035     
33879 D8E4 D360  30        movb @XX18+8,ra                 ; LDA XX18+8
     D8E6 0086     
33880 D8E8 D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     D8EA 0036     
33881               
33882 D8EC 0460  28        b    @LL89                      ; JMP LL89          ; Jump down to LL89
     D8EE D9D6     
33883               
33884               ovflw_:
33885                                                                          ; If we get here then the addition below overflowed, so
33886                                                                          ; we halve the dot products and normal vector
33887                      .lsr @XX18                      ; LSR XX18          ; Divide dot_sidev_lo by 2, so dot_sidev = dot_sidev / 2
     **** ****     > LSR
0001 D8F0 D020  30        movb @XX18,rtmp
     D8F2 007E     
0002 D8F4 0910  18        srl  rtmp,1
0003 D8F6 D800  30        movb rtmp,@XX18
     D8F8 007E     
                   < elite.a99
33888               
33889                      .lsr @XX18+6                    ; LSR XX18+6        ; Divide dot_nosev_lo by 2, so dot_nosev = dot_nosev / 2
     **** ****     > LSR
0001 D8FA D020  30        movb @XX18+6,rtmp
     D8FC 0084     
0002 D8FE 0910  18        srl  rtmp,1
0003 D900 D800  30        movb rtmp,@XX18+6
     D902 0084     
                   < elite.a99
33890               
33891                      .lsr @XX18+3                    ; LSR XX18+3        ; Divide dot_roofv_lo by 2, so dot_roofv = dot_roofv / 2
     **** ****     > LSR
0001 D904 D020  30        movb @XX18+3,rtmp
     D906 0081     
0002 D908 0910  18        srl  rtmp,1
0003 D90A D800  30        movb rtmp,@XX18+3
     D90C 0081     
                   < elite.a99
33892               
33893 D90E 020E  20        li   rx,>01*256                 ; LDX #1            ; Set X = 1 so when we fall through into LL92, we divide
     D910 0100     
33894                                                                          ; the normal vector by 2 as well
33895               
33896               LL92:
33897                                                                          ; We jump here from above with the scale factor in X,
33898                                                                          ; and now we apply it by scaling the normal vector down
33899                                                                          ; by a factor of 2^X (i.e. divide by 2^X)
33900 D912 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set XX15 = normal_x
     D914 0037     
33901 D916 D80D  30        movb ra,@XX15                   ; STA XX15
     D918 0031     
33902               
33903 D91A D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX15+2 = normal_y
     D91C 0039     
33904 D91E D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     D920 0033     
33905               
33906 D922 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = normal_z
     D924 003B     
33907               
33908               LL93:
33909 D926 7387  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
33910               
33911 D928 110D  14        jlt  LL94                       ; BMI LL94          ; If X was 0 before the decrement, there is no scaling
33912                                                                          ; to do, so jump to LL94 to exit the loop
33913               
33914                      .lsr @XX15                      ; LSR XX15          ; Set XX15 = XX15 / 2
     **** ****     > LSR
0001 D92A D020  30        movb @XX15,rtmp
     D92C 0031     
0002 D92E 0910  18        srl  rtmp,1
0003 D930 D800  30        movb rtmp,@XX15
     D932 0031     
                   < elite.a99
33915                                                                          ; = normal_x / 2
33916               
33917                      .lsr @XX15+2                    ; LSR XX15+2        ; Set XX15+2 = XX15+2 / 2
     **** ****     > LSR
0001 D934 D020  30        movb @XX15+2,rtmp
     D936 0033     
0002 D938 0910  18        srl  rtmp,1
0003 D93A D800  30        movb rtmp,@XX15+2
     D93C 0033     
                   < elite.a99
33918                                                                          ; = normal_y / 2
33919               
33920 D93E 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
33921                                                                          ; = normal_z / 2
33922               
33923 D940 7387  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
33924               
33925 D942 15F2  14        jgt  LL93+3                     ; BPL LL93+3        ; If we have more scaling to do, loop back up to the
33926                                                                          ; first LSR above until the normal vector is scaled down
33927               
33928               LL94:
33929 D944 D80D  30        movb ra,@R                      ; STA R             ; Set R = normal_z
     D946 0091     
33930               
33931 D948 D360  30        movb @XX12+5,ra                 ; LDA XX12+5        ; Set S = normal_z_sign
     D94A 003C     
33932 D94C D80D  30        movb ra,@S                      ; STA S
     D94E 0092     
33933               
33934 D950 D360  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set Q = dot_nosev_lo
     D952 0084     
33935 D954 D80D  30        movb ra,@Q                      ; STA Q
     D956 0090     
33936               
33937 D958 D360  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set A = dot_nosev_sign
     D95A 0086     
33938               
33939 D95C 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     D95E D39A     
33940 D960 06A0  32        bl   @jsr                       ;
     D962 FE1E     
33941                                                                          ; = normal_z + dot_nosev
33942                                                                          ;
33943                                                                          ; setting the sign of the result in S
33944               
33945 D964 18C5  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33946                                                                          ; both the normal vector and dot products by 2 and try
33947                                                                          ; again
33948               
33949 D966 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; Set XX15(5 4) = (S A)
     D968 0035     
33950 D96A D360  30        movb @S,ra                      ; LDA S             ; = normal_z + dot_nosev
     D96C 0092     
33951 D96E D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     D970 0036     
33952               
33953 D972 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set R = normal_x
     D974 0031     
33954 D976 D80D  30        movb ra,@R                      ; STA R
     D978 0091     
33955               
33956 D97A D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = normal_x_sign
     D97C 0038     
33957 D97E D80D  30        movb ra,@S                      ; STA S
     D980 0092     
33958               
33959 D982 D360  30        movb @XX18,ra                   ; LDA XX18          ; Set Q = dot_sidev_lo
     D984 007E     
33960 D986 D80D  30        movb ra,@Q                      ; STA Q
     D988 0090     
33961               
33962 D98A D360  30        movb @XX18+2,ra                 ; LDA XX18+2        ; Set A = dot_sidev_sign
     D98C 0080     
33963               
33964 D98E 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     D990 D39A     
33965 D992 06A0  32        bl   @jsr                       ;
     D994 FE1E     
33966                                                                          ; = normal_x + dot_sidev
33967                                                                          ;
33968                                                                          ; setting the sign of the result in S
33969               
33970 D996 18AC  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33971                                                                          ; both the normal vector and dot products by 2 and try
33972                                                                          ; again
33973               
33974 D998 D80D  30        movb ra,@XX15                   ; STA XX15          ; Set XX15(1 0) = (S A)
     D99A 0031     
33975 D99C D360  30        movb @S,ra                      ; LDA S             ; = normal_x + dot_sidev
     D99E 0092     
33976 D9A0 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D9A2 0032     
33977               
33978 D9A4 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = normal_y
     D9A6 0033     
33979 D9A8 D80D  30        movb ra,@R                      ; STA R
     D9AA 0091     
33980               
33981 D9AC D360  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set S = normal_y_sign
     D9AE 003A     
33982 D9B0 D80D  30        movb ra,@S                      ; STA S
     D9B2 0092     
33983               
33984 D9B4 D360  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set Q = dot_roofv_lo
     D9B6 0081     
33985 D9B8 D80D  30        movb ra,@Q                      ; STA Q
     D9BA 0090     
33986               
33987 D9BC D360  30        movb @XX18+5,ra                 ; LDA XX18+5        ; Set A = dot_roofv_sign
     D9BE 0083     
33988               
33989 D9C0 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     D9C2 D39A     
33990 D9C4 06A0  32        bl   @jsr                       ;
     D9C6 FE1E     
33991                                                                          ; = normal_y + dot_roofv
33992               
33993 D9C8 1893  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
33994                                                                          ; both the normal vector and dot products by 2 and try
33995                                                                          ; again
33996               
33997 D9CA D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15(3 2) = (S A)
     D9CC 0033     
33998 D9CE D360  30        movb @S,ra                      ; LDA S             ; = normal_y + dot_roofv
     D9D0 0092     
33999 D9D2 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     D9D4 0034     
34000               
34001               LL89:
34002                                                                          ; When we get here, we have set up the following:
34003                                                                          ;
34004                                                                          ; XX15(1 0) = normal_x + dot_sidev
34005                                                                          ; = normal_x + [x y z] . sidev
34006                                                                          ;
34007                                                                          ; XX15(3 2) = normal_y + dot_roofv
34008                                                                          ; = normal_y + [x y z] . roofv
34009                                                                          ;
34010                                                                          ; XX15(5 4) = normal_z + dot_nosev
34011                                                                          ; = normal_z + [x y z] . nosev
34012                                                                          ;
34013                                                                          ; and:
34014                                                                          ;
34015                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
34016                                                                          ;
34017                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
34018                                                                          ;
34019                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
34020                                                                          ;
34021                                                                          ; We now calculate the dot product XX12 . XX15 to tell
34022                                                                          ; us whether or not this face is visible
34023 D9D6 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set Q = XX12
     D9D8 0037     
34024 D9DA D80D  30        movb ra,@Q                      ; STA Q
     D9DC 0090     
34025               
34026 D9DE D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     D9E0 0031     
34027               
34028 D9E2 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     D9E4 4338     
34029 D9E6 06A0  32        bl   @jsr                       ;
     D9E8 FE1E     
34030 D9EA D80D  30        movb ra,@T                      ; STA T             ; = XX15 * XX12 / 256
     D9EC 00D1     
34031               
34032 D9EE D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = sign of XX15(1 0) * XX12(1 0), so:
     D9F0 0038     
34033                      .eor @XX15+1                    ; EOR XX15+1        ;
     **** ****     > EOR
0001 D9F2 D020  30        movb @XX15+1,rtmp
     D9F4 0032     
0002 D9F6 2B40  18        xor  rtmp,ra
                   < elite.a99
34034 D9F8 D80D  30        movb ra,@S                      ; STA S             ; (S T) = XX15(1 0) * XX12(1 0) / 256
     D9FA 0092     
34035               
34036 D9FC D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set Q = XX12+2
     D9FE 0039     
34037 DA00 D80D  30        movb ra,@Q                      ; STA Q
     DA02 0090     
34038               
34039 DA04 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     DA06 0033     
34040               
34041 DA08 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     DA0A 4338     
34042 DA0C 06A0  32        bl   @jsr                       ;
     DA0E FE1E     
34043 DA10 D80D  30        movb ra,@Q                      ; STA Q             ; = XX15+2 * XX12+2 / 256
     DA12 0090     
34044               
34045 DA14 D360  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     DA16 00D1     
34046 DA18 D80D  30        movb ra,@R                      ; STA R             ;
     DA1A 0091     
34047                                                                          ; (S R) = XX15(1 0) * XX12(1 0) / 256
34048               
34049 DA1C D360  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set A = sign of XX15+3 * XX12+3, so:
     DA1E 003A     
34050                      .eor @XX15+3                    ; EOR XX15+3        ;
     **** ****     > EOR
0001 DA20 D020  30        movb @XX15+3,rtmp
     DA22 0034     
0002 DA24 2B40  18        xor  rtmp,ra
                   < elite.a99
34051                                                                          ; (A Q) = XX15(3 2) * XX12(3 2) / 256
34052               
34053 DA26 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     DA28 D39A     
34054 DA2A 06A0  32        bl   @jsr                       ;
     DA2C FE1E     
34055 DA2E D80D  30        movb ra,@T                      ; STA T             ; =   XX15(1 0) * XX12(1 0) / 256
     DA30 00D1     
34056                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34057               
34058 DA32 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = XX12+4
     DA34 003B     
34059 DA36 D80D  30        movb ra,@Q                      ; STA Q
     DA38 0090     
34060               
34061 DA3A D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set A = XX15+4
     DA3C 0035     
34062               
34063 DA3E 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     DA40 4338     
34064 DA42 06A0  32        bl   @jsr                       ;
     DA44 FE1E     
34065 DA46 D80D  30        movb ra,@Q                      ; STA Q             ; = XX15+4 * XX12+4 / 256
     DA48 0090     
34066               
34067 DA4A D360  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     DA4C 00D1     
34068 DA4E D80D  30        movb ra,@R                      ; STA R             ;
     DA50 0091     
34069                                                                          ; (S R) =   XX15(1 0) * XX12(1 0) / 256
34070                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34071               
34072 DA52 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = sign of XX15+5 * XX12+5, so:
     DA54 0036     
34073                      .eor @XX12+5                    ; EOR XX12+5        ;
     **** ****     > EOR
0001 DA56 D020  30        movb @XX12+5,rtmp
     DA58 003C     
0002 DA5A 2B40  18        xor  rtmp,ra
                   < elite.a99
34074                                                                          ; (A Q) = XX15(5 4) * XX12(5 4) / 256
34075               
34076 DA5C 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     DA5E D39A     
34077 DA60 06A0  32        bl   @jsr                       ;
     DA62 FE1E     
34078                                                                          ; =   XX15(1 0) * XX12(1 0) / 256
34079                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34080                                                                          ; + XX15(5 4) * XX12(5 4) / 256
34081               
34082                      .pha                            ; PHA               ; Push the result A onto the stack, so the stack now
     **** ****     > PHA
0001 DA64 D68D  30        movb ra,*rsp
0002 DA66 060A  14        dec  rsp
                   < elite.a99
34083                                                                          ; contains the dot product XX12 . XX15
34084               
34085 DA68 D34F  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
34086 DA6A 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
34087 DA6C 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face
34088 DA6E D38D  18        movb ra,rx                      ; TAX
34089               
34090                      .pla                            ; PLA               ; Pull the dot product off the stack into A
     **** ****     > PLA
0001 DA70 058A  14        inc  rsp
0002 DA72 D35A  26        movb *rsp,ra
                   < elite.a99
34091               
34092                      .bit @S                         ; BIT S             ; If bit 7 of S is set, i.e. the dot product is
     **** ****     > BIT
0001 DA74 D020  30        movb @S,rtmp
     DA76 0092     
0002 DA78 0540  14        inv  rtmp
0003 DA7A D047  18        movb rone,rtmp2
0004 DA7C 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34093 DA7E 1102  14        jlt  B112                       ; BMI B112          ; negative, then this face is visible as its normal is
34094                                                                          ; pointing towards us, so skip the following instruction
34095               
34096 DA80 020D  20        li   ra,>00*256                 ; LDA #0            ; Otherwise the face is not visible, so set A = 0 so we
     DA82 0000     
34097                                                                          ; can store this to mean "not visible"
34098               
34099               B112:
34100 DA84 DB8D  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Store the face's visibility in the X-th byte of XX2
     DA86 00D2     
34101               
34102 DA88 B3C7  18        ab   rone,ry                    ; INY               ; Above we incremented Y to point to byte #3, so this
34103                                                                          ; increments Y to point to byte #4, i.e. byte #0 of the
34104                                                                          ; next face
34105               
34106               LL88:
34107 DA8A 93E0  30        cb   @XX20,ry                   ; CPY XX20          ; If Y >= XX20, the number of faces * 4, jump down to
     DA8C 00A8     
34108 DA8E 1802  14        joc  LL42                       ; BCS LL42          ; LL42 to move on to the
34109               
34110 DA90 0460  28        b    @LL86                      ; JMP LL86          ; Otherwise loop back to LL86 to work out the visibility
     DA92 D822     
34111                                                                          ; of the next face
34112               
34113               * ******************************************************************************
34114               *
34115               * Name: LL9 (Part 6 of 12)
34116               * Type: Subroutine
34117               * Category: Drawing ships
34118               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
34119               * Deep dive: Drawing ships
34120               * Calculating vertex coordinates
34121               *
34122               * ------------------------------------------------------------------------------
34123               *
34124               * This section calculates the visibility of each of the ship's vertices, and for
34125               * those that are visible, it starts the process of calculating the screen
34126               * coordinates of each vertex
34127               *
34128               * ******************************************************************************
34129               
34130               LL42:
34131                                                                          ; The first task is to set up the inverse matrix, ready
34132                                                                          ; for us to send to the dot product routine at LL51.
34133                                                                          ; Back up in part 3, we set up the following variables:
34134                                                                          ;
34135                                                                          ; * XX16(1 0) = sidev_x
34136                                                                          ; * XX16(3 2) = sidev_y
34137                                                                          ; * XX16(5 4) = sidev_z
34138                                                                          ;
34139                                                                          ; * XX16(7 6) = roofv_x
34140                                                                          ; * XX16(9 8) = roofv_y
34141                                                                          ; * XX16(11 10) = roofv_z
34142                                                                          ;
34143                                                                          ; * XX16(13 12) = nosev_x
34144                                                                          ; * XX16(15 14) = nosev_y
34145                                                                          ; * XX16(17 16) = nosev_z
34146                                                                          ;
34147                                                                          ; and we then scaled the vectors to give the following:
34148                                                                          ;
34149                                                                          ; * XX16   = scaled |sidev_x|
34150                                                                          ; * XX16+2 = scaled |sidev_y|
34151                                                                          ; * XX16+4 = scaled |sidev_z|
34152                                                                          ;
34153                                                                          ; * XX16+6  = scaled |roofv_x|
34154                                                                          ; * XX16+8  = scaled |roofv_y|
34155                                                                          ; * XX16+10 = scaled |roofv_z|
34156                                                                          ;
34157                                                                          ; * XX16+12 = scaled |nosev_x|
34158                                                                          ; * XX16+14 = scaled |nosev_y|
34159                                                                          ; * XX16+16 = scaled |nosev_z|
34160                                                                          ;
34161                                                                          ; We now need to rearrange these locations so they
34162                                                                          ; effectively transpose the matrix into its inverse
34163 DA94 D3E0  30        movb @XX16+2,ry                 ; LDY XX16+2        ; Set XX16+2 = XX16+6 = scaled |roofv_x|
     DA96 000B     
34164 DA98 D3A0  30        movb @XX16+3,rx                 ; LDX XX16+3        ; Set XX16+3 = XX16+7 = roofv_x_hi
     DA9A 000C     
34165 DA9C D360  30        movb @XX16+6,ra                 ; LDA XX16+6        ; Set XX16+6 = XX16+2 = scaled |sidev_y|
     DA9E 000F     
34166 DAA0 D80D  30        movb ra,@XX16+2                 ; STA XX16+2        ; Set XX16+7 = XX16+3 = sidev_y_hi
     DAA2 000B     
34167 DAA4 D360  30        movb @XX16+7,ra                 ; LDA XX16+7
     DAA6 0010     
34168 DAA8 D80D  30        movb ra,@XX16+3                 ; STA XX16+3
     DAAA 000C     
34169 DAAC D80F  30        movb ry,@XX16+6                 ; STY XX16+6
     DAAE 000F     
34170 DAB0 D80E  30        movb rx,@XX16+7                 ; STX XX16+7
     DAB2 0010     
34171               
34172 DAB4 D3E0  30        movb @XX16+4,ry                 ; LDY XX16+4        ; Set XX16+4 = XX16+12 = scaled |nosev_x|
     DAB6 000D     
34173 DAB8 D3A0  30        movb @XX16+5,rx                 ; LDX XX16+5        ; Set XX16+5 = XX16+13 = nosev_x_hi
     DABA 000E     
34174 DABC D360  30        movb @XX16+12,ra                ; LDA XX16+12       ; Set XX16+12 = XX16+4 = scaled |sidev_z|
     DABE 0015     
34175 DAC0 D80D  30        movb ra,@XX16+4                 ; STA XX16+4        ; Set XX16+13 = XX16+5 = sidev_z_hi
     DAC2 000D     
34176 DAC4 D360  30        movb @XX16+13,ra                ; LDA XX16+13
     DAC6 0016     
34177 DAC8 D80D  30        movb ra,@XX16+5                 ; STA XX16+5
     DACA 000E     
34178 DACC D80F  30        movb ry,@XX16+12                ; STY XX16+12
     DACE 0015     
34179 DAD0 D80E  30        movb rx,@XX16+13                ; STX XX16+13
     DAD2 0016     
34180               
34181 DAD4 D3E0  30        movb @XX16+10,ry                ; LDY XX16+10       ; Set XX16+10 = XX16+14 = scaled |nosev_y|
     DAD6 0013     
34182 DAD8 D3A0  30        movb @XX16+11,rx                ; LDX XX16+11       ; Set XX16+11 = XX16+15 = nosev_y_hi
     DADA 0014     
34183 DADC D360  30        movb @XX16+14,ra                ; LDA XX16+14       ; Set XX16+14 = XX16+10 = scaled |roofv_z|
     DADE 0017     
34184 DAE0 D80D  30        movb ra,@XX16+10                ; STA XX16+10       ; Set XX16+15 = XX16+11 = roofv_z
     DAE2 0013     
34185 DAE4 D360  30        movb @XX16+15,ra                ; LDA XX16+15
     DAE6 0018     
34186 DAE8 D80D  30        movb ra,@XX16+11                ; STA XX16+11
     DAEA 0014     
34187 DAEC D80F  30        movb ry,@XX16+14                ; STY XX16+14
     DAEE 0017     
34188 DAF0 D80E  30        movb rx,@XX16+15                ; STX XX16+15
     DAF2 0018     
34189               
34190                                                                          ; So now we have the following sign-magnitude variables
34191                                                                          ; containing parts of the scaled orientation vectors:
34192                                                                          ;
34193                                                                          ; XX16(1 0)   = scaled sidev_x
34194                                                                          ; XX16(3 2)   = scaled roofv_x
34195                                                                          ; XX16(5 4)   = scaled nosev_x
34196                                                                          ;
34197                                                                          ; XX16(7 6)   = scaled sidev_y
34198                                                                          ; XX16(9 8)   = scaled roofv_y
34199                                                                          ; XX16(11 10) = scaled nosev_y
34200                                                                          ;
34201                                                                          ; XX16(13 12) = scaled sidev_z
34202                                                                          ; XX16(15 14) = scaled roofv_z
34203                                                                          ; XX16(17 16) = scaled nosev_z
34204                                                                          ;
34205                                                                          ; which is what we want, as the various vectors are now
34206                                                                          ; arranged so we can use LL51 to multiply by the
34207                                                                          ; transpose (i.e. the inverse of the matrix)
34208               
34209 DAF4 020F  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 of the ship's blueprint, which is the
     DAF6 0800     
34210                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of vertices * 8, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 DAF8 D820  50        movb @XX0,@rtmplb
     DAFA 001E     
     DAFC 206D     
0002 DAFE D020  30        movb @XX0+1,rtmp
     DB00 001F     
0003 DB02 A00F  18        a    ry,rtmp
0004 DB04 D350  26        movb *rtmp,RA
                   < elite.a99
34211 DB06 D80D  30        movb ra,@XX20                   ; STA XX20
     DB08 00A8     
34212               
34213                                                                          ; We now set V(1 0) = XX0(1 0) + 20, so V(1 0) points
34214                                                                          ; to byte #20 of the ship's blueprint, which is always
34215                                                                          ; where the vertex data starts (i.e. just after the 20
34216                                                                          ; byte block that define the ship's characteristics)
34217               
34218 DB0A D360  30        movb @XX0,ra                    ; LDA XX0           ; We start with the low bytes
     DB0C 001E     
34219                      .clc                            ; CLC
     **** ****     > CLC
0001 DB0E 0A16  18        sla  rzero,1
                   < elite.a99
34220                      .adi (>14*256)                  ; ADC #20
     **** ****     > ADI
0001 DB10 1701  14        jnc  !
0002 DB12 B347  18        ab   rone,ra
0003               !:
0004 DB14 022D  22        ai   ra,(>14*256)
     DB16 1400     
                   < elite.a99
34221 DB18 D80D  30        movb ra,@V                      ; STA V
     DB1A 0022     
34222               
34223 DB1C D360  30        movb @XX0+1,ra                  ; LDA XX0+1         ; And then do the high bytes
     DB1E 001F     
34224                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 DB20 1701  14        jnc  !
0002 DB22 B347  18        ab   rone,ra
0003               !:
0004 DB24 022D  22        ai   ra,(>00*256)
     DB26 0000     
                   < elite.a99
34225 DB28 D80D  30        movb ra,@V+1                    ; STA V+1
     DB2A 0023     
34226               
34227 DB2C 020F  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the vertices, using
     DB2E 0000     
34228                                                                          ; Y as a counter. There are six data bytes for each
34229                                                                          ; vertex, so we will increment Y by 6 for each iteration
34230                                                                          ; so it can act as an offset from V(1 0) to the current
34231                                                                          ; vertex's data
34232               
34233 DB30 D80F  30        movb ry,@CNT                    ; STY CNT           ; Set CNT = 0, which we will use as a pointer to the
     DB32 00A4     
34234                                                                          ; heap at XX3, starting it at zero so the heap starts
34235                                                                          ; out empty
34236               
34237               LL48:
34238 DB34 D80F  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = Y, so XX17 now contains the offset of the
     DB36 0095     
34239                                                                          ; current vertex's data
34240               
34241                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this vertex into XX15, so:
     **** ****     > LD_IND_Y_IDX
0001 DB38 D820  50        movb @V,@rtmplb
     DB3A 0022     
     DB3C 206D     
0002 DB3E D020  30        movb @V+1,rtmp
     DB40 0023     
0003 DB42 A00F  18        a    ry,rtmp
0004 DB44 D350  26        movb *rtmp,RA
                   < elite.a99
34242 DB46 D80D  30        movb ra,@XX15                   ; STA XX15          ;
     DB48 0031     
34243                                                                          ; XX15 = magnitude of the vertex's x-coordinate
34244               
34245 DB4A B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
34246               
34247                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this vertex into XX15+2, so:
     **** ****     > LD_IND_Y_IDX
0001 DB4C D820  50        movb @V,@rtmplb
     DB4E 0022     
     DB50 206D     
0002 DB52 D020  30        movb @V+1,rtmp
     DB54 0023     
0003 DB56 A00F  18        a    ry,rtmp
0004 DB58 D350  26        movb *rtmp,RA
                   < elite.a99
34248 DB5A D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ;
     DB5C 0033     
34249                                                                          ; XX15+2 = magnitude of the vertex's y-coordinate
34250               
34251 DB5E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
34252               
34253                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this vertex into XX15+4, so:
     **** ****     > LD_IND_Y_IDX
0001 DB60 D820  50        movb @V,@rtmplb
     DB62 0022     
     DB64 206D     
0002 DB66 D020  30        movb @V+1,rtmp
     DB68 0023     
0003 DB6A A00F  18        a    ry,rtmp
0004 DB6C D350  26        movb *rtmp,RA
                   < elite.a99
34254 DB6E D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ;
     DB70 0035     
34255                                                                          ; XX15+4 = magnitude of the vertex's z-coordinate
34256               
34257 DB72 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
34258               
34259                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this vertex into T, so:
     **** ****     > LD_IND_Y_IDX
0001 DB74 D820  50        movb @V,@rtmplb
     DB76 0022     
     DB78 206D     
0002 DB7A D020  30        movb @V+1,rtmp
     DB7C 0023     
0003 DB7E A00F  18        a    ry,rtmp
0004 DB80 D350  26        movb *rtmp,RA
                   < elite.a99
34260 DB82 D80D  30        movb ra,@T                      ; STA T             ;
     DB84 00D1     
34261                                                                          ; T = %xyz vvvvv, where:
34262                                                                          ;
34263                                                                          ; * Bits 0-4 = visibility distance, beyond which the
34264                                                                          ; vertex is not shown
34265                                                                          ;
34266                                                                          ; * Bits 7-5 = the sign bits of x, y and z
34267               
34268 DB86 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to get the visibility distance
     DB88 1F00     
34269               
34270 DB8A 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     DB8C 00A7     
34271 DB8E 1734  14        jnc  LL49-3                     ; BCC LL49-3        ; the ship's z-distance reduced to 0-31 (which we set in
34272                                                                          ; part 2), then this vertex is too far away to be
34273                                                                          ; visible, so jump down to LL50 (via the JMP instruction
34274                                                                          ; in LL49-3) to move on to the next vertex
34275               
34276 DB90 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #4
34277               
34278                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #4 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 DB92 D820  50        movb @V,@rtmplb
     DB94 0022     
     DB96 206D     
0002 DB98 D020  30        movb @V+1,rtmp
     DB9A 0023     
0003 DB9C A00F  18        a    ry,rtmp
0004 DB9E D350  26        movb *rtmp,RA
                   < elite.a99
34279 DBA0 D80D  30        movb ra,@P                      ; STA P             ;
     DBA2 001B     
34280                                                                          ; P = %ffff ffff, where:
34281                                                                          ;
34282                                                                          ; * Bits 0-3 = the number of face 1
34283                                                                          ;
34284                                                                          ; * Bits 4-7 = the number of face 2
34285               
34286 DBA4 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     DBA6 0F00     
34287 DBA8 D38D  18        movb ra,rx                      ; TAX
34288               
34289 DBAA D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DBAC 00D2     
34290 DBAE 1626  14        jne  LL49                       ; BNE LL49          ; face 1 is visible, so jump to LL49
34291               
34292 DBB0 D360  30        movb @P,ra                      ; LDA P             ; Fetch byte #4 for this vertex into A
     DBB2 001B     
34293               
34294 DBB4 091D  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
34295 DBB6 091D  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
34296 DBB8 091D  18        srl  ra,1                       ; LSR A
34297 DBBA 091D  18        srl  ra,1                       ; LSR A
34298 DBBC D38D  18        movb ra,rx                      ; TAX
34299               
34300 DBBE D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DBC0 00D2     
34301 DBC2 161C  14        jne  LL49                       ; BNE LL49          ; face 2 is visible, so jump to LL49
34302               
34303 DBC4 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #5
34304               
34305                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #5 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 DBC6 D820  50        movb @V,@rtmplb
     DBC8 0022     
     DBCA 206D     
0002 DBCC D020  30        movb @V+1,rtmp
     DBCE 0023     
0003 DBD0 A00F  18        a    ry,rtmp
0004 DBD2 D350  26        movb *rtmp,RA
                   < elite.a99
34306 DBD4 D80D  30        movb ra,@P                      ; STA P             ;
     DBD6 001B     
34307                                                                          ; P = %ffff ffff, where:
34308                                                                          ;
34309                                                                          ; * Bits 0-3 = the number of face 3
34310                                                                          ;
34311                                                                          ; * Bits 4-7 = the number of face 4
34312               
34313 DBD8 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     DBDA 0F00     
34314 DBDC D38D  18        movb ra,rx                      ; TAX
34315               
34316 DBDE D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DBE0 00D2     
34317 DBE2 160C  14        jne  LL49                       ; BNE LL49          ; face 3 is visible, so jump to LL49
34318               
34319 DBE4 D360  30        movb @P,ra                      ; LDA P             ; Fetch byte #5 for this vertex into A
     DBE6 001B     
34320               
34321 DBE8 091D  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 4
34322 DBEA 091D  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
34323 DBEC 091D  18        srl  ra,1                       ; LSR A
34324 DBEE 091D  18        srl  ra,1                       ; LSR A
34325 DBF0 D38D  18        movb ra,rx                      ; TAX
34326               
34327 DBF2 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     DBF4 00D2     
34328 DBF6 1602  14        jne  LL49                       ; BNE LL49          ; face 4 is visible, so jump to LL49
34329               
34330 DBF8 0460  28        b    @LL50                      ; JMP LL50          ; If we get here then none of the four faces associated
     DBFA DF44     
34331                                                                          ; with this vertex are visible, so this vertex is also
34332                                                                          ; not visible, so jump to LL50 to move on to the next
34333                                                                          ; vertex
34334               
34335               LL49:
34336 DBFC D360  30        movb @T,ra                      ; LDA T             ; Fetch byte #5 for this vertex into A and store it, so
     DBFE 00D1     
34337 DC00 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; XX15+1 now has the sign of the vertex's x-coordinate
     DC02 0032     
34338               
34339                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+3 now has the sign
     **** ****     > ASLA
0001 DC04 024D  22        andi ra,>ff00
     DC06 FF00     
0002 DC08 0A1D  18        sla  ra,1
                   < elite.a99
34340 DC0A D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; of the vertex's y-coordinate
     DC0C 0034     
34341               
34342                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+5 now has the sign
     **** ****     > ASLA
0001 DC0E 024D  22        andi ra,>ff00
     DC10 FF00     
0002 DC12 0A1D  18        sla  ra,1
                   < elite.a99
34343 DC14 D80D  30        movb ra,@XX15+5                 ; STA XX15+5        ; of the vertex's z-coordinate
     DC16 0036     
34344               
34345                                                                          ; By this point we have the following:
34346                                                                          ;
34347                                                                          ; XX15(1 0) = vertex x-coordinate
34348                                                                          ; XX15(3 2) = vertex y-coordinate
34349                                                                          ; XX15(5 4) = vertex z-coordinate
34350                                                                          ;
34351                                                                          ; XX16(1 0)   = scaled sidev_x
34352                                                                          ; XX16(3 2)   = scaled roofv_x
34353                                                                          ; XX16(5 4)   = scaled nosev_x
34354                                                                          ;
34355                                                                          ; XX16(7 6)   = scaled sidev_y
34356                                                                          ; XX16(9 8)   = scaled roofv_y
34357                                                                          ; XX16(11 10) = scaled nosev_y
34358                                                                          ;
34359                                                                          ; XX16(13 12) = scaled sidev_z
34360                                                                          ; XX16(15 14) = scaled roofv_z
34361                                                                          ; XX16(17 16) = scaled nosev_z
34362               
34363 DC18 0200  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     DC1A D3F2     
34364 DC1C 06A0  32        bl   @jsr                       ;
     DC1E FE1E     
34365                                                                          ; XX16, as follows:
34366                                                                          ;
34367                                                                          ; XX12(1 0) = [ x y z ] . [ sidev_x roofv_x nosev_x ]
34368                                                                          ;
34369                                                                          ; XX12(3 2) = [ x y z ] . [ sidev_y roofv_y nosev_y ]
34370                                                                          ;
34371                                                                          ; XX12(5 4) = [ x y z ] . [ sidev_z roofv_z nosev_z ]
34372                                                                          ;
34373                                                                          ; XX12 contains the vector from the ship's centre to
34374                                                                          ; the vertex, transformed from the orientation vector
34375                                                                          ; space to the universe orientated around our ship. So
34376                                                                          ; we can refer to this vector below, let's call it
34377                                                                          ; vertv, so:
34378                                                                          ;
34379                                                                          ; vertv_x = [ x y z ] . [ sidev_x roofv_x nosev_x ]
34380                                                                          ;
34381                                                                          ; vertv_y = [ x y z ] . [ sidev_y roofv_y nosev_y ]
34382                                                                          ;
34383                                                                          ; vertv_z = [ x y z ] . [ sidev_z roofv_z nosev_z ]
34384                                                                          ;
34385                                                                          ; To finish the calculation, we now want to calculate:
34386                                                                          ;
34387                                                                          ; vertv + [ x y z ]
34388                                                                          ;
34389                                                                          ; So let's start with the vertv_x + x
34390               
34391 DC20 D360  30        movb @XX1+2,ra                  ; LDA XX1+2         ; Set A = x_sign of the ship's location
     DC22 0055     
34392               
34393 DC24 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 = x_sign
     DC26 0033     
34394               
34395                      .eor @XX12+1                    ; EOR XX12+1        ; If the sign of x_sign * the sign of vertv_x is
     **** ****     > EOR
0001 DC28 D020  30        movb @XX12+1,rtmp
     DC2A 0038     
0002 DC2C 2B40  18        xor  rtmp,ra
                   < elite.a99
34396 DC2E 1113  14        jlt  LL52                       ; BMI LL52          ; negative (i.e. they have different signs), skip to
34397                                                                          ; LL52
34398               
34399                      .clc                            ; CLC               ; Set XX15(2 1 0) = XX1(2 1 0) + XX12(1 0)
     **** ****     > CLC
0001 DC30 0A16  18        sla  rzero,1
                   < elite.a99
34400 DC32 D360  30        movb @XX12,ra                   ; LDA XX12          ; = (x_sign x_hi x_lo) + vertv_x
     DC34 0037     
34401                      .adc @XX1,ra                    ; ADC XX1           ;
     **** ****     > ADC
0001 DC36 1701  14        jnc  !
0002 DC38 B347  18        ab   rone,ra
0003               !:
0004 DC3A B360  30        ab   @XX1,ra
     DC3C 0053     
                   < elite.a99
34402 DC3E D80D  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     DC40 0031     
34403               
34404 DC42 D360  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can add 0 here as
     DC44 0054     
34405                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_x is 0)
     **** ****     > ADI
0001 DC46 1701  14        jnc  !
0002 DC48 B347  18        ab   rone,ra
0003               !:
0004 DC4A 022D  22        ai   ra,(>00*256)
     DC4C 0000     
                   < elite.a99
34406 DC4E D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     DC50 0032     
34407               
34408 DC52 0460  28        b    @LL53                      ; JMP LL53          ; We've added the x-coordinates, so jump to LL53 to do
     DC54 DCA6     
34409                                                                          ; the y-coordinates
34410               
34411               LL52:
34412                                                                          ; If we get here then x_sign and vertv_x have different
34413                                                                          ; signs, so we need to subtract them to get the result
34414 DC56 D360  30        movb @XX1,ra                    ; LDA XX1           ; Set XX15(2 1 0) = XX1(2 1 0) - XX12(1 0)
     DC58 0053     
34415                      .sec                            ; SEC               ; = (x_sign x_hi x_lo) - vertv_x
     **** ****     > SEC
0001 DC5A 0A18  18        sla  rmone,1
                   < elite.a99
34416                      .sbc @XX12,ra                   ; SBC XX12          ;
     **** ****     > SBC
0001 DC5C 1801  14        joc  !
0002 DC5E 7347  18        sb   rone,ra
0003               !:
0004 DC60 7360  30        sb   @XX12,ra
     DC62 0037     
                   < elite.a99
34417 DC64 D80D  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     DC66 0031     
34418               
34419 DC68 D360  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can subtract 0 here
     DC6A 0054     
34420                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_x is 0)
     **** ****     > SBI
0001 DC6C 1801  14        joc  !
0002 DC6E 7347  18        sb   rone,ra
0003               !:
0004 DC70 022D  22        ai   ra,-(>00*256)
     DC72 0000     
                   < elite.a99
34421 DC74 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     DC76 0032     
34422               
34423 DC78 1816  14        joc  LL53                       ; BCS LL53          ; If the subtraction didn't underflow, then the sign of
34424                                                                          ; the result is the same sign as x_sign, and that's what
34425                                                                          ; we want, so we can jump down to LL53 to do the
34426                                                                          ; y-coordinates
34427               
34428                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 DC7A 0200  20        li   rtmp,(>FF*256)
     DC7C FF00     
0002 DC7E 2B40  18        xor  rtmp,ra
                   < elite.a99
34429 DC80 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; complement, so first we flip the bits of the high byte
     DC82 0032     
34430               
34431 DC84 020D  20        li   ra,>01*256                 ; LDA #1            ; And then subtract the low byte from 1
     DC86 0100     
34432                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 DC88 1801  14        joc  !
0002 DC8A 7347  18        sb   rone,ra
0003               !:
0004 DC8C 7360  30        sb   @XX15,ra
     DC8E 0031     
                   < elite.a99
34433 DC90 D80D  30        movb ra,@XX15                   ; STA XX15
     DC92 0031     
34434               
34435 DC94 1701  14        jnc  B113                       ; BCC B113          ; If the above subtraction underflowed then we need to
34436 DC96 B347  18        ab   rone,ra                    ; INC XX15+1        ; bump the high byte of the result up by 1
34437               
34438               B113:
34439 DC98 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And now we flip the sign of the result to get the
     DC9A 0033     
34440                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 DC9C 0200  20        li   rtmp,(>80*256)
     DC9E 8000     
0002 DCA0 2B40  18        xor  rtmp,ra
                   < elite.a99
34441 DCA2 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     DCA4 0033     
34442               
34443               LL53:
34444                                                                          ; Now for the y-coordinates, vertv_y + y
34445 DCA6 D360  30        movb @XX1+5,ra                  ; LDA XX1+5         ; Set A = y_sign of the ship's location
     DCA8 0058     
34446               
34447 DCAA D80D  30        movb ra,@XX15+5                 ; STA XX15+5        ; Set XX15+5 = y_sign
     DCAC 0036     
34448               
34449                      .eor @XX12+3                    ; EOR XX12+3        ; If the sign of y_sign * the sign of vertv_y is
     **** ****     > EOR
0001 DCAE D020  30        movb @XX12+3,rtmp
     DCB0 003A     
0002 DCB2 2B40  18        xor  rtmp,ra
                   < elite.a99
34450 DCB4 1113  14        jlt  LL54                       ; BMI LL54          ; negative (i.e. they have different signs), skip to
34451                                                                          ; LL54
34452               
34453                      .clc                            ; CLC               ; Set XX15(5 4 3) = XX1(5 4 3) + XX12(3 2)
     **** ****     > CLC
0001 DCB6 0A16  18        sla  rzero,1
                   < elite.a99
34454 DCB8 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; = (y_sign y_hi y_lo) + vertv_y
     DCBA 0039     
34455                      .adc @XX1+3,ra                  ; ADC XX1+3         ;
     **** ****     > ADC
0001 DCBC 1701  14        jnc  !
0002 DCBE B347  18        ab   rone,ra
0003               !:
0004 DCC0 B360  30        ab   @XX1+3,ra
     DCC2 0056     
                   < elite.a99
34456 DCC4 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     DCC6 0034     
34457               
34458 DCC8 D360  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can add 0 here as
     DCCA 0057     
34459                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 DCCC 1701  14        jnc  !
0002 DCCE B347  18        ab   rone,ra
0003               !:
0004 DCD0 022D  22        ai   ra,(>00*256)
     DCD2 0000     
                   < elite.a99
34460 DCD4 D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     DCD6 0035     
34461               
34462 DCD8 0460  28        b    @LL55                      ; JMP LL55          ; We've added the y-coordinates, so jump to LL55 to do
     DCDA DD32     
34463                                                                          ; the z-coordinates
34464               
34465               LL54:
34466                                                                          ; If we get here then y_sign and vertv_y have different
34467                                                                          ; signs, so we need to subtract them to get the result
34468 DCDC D360  30        movb @XX1+3,ra                  ; LDA XX1+3         ; Set XX15(5 4 3) = XX1(5 4 3) - XX12(3 2)
     DCDE 0056     
34469                      .sec                            ; SEC               ; = (y_sign y_hi y_lo) - vertv_y
     **** ****     > SEC
0001 DCE0 0A18  18        sla  rmone,1
                   < elite.a99
34470                      .sbc @XX12+2,ra                 ; SBC XX12+2        ;
     **** ****     > SBC
0001 DCE2 1801  14        joc  !
0002 DCE4 7347  18        sb   rone,ra
0003               !:
0004 DCE6 7360  30        sb   @XX12+2,ra
     DCE8 0039     
                   < elite.a99
34471 DCEA D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     DCEC 0034     
34472               
34473 DCEE D360  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can subtract 0 here
     DCF0 0057     
34474                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 DCF2 1801  14        joc  !
0002 DCF4 7347  18        sb   rone,ra
0003               !:
0004 DCF6 022D  22        ai   ra,-(>00*256)
     DCF8 0000     
                   < elite.a99
34475 DCFA D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     DCFC 0035     
34476               
34477 DCFE 1819  14        joc  LL55                       ; BCS LL55          ; If the subtraction didn't underflow, then the sign of
34478                                                                          ; the result is the same sign as y_sign, and that's what
34479                                                                          ; we want, so we can jump down to LL55 to do the
34480                                                                          ; z-coordinates
34481               
34482                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 DD00 0200  20        li   rtmp,(>FF*256)
     DD02 FF00     
0002 DD04 2B40  18        xor  rtmp,ra
                   < elite.a99
34483 DD06 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; complement, so first we flip the bits of the high byte
     DD08 0035     
34484               
34485 DD0A D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then flip the bits of the low byte and add 1
     DD0C 0034     
34486                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 DD0E 0200  20        li   rtmp,(>FF*256)
     DD10 FF00     
0002 DD12 2B40  18        xor  rtmp,ra
                   < elite.a99
34487                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 DD14 1701  14        jnc  !
0002 DD16 B347  18        ab   rone,ra
0003               !:
0004 DD18 022D  22        ai   ra,(>01*256)
     DD1A 0100     
                   < elite.a99
34488 DD1C D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     DD1E 0034     
34489               
34490 DD20 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; And now we flip the sign of the result to get the
     DD22 0036     
34491                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 DD24 0200  20        li   rtmp,(>80*256)
     DD26 8000     
0002 DD28 2B40  18        xor  rtmp,ra
                   < elite.a99
34492 DD2A D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     DD2C 0036     
34493               
34494 DD2E 1701  14        jnc  LL55                       ; BCC LL55          ; If the above subtraction underflowed then we need to
34495 DD30 B347  18        ab   rone,ra                    ; INC XX15+4        ; bump the high byte of the result up by 1
34496               
34497               LL55:
34498                                                                          ; Now for the z-coordinates, vertv_z + z
34499 DD32 D360  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If vertv_z_hi is negative, jump down to LL56
     DD34 003C     
34500 DD36 1151  14        jlt  LL56                       ; BMI LL56
34501               
34502 DD38 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set (U T) = XX1(7 6) + XX12(5 4)
     DD3A 003B     
34503                      .clc                            ; CLC               ; = (z_hi z_lo) + vertv_z
     **** ****     > CLC
0001 DD3C 0A16  18        sla  rzero,1
                   < elite.a99
34504                      .adc @XX1+6,ra                  ; ADC XX1+6         ;
     **** ****     > ADC
0001 DD3E 1701  14        jnc  !
0002 DD40 B347  18        ab   rone,ra
0003               !:
0004 DD42 B360  30        ab   @XX1+6,ra
     DD44 0059     
                   < elite.a99
34505 DD46 D80D  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     DD48 00D1     
34506               
34507 DD4A D360  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can add 0 here as
     DD4C 005A     
34508                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 DD4E 1701  14        jnc  !
0002 DD50 B347  18        ab   rone,ra
0003               !:
0004 DD52 022D  22        ai   ra,(>00*256)
     DD54 0000     
                   < elite.a99
34509 DD56 D80D  30        movb ra,@U                      ; STA U
     DD58 008F     
34510               
34511 DD5A 0460  28        b    @LL57                      ; JMP LL57          ; We've added the z-coordinates, so jump to LL57
     DD5C DE1A     
34512               
34513                                                                          ; The adding process is continued in part 7, after a
34514                                                                          ; couple of subroutines that we don't need quite yet
34515               
34516               * ******************************************************************************
34517               *
34518               * Name: LL61
34519               * Type: Subroutine
34520               * Category: Maths (Arithmetic)
34521               * Summary: Calculate (U R) = 256 * A / Q
34522               *
34523               * ------------------------------------------------------------------------------
34524               *
34525               * Calculate the following, where A >= Q:
34526               *
34527               * (U R) = 256 * A / Q
34528               *
34529               * This is a sister routine to LL28, which does the division when A < Q.
34530               *
34531               * ******************************************************************************
34532               
34533               LL61:
34534 DD5E D3A0  30        movb @Q,rx                      ; LDX Q             ; If Q = 0, jump down to LL84 to return a division
     DD60 0090     
34535 DD62 131F  14        jeq  LL84                       ; BEQ LL84          ; error
34536               
34537                                                                          ; The LL28 routine returns A / Q, but only if A < Q. In
34538                                                                          ; our case A >= Q, but we still want to use the LL28
34539                                                                          ; routine, so we halve A until it's less than Q, call
34540                                                                          ; the division routine, and then double A by the same
34541                                                                          ; number of times
34542               
34543 DD64 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0 to count the number of times we halve A
     DD66 0000     
34544               
34545               LL63:
34546 DD68 091D  18        srl  ra,1                       ; LSR A             ; Halve A by shifting right
34547               
34548 DD6A B387  18        ab   rone,rx                    ; INX               ; Increment X
34549               
34550 DD6C 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, loop back to LL63 to halve it again
     DD6E 0090     
34551 DD70 18FB  14        joc  LL63                       ; BCS LL63
34552               
34553 DD72 D80E  30        movb rx,@S                      ; STX S             ; Otherwise store the number of times we halved A in S
     DD74 0092     
34554               
34555 DD76 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     DD78 D344     
34556 DD7A 06A0  32        bl   @jsr                       ;
     DD7C FE1E     
34557                                                                          ;
34558                                                                          ; R = 256 * A / Q
34559                                                                          ;
34560                                                                          ; which we can do now as A < Q
34561               
34562 DD7E D3A0  30        movb @S,rx                      ; LDX S             ; Otherwise restore the number of times we halved A
     DD80 0092     
34563                                                                          ; above into X
34564               
34565 DD82 D360  30        movb @R,ra                      ; LDA R             ; Set A = our division result
     DD84 0091     
34566               
34567               LL64:
34568                      .asla                           ; ASL A             ; Double (U A) by shifting left
     **** ****     > ASLA
0001 DD86 024D  22        andi ra,>ff00
     DD88 FF00     
0002 DD8A 0A1D  18        sla  ra,1
                   < elite.a99
34569 DD8C 0204  20        li   rarg1,U                    ; ROL U
     DD8E 008F     
34570 DD90 06A0  32        bl   @rol                       ;
     DD92 FE44     
34571               
34572 DD94 1106  14        jlt  LL84                       ; BMI LL84          ; If bit 7 of U is set, the doubling has overflowed, so
34573                                                                          ; jump to LL84 to return a division error
34574               
34575 DD96 7387  18        sb   rone,rx                    ; DEX               ; Decrement X
34576               
34577 DD98 16F6  14        jne  LL64                       ; BNE LL64          ; If X is not yet zero then we haven't done as many
34578                                                                          ; doublings as we did halvings earlier, so loop back for
34579                                                                          ; another doubling
34580               
34581 DD9A D80D  30        movb ra,@R                      ; STA R             ; Store the low byte of the division result in R
     DD9C 0091     
34582               
34583 DD9E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DDA0 FE2A     
34584               
34585               LL84:
34586 DDA2 020D  20        li   ra,>32*256                 ; LDA #50           ; If we get here then either we tried to divide by 0, or
     DDA4 3200     
34587 DDA6 D80D  30        movb ra,@R                      ; STA R             ; the result overflowed, so we set U and R to 50
     DDA8 0091     
34588 DDAA D80D  30        movb ra,@U                      ; STA U
     DDAC 008F     
34589               
34590 DDAE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DDB0 FE2A     
34591               
34592               * ******************************************************************************
34593               *
34594               * Name: LL62
34595               * Type: Subroutine
34596               * Category: Maths (Arithmetic)
34597               * Summary: Calculate 128 - (U R)
34598               *
34599               * ------------------------------------------------------------------------------
34600               *
34601               * Calculate the following for a positive sign-magnitude number (U R):
34602               *
34603               * 128 - (U R)
34604               *
34605               * and then store the result, low byte then high byte, on the end of the heap at
34606               * XX3, where X points to the first free byte on the heap. Return by jumping down
34607               * to LL66.
34608               *
34609               * ------------------------------------------------------------------------------
34610               *
34611               * Returns:
34612               *
34613               * X                   X is incremented by 1
34614               *
34615               * ******************************************************************************
34616               
34617               LL62:
34618 DDB2 020D  20        li   ra,>80*256                 ; LDA #128          ; Calculate 128 - (U R), starting with the low bytes
     DDB4 8000     
34619                      .sec                            ; SEC
     **** ****     > SEC
0001 DDB6 0A18  18        sla  rmone,1
                   < elite.a99
34620                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 DDB8 1801  14        joc  !
0002 DDBA 7347  18        sb   rone,ra
0003               !:
0004 DDBC 7360  30        sb   @R,ra
     DDBE 0091     
                   < elite.a99
34621               
34622 DDC0 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DDC2 0100     
34623                                                                          ; the heap at XX3
34624               
34625 DDC4 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34626                                                                          ; byte
34627               
34628 DDC6 020D  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     DDC8 0000     
34629                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 DDCA 1801  14        joc  !
0002 DDCC 7347  18        sb   rone,ra
0003               !:
0004 DDCE 7360  30        sb   @U,ra
     DDD0 008F     
                   < elite.a99
34630               
34631 DDD2 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DDD4 0100     
34632                                                                          ; the heap at XX3
34633               
34634 DDD6 0460  28        b    @LL66                      ; JMP LL66          ; Jump down to LL66
     DDD8 DEB6     
34635               
34636               * ******************************************************************************
34637               *
34638               * Name: LL9 (Part 7 of 12)
34639               * Type: Subroutine
34640               * Category: Drawing ships
34641               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
34642               * Deep dive: Drawing ships
34643               * Calculating vertex coordinates
34644               *
34645               * ------------------------------------------------------------------------------
34646               *
34647               * This section continues the coordinate adding from part 6 by finishing off the
34648               * calculation that we started above:
34649               *
34650               * [ sidev_x roofv_x nosev_x ]   [ x ]   [ x ]
34651               * vector to vertex = [ sidev_y roofv_y nosev_y ] . [ y ] + [ y ]
34652               * [ sidev_z roofv_z nosev_z ]   [ z ]   [ z ]
34653               *
34654               * The gets stored as follows, in sign-magnitude values with the magnitudes
34655               * fitting into the low bytes:
34656               *
34657               * XX15(2 0)           [ x y z ] . [ sidev_x roofv_x nosev_x ] + [ x y z ]
34658               *
34659               * XX15(5 3)           [ x y z ] . [ sidev_y roofv_y nosev_y ] + [ x y z ]
34660               *
34661               * (U T)               [ x y z ] . [ sidev_z roofv_z nosev_z ] + [ x y z ]
34662               *
34663               * Finally, because this vector is from our ship to the vertex, and we are at the
34664               * origin, this vector is the same as the coordinates of the vertex. In other
34665               * words, we have just worked out:
34666               *
34667               * XX15(2 0)           x-coordinate of the current vertex
34668               *
34669               * XX15(5 3)           y-coordinate of the current vertex
34670               *
34671               * (U T)               z-coordinate of the current vertex
34672               *
34673               * ******************************************************************************
34674               
34675               LL56:
34676 DDDA D360  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (U T) = XX1(7 6) - XX12(5 4)
     DDDC 0059     
34677                      .sec                            ; SEC               ; = (z_hi z_lo) - vertv_z
     **** ****     > SEC
0001 DDDE 0A18  18        sla  rmone,1
                   < elite.a99
34678                      .sbc @XX12+4,ra                 ; SBC XX12+4        ;
     **** ****     > SBC
0001 DDE0 1801  14        joc  !
0002 DDE2 7347  18        sb   rone,ra
0003               !:
0004 DDE4 7360  30        sb   @XX12+4,ra
     DDE6 003B     
                   < elite.a99
34679 DDE8 D80D  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     DDEA 00D1     
34680               
34681 DDEC D360  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can subtract 0 here
     DDEE 005A     
34682                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 DDF0 1801  14        joc  !
0002 DDF2 7347  18        sb   rone,ra
0003               !:
0004 DDF4 022D  22        ai   ra,-(>00*256)
     DDF6 0000     
                   < elite.a99
34683 DDF8 D80D  30        movb ra,@U                      ; STA U
     DDFA 008F     
34684               
34685 DDFC 1706  14        jnc  LL140                      ; BCC LL140         ; If the subtraction just underflowed, skip to LL140 to
34686                                                                          ; set (U T) to the minimum value of 4
34687               
34688 DDFE 160D  14        jne  LL57                       ; BNE LL57          ; If U is non-zero, jump down to LL57
34689               
34690 DE00 D360  30        movb @T,ra                      ; LDA T             ; If T >= 4, jump down to LL57
     DE02 00D1     
34691 DE04 028D  22        ci   ra,>04*256                 ; CMP #4
     DE06 0400     
34692 DE08 1808  14        joc  LL57                       ; BCS LL57
34693               
34694               LL140:
34695 DE0A 020D  20        li   ra,>00*256                 ; LDA #0            ; If we get here then either (U T) < 4 or the
     DE0C 0000     
34696 DE0E D80D  30        movb ra,@U                      ; STA U             ; subtraction underflowed, so set (U T) = 4
     DE10 008F     
34697 DE12 020D  20        li   ra,>04*256                 ; LDA #4
     DE14 0400     
34698 DE16 D80D  30        movb ra,@T                      ; STA T
     DE18 00D1     
34699               
34700               LL57:
34701                                                                          ; By this point we have our results, so now to scale
34702                                                                          ; the 16-bit results down into 8-bit values
34703 DE1A D360  30        movb @U,ra                      ; LDA U             ; If the high bytes of the result are all zero, we are
     DE1C 008F     
34704 DE1E F360  30        socb @XX15+1,ra                 ; ORA XX15+1        ; done, so jump down to LL60 for the next stage
     DE20 0032     
34705 DE22 F360  30        socb @XX15+4,ra                 ; ORA XX15+4
     DE24 0035     
34706 DE26 131D  14        jeq  LL60                       ; BEQ LL60
34707               
34708                      .lsr @XX15+1                    ; LSR XX15+1        ; Shift XX15(1 0) to the right
     **** ****     > LSR
0001 DE28 D020  30        movb @XX15+1,rtmp
     DE2A 0032     
0002 DE2C 0910  18        srl  rtmp,1
0003 DE2E D800  30        movb rtmp,@XX15+1
     DE30 0032     
                   < elite.a99
34709 DE32 0204  20        li   rarg1,XX15                 ; ROR XX15
     DE34 0031     
34710 DE36 06A0  32        bl   @ror                       ;
     DE38 FE70     
34711               
34712                      .lsr @XX15+4                    ; LSR XX15+4        ; Shift XX15(4 3) to the right
     **** ****     > LSR
0001 DE3A D020  30        movb @XX15+4,rtmp
     DE3C 0035     
0002 DE3E 0910  18        srl  rtmp,1
0003 DE40 D800  30        movb rtmp,@XX15+4
     DE42 0035     
                   < elite.a99
34713 DE44 0204  20        li   rarg1,XX15+3               ; ROR XX15+3
     DE46 0034     
34714 DE48 06A0  32        bl   @ror                       ;
     DE4A FE70     
34715               
34716                      .lsr @U                         ; LSR U             ; Shift (U T) to the right
     **** ****     > LSR
0001 DE4C D020  30        movb @U,rtmp
     DE4E 008F     
0002 DE50 0910  18        srl  rtmp,1
0003 DE52 D800  30        movb rtmp,@U
     DE54 008F     
                   < elite.a99
34717 DE56 0204  20        li   rarg1,T                    ; ROR T
     DE58 00D1     
34718 DE5A 06A0  32        bl   @ror                       ;
     DE5C FE70     
34719               
34720 DE5E 0460  28        b    @LL57                      ; JMP LL57          ; Jump back to LL57 to see if we can shift the result
     DE60 DE1A     
34721                                                                          ; any more
34722               
34723               * ******************************************************************************
34724               *
34725               * Name: LL9 (Part 8 of 12)
34726               * Type: Subroutine
34727               * Category: Drawing ships
34728               * Summary: Draw ship: Calculate the screen coordinates of visible vertices
34729               * Deep dive: Drawing ships
34730               *
34731               * ------------------------------------------------------------------------------
34732               *
34733               * This section projects the coordinate of the vertex into screen coordinates and
34734               * stores them on the XX3 heap. By the end of this part, the XX3 heap contains
34735               * four bytes containing the 16-bit screen coordinates of the current vertex, in
34736               * the order: x_lo, x_hi, y_lo, y_hi.
34737               *
34738               * When we reach here, we are looping through the vertices, and we've just worked
34739               * out the coordinates of the vertex in our normal coordinate system, as follows
34740               *
34741               * XX15(2 0)           (x_sign x_lo) = x-coordinate of the current vertex
34742               *
34743               * XX15(5 3)           (y_sign y_lo) = y-coordinate of the current vertex
34744               *
34745               * (U T)               (z_sign z_lo) = z-coordinate of the current vertex
34746               *
34747               * Note that U is always zero when we get to this point, as the vertex is always
34748               * in front of us (so it has a positive z-coordinate, into the screen).
34749               *
34750               * ------------------------------------------------------------------------------
34751               *
34752               * Other entry points:
34753               *
34754               * LL70+1              Contains an RTS (as the first byte of an LDA
34755               * instruction)
34756               *
34757               * LL66                A re-entry point into the ship-drawing routine, used by
34758               * the LL62 routine to store 128 - (U R) on the XX3 heap
34759               *
34760               * ******************************************************************************
34761               
34762               LL60:
34763 DE62 D360  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     DE64 00D1     
34764 DE66 D80D  30        movb ra,@Q                      ; STA Q
     DE68 0090     
34765               
34766 DE6A D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = x_lo
     DE6C 0031     
34767               
34768 DE6E 9360  30        cb   @Q,ra                      ; CMP Q             ; If x_lo < z_lo jump to LL69
     DE70 0090     
34769 DE72 1706  14        jnc  LL69                       ; BCC LL69
34770               
34771 DE74 0200  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     DE76 DD5E     
34772 DE78 06A0  32        bl   @jsr                       ;
     DE7A FE1E     
34773                                                                          ;
34774                                                                          ; (U R) = 256 * A / Q
34775                                                                          ; = 256 * x / z
34776                                                                          ;
34777                                                                          ; which we can do as x >= z
34778               
34779 DE7C 0460  28        b    @LL65                      ; JMP LL65          ; Jump to LL65 to skip the division for x_lo < z_lo
     DE7E DE88     
34780               
34781               LL69:
34782 DE80 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     DE82 D344     
34783 DE84 06A0  32        bl   @jsr                       ;
     DE86 FE1E     
34784                                                                          ;
34785                                                                          ; R = 256 * A / Q
34786                                                                          ; = 256 * x / z
34787                                                                          ;
34788                                                                          ; Because x < z, the result fits into one byte, and we
34789                                                                          ; also know that U = 0, so (U R) also contains the
34790                                                                          ; result
34791               
34792               LL65:
34793                                                                          ; At this point we have:
34794                                                                          ;
34795                                                                          ; (U R) = x / z
34796                                                                          ;
34797                                                                          ; so (U R) contains the vertex's x-coordinate projected
34798                                                                          ; on screen
34799                                                                          ;
34800                                                                          ; The next task is to convert (U R) to a pixel screen
34801                                                                          ; coordinate and stick it on the XX3 heap.
34802                                                                          ;
34803                                                                          ; We start with the x-coordinate. To convert the
34804                                                                          ; x-coordinate to a screen pixel we add 128, the
34805                                                                          ; x-coordinate of the centre of the screen, because the
34806                                                                          ; projected value is relative to an origin at the centre
34807                                                                          ; of the screen, but the origin of the screen pixels is
34808                                                                          ; at the top-left of the screen
34809 DE88 D3A0  30        movb @CNT,rx                    ; LDX CNT           ; Fetch the pointer to the end of the XX3 heap from CNT
     DE8A 00A4     
34810                                                                          ; into X
34811               
34812 DE8C D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If x_sign is negative, jump up to LL62, which will
     DE8E 0033     
34813 DE90 1190  14        jlt  LL62                       ; BMI LL62          ; store 128 - (U R) on the XX3 heap and return by
34814                                                                          ; jumping down to LL66 below
34815               
34816 DE92 D360  30        movb @R,ra                      ; LDA R             ; Calculate 128 + (U R), starting with the low bytes
     DE94 0091     
34817                      .clc                            ; CLC
     **** ****     > CLC
0001 DE96 0A16  18        sla  rzero,1
                   < elite.a99
34818                      .adi (>80*256)                  ; ADC #128
     **** ****     > ADI
0001 DE98 1701  14        jnc  !
0002 DE9A B347  18        ab   rone,ra
0003               !:
0004 DE9C 022D  22        ai   ra,(>80*256)
     DE9E 8000     
                   < elite.a99
34819               
34820 DEA0 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DEA2 0100     
34821                                                                          ; the heap at XX3
34822               
34823 DEA4 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34824                                                                          ; byte
34825               
34826 DEA6 D360  30        movb @U,ra                      ; LDA U             ; And then add the high bytes
     DEA8 008F     
34827                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 DEAA 1701  14        jnc  !
0002 DEAC B347  18        ab   rone,ra
0003               !:
0004 DEAE 022D  22        ai   ra,(>00*256)
     DEB0 0000     
                   < elite.a99
34828               
34829 DEB2 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     DEB4 0100     
34830                                                                          ; the heap at XX3
34831               
34832               LL66:
34833                                                                          ; We've just stored the screen x-coordinate of the
34834                                                                          ; vertex on the XX3 heap, so now for the y-coordinate
34835 DEB6 D34E  18        movb rx,ra                      ; TXA               ; Store the heap pointer in X on the stack (at this
34836                      .pha                            ; PHA               ; it points to the last entry on the heap, not the first
     **** ****     > PHA
0001 DEB8 D68D  30        movb ra,*rsp
0002 DEBA 060A  14        dec  rsp
                   < elite.a99
34837                                                                          ; free byte)
34838               
34839 DEBC 020D  20        li   ra,>00*256                 ; LDA #0            ; Set U = 0
     DEBE 0000     
34840 DEC0 D80D  30        movb ra,@U                      ; STA U
     DEC2 008F     
34841               
34842 DEC4 D360  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     DEC6 00D1     
34843 DEC8 D80D  30        movb ra,@Q                      ; STA Q
     DECA 0090     
34844               
34845 DECC D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A = y_lo
     DECE 0034     
34846               
34847 DED0 9360  30        cb   @Q,ra                      ; CMP Q             ; If y_lo < z_lo jump to LL67
     DED2 0090     
34848 DED4 171A  14        jnc  LL67                       ; BCC LL67
34849               
34850 DED6 0200  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     DED8 DD5E     
34851 DEDA 06A0  32        bl   @jsr                       ;
     DEDC FE1E     
34852                                                                          ;
34853                                                                          ; (U R) = 256 * A / Q
34854                                                                          ; = 256 * y / z
34855                                                                          ;
34856                                                                          ; which we can do as y >= z
34857               
34858 DEDE 0460  28        b    @LL68                      ; JMP LL68          ; Jump to LL68 to skip the division for y_lo < z_lo
     DEE0 DF12     
34859               
34860               LL70:
34861                                                                          ; This gets called from below when y_sign is negative
34862 DEE2 020D  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y + (U R), starting with the low bytes
     DEE4 6000     
34863                      .clc                            ; CLC
     **** ****     > CLC
0001 DEE6 0A16  18        sla  rzero,1
                   < elite.a99
34864                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 DEE8 1701  14        jnc  !
0002 DEEA B347  18        ab   rone,ra
0003               !:
0004 DEEC B360  30        ab   @R,ra
     DEEE 0091     
                   < elite.a99
34865               
34866 DEF0 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DEF2 0100     
34867                                                                          ; the heap at XX3
34868               
34869 DEF4 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34870                                                                          ; byte
34871               
34872 DEF6 020D  20        li   ra,>00*256                 ; LDA #0            ; And then add the high bytes
     DEF8 0000     
34873                      .adc @U,ra                      ; ADC U
     **** ****     > ADC
0001 DEFA 1701  14        jnc  !
0002 DEFC B347  18        ab   rone,ra
0003               !:
0004 DEFE B360  30        ab   @U,ra
     DF00 008F     
                   < elite.a99
34874               
34875 DF02 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     DF04 0100     
34876                                                                          ; the heap at XX3
34877               
34878 DF06 0460  28        b    @LL50                      ; JMP LL50          ; Jump to LL50 to move on to the next vertex
     DF08 DF44     
34879               
34880               LL67:
34881 DF0A 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     DF0C D344     
34882 DF0E 06A0  32        bl   @jsr                       ;
     DF10 FE1E     
34883                                                                          ;
34884                                                                          ; R = 256 * A / Q
34885                                                                          ; = 256 * y / z
34886                                                                          ;
34887                                                                          ; Because y < z, the result fits into one byte, and we
34888                                                                          ; also know that U = 0, so (U R) also contains the
34889                                                                          ; result
34890               
34891               LL68:
34892                                                                          ; At this point we have:
34893                                                                          ;
34894                                                                          ; (U R) = y / z
34895                                                                          ;
34896                                                                          ; so (U R) contains the vertex's y-coordinate projected
34897                                                                          ; on screen
34898                                                                          ;
34899                                                                          ; We now want to convert this to a screen y-coordinate
34900                                                                          ; and stick it on the XX3 heap, much like we did with
34901                                                                          ; the x-coordinate above. Again, we convert the
34902                                                                          ; coordinate by adding or subtracting the y-coordinate
34903                                                                          ; of the centre of the screen, which is in the constant
34904                                                                          ; #Y, but this time we do the opposite, as a positive
34905                                                                          ; projected y-coordinate, i.e. up the space y-axis and
34906                                                                          ; up the screen, converts to a low y-coordinate, which
34907                                                                          ; is the opposite way round to the x-coordinates
34908                      .pla                            ; PLA               ; Restore the heap pointer from the stack into X
     **** ****     > PLA
0001 DF12 058A  14        inc  rsp
0002 DF14 D35A  26        movb *rsp,ra
                   < elite.a99
34909 DF16 D38D  18        movb ra,rx                      ; TAX
34910               
34911 DF18 B387  18        ab   rone,rx                    ; INX               ; When we stored the heap pointer, it pointed to the
34912                                                                          ; last entry on the heap, not the first free byte, so we
34913                                                                          ; increment it so it does point to the next free byte
34914               
34915 DF1A D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; If y_sign is negative, jump up to LL70, which will
     DF1C 0036     
34916 DF1E 11E1  14        jlt  LL70                       ; BMI LL70          ; store #Y + (U R) on the XX3 heap and return by jumping
34917                                                                          ; down to LL50 below
34918               
34919 DF20 020D  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y - (U R), starting with the low bytes
     DF22 6000     
34920                      .sec                            ; SEC
     **** ****     > SEC
0001 DF24 0A18  18        sla  rmone,1
                   < elite.a99
34921                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 DF26 1801  14        joc  !
0002 DF28 7347  18        sb   rone,ra
0003               !:
0004 DF2A 7360  30        sb   @R,ra
     DF2C 0091     
                   < elite.a99
34922               
34923 DF2E DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     DF30 0100     
34924                                                                          ; the heap at XX3
34925               
34926 DF32 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
34927                                                                          ; byte
34928               
34929 DF34 020D  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     DF36 0000     
34930                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 DF38 1801  14        joc  !
0002 DF3A 7347  18        sb   rone,ra
0003               !:
0004 DF3C 7360  30        sb   @U,ra
     DF3E 008F     
                   < elite.a99
34931               
34932 DF40 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     DF42 0100     
34933                                                                          ; the heap at XX3
34934               
34935               LL50:
34936                                                                          ; By the time we get here, the XX3 heap contains four
34937                                                                          ; bytes containing the screen coordinates of the current
34938                                                                          ; vertex, in the order: x_lo, x_hi, y_lo, y_hi
34939                      .clc                            ; CLC               ; Set CNT = CNT + 4, so the heap pointer points to the
     **** ****     > CLC
0001 DF44 0A16  18        sla  rzero,1
                   < elite.a99
34940 DF46 D360  30        movb @CNT,ra                    ; LDA CNT           ; next free byte on the heap
     DF48 00A4     
34941                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 DF4A 1701  14        jnc  !
0002 DF4C B347  18        ab   rone,ra
0003               !:
0004 DF4E 022D  22        ai   ra,(>04*256)
     DF50 0400     
                   < elite.a99
34942 DF52 D80D  30        movb ra,@CNT                    ; STA CNT
     DF54 00A4     
34943               
34944 DF56 D360  30        movb @XX17,ra                   ; LDA XX17          ; Set A to the offset of the current vertex's data,
     DF58 0095     
34945                                                                          ; which we set in part 6
34946               
34947                      .adi (>06*256)                  ; ADC #6            ; Set Y = A + 6, so Y now points to the data for the
     **** ****     > ADI
0001 DF5A 1701  14        jnc  !
0002 DF5C B347  18        ab   rone,ra
0003               !:
0004 DF5E 022D  22        ai   ra,(>06*256)
     DF60 0600     
                   < elite.a99
34948 DF62 D3CD  18        movb ra,ry                      ; TAY               ; next vertex
34949               
34950 DF64 1805  14        joc  LL72                       ; BCS LL72          ; If the addition just overflowed, meaning we just tried
34951                                                                          ; to access vertex #43, jump to LL72, as the maximum
34952                                                                          ; number of vertices allowed is 42
34953               
34954 DF66 9360  30        cb   @XX20,ra                   ; CMP XX20          ; If Y >= number of vertices * 6 (which we stored in
     DF68 00A8     
34955 DF6A 1802  14        joc  LL72                       ; BCS LL72          ; XX20 in part 6), jump to LL72, as we have processed
34956                                                                          ; all the vertices for this ship
34957               
34958 DF6C 0460  28        b    @LL48                      ; JMP LL48          ; Loop back to LL48 in part 6 to calculate visibility
     DF6E DB34     
34959                                                                          ; and screen coordinates for the next vertex
34960               
34961               * ******************************************************************************
34962               *
34963               * Name: LL9 (Part 9 of 12)
34964               * Type: Subroutine
34965               * Category: Drawing ships
34966               * Summary: Draw ship: Draw laser beams if the ship is firing its laser at us
34967               * Deep dive: Drawing ships
34968               *
34969               * ------------------------------------------------------------------------------
34970               *
34971               * This part sets things up so we can loop through the edges in the next part. It
34972               * also adds a line to the ship line heap, if the ship is firing at us.
34973               *
34974               * When we get here, the heap at XX3 contains all the visible vertex screen
34975               * coordinates.
34976               *
34977               * ******************************************************************************
34978               
34979               LL72:
34980 DF70 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     DF72 0072     
34981 DF74 024D  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE31
     DF76 2000     
34982 DF78 1308  14        jeq  EE31                       ; BEQ EE31
34983               
34984 DF7A D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so set bit 3 of the ship's byte
     DF7C 0072     
34985 DF7E 026D  22        ori  ra,>08*256                 ; ORA #%00001000    ; #31 to denote that we are drawing something on-screen
     DF80 0800     
34986 DF82 D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; for this ship
     DF84 0072     
34987               
34988 DF86 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud,
     DF88 A8A0     
34989                                                                          ; returning from the subroutine using a tail call
34990               
34991               EE31:
34992 DF8A 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     DF8C 0800     
34993                      .bit @XX1+31                    ; BIT XX1+31        ; is nothing already being shown for this ship, so skip
     **** ****     > BIT
0001 DF8E D020  30        movb @XX1+31,rtmp
     DF90 0072     
0002 DF92 0540  14        inv  rtmp
0003 DF94 D047  18        movb rone,rtmp2
0004 DF96 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34994 DF98 1306  14        jeq  LL74                       ; BEQ LL74          ; to LL74 as we don't need to erase anything from the
34995                                                                          ; screen
34996               
34997 DF9A 0200  20        li   rtmp,LL155                 ; JSR LL155         ; Otherwise call LL155 to draw the existing ship, which
     DF9C E25C     
34998 DF9E 06A0  32        bl   @jsr                       ;
     DFA0 FE1E     
34999                                                                          ; removes it from the screen
35000               
35001 DFA2 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of A so the next instruction sets bit 3 of
     DFA4 0800     
35002                                                                          ; the ship's byte #31 to denote that we are drawing
35003                                                                          ; something on-screen for this ship
35004               
35005               LL74:
35006 DFA6 F360  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Apply bit 3 of A to the ship's byte #31, so if there
     DFA8 0072     
35007 DFAA D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; was no ship already on screen, the bit is clear,
     DFAC 0072     
35008                                                                          ; otherwise it is set
35009               
35010 DFAE 020F  20        li   ry,>09*256                 ; LDY #9            ; Fetch byte #9 of the ship's blueprint, which is the
     DFB0 0900     
35011                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of edges, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 DFB2 D820  50        movb @XX0,@rtmplb
     DFB4 001E     
     DFB6 206D     
0002 DFB8 D020  30        movb @XX0+1,rtmp
     DFBA 001F     
0003 DFBC A00F  18        a    ry,rtmp
0004 DFBE D350  26        movb *rtmp,RA
                   < elite.a99
35012 DFC0 D80D  30        movb ra,@XX20                   ; STA XX20
     DFC2 00A8     
35013               
35014 DFC4 020F  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the edges, using Y
     DFC6 0000     
35015                                                                          ; as a counter
35016               
35017 DFC8 D80F  30        movb ry,@U                      ; STY U             ; Set U = 0 (though we increment it to 1 below)
     DFCA 008F     
35018               
35019 DFCC D80F  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = 0, which we are going to use as a counter
     DFCE 0095     
35020                                                                          ; for stepping through the ship's edges
35021               
35022 DFD0 B347  18        ab   rone,ra                    ; INC U             ; We are going to start calculating the lines we need to
35023                                                                          ; draw for this ship, and will store them in the ship
35024                                                                          ; line heap, using U to point to the end of the heap, so
35025                                                                          ; we start by setting U = 1
35026               
35027                      .bit @XX1+31                    ; BIT XX1+31        ; If bit 6 of the ship's byte #31 is clear, then the
     **** ****     > BIT
0001 DFD2 D020  30        movb @XX1+31,rtmp
     DFD4 0072     
0002 DFD6 0540  14        inv  rtmp
0003 DFD8 D047  18        movb rone,rtmp2
0004 DFDA 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
35028 DFDC 1965  14        jno  LL170                      ; BVC LL170         ; ship is not firing its lasers, so jump to LL170 to
35029                                                                          ; skip the drawing of laser lines
35030               
35031                                                                          ; The ship is firing its laser at us, so we need to draw
35032                                                                          ; the laser lines
35033               
35034 DFDE D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; Clear bit 6 of the ship's byte #31 so the ship doesn't
     DFE0 0072     
35035 DFE2 024D  22        andi ra,>bf*256                 ; AND #%10111111    ; keep firing endlessly
     DFE4 BF00     
35036 DFE6 D80D  30        movb ra,@XX1+31                 ; STA XX1+31
     DFE8 0072     
35037               
35038 DFEA 020F  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 of the ship's blueprint, which is the
     DFEC 0600     
35039                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number * 4 of the vertex where the ship has its lasers
     **** ****     > LD_IND_Y_IDX
0001 DFEE D820  50        movb @XX0,@rtmplb
     DFF0 001E     
     DFF2 206D     
0002 DFF4 D020  30        movb @XX0+1,rtmp
     DFF6 001F     
0003 DFF8 A00F  18        a    ry,rtmp
0004 DFFA D350  26        movb *rtmp,RA
                   < elite.a99
35040               
35041 DFFC D3CD  18        movb ra,ry                      ; TAY               ; Put the vertex number into Y, where it can act as an
35042                                                                          ; index into list of vertex screen coordinates we added
35043                                                                          ; to the XX3 heap
35044               
35045 DFFE D3AF  34        movb @XX3(ry),rx                ; LDX XX3,Y         ; Fetch the x_lo coordinate of the laser vertex from the
     E000 0100     
35046 E002 D80E  30        movb rx,@XX15                   ; STX XX15          ; XX3 heap into XX15
     E004 0031     
35047               
35048 E006 B387  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35049 E008 134F  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35050                                                                          ; the vertex calculation in part 6 and 7, so jump to
35051                                                                          ; LL170 to skip drawing the laser lines
35052               
35053                                                                          ; We now build a laser beam from the ship's laser vertex
35054                                                                          ; towards our ship, as follows:
35055                                                                          ;
35056                                                                          ; XX15(1 0) = laser vertex x-coordinate
35057                                                                          ;
35058                                                                          ; XX15(3 2) = laser vertex y-coordinate
35059                                                                          ;
35060                                                                          ; XX15(5 4) = x-coordinate of the end of the beam
35061                                                                          ;
35062                                                                          ; XX12(1 0) = y-coordinate of the end of the beam
35063                                                                          ;
35064                                                                          ; The end of the laser beam will be positioned to look
35065                                                                          ; good, rather than being directly aimed at us, as
35066                                                                          ; otherwise we would only see a flashing point of light
35067                                                                          ; as they unleashed their attack
35068               
35069 E00A D3AF  34        movb @XX3+1(ry),rx              ; LDX XX3+1,Y       ; Fetch the x_hi coordinate of the laser vertex from the
     E00C 0101     
35070 E00E D80E  30        movb rx,@XX15+1                 ; STX XX15+1        ; XX3 heap into XX15+1
     E010 0032     
35071               
35072 E012 B387  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35073 E014 1349  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35074                                                                          ; a vertex calculation in part 6 and 7, so jump to LL170
35075                                                                          ; to skip drawing the laser beam
35076               
35077 E016 D3AF  34        movb @XX3+2(ry),rx              ; LDX XX3+2,Y       ; Fetch the y_lo coordinate of the laser vertex from the
     E018 0102     
35078 E01A D80E  30        movb rx,@XX15+2                 ; STX XX15+2        ; XX3 heap into XX15+2
     E01C 0033     
35079               
35080 E01E D3AF  34        movb @XX3+3(ry),rx              ; LDX XX3+3,Y       ; Fetch the y_hi coordinate of the laser vertex from the
     E020 0103     
35081 E022 D80E  30        movb rx,@XX15+3                 ; STX XX15+3        ; XX3 heap into XX15+3
     E024 0034     
35082               
35083 E026 020D  20        li   ra,>00*256                 ; LDA #0            ; Set XX15(5 4) = 0, so their laser beam fires to the
     E028 0000     
35084 E02A D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; left edge of the screen
     E02C 0035     
35085 E02E D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     E030 0036     
35086               
35087 E032 D80D  30        movb ra,@XX12+1                 ; STA XX12+1        ; Set XX12(1 0) = the ship's z_lo coordinate, which will
     E034 0038     
35088 E036 D360  30        movb @XX1+6,ra                  ; LDA XX1+6         ; effectively make the vertical position of the end of
     E038 0059     
35089 E03A D80D  30        movb ra,@XX12                   ; STA XX12          ; the laser beam move around as the ship moves in space
     E03C 0037     
35090               
35091 E03E D360  30        movb @XX1+2,ra                  ; LDA XX1+2         ; If the ship's x_sign is positive, skip the next
     E040 0055     
35092 E042 1501  14        jgt  B114                       ; BPL B114          ; instruction
35093               
35094 E044 7347  18        sb   rone,ra                    ; DEC XX15+4        ; The ship's x_sign is negative (i.e. it's on the left
35095                                                                          ; side of the screen), so switch the laser beam so it
35096                                                                          ; goes to the right edge of the screen by decrementing
35097                                                                          ; XX15(5 4) to 255
35098               
35099               B114:
35100 E046 0200  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the laser beam needs to be
     E048 E56C     
35101 E04A 06A0  32        bl   @jsr                       ;
     E04C FE1E     
35102                                                                          ; clipped to fit on-screen, returning the clipped line's
35103                                                                          ; end-points in (X1, Y1) and (X2, Y2)
35104               
35105 E04E 182C  14        joc  LL170                      ; BCS LL170         ; If the C flag is set then the line is not visible on
35106                                                                          ; screen, so jump to LL170 so we don't store this line
35107                                                                          ; in the ship line heap
35108               
35109 E050 D3E0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     E052 008F     
35110                                                                          ; next free byte on the heap, into Y
35111               
35112 E054 D360  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     E056 0031     
35113                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E058 D820  50        movb @XX19,@rtmplb
     E05A 0074     
     E05C 206D     
0002 E05E D020  30        movb @XX19+1,rtmp
     E060 0075     
0003 E062 A00F  18        a    ry,rtmp
0004 E064 D40D  30        movb RA,*rtmp
                   < elite.a99
35114               
35115 E066 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35116               
35117 E068 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     E06A 0032     
35118                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E06C D820  50        movb @XX19,@rtmplb
     E06E 0074     
     E070 206D     
0002 E072 D020  30        movb @XX19+1,rtmp
     E074 0075     
0003 E076 A00F  18        a    ry,rtmp
0004 E078 D40D  30        movb RA,*rtmp
                   < elite.a99
35119               
35120 E07A B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35121               
35122 E07C D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     E07E 0033     
35123                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E080 D820  50        movb @XX19,@rtmplb
     E082 0074     
     E084 206D     
0002 E086 D020  30        movb @XX19+1,rtmp
     E088 0075     
0003 E08A A00F  18        a    ry,rtmp
0004 E08C D40D  30        movb RA,*rtmp
                   < elite.a99
35124               
35125 E08E B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35126               
35127 E090 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     E092 0034     
35128                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E094 D820  50        movb @XX19,@rtmplb
     E096 0074     
     E098 206D     
0002 E09A D020  30        movb @XX19+1,rtmp
     E09C 0075     
0003 E09E A00F  18        a    ry,rtmp
0004 E0A0 D40D  30        movb RA,*rtmp
                   < elite.a99
35129               
35130 E0A2 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35131               
35132 E0A4 D80F  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     E0A6 008F     
35133               
35134               * ******************************************************************************
35135               *
35136               * Name: LL9 (Part 10 of 12)
35137               * Type: Subroutine
35138               * Category: Drawing ships
35139               * Summary: Draw ship: Calculate the visibility of each of the ship's edges
35140               * Deep dive: Drawing ships
35141               *
35142               * ------------------------------------------------------------------------------
35143               *
35144               * This part calculates which edges are visible - in other words, which lines we
35145               * should draw - and clips them to fit on the screen.
35146               *
35147               * When we get here, the heap at XX3 contains all the visible vertex screen
35148               * coordinates.
35149               *
35150               * ******************************************************************************
35151               
35152               LL170:
35153 E0A8 020F  20        li   ry,>03*256                 ; LDY #3            ; Fetch byte #3 of the ship's blueprint, which contains
     E0AA 0300     
35154                      .clc                            ; CLC               ; the low byte of the offset to the edges data
     **** ****     > CLC
0001 E0AC 0A16  18        sla  rzero,1
                   < elite.a99
35155                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 E0AE D820  50        movb @XX0,@rtmplb
     E0B0 001E     
     E0B2 206D     
0002 E0B4 D020  30        movb @XX0+1,rtmp
     E0B6 001F     
0003 E0B8 A00F  18        a    ry,rtmp
0004 E0BA D350  26        movb *rtmp,RA
                   < elite.a99
35156               
35157                      .adc @XX0,ra                    ; ADC XX0           ; Set V = low byte edges offset + XX0
     **** ****     > ADC
0001 E0BC 1701  14        jnc  !
0002 E0BE B347  18        ab   rone,ra
0003               !:
0004 E0C0 B360  30        ab   @XX0,ra
     E0C2 001E     
                   < elite.a99
35158 E0C4 D80D  30        movb ra,@V                      ; STA V
     E0C6 0022     
35159               
35160 E0C8 020F  20        li   ry,>10*256                 ; LDY #16           ; Fetch byte #16 of the ship's blueprint, which contains
     E0CA 1000     
35161                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the edges data
     **** ****     > LD_IND_Y_IDX
0001 E0CC D820  50        movb @XX0,@rtmplb
     E0CE 001E     
     E0D0 206D     
0002 E0D2 D020  30        movb @XX0+1,rtmp
     E0D4 001F     
0003 E0D6 A00F  18        a    ry,rtmp
0004 E0D8 D350  26        movb *rtmp,RA
                   < elite.a99
35162               
35163                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte edges offset + XX0+1
     **** ****     > ADC
0001 E0DA 1701  14        jnc  !
0002 E0DC B347  18        ab   rone,ra
0003               !:
0004 E0DE B360  30        ab   @XX0+1,ra
     E0E0 001F     
                   < elite.a99
35164 E0E2 D80D  30        movb ra,@V+1                    ; STA V+1           ;
     E0E4 0023     
35165                                                                          ; So V(1 0) now points to the start of the edges data
35166                                                                          ; for this ship
35167               
35168 E0E6 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the ship's blueprint, which contains
     E0E8 0500     
35169                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the maximum heap size for plotting the ship (which is
     **** ****     > LD_IND_Y_IDX
0001 E0EA D820  50        movb @XX0,@rtmplb
     E0EC 001E     
     E0EE 206D     
0002 E0F0 D020  30        movb @XX0+1,rtmp
     E0F2 001F     
0003 E0F4 A00F  18        a    ry,rtmp
0004 E0F6 D350  26        movb *rtmp,RA
                   < elite.a99
35170 E0F8 D80D  30        movb ra,@T1                     ; STA T1            ; 1 + 4 * the maximum number of visible edges) and store
     E0FA 0006     
35171                                                                          ; it in T1
35172               
35173 E0FC D3E0  30        movb @XX17,ry                   ; LDY XX17          ; Set Y to the edge counter in XX17
     E0FE 0095     
35174               
35175               LL75:
35176                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this edge, which contains the
     **** ****     > LD_IND_Y_IDX
0001 E100 D820  50        movb @V,@rtmplb
     E102 0022     
     E104 206D     
0002 E106 D020  30        movb @V+1,rtmp
     E108 0023     
0003 E10A A00F  18        a    ry,rtmp
0004 E10C D350  26        movb *rtmp,RA
                   < elite.a99
35177                                                                          ; visibility distance for this edge, beyond which the
35178                                                                          ; edge is not shown
35179               
35180 E10E 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     E110 00A7     
35181 E112 1802  14        joc  FIX011                     ; BCS FIX011        ; the ship's z-distance reduced to 0-31 (which we set in
35182 E114 0460  28        b    @LL78                      ; JMP LL78          ; part 2), then this edge is too far away to be visible,
     E116 E21E     
35183                                                                          ; so jump down to LL78 to move on to the next edge
35184               FIX011:
35185 E118 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
35186               
35187                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this edge into A, so:
     **** ****     > LD_IND_Y_IDX
0001 E11A D820  50        movb @V,@rtmplb
     E11C 0022     
     E11E 206D     
0002 E120 D020  30        movb @V+1,rtmp
     E122 0023     
0003 E124 A00F  18        a    ry,rtmp
0004 E126 D350  26        movb *rtmp,RA
                   < elite.a99
35188                                                                          ;
35189                                                                          ; A = %ffff ffff, where:
35190                                                                          ;
35191                                                                          ; * Bits 0-3 = the number of face 1
35192                                                                          ;
35193                                                                          ; * Bits 4-7 = the number of face 2
35194               
35195 E128 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
35196               
35197 E12A D80D  30        movb ra,@P                      ; STA P             ; Store byte #1 into P
     E12C 001B     
35198               
35199 E12E 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     E130 0F00     
35200 E132 D38D  18        movb ra,rx                      ; TAX
35201               
35202 E134 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     E136 00D2     
35203 E138 160A  14        jne  LL79                       ; BNE LL79          ; face 1 is visible, so jump to LL79
35204               
35205 E13A D360  30        movb @P,ra                      ; LDA P             ; Fetch byte #1 for this edge into A
     E13C 001B     
35206               
35207 E13E 091D  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
35208 E140 091D  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
35209 E142 091D  18        srl  ra,1                       ; LSR A
35210 E144 091D  18        srl  ra,1                       ; LSR A
35211 E146 D38D  18        movb ra,rx                      ; TAX
35212               
35213 E148 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is zero then we decided in part 5 that
     E14A 00D2     
35214 E14C 1368  14        jeq  LL78                       ; BEQ LL78          ; face 2 is hidden, so jump to LL78
35215               
35216               LL79:
35217                                                                          ; We now build the screen line for this edge, as
35218                                                                          ; follows:
35219                                                                          ;
35220                                                                          ; XX15(1 0) = start x-coordinate
35221                                                                          ;
35222                                                                          ; XX15(3 2) = start y-coordinate
35223                                                                          ;
35224                                                                          ; XX15(5 4) = end x-coordinate
35225                                                                          ;
35226                                                                          ; XX12(1 0) = end y-coordinate
35227                                                                          ;
35228                                                                          ; We can then pass this to the line clipping routine
35229                                                                          ; before storing the resulting line in the ship line
35230                                                                          ; heap
35231                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this edge into X, which contains
     **** ****     > LD_IND_Y_IDX
0001 E14E D820  50        movb @V,@rtmplb
     E150 0022     
     E152 206D     
0002 E154 D020  30        movb @V+1,rtmp
     E156 0023     
0003 E158 A00F  18        a    ry,rtmp
0004 E15A D350  26        movb *rtmp,RA
                   < elite.a99
35232 E15C D38D  18        movb ra,rx                      ; TAX               ; the number of the vertex at the start of the edge
35233               
35234 E15E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
35235               
35236                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this edge into Q, which contains
     **** ****     > LD_IND_Y_IDX
0001 E160 D820  50        movb @V,@rtmplb
     E162 0022     
     E164 206D     
0002 E166 D020  30        movb @V+1,rtmp
     E168 0023     
0003 E16A A00F  18        a    ry,rtmp
0004 E16C D350  26        movb *rtmp,RA
                   < elite.a99
35237 E16E D80D  30        movb ra,@Q                      ; STA Q             ; the number of the vertex at the end of the edge
     E170 0090     
35238               
35239 E172 D36E  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's start vertex
     E174 0101     
35240 E176 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; from the XX3 heap into XX15+1
     E178 0032     
35241               
35242 E17A D36E  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's start vertex
     E17C 0100     
35243 E17E D80D  30        movb ra,@XX15                   ; STA XX15          ; from the XX3 heap into XX15
     E180 0031     
35244               
35245 E182 D36E  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's start vertex
     E184 0102     
35246 E186 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; from the XX3 heap into XX15+2
     E188 0033     
35247               
35248 E18A D36E  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's start vertex
     E18C 0103     
35249 E18E D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; from the XX3 heap into XX15+3
     E190 0034     
35250               
35251 E192 D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X to the number of the vertex at the end of the
     E194 0090     
35252                                                                          ; edge, which we stored in Q
35253               
35254 E196 D36E  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's end vertex
     E198 0100     
35255 E19A D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; from the XX3 heap into XX15+4
     E19C 0035     
35256               
35257 E19E D36E  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's end vertex
     E1A0 0103     
35258 E1A2 D80D  30        movb ra,@XX12+1                 ; STA XX12+1        ; from the XX3 heap into XX12+1
     E1A4 0038     
35259               
35260 E1A6 D36E  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's end vertex
     E1A8 0102     
35261 E1AA D80D  30        movb ra,@XX12                   ; STA XX12          ; from the XX3 heap into XX12
     E1AC 0037     
35262               
35263 E1AE D36E  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's end vertex
     E1B0 0101     
35264 E1B2 D80D  30        movb ra,@XX15+5                 ; STA XX15+5        ; from the XX3 heap into XX15+5
     E1B4 0036     
35265               
35266 E1B6 0200  20        li   rtmp,LL147                 ; JSR LL147         ; Call LL147 to see if the new line segment needs to be
     E1B8 E578     
35267 E1BA 06A0  32        bl   @jsr                       ;
     E1BC FE1E     
35268                                                                          ; clipped to fit on-screen, returning the clipped line's
35269                                                                          ; end-points in (X1, Y1) and (X2, Y2)
35270               
35271 E1BE 182F  14        joc  LL78                       ; BCS LL78          ; If the C flag is set then the line is not visible on
35272                                                                          ; screen, so jump to LL78 so we don't store this line
35273                                                                          ; in the ship line heap
35274               
35275               * ******************************************************************************
35276               *
35277               * Name: LL9 (Part 11 of 12)
35278               * Type: Subroutine
35279               * Category: Drawing ships
35280               * Summary: Draw ship: Add all visible edges to the ship line heap
35281               * Deep dive: Drawing ships
35282               *
35283               * ------------------------------------------------------------------------------
35284               *
35285               * This part adds all the visible edges to the ship line heap, so we can draw
35286               * them in part 12.
35287               *
35288               * Other entry points:
35289               *
35290               * LL81+2              Draw the contents of the ship line heap, used to draw
35291               * the ship as a dot from SHPPT
35292               *
35293               * ******************************************************************************
35294               
35295               LL80:
35296 E1C0 D3E0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     E1C2 008F     
35297                                                                          ; next free byte on the heap, into Y
35298               
35299 E1C4 D360  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     E1C6 0031     
35300                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E1C8 D820  50        movb @XX19,@rtmplb
     E1CA 0074     
     E1CC 206D     
0002 E1CE D020  30        movb @XX19+1,rtmp
     E1D0 0075     
0003 E1D2 A00F  18        a    ry,rtmp
0004 E1D4 D40D  30        movb RA,*rtmp
                   < elite.a99
35301               
35302 E1D6 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35303               
35304 E1D8 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     E1DA 0032     
35305                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E1DC D820  50        movb @XX19,@rtmplb
     E1DE 0074     
     E1E0 206D     
0002 E1E2 D020  30        movb @XX19+1,rtmp
     E1E4 0075     
0003 E1E6 A00F  18        a    ry,rtmp
0004 E1E8 D40D  30        movb RA,*rtmp
                   < elite.a99
35306               
35307 E1EA B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35308               
35309 E1EC D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     E1EE 0033     
35310                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E1F0 D820  50        movb @XX19,@rtmplb
     E1F2 0074     
     E1F4 206D     
0002 E1F6 D020  30        movb @XX19+1,rtmp
     E1F8 0075     
0003 E1FA A00F  18        a    ry,rtmp
0004 E1FC D40D  30        movb RA,*rtmp
                   < elite.a99
35311               
35312 E1FE B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35313               
35314 E200 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     E202 0034     
35315                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E204 D820  50        movb @XX19,@rtmplb
     E206 0074     
     E208 206D     
0002 E20A D020  30        movb @XX19+1,rtmp
     E20C 0075     
0003 E20E A00F  18        a    ry,rtmp
0004 E210 D40D  30        movb RA,*rtmp
                   < elite.a99
35316               
35317 E212 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35318               
35319 E214 D80F  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     E216 008F     
35320               
35321 E218 93E0  30        cb   @T1,ry                     ; CPY T1            ; If Y >= T1 then we have reached the maximum number of
     E21A 0006     
35322 E21C 1814  14        joc  LL81                       ; BCS LL81          ; edge lines that we can store in the ship line heap, so
35323                                                                          ; skip to LL81 so we don't loop back for the next edge
35324               
35325               LL78:
35326 E21E B347  18        ab   rone,ra                    ; INC XX17          ; Increment the edge counter to point to the next edge
35327               
35328 E220 D3E0  30        movb @XX17,ry                   ; LDY XX17          ; If Y >= XX20, which contains the number of edges in
     E222 0095     
35329 E224 93E0  30        cb   @XX20,ry                   ; CPY XX20          ; the blueprint, jump to LL81 as we have processed all
     E226 00A8     
35330 E228 180E  14        joc  LL81                       ; BCS LL81          ; the edges and don't need to loop back for the next one
35331               
35332 E22A 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y to point to byte #0 again, ready for the next
     E22C 0000     
35333                                                                          ; edge
35334               
35335 E22E D360  30        movb @V,ra                      ; LDA V             ; Increment V by 4 so V(1 0) points to the data for the
     E230 0022     
35336                      .adi (>04*256)                  ; ADC #4            ; next edge
     **** ****     > ADI
0001 E232 1701  14        jnc  !
0002 E234 B347  18        ab   rone,ra
0003               !:
0004 E236 022D  22        ai   ra,(>04*256)
     E238 0400     
                   < elite.a99
35337 E23A D80D  30        movb ra,@V                      ; STA V
     E23C 0022     
35338               
35339 E23E 1701  14        jnc  ll81_                      ; BCC ll81          ; If the above addition didn't overflow, jump to ll81 to
35340                                                                          ; skip the following instruction
35341               
35342 E240 B347  18        ab   rone,ra                    ; INC V+1           ; Otherwise increment the high byte of V(1 0), as we
35343                                                                          ; just moved the V(1 0) pointer past a page boundary
35344               
35345               ll81_:
35346 E242 0460  28        b    @LL75                      ; JMP LL75          ; Loop back to LL75 to process the next edge
     E244 E100     
35347               
35348               LL81:
35349                                                                          ; We have finished adding lines to the ship line heap,
35350                                                                          ; so now we need to set the first byte of the heap to
35351                                                                          ; the number of bytes stored there
35352 E246 D360  30        movb @U,ra                      ; LDA U             ; Fetch the ship line heap pointer from U into A, which
     E248 008F     
35353                                                                          ; points to the end of the heap, and therefore contains
35354                                                                          ; the heap size
35355               
35356 E24A 020F  20        li   ry,>00*256                 ; LDY #0            ; Store A as the first byte of the ship line heap, so
     E24C 0000     
35357                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the heap is now correctly set up
     **** ****     > ST_IND_Y_IDX
0001 E24E D820  50        movb @XX19,@rtmplb
     E250 0074     
     E252 206D     
0002 E254 D020  30        movb @XX19+1,rtmp
     E256 0075     
0003 E258 A00F  18        a    ry,rtmp
0004 E25A D40D  30        movb RA,*rtmp
                   < elite.a99
35358               
35359               * ******************************************************************************
35360               *
35361               * Name: LL9 (Part 12 of 12)
35362               * Type: Subroutine
35363               * Category: Drawing ships
35364               * Summary: Draw ship: Draw all the visible edges from the ship line heap
35365               * Deep dive: Drawing ships
35366               *
35367               * ------------------------------------------------------------------------------
35368               *
35369               * This part draws the lines in the ship line heap, which is used both to draw
35370               * the ship, and to remove it from the screen.
35371               *
35372               * ******************************************************************************
35373               
35374               LL155:
35375 E25C 020F  20        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte from the ship line heap into A,
     E25E 0000     
35376                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; which contains the number of bytes in the heap
     **** ****     > LD_IND_Y_IDX
0001 E260 D820  50        movb @XX19,@rtmplb
     E262 0074     
     E264 206D     
0002 E266 D020  30        movb @XX19+1,rtmp
     E268 0075     
0003 E26A A00F  18        a    ry,rtmp
0004 E26C D350  26        movb *rtmp,RA
                   < elite.a99
35377               
35378 E26E D80D  30        movb ra,@XX20                   ; STA XX20          ; Store the heap size in XX20
     E270 00A8     
35379               
35380 E272 028D  22        ci   ra,>04*256                 ; CMP #4            ; If the heap size is less than 4, there is nothing to
     E274 0400     
35381 E276 1731  14        jnc  LL118-1                    ; BCC LL118-1       ; draw, so return from the subroutine (as LL118-1
35382                                                                          ; contains an RTS)
35383               
35384 E278 B3C7  18        ab   rone,ry                    ; INY               ; Set Y = 1, which we will use as an index into the ship
35385                                                                          ; line heap, starting at byte #1 (as byte #0 contains
35386                                                                          ; the heap size)
35387               
35388               LL27:
35389                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E27A D820  50        movb @XX19,@rtmplb
     E27C 0074     
     E27E 206D     
0002 E280 D020  30        movb @XX19+1,rtmp
     E282 0075     
0003 E284 A00F  18        a    ry,rtmp
0004 E286 D350  26        movb *rtmp,RA
                   < elite.a99
35390 E288 D80D  30        movb ra,@XX15                   ; STA XX15          ; it in XX15
     E28A 0031     
35391               
35392 E28C B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35393               
35394                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E28E D820  50        movb @XX19,@rtmplb
     E290 0074     
     E292 206D     
0002 E294 D020  30        movb @XX19+1,rtmp
     E296 0075     
0003 E298 A00F  18        a    ry,rtmp
0004 E29A D350  26        movb *rtmp,RA
                   < elite.a99
35395 E29C D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; it in XX15+1
     E29E 0032     
35396               
35397 E2A0 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35398               
35399                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E2A2 D820  50        movb @XX19,@rtmplb
     E2A4 0074     
     E2A6 206D     
0002 E2A8 D020  30        movb @XX19+1,rtmp
     E2AA 0075     
0003 E2AC A00F  18        a    ry,rtmp
0004 E2AE D350  26        movb *rtmp,RA
                   < elite.a99
35400 E2B0 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; it in XX15+2
     E2B2 0033     
35401               
35402 E2B4 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35403               
35404                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 E2B6 D820  50        movb @XX19,@rtmplb
     E2B8 0074     
     E2BA 206D     
0002 E2BC D020  30        movb @XX19+1,rtmp
     E2BE 0075     
0003 E2C0 A00F  18        a    ry,rtmp
0004 E2C2 D350  26        movb *rtmp,RA
                   < elite.a99
35405 E2C4 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; it in XX15+3
     E2C6 0034     
35406               
35407 E2C8 0200  20        li   rtmp,LL30                  ; JSR LL30          ; Draw a line from (X1, Y1) to (X2, Y2)
     E2CA 224E     
35408 E2CC 06A0  32        bl   @jsr                       ;
     E2CE FE1E     
35409               
35410 E2D0 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35411               
35412 E2D2 93E0  30        cb   @XX20,ry                   ; CPY XX20          ; If the heap counter is less than the size of the heap,
     E2D4 00A8     
35413 E2D6 17D1  14        jnc  LL27                       ; BCC LL27          ; loop back to LL27 to draw the next line from the heap
35414               
35415               * .LL82                  \ This label is commented out in the original source
35416               
35417 E2D8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E2DA FE2A     
35418               
35419               * ******************************************************************************
35420               *
35421               * Name: LL118
35422               * Type: Subroutine
35423               * Category: Drawing lines
35424               * Summary: Move a point along a line until it is on-screen
35425               * Deep dive: Line-clipping
35426               *
35427               * ------------------------------------------------------------------------------
35428               *
35429               * Given a point (x1, y1), a gradient and a direction of slope, move the point
35430               * along the line until it is on-screen, so this effectively clips the (x1, y1)
35431               * end of a line to be on the screen.
35432               *
35433               * See the deep dive on "Line-clipping" for more details.
35434               *
35435               * ------------------------------------------------------------------------------
35436               *
35437               * Arguments:
35438               *
35439               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
35440               *
35441               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
35442               *
35443               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
35444               *
35445               * XX12+3              The direction of slope:
35446               *
35447               * * Positive (bit 7 clear) = top left to bottom right
35448               *
35449               * * Negative (bit 7 set) = top right to bottom left
35450               *
35451               * T                   The gradient of slope:
35452               *
35453               * * 0 if it's a shallow slope
35454               *
35455               * * &FF if it's a steep slope
35456               *
35457               * ------------------------------------------------------------------------------
35458               *
35459               * Returns:
35460               *
35461               * XX15                x1 as an 8-bit coordinate
35462               *
35463               * XX15+2              y1 as an 8-bit coordinate
35464               *
35465               * ------------------------------------------------------------------------------
35466               *
35467               * Other entry points:
35468               *
35469               * LL118-1             Contains an RTS
35470               *
35471               * ******************************************************************************
35472               
35473               LL118:
35474 E2DC D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If x1_hi is positive, jump down to LL119 to skip the
     E2DE 0032     
35475 E2E0 151C  14        jgt  LL119                      ; BPL LL119         ; following
35476               
35477 E2E2 D80D  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is negative, i.e. off the left of the
     E2E4 0092     
35478                                                                          ; screen, so set S = x1_hi
35479               
35480 E2E6 0200  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     E2E8 E3F8     
35481 E2EA 06A0  32        bl   @jsr                       ;
     E2EC FE1E     
35482                                                                          ;
35483                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
35484                                                                          ; = x1 * gradient
35485                                                                          ;
35486                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
35487                                                                          ; = x1 / gradient
35488                                                                          ;
35489                                                                          ; with the sign of (Y X) set to the opposite of the
35490                                                                          ; line's direction of slope
35491               
35492 E2EE D34E  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
35493                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E2F0 0A16  18        sla  rzero,1
                   < elite.a99
35494                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 E2F2 1701  14        jnc  !
0002 E2F4 B347  18        ab   rone,ra
0003               !:
0004 E2F6 B360  30        ab   @XX15+2,ra
     E2F8 0033     
                   < elite.a99
35495 E2FA D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E2FC 0033     
35496               
35497 E2FE D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35498                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 E300 1701  14        jnc  !
0002 E302 B347  18        ab   rone,ra
0003               !:
0004 E304 B360  30        ab   @XX15+3,ra
     E306 0034     
                   < elite.a99
35499 E308 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E30A 0034     
35500               
35501 E30C 020D  20        li   ra,>00*256                 ; LDA #0            ; Set x1 = 0
     E30E 0000     
35502 E310 D80D  30        movb ra,@XX15                   ; STA XX15
     E312 0031     
35503 E314 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E316 0032     
35504               
35505 E318 D38D  18        movb ra,rx                      ; TAX               ; Set X = 0 so the next instruction becomes a JMP
35506               
35507               LL119:
35508 E31A 131D  14        jeq  LL134                      ; BEQ LL134         ; If x1_hi = 0 then jump down to LL134 to skip the
35509                                                                          ; following, as the x-coordinate is already on-screen
35510                                                                          ; (as 0 <= (x_hi x_lo) <= 255)
35511               
35512 E31C D80D  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is positive, i.e. x1 >= 256 and off
     E31E 0092     
35513 E320 7347  18        sb   rone,ra                    ; DEC S             ; the right side of the screen, so set S = x1_hi - 1
35514               
35515 E322 0200  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     E324 E3F8     
35516 E326 06A0  32        bl   @jsr                       ;
     E328 FE1E     
35517                                                                          ;
35518                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
35519                                                                          ; = (x1 - 256) * gradient
35520                                                                          ;
35521                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
35522                                                                          ; = (x1 - 256) / gradient
35523                                                                          ;
35524                                                                          ; with the sign of (Y X) set to the opposite of the
35525                                                                          ; line's direction of slope
35526               
35527 E32A D34E  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
35528                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E32C 0A16  18        sla  rzero,1
                   < elite.a99
35529                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 E32E 1701  14        jnc  !
0002 E330 B347  18        ab   rone,ra
0003               !:
0004 E332 B360  30        ab   @XX15+2,ra
     E334 0033     
                   < elite.a99
35530 E336 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E338 0033     
35531               
35532 E33A D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35533                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 E33C 1701  14        jnc  !
0002 E33E B347  18        ab   rone,ra
0003               !:
0004 E340 B360  30        ab   @XX15+3,ra
     E342 0034     
                   < elite.a99
35534 E344 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E346 0034     
35535               
35536 E348 020E  20        li   rx,>ff*256                 ; LDX #255          ; Set x1 = 255
     E34A FF00     
35537 E34C D80E  30        movb rx,@XX15                   ; STX XX15
     E34E 0031     
35538 E350 B387  18        ab   rone,rx                    ; INX
35539 E352 D80E  30        movb rx,@XX15+1                 ; STX XX15+1
     E354 0032     
35540               
35541               LL134:
35542                                                                          ; We have moved the point so the x-coordinate is on
35543                                                                          ; screen (i.e. in the range 0-255), so now for the
35544                                                                          ; y-coordinate
35545 E356 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If y1_hi is positive, jump down to LL119 to skip
     E358 0034     
35546 E35A 151F  14        jgt  LL135                      ; BPL LL135         ; the following
35547               
35548 E35C D80D  30        movb ra,@S                      ; STA S             ; Otherwise y1_hi is negative, i.e. off the top of the
     E35E 0092     
35549                                                                          ; screen, so set S = y1_hi
35550               
35551 E360 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = y1_lo
     E362 0033     
35552 E364 D80D  30        movb ra,@R                      ; STA R
     E366 0091     
35553               
35554 E368 0200  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     E36A E484     
35555 E36C 06A0  32        bl   @jsr                       ;
     E36E FE1E     
35556                                                                          ;
35557                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
35558                                                                          ; = y1 / gradient
35559                                                                          ;
35560                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
35561                                                                          ; = y1 * gradient
35562                                                                          ;
35563                                                                          ; with the sign of (Y X) set to the opposite of the
35564                                                                          ; line's direction of slope
35565               
35566 E370 D34E  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
35567                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E372 0A16  18        sla  rzero,1
                   < elite.a99
35568                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 E374 1701  14        jnc  !
0002 E376 B347  18        ab   rone,ra
0003               !:
0004 E378 B360  30        ab   @XX15,ra
     E37A 0031     
                   < elite.a99
35569 E37C D80D  30        movb ra,@XX15                   ; STA XX15
     E37E 0031     
35570               
35571 E380 D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35572                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 E382 1701  14        jnc  !
0002 E384 B347  18        ab   rone,ra
0003               !:
0004 E386 B360  30        ab   @XX15+1,ra
     E388 0032     
                   < elite.a99
35573 E38A D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E38C 0032     
35574               
35575 E38E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set y1 = 0
     E390 0000     
35576 E392 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E394 0033     
35577 E396 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E398 0034     
35578               
35579               LL135:
35580               * BNE LL139              \ This instruction is commented out in the original
35581                                                                          ; source
35582 E39A D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set (S R) = (y1_hi y1_lo) - screen height
     E39C 0033     
35583                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 E39E 0A18  18        sla  rmone,1
                   < elite.a99
35584                      .sbi ((Y*2)*256)                ; SBC #Y*2          ; starting with the low bytes
     **** ****     > SBI
0001 E3A0 1801  14        joc  !
0002 E3A2 7347  18        sb   rone,ra
0003               !:
0004 E3A4 022D  22        ai   ra,-((Y*2)*256)
     E3A6 4000     
                   < elite.a99
35585 E3A8 D80D  30        movb ra,@R                      ; STA R
     E3AA 0091     
35586               
35587 E3AC D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then subtracting the high bytes
     E3AE 0034     
35588                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 E3B0 1801  14        joc  !
0002 E3B2 7347  18        sb   rone,ra
0003               !:
0004 E3B4 022D  22        ai   ra,-(>00*256)
     E3B6 0000     
                   < elite.a99
35589 E3B8 D80D  30        movb ra,@S                      ; STA S
     E3BA 0092     
35590               
35591 E3BC 171B  14        jnc  LL136                      ; BCC LL136         ; If the subtraction underflowed, i.e. if y1 < screen
35592                                                                          ; height, then y1 is already on-screen, so jump to LL136
35593                                                                          ; to return from the subroutine, as we are done
35594               
35595               LL139:
35596                                                                          ; If we get here then y1 >= screen height, i.e. off the
35597                                                                          ; bottom of the screen
35598 E3BE 0200  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     E3C0 E484     
35599 E3C2 06A0  32        bl   @jsr                       ;
     E3C4 FE1E     
35600                                                                          ;
35601                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
35602                                                                          ; = (y1 - screen height) / gradient
35603                                                                          ;
35604                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
35605                                                                          ; = (y1 - screen height) * gradient
35606                                                                          ;
35607                                                                          ; with the sign of (Y X) set to the opposite of the
35608                                                                          ; line's direction of slope
35609               
35610 E3C6 D34E  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
35611                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E3C8 0A16  18        sla  rzero,1
                   < elite.a99
35612                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 E3CA 1701  14        jnc  !
0002 E3CC B347  18        ab   rone,ra
0003               !:
0004 E3CE B360  30        ab   @XX15,ra
     E3D0 0031     
                   < elite.a99
35613 E3D2 D80D  30        movb ra,@XX15                   ; STA XX15
     E3D4 0031     
35614               
35615 E3D6 D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
35616                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 E3D8 1701  14        jnc  !
0002 E3DA B347  18        ab   rone,ra
0003               !:
0004 E3DC B360  30        ab   @XX15+1,ra
     E3DE 0032     
                   < elite.a99
35617 E3E0 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E3E2 0032     
35618               
35619 E3E4 020D  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; Set y1 = 2 * #Y - 1. The constant #Y is 96, the
     E3E6 BF00     
35620 E3E8 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; y-coordinate of the mid-point of the space view, so
     E3EA 0033     
35621 E3EC 020D  20        li   ra,>00*256                 ; LDA #0            ; this sets Y2 to 191, the y-coordinate of the bottom
     E3EE 0000     
35622 E3F0 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; pixel row of the space view
     E3F2 0034     
35623               
35624               LL136:
35625 E3F4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E3F6 FE2A     
35626               
35627               * ******************************************************************************
35628               *
35629               * Name: LL120
35630               * Type: Subroutine
35631               * Category: Maths (Arithmetic)
35632               * Summary: Calculate (Y X) = (S x1_lo) * XX12+2 or (S x1_lo) / XX12+2
35633               *
35634               * ------------------------------------------------------------------------------
35635               *
35636               * Calculate the following:
35637               *
35638               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
35639               *
35640               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
35641               *
35642               * giving (Y X) the opposite sign to the slope direction in XX12+3.
35643               *
35644               * ------------------------------------------------------------------------------
35645               *
35646               * Arguments:
35647               *
35648               * T                   The gradient of slope:
35649               *
35650               * * 0 if it's a shallow slope
35651               *
35652               * * &FF if it's a steep slope
35653               *
35654               * ------------------------------------------------------------------------------
35655               *
35656               * Other entry points:
35657               *
35658               * LL122               Calculate (Y X) = (S R) * Q and set the sign to the
35659               * opposite of the top byte on the stack
35660               *
35661               * ******************************************************************************
35662               
35663               LL120:
35664 E3F8 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set R = x1_lo
     E3FA 0031     
35665 E3FC D80D  30        movb ra,@R                      ; STA R
     E3FE 0091     
35666               
35667               * .LL120                 \ This label is commented out in the original source
35668               
35669 E400 0200  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     E402 E524     
35670 E404 06A0  32        bl   @jsr                       ;
     E406 FE1E     
35671                                                                          ;
35672                                                                          ; Q = XX12+2
35673                                                                          ; = line gradient
35674                                                                          ;
35675                                                                          ; A = S EOR XX12+3
35676                                                                          ; = S EOR slope direction
35677                                                                          ;
35678                                                                          ; (S R) = |S R|
35679                                                                          ;
35680                                                                          ; So A contains the sign of S * slope direction
35681               
35682                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 E408 D68D  30        movb ra,*rsp
0002 E40A 060A  14        dec  rsp
                   < elite.a99
35683               
35684 E40C D3A0  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump
     E40E 00D1     
35685 E410 1642  14        jne  LL121                      ; BNE LL121         ; down to LL121 to calculate this instead:
35686                                                                          ;
35687                                                                          ; (Y X) = (S R) / Q
35688               
35689               LL122:
35690                                                                          ; The following calculates:
35691                                                                          ;
35692                                                                          ; (Y X) = (S R) * Q
35693                                                                          ;
35694                                                                          ; using the same shift-and-add algorithm that's
35695                                                                          ; documented in MULT1
35696 E412 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     E414 0000     
35697               
35698 E416 D38D  18        movb ra,rx                      ; TAX               ; Set (Y X) = 0 so we can start building the answer here
35699 E418 D3CD  18        movb ra,ry                      ; TAY
35700               
35701                      .lsr @S                         ; LSR S             ; Shift (S R) to the right, so we extract bit 0 of (S R)
     **** ****     > LSR
0001 E41A D020  30        movb @S,rtmp
     E41C 0092     
0002 E41E 0910  18        srl  rtmp,1
0003 E420 D800  30        movb rtmp,@S
     E422 0092     
                   < elite.a99
35702 E424 0204  20        li   rarg1,R                    ; ROR R             ; into the C flag
     E426 0091     
35703 E428 06A0  32        bl   @ror                       ;
     E42A FE70     
35704               
35705                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 E42C D020  30        movb @Q,rtmp
     E42E 0090     
0002 E430 0240  22        andi rtmp,>ff00
     E432 FF00     
0003 E434 0A10  18        sla  rtmp,1
0004 E436 D800  30        movb rtmp,@Q
     E438 0090     
                   < elite.a99
35706               
35707 E43A 170D  14        jnc  LL126                      ; BCC LL126         ; If C (i.e. the next bit from Q) is clear, do not do
35708                                                                          ; the addition for this bit of Q, and instead skip to
35709                                                                          ; LL126 to just do the shifts
35710               
35711               LL125:
35712 E43C D34E  18        movb rx,ra                      ; TXA               ; Set (Y X) = (Y X) + (S R)
35713                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 E43E 0A16  18        sla  rzero,1
                   < elite.a99
35714                      .adc @R,ra                      ; ADC R             ; starting with the low bytes
     **** ****     > ADC
0001 E440 1701  14        jnc  !
0002 E442 B347  18        ab   rone,ra
0003               !:
0004 E444 B360  30        ab   @R,ra
     E446 0091     
                   < elite.a99
35715 E448 D38D  18        movb ra,rx                      ; TAX
35716               
35717 E44A D34F  18        movb ry,ra                      ; TYA               ; And then doing the high bytes
35718                      .adc @S,ra                      ; ADC S
     **** ****     > ADC
0001 E44C 1701  14        jnc  !
0002 E44E B347  18        ab   rone,ra
0003               !:
0004 E450 B360  30        ab   @S,ra
     E452 0092     
                   < elite.a99
35719 E454 D3CD  18        movb ra,ry                      ; TAY
35720               
35721               LL126:
35722                      .lsr @S                         ; LSR S             ; Shift (S R) to the right
     **** ****     > LSR
0001 E456 D020  30        movb @S,rtmp
     E458 0092     
0002 E45A 0910  18        srl  rtmp,1
0003 E45C D800  30        movb rtmp,@S
     E45E 0092     
                   < elite.a99
35723 E460 0204  20        li   rarg1,R                    ; ROR R
     E462 0091     
35724 E464 06A0  32        bl   @ror                       ;
     E466 FE70     
35725               
35726                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 E468 D020  30        movb @Q,rtmp
     E46A 0090     
0002 E46C 0240  22        andi rtmp,>ff00
     E46E FF00     
0003 E470 0A10  18        sla  rtmp,1
0004 E472 D800  30        movb rtmp,@Q
     E474 0090     
                   < elite.a99
35727               
35728 E476 18E2  14        joc  LL125                      ; BCS LL125         ; If C (i.e. the next bit from Q) is set, loop back to
35729                                                                          ; LL125 to do the addition for this bit of Q
35730               
35731 E478 16EE  14        jne  LL126                      ; BNE LL126         ; If Q has not yet run out of set bits, loop back to
35732                                                                          ; LL126 to do the "shift" part of shift-and-add until
35733                                                                          ; we have done additions for all the set bits in Q, to
35734                                                                          ; give us our multiplication result
35735               
35736                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 E47A 058A  14        inc  rsp
0002 E47C D35A  26        movb *rsp,ra
                   < elite.a99
35737               
35738 E47E 153E  14        jgt  LL133                      ; BPL LL133         ; If A is positive jump to LL133 to negate (Y X) and
35739                                                                          ; return from the subroutine using a tail call
35740               
35741 E480 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E482 FE2A     
35742               
35743               * ******************************************************************************
35744               *
35745               * Name: LL123
35746               * Type: Subroutine
35747               * Category: Maths (Arithmetic)
35748               * Summary: Calculate (Y X) = (S R) / XX12+2 or (S R) * XX12+2
35749               *
35750               * ------------------------------------------------------------------------------
35751               *
35752               * Calculate the following:
35753               *
35754               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2
35755               *
35756               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2
35757               *
35758               * giving (Y X) the opposite sign to the slope direction in XX12+3.
35759               *
35760               * ------------------------------------------------------------------------------
35761               *
35762               * Arguments:
35763               *
35764               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
35765               *
35766               * XX12+3              The direction of slope:
35767               *
35768               * * Bit 7 clear means top left to bottom right
35769               *
35770               * * Bit 7 set means top right to bottom left
35771               *
35772               * T                   The gradient of slope:
35773               *
35774               * * 0 if it's a shallow slope
35775               *
35776               * * &FF if it's a steep slope
35777               *
35778               * ------------------------------------------------------------------------------
35779               *
35780               * Other entry points:
35781               *
35782               * LL121               Calculate (Y X) = (S R) / Q and set the sign to the
35783               * opposite of the top byte on the stack
35784               *
35785               * LL133               Negate (Y X) and return from the subroutine
35786               *
35787               * LL128               Contains an RTS
35788               *
35789               * ******************************************************************************
35790               
35791               LL123:
35792 E484 0200  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     E486 E524     
35793 E488 06A0  32        bl   @jsr                       ;
     E48A FE1E     
35794                                                                          ;
35795                                                                          ; Q = XX12+2
35796                                                                          ; = line gradient
35797                                                                          ;
35798                                                                          ; A = S EOR XX12+3
35799                                                                          ; = S EOR slope direction
35800                                                                          ;
35801                                                                          ; (S R) = |S R|
35802                                                                          ;
35803                                                                          ; So A contains the sign of S * slope direction
35804               
35805                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 E48C D68D  30        movb ra,*rsp
0002 E48E 060A  14        dec  rsp
                   < elite.a99
35806               
35807 E490 D3A0  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump up
     E492 00D1     
35808 E494 16BE  14        jne  LL122                      ; BNE LL122         ; to LL122 to calculate this instead:
35809                                                                          ;
35810                                                                          ; (Y X) = (S R) * Q
35811               
35812               LL121:
35813                                                                          ; The following calculates:
35814                                                                          ;
35815                                                                          ; (Y X) = (S R) / Q
35816                                                                          ;
35817                                                                          ; using the same shift-and-subtract algorithm that's
35818                                                                          ; documented in TIS2
35819 E496 020D  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set Y = %11111111
     E498 FF00     
35820 E49A D3CD  18        movb ra,ry                      ; TAY
35821               
35822                      .asla                           ; ASL A             ; Set X = %11111110
     **** ****     > ASLA
0001 E49C 024D  22        andi ra,>ff00
     E49E FF00     
0002 E4A0 0A1D  18        sla  ra,1
                   < elite.a99
35823 E4A2 D38D  18        movb ra,rx                      ; TAX
35824               
35825                                                                          ; This sets (Y X) = %1111111111111110, so we can rotate
35826                                                                          ; through 15 loop iterations, getting a 1 each time, and
35827                                                                          ; then getting a 0 on the 16th iteration... and we can
35828                                                                          ; also use it to catch our result bits into bit 0 each
35829                                                                          ; time
35830               
35831               LL130:
35832                      .asl @R                         ; ASL R             ; Shift (S R) to the left
     **** ****     > ASL
0001 E4A4 D020  30        movb @R,rtmp
     E4A6 0091     
0002 E4A8 0240  22        andi rtmp,>ff00
     E4AA FF00     
0003 E4AC 0A10  18        sla  rtmp,1
0004 E4AE D800  30        movb rtmp,@R
     E4B0 0091     
                   < elite.a99
35833 E4B2 0204  20        li   rarg1,S                    ; ROL S
     E4B4 0092     
35834 E4B6 06A0  32        bl   @rol                       ;
     E4B8 FE44     
35835               
35836 E4BA D360  30        movb @S,ra                      ; LDA S             ; Set A = S
     E4BC 0092     
35837               
35838 E4BE 1803  14        joc  LL131                      ; BCS LL131         ; If bit 7 of S was set, then jump straight to the
35839                                                                          ; subtraction
35840               
35841 E4C0 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q (i.e. S < Q), skip the following subtractions
     E4C2 0090     
35842 E4C4 170F  14        jnc  LL132                      ; BCC LL132
35843               
35844               LL131:
35845                      .sbc @Q,ra                      ; SBC Q             ; A >= Q (i.e. S >= Q) so set:
     **** ****     > SBC
0001 E4C6 1801  14        joc  !
0002 E4C8 7347  18        sb   rone,ra
0003               !:
0004 E4CA 7360  30        sb   @Q,ra
     E4CC 0090     
                   < elite.a99
35846 E4CE D80D  30        movb ra,@S                      ; STA S             ;
     E4D0 0092     
35847                                                                          ; S = (A R) - Q
35848                                                                          ; = (S R) - Q
35849                                                                          ;
35850                                                                          ; starting with the low bytes (we know the C flag is
35851                                                                          ; set so the subtraction will be correct)
35852               
35853 E4D2 D360  30        movb @R,ra                      ; LDA R             ; And then doing the high bytes
     E4D4 0091     
35854                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 E4D6 1801  14        joc  !
0002 E4D8 7347  18        sb   rone,ra
0003               !:
0004 E4DA 022D  22        ai   ra,-(>00*256)
     E4DC 0000     
                   < elite.a99
35855 E4DE D80D  30        movb ra,@R                      ; STA R
     E4E0 0091     
35856               
35857                      .sec                            ; SEC               ; Set the C flag to rotate into the result in (Y X)
     **** ****     > SEC
0001 E4E2 0A18  18        sla  rmone,1
                   < elite.a99
35858               
35859               LL132:
35860 E4E4 D34E  18        movb rx,ra                      ; TXA               ; Rotate the counter in (Y X) to the left, and catch the
35861 E4E6 06A0  32        bl   @rola                      ; ROL A             ; result bit into bit 0 (which will be a 0 if we didn't
     E4E8 FE34     
35862 E4EA D38D  18        movb ra,rx                      ; TAX               ; do the subtraction, or 1 if we did)
35863 E4EC D34F  18        movb ry,ra                      ; TYA
35864 E4EE 06A0  32        bl   @rola                      ; ROL A
     E4F0 FE34     
35865 E4F2 D3CD  18        movb ra,ry                      ; TAY
35866               
35867 E4F4 18D7  14        joc  LL130                      ; BCS LL130         ; If we still have set bits in (Y X), loop back to LL130
35868                                                                          ; to do the next iteration of 15, until we have done the
35869                                                                          ; whole division
35870               
35871                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 E4F6 058A  14        inc  rsp
0002 E4F8 D35A  26        movb *rsp,ra
                   < elite.a99
35872               
35873 E4FA 1112  14        jlt  LL128                      ; BMI LL128         ; If A is negative jump to LL128 to return from the
35874                                                                          ; subroutine with (Y X) as is
35875               
35876               LL133:
35877 E4FC D34E  18        movb rx,ra                      ; TXA               ; Otherwise negate (Y X) using two's complement by first
35878                      .eoi (>ff*256)                  ; EOR #%11111111    ; setting the low byte to ~X + 1
     **** ****     > EOI
0001 E4FE 0200  20        li   rtmp,(>FF*256)
     E500 FF00     
0002 E502 2B40  18        xor  rtmp,ra
                   < elite.a99
35879               * CLC                    \
35880                      .adi (>01*256)                  ; ADC #1            ; The CLC instruction is commented out in the original
     **** ****     > ADI
0001 E504 1701  14        jnc  !
0002 E506 B347  18        ab   rone,ra
0003               !:
0004 E508 022D  22        ai   ra,(>01*256)
     E50A 0100     
                   < elite.a99
35881 E50C D38D  18        movb ra,rx                      ; TAX               ; source. It would have no effect as we know the C flag
35882                                                                          ; is clear from when we passed through the BCS above
35883               
35884 E50E D34F  18        movb ry,ra                      ; TYA               ; Then set the high byte to ~Y + C
35885                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 E510 0200  20        li   rtmp,(>FF*256)
     E512 FF00     
0002 E514 2B40  18        xor  rtmp,ra
                   < elite.a99
35886                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 E516 1701  14        jnc  !
0002 E518 B347  18        ab   rone,ra
0003               !:
0004 E51A 022D  22        ai   ra,(>00*256)
     E51C 0000     
                   < elite.a99
35887 E51E D3CD  18        movb ra,ry                      ; TAY
35888               
35889               LL128:
35890 E520 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E522 FE2A     
35891               
35892               * ******************************************************************************
35893               *
35894               * Name: LL129
35895               * Type: Subroutine
35896               * Category: Maths (Arithmetic)
35897               * Summary: Calculate Q = XX12+2, A = S EOR XX12+3 and (S R) = |S R|
35898               *
35899               * ------------------------------------------------------------------------------
35900               *
35901               * Do the following, in this order:
35902               *
35903               * Q = XX12+2
35904               *
35905               * A = S EOR XX12+3
35906               *
35907               * (S R) = |S R|
35908               *
35909               * This sets up the variables required above to calculate (S R) / XX12+2 and give
35910               * the result the opposite sign to XX13+3.
35911               *
35912               * ******************************************************************************
35913               
35914               LL129:
35915 E524 D3A0  30        movb @XX12+2,rx                 ; LDX XX12+2        ; Set Q = XX12+2
     E526 0039     
35916 E528 D80E  30        movb rx,@Q                      ; STX Q
     E52A 0090     
35917               
35918 E52C D360  30        movb @S,ra                      ; LDA S             ; If S is positive, jump to LL127
     E52E 0092     
35919 E530 1518  14        jgt  LL127                      ; BPL LL127
35920               
35921 E532 020D  20        li   ra,>00*256                 ; LDA #0            ; Otherwise set R = -R
     E534 0000     
35922                      .sec                            ; SEC
     **** ****     > SEC
0001 E536 0A18  18        sla  rmone,1
                   < elite.a99
35923                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 E538 1801  14        joc  !
0002 E53A 7347  18        sb   rone,ra
0003               !:
0004 E53C 7360  30        sb   @R,ra
     E53E 0091     
                   < elite.a99
35924 E540 D80D  30        movb ra,@R                      ; STA R
     E542 0091     
35925               
35926 E544 D360  30        movb @S,ra                      ; LDA S             ; Push S onto the stack
     E546 0092     
35927                      .pha                            ; PHA
     **** ****     > PHA
0001 E548 D68D  30        movb ra,*rsp
0002 E54A 060A  14        dec  rsp
                   < elite.a99
35928               
35929                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set S = ~S + 1 + C
     **** ****     > EOI
0001 E54C 0200  20        li   rtmp,(>FF*256)
     E54E FF00     
0002 E550 2B40  18        xor  rtmp,ra
                   < elite.a99
35930                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 E552 1701  14        jnc  !
0002 E554 B347  18        ab   rone,ra
0003               !:
0004 E556 022D  22        ai   ra,(>00*256)
     E558 0000     
                   < elite.a99
35931 E55A D80D  30        movb ra,@S                      ; STA S
     E55C 0092     
35932               
35933                      .pla                            ; PLA               ; Pull the original, negative S from the stack into A
     **** ****     > PLA
0001 E55E 058A  14        inc  rsp
0002 E560 D35A  26        movb *rsp,ra
                   < elite.a99
35934               
35935               LL127:
35936                      .eor @XX12+3                    ; EOR XX12+3        ; Set A = original argument S EOR'd with XX12+3
     **** ****     > EOR
0001 E562 D020  30        movb @XX12+3,rtmp
     E564 003A     
0002 E566 2B40  18        xor  rtmp,ra
                   < elite.a99
35937               
35938 E568 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E56A FE2A     
35939               
35940               * ******************************************************************************
35941               *
35942               * Name: LL145 (Part 1 of 4)
35943               * Type: Subroutine
35944               * Category: Drawing lines
35945               * Summary: Clip line: Work out which end-points are on-screen, if any
35946               * Deep dive: Line-clipping
35947               * Extended screen coordinates
35948               *
35949               * ------------------------------------------------------------------------------
35950               *
35951               * This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or
35952               * returns an error if it can't be clipped to fit. The arguments are 16-bit
35953               * coordinates, and the clipped line is returned using 8-bit screen coordinates.
35954               *
35955               * This part sets XX13 to reflect which of the two points are on-screen and
35956               * off-screen.
35957               *
35958               * ------------------------------------------------------------------------------
35959               *
35960               * Arguments:
35961               *
35962               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
35963               *
35964               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
35965               *
35966               * XX15(5 4)           x2 as a 16-bit coordinate (x2_hi x2_lo)
35967               *
35968               * XX12(1 0)           y2 as a 16-bit coordinate (y2_hi y2_lo)
35969               *
35970               * ------------------------------------------------------------------------------
35971               *
35972               * Returns:
35973               *
35974               * (X1, Y1)            Screen coordinate of the start of the clipped line
35975               *
35976               * (X2, Y2)            Screen coordinate of the end of the clipped line
35977               *
35978               * C flag              Clear if the clipped line fits on-screen, set if it
35979               * doesn't
35980               *
35981               * XX13                The state of the original coordinates on-screen:
35982               *
35983               * * 0   = (x2, y2) on-screen
35984               *
35985               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
35986               *
35987               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
35988               *
35989               * So XX13 is non-zero if the end of the line was clipped,
35990               * meaning the next line sent to BLINE can't join onto the
35991               * end but has to start a new segment
35992               *
35993               * SWAP                The swap status of the returned coordinates:
35994               *
35995               * * &FF if we swapped the values of (x1, y1) and
35996               * (x2, y2) as part of the clipping process
35997               *
35998               * * 0 if the coordinates are still in the same order
35999               *
36000               * Y                   Y is preserved
36001               *
36002               * ------------------------------------------------------------------------------
36003               *
36004               * Other entry points:
36005               *
36006               * LL147               Don't initialise the values in SWAP or A
36007               *
36008               * ******************************************************************************
36009               
36010               LL145:
36011 E56C 020D  20        li   ra,>00*256                 ; LDA #0            ; Set SWAP = 0
     E56E 0000     
36012 E570 D80D  30        movb ra,@SWAP                   ; STA SWAP
     E572 00A1     
36013               
36014 E574 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = x2_hi
     E576 0036     
36015               
36016               LL147:
36017 E578 020E  20        li   rx,(Y*2-1)*256             ; LDX #Y*2-1        ; Set X = #Y * 2 - 1. The constant #Y is 96, the
     E57A BF00     
36018                                                                          ; y-coordinate of the mid-point of the space view, so
36019                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
36020                                                                          ; pixel row of the space view
36021               
36022 E57C F360  30        socb @XX12+1,ra                 ; ORA XX12+1        ; If one or both of x2_hi and y2_hi are non-zero, jump
     E57E 0038     
36023 E580 1605  14        jne  LL107                      ; BNE LL107         ; to LL107 to skip the following, leaving X at 191
36024               
36025 E582 93A0  30        cb   @XX12,rx                   ; CPX XX12          ; If y2_lo > the y-coordinate of the bottom of screen
     E584 0037     
36026 E586 1702  14        jnc  LL107                      ; BCC LL107         ; then (x2, y2) is off the bottom of the screen, so skip
36027                                                                          ; the following instruction, leaving X at 191
36028               
36029 E588 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0
     E58A 0000     
36030               
36031               LL107:
36032 E58C D80E  30        movb rx,@XX13                   ; STX XX13          ; Set XX13 = X, so we have:
     E58E 0098     
36033                                                                          ;
36034                                                                          ; * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen
36035                                                                          ;
36036                                                                          ; * XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo
36037                                                                          ; is off the bottom of the screen
36038                                                                          ;
36039                                                                          ; In other words, XX13 is 191 if (x2, y2) is off-screen,
36040                                                                          ; otherwise it is 0
36041               
36042 E590 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If one or both of x1_hi and y1_hi are non-zero, jump
     E592 0032     
36043 E594 F360  30        socb @XX15+3,ra                 ; ORA XX15+3        ; to LL83
     E596 0034     
36044 E598 161F  14        jne  LL83                       ; BNE LL83
36045               
36046 E59A 020D  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; If y1_lo > the y-coordinate of the bottom of screen
     E59C BF00     
36047 E59E 9360  30        cb   @XX15+2,ra                 ; CMP XX15+2        ; then (x1, y1) is off the bottom of the screen, so jump
     E5A0 0033     
36048 E5A2 171A  14        jnc  LL83                       ; BCC LL83          ; to LL83
36049               
36050                                                                          ; If we get here, (x1, y1) is on-screen
36051               
36052 E5A4 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
     E5A6 0098     
36053 E5A8 1612  14        jne  LL108                      ; BNE LL108         ; to LL108 to halve it before continuing at LL83
36054               
36055                                                                          ; If we get here, the high bytes are all zero, which
36056                                                                          ; means the x-coordinates are < 256 and therefore fit on
36057                                                                          ; screen, and neither coordinate is off the bottom of
36058                                                                          ; the screen. That means both coordinates are already on
36059                                                                          ; screen, so we don't need to do any clipping, all we
36060                                                                          ; need to do is move the low bytes into (X1, Y1) and
36061                                                                          ; X2, Y2) and return
36062               
36063               LL146:
36064                                                                          ; If we get here then we have clipped our line to the
36065                                                                          ; screen edge (if we had to clip it at all), so we move
36066                                                                          ; the low bytes from (x1, y1) and (x2, y2) into (X1, Y1)
36067                                                                          ; and (X2, Y2), remembering that they share locations
36068                                                                          ; with XX15:
36069                                                                          ;
36070                                                                          ; X1 = XX15
36071                                                                          ; Y1 = XX15+1
36072                                                                          ; X2 = XX15+2
36073                                                                          ; Y2 = XX15+3
36074                                                                          ;
36075                                                                          ; X1 already contains x1_lo, so now we do the rest
36076 E5AA D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Y1 (aka XX15+1) = y1_lo
     E5AC 0033     
36077 E5AE D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E5B0 0032     
36078               
36079 E5B2 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set X2 (aka XX15+2) = x2_lo
     E5B4 0035     
36080 E5B6 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E5B8 0033     
36081               
36082 E5BA D360  30        movb @XX12,ra                   ; LDA XX12          ; Set Y2 (aka XX15+3) = y2_lo
     E5BC 0037     
36083 E5BE D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E5C0 0034     
36084               
36085                      .clc                            ; CLC               ; Clear the C flag as the clipped line fits on-screen
     **** ****     > CLC
0001 E5C2 0A16  18        sla  rzero,1
                   < elite.a99
36086               
36087 E5C4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E5C6 FE2A     
36088               
36089               LL109:
36090                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 E5C8 0A18  18        sla  rmone,1
                   < elite.a99
36091                                                                          ; fit on-screen
36092               
36093 E5CA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E5CC FE2A     
36094               
36095               LL108:
36096                      .lsr @XX13                      ; LSR XX13          ; If we get here then (x2, y2) is off-screen and XX13 is
     **** ****     > LSR
0001 E5CE D020  30        movb @XX13,rtmp
     E5D0 0098     
0002 E5D2 0910  18        srl  rtmp,1
0003 E5D4 D800  30        movb rtmp,@XX13
     E5D6 0098     
                   < elite.a99
36097                                                                          ; 191, so shift XX13 right to halve it to 95
36098               
36099               * ******************************************************************************
36100               *
36101               * Name: LL145 (Part 2 of 4)
36102               * Type: Subroutine
36103               * Category: Drawing lines
36104               * Summary: Clip line: Work out if any part of the line is on-screen
36105               * Deep dive: Line-clipping
36106               * Extended screen coordinates
36107               *
36108               * ------------------------------------------------------------------------------
36109               *
36110               * This part does a number of tests to see if the line is on or off the screen.
36111               *
36112               * If we get here then at least one of (x1, y1) and (x2, y2) is off-screen, with
36113               * XX13 set as follows:
36114               *
36115               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
36116               *
36117               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36118               *
36119               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36120               *
36121               * where "off-screen" is defined as having a non-zero high byte in one of the
36122               * coordinates, or in the case of y-coordinates, having a low byte > 191, the
36123               * y-coordinate of the bottom of the space view.
36124               *
36125               * ******************************************************************************
36126               
36127               LL83:
36128 E5D8 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 < 128 then only one of the points is on-screen
     E5DA 0098     
36129 E5DC 1533  14        jgt  LL115                      ; BPL LL115         ; so jump down to LL115 to skip the checks of whether
36130                                                                          ; both points are in the strips to the right or bottom
36131                                                                          ; of the screen
36132               
36133                                                                          ; If we get here, both points are off-screen
36134               
36135 E5DE D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If both x1_hi and x2_hi have bit 7 set, jump to LL109
     E5E0 0032     
36136                      .and @XX15+5                    ; AND XX15+5        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 E5E2 D020  30        movb @XX15+5,rtmp
     E5E4 0036     
0002 E5E6 0540  14        inv  rtmp
0003 E5E8 5340  18        szcb rtmp,ra
                   < elite.a99
36137 E5EA 11EE  14        jlt  LL109                      ; BMI LL109         ; the entire line is above the top of the screen
36138               
36139 E5EC D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If both y1_hi and y2_hi have bit 7 set, jump to LL109
     E5EE 0034     
36140                      .and @XX12+1                    ; AND XX12+1        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 E5F0 D020  30        movb @XX12+1,rtmp
     E5F2 0038     
0002 E5F4 0540  14        inv  rtmp
0003 E5F6 5340  18        szcb rtmp,ra
                   < elite.a99
36141 E5F8 11E7  14        jlt  LL109                      ; BMI LL109         ; the entire line is to the left of the screen
36142               
36143 E5FA D3A0  30        movb @XX15+1,rx                 ; LDX XX15+1        ; Set A = X = x1_hi - 1
     E5FC 0032     
36144 E5FE 7387  18        sb   rone,rx                    ; DEX
36145 E600 D34E  18        movb rx,ra                      ; TXA
36146               
36147 E602 D3A0  30        movb @XX15+5,rx                 ; LDX XX15+5        ; Set XX12+2 = x2_hi - 1
     E604 0036     
36148 E606 7387  18        sb   rone,rx                    ; DEX
36149 E608 D80E  30        movb rx,@XX12+2                 ; STX XX12+2
     E60A 0039     
36150               
36151 E60C F360  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
     E60E 0039     
36152 E610 15DB  14        jgt  LL109                      ; BPL LL109         ; jump to LL109 to return from the subroutine with the C
36153                                                                          ; flag set, as the line doesn't fit on-screen
36154               
36155 E612 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo < y-coordinate of screen bottom, clear the C
     E614 0033     
36156 E616 028D  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     E618 C000     
36157               
36158 E61A D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set XX12+2 = y1_hi - (1 - C), so:
     E61C 0034     
36159                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 E61E 1801  14        joc  !
0002 E620 7347  18        sb   rone,ra
0003               !:
0004 E622 022D  22        ai   ra,-(>00*256)
     E624 0000     
                   < elite.a99
36160 E626 D80D  30        movb ra,@XX12+2                 ; STA XX12+2        ; * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen
     E628 0039     
36161                                                                          ; * Set XX12+2 = y1_hi     otherwise
36162                                                                          ;
36163                                                                          ; We do this subtraction because we are only interested
36164                                                                          ; in trying to move the points up by a screen if that
36165                                                                          ; might move the point into the space view portion of
36166                                                                          ; the screen, i.e. if y1_lo is on-screen
36167               
36168 E62A D360  30        movb @XX12,ra                   ; LDA XX12          ; If y2_lo < y-coordinate of screen bottom, clear the C
     E62C 0037     
36169 E62E 028D  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     E630 C000     
36170               
36171 E632 D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+2 = y2_hi - (1 - C), so:
     E634 0038     
36172                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 E636 1801  14        joc  !
0002 E638 7347  18        sb   rone,ra
0003               !:
0004 E63A 022D  22        ai   ra,-(>00*256)
     E63C 0000     
                   < elite.a99
36173                                                                          ; * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen
36174                                                                          ; * Set XX12+1 = y2_hi     otherwise
36175                                                                          ;
36176                                                                          ; We do this subtraction because we are only interested
36177                                                                          ; in trying to move the points up by a screen if that
36178                                                                          ; might move the point into the space view portion of
36179                                                                          ; the screen, i.e. if y1_lo is on-screen
36180               
36181 E63E F360  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither XX12+1 or XX12+2 have bit 7 set, jump to
     E640 0039     
36182 E642 15C2  14        jgt  LL109                      ; BPL LL109         ; LL109 to return from the subroutine with the C flag
36183                                                                          ; set, as the line doesn't fit on-screen
36184               
36185               * ******************************************************************************
36186               *
36187               * Name: LL145 (Part 3 of 4)
36188               * Type: Subroutine
36189               * Category: Drawing lines
36190               * Summary: Clip line: Calculate the line's gradient
36191               * Deep dive: Line-clipping
36192               * Extended screen coordinates
36193               *
36194               * ******************************************************************************
36195               
36196               LL115:
36197 E644 D34F  18        movb ry,ra                      ; TYA               ; Store Y on the stack so we can preserve it through the
36198                      .pha                            ; PHA               ; call to this subroutine
     **** ****     > PHA
0001 E646 D68D  30        movb ra,*rsp
0002 E648 060A  14        dec  rsp
                   < elite.a99
36199               
36200 E64A D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set XX12+2 = x2_lo - x1_lo
     E64C 0035     
36201                      .sec                            ; SEC
     **** ****     > SEC
0001 E64E 0A18  18        sla  rmone,1
                   < elite.a99
36202                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 E650 1801  14        joc  !
0002 E652 7347  18        sb   rone,ra
0003               !:
0004 E654 7360  30        sb   @XX15,ra
     E656 0031     
                   < elite.a99
36203 E658 D80D  30        movb ra,@XX12+2                 ; STA XX12+2
     E65A 0039     
36204               
36205 E65C D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set XX12+3 = x2_hi - x1_hi
     E65E 0036     
36206                      .sbc @XX15+1,ra                 ; SBC XX15+1
     **** ****     > SBC
0001 E660 1801  14        joc  !
0002 E662 7347  18        sb   rone,ra
0003               !:
0004 E664 7360  30        sb   @XX15+1,ra
     E666 0032     
                   < elite.a99
36207 E668 D80D  30        movb ra,@XX12+3                 ; STA XX12+3
     E66A 003A     
36208               
36209 E66C D360  30        movb @XX12,ra                   ; LDA XX12          ; Set XX12+4 = y2_lo - y1_lo
     E66E 0037     
36210                      .sec                            ; SEC
     **** ****     > SEC
0001 E670 0A18  18        sla  rmone,1
                   < elite.a99
36211                      .sbc @XX15+2,ra                 ; SBC XX15+2
     **** ****     > SBC
0001 E672 1801  14        joc  !
0002 E674 7347  18        sb   rone,ra
0003               !:
0004 E676 7360  30        sb   @XX15+2,ra
     E678 0033     
                   < elite.a99
36212 E67A D80D  30        movb ra,@XX12+4                 ; STA XX12+4
     E67C 003B     
36213               
36214 E67E D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+5 = y2_hi - y1_hi
     E680 0038     
36215                      .sbc @XX15+3,ra                 ; SBC XX15+3
     **** ****     > SBC
0001 E682 1801  14        joc  !
0002 E684 7347  18        sb   rone,ra
0003               !:
0004 E686 7360  30        sb   @XX15+3,ra
     E688 0034     
                   < elite.a99
36216 E68A D80D  30        movb ra,@XX12+5                 ; STA XX12+5
     E68C 003C     
36217               
36218                                                                          ; So we now have:
36219                                                                          ;
36220                                                                          ; delta_x in XX12(3 2)
36221                                                                          ; delta_y in XX12(5 4)
36222                                                                          ;
36223                                                                          ; where the delta is (x1, y1) - (x2, y2))
36224               
36225                      .eor @XX12+3                    ; EOR XX12+3        ; Set S = the sign of delta_x * the sign of delta_y, so
     **** ****     > EOR
0001 E68E D020  30        movb @XX12+3,rtmp
     E690 003A     
0002 E692 2B40  18        xor  rtmp,ra
                   < elite.a99
36226 E694 D80D  30        movb ra,@S                      ; STA S             ; if bit 7 of S is set, the deltas have different signs
     E696 0092     
36227               
36228 E698 D360  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If delta_y_hi is positive, jump down to LL110 to skip
     E69A 003C     
36229 E69C 1511  14        jgt  LL110                      ; BPL LL110         ; the following
36230               
36231 E69E 020D  20        li   ra,>00*256                 ; LDA #0            ; Otherwise flip the sign of delta_y to make it
     E6A0 0000     
36232                      .sec                            ; SEC               ; positive, starting with the low bytes
     **** ****     > SEC
0001 E6A2 0A18  18        sla  rmone,1
                   < elite.a99
36233                      .sbc @XX12+4,ra                 ; SBC XX12+4
     **** ****     > SBC
0001 E6A4 1801  14        joc  !
0002 E6A6 7347  18        sb   rone,ra
0003               !:
0004 E6A8 7360  30        sb   @XX12+4,ra
     E6AA 003B     
                   < elite.a99
36234 E6AC D80D  30        movb ra,@XX12+4                 ; STA XX12+4
     E6AE 003B     
36235               
36236 E6B0 020D  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     E6B2 0000     
36237                      .sbc @XX12+5,ra                 ; SBC XX12+5        ;
     **** ****     > SBC
0001 E6B4 1801  14        joc  !
0002 E6B6 7347  18        sb   rone,ra
0003               !:
0004 E6B8 7360  30        sb   @XX12+5,ra
     E6BA 003C     
                   < elite.a99
36238 E6BC D80D  30        movb ra,@XX12+5                 ; STA XX12+5        ; XX12(5 4) = |delta_y|
     E6BE 003C     
36239               
36240               LL110:
36241 E6C0 D360  30        movb @XX12+3,ra                 ; LDA XX12+3        ; If delta_x_hi is positive, jump down to LL111 to skip
     E6C2 003A     
36242 E6C4 150F  14        jgt  LL111                      ; BPL LL111         ; the following
36243               
36244                      .sec                            ; SEC               ; Otherwise flip the sign of delta_x to make it
     **** ****     > SEC
0001 E6C6 0A18  18        sla  rmone,1
                   < elite.a99
36245 E6C8 020D  20        li   ra,>00*256                 ; LDA #0            ; positive, starting with the low bytes
     E6CA 0000     
36246                      .sbc @XX12+2,ra                 ; SBC XX12+2
     **** ****     > SBC
0001 E6CC 1801  14        joc  !
0002 E6CE 7347  18        sb   rone,ra
0003               !:
0004 E6D0 7360  30        sb   @XX12+2,ra
     E6D2 0039     
                   < elite.a99
36247 E6D4 D80D  30        movb ra,@XX12+2                 ; STA XX12+2
     E6D6 0039     
36248               
36249 E6D8 020D  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     E6DA 0000     
36250                      .sbc @XX12+3,ra                 ; SBC XX12+3        ;
     **** ****     > SBC
0001 E6DC 1801  14        joc  !
0002 E6DE 7347  18        sb   rone,ra
0003               !:
0004 E6E0 7360  30        sb   @XX12+3,ra
     E6E2 003A     
                   < elite.a99
36251                                                                          ; (A XX12+2) = |delta_x|
36252               
36253               LL111:
36254                                                                          ; We now keep halving |delta_x| and |delta_y| until
36255                                                                          ; both of them have zero in their high bytes
36256 E6E4 D38D  18        movb ra,rx                      ; TAX               ; If |delta_x_hi| is non-zero, skip the following
36257 E6E6 1603  14        jne  LL112                      ; BNE LL112
36258               
36259 E6E8 D3A0  30        movb @XX12+5,rx                 ; LDX XX12+5        ; If |delta_y_hi| = 0, jump down to LL113 (as both
     E6EA 003C     
36260 E6EC 1310  14        jeq  LL113                      ; BEQ LL113         ; |delta_x_hi| and |delta_y_hi| are 0)
36261               
36262               LL112:
36263 E6EE 091D  18        srl  ra,1                       ; LSR A             ; Halve the value of delta_x in (A XX12+2)
36264 E6F0 0204  20        li   rarg1,XX12+2               ; ROR XX12+2
     E6F2 0039     
36265 E6F4 06A0  32        bl   @ror                       ;
     E6F6 FE70     
36266               
36267                      .lsr @XX12+5                    ; LSR XX12+5        ; Halve the value of delta_y XX12(5 4)
     **** ****     > LSR
0001 E6F8 D020  30        movb @XX12+5,rtmp
     E6FA 003C     
0002 E6FC 0910  18        srl  rtmp,1
0003 E6FE D800  30        movb rtmp,@XX12+5
     E700 003C     
                   < elite.a99
36268 E702 0204  20        li   rarg1,XX12+4               ; ROR XX12+4
     E704 003B     
36269 E706 06A0  32        bl   @ror                       ;
     E708 FE70     
36270               
36271 E70A 0460  28        b    @LL111                     ; JMP LL111         ; Loop back to LL111
     E70C E6E4     
36272               
36273               LL113:
36274                                                                          ; By now, the high bytes of both |delta_x| and |delta_y|
36275                                                                          ; are zero
36276 E70E D80E  30        movb rx,@T                      ; STX T             ; We know that X = 0 as that's what we tested with a BEQ
     E710 00D1     
36277                                                                          ; above, so this sets T = 0
36278               
36279 E712 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; If delta_x_lo < delta_y_lo, so our line is more
     E714 0039     
36280 E716 9360  30        cb   @XX12+4,ra                 ; CMP XX12+4        ; vertical than horizontal, jump to LL114
     E718 003B     
36281 E71A 170A  14        jnc  LL114                      ; BCC LL114
36282               
36283                                                                          ; If we get here then our line is more horizontal than
36284                                                                          ; vertical, so it is a shallow slope
36285               
36286 E71C D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = delta_x_lo
     E71E 0090     
36287               
36288 E720 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = delta_y_lo
     E722 003B     
36289               
36290 E724 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E726 D344     
36291 E728 06A0  32        bl   @jsr                       ;
     E72A FE1E     
36292                                                                          ;
36293                                                                          ; R = 256 * A / Q
36294                                                                          ; = 256 * delta_y_lo / delta_x_lo
36295               
36296 E72C 0460  28        b    @LL116                     ; JMP LL116         ; Jump to LL116, as we now have the line's gradient in R
     E72E E746     
36297               
36298               LL114:
36299                                                                          ; If we get here then our line is more vertical than
36300                                                                          ; horizontal, so it is a steep slope
36301 E730 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = delta_y_lo
     E732 003B     
36302 E734 D80D  30        movb ra,@Q                      ; STA Q
     E736 0090     
36303 E738 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set A = delta_x_lo
     E73A 0039     
36304               
36305 E73C 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E73E D344     
36306 E740 06A0  32        bl   @jsr                       ;
     E742 FE1E     
36307                                                                          ;
36308                                                                          ; R = 256 * A / Q
36309                                                                          ; = 256 * delta_x_lo / delta_y_lo
36310               
36311 E744 7347  18        sb   rone,ra                    ; DEC T             ; T was set to 0 above, so this sets T = &FF when our
36312                                                                          ; line is steep
36313               
36314               * ******************************************************************************
36315               *
36316               * Name: LL145 (Part 4 of 4)
36317               * Type: Subroutine
36318               * Category: Drawing lines
36319               * Summary: Clip line: Call the routine in LL188 to do the actual clipping
36320               * Deep dive: Line-clipping
36321               * Extended screen coordinates
36322               *
36323               * ------------------------------------------------------------------------------
36324               *
36325               * This part sets things up to call the routine in LL188, which does the actual
36326               * clipping.
36327               *
36328               * If we get here, then R has been set to the gradient of the line (x1, y1) to
36329               * (x2, y2), with T indicating the gradient of slope:
36330               *
36331               * * 0   = shallow slope (more horizontal than vertical)
36332               *
36333               * * &FF = steep slope (more vertical than horizontal)
36334               *
36335               * and XX13 has been set as follows:
36336               *
36337               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
36338               *
36339               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36340               *
36341               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36342               *
36343               * ******************************************************************************
36344               
36345               LL116:
36346 E746 D360  30        movb @R,ra                      ; LDA R             ; Store the gradient in XX12+2
     E748 0091     
36347 E74A D80D  30        movb ra,@XX12+2                 ; STA XX12+2
     E74C 0039     
36348               
36349 E74E D360  30        movb @S,ra                      ; LDA S             ; Store the type of slope in XX12+3, bit 7 clear means
     E750 0092     
36350 E752 D80D  30        movb ra,@XX12+3                 ; STA XX12+3        ; top left to bottom right, bit 7 set means top right to
     E754 003A     
36351                                                                          ; bottom left
36352               
36353 E756 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, skip the following instruction
     E758 0098     
36354 E75A 1301  14        jeq  LL138                      ; BEQ LL138
36355               
36356 E75C 1511  14        jgt  LLX117                     ; BPL LLX117        ; If XX13 is positive, it must be 95. This means
36357                                                                          ; (x1, y1) is on-screen but (x2, y2) isn't, so we jump
36358                                                                          ; to LLX117 to swap the (x1, y1) and (x2, y2)
36359                                                                          ; coordinates around before doing the actual clipping,
36360                                                                          ; because we need to clip (x2, y2) but the clipping
36361                                                                          ; routine at LL118 only clips (x1, y1)
36362               
36363               LL138:
36364                                                                          ; If we get here, XX13 = 0 or 191, so (x1, y1) is
36365                                                                          ; off-screen and needs clipping
36366 E75E 0200  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     E760 E2DC     
36367 E762 06A0  32        bl   @jsr                       ;
     E764 FE1E     
36368                                                                          ; screen, i.e. clip the line at the (x1, y1) end
36369               
36370 E766 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
     E768 0098     
36371 E76A 152F  14        jgt  LL124                      ; BPL LL124         ; LL124 to return with a successfully clipped line
36372               
36373               LL117:
36374                                                                          ; If we get here, XX13 = 191 (both coordinates are
36375                                                                          ; off-screen)
36376 E76C D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If either of x1_hi or y1_hi are non-zero, jump to
     E76E 0032     
36377 E770 F360  30        socb @XX15+3,ra                 ; ORA XX15+3        ; LL137 to return from the subroutine with the C flag
     E772 0034     
36378 E774 162F  14        jne  LL137                      ; BNE LL137         ; set, as the line doesn't fit on-screen
36379               
36380 E776 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo > y-coordinate of the bottom of the screen
     E778 0033     
36381 E77A 028D  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; jump to LL137 to return from the subroutine with the
     E77C C000     
36382 E77E 182A  14        joc  LL137                      ; BCS LL137         ; C flag set, as the line doesn't fit on-screen
36383               
36384               LLX117:
36385                                                                          ; If we get here, XX13 = 95 or 191, and in both cases
36386                                                                          ; (x2, y2) is off-screen, so we now need to swap the
36387                                                                          ; (x1, y1) and (x2, y2) coordinates around before doing
36388                                                                          ; the actual clipping, because we need to clip (x2, y2)
36389                                                                          ; but the clipping routine at LL118 only clips (x1, y1)
36390 E780 D3A0  30        movb @XX15,rx                   ; LDX XX15          ; Swap x1_lo = x2_lo
     E782 0031     
36391 E784 D360  30        movb @XX15+4,ra                 ; LDA XX15+4
     E786 0035     
36392 E788 D80D  30        movb ra,@XX15                   ; STA XX15
     E78A 0031     
36393 E78C D80E  30        movb rx,@XX15+4                 ; STX XX15+4
     E78E 0035     
36394               
36395 E790 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Swap x2_lo = x1_lo
     E792 0036     
36396 E794 D3A0  30        movb @XX15+1,rx                 ; LDX XX15+1
     E796 0032     
36397 E798 D80E  30        movb rx,@XX15+5                 ; STX XX15+5
     E79A 0036     
36398 E79C D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E79E 0032     
36399               
36400 E7A0 D3A0  30        movb @XX15+2,rx                 ; LDX XX15+2        ; Swap y1_lo = y2_lo
     E7A2 0033     
36401 E7A4 D360  30        movb @XX12,ra                   ; LDA XX12
     E7A6 0037     
36402 E7A8 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E7AA 0033     
36403 E7AC D80E  30        movb rx,@XX12                   ; STX XX12
     E7AE 0037     
36404               
36405 E7B0 D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Swap y2_lo = y1_lo
     E7B2 0038     
36406 E7B4 D3A0  30        movb @XX15+3,rx                 ; LDX XX15+3
     E7B6 0034     
36407 E7B8 D80E  30        movb rx,@XX12+1                 ; STX XX12+1
     E7BA 0038     
36408 E7BC D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E7BE 0034     
36409               
36410 E7C0 0200  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     E7C2 E2DC     
36411 E7C4 06A0  32        bl   @jsr                       ;
     E7C6 FE1E     
36412                                                                          ; screen, i.e. clip the line at the (x1, y1) end
36413               
36414 E7C8 7347  18        sb   rone,ra                    ; DEC SWAP          ; Set SWAP = &FF to indicate that we just clipped the
36415                                                                          ; line at the (x2, y2) end by swapping the coordinates
36416                                                                          ; (the DEC does this as we set SWAP to 0 at the start of
36417                                                                          ; this subroutine)
36418               
36419               LL124:
36420                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 E7CA 058A  14        inc  rsp
0002 E7CC D35A  26        movb *rsp,ra
                   < elite.a99
36421 E7CE D3CD  18        movb ra,ry                      ; TAY               ; the call to this subroutine
36422               
36423 E7D0 0460  28        b    @LL146                     ; JMP LL146         ; Jump up to LL146 to move the low bytes of (x1, y1) and
     E7D2 E5AA     
36424                                                                          ; (x2, y2) into (X1, Y1) and (X2, Y2), and return from
36425                                                                          ; the subroutine with a successfully clipped line
36426               
36427               LL137:
36428                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 E7D4 058A  14        inc  rsp
0002 E7D6 D35A  26        movb *rsp,ra
                   < elite.a99
36429 E7D8 D3CD  18        movb ra,ry                      ; TAY               ; the call to this subroutine
36430               
36431                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 E7DA 0A18  18        sla  rmone,1
                   < elite.a99
36432                                                                          ; fit on-screen
36433               
36434 E7DC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E7DE FE2A     
36435               
36436               * ******************************************************************************
36437               *
36438               * Save ELTG.bin
36439               *
36440               * ******************************************************************************
36441               
36442                      ; PRINT "ELITE G"
36443                      ; PRINT "Assembled at ", ~CODE_G%
36444                      ; PRINT "Ends at ", ~P%
36445                      ; PRINT "Code size is ", ~(P% - CODE_G%)
36446                      ; PRINT "Execute at ", ~LOAD%
36447                      ; PRINT "Reload at ", ~LOAD_G%
36448               
36449                      ; PRINT "S.ELTG ", ~CODE_G%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_G%
36450                      ; SAVE "3-assembled-output/ELTG.bin", CODE_G%, P%, LOAD%
36451               
36452               * ******************************************************************************
36453               *
36454               * Name: checksum0
36455               * Type: Variable
36456               * Category: Copy protection
36457               * Summary: Checksum for the entire main game code
36458               *
36459               * ------------------------------------------------------------------------------
36460               *
36461               * This byte contains a checksum for the entire main game code. It is populated
36462               * by elite-checksum.py and is used by the encryption checks in elite-loader.asm
36463               * (see the CHK routine in the loader for more details).
36464               *
36465               * ******************************************************************************
36466               
36467               checksum0_:
36468 E7E0                 bss 1                                               ; This value is checked against the calculated checksum
36469                                                                          ; in part 6 of the loader in elite-loader.asm
36470               
36471               * ******************************************************************************
36472               *
36473               * ELITE SHIP BLUEPRINTS FILE
36474               *
36475               * Produces the binary file SHIPS.bin that gets loaded by elite-bcfs.asm.
36476               *
36477               * ******************************************************************************
36478               
36479               CODE_SHIPS.:
36480                      equ $
36481               
36482               LOAD_SHIPS.:
36483                      equ LOAD. + $ - CODE.
36484               
36485               * ******************************************************************************
36486               *
36487               * Name: XX21
36488               * Type: Variable
36489               * Category: Drawing ships
36490               * Summary: Ship blueprints lookup table
36491               * Deep dive: Ship blueprints
36492               *
36493               * ******************************************************************************
36494               
36495               XX21:
36496 E7E2 E7FC            data SHIP_SIDEWINDER                                ; 1 = Sidewinder
36497 E7E4 E8A6            data SHIP_VIPER                                     ; COPS =  2 = Viper
36498 E7E6 E982            data SHIP_MAMBA                                     ; 3 = Mamba
36499 E7E8 F1BE            data SHIP_PYTHON                                    ; 4 = Python
36500 E7EA EAB2            data SHIP_COBRA_MK_3                                ; 5 = Cobra Mk III (bounty hunter)
36501 E7EC EC3C            data SHIP_THARGOID                                  ; THG  =  6 = Thargoid
36502 E7EE EAB2            data SHIP_COBRA_MK_3                                ; CYL  =  7 = Cobra Mk III (trader)
36503 E7F0 ED5A            data SHIP_CORIOLIS                                  ; SST  =  8 = Coriolis space station
36504 E7F2 EE78            data SHIP_MISSILE                                   ; MSL  =  9 = Missile
36505 E7F4 EF78            data SHIP_ASTEROID                                  ; AST  = 10 = Asteroid
36506 E7F6 F050            data SHIP_CANISTER                                  ; OIL  = 11 = Cargo canister
36507 E7F8 F0FA            data SHIP_THARGON                                   ; TGL  = 12 = Thargon
36508 E7FA F168            data SHIP_ESCAPE_POD                                ; ESC  = 13 = Escape pod
36509               
36510               * ******************************************************************************
36511               *
36512               * Name: VERTEX
36513               * Type: Macro
36514               * Category: Drawing ships
36515               * Summary: Macro definition for adding vertices to ship blueprints
36516               * Deep dive: Ship blueprints
36517               *
36518               * ------------------------------------------------------------------------------
36519               *
36520               * The following macro is used to build the ship blueprints:
36521               *
36522               * VERTEX x, y, z, face1, face2, face3, face4, visibility
36523               *
36524               * See the deep dive on "Ship blueprints" for details of how vertices are stored
36525               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36526               * on how vertices are used to draw 3D wireframe ships.
36527               *
36528               * ------------------------------------------------------------------------------
36529               *
36530               * Arguments:
36531               *
36532               * x                   The vertex's x-coordinate
36533               *
36534               * y                   The vertex's y-coordinate
36535               *
36536               * z                   The vertex's z-coordinate
36537               *
36538               * face1               The number of face 1 associated with this vertex
36539               *
36540               * face2               The number of face 2 associated with this vertex
36541               *
36542               * face3               The number of face 3 associated with this vertex
36543               *
36544               * face4               The number of face 4 associated with this vertex
36545               *
36546               * visibility          The visibility distance, beyond which the vertex is not
36547               * shown
36548               *
36549               * ******************************************************************************
36550               
36551                      ; MACRO VERTEX x, y, z, face1, face2, face3, face4, visibility
36552               
36553                      ; IF x < 0                      ;
36554                      ; s_x = 1 << 7                  ;
36555                      ; ELSE                          ;
36556                      ; s_x = 0                       ;
36557                      ; ENDIF                         ;
36558               
36559                      ; IF y < 0                      ;
36560                      ; s_y = 1 << 6                  ;
36561                      ; ELSE                          ;
36562                      ; s_y = 0                       ;
36563                      ; ENDIF                         ;
36564               
36565                      ; IF z < 0                      ;
36566                      ; s_z = 1 << 5                  ;
36567                      ; ELSE                          ;
36568                      ; s_z = 0                       ;
36569                      ; ENDIF                         ;
36570               
36571                      ; s = s_x + s_y + s_z + visibility ;
36572                      ; f1 = face1 + (face2 << 4)     ;
36573                      ; f2 = face3 + (face4 << 4)     ;
36574                      ; ax = ABS(x)                   ;
36575                      ; ay = ABS(y)                   ;
36576                      ; az = ABS(z)                   ;
36577               
36578                      ; EQUB ax, ay, az, s, f1, f2    ;
36579               
36580                      ; ENDMACRO
36581               
36582               * ******************************************************************************
36583               *
36584               * Name: EDGE
36585               * Type: Macro
36586               * Category: Drawing ships
36587               * Summary: Macro definition for adding edges to ship blueprints
36588               * Deep dive: Ship blueprints
36589               *
36590               * ------------------------------------------------------------------------------
36591               *
36592               * The following macro is used to build the ship blueprints:
36593               *
36594               * EDGE vertex1, vertex2, face1, face2, visibility
36595               *
36596               * See the deep dive on "Ship blueprints" for details of how edges are stored
36597               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36598               * on how edges are used to draw 3D wireframe ships.
36599               *
36600               * ------------------------------------------------------------------------------
36601               *
36602               * Arguments:
36603               *
36604               * vertex1             The number of the vertex at the start of the edge
36605               *
36606               * vertex1             The number of the vertex at the end of the edge
36607               *
36608               * face1               The number of face 1 associated with this edge
36609               *
36610               * face2               The number of face 2 associated with this edge
36611               *
36612               * visibility          The visibility distance, beyond which the edge is not
36613               * shown
36614               *
36615               * ******************************************************************************
36616               
36617                      ; MACRO EDGE vertex1, vertex2, face1, face2, visibility
36618               
36619                      ; f = face1 + (face2 << 4)      ;
36620                      ; EQUB visibility, f, vertex1 << 2, vertex2 << 2 ;
36621               
36622                      ; ENDMACRO
36623               
36624               * ******************************************************************************
36625               *
36626               * Name: FACE
36627               * Type: Macro
36628               * Category: Drawing ships
36629               * Summary: Macro definition for adding faces to ship blueprints
36630               * Deep dive: Ship blueprints
36631               *
36632               * ------------------------------------------------------------------------------
36633               *
36634               * The following macro is used to build the ship blueprints:
36635               *
36636               * FACE normal_x, normal_y, normal_z, visibility
36637               *
36638               * See the deep dive on "Ship blueprints" for details of how faces are stored
36639               * in the ship blueprints, and the deep dive on "Drawing ships" for information
36640               * on how faces are used to draw 3D wireframe ships.
36641               *
36642               * ------------------------------------------------------------------------------
36643               *
36644               * Arguments:
36645               *
36646               * normal_x            The face normal's x-coordinate
36647               *
36648               * normal_y            The face normal's y-coordinate
36649               *
36650               * normal_z            The face normal's z-coordinate
36651               *
36652               * visibility          The visibility distance, beyond which the edge is always
36653               * shown
36654               *
36655               * ******************************************************************************
36656               
36657                      ; MACRO FACE normal_x, normal_y, normal_z, visibility
36658               
36659                      ; IF normal_x < 0               ;
36660                      ; s_x = 1 << 7                  ;
36661                      ; ELSE                          ;
36662                      ; s_x = 0                       ;
36663                      ; ENDIF                         ;
36664               
36665                      ; IF normal_y < 0               ;
36666                      ; s_y = 1 << 6                  ;
36667                      ; ELSE                          ;
36668                      ; s_y = 0                       ;
36669                      ; ENDIF                         ;
36670               
36671                      ; IF normal_z < 0               ;
36672                      ; s_z = 1 << 5                  ;
36673                      ; ELSE                          ;
36674                      ; s_z = 0                       ;
36675                      ; ENDIF                         ;
36676               
36677                      ; s = s_x + s_y + s_z + visibility ;
36678                      ; ax = ABS(normal_x)            ;
36679                      ; ay = ABS(normal_y)            ;
36680                      ; az = ABS(normal_z)            ;
36681               
36682                      ; EQUB s, ax, ay, az            ;
36683               
36684                      ; ENDMACRO
36685               
36686               * ******************************************************************************
36687               *
36688               * Name: SHIP_SIDEWINDER
36689               * Type: Variable
36690               * Category: Drawing ships
36691               * Summary: Ship blueprint for a Sidewinder
36692               * Deep dive: Ship blueprints
36693               *
36694               * ******************************************************************************
36695               
36696               SHIP_SIDEWINDER:
36697 E7FC 00              byte >00                                            ; Max. canisters on demise = 0
36698 E7FE 1081            data 65 * 65                                        ; Targetable area          = 65 * 65
36699               
36700 E800 52              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)%256  ; Edges data offset (low)
36701 E801   8E            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)%256  ; Faces data offset (low)
36702               
36703 E802 3D              byte >3d                                            ; Max. edge count          = (61 - 1) / 4 = 15
36704 E803   00            byte >00                                            ; Gun vertex               = 0
36705 E804 1E              byte >1e                                            ; Explosion count          = 6, as (4 * n) + 6 = 30
36706 E805   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
36707 E806 0F              byte >0f                                            ; Number of edges          = 15
36708 E808 3200            data >3200                                          ; Bounty                   = 50
36709 E80A 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
36710 E80B   14            byte >14                                            ; Visibility distance      = 20
36711 E80C 46              byte >46                                            ; Max. energy              = 70
36712 E80D   25            byte >25                                            ; Max. speed               = 37
36713               
36714 E80E 00              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)/256  ; Edges data offset (high)
36715 E80F   00            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)/256  ; Faces data offset (high)
36716               
36717 E810 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
36718 E811   10            byte >10                                            ; Laser power              = 2
36719                                                                          ; Missiles                 = 0
36720               
36721               SHIP_SIDEWINDER_VERTICES:
36722                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36723 E812 2000            byte >20, >00, >24, >9f, >10, >54                   ; Vertex 0
     E814 249F     
     E816 1054     
36724 E818 2000            byte >20, >00, >24, >1f, >20, >65                   ; Vertex 1
     E81A 241F     
     E81C 2065     
36725 E81E 4000            byte >40, >00, >1c, >3f, >32, >66                   ; Vertex 2
     E820 1C3F     
     E822 3266     
36726 E824 4000            byte >40, >00, >1c, >bf, >31, >44                   ; Vertex 3
     E826 1CBF     
     E828 3144     
36727 E82A 0010            byte >00, >10, >1c, >3f, >10, >32                   ; Vertex 4
     E82C 1C3F     
     E82E 1032     
36728 E830 0010            byte >00, >10, >1c, >7f, >43, >65                   ; Vertex 5
     E832 1C7F     
     E834 4365     
36729 E836 0C06            byte >0c, >06, >1c, >af, >33, >33                   ; Vertex 6
     E838 1CAF     
     E83A 3333     
36730 E83C 0C06            byte >0c, >06, >1c, >2f, >33, >33                   ; Vertex 7
     E83E 1C2F     
     E840 3333     
36731 E842 0C06            byte >0c, >06, >1c, >6c, >33, >33                   ; Vertex 8
     E844 1C6C     
     E846 3333     
36732 E848 0C06            byte >0c, >06, >1c, >ec, >33, >33                   ; Vertex 9
     E84A 1CEC     
     E84C 3333     
36733               
36734               SHIP_SIDEWINDER_EDGES:
36735                                                                          ; vertex1, vertex2, face1, face2, visibility
36736 E84E 1F50            byte >1f, >50, >00, >04                             ; Edge 0
     E850 0004     
36737 E852 1F62            byte >1f, >62, >04, >08                             ; Edge 1
     E854 0408     
36738 E856 1F20            byte >1f, >20, >04, >10                             ; Edge 2
     E858 0410     
36739 E85A 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     E85C 0010     
36740 E85E 1F41            byte >1f, >41, >00, >0c                             ; Edge 4
     E860 000C     
36741 E862 1F31            byte >1f, >31, >0c, >10                             ; Edge 5
     E864 0C10     
36742 E866 1F32            byte >1f, >32, >08, >10                             ; Edge 6
     E868 0810     
36743 E86A 1F43            byte >1f, >43, >0c, >14                             ; Edge 7
     E86C 0C14     
36744 E86E 1F63            byte >1f, >63, >08, >14                             ; Edge 8
     E870 0814     
36745 E872 1F65            byte >1f, >65, >04, >14                             ; Edge 9
     E874 0414     
36746 E876 1F54            byte >1f, >54, >00, >14                             ; Edge 10
     E878 0014     
36747 E87A 0F33            byte >0f, >33, >18, >1c                             ; Edge 11
     E87C 181C     
36748 E87E 0C33            byte >0c, >33, >1c, >20                             ; Edge 12
     E880 1C20     
36749 E882 0C33            byte >0c, >33, >18, >24                             ; Edge 13
     E884 1824     
36750 E886 0C33            byte >0c, >33, >20, >24                             ; Edge 14
     E888 2024     
36751               
36752               SHIP_SIDEWINDER_FACES:
36753                                                                          ; normal_x, normal_y, normal_z, visibility
36754 E88A 1F00            byte >1f, >00, >20, >08                             ; Face 0
     E88C 2008     
36755 E88E 9F0C            byte >9f, >0c, >2f, >06                             ; Face 1
     E890 2F06     
36756 E892 1F0C            byte >1f, >0c, >2f, >06                             ; Face 2
     E894 2F06     
36757 E896 3F00            byte >3f, >00, >00, >70                             ; Face 3
     E898 0070     
36758 E89A DF0C            byte >df, >0c, >2f, >06                             ; Face 4
     E89C 2F06     
36759 E89E 5F00            byte >5f, >00, >20, >08                             ; Face 5
     E8A0 2008     
36760 E8A2 5F0C            byte >5f, >0c, >2f, >06                             ; Face 6
     E8A4 2F06     
36761               
36762               * ******************************************************************************
36763               *
36764               * Name: SHIP_VIPER
36765               * Type: Variable
36766               * Category: Drawing ships
36767               * Summary: Ship blueprint for a Viper
36768               * Deep dive: Ship blueprints
36769               *
36770               * ******************************************************************************
36771               
36772               SHIP_VIPER:
36773 E8A6 00              byte >00                                            ; Max. canisters on demise = 0
36774 E8A8 15F9            data 75 * 75                                        ; Targetable area          = 75 * 75
36775               
36776 E8AA 70              byte (SHIP_VIPER_EDGES - SHIP_VIPER)%256            ; Edges data offset (low)
36777 E8AB   C0            byte (SHIP_VIPER_FACES - SHIP_VIPER)%256            ; Faces data offset (low)
36778               
36779 E8AC 4D              byte >4d                                            ; Max. edge count          = (77 - 1) / 4 = 19
36780 E8AD   00            byte >00                                            ; Gun vertex               = 0
36781 E8AE 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
36782 E8AF   5A            byte >5a                                            ; Number of vertices       = 90 / 6 = 15
36783 E8B0 14              byte >14                                            ; Number of edges          = 20
36784 E8B2 0000            data >0000                                          ; Bounty                   = 0
36785 E8B4 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
36786 E8B5   17            byte >17                                            ; Visibility distance      = 23
36787 E8B6 78              byte >78                                            ; Max. energy              = 120
36788 E8B7   20            byte >20                                            ; Max. speed               = 32
36789               
36790 E8B8 00              byte (SHIP_VIPER_EDGES - SHIP_VIPER)/256            ; Edges data offset (high)
36791 E8B9   00            byte (SHIP_VIPER_FACES - SHIP_VIPER)/256            ; Faces data offset (high)
36792               
36793 E8BA 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
36794 E8BB   11            byte >11                                            ; Laser power              = 2
36795                                                                          ; Missiles                 = 1
36796               
36797               SHIP_VIPER_VERTICES:
36798                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36799 E8BC 0000            byte >00, >00, >48, >1f, >21, >43                   ; Vertex 0
     E8BE 481F     
     E8C0 2143     
36800 E8C2 0010            byte >00, >10, >18, >1e, >10, >22                   ; Vertex 1
     E8C4 181E     
     E8C6 1022     
36801 E8C8 0010            byte >00, >10, >18, >5e, >43, >55                   ; Vertex 2
     E8CA 185E     
     E8CC 4355     
36802 E8CE 3000            byte >30, >00, >18, >3f, >42, >66                   ; Vertex 3
     E8D0 183F     
     E8D2 4266     
36803 E8D4 3000            byte >30, >00, >18, >bf, >31, >66                   ; Vertex 4
     E8D6 18BF     
     E8D8 3166     
36804 E8DA 1810            byte >18, >10, >18, >7e, >54, >66                   ; Vertex 5
     E8DC 187E     
     E8DE 5466     
36805 E8E0 1810            byte >18, >10, >18, >fe, >35, >66                   ; Vertex 6
     E8E2 18FE     
     E8E4 3566     
36806 E8E6 1810            byte >18, >10, >18, >3f, >20, >66                   ; Vertex 7
     E8E8 183F     
     E8EA 2066     
36807 E8EC 1810            byte >18, >10, >18, >bf, >10, >66                   ; Vertex 8
     E8EE 18BF     
     E8F0 1066     
36808 E8F2 2000            byte >20, >00, >18, >b3, >66, >66                   ; Vertex 9
     E8F4 18B3     
     E8F6 6666     
36809 E8F8 2000            byte >20, >00, >18, >33, >66, >66                   ; Vertex 10
     E8FA 1833     
     E8FC 6666     
36810 E8FE 0808            byte >08, >08, >18, >33, >66, >66                   ; Vertex 11
     E900 1833     
     E902 6666     
36811 E904 0808            byte >08, >08, >18, >b3, >66, >66                   ; Vertex 12
     E906 18B3     
     E908 6666     
36812 E90A 0808            byte >08, >08, >18, >f2, >66, >66                   ; Vertex 13
     E90C 18F2     
     E90E 6666     
36813 E910 0808            byte >08, >08, >18, >72, >66, >66                   ; Vertex 14
     E912 1872     
     E914 6666     
36814               
36815               SHIP_VIPER_EDGES:
36816                                                                          ; vertex1, vertex2, face1, face2, visibility
36817 E916 1F42            byte >1f, >42, >00, >0c                             ; Edge 0
     E918 000C     
36818 E91A 1E21            byte >1e, >21, >00, >04                             ; Edge 1
     E91C 0004     
36819 E91E 1E43            byte >1e, >43, >00, >08                             ; Edge 2
     E920 0008     
36820 E922 1F31            byte >1f, >31, >00, >10                             ; Edge 3
     E924 0010     
36821 E926 1E20            byte >1e, >20, >04, >1c                             ; Edge 4
     E928 041C     
36822 E92A 1E10            byte >1e, >10, >04, >20                             ; Edge 5
     E92C 0420     
36823 E92E 1E54            byte >1e, >54, >08, >14                             ; Edge 6
     E930 0814     
36824 E932 1E53            byte >1e, >53, >08, >18                             ; Edge 7
     E934 0818     
36825 E936 1F60            byte >1f, >60, >1c, >20                             ; Edge 8
     E938 1C20     
36826 E93A 1E65            byte >1e, >65, >14, >18                             ; Edge 9
     E93C 1418     
36827 E93E 1F61            byte >1f, >61, >10, >20                             ; Edge 10
     E940 1020     
36828 E942 1E63            byte >1e, >63, >10, >18                             ; Edge 11
     E944 1018     
36829 E946 1F62            byte >1f, >62, >0c, >1c                             ; Edge 12
     E948 0C1C     
36830 E94A 1E46            byte >1e, >46, >0c, >14                             ; Edge 13
     E94C 0C14     
36831 E94E 1366            byte >13, >66, >24, >30                             ; Edge 14
     E950 2430     
36832 E952 1266            byte >12, >66, >24, >34                             ; Edge 15
     E954 2434     
36833 E956 1366            byte >13, >66, >28, >2c                             ; Edge 16
     E958 282C     
36834 E95A 1266            byte >12, >66, >28, >38                             ; Edge 17
     E95C 2838     
36835 E95E 1066            byte >10, >66, >2c, >38                             ; Edge 18
     E960 2C38     
36836 E962 1066            byte >10, >66, >30, >34                             ; Edge 19
     E964 3034     
36837               
36838               SHIP_VIPER_FACES:
36839                                                                          ; normal_x, normal_y, normal_z, visibility
36840 E966 1F00            byte >1f, >00, >20, >00                             ; Face 0
     E968 2000     
36841 E96A 9F16            byte >9f, >16, >21, >0b                             ; Face 1
     E96C 210B     
36842 E96E 1F16            byte >1f, >16, >21, >0b                             ; Face 2
     E970 210B     
36843 E972 DF16            byte >df, >16, >21, >0b                             ; Face 3
     E974 210B     
36844 E976 5F16            byte >5f, >16, >21, >0b                             ; Face 4
     E978 210B     
36845 E97A 5F00            byte >5f, >00, >20, >00                             ; Face 5
     E97C 2000     
36846 E97E 3F00            byte >3f, >00, >00, >30                             ; Face 6
     E980 0030     
36847               
36848               * ******************************************************************************
36849               *
36850               * Name: SHIP_MAMBA
36851               * Type: Variable
36852               * Category: Drawing ships
36853               * Summary: Ship blueprint for a Mamba
36854               * Deep dive: Ship blueprints
36855               *
36856               * ******************************************************************************
36857               
36858               SHIP_MAMBA:
36859 E982 01              byte >01                                            ; Max. canisters on demise = 1
36860 E984 1324            data 70 * 70                                        ; Targetable area          = 70 * 70
36861               
36862 E986 AC              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)%256            ; Edges data offset (low)
36863 E987   1C            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)%256            ; Faces data offset (low)
36864               
36865 E988 5D              byte >5d                                            ; Max. edge count          = (93 - 1) / 4 = 23
36866 E989   00            byte >00                                            ; Gun vertex               = 0
36867 E98A 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
36868 E98B   96            byte >96                                            ; Number of vertices       = 150 / 6 = 25
36869 E98C 1C              byte >1c                                            ; Number of edges          = 28
36870 E98E 9600            data >9600                                          ; Bounty                   = 150
36871 E990 14              byte >14                                            ; Number of faces          = 20 / 4 = 5
36872 E991   19            byte >19                                            ; Visibility distance      = 25
36873 E992 5A              byte >5a                                            ; Max. energy              = 90
36874 E993   1E            byte >1e                                            ; Max. speed               = 30
36875               
36876 E994 00              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)/256            ; Edges data offset (high)
36877 E995   01            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)/256            ; Faces data offset (high)
36878               
36879 E996 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
36880 E997   12            byte >12                                            ; Laser power              = 2
36881                                                                          ; Missiles                 = 2
36882               
36883               SHIP_MAMBA_VERTICES:
36884                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36885 E998 0000            byte >00, >00, >40, >1f, >10, >32                   ; Vertex 0
     E99A 401F     
     E99C 1032     
36886 E99E 4008            byte >40, >08, >20, >ff, >20, >44                   ; Vertex 1
     E9A0 20FF     
     E9A2 2044     
36887 E9A4 2008            byte >20, >08, >20, >be, >21, >44                   ; Vertex 2
     E9A6 20BE     
     E9A8 2144     
36888 E9AA 2008            byte >20, >08, >20, >3e, >31, >44                   ; Vertex 3
     E9AC 203E     
     E9AE 3144     
36889 E9B0 4008            byte >40, >08, >20, >7f, >30, >44                   ; Vertex 4
     E9B2 207F     
     E9B4 3044     
36890 E9B6 0404            byte >04, >04, >10, >8e, >11, >11                   ; Vertex 5
     E9B8 108E     
     E9BA 1111     
36891 E9BC 0404            byte >04, >04, >10, >0e, >11, >11                   ; Vertex 6
     E9BE 100E     
     E9C0 1111     
36892 E9C2 0803            byte >08, >03, >1c, >0d, >11, >11                   ; Vertex 7
     E9C4 1C0D     
     E9C6 1111     
36893 E9C8 0803            byte >08, >03, >1c, >8d, >11, >11                   ; Vertex 8
     E9CA 1C8D     
     E9CC 1111     
36894 E9CE 1404            byte >14, >04, >10, >d4, >00, >00                   ; Vertex 9
     E9D0 10D4     
     E9D2 0000     
36895 E9D4 1404            byte >14, >04, >10, >54, >00, >00                   ; Vertex 10
     E9D6 1054     
     E9D8 0000     
36896 E9DA 1807            byte >18, >07, >14, >f4, >00, >00                   ; Vertex 11
     E9DC 14F4     
     E9DE 0000     
36897 E9E0 1007            byte >10, >07, >14, >f0, >00, >00                   ; Vertex 12
     E9E2 14F0     
     E9E4 0000     
36898 E9E6 1007            byte >10, >07, >14, >70, >00, >00                   ; Vertex 13
     E9E8 1470     
     E9EA 0000     
36899 E9EC 1807            byte >18, >07, >14, >74, >00, >00                   ; Vertex 14
     E9EE 1474     
     E9F0 0000     
36900 E9F2 0804            byte >08, >04, >20, >ad, >44, >44                   ; Vertex 15
     E9F4 20AD     
     E9F6 4444     
36901 E9F8 0804            byte >08, >04, >20, >2d, >44, >44                   ; Vertex 16
     E9FA 202D     
     E9FC 4444     
36902 E9FE 0804            byte >08, >04, >20, >6e, >44, >44                   ; Vertex 17
     EA00 206E     
     EA02 4444     
36903 EA04 0804            byte >08, >04, >20, >ee, >44, >44                   ; Vertex 18
     EA06 20EE     
     EA08 4444     
36904 EA0A 2004            byte >20, >04, >20, >a7, >44, >44                   ; Vertex 19
     EA0C 20A7     
     EA0E 4444     
36905 EA10 2004            byte >20, >04, >20, >27, >44, >44                   ; Vertex 20
     EA12 2027     
     EA14 4444     
36906 EA16 2404            byte >24, >04, >20, >67, >44, >44                   ; Vertex 21
     EA18 2067     
     EA1A 4444     
36907 EA1C 2404            byte >24, >04, >20, >e7, >44, >44                   ; Vertex 22
     EA1E 20E7     
     EA20 4444     
36908 EA22 2600            byte >26, >00, >20, >a5, >44, >44                   ; Vertex 23
     EA24 20A5     
     EA26 4444     
36909 EA28 2600            byte >26, >00, >20, >25, >44, >44                   ; Vertex 24
     EA2A 2025     
     EA2C 4444     
36910               
36911               SHIP_MAMBA_EDGES:
36912                                                                          ; vertex1, vertex2, face1, face2, visibility
36913 EA2E 1F20            byte >1f, >20, >00, >04                             ; Edge 0
     EA30 0004     
36914 EA32 1F30            byte >1f, >30, >00, >10                             ; Edge 1
     EA34 0010     
36915 EA36 1F40            byte >1f, >40, >04, >10                             ; Edge 2
     EA38 0410     
36916 EA3A 1E42            byte >1e, >42, >04, >08                             ; Edge 3
     EA3C 0408     
36917 EA3E 1E41            byte >1e, >41, >08, >0c                             ; Edge 4
     EA40 080C     
36918 EA42 1E43            byte >1e, >43, >0c, >10                             ; Edge 5
     EA44 0C10     
36919 EA46 0E11            byte >0e, >11, >14, >18                             ; Edge 6
     EA48 1418     
36920 EA4A 0C11            byte >0c, >11, >18, >1c                             ; Edge 7
     EA4C 181C     
36921 EA4E 0D11            byte >0d, >11, >1c, >20                             ; Edge 8
     EA50 1C20     
36922 EA52 0C11            byte >0c, >11, >14, >20                             ; Edge 9
     EA54 1420     
36923 EA56 1400            byte >14, >00, >24, >2c                             ; Edge 10
     EA58 242C     
36924 EA5A 1000            byte >10, >00, >24, >30                             ; Edge 11
     EA5C 2430     
36925 EA5E 1000            byte >10, >00, >28, >34                             ; Edge 12
     EA60 2834     
36926 EA62 1400            byte >14, >00, >28, >38                             ; Edge 13
     EA64 2838     
36927 EA66 0E00            byte >0e, >00, >34, >38                             ; Edge 14
     EA68 3438     
36928 EA6A 0E00            byte >0e, >00, >2c, >30                             ; Edge 15
     EA6C 2C30     
36929 EA6E 0D44            byte >0d, >44, >3c, >40                             ; Edge 16
     EA70 3C40     
36930 EA72 0E44            byte >0e, >44, >44, >48                             ; Edge 17
     EA74 4448     
36931 EA76 0C44            byte >0c, >44, >3c, >48                             ; Edge 18
     EA78 3C48     
36932 EA7A 0C44            byte >0c, >44, >40, >44                             ; Edge 19
     EA7C 4044     
36933 EA7E 0744            byte >07, >44, >50, >54                             ; Edge 20
     EA80 5054     
36934 EA82 0544            byte >05, >44, >50, >60                             ; Edge 21
     EA84 5060     
36935 EA86 0544            byte >05, >44, >54, >60                             ; Edge 22
     EA88 5460     
36936 EA8A 0744            byte >07, >44, >4c, >58                             ; Edge 23
     EA8C 4C58     
36937 EA8E 0544            byte >05, >44, >4c, >5c                             ; Edge 24
     EA90 4C5C     
36938 EA92 0544            byte >05, >44, >58, >5c                             ; Edge 25
     EA94 585C     
36939 EA96 1E21            byte >1e, >21, >00, >08                             ; Edge 26
     EA98 0008     
36940 EA9A 1E31            byte >1e, >31, >00, >0c                             ; Edge 27
     EA9C 000C     
36941               
36942               SHIP_MAMBA_FACES:
36943                                                                          ; normal_x, normal_y, normal_z, visibility
36944 EA9E 5E00            byte >5e, >00, >18, >02                             ; Face 0
     EAA0 1802     
36945 EAA2 1E00            byte >1e, >00, >18, >02                             ; Face 1
     EAA4 1802     
36946 EAA6 9E20            byte >9e, >20, >40, >10                             ; Face 2
     EAA8 4010     
36947 EAAA 1E20            byte >1e, >20, >40, >10                             ; Face 3
     EAAC 4010     
36948 EAAE 3E00            byte >3e, >00, >00, >7f                             ; Face 4
     EAB0 007F     
36949               
36950               * ******************************************************************************
36951               *
36952               * Name: SHIP_COBRA_MK_3
36953               * Type: Variable
36954               * Category: Drawing ships
36955               * Summary: Ship blueprint for a Cobra Mk III
36956               * Deep dive: Ship blueprints
36957               *
36958               * ******************************************************************************
36959               
36960               SHIP_COBRA_MK_3:
36961 EAB2 03              byte >03                                            ; Max. canisters on demise = 3
36962 EAB4 2341            data 95 * 95                                        ; Targetable area          = 95 * 95
36963               
36964 EAB6 BE              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)%256  ; Edges data offset (low)
36965 EAB7   56            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)%256  ; Faces data offset (low)
36966               
36967 EAB8 99              byte >99                                            ; Max. edge count          = (153 - 1) / 4 = 38
36968 EAB9   54            byte >54                                            ; Gun vertex               = 84 / 4 = 21
36969 EABA 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
36970 EABB   A8            byte >a8                                            ; Number of vertices       = 168 / 6 = 28
36971 EABC 26              byte >26                                            ; Number of edges          = 38
36972 EABE 0000            data >0000                                          ; Bounty                   = 0
36973 EAC0 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
36974 EAC1   32            byte >32                                            ; Visibility distance      = 50
36975 EAC2 96              byte >96                                            ; Max. energy              = 150
36976 EAC3   1C            byte >1c                                            ; Max. speed               = 28
36977               
36978 EAC4 00              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)/256  ; Edges data offset (low)
36979 EAC5   01            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)/256  ; Faces data offset (low)
36980               
36981 EAC6 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
36982 EAC7   13            byte >13                                            ; Laser power              = 2
36983                                                                          ; Missiles                 = 3
36984               
36985               SHIP_COBRA_MK_3_VERTICES:
36986                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
36987 EAC8 2000            byte >20, >00, >4c, >1f, >ff, >ff                   ; Vertex 0
     EACA 4C1F     
     EACC FFFF     
36988 EACE 2000            byte >20, >00, >4c, >9f, >ff, >ff                   ; Vertex 1
     EAD0 4C9F     
     EAD2 FFFF     
36989 EAD4 001A            byte >00, >1a, >18, >1f, >ff, >ff                   ; Vertex 2
     EAD6 181F     
     EAD8 FFFF     
36990 EADA 7803            byte >78, >03, >08, >ff, >73, >aa                   ; Vertex 3
     EADC 08FF     
     EADE 73AA     
36991 EAE0 7803            byte >78, >03, >08, >7f, >84, >cc                   ; Vertex 4
     EAE2 087F     
     EAE4 84CC     
36992 EAE6 5810            byte >58, >10, >28, >bf, >ff, >ff                   ; Vertex 5
     EAE8 28BF     
     EAEA FFFF     
36993 EAEC 5810            byte >58, >10, >28, >3f, >ff, >ff                   ; Vertex 6
     EAEE 283F     
     EAF0 FFFF     
36994 EAF2 8008            byte >80, >08, >28, >7f, >98, >cc                   ; Vertex 7
     EAF4 287F     
     EAF6 98CC     
36995 EAF8 8008            byte >80, >08, >28, >ff, >97, >aa                   ; Vertex 8
     EAFA 28FF     
     EAFC 97AA     
36996 EAFE 001A            byte >00, >1a, >28, >3f, >65, >99                   ; Vertex 9
     EB00 283F     
     EB02 6599     
36997 EB04 2018            byte >20, >18, >28, >ff, >a9, >bb                   ; Vertex 10
     EB06 28FF     
     EB08 A9BB     
36998 EB0A 2018            byte >20, >18, >28, >7f, >b9, >cc                   ; Vertex 11
     EB0C 287F     
     EB0E B9CC     
36999 EB10 2408            byte >24, >08, >28, >b4, >99, >99                   ; Vertex 12
     EB12 28B4     
     EB14 9999     
37000 EB16 080C            byte >08, >0c, >28, >b4, >99, >99                   ; Vertex 13
     EB18 28B4     
     EB1A 9999     
37001 EB1C 080C            byte >08, >0c, >28, >34, >99, >99                   ; Vertex 14
     EB1E 2834     
     EB20 9999     
37002 EB22 2408            byte >24, >08, >28, >34, >99, >99                   ; Vertex 15
     EB24 2834     
     EB26 9999     
37003 EB28 240C            byte >24, >0c, >28, >74, >99, >99                   ; Vertex 16
     EB2A 2874     
     EB2C 9999     
37004 EB2E 0810            byte >08, >10, >28, >74, >99, >99                   ; Vertex 17
     EB30 2874     
     EB32 9999     
37005 EB34 0810            byte >08, >10, >28, >f4, >99, >99                   ; Vertex 18
     EB36 28F4     
     EB38 9999     
37006 EB3A 240C            byte >24, >0c, >28, >f4, >99, >99                   ; Vertex 19
     EB3C 28F4     
     EB3E 9999     
37007 EB40 0000            byte >00, >00, >4c, >06, >b0, >bb                   ; Vertex 20
     EB42 4C06     
     EB44 B0BB     
37008 EB46 0000            byte >00, >00, >5a, >1f, >b0, >bb                   ; Vertex 21
     EB48 5A1F     
     EB4A B0BB     
37009 EB4C 5006            byte >50, >06, >28, >e8, >99, >99                   ; Vertex 22
     EB4E 28E8     
     EB50 9999     
37010 EB52 5006            byte >50, >06, >28, >a8, >99, >99                   ; Vertex 23
     EB54 28A8     
     EB56 9999     
37011 EB58 5800            byte >58, >00, >28, >a6, >99, >99                   ; Vertex 24
     EB5A 28A6     
     EB5C 9999     
37012 EB5E 5006            byte >50, >06, >28, >28, >99, >99                   ; Vertex 25
     EB60 2828     
     EB62 9999     
37013 EB64 5800            byte >58, >00, >28, >26, >99, >99                   ; Vertex 26
     EB66 2826     
     EB68 9999     
37014 EB6A 5006            byte >50, >06, >28, >68, >99, >99                   ; Vertex 27
     EB6C 2868     
     EB6E 9999     
37015               
37016               SHIP_COBRA_MK_3_EDGES:
37017                                                                          ; vertex1, vertex2, face1, face2, visibility
37018 EB70 1FB0            byte >1f, >b0, >00, >04                             ; Edge 0
     EB72 0004     
37019 EB74 1FC4            byte >1f, >c4, >00, >10                             ; Edge 1
     EB76 0010     
37020 EB78 1FA3            byte >1f, >a3, >04, >0c                             ; Edge 2
     EB7A 040C     
37021 EB7C 1FA7            byte >1f, >a7, >0c, >20                             ; Edge 3
     EB7E 0C20     
37022 EB80 1FC8            byte >1f, >c8, >10, >1c                             ; Edge 4
     EB82 101C     
37023 EB84 1F98            byte >1f, >98, >18, >1c                             ; Edge 5
     EB86 181C     
37024 EB88 1F96            byte >1f, >96, >18, >24                             ; Edge 6
     EB8A 1824     
37025 EB8C 1F95            byte >1f, >95, >14, >24                             ; Edge 7
     EB8E 1424     
37026 EB90 1F97            byte >1f, >97, >14, >20                             ; Edge 8
     EB92 1420     
37027 EB94 1F51            byte >1f, >51, >08, >14                             ; Edge 9
     EB96 0814     
37028 EB98 1F62            byte >1f, >62, >08, >18                             ; Edge 10
     EB9A 0818     
37029 EB9C 1F73            byte >1f, >73, >0c, >14                             ; Edge 11
     EB9E 0C14     
37030 EBA0 1F84            byte >1f, >84, >10, >18                             ; Edge 12
     EBA2 1018     
37031 EBA4 1F10            byte >1f, >10, >04, >08                             ; Edge 13
     EBA6 0408     
37032 EBA8 1F20            byte >1f, >20, >00, >08                             ; Edge 14
     EBAA 0008     
37033 EBAC 1FA9            byte >1f, >a9, >20, >28                             ; Edge 15
     EBAE 2028     
37034 EBB0 1FB9            byte >1f, >b9, >28, >2c                             ; Edge 16
     EBB2 282C     
37035 EBB4 1FC9            byte >1f, >c9, >1c, >2c                             ; Edge 17
     EBB6 1C2C     
37036 EBB8 1FBA            byte >1f, >ba, >04, >28                             ; Edge 18
     EBBA 0428     
37037 EBBC 1FCB            byte >1f, >cb, >00, >2c                             ; Edge 19
     EBBE 002C     
37038 EBC0 1D31            byte >1d, >31, >04, >14                             ; Edge 20
     EBC2 0414     
37039 EBC4 1D42            byte >1d, >42, >00, >18                             ; Edge 21
     EBC6 0018     
37040 EBC8 06B0            byte >06, >b0, >50, >54                             ; Edge 22
     EBCA 5054     
37041 EBCC 1499            byte >14, >99, >30, >34                             ; Edge 23
     EBCE 3034     
37042 EBD0 1499            byte >14, >99, >48, >4c                             ; Edge 24
     EBD2 484C     
37043 EBD4 1499            byte >14, >99, >38, >3c                             ; Edge 25
     EBD6 383C     
37044 EBD8 1499            byte >14, >99, >40, >44                             ; Edge 26
     EBDA 4044     
37045 EBDC 1399            byte >13, >99, >3c, >40                             ; Edge 27
     EBDE 3C40     
37046 EBE0 1199            byte >11, >99, >38, >44                             ; Edge 28
     EBE2 3844     
37047 EBE4 1399            byte >13, >99, >34, >48                             ; Edge 29
     EBE6 3448     
37048 EBE8 1399            byte >13, >99, >30, >4c                             ; Edge 30
     EBEA 304C     
37049 EBEC 1E65            byte >1e, >65, >08, >24                             ; Edge 31
     EBEE 0824     
37050 EBF0 0699            byte >06, >99, >58, >60                             ; Edge 32
     EBF2 5860     
37051 EBF4 0699            byte >06, >99, >5c, >60                             ; Edge 33
     EBF6 5C60     
37052 EBF8 0899            byte >08, >99, >58, >5c                             ; Edge 34
     EBFA 585C     
37053 EBFC 0699            byte >06, >99, >64, >68                             ; Edge 35
     EBFE 6468     
37054 EC00 0699            byte >06, >99, >68, >6c                             ; Edge 36
     EC02 686C     
37055 EC04 0899            byte >08, >99, >64, >6c                             ; Edge 37
     EC06 646C     
37056               
37057               SHIP_COBRA_MK_3_FACES:
37058                                                                          ; normal_x, normal_y, normal_z, visibility
37059 EC08 1F00            byte >1f, >00, >3e, >1f                             ; Face 0
     EC0A 3E1F     
37060 EC0C 9F12            byte >9f, >12, >37, >10                             ; Face 1
     EC0E 3710     
37061 EC10 1F12            byte >1f, >12, >37, >10                             ; Face 2
     EC12 3710     
37062 EC14 9F10            byte >9f, >10, >34, >0e                             ; Face 3
     EC16 340E     
37063 EC18 1F10            byte >1f, >10, >34, >0e                             ; Face 4
     EC1A 340E     
37064 EC1C 9F0E            byte >9f, >0e, >2f, >00                             ; Face 5
     EC1E 2F00     
37065 EC20 1F0E            byte >1f, >0e, >2f, >00                             ; Face 6
     EC22 2F00     
37066 EC24 9F3D            byte >9f, >3d, >66, >00                             ; Face 7
     EC26 6600     
37067 EC28 1F3D            byte >1f, >3d, >66, >00                             ; Face 8
     EC2A 6600     
37068 EC2C 3F00            byte >3f, >00, >00, >50                             ; Face 9
     EC2E 0050     
37069 EC30 DF07            byte >df, >07, >2a, >09                             ; Face 10
     EC32 2A09     
37070 EC34 5F00            byte >5f, >00, >1e, >06                             ; Face 11
     EC36 1E06     
37071 EC38 5F07            byte >5f, >07, >2a, >09                             ; Face 12
     EC3A 2A09     
37072               
37073               * ******************************************************************************
37074               *
37075               * Name: SHIP_THARGOID
37076               * Type: Variable
37077               * Category: Drawing ships
37078               * Summary: Ship blueprint for a Thargoid mothership
37079               * Deep dive: Ship blueprints
37080               *
37081               * ******************************************************************************
37082               
37083               SHIP_THARGOID:
37084 EC3C 00              byte >00                                            ; Max. canisters on demise = 0
37085 EC3E 2649            data 99 * 99                                        ; Targetable area          = 99 * 99
37086               
37087 EC40 8E              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)%256      ; Edges data offset (low)
37088 EC41   F6            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)%256      ; Faces data offset (low)
37089               
37090 EC42 65              byte >65                                            ; Max. edge count          = (101 - 1) / 4 = 25
37091 EC43   3C            byte >3c                                            ; Gun vertex               = 60 / 4 = 15
37092 EC44 26              byte >26                                            ; Explosion count          = 8, as (4 * n) + 6 = 38
37093 EC45   78            byte >78                                            ; Number of vertices       = 120 / 6 = 20
37094 EC46 1A              byte >1a                                            ; Number of edges          = 26
37095 EC48 F401            data >f401                                          ; Bounty                   = 500
37096 EC4A 28              byte >28                                            ; Number of faces          = 40 / 4 = 10
37097 EC4B   37            byte >37                                            ; Visibility distance      = 55
37098 EC4C F0              byte >f0                                            ; Max. energy              = 240
37099 EC4D   27            byte >27                                            ; Max. speed               = 39
37100               
37101 EC4E 00              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)/256      ; Edges data offset (high)
37102 EC4F   00            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)/256      ; Faces data offset (high)
37103               
37104 EC50 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37105 EC51   16            byte >16                                            ; Laser power              = 2
37106                                                                          ; Missiles                 = 6
37107               
37108               SHIP_THARGOID_VERTICES:
37109                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37110 EC52 2030            byte >20, >30, >30, >5f, >40, >88                   ; Vertex 0
     EC54 305F     
     EC56 4088     
37111 EC58 2044            byte >20, >44, >00, >5f, >10, >44                   ; Vertex 1
     EC5A 005F     
     EC5C 1044     
37112 EC5E 2030            byte >20, >30, >30, >7f, >21, >44                   ; Vertex 2
     EC60 307F     
     EC62 2144     
37113 EC64 2000            byte >20, >00, >44, >3f, >32, >44                   ; Vertex 3
     EC66 443F     
     EC68 3244     
37114 EC6A 2030            byte >20, >30, >30, >3f, >43, >55                   ; Vertex 4
     EC6C 303F     
     EC6E 4355     
37115 EC70 2044            byte >20, >44, >00, >1f, >54, >66                   ; Vertex 5
     EC72 001F     
     EC74 5466     
37116 EC76 2030            byte >20, >30, >30, >1f, >64, >77                   ; Vertex 6
     EC78 301F     
     EC7A 6477     
37117 EC7C 2000            byte >20, >00, >44, >1f, >74, >88                   ; Vertex 7
     EC7E 441F     
     EC80 7488     
37118 EC82 1874            byte >18, >74, >74, >df, >80, >99                   ; Vertex 8
     EC84 74DF     
     EC86 8099     
37119 EC88 18A4            byte >18, >a4, >00, >df, >10, >99                   ; Vertex 9
     EC8A 00DF     
     EC8C 1099     
37120 EC8E 1874            byte >18, >74, >74, >ff, >21, >99                   ; Vertex 10
     EC90 74FF     
     EC92 2199     
37121 EC94 1800            byte >18, >00, >a4, >bf, >32, >99                   ; Vertex 11
     EC96 A4BF     
     EC98 3299     
37122 EC9A 1874            byte >18, >74, >74, >bf, >53, >99                   ; Vertex 12
     EC9C 74BF     
     EC9E 5399     
37123 ECA0 18A4            byte >18, >a4, >00, >9f, >65, >99                   ; Vertex 13
     ECA2 009F     
     ECA4 6599     
37124 ECA6 1874            byte >18, >74, >74, >9f, >76, >99                   ; Vertex 14
     ECA8 749F     
     ECAA 7699     
37125 ECAC 1800            byte >18, >00, >a4, >9f, >87, >99                   ; Vertex 15
     ECAE A49F     
     ECB0 8799     
37126 ECB2 1840            byte >18, >40, >50, >9e, >99, >99                   ; Vertex 16
     ECB4 509E     
     ECB6 9999     
37127 ECB8 1840            byte >18, >40, >50, >be, >99, >99                   ; Vertex 17
     ECBA 50BE     
     ECBC 9999     
37128 ECBE 1840            byte >18, >40, >50, >fe, >99, >99                   ; Vertex 18
     ECC0 50FE     
     ECC2 9999     
37129 ECC4 1840            byte >18, >40, >50, >de, >99, >99                   ; Vertex 19
     ECC6 50DE     
     ECC8 9999     
37130               
37131               SHIP_THARGOID_EDGES:
37132                                                                          ; vertex1, vertex2, face1, face2, visibility
37133 ECCA 1F84            byte >1f, >84, >00, >1c                             ; Edge 0
     ECCC 001C     
37134 ECCE 1F40            byte >1f, >40, >00, >04                             ; Edge 1
     ECD0 0004     
37135 ECD2 1F41            byte >1f, >41, >04, >08                             ; Edge 2
     ECD4 0408     
37136 ECD6 1F42            byte >1f, >42, >08, >0c                             ; Edge 3
     ECD8 080C     
37137 ECDA 1F43            byte >1f, >43, >0c, >10                             ; Edge 4
     ECDC 0C10     
37138 ECDE 1F54            byte >1f, >54, >10, >14                             ; Edge 5
     ECE0 1014     
37139 ECE2 1F64            byte >1f, >64, >14, >18                             ; Edge 6
     ECE4 1418     
37140 ECE6 1F74            byte >1f, >74, >18, >1c                             ; Edge 7
     ECE8 181C     
37141 ECEA 1F80            byte >1f, >80, >00, >20                             ; Edge 8
     ECEC 0020     
37142 ECEE 1F10            byte >1f, >10, >04, >24                             ; Edge 9
     ECF0 0424     
37143 ECF2 1F21            byte >1f, >21, >08, >28                             ; Edge 10
     ECF4 0828     
37144 ECF6 1F32            byte >1f, >32, >0c, >2c                             ; Edge 11
     ECF8 0C2C     
37145 ECFA 1F53            byte >1f, >53, >10, >30                             ; Edge 12
     ECFC 1030     
37146 ECFE 1F65            byte >1f, >65, >14, >34                             ; Edge 13
     ED00 1434     
37147 ED02 1F76            byte >1f, >76, >18, >38                             ; Edge 14
     ED04 1838     
37148 ED06 1F87            byte >1f, >87, >1c, >3c                             ; Edge 15
     ED08 1C3C     
37149 ED0A 1F98            byte >1f, >98, >20, >3c                             ; Edge 16
     ED0C 203C     
37150 ED0E 1F90            byte >1f, >90, >20, >24                             ; Edge 17
     ED10 2024     
37151 ED12 1F91            byte >1f, >91, >24, >28                             ; Edge 18
     ED14 2428     
37152 ED16 1F92            byte >1f, >92, >28, >2c                             ; Edge 19
     ED18 282C     
37153 ED1A 1F93            byte >1f, >93, >2c, >30                             ; Edge 20
     ED1C 2C30     
37154 ED1E 1F95            byte >1f, >95, >30, >34                             ; Edge 21
     ED20 3034     
37155 ED22 1F96            byte >1f, >96, >34, >38                             ; Edge 22
     ED24 3438     
37156 ED26 1F97            byte >1f, >97, >38, >3c                             ; Edge 23
     ED28 383C     
37157 ED2A 1E99            byte >1e, >99, >40, >44                             ; Edge 24
     ED2C 4044     
37158 ED2E 1E99            byte >1e, >99, >48, >4c                             ; Edge 25
     ED30 484C     
37159               
37160               SHIP_THARGOID_FACES:
37161                                                                          ; normal_x, normal_y, normal_z, visibility
37162 ED32 5F67            byte >5f, >67, >3c, >19                             ; Face 0
     ED34 3C19     
37163 ED36 7F67            byte >7f, >67, >3c, >19                             ; Face 1
     ED38 3C19     
37164 ED3A 7F67            byte >7f, >67, >19, >3c                             ; Face 2
     ED3C 193C     
37165 ED3E 3F67            byte >3f, >67, >19, >3c                             ; Face 3
     ED40 193C     
37166 ED42 1F40            byte >1f, >40, >00, >00                             ; Face 4
     ED44 0000     
37167 ED46 3F67            byte >3f, >67, >3c, >19                             ; Face 5
     ED48 3C19     
37168 ED4A 1F67            byte >1f, >67, >3c, >19                             ; Face 6
     ED4C 3C19     
37169 ED4E 1F67            byte >1f, >67, >19, >3c                             ; Face 7
     ED50 193C     
37170 ED52 5F67            byte >5f, >67, >19, >3c                             ; Face 8
     ED54 193C     
37171 ED56 9F30            byte >9f, >30, >00, >00                             ; Face 9
     ED58 0000     
37172               
37173               * ******************************************************************************
37174               *
37175               * Name: SHIP_CORIOLIS
37176               * Type: Variable
37177               * Category: Drawing ships
37178               * Summary: Ship blueprint for a Coriolis space station
37179               * Deep dive: Ship blueprints
37180               *
37181               * ******************************************************************************
37182               
37183               SHIP_CORIOLIS:
37184 ED5A 00              byte >00                                            ; Max. canisters on demise = 0
37185 ED5C 6400            data 160 * 160                                      ; Targetable area          = 160 * 160
37186               
37187 ED5E 76              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)%256      ; Edges data offset (low)
37188 ED5F   E6            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)%256      ; Faces data offset (low)
37189               
37190 ED60 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
37191 ED61   00            byte >00                                            ; Gun vertex               = 0
37192 ED62 36              byte >36                                            ; Explosion count          = 12, as (4 * n) + 6 = 54
37193 ED63   60            byte >60                                            ; Number of vertices       = 96 / 6 = 16
37194 ED64 1C              byte >1c                                            ; Number of edges          = 28
37195 ED66 0000            data >0000                                          ; Bounty                   = 0
37196 ED68 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
37197 ED69   78            byte >78                                            ; Visibility distance      = 120
37198 ED6A F0              byte >f0                                            ; Max. energy              = 240
37199 ED6B   00            byte >00                                            ; Max. speed               = 0
37200               
37201 ED6C 00              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)/256      ; Edges data offset (high)
37202 ED6D   00            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)/256      ; Faces data offset (high)
37203               
37204 ED6E 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
37205 ED6F   06            byte >06                                            ; Laser power              = 0
37206                                                                          ; Missiles                 = 6
37207               
37208               SHIP_CORIOLIS_VERTICES:
37209                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37210 ED70 A000            byte >a0, >00, >a0, >1f, >10, >62                   ; Vertex 0
     ED72 A01F     
     ED74 1062     
37211 ED76 00A0            byte >00, >a0, >a0, >1f, >20, >83                   ; Vertex 1
     ED78 A01F     
     ED7A 2083     
37212 ED7C A000            byte >a0, >00, >a0, >9f, >30, >74                   ; Vertex 2
     ED7E A09F     
     ED80 3074     
37213 ED82 00A0            byte >00, >a0, >a0, >5f, >10, >54                   ; Vertex 3
     ED84 A05F     
     ED86 1054     
37214 ED88 A0A0            byte >a0, >a0, >00, >5f, >51, >a6                   ; Vertex 4
     ED8A 005F     
     ED8C 51A6     
37215 ED8E A0A0            byte >a0, >a0, >00, >1f, >62, >b8                   ; Vertex 5
     ED90 001F     
     ED92 62B8     
37216 ED94 A0A0            byte >a0, >a0, >00, >9f, >73, >c8                   ; Vertex 6
     ED96 009F     
     ED98 73C8     
37217 ED9A A0A0            byte >a0, >a0, >00, >df, >54, >97                   ; Vertex 7
     ED9C 00DF     
     ED9E 5497     
37218 EDA0 A000            byte >a0, >00, >a0, >3f, >a6, >db                   ; Vertex 8
     EDA2 A03F     
     EDA4 A6DB     
37219 EDA6 00A0            byte >00, >a0, >a0, >3f, >b8, >dc                   ; Vertex 9
     EDA8 A03F     
     EDAA B8DC     
37220 EDAC A000            byte >a0, >00, >a0, >bf, >97, >dc                   ; Vertex 10
     EDAE A0BF     
     EDB0 97DC     
37221 EDB2 00A0            byte >00, >a0, >a0, >7f, >95, >da                   ; Vertex 11
     EDB4 A07F     
     EDB6 95DA     
37222 EDB8 0A1E            byte >0a, >1e, >a0, >5e, >00, >00                   ; Vertex 12
     EDBA A05E     
     EDBC 0000     
37223 EDBE 0A1E            byte >0a, >1e, >a0, >1e, >00, >00                   ; Vertex 13
     EDC0 A01E     
     EDC2 0000     
37224 EDC4 0A1E            byte >0a, >1e, >a0, >9e, >00, >00                   ; Vertex 14
     EDC6 A09E     
     EDC8 0000     
37225 EDCA 0A1E            byte >0a, >1e, >a0, >de, >00, >00                   ; Vertex 15
     EDCC A0DE     
     EDCE 0000     
37226               
37227               SHIP_CORIOLIS_EDGES:
37228                                                                          ; vertex1, vertex2, face1, face2, visibility
37229 EDD0 1F10            byte >1f, >10, >00, >0c                             ; Edge 0
     EDD2 000C     
37230 EDD4 1F20            byte >1f, >20, >00, >04                             ; Edge 1
     EDD6 0004     
37231 EDD8 1F30            byte >1f, >30, >04, >08                             ; Edge 2
     EDDA 0408     
37232 EDDC 1F40            byte >1f, >40, >08, >0c                             ; Edge 3
     EDDE 080C     
37233 EDE0 1F51            byte >1f, >51, >0c, >10                             ; Edge 4
     EDE2 0C10     
37234 EDE4 1F61            byte >1f, >61, >00, >10                             ; Edge 5
     EDE6 0010     
37235 EDE8 1F62            byte >1f, >62, >00, >14                             ; Edge 6
     EDEA 0014     
37236 EDEC 1F82            byte >1f, >82, >14, >04                             ; Edge 7
     EDEE 1404     
37237 EDF0 1F83            byte >1f, >83, >04, >18                             ; Edge 8
     EDF2 0418     
37238 EDF4 1F73            byte >1f, >73, >08, >18                             ; Edge 9
     EDF6 0818     
37239 EDF8 1F74            byte >1f, >74, >08, >1c                             ; Edge 10
     EDFA 081C     
37240 EDFC 1F54            byte >1f, >54, >0c, >1c                             ; Edge 11
     EDFE 0C1C     
37241 EE00 1FDA            byte >1f, >da, >20, >2c                             ; Edge 12
     EE02 202C     
37242 EE04 1FDB            byte >1f, >db, >20, >24                             ; Edge 13
     EE06 2024     
37243 EE08 1FDC            byte >1f, >dc, >24, >28                             ; Edge 14
     EE0A 2428     
37244 EE0C 1FD9            byte >1f, >d9, >28, >2c                             ; Edge 15
     EE0E 282C     
37245 EE10 1FA5            byte >1f, >a5, >10, >2c                             ; Edge 16
     EE12 102C     
37246 EE14 1FA6            byte >1f, >a6, >10, >20                             ; Edge 17
     EE16 1020     
37247 EE18 1FB6            byte >1f, >b6, >14, >20                             ; Edge 18
     EE1A 1420     
37248 EE1C 1FB8            byte >1f, >b8, >14, >24                             ; Edge 19
     EE1E 1424     
37249 EE20 1FC8            byte >1f, >c8, >18, >24                             ; Edge 20
     EE22 1824     
37250 EE24 1FC7            byte >1f, >c7, >18, >28                             ; Edge 21
     EE26 1828     
37251 EE28 1F97            byte >1f, >97, >1c, >28                             ; Edge 22
     EE2A 1C28     
37252 EE2C 1F95            byte >1f, >95, >1c, >2c                             ; Edge 23
     EE2E 1C2C     
37253 EE30 1E00            byte >1e, >00, >30, >34                             ; Edge 24
     EE32 3034     
37254 EE34 1E00            byte >1e, >00, >34, >38                             ; Edge 25
     EE36 3438     
37255 EE38 1E00            byte >1e, >00, >38, >3c                             ; Edge 26
     EE3A 383C     
37256 EE3C 1E00            byte >1e, >00, >3c, >30                             ; Edge 27
     EE3E 3C30     
37257               
37258               SHIP_CORIOLIS_FACES:
37259                                                                          ; normal_x, normal_y, normal_z, visibility
37260 EE40 1F00            byte >1f, >00, >00, >a0                             ; Face 0
     EE42 00A0     
37261 EE44 5F6B            byte >5f, >6b, >6b, >6b                             ; Face 1
     EE46 6B6B     
37262 EE48 1F6B            byte >1f, >6b, >6b, >6b                             ; Face 2
     EE4A 6B6B     
37263 EE4C 9F6B            byte >9f, >6b, >6b, >6b                             ; Face 3
     EE4E 6B6B     
37264 EE50 DF6B            byte >df, >6b, >6b, >6b                             ; Face 4
     EE52 6B6B     
37265 EE54 5F00            byte >5f, >00, >a0, >00                             ; Face 5
     EE56 A000     
37266 EE58 1FA0            byte >1f, >a0, >00, >00                             ; Face 6
     EE5A 0000     
37267 EE5C 9FA0            byte >9f, >a0, >00, >00                             ; Face 7
     EE5E 0000     
37268 EE60 1F00            byte >1f, >00, >a0, >00                             ; Face 8
     EE62 A000     
37269 EE64 FF6B            byte >ff, >6b, >6b, >6b                             ; Face 9
     EE66 6B6B     
37270 EE68 7F6B            byte >7f, >6b, >6b, >6b                             ; Face 10
     EE6A 6B6B     
37271 EE6C 3F6B            byte >3f, >6b, >6b, >6b                             ; Face 11
     EE6E 6B6B     
37272 EE70 BF6B            byte >bf, >6b, >6b, >6b                             ; Face 12
     EE72 6B6B     
37273 EE74 3F00            byte >3f, >00, >00, >a0                             ; Face 13
     EE76 00A0     
37274               
37275               * ******************************************************************************
37276               *
37277               * Name: SHIP_MISSILE
37278               * Type: Variable
37279               * Category: Drawing ships
37280               * Summary: Ship blueprint for a missile
37281               * Deep dive: Ship blueprints
37282               *
37283               * ******************************************************************************
37284               
37285               SHIP_MISSILE:
37286 EE78 00              byte >00                                            ; Max. canisters on demise = 0
37287 EE7A 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
37288               
37289 EE7C 7C              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)%256        ; Edges data offset (low)
37290 EE7D   DC            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)%256        ; Faces data offset (low)
37291               
37292 EE7E 51              byte >51                                            ; Max. edge count          = (81 - 1) / 4 = 20
37293 EE7F   00            byte >00                                            ; Gun vertex               = 0
37294 EE80 0A              byte >0a                                            ; Explosion count          = 1, as (4 * n) + 6 = 10
37295 EE81   66            byte >66                                            ; Number of vertices       = 102 / 6 = 17
37296 EE82 18              byte >18                                            ; Number of edges          = 24
37297 EE84 0000            data >0000                                          ; Bounty                   = 0
37298 EE86 24              byte >24                                            ; Number of faces          = 36 / 4 = 9
37299 EE87   0E            byte >0e                                            ; Visibility distance      = 14
37300 EE88 02              byte >02                                            ; Max. energy              = 2
37301 EE89   2C            byte >2c                                            ; Max. speed               = 44
37302               
37303 EE8A 00              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)/256        ; Edges data offset (high)
37304 EE8B   00            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)/256        ; Faces data offset (high)
37305               
37306 EE8C 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37307 EE8D   00            byte >00                                            ; Laser power              = 0
37308                                                                          ; Missiles                 = 0
37309               
37310               SHIP_MISSILE_VERTICES:
37311                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37312 EE8E 0000            byte >00, >00, >44, >1f, >10, >32                   ; Vertex 0
     EE90 441F     
     EE92 1032     
37313 EE94 0808            byte >08, >08, >24, >5f, >21, >54                   ; Vertex 1
     EE96 245F     
     EE98 2154     
37314 EE9A 0808            byte >08, >08, >24, >1f, >32, >74                   ; Vertex 2
     EE9C 241F     
     EE9E 3274     
37315 EEA0 0808            byte >08, >08, >24, >9f, >30, >76                   ; Vertex 3
     EEA2 249F     
     EEA4 3076     
37316 EEA6 0808            byte >08, >08, >24, >df, >10, >65                   ; Vertex 4
     EEA8 24DF     
     EEAA 1065     
37317 EEAC 0808            byte >08, >08, >2c, >3f, >74, >88                   ; Vertex 5
     EEAE 2C3F     
     EEB0 7488     
37318 EEB2 0808            byte >08, >08, >2c, >7f, >54, >88                   ; Vertex 6
     EEB4 2C7F     
     EEB6 5488     
37319 EEB8 0808            byte >08, >08, >2c, >ff, >65, >88                   ; Vertex 7
     EEBA 2CFF     
     EEBC 6588     
37320 EEBE 0808            byte >08, >08, >2c, >bf, >76, >88                   ; Vertex 8
     EEC0 2CBF     
     EEC2 7688     
37321 EEC4 0C0C            byte >0c, >0c, >2c, >28, >74, >88                   ; Vertex 9
     EEC6 2C28     
     EEC8 7488     
37322 EECA 0C0C            byte >0c, >0c, >2c, >68, >54, >88                   ; Vertex 10
     EECC 2C68     
     EECE 5488     
37323 EED0 0C0C            byte >0c, >0c, >2c, >e8, >65, >88                   ; Vertex 11
     EED2 2CE8     
     EED4 6588     
37324 EED6 0C0C            byte >0c, >0c, >2c, >a8, >76, >88                   ; Vertex 12
     EED8 2CA8     
     EEDA 7688     
37325 EEDC 0808            byte >08, >08, >0c, >a8, >76, >77                   ; Vertex 13
     EEDE 0CA8     
     EEE0 7677     
37326 EEE2 0808            byte >08, >08, >0c, >e8, >65, >66                   ; Vertex 14
     EEE4 0CE8     
     EEE6 6566     
37327 EEE8 0808            byte >08, >08, >0c, >28, >74, >77                   ; Vertex 15
     EEEA 0C28     
     EEEC 7477     
37328 EEEE 0808            byte >08, >08, >0c, >68, >54, >55                   ; Vertex 16
     EEF0 0C68     
     EEF2 5455     
37329               
37330               SHIP_MISSILE_EDGES:
37331                                                                          ; vertex1, vertex2, face1, face2, visibility
37332 EEF4 1F21            byte >1f, >21, >00, >04                             ; Edge 0
     EEF6 0004     
37333 EEF8 1F32            byte >1f, >32, >00, >08                             ; Edge 1
     EEFA 0008     
37334 EEFC 1F30            byte >1f, >30, >00, >0c                             ; Edge 2
     EEFE 000C     
37335 EF00 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     EF02 0010     
37336 EF04 1F24            byte >1f, >24, >04, >08                             ; Edge 4
     EF06 0408     
37337 EF08 1F51            byte >1f, >51, >04, >10                             ; Edge 5
     EF0A 0410     
37338 EF0C 1F60            byte >1f, >60, >0c, >10                             ; Edge 6
     EF0E 0C10     
37339 EF10 1F73            byte >1f, >73, >08, >0c                             ; Edge 7
     EF12 080C     
37340 EF14 1F74            byte >1f, >74, >08, >14                             ; Edge 8
     EF16 0814     
37341 EF18 1F54            byte >1f, >54, >04, >18                             ; Edge 9
     EF1A 0418     
37342 EF1C 1F65            byte >1f, >65, >10, >1c                             ; Edge 10
     EF1E 101C     
37343 EF20 1F76            byte >1f, >76, >0c, >20                             ; Edge 11
     EF22 0C20     
37344 EF24 1F86            byte >1f, >86, >1c, >20                             ; Edge 12
     EF26 1C20     
37345 EF28 1F87            byte >1f, >87, >14, >20                             ; Edge 13
     EF2A 1420     
37346 EF2C 1F84            byte >1f, >84, >14, >18                             ; Edge 14
     EF2E 1418     
37347 EF30 1F85            byte >1f, >85, >18, >1c                             ; Edge 15
     EF32 181C     
37348 EF34 0885            byte >08, >85, >18, >28                             ; Edge 16
     EF36 1828     
37349 EF38 0887            byte >08, >87, >14, >24                             ; Edge 17
     EF3A 1424     
37350 EF3C 0887            byte >08, >87, >20, >30                             ; Edge 18
     EF3E 2030     
37351 EF40 0885            byte >08, >85, >1c, >2c                             ; Edge 19
     EF42 1C2C     
37352 EF44 0874            byte >08, >74, >24, >3c                             ; Edge 20
     EF46 243C     
37353 EF48 0854            byte >08, >54, >28, >40                             ; Edge 21
     EF4A 2840     
37354 EF4C 0876            byte >08, >76, >30, >34                             ; Edge 22
     EF4E 3034     
37355 EF50 0865            byte >08, >65, >2c, >38                             ; Edge 23
     EF52 2C38     
37356               
37357               SHIP_MISSILE_FACES:
37358                                                                          ; normal_x, normal_y, normal_z, visibility
37359 EF54 9F40            byte >9f, >40, >00, >10                             ; Face 0
     EF56 0010     
37360 EF58 5F00            byte >5f, >00, >40, >10                             ; Face 1
     EF5A 4010     
37361 EF5C 1F40            byte >1f, >40, >00, >10                             ; Face 2
     EF5E 0010     
37362 EF60 1F00            byte >1f, >00, >40, >10                             ; Face 3
     EF62 4010     
37363 EF64 1F20            byte >1f, >20, >00, >00                             ; Face 4
     EF66 0000     
37364 EF68 5F00            byte >5f, >00, >20, >00                             ; Face 5
     EF6A 2000     
37365 EF6C 9F20            byte >9f, >20, >00, >00                             ; Face 6
     EF6E 0000     
37366 EF70 1F00            byte >1f, >00, >20, >00                             ; Face 7
     EF72 2000     
37367 EF74 3F00            byte >3f, >00, >00, >b0                             ; Face 8
     EF76 00B0     
37368               
37369               * ******************************************************************************
37370               *
37371               * Name: SHIP_ASTEROID
37372               * Type: Variable
37373               * Category: Drawing ships
37374               * Summary: Ship blueprint for an asteroid
37375               * Deep dive: Ship blueprints
37376               *
37377               * ******************************************************************************
37378               
37379               SHIP_ASTEROID:
37380 EF78 00              byte >00                                            ; Max. canisters on demise = 0
37381 EF7A 1900            data 80 * 80                                        ; Targetable area          = 80 * 80
37382               
37383 EF7C 4C              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)%256      ; Edges data offset (low)
37384 EF7D   A0            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)%256      ; Faces data offset (low)
37385               
37386 EF7E 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
37387 EF7F   00            byte >00                                            ; Gun vertex               = 0
37388 EF80 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
37389 EF81   36            byte >36                                            ; Number of vertices       = 54 / 6 = 9
37390 EF82 15              byte >15                                            ; Number of edges          = 21
37391 EF84 0500            data >0500                                          ; Bounty                   = 5
37392 EF86 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
37393 EF87   32            byte >32                                            ; Visibility distance      = 50
37394 EF88 3C              byte >3c                                            ; Max. energy              = 60
37395 EF89   1E            byte >1e                                            ; Max. speed               = 30
37396               
37397 EF8A 00              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)/256      ; Edges data offset (high)
37398 EF8B   00            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)/256      ; Faces data offset (high)
37399               
37400 EF8C 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
37401 EF8D   00            byte >00                                            ; Laser power              = 0
37402                                                                          ; Missiles                 = 0
37403               
37404               SHIP_ASTEROID_VERTICES:
37405                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37406 EF8E 0050            byte >00, >50, >00, >1f, >ff, >ff                   ; Vertex 0
     EF90 001F     
     EF92 FFFF     
37407 EF94 500A            byte >50, >0a, >00, >df, >ff, >ff                   ; Vertex 1
     EF96 00DF     
     EF98 FFFF     
37408 EF9A 0050            byte >00, >50, >00, >5f, >ff, >ff                   ; Vertex 2
     EF9C 005F     
     EF9E FFFF     
37409 EFA0 4628            byte >46, >28, >00, >5f, >ff, >ff                   ; Vertex 3
     EFA2 005F     
     EFA4 FFFF     
37410 EFA6 3C32            byte >3c, >32, >00, >1f, >65, >dc                   ; Vertex 4
     EFA8 001F     
     EFAA 65DC     
37411 EFAC 3200            byte >32, >00, >3c, >1f, >ff, >ff                   ; Vertex 5
     EFAE 3C1F     
     EFB0 FFFF     
37412 EFB2 2800            byte >28, >00, >46, >9f, >10, >32                   ; Vertex 6
     EFB4 469F     
     EFB6 1032     
37413 EFB8 001E            byte >00, >1e, >4b, >3f, >ff, >ff                   ; Vertex 7
     EFBA 4B3F     
     EFBC FFFF     
37414 EFBE 0032            byte >00, >32, >3c, >7f, >98, >ba                   ; Vertex 8
     EFC0 3C7F     
     EFC2 98BA     
37415               
37416               SHIP_ASTEROID_EDGES:
37417                                                                          ; vertex1, vertex2, face1, face2, visibility
37418 EFC4 1F72            byte >1f, >72, >00, >04                             ; Edge 0
     EFC6 0004     
37419 EFC8 1FD6            byte >1f, >d6, >00, >10                             ; Edge 1
     EFCA 0010     
37420 EFCC 1FC5            byte >1f, >c5, >0c, >10                             ; Edge 2
     EFCE 0C10     
37421 EFD0 1FB4            byte >1f, >b4, >08, >0c                             ; Edge 3
     EFD2 080C     
37422 EFD4 1FA3            byte >1f, >a3, >04, >08                             ; Edge 4
     EFD6 0408     
37423 EFD8 1F32            byte >1f, >32, >04, >18                             ; Edge 5
     EFDA 0418     
37424 EFDC 1F31            byte >1f, >31, >08, >18                             ; Edge 6
     EFDE 0818     
37425 EFE0 1F41            byte >1f, >41, >08, >14                             ; Edge 7
     EFE2 0814     
37426 EFE4 1F10            byte >1f, >10, >14, >18                             ; Edge 8
     EFE6 1418     
37427 EFE8 1F60            byte >1f, >60, >00, >14                             ; Edge 9
     EFEA 0014     
37428 EFEC 1F54            byte >1f, >54, >0c, >14                             ; Edge 10
     EFEE 0C14     
37429 EFF0 1F20            byte >1f, >20, >00, >18                             ; Edge 11
     EFF2 0018     
37430 EFF4 1F65            byte >1f, >65, >10, >14                             ; Edge 12
     EFF6 1014     
37431 EFF8 1FA8            byte >1f, >a8, >04, >20                             ; Edge 13
     EFFA 0420     
37432 EFFC 1F87            byte >1f, >87, >04, >1c                             ; Edge 14
     EFFE 041C     
37433 F000 1FD7            byte >1f, >d7, >00, >1c                             ; Edge 15
     F002 001C     
37434 F004 1FDC            byte >1f, >dc, >10, >1c                             ; Edge 16
     F006 101C     
37435 F008 1FC9            byte >1f, >c9, >0c, >1c                             ; Edge 17
     F00A 0C1C     
37436 F00C 1FB9            byte >1f, >b9, >0c, >20                             ; Edge 18
     F00E 0C20     
37437 F010 1FBA            byte >1f, >ba, >08, >20                             ; Edge 19
     F012 0820     
37438 F014 1F98            byte >1f, >98, >1c, >20                             ; Edge 20
     F016 1C20     
37439               
37440               SHIP_ASTEROID_FACES:
37441                                                                          ; normal_x, normal_y, normal_z, visibility
37442 F018 1F09            byte >1f, >09, >42, >51                             ; Face 0
     F01A 4251     
37443 F01C 5F09            byte >5f, >09, >42, >51                             ; Face 1
     F01E 4251     
37444 F020 9F48            byte >9f, >48, >40, >1f                             ; Face 2
     F022 401F     
37445 F024 DF40            byte >df, >40, >49, >2f                             ; Face 3
     F026 492F     
37446 F028 5F2D            byte >5f, >2d, >4f, >41                             ; Face 4
     F02A 4F41     
37447 F02C 1F87            byte >1f, >87, >0f, >23                             ; Face 5
     F02E 0F23     
37448 F030 1F26            byte >1f, >26, >4c, >46                             ; Face 6
     F032 4C46     
37449 F034 BF42            byte >bf, >42, >3b, >27                             ; Face 7
     F036 3B27     
37450 F038 FF43            byte >ff, >43, >0f, >50                             ; Face 8
     F03A 0F50     
37451 F03C 7F42            byte >7f, >42, >0e, >4b                             ; Face 9
     F03E 0E4B     
37452 F040 FF46            byte >ff, >46, >50, >28                             ; Face 10
     F042 5028     
37453 F044 7F3A            byte >7f, >3a, >66, >33                             ; Face 11
     F046 6633     
37454 F048 3F51            byte >3f, >51, >09, >43                             ; Face 12
     F04A 0943     
37455 F04C 3F2F            byte >3f, >2f, >5e, >3f                             ; Face 13
     F04E 5E3F     
37456               
37457               * ******************************************************************************
37458               *
37459               * Name: SHIP_CANISTER
37460               * Type: Variable
37461               * Category: Drawing ships
37462               * Summary: Ship blueprint for a cargo canister
37463               * Deep dive: Ship blueprints
37464               *
37465               * ******************************************************************************
37466               
37467               SHIP_CANISTER:
37468 F050 00              byte >00                                            ; Max. canisters on demise = 0
37469 F052 0190            data 20 * 20                                        ; Targetable area          = 20 * 20
37470               
37471 F054 52              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)%256      ; Edges data offset (low)
37472 F055   8E            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)%256      ; Faces data offset (low)
37473               
37474 F056 31              byte >31                                            ; Max. edge count          = (49 - 1) / 4 = 12
37475 F057   00            byte >00                                            ; Gun vertex               = 0
37476 F058 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
37477 F059   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
37478 F05A 0F              byte >0f                                            ; Number of edges          = 15
37479 F05C 0000            data >0000                                          ; Bounty                   = 0
37480 F05E 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37481 F05F   0C            byte >0c                                            ; Visibility distance      = 12
37482 F060 11              byte >11                                            ; Max. energy              = 17
37483 F061   0F            byte >0f                                            ; Max. speed               = 15
37484               
37485 F062 00              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)/256      ; Edges data offset (high)
37486 F063   00            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)/256      ; Faces data offset (high)
37487               
37488 F064 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37489 F065   00            byte >00                                            ; Laser power              = 0
37490                                                                          ; Missiles                 = 0
37491               
37492               SHIP_CANISTER_VERTICES:
37493                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37494 F066 1810            byte >18, >10, >00, >1f, >10, >55                   ; Vertex 0
     F068 001F     
     F06A 1055     
37495 F06C 1805            byte >18, >05, >0f, >1f, >10, >22                   ; Vertex 1
     F06E 0F1F     
     F070 1022     
37496 F072 180D            byte >18, >0d, >09, >5f, >20, >33                   ; Vertex 2
     F074 095F     
     F076 2033     
37497 F078 180D            byte >18, >0d, >09, >7f, >30, >44                   ; Vertex 3
     F07A 097F     
     F07C 3044     
37498 F07E 1805            byte >18, >05, >0f, >3f, >40, >55                   ; Vertex 4
     F080 0F3F     
     F082 4055     
37499 F084 1810            byte >18, >10, >00, >9f, >51, >66                   ; Vertex 5
     F086 009F     
     F088 5166     
37500 F08A 1805            byte >18, >05, >0f, >9f, >21, >66                   ; Vertex 6
     F08C 0F9F     
     F08E 2166     
37501 F090 180D            byte >18, >0d, >09, >df, >32, >66                   ; Vertex 7
     F092 09DF     
     F094 3266     
37502 F096 180D            byte >18, >0d, >09, >ff, >43, >66                   ; Vertex 8
     F098 09FF     
     F09A 4366     
37503 F09C 1805            byte >18, >05, >0f, >bf, >54, >66                   ; Vertex 9
     F09E 0FBF     
     F0A0 5466     
37504               
37505               SHIP_CANISTER_EDGES:
37506                                                                          ; vertex1, vertex2, face1, face2, visibility
37507 F0A2 1F10            byte >1f, >10, >00, >04                             ; Edge 0
     F0A4 0004     
37508 F0A6 1F20            byte >1f, >20, >04, >08                             ; Edge 1
     F0A8 0408     
37509 F0AA 1F30            byte >1f, >30, >08, >0c                             ; Edge 2
     F0AC 080C     
37510 F0AE 1F40            byte >1f, >40, >0c, >10                             ; Edge 3
     F0B0 0C10     
37511 F0B2 1F50            byte >1f, >50, >00, >10                             ; Edge 4
     F0B4 0010     
37512 F0B6 1F51            byte >1f, >51, >00, >14                             ; Edge 5
     F0B8 0014     
37513 F0BA 1F21            byte >1f, >21, >04, >18                             ; Edge 6
     F0BC 0418     
37514 F0BE 1F32            byte >1f, >32, >08, >1c                             ; Edge 7
     F0C0 081C     
37515 F0C2 1F43            byte >1f, >43, >0c, >20                             ; Edge 8
     F0C4 0C20     
37516 F0C6 1F54            byte >1f, >54, >10, >24                             ; Edge 9
     F0C8 1024     
37517 F0CA 1F61            byte >1f, >61, >14, >18                             ; Edge 10
     F0CC 1418     
37518 F0CE 1F62            byte >1f, >62, >18, >1c                             ; Edge 11
     F0D0 181C     
37519 F0D2 1F63            byte >1f, >63, >1c, >20                             ; Edge 12
     F0D4 1C20     
37520 F0D6 1F64            byte >1f, >64, >20, >24                             ; Edge 13
     F0D8 2024     
37521 F0DA 1F65            byte >1f, >65, >24, >14                             ; Edge 14
     F0DC 2414     
37522               
37523               SHIP_CANISTER_FACES:
37524                                                                          ; normal_x, normal_y, normal_z, visibility
37525 F0DE 1F60            byte >1f, >60, >00, >00                             ; Face 0
     F0E0 0000     
37526 F0E2 1F00            byte >1f, >00, >29, >1e                             ; Face 1
     F0E4 291E     
37527 F0E6 5F00            byte >5f, >00, >12, >30                             ; Face 2
     F0E8 1230     
37528 F0EA 5F00            byte >5f, >00, >33, >00                             ; Face 3
     F0EC 3300     
37529 F0EE 7F00            byte >7f, >00, >12, >30                             ; Face 4
     F0F0 1230     
37530 F0F2 3F00            byte >3f, >00, >29, >1e                             ; Face 5
     F0F4 291E     
37531 F0F6 9F60            byte >9f, >60, >00, >00                             ; Face 6
     F0F8 0000     
37532               
37533               * ******************************************************************************
37534               *
37535               * Name: SHIP_THARGON
37536               * Type: Variable
37537               * Category: Drawing ships
37538               * Summary: Ship blueprint for a Thargon
37539               * Deep dive: Ship blueprints
37540               *
37541               * ------------------------------------------------------------------------------
37542               *
37543               * The ship blueprint for the Thargon reuses the edges data from the cargo
37544               * canister, so the edges data offset is negative.
37545               *
37546               * ******************************************************************************
37547               
37548               SHIP_THARGON:
37549 F0FA 00              byte >00                                            ; Max. canisters on demise = 0
37550 F0FC 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
37551               
37552 F0FE 58              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)%256       ; Edges from canister
37553 F0FF   52            byte (SHIP_THARGON_FACES - SHIP_THARGON)%256        ; Faces data offset (low)
37554               
37555 F100 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
37556 F101   00            byte >00                                            ; Gun vertex               = 0
37557 F102 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
37558 F103   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
37559 F104 0F              byte >0f                                            ; Number of edges          = 15
37560 F106 3200            data >3200                                          ; Bounty                   = 50
37561 F108 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37562 F109   14            byte >14                                            ; Visibility distance      = 20
37563 F10A 14              byte >14                                            ; Max. energy              = 20
37564 F10B   1E            byte >1e                                            ; Max. speed               = 30
37565               
37566 F10C 00              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)/256       ; Edges from canister
37567 F10D   00            byte (SHIP_THARGON_FACES - SHIP_THARGON)/256        ; Faces data offset (high)
37568               
37569 F10E 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37570 F10F   10            byte >10                                            ; Laser power              = 2
37571                                                                          ; Missiles                 = 0
37572               
37573               SHIP_THARGON_VERTICES:
37574                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37575 F110 0900            byte >09, >00, >28, >9f, >01, >55                   ; Vertex 0
     F112 289F     
     F114 0155     
37576 F116 0926            byte >09, >26, >0c, >df, >01, >22                   ; Vertex 1
     F118 0CDF     
     F11A 0122     
37577 F11C 0918            byte >09, >18, >20, >ff, >02, >33                   ; Vertex 2
     F11E 20FF     
     F120 0233     
37578 F122 0918            byte >09, >18, >20, >bf, >03, >44                   ; Vertex 3
     F124 20BF     
     F126 0344     
37579 F128 0926            byte >09, >26, >0c, >9f, >04, >55                   ; Vertex 4
     F12A 0C9F     
     F12C 0455     
37580 F12E 0900            byte >09, >00, >08, >3f, >15, >66                   ; Vertex 5
     F130 083F     
     F132 1566     
37581 F134 090A            byte >09, >0a, >0f, >7f, >12, >66                   ; Vertex 6
     F136 0F7F     
     F138 1266     
37582 F13A 0906            byte >09, >06, >1a, >7f, >23, >66                   ; Vertex 7
     F13C 1A7F     
     F13E 2366     
37583 F140 0906            byte >09, >06, >1a, >3f, >34, >66                   ; Vertex 8
     F142 1A3F     
     F144 3466     
37584 F146 090A            byte >09, >0a, >0f, >3f, >45, >66                   ; Vertex 9
     F148 0F3F     
     F14A 4566     
37585               
37586               SHIP_THARGON_FACES:
37587                                                                          ; normal_x, normal_y, normal_z, visibility
37588 F14C 9F24            byte >9f, >24, >00, >00                             ; Face 0
     F14E 0000     
37589 F150 5F14            byte >5f, >14, >05, >07                             ; Face 1
     F152 0507     
37590 F154 7F2E            byte >7f, >2e, >2a, >0e                             ; Face 2
     F156 2A0E     
37591 F158 3F24            byte >3f, >24, >00, >68                             ; Face 3
     F15A 0068     
37592 F15C 3F2E            byte >3f, >2e, >2a, >0e                             ; Face 4
     F15E 2A0E     
37593 F160 1F14            byte >1f, >14, >05, >07                             ; Face 5
     F162 0507     
37594 F164 1F24            byte >1f, >24, >00, >00                             ; Face 6
     F166 0000     
37595               
37596               * ******************************************************************************
37597               *
37598               * Name: SHIP_ESCAPE_POD
37599               * Type: Variable
37600               * Category: Drawing ships
37601               * Summary: Ship blueprint for an escape pod
37602               * Deep dive: Ship blueprints
37603               *
37604               * ******************************************************************************
37605               
37606               SHIP_ESCAPE_POD:
37607 F168 00              byte >00                                            ; Max. canisters on demise = 0
37608 F16A 0100            data 16 * 16                                        ; Targetable area          = 16 * 16
37609               
37610 F16C 2E              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)%256  ; Edges data offset (low)
37611 F16D   46            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)%256  ; Faces data offset (low)
37612               
37613 F16E 19              byte >19                                            ; Max. edge count          = (25 - 1) / 4 = 6
37614 F16F   00            byte >00                                            ; Gun vertex               = 0
37615 F170 16              byte >16                                            ; Explosion count          = 4, as (4 * n) + 6 = 22
37616 F171   18            byte >18                                            ; Number of vertices       = 24 / 6 = 4
37617 F172 06              byte >06                                            ; Number of edges          = 6
37618 F174 0000            data >0000                                          ; Bounty                   = 0
37619 F176 10              byte >10                                            ; Number of faces          = 16 / 4 = 4
37620 F177   08            byte >08                                            ; Visibility distance      = 8
37621 F178 11              byte >11                                            ; Max. energy              = 17
37622 F179   08            byte >08                                            ; Max. speed               = 8
37623               
37624 F17A 00              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)/256  ; Edges data offset (high)
37625 F17B   00            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)/256  ; Faces data offset (high)
37626               
37627 F17C 03              byte >03                                            ; Normals are scaled by    =  2^3 = 8
37628 F17D   00            byte >00                                            ; Laser power              = 0
37629                                                                          ; Missiles                 = 0
37630               
37631               SHIP_ESCAPE_POD_VERTICES:
37632                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37633 F17E 0700            byte >07, >00, >24, >9f, >12, >33                   ; Vertex 0
     F180 249F     
     F182 1233     
37634 F184 070E            byte >07, >0e, >0c, >ff, >02, >33                   ; Vertex 1
     F186 0CFF     
     F188 0233     
37635 F18A 070E            byte >07, >0e, >0c, >bf, >01, >33                   ; Vertex 2
     F18C 0CBF     
     F18E 0133     
37636 F190 1500            byte >15, >00, >00, >1f, >01, >22                   ; Vertex 3
     F192 001F     
     F194 0122     
37637               
37638               SHIP_ESCAPE_POD_EDGES:
37639                                                                          ; vertex1, vertex2, face1, face2, visibility
37640 F196 1F23            byte >1f, >23, >00, >04                             ; Edge 0
     F198 0004     
37641 F19A 1F03            byte >1f, >03, >04, >08                             ; Edge 1
     F19C 0408     
37642 F19E 1F01            byte >1f, >01, >08, >0c                             ; Edge 2
     F1A0 080C     
37643 F1A2 1F12            byte >1f, >12, >0c, >00                             ; Edge 3
     F1A4 0C00     
37644 F1A6 1F13            byte >1f, >13, >00, >08                             ; Edge 4
     F1A8 0008     
37645 F1AA 1F02            byte >1f, >02, >0c, >04                             ; Edge 5
     F1AC 0C04     
37646               
37647               SHIP_ESCAPE_POD_FACES:
37648                                                                          ; normal_x, normal_y, normal_z, visibility
37649 F1AE 3F1A            byte >3f, >1a, >00, >3d                             ; Face 0
     F1B0 003D     
37650 F1B2 1F13            byte >1f, >13, >33, >0f                             ; Face 1
     F1B4 330F     
37651 F1B6 5F13            byte >5f, >13, >33, >0f                             ; Face 2
     F1B8 330F     
37652 F1BA 9F38            byte >9f, >38, >00, >00                             ; Face 3
     F1BC 0000     
37653               
37654               * ******************************************************************************
37655               *
37656               * Save SHIPS.bin
37657               *
37658               * ******************************************************************************
37659               
37660                      ; PRINT "SHIPS"
37661                      ; PRINT "Assembled at ", ~CODE_SHIPS%
37662                      ; PRINT "Ends at ", ~P%
37663                      ; PRINT "Code size is ", ~(P% - CODE_SHIPS%)
37664                      ; PRINT "Execute at ", ~LOAD%
37665                      ; PRINT "Reload at ", ~LOAD_SHIPS%
37666               
37667                      ; PRINT "S.SHIPS ", ~CODE_SHIPS%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_SHIPS%
37668                      ; SAVE "3-assembled-output/SHIPS.bin", CODE_SHIPS%, P%, LOAD%
37669               
37670               * ******************************************************************************
37671               *
37672               * ELITE PYTHON SHIP BLUEPRINT FILE
37673               *
37674               * Produces the binary file PYTHON.bin that gets loaded by elite-bcfs.asm.
37675               *
37676               * ******************************************************************************
37677               
37678                      ; CLEAR 0, &7F00                ; CLEAR 0, &7F00
37679               
37680               LOAD_PYTHON.:
37681                      equ >1B00
37682               
37683               * ORG CODE_PYTHON%
37684               
37685               * ******************************************************************************
37686               *
37687               * Name: SHIP_PYTHON
37688               * Type: Variable
37689               * Category: Drawing ships
37690               * Summary: Ship blueprint for a Python
37691               * Deep dive: Ship blueprints
37692               *
37693               * ******************************************************************************
37694               
37695               SHIP_PYTHON:
37696 F1BE 03              byte >03                                            ; Max. canisters on demise = 3
37697 F1C0 3840            data 120 * 120                                      ; Targetable area          = 120 * 120
37698               
37699 F1C2 58              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)%256          ; Edges data offset (low)
37700 F1C3   C0            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)%256          ; Faces data offset (low)
37701               
37702 F1C4 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
37703 F1C5   00            byte >00                                            ; Gun vertex               = 0
37704 F1C6 2E              byte >2e                                            ; Explosion count          = 10, as (4 * n) + 6 = 46
37705 F1C7   42            byte >42                                            ; Number of vertices       = 66 / 6 = 11
37706 F1C8 1A              byte >1a                                            ; Number of edges          = 26
37707 F1CA C800            data >c800                                          ; Bounty                   = 200
37708 F1CC 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
37709 F1CD   28            byte >28                                            ; Visibility distance      = 40
37710 F1CE FA              byte >fa                                            ; Max. energy              = 250
37711 F1CF   14            byte >14                                            ; Max. speed               = 20
37712               
37713 F1D0 00              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)/256          ; Edges data offset (high)
37714 F1D1   00            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)/256          ; Faces data offset (high)
37715               
37716 F1D2 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
37717 F1D3   1B            byte >1b                                            ; Laser power              = 3
37718                                                                          ; Missiles                 = 3
37719               
37720               SHIP_PYTHON_VERTICES:
37721                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37722 F1D4 0000            byte >00, >00, >e0, >1f, >10, >32                   ; Vertex 0
     F1D6 E01F     
     F1D8 1032     
37723 F1DA 0030            byte >00, >30, >30, >1e, >10, >54                   ; Vertex 1
     F1DC 301E     
     F1DE 1054     
37724 F1E0 6000            byte >60, >00, >10, >3f, >ff, >ff                   ; Vertex 2
     F1E2 103F     
     F1E4 FFFF     
37725 F1E6 6000            byte >60, >00, >10, >bf, >ff, >ff                   ; Vertex 3
     F1E8 10BF     
     F1EA FFFF     
37726 F1EC 0030            byte >00, >30, >20, >3e, >54, >98                   ; Vertex 4
     F1EE 203E     
     F1F0 5498     
37727 F1F2 0018            byte >00, >18, >70, >3f, >89, >cc                   ; Vertex 5
     F1F4 703F     
     F1F6 89CC     
37728 F1F8 3000            byte >30, >00, >70, >bf, >b8, >cc                   ; Vertex 6
     F1FA 70BF     
     F1FC B8CC     
37729 F1FE 3000            byte >30, >00, >70, >3f, >a9, >cc                   ; Vertex 7
     F200 703F     
     F202 A9CC     
37730 F204 0030            byte >00, >30, >30, >5e, >32, >76                   ; Vertex 8
     F206 305E     
     F208 3276     
37731 F20A 0030            byte >00, >30, >20, >7e, >76, >ba                   ; Vertex 9
     F20C 207E     
     F20E 76BA     
37732 F210 0018            byte >00, >18, >70, >7e, >ba, >cc                   ; Vertex 10
     F212 707E     
     F214 BACC     
37733               
37734               SHIP_PYTHON_EDGES:
37735                                                                          ; vertex1, vertex2, face1, face2, visibility
37736 F216 1E32            byte >1e, >32, >00, >20                             ; Edge 0
     F218 0020     
37737 F21A 1F20            byte >1f, >20, >00, >0c                             ; Edge 1
     F21C 000C     
37738 F21E 1F31            byte >1f, >31, >00, >08                             ; Edge 2
     F220 0008     
37739 F222 1E10            byte >1e, >10, >00, >04                             ; Edge 3
     F224 0004     
37740 F226 1D59            byte >1d, >59, >08, >10                             ; Edge 4
     F228 0810     
37741 F22A 1D51            byte >1d, >51, >04, >08                             ; Edge 5
     F22C 0408     
37742 F22E 1D37            byte >1d, >37, >08, >20                             ; Edge 6
     F230 0820     
37743 F232 1D40            byte >1d, >40, >04, >0c                             ; Edge 7
     F234 040C     
37744 F236 1D62            byte >1d, >62, >0c, >20                             ; Edge 8
     F238 0C20     
37745 F23A 1DA7            byte >1d, >a7, >08, >24                             ; Edge 9
     F23C 0824     
37746 F23E 1D84            byte >1d, >84, >0c, >10                             ; Edge 10
     F240 0C10     
37747 F242 1DB6            byte >1d, >b6, >0c, >24                             ; Edge 11
     F244 0C24     
37748 F246 0588            byte >05, >88, >0c, >14                             ; Edge 12
     F248 0C14     
37749 F24A 05BB            byte >05, >bb, >0c, >28                             ; Edge 13
     F24C 0C28     
37750 F24E 0599            byte >05, >99, >08, >14                             ; Edge 14
     F250 0814     
37751 F252 05AA            byte >05, >aa, >08, >28                             ; Edge 15
     F254 0828     
37752 F256 1FA9            byte >1f, >a9, >08, >1c                             ; Edge 16
     F258 081C     
37753 F25A 1FB8            byte >1f, >b8, >0c, >18                             ; Edge 17
     F25C 0C18     
37754 F25E 1FC8            byte >1f, >c8, >14, >18                             ; Edge 18
     F260 1418     
37755 F262 1FC9            byte >1f, >c9, >14, >1c                             ; Edge 19
     F264 141C     
37756 F266 1DAC            byte >1d, >ac, >1c, >28                             ; Edge 20
     F268 1C28     
37757 F26A 1DCB            byte >1d, >cb, >18, >28                             ; Edge 21
     F26C 1828     
37758 F26E 1D98            byte >1d, >98, >10, >14                             ; Edge 22
     F270 1014     
37759 F272 1DBA            byte >1d, >ba, >24, >28                             ; Edge 23
     F274 2428     
37760 F276 1D54            byte >1d, >54, >04, >10                             ; Edge 24
     F278 0410     
37761 F27A 1D76            byte >1d, >76, >20, >24                             ; Edge 25
     F27C 2024     
37762               
37763               SHIP_PYTHON_FACES:
37764                                                                          ; normal_x, normal_y, normal_z, visibility
37765 F27E 9E1B            byte >9e, >1b, >28, >0b                             ; Face 0
     F280 280B     
37766 F282 1E1B            byte >1e, >1b, >28, >0b                             ; Face 1
     F284 280B     
37767 F286 DE1B            byte >de, >1b, >28, >0b                             ; Face 2
     F288 280B     
37768 F28A 5E1B            byte >5e, >1b, >28, >0b                             ; Face 3
     F28C 280B     
37769 F28E 9E13            byte >9e, >13, >26, >00                             ; Face 4
     F290 2600     
37770 F292 1E13            byte >1e, >13, >26, >00                             ; Face 5
     F294 2600     
37771 F296 DE13            byte >de, >13, >26, >00                             ; Face 6
     F298 2600     
37772 F29A 5E13            byte >5e, >13, >26, >00                             ; Face 7
     F29C 2600     
37773 F29E BE19            byte >be, >19, >25, >0b                             ; Face 8
     F2A0 250B     
37774 F2A2 3E19            byte >3e, >19, >25, >0b                             ; Face 9
     F2A4 250B     
37775 F2A6 7E19            byte >7e, >19, >25, >0b                             ; Face 10
     F2A8 250B     
37776 F2AA FE19            byte >fe, >19, >25, >0b                             ; Face 11
     F2AC 250B     
37777 F2AE 3E00            byte >3e, >00, >00, >70                             ; Face 12
     F2B0 0070     
37778               
37779 F2B2                 bss 11                                              ; This space appears to be unused
37780               
37781               * ******************************************************************************
37782               *
37783               * Name: SVN
37784               * Type: Variable
37785               * Category: Save and load
37786               * Summary: The "saving in progress" flag
37787               *
37788               * ******************************************************************************
37789               
37790               SVN:
37791 F2BD                 bss 1                                               ; "Saving in progress" flag
37792                                                                          ;
37793                                                                          ; * Non-zero while we are saving a commander
37794                                                                          ;
37795                                                                          ; * 0 otherwise
37796               
37797               * ******************************************************************************
37798               *
37799               * Name: VEC
37800               * Type: Variable
37801               * Category: Drawing the screen
37802               * Summary: The original value of the IRQ1 vector
37803               *
37804               * ******************************************************************************
37805               
37806               VEC:
37807               * SKIP 2                 \ VEC = &7FFE
37808                                                                          ;
37809                                                                          ; This gets set to the value of the original IRQ1 vector
37810                                                                          ; by the loading process
37811               * ******************************************************************************
37812               *
37813               * Save PYTHON.bin
37814               *
37815               * ******************************************************************************
37816                      ; PRINT "PYTHON"
37817                      ; PRINT "Assembled at ", ~CODE_PYTHON%
37818                      ; PRINT "Ends at ", ~P%
37819                      ; PRINT "Code size is ", ~(P% - CODE_PYTHON%)
37820                      ; PRINT "Execute at ", ~LOAD%
37821                      ; PRINT "Reload at ", ~LOAD_PYTHON%
37822               
37823                      ; PRINT "S.PYTHON ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_PYTHON%
37824                      ; SAVE "3-assembled-output/PYTHON.bin", CODE_PYTHON%, P%, LOAD%
37825               
37826               * ******************************************************************************
37827               *
37828               * Show free space
37829               *
37830               * ******************************************************************************
37831               
37832                      ; PRINT "ELITE game code ", ~(&6000-P%), " bytes free"
37833                      ; PRINT "Ends at ", ~P%
                   < main.a99
0004                      aorg >FE00
0005                      copy "entry.a99"
     **** ****     > entry.a99
0001 FE00 0300  22        limi 0
     FE02 0000     
0002 FE04 02E0  18        lwpi workspace
     FE06 206C     
0003 FE08 020A  24        li   rsp,STACK.
     FE0A 0100     
0004 FE0C 0209  24        li   rvdpwd,vdpwd
     FE0E 8C00     
0005 FE10 06A0  36        bl   @graphics_mode
     FE12 FE8A     
0006 FE14 0460  28        b    @TT170
     FE16 C5A4     
0007               
                   < main.a99
0006                      copy "subroutines.a99"
     **** ****     > subroutines.a99
0001               OSBYTE:
0002 FE18 1008  14        jmp rts
0003               OSWORD:
0004 FE1A 1007  14        jmp rts
0005               OSFILE:
0006 FE1C 1006  14        jmp rts
0007               
0008               jsr:
0009 FE1E D68B  38        movb r11,*rsp
0010 FE20 060A  22        dec  rsp
0011 FE22 06CB  22        swpb r11
0012 FE24 D68B  38        movb r11,*rsp
0013 FE26 060A  22        dec  rsp
0014 FE28 0450  24        b    *rtmp
0015               
0016               rts:
0017 FE2A 058A  22        inc  rsp
0018 FE2C D2FA  44        movb *rsp+,r11
0019 FE2E 06CB  22        swpb r11
0020 FE30 D2DA  38        movb *rsp,r11
0021 FE32 045B  24        b    *r11
0022               
0023               rola:
0024 FE34 1702  14        jnc  !
0025 FE36 026D  30        ori  ra,>0080
     FE38 0080     
0026               !:
0027 FE3A 1002  14        jmp  !
0028 FE3C 024D  30        andi ra,>ff7f
     FE3E FF7F     
0029               !:
0030 FE40 0A1D  26        sla  ra,1
0031 FE42 045B  24        rt
0032               
0033               rol:
0034 FE44 D014  38        movb *rarg1,rtmp
0035 FE46 1702  14        jnc  !
0036 FE48 0260  30        ori  rtmp,>0080
     FE4A 0080     
0037               !:
0038 FE4C 1002  14        jmp  !
0039 FE4E 0240  30        andi rtmp,>ff7f
     FE50 FF7F     
0040               !:
0041 FE52 0A10  26        sla  rtmp,1
0042 FE54 C500  38        mov  rtmp,*rarg1
0043 FE56 045B  24        rt
0044               
0045               rora:
0046 FE58 1702  14        jnc  !
0047 FE5A 026D  30        ori  ra,>0001
     FE5C 0001     
0048               !:
0049 FE5E 1002  14        jmp  !
0050 FE60 024D  30        andi ra,>fffe
     FE62 FFFE     
0051               !:
0052 FE64 0B1D  26        src  ra,1
0053 FE66 024D  30        andi ra,>0080
     FE68 0080     
0054 FE6A C00D  30        mov  ra,rtmp
0055 FE6C 0A90  42        sla  rtmp,9
0056 FE6E 045B  24        rt
0057               
0058               ror:
0059 FE70 D014  38        movb *rarg1,rtmp
0060 FE72 1702  14        jnc  !
0061 FE74 0260  30        ori  rtmp,>0001
     FE76 0001     
0062               !:
0063 FE78 1002  14        jmp  !
0064 FE7A 0240  30        andi rtmp,>fffe
     FE7C FFFE     
0065               !:
0066 FE7E 0B10  26        src  rtmp,1
0067 FE80 D500  38        movb rtmp,*rarg1
0068 FE82 0240  30        andi rtmp,>0080
     FE84 0080     
0069 FE86 0A90  42        sla  rtmp,9
0070 FE88 045B  24        rt
                   < main.a99
0007                      copy "vdp.a99"
     **** ****     > vdp.a99
0001               *********************************************************************************
0002               *
0003               * Set graphics mode
0004               *
0005               graphics_mode:
0006                      .proc
     **** ****     > PROC
0001 FE8A 064A  22        dect rsp
0002 FE8C C68B  38        mov  r11,*rsp
                   < vdp.a99
0007 FE8E 0201  24        li   rtmp2,vregs2
     FE90 FED8     
0008               graphics_mode_1:
0009 FE92 C031  46        mov  *rtmp2+,rtmp
0010 FE94 111F  14        jlt  graphics_mode_2
0011 FE96 06A0  36        bl   @vwtr                      ; Set register
     FE98 FEEA     
0012 FE9A 10FB  14        jmp  graphics_mode_1
0013               *      Init name table
0014 FE9C 0200  24        li   rtmp,name_table
     FE9E 3800     
0015 FEA0 06A0  36        bl   @vwad
     FEA2 FEFC     
0016 FEA4 04C1  22        clr  rtmp2
0017 FEA6 0202  24        li   rtmp3,>300
     FEA8 0300     
0018               init_vdp_ram_1:
0019 FEAA D641  38        movb rtmp2,*rvdpwd
0020 FEAC 0220  30        ai   rtmp,>0100
     FEAE 0100     
0021 FEB0 0602  22        dec  rtmp3
0022 FEB2 16FB  14        jne   init_vdp_ram_1
0023               *      Init patterms
0024 FEB4 0200  24        li   rtmp,pattern_table
     FEB6 0000     
0025 FEB8 0200  24        li   rtmp,>0000
     FEBA 0000     
0026 FEBC 0202  24        li   rtmp3,>1800
     FEBE 1800     
0027 FEC0 06A0  36        bl   @vsmw
     FEC2 FF3A     
0028               *      Init colors
0029 FEC4 0200  24        li   rtmp,color_table
     FEC6 2000     
0030 FEC8 0201  24        li   rtmp2,>f100
     FECA F100     
0031 FECC 0202  24        li   rtmp3,>1800
     FECE 1800     
0032 FED0 06A0  36        bl   @vsmw
     FED2 FF3A     
0033               *      Return
0034               graphics_mode_2:
0035                      .endproc
     **** ****     > ENDPROC
0001 FED4 C2FA  46        mov  *rsp+,r11
0002 FED6 045B  24        b    *r11
                   < vdp.a99
0036               *      VDP registers
0037               vregs2:
0038 FED8 0002            byte >00,>02                        ; Graphics II mode
0039 FEDA 01E2            byte >01,>e2                        ; 16K, display on, interrupts enabled
0040 FEDC 020E            byte >02,name_table/>400            ; Name table
0041 FEDE 03FF            byte >03,>ff                        ; Color table
0042 FEE0 0403            byte >04,pattern_table/>800+>03     ; Pattern table
0043 FEE2 0576            byte >05,sprite_attr_table/>80      ; Sprite attribute table
0044 FEE4 0603            byte >06,sprite_pattern_table/>800  ; Sprite pattern table
0045 FEE6 0701            byte >07,>01                        ; Backdrop color
0046 FEE8 FFFF            data -1
0047               *// graphics_mode
0048               
0049               *********************************************************************
0050               *
0051               * VDP Write To Register
0052               *
0053               * rtmp MSB: VDP register to write to
0054               * rtmp LSB: Value to write
0055               *
0056               vwtr:
0057 FEEA 06C0  22        swpb rtmp
0058 FEEC D800  34        movb rtmp,@vdpwa                ; Send low byte (value) to write to VDP register
     FEEE 8C02     
0059 FEF0 06C0  22        swpb rtmp
0060 FEF2 0260  30        ori  rtmp,>8000                 ; Set up a VDP register write operation (10)
     FEF4 8000     
0061 FEF6 D800  34        movb rtmp,@vdpwa                ; Send high byte (address) of VDP register
     FEF8 8C02     
0062 FEFA 045B  24        rt
0063               *// vwtr
0064               
0065               *********************************************************************
0066               *
0067               * VDP Set Write Address
0068               *
0069               * rtmp: Write address in VDP RAM
0070               *
0071               vwad:
0072 FEFC 06C0  22        swpb rtmp
0073 FEFE D800  34        movb rtmp,@vdpwa                ; Send low byte of VDP RAM write address
     FF00 8C02     
0074 FF02 06C0  22        swpb rtmp
0075 FF04 0260  30        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF06 4000     
0076 FF08 D800  34        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF0A 8C02     
0077 FF0C 045B  24        rt
0078               *// vwad
0079               
0080               *********************************************************************
0081               *
0082               * VDP Single Byte Write
0083               *
0084               * rtmp: Write address in VDP RAM
0085               * rtmp2: MSB of rtmp2 sent to VDP RAM
0086               *
0087               vsbw:
0088 FF0E 06C0  22        swpb rtmp
0089 FF10 D800  34        movb rtmp,@vdpwa                ; Send low byte of VDP RAM write address
     FF12 8C02     
0090 FF14 06C0  22        swpb rtmp
0091 FF16 0260  30        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF18 4000     
0092 FF1A D800  34        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF1C 8C02     
0093 FF1E D641  38        movb rtmp2,*rvdpwd              ; Write byte to VDP RAM
0094 FF20 045B  24        rt
0095               *// vsbw
0096               
0097               *********************************************************************
0098               *
0099               * VDP multiple Byte Write
0100               *
0101               * rtmp: Write address in VDP RAM
0102               * rtmp2: Starting read address in CPU RAM
0103               * rtmp3: Number of bytes to send
0104               *
0105               vmbw:
0106 FF22 06C0  22        swpb rtmp
0107 FF24 D800  34        movb rtmp,@vdpwa                ; Send low byte of VDP RAM write address
     FF26 8C02     
0108 FF28 06C0  22        swpb rtmp
0109 FF2A 0260  30        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF2C 4000     
0110 FF2E D800  34        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF30 8C02     
0111               vmbw_1:
0112 FF32 D670  52        movb *rtmp+,*rvdpwd             ; Write byte to VDP RAM
0113 FF34 0602  22        dec  rtmp3
0114 FF36 16FD  14        jne  vmbw_1
0115 FF38 045B  24        rt
0116               *// vmbw
0117               
0118               *********************************************************************
0119               *
0120               * VDP Single Byte Multiple Write
0121               *
0122               * rtmp: Write address in VDP RAM
0123               * rtmp2: MSB of  sent to VDP RAM
0124               * rtmp3: Number of bytes to write to VDP RAM
0125               *
0126               vsmw:
0127 FF3A 06C0  22        swpb rtmp
0128 FF3C D800  34        movb  rtmp,@vdpwa               ; Send low byte of VDP RAM write address
     FF3E 8C02     
0129 FF40 06C0  22        swpb rtmp
0130 FF42 0260  30        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF44 4000     
0131 FF46 D800  34        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF48 8C02     
0132               vsmw_1:
0133 FF4A D641  38        movb rtmp2,*rvdpwd              ; Write byte to VDP RAM
0134 FF4C 0602  22        dec  rtmp3                      ; Byte counter
0135 FF4E 16FD  14        jne  vsmw_1
0136 FF50 045B  24        rt
0137               *// vsmw
0138               
0139               *********************************************************************
0140               *
0141               * Copy screen buffer to VDP
0142               *
0143               display_scr_buffer:
0144 FF52 04E0  26        clr  @vdpwa                     ; Send low byte of VDP RAM write address
     FF54 8C02     
0145 FF56 0200  24        li   rtmp,pattern_table+>4000
     FF58 4000     
0146 FF5A D800  34        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF5C 8C02     
0147 FF5E 0201  24        li   rtmp2,scr_buffer
     FF60 6000     
0148 FF62 0202  24        li   rtmp3,>1800/8
     FF64 0300     
0149               display_scr_buffer_1:
0150 FF66 D671  52        movb *rtmp2+,*rvdpwd            ; Send by to VDP
0151 FF68 D671  52        movb *rtmp2+,*rvdpwd            ; ...
0152 FF6A D671  52        movb *rtmp2+,*rvdpwd            ; ...
0153 FF6C D671  52        movb *rtmp2+,*rvdpwd            ; ...
0154 FF6E D671  52        movb *rtmp2+,*rvdpwd            ; ...
0155 FF70 D671  52        movb *rtmp2+,*rvdpwd            ; ...
0156 FF72 D671  52        movb *rtmp2+,*rvdpwd            ; ...
0157 FF74 D671  52        movb *rtmp2+,*rvdpwd            ; ...
0158 FF76 0602  22        dec  rtmp3                      ; Counter
0159 FF78 16F6  14        jne  display_scr_buffer_1       ; Loop
0160 FF7A 045B  24        rt
0161               display_scr_buffer_end:
0162                      equ  $
0163               *// display_scr_buffer
                   < main.a99
