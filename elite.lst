XAS99 CROSS-ASSEMBLER   VERSION 3.6.5
     **** ****     > main.a99
0001                      copy "equates.a99"
     **** ****     > equates.a99
0001               **
0002               * Memory mapped addresses
0003               *
0004               vdpwd:                                 ; VDP write data
0005                      equ  >8c00
0006               vdpwa:                                 ; VDP set read/write address
0007                      equ  >8c02
0008               vdprd:                                 ; VDP read data
0009                      equ  >8800
0010               vdpsta:                                ; VDP status
0011                      equ  >8802
0012               sound:                                 ; Sound
0013                      equ  >8400
0014               spchwt:
0015                      equ  >9400
0016               spchrd:
0017                      equ  >9000
0018               
0019               workspace:
0020                      equ  >8300
0021               
0022               **
0023               * VDP memory map
0024               *
0025               pattern_table:                         ; Pattern table
0026                      equ  >0000
0027               sprite_pattern_table:                  ; Sprite pattern table
0028                      equ  >1800
0029               name_table:                            ; Name table
0030                      equ  >3800
0031               sprite_attr_table:                     ; Sprite attribute table
0032                      equ  >3b00
0033               color_table:                           ; Color table
0034                      equ  >2000
0035               
0036               **
0037               * Register map
0038               *
0039               rtmp:
0040      0000            requ 0
0041               rtmplb:
0042                      equ workspace + 1
0043               rtmp2:
0044      0000            requ 1
0045               rtmp3:
0046      0000            requ 2
0047               rtmp4:
0048      0000            requ 3
0049               rarg1:
0050      0000            requ 4
0051               rarg2:
0052      0000            requ 5
0053               rzero:
0054      0000            requ 6
0055               rone:
0056      0000            requ 7
0057               rmone:
0058      0000            requ 8
0059               rvdpwd:
0060      0000            requ 9
0061               rsp:
0062      0000            requ 10
0063               rsplb:
0064                      equ workspace + 21
0065               ra:
0066      0000            requ 13
0067               rx:
0068      0000            requ 14
0069               ry:
0070      0000            requ 15
0071               
0072               **
0073               * Constants
0074               *
0075               _MAX_COMMANDER:
0076                      equ  0
0077               _REMOVE_CHECKSUMS:
0078                      equ  1
0079               ZERO_PAGE.:
0080                      equ >0000
0081               STACK.:
0082                      equ >0100
0083               T.:
0084                      equ >0300
0085               CODE_WORDS.:
0086                      equ >0400
0087               K.:
0088                      equ >0900
0089               WP.:
0090                      equ >0D40
0091               CODE.:
0092                      equ >0F40
0093               CODE_UPPER.:
0094                      equ >A000
0095               CODE_PYTHON.:
0096                      equ >F200
0097               
0098               scr_buffer:
0099                      equ >6000
                   < main.a99
0002                      copy "macros.a99"
     **** ****     > macros.a99
0001               **
0002               * Macros
0003               *
0008               
0013               
0019               
0025               
0032               
0039               
0052               
0059               
0066               
0072               
0083               
0093               
0099               
0105               
0114               
0123               
0128               
0133               
0141               
0147               
0152               
0159               
0165               
0171               
0175               
0179               
0187               
0207               
                   < main.a99
0003                      copy "elite.a99"
     **** ****     > elite.a99
0001               * ******************************************************************************
0002               *
0003               * ELITE GAME SOURCE
0004               *
0005               * Elite was written by Ian Bell and David Braben and is copyright Acornsoft 1984
0006               *
0007               * The code on this site is identical to the source discs released on Ian Bell's
0008               * personal website at http://www.elitehomepage.org/ (it's just been reformatted
0009               * to be more readable)
0010               *
0011               * The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
0012               * in the documentation are entirely my fault
0013               *
0014               * The terminology and notations used in this commentary are explained at
0015               * https://elite.bbcelite.com/terminology
0016               *
0017               * The deep dive articles referred to in this commentary can be found at
0018               * https://elite.bbcelite.com/deep_dives
0019               *
0020               * ------------------------------------------------------------------------------
0021               *
0022               * This source file produces the following binary files:
0023               *
0024               * * ELTA.bin
0025               * * ELTB.bin
0026               * * ELTC.bin
0027               * * ELTD.bin
0028               * * ELTE.bin
0029               * * ELTF.bin
0030               * * ELTG.bin
0031               * * PYTHON.bin
0032               * * SHIPS.bin
0033               * * WORDS9.bin
0034               *
0035               * ******************************************************************************
0036               
0037                      ; INCLUDE "1-source-files/main-sources/elite-build-options.asm"
0038               
0039               _SOURCE_DISC:                                              ; (_VARIANT = 1)
0040                      equ 0
0041               _TEXT_SOURCES:                                             ; (_VARIANT = 2)
0042                      equ 0
0043               _STH_CASSETTE:                                             ; (_VARIANT = 3)
0044                      equ 1
0045               
0046                      ; GUARD &6000                                       ; Guard against assembling over screen memory
0047               
0048               * ******************************************************************************
0049               *
0050               * Configuration variables
0051               *
0052               * ******************************************************************************
0053               
0054               * ZERO_PAGE% = &0000
0055               
0056               * STACK% = &0100
0057               
0058               * CODE% = &0F40         \ The address where the code will be run
0059               
0060               LOAD.:                                                     ; The address where the code will be loaded
0061                      equ >1128
0062               
0063               * T% = &0300            \ Current commander data and stardust data blocks
0064               
0065               * CODE_WORDS% = &0400   \ The address where the text data will be run
0066               
0067               LOAD_WORDS.:                                               ; The address where the text data will be loaded
0068                      equ >1100
0069               
0070               * K% = &0900
0071               
0072               * WP% = &0D40
0073               
0074               * CODE_PYTHON% = &7F00
0075               
0076               Q.:                                                        ; Set Q% to TRUE to max out the default commander, FALSE
0077                      equ _MAX_COMMANDER
0078                                                                          ; for the standard default commander
0079               
0080               NOST:                                                      ; The number of stardust particles in normal space (this
0081                      equ 18
0082                                                                          ; goes down to 3 in witchspace)
0083               
0084               NOSH:                                                      ; The maximum number of ships in our local bubble of
0085                      equ 12
0086                                                                          ; universe
0087               
0088               NTY:                                                       ; The number of different ship types
0089                      equ 13
0090               
0091               COPS:                                                      ; Ship type for a Viper
0092                      equ 2
0093               
0094               THG:                                                       ; Ship type for a Thargoid
0095                      equ 6
0096               
0097               CYL:                                                       ; Ship type for a Cobra Mk III (trader)
0098                      equ 7
0099               
0100               SST:                                                       ; Ship type for the space station
0101                      equ 8
0102               
0103               MSL:                                                       ; Ship type for a missile
0104                      equ 9
0105               
0106               AST:                                                       ; Ship type for an asteroid
0107                      equ 10
0108               
0109               OIL:                                                       ; Ship type for a cargo canister
0110                      equ 11
0111               
0112               TGL:                                                       ; Ship type for a Thargon
0113                      equ 12
0114               
0115               ESC:                                                       ; Ship type for an escape pod
0116                      equ 13
0117               
0118               POW:                                                       ; Pulse laser power
0119                      equ 15
0120               
0121               NI.:                                                       ; The number of bytes in each ship's data block (as
0122                      equ 36
0123                                                                          ; stored in INWK and K%)
0124               
0125               VSCAN:                                                     ; Defines the split position in the split-screen mode
0126                      equ 57
0127               
0128               X:                                                         ; The centre x-coordinate of the 256 x 192 space view
0129                      equ 128
0130               
0131               Y:                                                         ; The centre y-coordinate of the 256 x 192 space view
0132                      equ 96
0133               
0134               f0_:                                                       ; Internal key number for red key f0 (Launch, Front)
0135                      equ >20
0136               
0137               f1_:                                                       ; Internal key number for red key f1 (Buy Cargo, Rear)
0138                      equ >71
0139               
0140               f2_:                                                       ; Internal key number for red key f2 (Sell Cargo, Left)
0141                      equ >72
0142               
0143               f3_:                                                       ; Internal key number for red key f3 (Equip Ship, Right)
0144                      equ >73
0145               
0146               f4_:                                                       ; Internal key number for red key f4 (Long-range Chart)
0147                      equ >14
0148               
0149               f5_:                                                       ; Internal key number for red key f5 (Short-range Chart)
0150                      equ >74
0151               
0152               f6_:                                                       ; Internal key number for red key f6 (Data on System)
0153                      equ >75
0154               
0155               f7_:                                                       ; Internal key number for red key f7 (Market Price)
0156                      equ >16
0157               
0158               f8_:                                                       ; Internal key number for red key f8 (Status Mode)
0159                      equ >76
0160               
0161               f9_:                                                       ; Internal key number for red key f9 (Inventory)
0162                      equ >77
0163               
0164               RE:                                                        ; The obfuscation byte used to hide the recursive tokens
0165                      equ >23
0166                                                                          ; table from crackers viewing the binary code
0167               
0168               VIA:                                                       ; Memory-mapped space for accessing internal hardware,
0169                      equ >FE00
0170                                                                          ; such as the video ULA, 6845 CRTC and 6522 VIAs (also
0171                                                                          ; known as SHEILA)
0172               
0173               * OSBYTE = &FFF4        \ The address for the OSBYTE routine, which is used
0174                                                                          ; three times in the main game code
0175               
0176               * OSWORD = &FFF1        \ The address for the OSWORD routine, which is used
0177                                                                          ; twice in the main game code
0178               
0179               * OSFILE = &FFDD        \ The address for the OSFILE routine, which is used
0180                                                                          ; once in the main game code
0181               
0182               * ******************************************************************************
0183               *
0184               * Name: ZP
0185               * Type: Workspace
0186               * Address: &0000 to &00B0
0187               * Category: Workspaces
0188               * Summary: Lots of important variables are stored in the zero page workspace
0189               * as it is quicker and more space-efficient to access memory here
0190               *
0191               * ******************************************************************************
0192               
0193                      aorg ZERO_PAGE.
0194               
0195               ZP:
0196 0000                 bss 0                                               ; The start of the zero page workspace
0197               
0198               RAND:
0199 0000                 bss 4                                               ; Four 8-bit seeds for the random number generation
0200                                                                          ; system implemented in the DORND routine
0201               
0202               TRTB.:
0203 0004                 bss 2                                               ; Contains the address of the keyboard translation
0204                                                                          ; table, which is used to translate internal key
0205                                                                          ; numbers to ASCII
0206               
0207               T1:
0208 0006                 bss 1                                               ; Temporary storage, used in a number of places
0209               
0210               SC:
0211 0007                 bss 1                                               ; Screen address (low byte)
0212                                                                          ;
0213                                                                          ; Elite draws on-screen by poking bytes directly into
0214                                                                          ; screen memory, and SC(1 0) is typically set to the
0215                                                                          ; address of the character block containing the pixel
0216                                                                          ; we want to draw (see the deep dives on "Drawing
0217                                                                          ; monochrome pixels in mode 4" and "Drawing colour
0218                                                                          ; pixels in mode 5" for more details)
0219               
0220               SCH:
0221 0008                 bss 1                                               ; Screen address (high byte)
0222               
0223               XX16:
0224 0009                 bss 18                                              ; Temporary storage for a block of values, used in a
0225                                                                          ; number of places
0226               
0227               P:
0228 001B                 bss 3                                               ; Temporary storage, used in a number of places
0229               
0230               XX0:
0231 001E                 bss 2                                               ; Temporary storage, used to store the address of a ship
0232                                                                          ; blueprint. For example, it is used when we add a new
0233                                                                          ; ship to the local bubble in routine NWSHP, and it
0234                                                                          ; contains the address of the current ship's blueprint
0235                                                                          ; as we loop through all the nearby ships in the main
0236                                                                          ; flight loop
0237               
0238               INF:
0239 0020                 bss 2                                               ; Temporary storage, typically used for storing the
0240                                                                          ; address of a ship's data block, so it can be copied
0241                                                                          ; to and from the internal workspace at INWK
0242               
0243               V:
0244 0022                 bss 2                                               ; Temporary storage, typically used for storing an
0245                                                                          ; address pointer
0246               
0247               XX:
0248 0024                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0249                                                                          ; x-coordinate
0250               
0251               YY:
0252 0026                 bss 2                                               ; Temporary storage, typically used for storing a 16-bit
0253                                                                          ; y-coordinate
0254               
0255               SUNX:
0256 0028                 bss 2                                               ; The 16-bit x-coordinate of the vertical centre axis
0257                                                                          ; of the sun (which might be off-screen)
0258               
0259               BETA:
0260 002A                 bss 1                                               ; The current pitch angle beta, which is reduced from
0261                                                                          ; JSTY to a sign-magnitude value between -8 and +8
0262                                                                          ;
0263                                                                          ; This describes how fast we are pitching our ship, and
0264                                                                          ; determines how fast the universe pitches around us
0265                                                                          ;
0266                                                                          ; The sign bit is also stored in BET2, while the
0267                                                                          ; opposite sign is stored in BET2+1
0268               
0269               BET1:
0270 002B                 bss 1                                               ; The magnitude of the pitch angle beta, i.e. |beta|,
0271                                                                          ; which is a positive value between 0 and 8
0272               
0273               XC:
0274 002C                 bss 1                                               ; The x-coordinate of the text cursor (i.e. the text
0275                                                                          ; column), which can be from 0 to 32
0276                                                                          ;
0277                                                                          ; A value of 0 denotes the leftmost column and 32 the
0278                                                                          ; rightmost column, but because the top part of the
0279                                                                          ; screen (the space view) has a white border that
0280                                                                          ; clashes with columns 0 and 32, text is only shown
0281                                                                          ; in columns 1-31
0282               
0283               YC:
0284 002D                 bss 1                                               ; The y-coordinate of the text cursor (i.e. the text
0285                                                                          ; row), which can be from 0 to 23
0286                                                                          ;
0287                                                                          ; The screen actually has 31 character rows if you
0288                                                                          ; include the dashboard, but the text printing routines
0289                                                                          ; only work on the top part (the space view), so the
0290                                                                          ; text cursor only goes up to a maximum of 23, the row
0291                                                                          ; just before the screen splits
0292                                                                          ;
0293                                                                          ; A value of 0 denotes the top row, but because the
0294                                                                          ; top part of the screen has a white border that clashes
0295                                                                          ; with row 0, text is always shown at row 1 or greater
0296               
0297               QQ22:
0298 002E                 bss 2                                               ; The two hyperspace countdown counters
0299                                                                          ;
0300                                                                          ; Before a hyperspace jump, both QQ22 and QQ22+1 are
0301                                                                          ; set to 15
0302                                                                          ;
0303                                                                          ; QQ22 is an internal counter that counts down by 1
0304                                                                          ; each time TT102 is called, which happens every
0305                                                                          ; iteration of the main game loop. When it reaches
0306                                                                          ; zero, the on-screen counter in QQ22+1 gets
0307                                                                          ; decremented, and QQ22 gets set to 5 and the countdown
0308                                                                          ; continues (so the first tick of the hyperspace counter
0309                                                                          ; takes 15 iterations to happen, but subsequent ticks
0310                                                                          ; take 5 iterations each)
0311                                                                          ;
0312                                                                          ; QQ22+1 contains the number that's shown on-screen
0313                                                                          ; during the countdown. It counts down from 15 to 1, and
0314                                                                          ; when it hits 0, the hyperspace engines kick in
0315               
0316               ECMA:
0317 0030                 bss 1                                               ; The E.C.M. countdown timer, which determines whether
0318                                                                          ; an E.C.M. system is currently operating:
0319                                                                          ;
0320                                                                          ; * 0 = E.C.M. is off
0321                                                                          ;
0322                                                                          ; * Non-zero = E.C.M. is on and is counting down
0323                                                                          ;
0324                                                                          ; The counter starts at 32 when an E.C.M. is activated,
0325                                                                          ; either by us or by an opponent, and it decreases by 1
0326                                                                          ; in each iteration of the main flight loop until it
0327                                                                          ; reaches zero, at which point the E.C.M. switches off.
0328                                                                          ; Only one E.C.M. can be active at any one time, so
0329                                                                          ; there is only one counter
0330               
0331               XX15:
0332 0031                 bss 0                                               ; Temporary storage, typically used for storing screen
0333                                                                          ; coordinates in line-drawing routines
0334                                                                          ;
0335                                                                          ; There are six bytes of storage, from XX15 TO XX15+5.
0336                                                                          ; The first four bytes have the following aliases:
0337                                                                          ;
0338                                                                          ; X1 = XX15
0339                                                                          ; Y1 = XX15+1
0340                                                                          ; X2 = XX15+2
0341                                                                          ; Y2 = XX15+3
0342                                                                          ;
0343                                                                          ; These are typically used for describing lines in terms
0344                                                                          ; of screen coordinates, i.e. (X1, Y1) to (X2, Y2)
0345                                                                          ;
0346                                                                          ; The last two bytes of XX15 do not have aliases
0347               
0348               X1:
0349 0031                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0350                                                                          ; line-drawing routines
0351               
0352               Y1:
0353 0032                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0354                                                                          ; line-drawing routines
0355               
0356               X2:
0357 0033                 bss 1                                               ; Temporary storage, typically used for x-coordinates in
0358                                                                          ; line-drawing routines
0359               
0360               Y2:
0361 0034                 bss 1                                               ; Temporary storage, typically used for y-coordinates in
0362                                                                          ; line-drawing routines
0363               
0364 0035                 bss 2                                               ; The last two bytes of the XX15 block
0365               
0366               XX12:
0367 0037                 bss 6                                               ; Temporary storage for a block of values, used in a
0368                                                                          ; number of places
0369               
0370               K:
0371 003D                 bss 4                                               ; Temporary storage, used in a number of places
0372               
0373               KL:
0374 0041                 bss 1                                               ; The following bytes implement a key logger that
0375                                                                          ; enables Elite to scan for concurrent key presses of
0376                                                                          ; the primary flight keys, plus a secondary flight key
0377                                                                          ;
0378                                                                          ; See the deep dive on "The key logger" for more details
0379                                                                          ;
0380                                                                          ; If a key is being pressed that is not in the keyboard
0381                                                                          ; table at KYTB, it can be stored here (as seen in
0382                                                                          ; routine DK4, for example)
0383               
0384               KY1:
0385 0042                 bss 1                                               ; "?" is being pressed
0386                                                                          ;
0387                                                                          ; * 0 = no
0388                                                                          ;
0389                                                                          ; * Non-zero = yes
0390               
0391               KY2:
0392 0043                 bss 1                                               ; Space is being pressed
0393                                                                          ;
0394                                                                          ; * 0 = no
0395                                                                          ;
0396                                                                          ; * Non-zero = yes
0397               
0398               KY3:
0399 0044                 bss 1                                               ; "<" is being pressed
0400                                                                          ;
0401                                                                          ; * 0 = no
0402                                                                          ;
0403                                                                          ; * Non-zero = yes
0404               
0405               KY4:
0406 0045                 bss 1                                               ; ">" is being pressed
0407                                                                          ;
0408                                                                          ; * 0 = no
0409                                                                          ;
0410                                                                          ; * Non-zero = yes
0411               
0412               KY5:
0413 0046                 bss 1                                               ; "X" is being pressed
0414                                                                          ;
0415                                                                          ; * 0 = no
0416                                                                          ;
0417                                                                          ; * Non-zero = yes
0418               
0419               KY6:
0420 0047                 bss 1                                               ; "S" is being pressed
0421                                                                          ;
0422                                                                          ; * 0 = no
0423                                                                          ;
0424                                                                          ; * Non-zero = yes
0425               
0426               KY7:
0427 0048                 bss 1                                               ; "A" is being pressed
0428                                                                          ;
0429                                                                          ; * 0 = no
0430                                                                          ;
0431                                                                          ; * Non-zero = yes
0432                                                                          ;
0433                                                                          ; This is also set when the joystick fire button has
0434                                                                          ; been pressed
0435               
0436               KY12:
0437 0049                 bss 1                                               ; TAB is being pressed
0438                                                                          ;
0439                                                                          ; * 0 = no
0440                                                                          ;
0441                                                                          ; * Non-zero = yes
0442               
0443               KY13:
0444 004A                 bss 1                                               ; ESCAPE is being pressed
0445                                                                          ;
0446                                                                          ; * 0 = no
0447                                                                          ;
0448                                                                          ; * Non-zero = yes
0449               
0450               KY14:
0451 004B                 bss 1                                               ; "T" is being pressed
0452                                                                          ;
0453                                                                          ; * 0 = no
0454                                                                          ;
0455                                                                          ; * Non-zero = yes
0456               
0457               KY15:
0458 004C                 bss 1                                               ; "U" is being pressed
0459                                                                          ;
0460                                                                          ; * 0 = no
0461                                                                          ;
0462                                                                          ; * Non-zero = yes
0463               
0464               KY16:
0465 004D                 bss 1                                               ; "M" is being pressed
0466                                                                          ;
0467                                                                          ; * 0 = no
0468                                                                          ;
0469                                                                          ; * Non-zero = yes
0470               
0471               KY17:
0472 004E                 bss 1                                               ; "E" is being pressed
0473                                                                          ;
0474                                                                          ; * 0 = no
0475                                                                          ;
0476                                                                          ; * Non-zero = yes
0477               
0478               KY18:
0479 004F                 bss 1                                               ; "J" is being pressed
0480                                                                          ;
0481                                                                          ; * 0 = no
0482                                                                          ;
0483                                                                          ; * Non-zero = yes
0484               
0485               KY19:
0486 0050                 bss 1                                               ; "C" is being pressed
0487                                                                          ;
0488                                                                          ; * 0 = no
0489                                                                          ;
0490                                                                          ; * Non-zero = yes
0491               
0492               LAS:
0493 0051                 bss 1                                               ; Contains the laser power of the laser fitted to the
0494                                                                          ; current space view (or 0 if there is no laser fitted
0495                                                                          ; to the current view)
0496                                                                          ;
0497                                                                          ; This gets set to bits 0-6 of the laser power byte from
0498                                                                          ; the commander data block, which contains the laser's
0499                                                                          ; power (bit 7 doesn't denote laser power, just whether
0500                                                                          ; or not the laser pulses, so that is not stored here)
0501               
0502               MSTG:
0503 0052                 bss 1                                               ; The current missile lock target
0504                                                                          ;
0505                                                                          ; * &FF = no target
0506                                                                          ;
0507                                                                          ; * 1-12 = the slot number of the ship that our
0508                                                                          ; missile is locked onto
0509               
0510               XX1:
0511 0053                 bss 0                                               ; This is an alias for INWK that is used in the main
0512                                                                          ; ship-drawing routine at LL9
0513               
0514               INWK:
0515 0053                 bss 33                                              ; The zero-page internal workspace for the current ship
0516                                                                          ; data block
0517                                                                          ;
0518                                                                          ; As operations on zero page locations are faster and
0519                                                                          ; have smaller opcodes than operations on the rest of
0520                                                                          ; the addressable memory, Elite tends to store oft-used
0521                                                                          ; data here. A lot of the routines in Elite need to
0522                                                                          ; access and manipulate ship data, so to make this an
0523                                                                          ; efficient exercise, the ship data is first copied from
0524                                                                          ; the ship data blocks at K% into INWK (or, when new
0525                                                                          ; ships are spawned, from the blueprints at XX21). See
0526                                                                          ; the deep dive on "Ship data blocks" for details of
0527                                                                          ; what each of the bytes in the INWK data block
0528                                                                          ; represents
0529               
0530               XX19:
0531 0074                 bss NI. - 33                                        ; XX19(1 0) shares its location with INWK(34 33), which
0532                                                                          ; contains the address of the ship line heap
0533               
0534               LSP:
0535 0077                 bss 1                                               ; The ball line heap pointer, which contains the number
0536                                                                          ; of the first free byte after the end of the LSX2 and
0537                                                                          ; LSY2 heaps (see the deep dive on "The ball line heap"
0538                                                                          ; for details)
0539               
0540               QQ15:
0541 0078                 bss 6                                               ; The three 16-bit seeds for the selected system, i.e.
0542                                                                          ; the one in the crosshairs in the Short-range Chart
0543                                                                          ;
0544                                                                          ; See the deep dives on "Galaxy and system seeds" and
0545                                                                          ; "Twisting the system seeds" for more details
0546               
0547               K5:
0548 007E                 bss 0                                               ; Temporary storage used to store segment coordinates
0549                                                                          ; across successive calls to BLINE, the ball line
0550                                                                          ; routine
0551               
0552               XX18:
0553 007E                 bss 0                                               ; Temporary storage used to store coordinates in the
0554                                                                          ; LL9 ship-drawing routine
0555               
0556               QQ17:
0557 007E                 bss 1                                               ; Contains a number of flags that affect how text tokens
0558                                                                          ; are printed, particularly capitalisation:
0559                                                                          ;
0560                                                                          ; * If all bits are set (255) then text printing is
0561                                                                          ; disabled
0562                                                                          ;
0563                                                                          ; * Bit 7: 0 = ALL CAPS
0564                                                                          ; 1 = Sentence Case, bit 6 determines the
0565                                                                          ; case of the next letter to print
0566                                                                          ;
0567                                                                          ; * Bit 6: 0 = print the next letter in upper case
0568                                                                          ; 1 = print the next letter in lower case
0569                                                                          ;
0570                                                                          ; * Bits 0-5: If any of bits 0-5 are set, print in
0571                                                                          ; lower case
0572                                                                          ;
0573                                                                          ; So:
0574                                                                          ;
0575                                                                          ; * QQ17 = 0 means case is set to ALL CAPS
0576                                                                          ;
0577                                                                          ; * QQ17 = %10000000 means Sentence Case, currently
0578                                                                          ; printing upper case
0579                                                                          ;
0580                                                                          ; * QQ17 = %11000000 means Sentence Case, currently
0581                                                                          ; printing lower case
0582                                                                          ;
0583                                                                          ; * QQ17 = %11111111 means printing is disabled
0584               
0585               QQ19:
0586 007F                 bss 3                                               ; Temporary storage, used in a number of places
0587               
0588               K6:
0589 0082                 bss 5                                               ; Temporary storage, typically used for storing
0590                                                                          ; coordinates during vector calculations
0591               
0592               ALP1:
0593 0087                 bss 1                                               ; Magnitude of the roll angle alpha, i.e. |alpha|,
0594                                                                          ; which is a positive value between 0 and 31
0595               
0596               ALP2:
0597 0088                 bss 2                                               ; Bit 7 of ALP2 = sign of the roll angle in ALPHA
0598                                                                          ;
0599                                                                          ; Bit 7 of ALP2+1 = opposite sign to ALP2 and ALPHA
0600               
0601               BET2:
0602 008A                 bss 2                                               ; Bit 7 of BET2 = sign of the pitch angle in BETA
0603                                                                          ;
0604                                                                          ; Bit 7 of BET2+1 = opposite sign to BET2 and BETA
0605               
0606               DELTA:
0607 008C                 bss 1                                               ; Our current speed, in the range 1-40
0608               
0609               DELT4:
0610 008D                 bss 2                                               ; Our current speed * 64 as a 16-bit value
0611                                                                          ;
0612                                                                          ; This is stored as DELT4(1 0), so the high byte in
0613                                                                          ; DELT4+1 therefore contains our current speed / 4
0614               
0615               U:
0616 008F                 bss 1                                               ; Temporary storage, used in a number of places
0617               
0618               Q:
0619 0090                 bss 1                                               ; Temporary storage, used in a number of places
0620               
0621               R:
0622 0091                 bss 1                                               ; Temporary storage, used in a number of places
0623               
0624               S:
0625 0092                 bss 1                                               ; Temporary storage, used in a number of places
0626               
0627               XSAV:
0628 0093                 bss 1                                               ; Temporary storage for saving the value of the X
0629                                                                          ; register, used in a number of places
0630               
0631               YSAV:
0632 0094                 bss 1                                               ; Temporary storage for saving the value of the Y
0633                                                                          ; register, used in a number of places
0634               
0635               XX17:
0636 0095                 bss 1                                               ; Temporary storage, used in BPRNT to store the number
0637                                                                          ; of characters to print, and as the edge counter in the
0638                                                                          ; main ship-drawing routine
0639               
0640               QQ11:
0641 0096                 bss 1                                               ; The type of the current view:
0642                                                                          ;
0643                                                                          ; 0   = Space view
0644                                                                          ; 1   = Title screen
0645                                                                          ; Get commander name ("@", save/load commander)
0646                                                                          ; In-system jump just arrived ("J")
0647                                                                          ; Data on System screen (red key f6)
0648                                                                          ; Buy Cargo screen (red key f1)
0649                                                                          ; Mis-jump just arrived (witchspace)
0650                                                                          ; 4   = Sell Cargo screen (red key f2)
0651                                                                          ; 6   = Death screen
0652                                                                          ; 8   = Status Mode screen (red key f8)
0653                                                                          ; Inventory screen (red key f9)
0654                                                                          ; 16  = Market Price screen (red key f7)
0655                                                                          ; 32  = Equip Ship screen (red key f3)
0656                                                                          ; 64  = Long-range Chart (red key f4)
0657                                                                          ; 128 = Short-range Chart (red key f5)
0658                                                                          ;
0659                                                                          ; This value is typically set by calling routine TT66
0660               
0661               ZZ:
0662 0097                 bss 1                                               ; Temporary storage, typically used for distance values
0663               
0664               XX13:
0665 0098                 bss 1                                               ; Temporary storage, typically used in the line-drawing
0666                                                                          ; routines
0667               
0668               MCNT:
0669 0099                 bss 1                                               ; The main loop counter
0670                                                                          ;
0671                                                                          ; This counter determines how often certain actions are
0672                                                                          ; performed within the main loop. See the deep dive on
0673                                                                          ; "Scheduling tasks with the main loop counter" for more
0674                                                                          ; details
0675               
0676               DL:
0677 009A                 bss 1                                               ; Vertical sync flag
0678                                                                          ;
0679                                                                          ; DL gets set to 30 every time we reach vertical sync on
0680                                                                          ; the video system, which happens 50 times a second
0681                                                                          ; (50Hz). The WSCAN routine uses this to pause until the
0682                                                                          ; vertical sync, by setting DL to 0 and then monitoring
0683                                                                          ; its value until it changes to 30
0684               
0685               TYPE:
0686 009B                 bss 1                                               ; The current ship type
0687                                                                          ;
0688                                                                          ; This is where we store the current ship type for when
0689                                                                          ; we are iterating through the ships in the local bubble
0690                                                                          ; as part of the main flight loop. See the table at XX21
0691                                                                          ; for information about ship types
0692               
0693               JSTX:
0694 009C                 bss 1                                               ; Our current roll rate
0695                                                                          ;
0696                                                                          ; This value is shown in the dashboard's RL indicator,
0697                                                                          ; and determines the rate at which we are rolling
0698                                                                          ;
0699                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0700                                                                          ; point, so 1 means roll is decreasing at the maximum
0701                                                                          ; rate, 128 means roll is not changing, and 255 means
0702                                                                          ; roll is increasing at the maximum rate
0703                                                                          ;
0704                                                                          ; This value is updated by "<" and ">" key presses, or
0705                                                                          ; if joysticks are enabled, from the joystick. If
0706                                                                          ; keyboard damping is enabled (which it is by default),
0707                                                                          ; the value is slowly moved towards the centre value of
0708                                                                          ; 128 (no roll) if there are no key presses or joystick
0709                                                                          ; movement
0710               
0711               JSTY:
0712 009D                 bss 1                                               ; Our current pitch rate
0713                                                                          ;
0714                                                                          ; This value is shown in the dashboard's DC indicator,
0715                                                                          ; and determines the rate at which we are pitching
0716                                                                          ;
0717                                                                          ; The value ranges from 1 to 255 with 128 as the centre
0718                                                                          ; point, so 1 means pitch is decreasing at the maximum
0719                                                                          ; rate, 128 means pitch is not changing, and 255 means
0720                                                                          ; pitch is increasing at the maximum rate
0721                                                                          ;
0722                                                                          ; This value is updated by "S" and "X" key presses, or
0723                                                                          ; if joysticks are enabled, from the joystick. If
0724                                                                          ; keyboard damping is enabled (which it is by default),
0725                                                                          ; the value is slowly moved towards the centre value of
0726                                                                          ; 128 (no pitch) if there are no key presses or joystick
0727                                                                          ; movement
0728               
0729               ALPHA:
0730 009E                 bss 1                                               ; The current roll angle alpha, which is reduced from
0731                                                                          ; JSTX to a sign-magnitude value between -31 and +31
0732                                                                          ;
0733                                                                          ; This describes how fast we are rolling our ship, and
0734                                                                          ; determines how fast the universe rolls around us
0735                                                                          ;
0736                                                                          ; The sign bit is also stored in ALP2, while the
0737                                                                          ; opposite sign is stored in ALP2+1
0738               
0739               QQ12:
0740 009F                 bss 1                                               ; Our "docked" status
0741                                                                          ;
0742                                                                          ; * 0 = we are not docked
0743                                                                          ;
0744                                                                          ; * &FF = we are docked
0745               
0746               TGT:
0747 00A0                 bss 1                                               ; Temporary storage, typically used as a target value
0748                                                                          ; for counters when drawing explosion clouds and partial
0749                                                                          ; circles
0750               
0751               SWAP:
0752 00A1                 bss 1                                               ; Temporary storage, used to store a flag that records
0753                                                                          ; whether or not we had to swap a line's start and end
0754                                                                          ; coordinates around when clipping the line in routine
0755                                                                          ; LL145 (the flag is used in places like BLINE to swap
0756                                                                          ; them back)
0757               
0758               COL:
0759 00A2                 bss 1                                               ; Temporary storage, used to store colour information
0760                                                                          ; when drawing pixels in the dashboard
0761               
0762               FLAG:
0763 00A3                 bss 1                                               ; A flag that's used to define whether this is the first
0764                                                                          ; call to the ball line routine in BLINE, so it knows
0765                                                                          ; whether to wait for the second call before storing
0766                                                                          ; segment data in the ball line heap
0767               
0768               CNT:
0769 00A4                 bss 1                                               ; Temporary storage, typically used for storing the
0770                                                                          ; number of iterations required when looping
0771               
0772               CNT2:
0773 00A5                 bss 1                                               ; Temporary storage, used in the planet-drawing routine
0774                                                                          ; to store the segment number where the arc of a partial
0775                                                                          ; circle should start
0776               
0777               STP:
0778 00A6                 bss 1                                               ; The step size for drawing circles
0779                                                                          ;
0780                                                                          ; Circles in Elite are split up into 64 points, and the
0781                                                                          ; step size determines how many points to skip with each
0782                                                                          ; straight-line segment, so the smaller the step size,
0783                                                                          ; the smoother the circle. The values used are:
0784                                                                          ;
0785                                                                          ; * 2 for big planets and the circles on the charts
0786                                                                          ; * 4 for medium planets and the launch tunnel
0787                                                                          ; * 8 for small planets and the hyperspace tunnel
0788                                                                          ;
0789                                                                          ; As the step size increases we move from smoother
0790                                                                          ; circles at the top to more polygonal at the bottom.
0791                                                                          ; See the CIRCLE2 routine for more details
0792               
0793               XX4:
0794 00A7                 bss 1                                               ; Temporary storage, used in a number of places
0795               
0796               XX20:
0797 00A8                 bss 1                                               ; Temporary storage, used in a number of places
0798               
0799               XX14:
0800 00A9                 bss 1                                               ; This byte appears to be unused
0801               
0802               RAT:
0803 00AA                 bss 1                                               ; Used to store different signs depending on the current
0804                                                                          ; space view, for use in calculating stardust movement
0805               
0806               RAT2:
0807 00AB                 bss 1                                               ; Temporary storage, used to store the pitch and roll
0808                                                                          ; signs when moving objects and stardust
0809               
0810               K2:
0811 00AC                 bss 4                                               ; Temporary storage, used in a number of places
0812               
0813               * RM: At &00B0 = 176
0814               
0815                      aorg ZERO_PAGE.+>00D1
0816               
0817               T:
0818 00D1                 bss 1                                               ; Temporary storage, used in a number of places
0819               
0820               K3:
0821 00D2                 bss 0                                               ; Temporary storage, used in a number of places
0822               
0823               XX2:
0824 00D2                 bss 14                                              ; Temporary storage, used to store the visibility of the
0825                                                                          ; ship's faces during the ship-drawing routine at LL9
0826               
0827               K4:
0828 00E0                 bss 2                                               ; Temporary storage, used in a number of places
0829               
0830                      ; PRINT "Zero page variables from ", ~ZP, " to ", ~P%
0831               
0832               * ******************************************************************************
0833               *
0834               * Name: XX3
0835               * Type: Workspace
0836               * Address: &0100 to the top of the descending stack
0837               * Category: Workspaces
0838               * Summary: Temporary storage space for complex calculations
0839               *
0840               * ------------------------------------------------------------------------------
0841               *
0842               * Used as heap space for storing temporary data during calculations. Shared with
0843               * the descending 6502 stack, which works down from &01FF.
0844               *
0845               * ******************************************************************************
0846               
0847                      aorg STACK.
0848               
0849               XX3:
0850 0100                 bss 256                                             ; Temporary storage, typically used for storing tables
0851                                                                          ; of values such as screen coordinates or ship data
0852               
0853               * ******************************************************************************
0854               *
0855               * Name: T%
0856               * Type: Workspace
0857               * Address: &0300 to &035F
0858               * Category: Workspaces
0859               * Summary: Current commander data and stardust data blocks
0860               *
0861               * ------------------------------------------------------------------------------
0862               *
0863               * Contains the current commander data (NT% bytes at location TP), and the
0864               * stardust data blocks (NOST bytes at location SX)
0865               *
0866               * ******************************************************************************
0867               
0868                      aorg T.
0869               
0870 0300                 bss 0                                               ; The start of the T% workspace
0871               
0872               TP:
0873 0300                 bss 1                                               ; The current mission status, which is always 0 for the
0874                                                                          ; cassette version of Elite as there are no missions
0875               
0876               QQ0:
0877 0301                 bss 1                                               ; The current system's galactic x-coordinate (0-256)
0878               
0879               QQ1:
0880 0302                 bss 1                                               ; The current system's galactic y-coordinate (0-256)
0881               
0882               QQ21:
0883 0303                 bss 6                                               ; The three 16-bit seeds for the current galaxy
0884                                                                          ;
0885                                                                          ; These seeds define system 0 in the current galaxy, so
0886                                                                          ; they can be used as a starting point to generate all
0887                                                                          ; 256 systems in the galaxy
0888                                                                          ;
0889                                                                          ; Using a galactic hyperdrive rotates each byte to the
0890                                                                          ; left (rolling each byte within itself) to get the
0891                                                                          ; seeds for the next galaxy, so after eight galactic
0892                                                                          ; jumps, the seeds roll around to the first galaxy again
0893                                                                          ;
0894                                                                          ; See the deep dives on "Galaxy and system seeds" and
0895                                                                          ; "Twisting the system seeds" for more details
0896               
0897               CASH:
0898 0309                 bss 4                                               ; Our current cash pot
0899                                                                          ;
0900                                                                          ; The cash stash is stored as a 32-bit unsigned integer,
0901                                                                          ; with the most significant byte in CASH and the least
0902                                                                          ; significant in CASH+3. This is big-endian, which is
0903                                                                          ; the opposite way round to most of the numbers used in
0904                                                                          ; Elite - to use our notation for multi-byte numbers,
0905                                                                          ; the amount of cash is CASH(0 1 2 3)
0906               
0907               QQ14:
0908 030D                 bss 1                                               ; Our current fuel level (0-70)
0909                                                                          ;
0910                                                                          ; The fuel level is stored as the number of light years
0911                                                                          ; multiplied by 10, so QQ14 = 1 represents 0.1 light
0912                                                                          ; years, and the maximum possible value is 70, for 7.0
0913                                                                          ; light years
0914               
0915               COK:
0916 030E                 bss 1                                               ; Flags used to generate the competition code
0917                                                                          ;
0918                                                                          ; See the deep dive on "The competition code" for
0919                                                                          ; details of these flags and how they are used in
0920                                                                          ; generating and decoding the competition code
0921               
0922               GCNT:
0923 030F                 bss 1                                               ; The number of the current galaxy (0-7)
0924                                                                          ;
0925                                                                          ; When this is displayed in-game, 1 is added to the
0926                                                                          ; number, so we start in galaxy 1 in-game, but it's
0927                                                                          ; stored as galaxy 0 internally
0928                                                                          ;
0929                                                                          ; The galaxy number increases by one every time a
0930                                                                          ; galactic hyperdrive is used, and wraps back around to
0931                                                                          ; the start after eight galaxies
0932               
0933               LASER:
0934 0310                 bss 4                                               ; The specifications of the lasers fitted to each of the
0935                                                                          ; four space views:
0936                                                                          ;
0937                                                                          ; * Byte #0 = front view
0938                                                                          ; * Byte #1 = rear view
0939                                                                          ; * Byte #2 = left view
0940                                                                          ; * Byte #3 = right view
0941                                                                          ;
0942                                                                          ; For each of the views:
0943                                                                          ;
0944                                                                          ; * 0 = no laser is fitted to this view
0945                                                                          ;
0946                                                                          ; * Non-zero = a laser is fitted to this view, with
0947                                                                          ; the following specification:
0948                                                                          ;
0949                                                                          ; * Bits 0-6 contain the laser's power
0950                                                                          ;
0951                                                                          ; * Bit 7 determines whether or not the laser pulses
0952                                                                          ; (0 = pulse laser) or is always on (1 = beam
0953                                                                          ; laser)
0954               
0955 0314                 bss 2                                               ; These bytes appear to be unused (they were originally
0956                                                                          ; used for up/down lasers, but they were dropped)
0957               
0958               CRGO:
0959 0316                 bss 1                                               ; Our ship's cargo capacity
0960                                                                          ;
0961                                                                          ; * 22 = standard cargo bay of 20 tonnes
0962                                                                          ;
0963                                                                          ; * 37 = large cargo bay of 35 tonnes
0964                                                                          ;
0965                                                                          ; The value is two greater than the actual capacity to
0966                                                                          ; make the maths in tnpr slightly more efficient
0967               
0968               QQ20:
0969 0317                 bss 17                                              ; The contents of our cargo hold
0970                                                                          ;
0971                                                                          ; The amount of market item X that we have in our hold
0972                                                                          ; can be found in the X-th byte of QQ20. For example:
0973                                                                          ;
0974                                                                          ; * QQ20 contains the amount of food (item 0)
0975                                                                          ;
0976                                                                          ; * QQ20+7 contains the amount of computers (item 7)
0977                                                                          ;
0978                                                                          ; See QQ23 for a list of market item numbers and their
0979                                                                          ; storage units
0980               
0981               ECM:
0982 0328                 bss 1                                               ; E.C.M. system
0983                                                                          ;
0984                                                                          ; * 0 = not fitted
0985                                                                          ;
0986                                                                          ; * &FF = fitted
0987               
0988               BST:
0989 0329                 bss 1                                               ; Fuel scoops (BST stands for "barrel status")
0990                                                                          ;
0991                                                                          ; * 0 = not fitted
0992                                                                          ;
0993                                                                          ; * &FF = fitted
0994               
0995               BOMB:
0996 032A                 bss 1                                               ; Energy bomb
0997                                                                          ;
0998                                                                          ; * 0 = not fitted
0999                                                                          ;
1000                                                                          ; * &7F = fitted
1001               
1002               ENGY:
1003 032B                 bss 1                                               ; Energy unit
1004                                                                          ;
1005                                                                          ; * 0 = not fitted
1006                                                                          ;
1007                                                                          ; * Non-zero = fitted
1008                                                                          ;
1009                                                                          ; The actual value determines the refresh rate of our
1010                                                                          ; energy banks, as they refresh by ENGY+1 each time (so
1011                                                                          ; our ship's energy level goes up by 2 each time if we
1012                                                                          ; have an energy unit fitted, otherwise it goes up by 1)
1013               
1014               DKCMP:
1015 032C                 bss 1                                               ; Docking computer
1016                                                                          ;
1017                                                                          ; * 0 = not fitted
1018                                                                          ;
1019                                                                          ; * &FF = fitted
1020               
1021               GHYP:
1022 032D                 bss 1                                               ; Galactic hyperdrive
1023                                                                          ;
1024                                                                          ; * 0 = not fitted
1025                                                                          ;
1026                                                                          ; * &FF = fitted
1027               
1028               ESCP:
1029 032E                 bss 1                                               ; Escape pod
1030                                                                          ;
1031                                                                          ; * 0 = not fitted
1032                                                                          ;
1033                                                                          ; * &FF = fitted
1034               
1035 032F                 bss 4                                               ; These bytes appear to be unused
1036               
1037               NOMSL:
1038 0333                 bss 1                                               ; The number of missiles we have fitted (0-4)
1039               
1040               FIST:
1041 0334                 bss 1                                               ; Our legal status (FIST stands for "fugitive/innocent
1042                                                                          ; status"):
1043                                                                          ;
1044                                                                          ; * 0 = Clean
1045                                                                          ;
1046                                                                          ; * 1-49 = Offender
1047                                                                          ;
1048                                                                          ; * 50+ = Fugitive
1049                                                                          ;
1050                                                                          ; You get 64 points if you kill a cop, so that's a fast
1051                                                                          ; ticket to fugitive status
1052               
1053               AVL:
1054 0335                 bss 17                                              ; Market availability in the current system
1055                                                                          ;
1056                                                                          ; The available amount of market item X is stored in
1057                                                                          ; the X-th byte of AVL, so for example:
1058                                                                          ;
1059                                                                          ; * AVL contains the amount of food (item 0)
1060                                                                          ;
1061                                                                          ; * AVL+7 contains the amount of computers (item 7)
1062                                                                          ;
1063                                                                          ; See QQ23 for a list of market item numbers and their
1064                                                                          ; storage units, and the deep dive on "Market item
1065                                                                          ; prices and availability" for details of the algorithm
1066                                                                          ; used for calculating each item's availability
1067               
1068               QQ26:
1069 0346                 bss 1                                               ; A random value used to randomise market data
1070                                                                          ;
1071                                                                          ; This value is set to a new random number for each
1072                                                                          ; change of system, so we can add a random factor into
1073                                                                          ; the calculations for market prices (for details of how
1074                                                                          ; this is used, see the deep dive on "Market prices")
1075               
1076               TALLY:
1077 0347                 bss 2                                               ; Our combat rank
1078                                                                          ;
1079                                                                          ; The combat rank is stored as the number of kills, in a
1080                                                                          ; 16-bit number TALLY(1 0) - so the high byte is in
1081                                                                          ; TALLY+1 and the low byte in TALLY
1082                                                                          ;
1083                                                                          ; If the high byte in TALLY+1 is 0 then we have between
1084                                                                          ; 0 and 255 kills, so our rank is Harmless, Mostly
1085                                                                          ; Harmless, Poor, Average or Above Average, according to
1086                                                                          ; the value of the low byte in TALLY:
1087                                                                          ;
1088                                                                          ; Harmless        = %00000000 to %00000011 = 0 to 3
1089                                                                          ; Mostly Harmless = %00000100 to %00000111 = 4 to 7
1090                                                                          ; Poor            = %00001000 to %00001111 = 8 to 15
1091                                                                          ; Average         = %00010000 to %00011111 = 16 to 31
1092                                                                          ; Above Average   = %00100000 to %11111111 = 32 to 255
1093                                                                          ;
1094                                                                          ; If the high byte in TALLY+1 is non-zero then we are
1095                                                                          ; Competent, Dangerous, Deadly or Elite, according to
1096                                                                          ; the high byte in TALLY+1:
1097                                                                          ;
1098                                                                          ; Competent       = 1           = 256 to 511 kills
1099                                                                          ; Dangerous       = 2 to 9      = 512 to 2559 kills
1100                                                                          ; Deadly          = 10 to 24    = 2560 to 6399 kills
1101                                                                          ; Elite           = 25 and up   = 6400 kills and up
1102                                                                          ;
1103                                                                          ; You can see the rating calculation in the STATUS
1104                                                                          ; subroutine
1105               
1106               SVC:
1107 0349                 bss 1                                               ; The save count
1108                                                                          ;
1109                                                                          ; When a new commander is created, the save count gets
1110                                                                          ; set to 128. This value gets halved each time the
1111                                                                          ; commander file is saved, but it is otherwise unused.
1112                                                                          ; It is presumably part of the security system for the
1113                                                                          ; competition, possibly another flag to catch out
1114                                                                          ; entries with manually altered commander files
1115               
1116 034A                 bss 2                                               ; The commander file checksum
1117                                                                          ;
1118                                                                          ; These two bytes are reserved for the commander file
1119                                                                          ; checksum, so when the current commander block is
1120                                                                          ; copied from here to the last saved commander block at
1121                                                                          ; NA%, CHK and CHK2 get overwritten
1122               
1123               NT.:                                                       ; This sets the variable NT% to the size of the current
1124                      equ SVC + 2 - TP
1125                                                                          ; commander data block, which starts at TP and ends at
1126                                                                          ; SVC+2 (inclusive)
1127               
1128               SX:
1129 034C                 bss NOST + 1                                        ; This is where we store the x_hi coordinates for all
1130                                                                          ; the stardust particles
1131               
1132               SXL:
1133 035F                 bss NOST + 1                                        ; This is where we store the x_lo coordinates for all
1134                                                                          ; the stardust particles
1135               
1136                      ; PRINT "T% workspace from  ", ~T%, " to ", ~P%
1137               
1138               * ******************************************************************************
1139               *
1140               * ELITE RECURSIVE TEXT TOKEN FILE
1141               *
1142               * Produces the binary file WORDS9.bin that gets loaded by elite-loader.asm.
1143               *
1144               * The recursive token table is loaded at &1100 and is moved down to &0400 as
1145               * part of elite-loader.asm, so it ends up at &0400 to &07FF.
1146               *
1147               * ******************************************************************************
1148               
1149                      aorg CODE_WORDS.
1150               
1151               * ******************************************************************************
1152               *
1153               * Name: CHAR
1154               * Type: Macro
1155               * Category: Text
1156               * Summary: Macro definition for characters in the recursive token table
1157               * Deep dive: Printing text tokens
1158               *
1159               * ------------------------------------------------------------------------------
1160               *
1161               * The following macro is used when building the recursive token table:
1162               *
1163               * CHAR 'x'            Insert ASCII character "x"
1164               *
1165               * To include an apostrophe, use a backtick character, as in CHAR '`'.
1166               *
1167               * See the deep dive on "Printing text tokens" for details on how characters are
1168               * stored in the recursive token table.
1169               *
1170               * ------------------------------------------------------------------------------
1171               *
1172               * Arguments:
1173               *
1174               * 'x'                 The character to insert into the table
1175               *
1176               * ******************************************************************************
1177               
1178                      ; MACRO CHAR x
1179               
1180                      ; IF x = '`'                    ;
1181                      ; EQUB 39 EOR RE                ;
1182                      ; ELSE                          ;
1183                      ; EQUB x EOR RE                 ;
1184                      ; ENDIF                         ;
1185               
1186                      ; ENDMACRO
1187               
1188               * ******************************************************************************
1189               *
1190               * Name: TWOK
1191               * Type: Macro
1192               * Category: Text
1193               * Summary: Macro definition for two-letter tokens in the token table
1194               * Deep dive: Printing text tokens
1195               *
1196               * ------------------------------------------------------------------------------
1197               *
1198               * The following macro is used when building the recursive token table:
1199               *
1200               * TWOK 'x', 'y'       Insert two-letter token "xy"
1201               *
1202               * See the deep dive on "Printing text tokens" for details on how two-letter
1203               * tokens are stored in the recursive token table.
1204               *
1205               * ------------------------------------------------------------------------------
1206               *
1207               * Arguments:
1208               *
1209               * 'x'                 The first letter of the two-letter token to insert into
1210               * the table
1211               *
1212               * 'y'                 The second letter of the two-letter token to insert into
1213               * the table
1214               *
1215               * ******************************************************************************
1216               
1217                      ; MACRO TWOK t, k
1218               
1219                      ; IF t = 'A' AND k = 'L' : EQUB 128 EOR RE : ENDIF ;
1220                      ; IF t = 'L' AND k = 'E' : EQUB 129 EOR RE : ENDIF ;
1221                      ; IF t = 'X' AND k = 'E' : EQUB 130 EOR RE : ENDIF ;
1222                      ; IF t = 'G' AND k = 'E' : EQUB 131 EOR RE : ENDIF ;
1223                      ; IF t = 'Z' AND k = 'A' : EQUB 132 EOR RE : ENDIF ;
1224                      ; IF t = 'C' AND k = 'E' : EQUB 133 EOR RE : ENDIF ;
1225                      ; IF t = 'B' AND k = 'I' : EQUB 134 EOR RE : ENDIF ;
1226                      ; IF t = 'S' AND k = 'O' : EQUB 135 EOR RE : ENDIF ;
1227                      ; IF t = 'U' AND k = 'S' : EQUB 136 EOR RE : ENDIF ;
1228                      ; IF t = 'E' AND k = 'S' : EQUB 137 EOR RE : ENDIF ;
1229                      ; IF t = 'A' AND k = 'R' : EQUB 138 EOR RE : ENDIF ;
1230                      ; IF t = 'M' AND k = 'A' : EQUB 139 EOR RE : ENDIF ;
1231                      ; IF t = 'I' AND k = 'N' : EQUB 140 EOR RE : ENDIF ;
1232                      ; IF t = 'D' AND k = 'I' : EQUB 141 EOR RE : ENDIF ;
1233                      ; IF t = 'R' AND k = 'E' : EQUB 142 EOR RE : ENDIF ;
1234                      ; IF t = 'A' AND k = '?' : EQUB 143 EOR RE : ENDIF ;
1235                      ; IF t = 'E' AND k = 'R' : EQUB 144 EOR RE : ENDIF ;
1236                      ; IF t = 'A' AND k = 'T' : EQUB 145 EOR RE : ENDIF ;
1237                      ; IF t = 'E' AND k = 'N' : EQUB 146 EOR RE : ENDIF ;
1238                      ; IF t = 'B' AND k = 'E' : EQUB 147 EOR RE : ENDIF ;
1239                      ; IF t = 'R' AND k = 'A' : EQUB 148 EOR RE : ENDIF ;
1240                      ; IF t = 'L' AND k = 'A' : EQUB 149 EOR RE : ENDIF ;
1241                      ; IF t = 'V' AND k = 'E' : EQUB 150 EOR RE : ENDIF ;
1242                      ; IF t = 'T' AND k = 'I' : EQUB 151 EOR RE : ENDIF ;
1243                      ; IF t = 'E' AND k = 'D' : EQUB 152 EOR RE : ENDIF ;
1244                      ; IF t = 'O' AND k = 'R' : EQUB 153 EOR RE : ENDIF ;
1245                      ; IF t = 'Q' AND k = 'U' : EQUB 154 EOR RE : ENDIF ;
1246                      ; IF t = 'A' AND k = 'N' : EQUB 155 EOR RE : ENDIF ;
1247                      ; IF t = 'T' AND k = 'E' : EQUB 156 EOR RE : ENDIF ;
1248                      ; IF t = 'I' AND k = 'S' : EQUB 157 EOR RE : ENDIF ;
1249                      ; IF t = 'R' AND k = 'I' : EQUB 158 EOR RE : ENDIF ;
1250                      ; IF t = 'O' AND k = 'N' : EQUB 159 EOR RE : ENDIF ;
1251               
1252                      ; ENDMACRO
1253               
1254               * ******************************************************************************
1255               *
1256               * Name: CONT
1257               * Type: Macro
1258               * Category: Text
1259               * Summary: Macro definition for control codes in the recursive token table
1260               * Deep dive: Printing text tokens
1261               *
1262               * ------------------------------------------------------------------------------
1263               *
1264               * The following macro is used when building the recursive token table:
1265               *
1266               * CONT n              Insert control code token {n}
1267               *
1268               * See the deep dive on "Printing text tokens" for details on how characters are
1269               * stored in the recursive token table.
1270               *
1271               * ------------------------------------------------------------------------------
1272               *
1273               * Arguments:
1274               *
1275               * n                   The control code to insert into the table
1276               *
1277               * ******************************************************************************
1278               
1279                      ; MACRO CONT n
1280               
1281                      ; EQUB n EOR RE                 ;
1282               
1283                      ; ENDMACRO
1284               
1285               * ******************************************************************************
1286               *
1287               * Name: RTOK
1288               * Type: Macro
1289               * Category: Text
1290               * Summary: Macro definition for recursive tokens in the recursive token table
1291               * Deep dive: Printing text tokens
1292               *
1293               * ------------------------------------------------------------------------------
1294               *
1295               * The following macro is used when building the recursive token table:
1296               *
1297               * RTOK n              Insert recursive token [n]
1298               *
1299               * * Tokens 0-95 get stored as n + 160
1300               *
1301               * * Tokens 128-145 get stored as n - 114
1302               *
1303               * * Tokens 96-127 get stored as n
1304               *
1305               * See the deep dive on "Printing text tokens" for details on how recursive
1306               * tokens are stored in the recursive token table.
1307               *
1308               * ------------------------------------------------------------------------------
1309               *
1310               * Arguments:
1311               *
1312               * n                   The number of the recursive token to insert into the
1313               * table, in the range 0 to 145
1314               *
1315               * ******************************************************************************
1316               
1317                      ; MACRO RTOK n
1318               
1319                      ; IF n >= 0 AND n <= 95         ;
1320                      ; t = n + 160                   ;
1321                      ; ELIF n >= 128                 ;
1322                      ; t = n - 114                   ;
1323                      ; ELSE                          ;
1324                      ; t = n                         ;
1325                      ; ENDIF                         ;
1326               
1327                      ; EQUB t EOR RE                 ;
1328               
1329                      ; ENDMACRO
1330               
1331               * ******************************************************************************
1332               *
1333               * Name: QQ18
1334               * Type: Variable
1335               * Category: Text
1336               * Summary: The recursive token table for tokens 0-148
1337               * Deep dive: Printing text tokens
1338               *
1339               * ******************************************************************************
1340               
1341               QQ18:
1342                      .rtok 111                                           ; Token 0:      "FUEL SCOOPS ON {beep}"
     **** ****     > RTOK
0008 0400 4C              byte 111 ^ RE
                   < elite.a99
1343                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0401   32            byte (131 - 114) ^ RE
                   < elite.a99
1344                      .cont 7                                             ; Encoded as:   "[111][131]{7}"
     **** ****     > CONT
0001 0402 24              byte 7 ^ RE
                   < elite.a99
1345 0403   00            byte >00
1346               
1347                      .char ' '                                           ; Token 1:      " CHART"
     **** ****     > CHAR
0004 0404 03              byte ' ' ^ RE
                   < elite.a99
1348                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0405   60            byte 'C' ^ RE
                   < elite.a99
1349                      .char 'H'                                           ; Encoded as:   " CH<138>T"
     **** ****     > CHAR
0004 0406 6B              byte 'H' ^ RE
                   < elite.a99
1350 0407   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1351                      .char 'T'
     **** ****     > CHAR
0004 0408 77              byte 'T' ^ RE
                   < elite.a99
1352 0409   00            byte >00
1353               
1354                      .char 'G'                                           ; Token 2:      "GOVERNMENT"
     **** ****     > CHAR
0004 040A 64              byte 'G' ^ RE
                   < elite.a99
1355                      .char 'O'                                           ;
     **** ****     > CHAR
0004 040B   6C            byte 'O' ^ RE
                   < elite.a99
1356 040C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "GO<150>RNM<146>T"
1357                      .char 'R'
     **** ****     > CHAR
0004 040D   71            byte 'R' ^ RE
                   < elite.a99
1358                      .char 'N'
     **** ****     > CHAR
0004 040E 6D              byte 'N' ^ RE
                   < elite.a99
1359                      .char 'M'
     **** ****     > CHAR
0004 040F   6E            byte 'M' ^ RE
                   < elite.a99
1360 0410 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1361                      .char 'T'
     **** ****     > CHAR
0004 0411   77            byte 'T' ^ RE
                   < elite.a99
1362 0412 00              byte >00
1363               
1364                      .char 'D'                                           ; Token 3:      "DATA ON {selected system name}"
     **** ****     > CHAR
0004 0413   67            byte 'D' ^ RE
                   < elite.a99
1365 0414 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T'
1366                      .char 'A'                                           ; Encoded as:   "D<145>A[131]{3}"
     **** ****     > CHAR
0004 0415   62            byte 'A' ^ RE
                   < elite.a99
1367                      .rtok 131
     **** ****     > RTOK
0006 0416 32              byte (131 - 114) ^ RE
                   < elite.a99
1368                      .cont 3
     **** ****     > CONT
0001 0417   20            byte 3 ^ RE
                   < elite.a99
1369 0418 00              byte >00
1370               
1371 0419   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 4:      "INVENTORY{crlf}
1372 041A B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' "
1373                      .char 'N'                                           ;
     **** ****     > CHAR
0004 041B   6D            byte 'N' ^ RE
                   < elite.a99
1374                      .char 'T'                                           ; Encoded as:   "<140><150>NT<153>Y{13}"
     **** ****     > CHAR
0004 041C 77              byte 'T' ^ RE
                   < elite.a99
1375 041D   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1376                      .char 'Y'
     **** ****     > CHAR
0004 041E 7A              byte 'Y' ^ RE
                   < elite.a99
1377                      .cont 13
     **** ****     > CONT
0001 041F   2E            byte 13 ^ RE
                   < elite.a99
1378 0420 00              byte >00
1379               
1380                      .char 'S'                                           ; Token 5:      "SYSTEM"
     **** ****     > CHAR
0004 0421   70            byte 'S' ^ RE
                   < elite.a99
1381                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0422 7A              byte 'Y' ^ RE
                   < elite.a99
1382                      .char 'S'                                           ; Encoded as:   "SYS<156>M"
     **** ****     > CHAR
0004 0423   70            byte 'S' ^ RE
                   < elite.a99
1383 0424 BF              byte 156 ^ RE                                       ; TWOK 'T', 'E' null
1384                      .char 'M'
     **** ****     > CHAR
0004 0425   6E            byte 'M' ^ RE
                   < elite.a99
1385 0426 00              byte >00
1386               
1387                      .char 'P'                                           ; Token 6:      "PRICE"
     **** ****     > CHAR
0004 0427   73            byte 'P' ^ RE
                   < elite.a99
1388 0428 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I'
1389 0429   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' Encoded as:   "P<158><133>"
1390 042A 00              byte >00
1391               
1392                      .cont 2                                             ; Token 7:      "{current system name} MARKET PRICES"
     **** ****     > CONT
0001 042B   21            byte 2 ^ RE
                   < elite.a99
1393                      .char ' '                                           ;
     **** ****     > CHAR
0004 042C 03              byte ' ' ^ RE
                   < elite.a99
1394 042D   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A' Encoded as:   "{2} <139>RKET [6]S"
1395                      .char 'R'
     **** ****     > CHAR
0004 042E 71              byte 'R' ^ RE
                   < elite.a99
1396                      .char 'K'
     **** ****     > CHAR
0004 042F   68            byte 'K' ^ RE
                   < elite.a99
1397                      .char 'E'
     **** ****     > CHAR
0004 0430 66              byte 'E' ^ RE
                   < elite.a99
1398                      .char 'T'
     **** ****     > CHAR
0004 0431   77            byte 'T' ^ RE
                   < elite.a99
1399                      .char ' '
     **** ****     > CHAR
0004 0432 03              byte ' ' ^ RE
                   < elite.a99
1400                      .rtok 6
     **** ****     > RTOK
0003 0433   85            byte (6 + 160) ^ RE
                   < elite.a99
1401                      .char 'S'
     **** ****     > CHAR
0004 0434 70              byte 'S' ^ RE
                   < elite.a99
1402 0435   00            byte >00
1403               
1404 0436 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 8:      "INDUSTRIAL"
1405                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0437   67            byte 'D' ^ RE
                   < elite.a99
1406 0438 AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' Encoded as:   "<140>D<136>T<158><128>"
1407                      .char 'T'
     **** ****     > CHAR
0004 0439   77            byte 'T' ^ RE
                   < elite.a99
1408 043A BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1409 043B   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1410 043C 00              byte >00
1411               
1412                      .char 'A'                                           ; Token 9:      "AGRICULTURAL"
     **** ****     > CHAR
0004 043D   62            byte 'A' ^ RE
                   < elite.a99
1413                      .char 'G'                                           ;
     **** ****     > CHAR
0004 043E 64              byte 'G' ^ RE
                   < elite.a99
1414 043F   BD            byte 158 ^ RE                                       ; TWOK 'R', 'I' Encoded as:   "AG<158>CULTU<148>L"
1415                      .char 'C'
     **** ****     > CHAR
0004 0440 60              byte 'C' ^ RE
                   < elite.a99
1416                      .char 'U'
     **** ****     > CHAR
0004 0441   76            byte 'U' ^ RE
                   < elite.a99
1417                      .char 'L'
     **** ****     > CHAR
0004 0442 6F              byte 'L' ^ RE
                   < elite.a99
1418                      .char 'T'
     **** ****     > CHAR
0004 0443   77            byte 'T' ^ RE
                   < elite.a99
1419                      .char 'U'
     **** ****     > CHAR
0004 0444 76              byte 'U' ^ RE
                   < elite.a99
1420 0445   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1421                      .char 'L'
     **** ****     > CHAR
0004 0446 6F              byte 'L' ^ RE
                   < elite.a99
1422 0447   00            byte >00
1423               
1424 0448 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 10:     "RICH "
1425                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0449   60            byte 'C' ^ RE
                   < elite.a99
1426                      .char 'H'                                           ; Encoded as:   "<158>CH "
     **** ****     > CHAR
0004 044A 6B              byte 'H' ^ RE
                   < elite.a99
1427                      .char ' '
     **** ****     > CHAR
0004 044B   03            byte ' ' ^ RE
                   < elite.a99
1428 044C 00              byte >00
1429               
1430                      .char 'A'                                           ; Token 11:     "AVERAGE "
     **** ****     > CHAR
0004 044D   62            byte 'A' ^ RE
                   < elite.a99
1431 044E B5              byte 150 ^ RE                                       ; TWOK 'V', 'E'
1432 044F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Encoded as:   "A<150><148><131> "
1433 0450 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' null
1434                      .char ' '
     **** ****     > CHAR
0004 0451   03            byte ' ' ^ RE
                   < elite.a99
1435 0452 00              byte >00
1436               
1437                      .char 'P'                                           ; Token 12:     "POOR "
     **** ****     > CHAR
0004 0453   73            byte 'P' ^ RE
                   < elite.a99
1438                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0454 6C              byte 'O' ^ RE
                   < elite.a99
1439 0455   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "PO<153> "
1440                      .char ' '
     **** ****     > CHAR
0004 0456 03              byte ' ' ^ RE
                   < elite.a99
1441 0457   00            byte >00
1442               
1443 0458 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 13:     "MAINLY "
1444 0459   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1445                      .char 'L'                                           ; Encoded as:   "<139><140>LY "
     **** ****     > CHAR
0004 045A 6F              byte 'L' ^ RE
                   < elite.a99
1446                      .char 'Y'
     **** ****     > CHAR
0004 045B   7A            byte 'Y' ^ RE
                   < elite.a99
1447                      .char ' '
     **** ****     > CHAR
0004 045C 03              byte ' ' ^ RE
                   < elite.a99
1448 045D   00            byte >00
1449               
1450                      .char 'U'                                           ; Token 14:     "UNIT"
     **** ****     > CHAR
0004 045E 76              byte 'U' ^ RE
                   < elite.a99
1451                      .char 'N'                                           ;
     **** ****     > CHAR
0004 045F   6D            byte 'N' ^ RE
                   < elite.a99
1452                      .char 'I'                                           ; Encoded as:   "UNIT"
     **** ****     > CHAR
0004 0460 6A              byte 'I' ^ RE
                   < elite.a99
1453                      .char 'T'
     **** ****     > CHAR
0004 0461   77            byte 'T' ^ RE
                   < elite.a99
1454 0462 00              byte >00
1455               
1456                      .char 'V'                                           ; Token 15:     "VIEW "
     **** ****     > CHAR
0004 0463   75            byte 'V' ^ RE
                   < elite.a99
1457                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0464 6A              byte 'I' ^ RE
                   < elite.a99
1458                      .char 'E'                                           ; Encoded as:   "VIEW "
     **** ****     > CHAR
0004 0465   66            byte 'E' ^ RE
                   < elite.a99
1459                      .char 'W'
     **** ****     > CHAR
0004 0466 74              byte 'W' ^ RE
                   < elite.a99
1460                      .char ' '
     **** ****     > CHAR
0004 0467   03            byte ' ' ^ RE
                   < elite.a99
1461 0468 00              byte >00
1462               
1463 0469   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Token 16:     "QUANTITY"
1464 046A B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1465 046B   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<154><155><151>TY"
1466                      .char 'T'
     **** ****     > CHAR
0004 046C 77              byte 'T' ^ RE
                   < elite.a99
1467                      .char 'Y'
     **** ****     > CHAR
0004 046D   7A            byte 'Y' ^ RE
                   < elite.a99
1468 046E 00              byte >00
1469               
1470 046F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Token 17:     "ANARCHY"
1471 0470 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1472                      .char 'C'                                           ; Encoded as:   "<155><138>CHY"
     **** ****     > CHAR
0004 0471   60            byte 'C' ^ RE
                   < elite.a99
1473                      .char 'H'
     **** ****     > CHAR
0004 0472 6B              byte 'H' ^ RE
                   < elite.a99
1474                      .char 'Y'
     **** ****     > CHAR
0004 0473   7A            byte 'Y' ^ RE
                   < elite.a99
1475 0474 00              byte >00
1476               
1477                      .char 'F'                                           ; Token 18:     "FEUDAL"
     **** ****     > CHAR
0004 0475   65            byte 'F' ^ RE
                   < elite.a99
1478                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0476 66              byte 'E' ^ RE
                   < elite.a99
1479                      .char 'U'                                           ; Encoded as:   "FEUD<128>"
     **** ****     > CHAR
0004 0477   76            byte 'U' ^ RE
                   < elite.a99
1480                      .char 'D'
     **** ****     > CHAR
0004 0478 67              byte 'D' ^ RE
                   < elite.a99
1481 0479   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1482 047A 00              byte >00
1483               
1484                      .char 'M'                                           ; Token 19:     "MULTI-GOVERNMENT"
     **** ****     > CHAR
0004 047B   6E            byte 'M' ^ RE
                   < elite.a99
1485                      .char 'U'                                           ;
     **** ****     > CHAR
0004 047C 76              byte 'U' ^ RE
                   < elite.a99
1486                      .char 'L'                                           ; Encoded as:   "MUL<151>-[2]"
     **** ****     > CHAR
0004 047D   6F            byte 'L' ^ RE
                   < elite.a99
1487 047E B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1488                      .char '-'
     **** ****     > CHAR
0004 047F   0E            byte '-' ^ RE
                   < elite.a99
1489                      .rtok 2
     **** ****     > RTOK
0003 0480 81              byte (2 + 160) ^ RE
                   < elite.a99
1490 0481   00            byte >00
1491               
1492 0482 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 20:     "DICTATORSHIP"
1493                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0483   60            byte 'C' ^ RE
                   < elite.a99
1494                      .char 'T'                                           ; Encoded as:   "<141>CT<145><153>[25]"
     **** ****     > CHAR
0004 0484 77              byte 'T' ^ RE
                   < elite.a99
1495 0485   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1496 0486 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1497                      .rtok 25
     **** ****     > RTOK
0003 0487   9A            byte (25 + 160) ^ RE
                   < elite.a99
1498 0488 00              byte >00
1499               
1500                      .rtok 91                                            ; Token 21:     "COMMUNIST"
     **** ****     > RTOK
0003 0489   D8            byte (91 + 160) ^ RE
                   < elite.a99
1501                      .char 'M'                                           ;
     **** ****     > CHAR
0004 048A 6E              byte 'M' ^ RE
                   < elite.a99
1502                      .char 'U'                                           ; Encoded as:   "[91]MUN<157>T"
     **** ****     > CHAR
0004 048B   76            byte 'U' ^ RE
                   < elite.a99
1503                      .char 'N'
     **** ****     > CHAR
0004 048C 6D              byte 'N' ^ RE
                   < elite.a99
1504 048D   BE            byte 157 ^ RE                                       ; TWOK 'I', 'S' null
1505                      .char 'T'
     **** ****     > CHAR
0004 048E 77              byte 'T' ^ RE
                   < elite.a99
1506 048F   00            byte >00
1507               
1508                      .char 'C'                                           ; Token 22:     "CONFEDERACY"
     **** ****     > CHAR
0004 0490 60              byte 'C' ^ RE
                   < elite.a99
1509 0491   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1510                      .char 'F'                                           ; Encoded as:   "C<159>F<152><144>ACY"
     **** ****     > CHAR
0004 0492 65              byte 'F' ^ RE
                   < elite.a99
1511 0493   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1512 0494 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1513                      .char 'A'
     **** ****     > CHAR
0004 0495   62            byte 'A' ^ RE
                   < elite.a99
1514                      .char 'C'
     **** ****     > CHAR
0004 0496 60              byte 'C' ^ RE
                   < elite.a99
1515                      .char 'Y'
     **** ****     > CHAR
0004 0497   7A            byte 'Y' ^ RE
                   < elite.a99
1516 0498 00              byte >00
1517               
1518                      .char 'D'                                           ; Token 23:     "DEMOCRACY"
     **** ****     > CHAR
0004 0499   67            byte 'D' ^ RE
                   < elite.a99
1519                      .char 'E'                                           ;
     **** ****     > CHAR
0004 049A 66              byte 'E' ^ RE
                   < elite.a99
1520                      .char 'M'                                           ; Encoded as:   "DEMOC<148>CY"
     **** ****     > CHAR
0004 049B   6E            byte 'M' ^ RE
                   < elite.a99
1521                      .char 'O'
     **** ****     > CHAR
0004 049C 6C              byte 'O' ^ RE
                   < elite.a99
1522                      .char 'C'
     **** ****     > CHAR
0004 049D   60            byte 'C' ^ RE
                   < elite.a99
1523 049E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
1524                      .char 'C'
     **** ****     > CHAR
0004 049F   60            byte 'C' ^ RE
                   < elite.a99
1525                      .char 'Y'
     **** ****     > CHAR
0004 04A0 7A              byte 'Y' ^ RE
                   < elite.a99
1526 04A1   00            byte >00
1527               
1528                      .char 'C'                                           ; Token 24:     "CORPORATE STATE"
     **** ****     > CHAR
0004 04A2 60              byte 'C' ^ RE
                   < elite.a99
1529 04A3   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R'
1530                      .char 'P'                                           ; Encoded as:   "C<153>P<153><145>E [43]<145>E"
     **** ****     > CHAR
0004 04A4 73              byte 'P' ^ RE
                   < elite.a99
1531 04A5   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1532 04A6 B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1533                      .char 'E'
     **** ****     > CHAR
0004 04A7   66            byte 'E' ^ RE
                   < elite.a99
1534                      .char ' '
     **** ****     > CHAR
0004 04A8 03              byte ' ' ^ RE
                   < elite.a99
1535                      .rtok 43
     **** ****     > RTOK
0003 04A9   E8            byte (43 + 160) ^ RE
                   < elite.a99
1536 04AA B2              byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1537                      .char 'E'
     **** ****     > CHAR
0004 04AB   66            byte 'E' ^ RE
                   < elite.a99
1538 04AC 00              byte >00
1539               
1540                      .char 'S'                                           ; Token 25:     "SHIP"
     **** ****     > CHAR
0004 04AD   70            byte 'S' ^ RE
                   < elite.a99
1541                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04AE 6B              byte 'H' ^ RE
                   < elite.a99
1542                      .char 'I'                                           ; Encoded as:   "SHIP"
     **** ****     > CHAR
0004 04AF   6A            byte 'I' ^ RE
                   < elite.a99
1543                      .char 'P'
     **** ****     > CHAR
0004 04B0 73              byte 'P' ^ RE
                   < elite.a99
1544 04B1   00            byte >00
1545               
1546                      .char 'P'                                           ; Token 26:     "PRODUCT"
     **** ****     > CHAR
0004 04B2 73              byte 'P' ^ RE
                   < elite.a99
1547                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04B3   71            byte 'R' ^ RE
                   < elite.a99
1548                      .char 'O'                                           ; Encoded as:   "PRODUCT"
     **** ****     > CHAR
0004 04B4 6C              byte 'O' ^ RE
                   < elite.a99
1549                      .char 'D'
     **** ****     > CHAR
0004 04B5   67            byte 'D' ^ RE
                   < elite.a99
1550                      .char 'U'
     **** ****     > CHAR
0004 04B6 76              byte 'U' ^ RE
                   < elite.a99
1551                      .char 'C'
     **** ****     > CHAR
0004 04B7   60            byte 'C' ^ RE
                   < elite.a99
1552                      .char 'T'
     **** ****     > CHAR
0004 04B8 77              byte 'T' ^ RE
                   < elite.a99
1553 04B9   00            byte >00
1554               
1555                      .char ' '                                           ; Token 27:     " LASER"
     **** ****     > CHAR
0004 04BA 03              byte ' ' ^ RE
                   < elite.a99
1556 04BB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1557                      .char 'S'                                           ; Encoded as:   " <149>S<144>"
     **** ****     > CHAR
0004 04BC 70              byte 'S' ^ RE
                   < elite.a99
1558 04BD   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1559 04BE 00              byte >00
1560               
1561                      .char 'H'                                           ; Token 28:     "HUMAN COLONIAL"
     **** ****     > CHAR
0004 04BF   6B            byte 'H' ^ RE
                   < elite.a99
1562                      .char 'U'                                           ;
     **** ****     > CHAR
0004 04C0 76              byte 'U' ^ RE
                   < elite.a99
1563                      .char 'M'                                           ; Encoded as:   "HUM<155> COL<159>I<128>"
     **** ****     > CHAR
0004 04C1   6E            byte 'M' ^ RE
                   < elite.a99
1564 04C2 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1565                      .char ' '
     **** ****     > CHAR
0004 04C3   03            byte ' ' ^ RE
                   < elite.a99
1566                      .char 'C'
     **** ****     > CHAR
0004 04C4 60              byte 'C' ^ RE
                   < elite.a99
1567                      .char 'O'
     **** ****     > CHAR
0004 04C5   6C            byte 'O' ^ RE
                   < elite.a99
1568                      .char 'L'
     **** ****     > CHAR
0004 04C6 6F              byte 'L' ^ RE
                   < elite.a99
1569 04C7   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1570                      .char 'I'
     **** ****     > CHAR
0004 04C8 6A              byte 'I' ^ RE
                   < elite.a99
1571 04C9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1572 04CA 00              byte >00
1573               
1574                      .char 'H'                                           ; Token 29:     "HYPERSPACE "
     **** ****     > CHAR
0004 04CB   6B            byte 'H' ^ RE
                   < elite.a99
1575                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 04CC 7A              byte 'Y' ^ RE
                   < elite.a99
1576                      .char 'P'                                           ; Encoded as:   "HYP<144>SPA<133> "
     **** ****     > CHAR
0004 04CD   73            byte 'P' ^ RE
                   < elite.a99
1577 04CE B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1578                      .char 'S'
     **** ****     > CHAR
0004 04CF   70            byte 'S' ^ RE
                   < elite.a99
1579                      .char 'P'
     **** ****     > CHAR
0004 04D0 73              byte 'P' ^ RE
                   < elite.a99
1580                      .char 'A'
     **** ****     > CHAR
0004 04D1   62            byte 'A' ^ RE
                   < elite.a99
1581 04D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1582                      .char ' '
     **** ****     > CHAR
0004 04D3   03            byte ' ' ^ RE
                   < elite.a99
1583 04D4 00              byte >00
1584               
1585                      .char 'S'                                           ; Token 30:     "SHORT RANGE CHART"
     **** ****     > CHAR
0004 04D5   70            byte 'S' ^ RE
                   < elite.a99
1586                      .char 'H'                                           ;
     **** ****     > CHAR
0004 04D6 6B              byte 'H' ^ RE
                   < elite.a99
1587 04D7   BA            byte 153 ^ RE                                       ; TWOK 'O', 'R' Encoded as:   "SH<153>T [42][1]"
1588                      .char 'T'
     **** ****     > CHAR
0004 04D8 77              byte 'T' ^ RE
                   < elite.a99
1589                      .char ' '
     **** ****     > CHAR
0004 04D9   03            byte ' ' ^ RE
                   < elite.a99
1590                      .rtok 42
     **** ****     > RTOK
0003 04DA E9              byte (42 + 160) ^ RE
                   < elite.a99
1591                      .rtok 1
     **** ****     > RTOK
0003 04DB   82            byte (1 + 160) ^ RE
                   < elite.a99
1592 04DC 00              byte >00
1593               
1594 04DD   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' Token 31:     "DISTANCE"
1595                      .rtok 43                                            ;
     **** ****     > RTOK
0003 04DE E8              byte (43 + 160) ^ RE
                   < elite.a99
1596 04DF   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "<141>[43]<155><133>"
1597 04E0 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1598 04E1   00            byte >00
1599               
1600                      .char 'P'                                           ; Token 32:     "POPULATION"
     **** ****     > CHAR
0004 04E2 73              byte 'P' ^ RE
                   < elite.a99
1601                      .char 'O'                                           ;
     **** ****     > CHAR
0004 04E3   6C            byte 'O' ^ RE
                   < elite.a99
1602                      .char 'P'                                           ; Encoded as:   "POPUL<145>I<159>"
     **** ****     > CHAR
0004 04E4 73              byte 'P' ^ RE
                   < elite.a99
1603                      .char 'U'
     **** ****     > CHAR
0004 04E5   76            byte 'U' ^ RE
                   < elite.a99
1604                      .char 'L'
     **** ****     > CHAR
0004 04E6 6F              byte 'L' ^ RE
                   < elite.a99
1605 04E7   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
1606                      .char 'I'
     **** ****     > CHAR
0004 04E8 6A              byte 'I' ^ RE
                   < elite.a99
1607 04E9   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1608 04EA 00              byte >00
1609               
1610                      .char 'G'                                           ; Token 33:     "GROSS PRODUCTIVITY"
     **** ****     > CHAR
0004 04EB   64            byte 'G' ^ RE
                   < elite.a99
1611                      .char 'R'                                           ;
     **** ****     > CHAR
0004 04EC 71              byte 'R' ^ RE
                   < elite.a99
1612                      .char 'O'                                           ; Encoded as:   "GROSS [26]IVITY"
     **** ****     > CHAR
0004 04ED   6C            byte 'O' ^ RE
                   < elite.a99
1613                      .char 'S'
     **** ****     > CHAR
0004 04EE 70              byte 'S' ^ RE
                   < elite.a99
1614                      .char 'S'
     **** ****     > CHAR
0004 04EF   70            byte 'S' ^ RE
                   < elite.a99
1615                      .char ' '
     **** ****     > CHAR
0004 04F0 03              byte ' ' ^ RE
                   < elite.a99
1616                      .rtok 26
     **** ****     > RTOK
0003 04F1   99            byte (26 + 160) ^ RE
                   < elite.a99
1617                      .char 'I'
     **** ****     > CHAR
0004 04F2 6A              byte 'I' ^ RE
                   < elite.a99
1618                      .char 'V'
     **** ****     > CHAR
0004 04F3   75            byte 'V' ^ RE
                   < elite.a99
1619                      .char 'I'
     **** ****     > CHAR
0004 04F4 6A              byte 'I' ^ RE
                   < elite.a99
1620                      .char 'T'
     **** ****     > CHAR
0004 04F5   77            byte 'T' ^ RE
                   < elite.a99
1621                      .char 'Y'
     **** ****     > CHAR
0004 04F6 7A              byte 'Y' ^ RE
                   < elite.a99
1622 04F7   00            byte >00
1623               
1624                      .char 'E'                                           ; Token 34:     "ECONOMY"
     **** ****     > CHAR
0004 04F8 66              byte 'E' ^ RE
                   < elite.a99
1625                      .char 'C'                                           ;
     **** ****     > CHAR
0004 04F9   60            byte 'C' ^ RE
                   < elite.a99
1626 04FA BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "EC<159>OMY"
1627                      .char 'O'
     **** ****     > CHAR
0004 04FB   6C            byte 'O' ^ RE
                   < elite.a99
1628                      .char 'M'
     **** ****     > CHAR
0004 04FC 6E              byte 'M' ^ RE
                   < elite.a99
1629                      .char 'Y'
     **** ****     > CHAR
0004 04FD   7A            byte 'Y' ^ RE
                   < elite.a99
1630 04FE 00              byte >00
1631               
1632                      .char ' '                                           ; Token 35:     " LIGHT YEARS"
     **** ****     > CHAR
0004 04FF   03            byte ' ' ^ RE
                   < elite.a99
1633                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0500 6F              byte 'L' ^ RE
                   < elite.a99
1634                      .char 'I'                                           ; Encoded as:   " LIGHT YE<138>S"
     **** ****     > CHAR
0004 0501   6A            byte 'I' ^ RE
                   < elite.a99
1635                      .char 'G'
     **** ****     > CHAR
0004 0502 64              byte 'G' ^ RE
                   < elite.a99
1636                      .char 'H'
     **** ****     > CHAR
0004 0503   6B            byte 'H' ^ RE
                   < elite.a99
1637                      .char 'T'
     **** ****     > CHAR
0004 0504 77              byte 'T' ^ RE
                   < elite.a99
1638                      .char ' '
     **** ****     > CHAR
0004 0505   03            byte ' ' ^ RE
                   < elite.a99
1639                      .char 'Y'
     **** ****     > CHAR
0004 0506 7A              byte 'Y' ^ RE
                   < elite.a99
1640                      .char 'E'
     **** ****     > CHAR
0004 0507   66            byte 'E' ^ RE
                   < elite.a99
1641 0508 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1642                      .char 'S'
     **** ****     > CHAR
0004 0509   70            byte 'S' ^ RE
                   < elite.a99
1643 050A 00              byte >00
1644               
1645 050B   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 36:     "TECH.LEVEL"
1646                      .char 'C'                                           ;
     **** ****     > CHAR
0004 050C 60              byte 'C' ^ RE
                   < elite.a99
1647                      .char 'H'                                           ; Encoded as:   "<156>CH.<129><150>L"
     **** ****     > CHAR
0004 050D   6B            byte 'H' ^ RE
                   < elite.a99
1648                      .char '.'
     **** ****     > CHAR
0004 050E 0D              byte '.' ^ RE
                   < elite.a99
1649 050F   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
1650 0510 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1651                      .char 'L'
     **** ****     > CHAR
0004 0511   6F            byte 'L' ^ RE
                   < elite.a99
1652 0512 00              byte >00
1653               
1654                      .char 'C'                                           ; Token 37:     "CASH"
     **** ****     > CHAR
0004 0513   60            byte 'C' ^ RE
                   < elite.a99
1655                      .char 'A'                                           ;
     **** ****     > CHAR
0004 0514 62              byte 'A' ^ RE
                   < elite.a99
1656                      .char 'S'                                           ; Encoded as:   "CASH"
     **** ****     > CHAR
0004 0515   70            byte 'S' ^ RE
                   < elite.a99
1657                      .char 'H'
     **** ****     > CHAR
0004 0516 6B              byte 'H' ^ RE
                   < elite.a99
1658 0517   00            byte >00
1659               
1660                      .char ' '                                           ; Token 38:     " BILLION"
     **** ****     > CHAR
0004 0518 03              byte ' ' ^ RE
                   < elite.a99
1661 0519   A5            byte 134 ^ RE                                       ; TWOK 'B', 'I'
1662                      .rtok 118                                           ; Encoded as:   " <134>[118]I<159>"
     **** ****     > RTOK
0008 051A 55              byte 118 ^ RE
                   < elite.a99
1663                      .char 'I'
     **** ****     > CHAR
0004 051B   6A            byte 'I' ^ RE
                   < elite.a99
1664 051C BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1665 051D   00            byte >00
1666               
1667                      .rtok 122                                           ; Token 39:     "GALACTIC CHART{galaxy number}"
     **** ****     > RTOK
0008 051E 59              byte 122 ^ RE
                   < elite.a99
1668                      .rtok 1                                             ;
     **** ****     > RTOK
0003 051F   82            byte (1 + 160) ^ RE
                   < elite.a99
1669                      .cont 1                                             ; Encoded as:   "[122][1]{1}"
     **** ****     > CONT
0001 0520 22              byte 1 ^ RE
                   < elite.a99
1670 0521   00            byte >00
1671               
1672                      .char 'T'                                           ; Token 40:     "TARGET LOST"
     **** ****     > CHAR
0004 0522 77              byte 'T' ^ RE
                   < elite.a99
1673 0523   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
1674 0524 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "T<138><131>T LO[43]"
1675                      .char 'T'
     **** ****     > CHAR
0004 0525   77            byte 'T' ^ RE
                   < elite.a99
1676                      .char ' '
     **** ****     > CHAR
0004 0526 03              byte ' ' ^ RE
                   < elite.a99
1677                      .char 'L'
     **** ****     > CHAR
0004 0527   6F            byte 'L' ^ RE
                   < elite.a99
1678                      .char 'O'
     **** ****     > CHAR
0004 0528 6C              byte 'O' ^ RE
                   < elite.a99
1679                      .rtok 43
     **** ****     > RTOK
0003 0529   E8            byte (43 + 160) ^ RE
                   < elite.a99
1680 052A 00              byte >00
1681               
1682                      .rtok 106                                           ; Token 41:     "MISSILE JAMMED"
     **** ****     > RTOK
0008 052B   49            byte 106 ^ RE
                   < elite.a99
1683                      .char ' '                                           ;
     **** ****     > CHAR
0004 052C 03              byte ' ' ^ RE
                   < elite.a99
1684                      .char 'J'                                           ; Encoded as:   "[106] JAMM<152>"
     **** ****     > CHAR
0004 052D   69            byte 'J' ^ RE
                   < elite.a99
1685                      .char 'A'
     **** ****     > CHAR
0004 052E 62              byte 'A' ^ RE
                   < elite.a99
1686                      .char 'M'
     **** ****     > CHAR
0004 052F   6E            byte 'M' ^ RE
                   < elite.a99
1687                      .char 'M'
     **** ****     > CHAR
0004 0530 6E              byte 'M' ^ RE
                   < elite.a99
1688 0531   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1689 0532 00              byte >00
1690               
1691                      .char 'R'                                           ; Token 42:     "RANGE"
     **** ****     > CHAR
0004 0533   71            byte 'R' ^ RE
                   < elite.a99
1692 0534 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
1693 0535   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "R<155><131>"
1694 0536 00              byte >00
1695               
1696                      .char 'S'                                           ; Token 43:     "ST"
     **** ****     > CHAR
0004 0537   70            byte 'S' ^ RE
                   < elite.a99
1697                      .char 'T'                                           ;
     **** ****     > CHAR
0004 0538 77              byte 'T' ^ RE
                   < elite.a99
1698 0539   00            byte >00                                            ; Encoded as:   "ST"
1699               
1700                      .rtok 16                                            ; Token 44:     "QUANTITY OF "
     **** ****     > RTOK
0003 053A 93              byte (16 + 160) ^ RE
                   < elite.a99
1701                      .char ' '                                           ;
     **** ****     > CHAR
0004 053B   03            byte ' ' ^ RE
                   < elite.a99
1702                      .char 'O'                                           ; Encoded as:   "[16] OF "
     **** ****     > CHAR
0004 053C 6C              byte 'O' ^ RE
                   < elite.a99
1703                      .char 'F'
     **** ****     > CHAR
0004 053D   65            byte 'F' ^ RE
                   < elite.a99
1704                      .char ' '
     **** ****     > CHAR
0004 053E 03              byte ' ' ^ RE
                   < elite.a99
1705 053F   00            byte >00
1706               
1707                      .char 'S'                                           ; Token 45:     "SELL"
     **** ****     > CHAR
0004 0540 70              byte 'S' ^ RE
                   < elite.a99
1708                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0541   66            byte 'E' ^ RE
                   < elite.a99
1709                      .rtok 118                                           ; Encoded as:   "SE[118]"
     **** ****     > RTOK
0008 0542 55              byte 118 ^ RE
                   < elite.a99
1710 0543   00            byte >00
1711               
1712                      .char ' '                                           ; Token 46:     " CARGO{sentence case}"
     **** ****     > CHAR
0004 0544 03              byte ' ' ^ RE
                   < elite.a99
1713                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0545   60            byte 'C' ^ RE
                   < elite.a99
1714 0546 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R' Encoded as:   " C<138>GO{6}"
1715                      .char 'G'
     **** ****     > CHAR
0004 0547   64            byte 'G' ^ RE
                   < elite.a99
1716                      .char 'O'
     **** ****     > CHAR
0004 0548 6C              byte 'O' ^ RE
                   < elite.a99
1717                      .cont 6
     **** ****     > CONT
0001 0549   25            byte 6 ^ RE
                   < elite.a99
1718 054A 00              byte >00
1719               
1720                      .char 'E'                                           ; Token 47:     "EQUIP"
     **** ****     > CHAR
0004 054B   66            byte 'E' ^ RE
                   < elite.a99
1721 054C B9              byte 154 ^ RE                                       ; TWOK 'Q', 'U'
1722                      .char 'I'                                           ; Encoded as:   "E<154>IP"
     **** ****     > CHAR
0004 054D   6A            byte 'I' ^ RE
                   < elite.a99
1723                      .char 'P'
     **** ****     > CHAR
0004 054E 73              byte 'P' ^ RE
                   < elite.a99
1724 054F   00            byte >00
1725               
1726                      .char 'F'                                           ; Token 48:     "FOOD"
     **** ****     > CHAR
0004 0550 65              byte 'F' ^ RE
                   < elite.a99
1727                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0551   6C            byte 'O' ^ RE
                   < elite.a99
1728                      .char 'O'                                           ; Encoded as:   "FOOD"
     **** ****     > CHAR
0004 0552 6C              byte 'O' ^ RE
                   < elite.a99
1729                      .char 'D'
     **** ****     > CHAR
0004 0553   67            byte 'D' ^ RE
                   < elite.a99
1730 0554 00              byte >00
1731               
1732 0555   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E' Token 49:     "TEXTILES"
1733                      .char 'X'                                           ;
     **** ****     > CHAR
0004 0556 7B              byte 'X' ^ RE
                   < elite.a99
1734 0557   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' Encoded as:   "<156>X<151>L<137>"
1735                      .char 'L'
     **** ****     > CHAR
0004 0558 6F              byte 'L' ^ RE
                   < elite.a99
1736 0559   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1737 055A 00              byte >00
1738               
1739 055B   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 50:     "RADIOACTIVES"
1740 055C AE              byte 141 ^ RE                                       ; TWOK 'D', 'I'
1741                      .char 'O'                                           ; Encoded as:   "<148><141>OAC<151><150>S"
     **** ****     > CHAR
0004 055D   6C            byte 'O' ^ RE
                   < elite.a99
1742                      .char 'A'
     **** ****     > CHAR
0004 055E 62              byte 'A' ^ RE
                   < elite.a99
1743                      .char 'C'
     **** ****     > CHAR
0004 055F   60            byte 'C' ^ RE
                   < elite.a99
1744 0560 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1745 0561   B5            byte 150 ^ RE                                       ; TWOK 'V', 'E' null
1746                      .char 'S'
     **** ****     > CHAR
0004 0562 70              byte 'S' ^ RE
                   < elite.a99
1747 0563   00            byte >00
1748               
1749                      .char 'S'                                           ; Token 51:     "SLAVES"
     **** ****     > CHAR
0004 0564 70              byte 'S' ^ RE
                   < elite.a99
1750 0565   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1751 0566 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' Encoded as:   "S<149><150>S"
1752                      .char 'S'
     **** ****     > CHAR
0004 0567   70            byte 'S' ^ RE
                   < elite.a99
1753 0568 00              byte >00
1754               
1755                      .char 'L'                                           ; Token 52:     "LIQUOR/WINES"
     **** ****     > CHAR
0004 0569   6F            byte 'L' ^ RE
                   < elite.a99
1756                      .char 'I'                                           ;
     **** ****     > CHAR
0004 056A 6A              byte 'I' ^ RE
                   < elite.a99
1757 056B   B9            byte 154 ^ RE                                       ; TWOK 'Q', 'U' Encoded as:   "LI<154><153>/W<140><137>"
1758 056C BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
1759                      .char '/'
     **** ****     > CHAR
0004 056D   0C            byte '/' ^ RE
                   < elite.a99
1760                      .char 'W'
     **** ****     > CHAR
0004 056E 74              byte 'W' ^ RE
                   < elite.a99
1761 056F   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1762 0570 AA              byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1763 0571   00            byte >00
1764               
1765                      .char 'L'                                           ; Token 53:     "LUXURIES"
     **** ****     > CHAR
0004 0572 6F              byte 'L' ^ RE
                   < elite.a99
1766                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0573   76            byte 'U' ^ RE
                   < elite.a99
1767                      .char 'X'                                           ; Encoded as:   "LUXU<158><137>"
     **** ****     > CHAR
0004 0574 7B              byte 'X' ^ RE
                   < elite.a99
1768                      .char 'U'
     **** ****     > CHAR
0004 0575   76            byte 'U' ^ RE
                   < elite.a99
1769 0576 BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' null
1770 0577   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1771 0578 00              byte >00
1772               
1773                      .char 'N'                                           ; Token 54:     "NARCOTICS"
     **** ****     > CHAR
0004 0579   6D            byte 'N' ^ RE
                   < elite.a99
1774 057A A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1775                      .char 'C'                                           ; Encoded as:   "N<138>CO<151>CS"
     **** ****     > CHAR
0004 057B   60            byte 'C' ^ RE
                   < elite.a99
1776                      .char 'O'
     **** ****     > CHAR
0004 057C 6C              byte 'O' ^ RE
                   < elite.a99
1777 057D   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
1778                      .char 'C'
     **** ****     > CHAR
0004 057E 60              byte 'C' ^ RE
                   < elite.a99
1779                      .char 'S'
     **** ****     > CHAR
0004 057F   70            byte 'S' ^ RE
                   < elite.a99
1780 0580 00              byte >00
1781               
1782                      .rtok 91                                            ; Token 55:     "COMPUTERS"
     **** ****     > RTOK
0003 0581   D8            byte (91 + 160) ^ RE
                   < elite.a99
1783                      .char 'P'                                           ;
     **** ****     > CHAR
0004 0582 73              byte 'P' ^ RE
                   < elite.a99
1784                      .char 'U'                                           ; Encoded as:   "[91]PUT<144>S"
     **** ****     > CHAR
0004 0583   76            byte 'U' ^ RE
                   < elite.a99
1785                      .char 'T'
     **** ****     > CHAR
0004 0584 77              byte 'T' ^ RE
                   < elite.a99
1786 0585   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1787                      .char 'S'
     **** ****     > CHAR
0004 0586 70              byte 'S' ^ RE
                   < elite.a99
1788 0587   00            byte >00
1789               
1790 0588 A8              byte 139 ^ RE                                       ; TWOK 'M', 'A' Token 56:     "MACHINERY"
1791                      .char 'C'                                           ;
     **** ****     > CHAR
0004 0589   60            byte 'C' ^ RE
                   < elite.a99
1792                      .char 'H'                                           ; Encoded as:   "<139>CH<140><144>Y"
     **** ****     > CHAR
0004 058A 6B              byte 'H' ^ RE
                   < elite.a99
1793 058B   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1794 058C B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1795                      .char 'Y'
     **** ****     > CHAR
0004 058D   7A            byte 'Y' ^ RE
                   < elite.a99
1796 058E 00              byte >00
1797               
1798                      .rtok 117                                           ; Token 57:     "ALLOYS"
     **** ****     > RTOK
0008 058F   56            byte 117 ^ RE
                   < elite.a99
1799                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0590 6C              byte 'O' ^ RE
                   < elite.a99
1800                      .char 'Y'                                           ; Encoded as:   "[117]OYS"
     **** ****     > CHAR
0004 0591   7A            byte 'Y' ^ RE
                   < elite.a99
1801                      .char 'S'
     **** ****     > CHAR
0004 0592 70              byte 'S' ^ RE
                   < elite.a99
1802 0593   00            byte >00
1803               
1804                      .char 'F'                                           ; Token 58:     "FIREARMS"
     **** ****     > CHAR
0004 0594 65              byte 'F' ^ RE
                   < elite.a99
1805                      .char 'I'                                           ;
     **** ****     > CHAR
0004 0595   6A            byte 'I' ^ RE
                   < elite.a99
1806 0596 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' Encoded as:   "FI<142><138>MS"
1807 0597   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R' null
1808                      .char 'M'
     **** ****     > CHAR
0004 0598 6E              byte 'M' ^ RE
                   < elite.a99
1809                      .char 'S'
     **** ****     > CHAR
0004 0599   70            byte 'S' ^ RE
                   < elite.a99
1810 059A 00              byte >00
1811               
1812                      .char 'F'                                           ; Token 59:     "FURS"
     **** ****     > CHAR
0004 059B   65            byte 'F' ^ RE
                   < elite.a99
1813                      .char 'U'                                           ;
     **** ****     > CHAR
0004 059C 76              byte 'U' ^ RE
                   < elite.a99
1814                      .char 'R'                                           ; Encoded as:   "FURS"
     **** ****     > CHAR
0004 059D   71            byte 'R' ^ RE
                   < elite.a99
1815                      .char 'S'
     **** ****     > CHAR
0004 059E 70              byte 'S' ^ RE
                   < elite.a99
1816 059F   00            byte >00
1817               
1818                      .char 'M'                                           ; Token 60:     "MINERALS"
     **** ****     > CHAR
0004 05A0 6E              byte 'M' ^ RE
                   < elite.a99
1819 05A1   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
1820 05A2 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "M<140><144><128>S"
1821 05A3   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' null
1822                      .char 'S'
     **** ****     > CHAR
0004 05A4 70              byte 'S' ^ RE
                   < elite.a99
1823 05A5   00            byte >00
1824               
1825                      .char 'G'                                           ; Token 61:     "GOLD"
     **** ****     > CHAR
0004 05A6 64              byte 'G' ^ RE
                   < elite.a99
1826                      .char 'O'                                           ;
     **** ****     > CHAR
0004 05A7   6C            byte 'O' ^ RE
                   < elite.a99
1827                      .char 'L'                                           ; Encoded as:   "GOLD"
     **** ****     > CHAR
0004 05A8 6F              byte 'L' ^ RE
                   < elite.a99
1828                      .char 'D'
     **** ****     > CHAR
0004 05A9   67            byte 'D' ^ RE
                   < elite.a99
1829 05AA 00              byte >00
1830               
1831                      .char 'P'                                           ; Token 62:     "PLATINUM"
     **** ****     > CHAR
0004 05AB   73            byte 'P' ^ RE
                   < elite.a99
1832                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05AC 6F              byte 'L' ^ RE
                   < elite.a99
1833 05AD   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' Encoded as:   "PL<145><140>UM"
1834 05AE AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1835                      .char 'U'
     **** ****     > CHAR
0004 05AF   76            byte 'U' ^ RE
                   < elite.a99
1836                      .char 'M'
     **** ****     > CHAR
0004 05B0 6E              byte 'M' ^ RE
                   < elite.a99
1837 05B1   00            byte >00
1838               
1839 05B2 A0              byte 131 ^ RE                                       ; TWOK 'G', 'E' Token 63:     "GEM-STONES"
1840                      .char 'M'                                           ;
     **** ****     > CHAR
0004 05B3   6E            byte 'M' ^ RE
                   < elite.a99
1841                      .char '-'                                           ; Encoded as:   "<131>M-[43]<159><137>"
     **** ****     > CHAR
0004 05B4 0E              byte '-' ^ RE
                   < elite.a99
1842                      .rtok 43
     **** ****     > RTOK
0003 05B5   E8            byte (43 + 160) ^ RE
                   < elite.a99
1843 05B6 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
1844 05B7   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' null
1845 05B8 00              byte >00
1846               
1847 05B9   A3            byte 128 ^ RE                                       ; TWOK 'A', 'L' Token 64:     "ALIEN ITEMS"
1848                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05BA 6A              byte 'I' ^ RE
                   < elite.a99
1849 05BB   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "<128>I<146> [127]S"
1850                      .char ' '
     **** ****     > CHAR
0004 05BC 03              byte ' ' ^ RE
                   < elite.a99
1851                      .rtok 127
     **** ****     > RTOK
0008 05BD   5C            byte 127 ^ RE
                   < elite.a99
1852                      .char 'S'
     **** ****     > CHAR
0004 05BE 70              byte 'S' ^ RE
                   < elite.a99
1853 05BF   00            byte >00
1854               
1855                      .char '('                                           ; Token 65:     "(Y/N)?"
     **** ****     > CHAR
0004 05C0 0B              byte '(' ^ RE
                   < elite.a99
1856                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 05C1   7A            byte 'Y' ^ RE
                   < elite.a99
1857                      .char '/'                                           ; Encoded as:   "(Y/N)?"
     **** ****     > CHAR
0004 05C2 0C              byte '/' ^ RE
                   < elite.a99
1858                      .char 'N'
     **** ****     > CHAR
0004 05C3   6D            byte 'N' ^ RE
                   < elite.a99
1859                      .char ')'
     **** ****     > CHAR
0004 05C4 0A              byte ')' ^ RE
                   < elite.a99
1860                      .char '?'
     **** ****     > CHAR
0004 05C5   1C            byte '?' ^ RE
                   < elite.a99
1861 05C6 00              byte >00
1862               
1863                      .char ' '                                           ; Token 66:     " CR"
     **** ****     > CHAR
0004 05C7   03            byte ' ' ^ RE
                   < elite.a99
1864                      .char 'C'                                           ;
     **** ****     > CHAR
0004 05C8 60              byte 'C' ^ RE
                   < elite.a99
1865                      .char 'R'                                           ; Encoded as:   " CR"
     **** ****     > CHAR
0004 05C9   71            byte 'R' ^ RE
                   < elite.a99
1866 05CA 00              byte >00
1867               
1868                      .char 'L'                                           ; Token 67:     "LARGE"
     **** ****     > CHAR
0004 05CB   6F            byte 'L' ^ RE
                   < elite.a99
1869 05CC A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
1870 05CD   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "L<138><131>"
1871 05CE 00              byte >00
1872               
1873                      .char 'F'                                           ; Token 68:     "FIERCE"
     **** ****     > CHAR
0004 05CF   65            byte 'F' ^ RE
                   < elite.a99
1874                      .char 'I'                                           ;
     **** ****     > CHAR
0004 05D0 6A              byte 'I' ^ RE
                   < elite.a99
1875 05D1   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' Encoded as:   "FI<144><133>"
1876 05D2 A6              byte 133 ^ RE                                       ; TWOK 'C', 'E' null
1877 05D3   00            byte >00
1878               
1879                      .char 'S'                                           ; Token 69:     "SMALL"
     **** ****     > CHAR
0004 05D4 70              byte 'S' ^ RE
                   < elite.a99
1880 05D5   A8            byte 139 ^ RE                                       ; TWOK 'M', 'A'
1881                      .rtok 118                                           ; Encoded as:   "S<139>[118]"
     **** ****     > RTOK
0008 05D6 55              byte 118 ^ RE
                   < elite.a99
1882 05D7   00            byte >00
1883               
1884                      .char 'G'                                           ; Token 70:     "GREEN"
     **** ****     > CHAR
0004 05D8 64              byte 'G' ^ RE
                   < elite.a99
1885 05D9   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E'
1886 05DA B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' Encoded as:   "G<142><146>"
1887 05DB   00            byte >00
1888               
1889                      .char 'R'                                           ; Token 71:     "RED"
     **** ****     > CHAR
0004 05DC 71              byte 'R' ^ RE
                   < elite.a99
1890 05DD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D'
1891 05DE 00              byte >00                                            ; Encoded as:   "R<152>"
1892               
1893                      .char 'Y'                                           ; Token 72:     "YELLOW"
     **** ****     > CHAR
0004 05DF   7A            byte 'Y' ^ RE
                   < elite.a99
1894                      .char 'E'                                           ;
     **** ****     > CHAR
0004 05E0 66              byte 'E' ^ RE
                   < elite.a99
1895                      .rtok 118                                           ; Encoded as:   "YE[118]OW"
     **** ****     > RTOK
0008 05E1   55            byte 118 ^ RE
                   < elite.a99
1896                      .char 'O'
     **** ****     > CHAR
0004 05E2 6C              byte 'O' ^ RE
                   < elite.a99
1897                      .char 'W'
     **** ****     > CHAR
0004 05E3   74            byte 'W' ^ RE
                   < elite.a99
1898 05E4 00              byte >00
1899               
1900                      .char 'B'                                           ; Token 73:     "BLUE"
     **** ****     > CHAR
0004 05E5   61            byte 'B' ^ RE
                   < elite.a99
1901                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05E6 6F              byte 'L' ^ RE
                   < elite.a99
1902                      .char 'U'                                           ; Encoded as:   "BLUE"
     **** ****     > CHAR
0004 05E7   76            byte 'U' ^ RE
                   < elite.a99
1903                      .char 'E'
     **** ****     > CHAR
0004 05E8 66              byte 'E' ^ RE
                   < elite.a99
1904 05E9   00            byte >00
1905               
1906                      .char 'B'                                           ; Token 74:     "BLACK"
     **** ****     > CHAR
0004 05EA 61              byte 'B' ^ RE
                   < elite.a99
1907 05EB   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A'
1908                      .char 'C'                                           ; Encoded as:   "B<149>CK"
     **** ****     > CHAR
0004 05EC 60              byte 'C' ^ RE
                   < elite.a99
1909                      .char 'K'
     **** ****     > CHAR
0004 05ED   68            byte 'K' ^ RE
                   < elite.a99
1910 05EE 00              byte >00
1911               
1912                      .rtok 136                                           ; Token 75:     "HARMLESS"
     **** ****     > RTOK
0006 05EF   35            byte (136 - 114) ^ RE
                   < elite.a99
1913 05F0 00              byte >00                                            ;
1914                                                                          ; Encoded as:   "[136]"
1915               
1916                      .char 'S'                                           ; Token 76:     "SLIMY"
     **** ****     > CHAR
0004 05F1   70            byte 'S' ^ RE
                   < elite.a99
1917                      .char 'L'                                           ;
     **** ****     > CHAR
0004 05F2 6F              byte 'L' ^ RE
                   < elite.a99
1918                      .char 'I'                                           ; Encoded as:   "SLIMY"
     **** ****     > CHAR
0004 05F3   6A            byte 'I' ^ RE
                   < elite.a99
1919                      .char 'M'
     **** ****     > CHAR
0004 05F4 6E              byte 'M' ^ RE
                   < elite.a99
1920                      .char 'Y'
     **** ****     > CHAR
0004 05F5   7A            byte 'Y' ^ RE
                   < elite.a99
1921 05F6 00              byte >00
1922               
1923                      .char 'B'                                           ; Token 77:     "BUG-EYED"
     **** ****     > CHAR
0004 05F7   61            byte 'B' ^ RE
                   < elite.a99
1924                      .char 'U'                                           ;
     **** ****     > CHAR
0004 05F8 76              byte 'U' ^ RE
                   < elite.a99
1925                      .char 'G'                                           ; Encoded as:   "BUG-EY<152>"
     **** ****     > CHAR
0004 05F9   64            byte 'G' ^ RE
                   < elite.a99
1926                      .char '-'
     **** ****     > CHAR
0004 05FA 0E              byte '-' ^ RE
                   < elite.a99
1927                      .char 'E'
     **** ****     > CHAR
0004 05FB   66            byte 'E' ^ RE
                   < elite.a99
1928                      .char 'Y'
     **** ****     > CHAR
0004 05FC 7A              byte 'Y' ^ RE
                   < elite.a99
1929 05FD   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1930 05FE 00              byte >00
1931               
1932                      .char 'H'                                           ; Token 78:     "HORNED"
     **** ****     > CHAR
0004 05FF   6B            byte 'H' ^ RE
                   < elite.a99
1933 0600 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R'
1934                      .char 'N'                                           ; Encoded as:   "H<153>N<152>"
     **** ****     > CHAR
0004 0601   6D            byte 'N' ^ RE
                   < elite.a99
1935 0602 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
1936 0603   00            byte >00
1937               
1938                      .char 'B'                                           ; Token 79:     "BONY"
     **** ****     > CHAR
0004 0604 61              byte 'B' ^ RE
                   < elite.a99
1939 0605   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N'
1940                      .char 'Y'                                           ; Encoded as:   "B<159>Y"
     **** ****     > CHAR
0004 0606 7A              byte 'Y' ^ RE
                   < elite.a99
1941 0607   00            byte >00
1942               
1943                      .char 'F'                                           ; Token 80:     "FAT"
     **** ****     > CHAR
0004 0608 65              byte 'F' ^ RE
                   < elite.a99
1944 0609   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T'
1945 060A 00              byte >00                                            ; Encoded as:   "F<145>"
1946               
1947                      .char 'F'                                           ; Token 81:     "FURRY"
     **** ****     > CHAR
0004 060B   65            byte 'F' ^ RE
                   < elite.a99
1948                      .char 'U'                                           ;
     **** ****     > CHAR
0004 060C 76              byte 'U' ^ RE
                   < elite.a99
1949                      .char 'R'                                           ; Encoded as:   "FURRY"
     **** ****     > CHAR
0004 060D   71            byte 'R' ^ RE
                   < elite.a99
1950                      .char 'R'
     **** ****     > CHAR
0004 060E 71              byte 'R' ^ RE
                   < elite.a99
1951                      .char 'Y'
     **** ****     > CHAR
0004 060F   7A            byte 'Y' ^ RE
                   < elite.a99
1952 0610 00              byte >00
1953               
1954                      .char 'R'                                           ; Token 82:     "RODENT"
     **** ****     > CHAR
0004 0611   71            byte 'R' ^ RE
                   < elite.a99
1955                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0612 6C              byte 'O' ^ RE
                   < elite.a99
1956                      .char 'D'                                           ; Encoded as:   "ROD<146>T"
     **** ****     > CHAR
0004 0613   67            byte 'D' ^ RE
                   < elite.a99
1957 0614 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
1958                      .char 'T'
     **** ****     > CHAR
0004 0615   77            byte 'T' ^ RE
                   < elite.a99
1959 0616 00              byte >00
1960               
1961                      .char 'F'                                           ; Token 83:     "FROG"
     **** ****     > CHAR
0004 0617   65            byte 'F' ^ RE
                   < elite.a99
1962                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0618 71              byte 'R' ^ RE
                   < elite.a99
1963                      .char 'O'                                           ; Encoded as:   "FROG"
     **** ****     > CHAR
0004 0619   6C            byte 'O' ^ RE
                   < elite.a99
1964                      .char 'G'
     **** ****     > CHAR
0004 061A 64              byte 'G' ^ RE
                   < elite.a99
1965 061B   00            byte >00
1966               
1967                      .char 'L'                                           ; Token 84:     "LIZARD"
     **** ****     > CHAR
0004 061C 6F              byte 'L' ^ RE
                   < elite.a99
1968                      .char 'I'                                           ;
     **** ****     > CHAR
0004 061D   6A            byte 'I' ^ RE
                   < elite.a99
1969 061E A7              byte 132 ^ RE                                       ; TWOK 'Z', 'A' Encoded as:   "LI<132>RD"
1970                      .char 'R'
     **** ****     > CHAR
0004 061F   71            byte 'R' ^ RE
                   < elite.a99
1971                      .char 'D'
     **** ****     > CHAR
0004 0620 67              byte 'D' ^ RE
                   < elite.a99
1972 0621   00            byte >00
1973               
1974                      .char 'L'                                           ; Token 85:     "LOBSTER"
     **** ****     > CHAR
0004 0622 6F              byte 'L' ^ RE
                   < elite.a99
1975                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0623   6C            byte 'O' ^ RE
                   < elite.a99
1976                      .char 'B'                                           ; Encoded as:   "LOB[43]<144>"
     **** ****     > CHAR
0004 0624 61              byte 'B' ^ RE
                   < elite.a99
1977                      .rtok 43
     **** ****     > RTOK
0003 0625   E8            byte (43 + 160) ^ RE
                   < elite.a99
1978 0626 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R' null
1979 0627   00            byte >00
1980               
1981 0628 A5              byte 134 ^ RE                                       ; TWOK 'B', 'I' Token 86:     "BIRD"
1982                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0629   71            byte 'R' ^ RE
                   < elite.a99
1983                      .char 'D'                                           ; Encoded as:   "<134>RD"
     **** ****     > CHAR
0004 062A 67              byte 'D' ^ RE
                   < elite.a99
1984 062B   00            byte >00
1985               
1986                      .char 'H'                                           ; Token 87:     "HUMANOID"
     **** ****     > CHAR
0004 062C 6B              byte 'H' ^ RE
                   < elite.a99
1987                      .char 'U'                                           ;
     **** ****     > CHAR
0004 062D   76            byte 'U' ^ RE
                   < elite.a99
1988                      .char 'M'                                           ; Encoded as:   "HUM<155>OID"
     **** ****     > CHAR
0004 062E 6E              byte 'M' ^ RE
                   < elite.a99
1989 062F   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' null
1990                      .char 'O'
     **** ****     > CHAR
0004 0630 6C              byte 'O' ^ RE
                   < elite.a99
1991                      .char 'I'
     **** ****     > CHAR
0004 0631   6A            byte 'I' ^ RE
                   < elite.a99
1992                      .char 'D'
     **** ****     > CHAR
0004 0632 67              byte 'D' ^ RE
                   < elite.a99
1993 0633   00            byte >00
1994               
1995                      .char 'F'                                           ; Token 88:     "FELINE"
     **** ****     > CHAR
0004 0634 65              byte 'F' ^ RE
                   < elite.a99
1996                      .char 'E'                                           ;
     **** ****     > CHAR
0004 0635   66            byte 'E' ^ RE
                   < elite.a99
1997                      .char 'L'                                           ; Encoded as:   "FEL<140>E"
     **** ****     > CHAR
0004 0636 6F              byte 'L' ^ RE
                   < elite.a99
1998 0637   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N' null
1999                      .char 'E'
     **** ****     > CHAR
0004 0638 66              byte 'E' ^ RE
                   < elite.a99
2000 0639   00            byte >00
2001               
2002 063A AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 89:     "INSECT"
2003                      .char 'S'                                           ;
     **** ****     > CHAR
0004 063B   70            byte 'S' ^ RE
                   < elite.a99
2004                      .char 'E'                                           ; Encoded as:   "<140>SECT"
     **** ****     > CHAR
0004 063C 66              byte 'E' ^ RE
                   < elite.a99
2005                      .char 'C'
     **** ****     > CHAR
0004 063D   60            byte 'C' ^ RE
                   < elite.a99
2006                      .char 'T'
     **** ****     > CHAR
0004 063E 77              byte 'T' ^ RE
                   < elite.a99
2007 063F   00            byte >00
2008               
2009                      .rtok 11                                            ; Token 90:     "AVERAGE RADIUS"
     **** ****     > RTOK
0003 0640 88              byte (11 + 160) ^ RE
                   < elite.a99
2010 0641   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A'
2011 0642 AE              byte 141 ^ RE                                       ; TWOK 'D', 'I' Encoded as:   "[11]<148><141><136>"
2012 0643   AB            byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2013 0644 00              byte >00
2014               
2015                      .char 'C'                                           ; Token 91:     "COM"
     **** ****     > CHAR
0004 0645   60            byte 'C' ^ RE
                   < elite.a99
2016                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0646 6C              byte 'O' ^ RE
                   < elite.a99
2017                      .char 'M'                                           ; Encoded as:   "COM"
     **** ****     > CHAR
0004 0647   6E            byte 'M' ^ RE
                   < elite.a99
2018 0648 00              byte >00
2019               
2020                      .rtok 91                                            ; Token 92:     "COMMANDER"
     **** ****     > RTOK
0003 0649   D8            byte (91 + 160) ^ RE
                   < elite.a99
2021                      .char 'M'                                           ;
     **** ****     > CHAR
0004 064A 6E              byte 'M' ^ RE
                   < elite.a99
2022 064B   B8            byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "[91]M<155>D<144>"
2023                      .char 'D'
     **** ****     > CHAR
0004 064C 67              byte 'D' ^ RE
                   < elite.a99
2024 064D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2025 064E 00              byte >00
2026               
2027                      .char ' '                                           ; Token 93:     " DESTROYED"
     **** ****     > CHAR
0004 064F   03            byte ' ' ^ RE
                   < elite.a99
2028                      .char 'D'                                           ;
     **** ****     > CHAR
0004 0650 67              byte 'D' ^ RE
                   < elite.a99
2029 0651   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Encoded as:   " D<137>TROY<152>"
2030                      .char 'T'
     **** ****     > CHAR
0004 0652 77              byte 'T' ^ RE
                   < elite.a99
2031                      .char 'R'
     **** ****     > CHAR
0004 0653   71            byte 'R' ^ RE
                   < elite.a99
2032                      .char 'O'
     **** ****     > CHAR
0004 0654 6C              byte 'O' ^ RE
                   < elite.a99
2033                      .char 'Y'
     **** ****     > CHAR
0004 0655   7A            byte 'Y' ^ RE
                   < elite.a99
2034 0656 BB              byte 152 ^ RE                                       ; TWOK 'E', 'D' null
2035 0657   00            byte >00
2036               
2037                      .char 'B'                                           ; Token 94:     "BY D.BRABEN & I.BELL"
     **** ****     > CHAR
0004 0658 61              byte 'B' ^ RE
                   < elite.a99
2038                      .char 'Y'                                           ;
     **** ****     > CHAR
0004 0659   7A            byte 'Y' ^ RE
                   < elite.a99
2039                      .char ' '                                           ; Encoded as:   "BY D.B<148><147>N & I.<147>[118]"
     **** ****     > CHAR
0004 065A 03              byte ' ' ^ RE
                   < elite.a99
2040                      .char 'D'
     **** ****     > CHAR
0004 065B   67            byte 'D' ^ RE
                   < elite.a99
2041                      .char '.'
     **** ****     > CHAR
0004 065C 0D              byte '.' ^ RE
                   < elite.a99
2042                      .char 'B'
     **** ****     > CHAR
0004 065D   61            byte 'B' ^ RE
                   < elite.a99
2043 065E B7              byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2044 065F   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2045                      .char 'N'
     **** ****     > CHAR
0004 0660 6D              byte 'N' ^ RE
                   < elite.a99
2046                      .char ' '
     **** ****     > CHAR
0004 0661   03            byte ' ' ^ RE
                   < elite.a99
2047                      .char '&'
     **** ****     > CHAR
0004 0662 05              byte '&' ^ RE
                   < elite.a99
2048                      .char ' '
     **** ****     > CHAR
0004 0663   03            byte ' ' ^ RE
                   < elite.a99
2049                      .char 'I'
     **** ****     > CHAR
0004 0664 6A              byte 'I' ^ RE
                   < elite.a99
2050                      .char '.'
     **** ****     > CHAR
0004 0665   0D            byte '.' ^ RE
                   < elite.a99
2051 0666 B0              byte 147 ^ RE                                       ; TWOK 'B', 'E' null
2052                      .rtok 118
     **** ****     > RTOK
0008 0667   55            byte 118 ^ RE
                   < elite.a99
2053 0668 00              byte >00
2054               
2055                      .rtok 14                                            ; Token 95:     "UNIT  QUANTITY{crlf}
     **** ****     > RTOK
0003 0669   8D            byte (14 + 160) ^ RE
                   < elite.a99
2056                      .char ' '                                           ; PRODUCT   UNIT PRICE FOR SALE{crlf}
     **** ****     > CHAR
0004 066A 03              byte ' ' ^ RE
                   < elite.a99
2057                      .char ' '                                           ; {lf}"
     **** ****     > CHAR
0004 066B   03            byte ' ' ^ RE
                   < elite.a99
2058                      .rtok 16                                            ;
     **** ****     > RTOK
0003 066C 93              byte (16 + 160) ^ RE
                   < elite.a99
2059                      .cont 13                                            ; Encoded as:   "[14]  [16]{13} [26]   [14] [6] F<153>
     **** ****     > CONT
0001 066D   2E            byte 13 ^ RE
                   < elite.a99
2060                      .char ' '                                           ; SA<129>{13}{10}"
     **** ****     > CHAR
0004 066E 03              byte ' ' ^ RE
                   < elite.a99
2061                      .rtok 26
     **** ****     > RTOK
0003 066F   99            byte (26 + 160) ^ RE
                   < elite.a99
2062                      .char ' '
     **** ****     > CHAR
0004 0670 03              byte ' ' ^ RE
                   < elite.a99
2063                      .char ' '
     **** ****     > CHAR
0004 0671   03            byte ' ' ^ RE
                   < elite.a99
2064                      .char ' '
     **** ****     > CHAR
0004 0672 03              byte ' ' ^ RE
                   < elite.a99
2065                      .rtok 14
     **** ****     > RTOK
0003 0673   8D            byte (14 + 160) ^ RE
                   < elite.a99
2066                      .char ' '
     **** ****     > CHAR
0004 0674 03              byte ' ' ^ RE
                   < elite.a99
2067                      .rtok 6
     **** ****     > RTOK
0003 0675   85            byte (6 + 160) ^ RE
                   < elite.a99
2068                      .char ' '
     **** ****     > CHAR
0004 0676 03              byte ' ' ^ RE
                   < elite.a99
2069                      .char 'F'
     **** ****     > CHAR
0004 0677   65            byte 'F' ^ RE
                   < elite.a99
2070 0678 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2071                      .char ' '
     **** ****     > CHAR
0004 0679   03            byte ' ' ^ RE
                   < elite.a99
2072                      .char 'S'
     **** ****     > CHAR
0004 067A 70              byte 'S' ^ RE
                   < elite.a99
2073                      .char 'A'
     **** ****     > CHAR
0004 067B   62            byte 'A' ^ RE
                   < elite.a99
2074 067C A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2075                      .cont 13
     **** ****     > CONT
0001 067D   2E            byte 13 ^ RE
                   < elite.a99
2076                      .cont 10
     **** ****     > CONT
0001 067E 29              byte 10 ^ RE
                   < elite.a99
2077 067F   00            byte >00
2078               
2079                      .char 'F'                                           ; Token 96:     "FRONT"
     **** ****     > CHAR
0004 0680 65              byte 'F' ^ RE
                   < elite.a99
2080                      .char 'R'                                           ;
     **** ****     > CHAR
0004 0681   71            byte 'R' ^ RE
                   < elite.a99
2081 0682 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' Encoded as:   "FR<159>T"
2082                      .char 'T'
     **** ****     > CHAR
0004 0683   77            byte 'T' ^ RE
                   < elite.a99
2083 0684 00              byte >00
2084               
2085 0685   AD            byte 142 ^ RE                                       ; TWOK 'R', 'E' Token 97:     "REAR"
2086 0686 A9              byte 138 ^ RE                                       ; TWOK 'A', 'R'
2087 0687   00            byte >00                                            ; Encoded as:   "<142><138>"
2088               
2089 0688 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' Token 98:     "LEFT"
2090                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0689   65            byte 'F' ^ RE
                   < elite.a99
2091                      .char 'T'                                           ; Encoded as:   "<129>FT"
     **** ****     > CHAR
0004 068A 77              byte 'T' ^ RE
                   < elite.a99
2092 068B   00            byte >00
2093               
2094 068C BD              byte 158 ^ RE                                       ; TWOK 'R', 'I' Token 99:     "RIGHT"
2095                      .char 'G'                                           ;
     **** ****     > CHAR
0004 068D   64            byte 'G' ^ RE
                   < elite.a99
2096                      .char 'H'                                           ; Encoded as:   "<158>GHT"
     **** ****     > CHAR
0004 068E 6B              byte 'H' ^ RE
                   < elite.a99
2097                      .char 'T'
     **** ****     > CHAR
0004 068F   77            byte 'T' ^ RE
                   < elite.a99
2098 0690 00              byte >00
2099               
2100                      .rtok 121                                           ; Token 100:    "ENERGY LOW{beep}"
     **** ****     > RTOK
0008 0691   5A            byte 121 ^ RE
                   < elite.a99
2101                      .char 'L'                                           ;
     **** ****     > CHAR
0004 0692 6F              byte 'L' ^ RE
                   < elite.a99
2102                      .char 'O'                                           ; Encoded as:   "[121]LOW{7}"
     **** ****     > CHAR
0004 0693   6C            byte 'O' ^ RE
                   < elite.a99
2103                      .char 'W'
     **** ****     > CHAR
0004 0694 74              byte 'W' ^ RE
                   < elite.a99
2104                      .cont 7
     **** ****     > CONT
0001 0695   24            byte 7 ^ RE
                   < elite.a99
2105 0696 00              byte >00
2106               
2107                      .rtok 99                                            ; Token 101:    "RIGHT ON COMMANDER!"
     **** ****     > RTOK
0008 0697   40            byte 99 ^ RE
                   < elite.a99
2108                      .rtok 131                                           ;
     **** ****     > RTOK
0006 0698 32              byte (131 - 114) ^ RE
                   < elite.a99
2109                      .rtok 92                                            ; Encoded as:   "[99][131][92]!"
     **** ****     > RTOK
0003 0699   DF            byte (92 + 160) ^ RE
                   < elite.a99
2110                      .char '!'
     **** ****     > CHAR
0004 069A 02              byte '!' ^ RE
                   < elite.a99
2111 069B   00            byte >00
2112               
2113                      .char 'E'                                           ; Token 102:    "EXTRA "
     **** ****     > CHAR
0004 069C 66              byte 'E' ^ RE
                   < elite.a99
2114                      .char 'X'                                           ;
     **** ****     > CHAR
0004 069D   7B            byte 'X' ^ RE
                   < elite.a99
2115                      .char 'T'                                           ; Encoded as:   "EXT<148> "
     **** ****     > CHAR
0004 069E 77              byte 'T' ^ RE
                   < elite.a99
2116 069F   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' null
2117                      .char ' '
     **** ****     > CHAR
0004 06A0 03              byte ' ' ^ RE
                   < elite.a99
2118 06A1   00            byte >00
2119               
2120                      .char 'P'                                           ; Token 103:    "PULSE LASER"
     **** ****     > CHAR
0004 06A2 73              byte 'P' ^ RE
                   < elite.a99
2121                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06A3   76            byte 'U' ^ RE
                   < elite.a99
2122                      .char 'L'                                           ; Encoded as:   "PULSE[27]"
     **** ****     > CHAR
0004 06A4 6F              byte 'L' ^ RE
                   < elite.a99
2123                      .char 'S'
     **** ****     > CHAR
0004 06A5   70            byte 'S' ^ RE
                   < elite.a99
2124                      .char 'E'
     **** ****     > CHAR
0004 06A6 66              byte 'E' ^ RE
                   < elite.a99
2125                      .rtok 27
     **** ****     > RTOK
0003 06A7   98            byte (27 + 160) ^ RE
                   < elite.a99
2126 06A8 00              byte >00
2127               
2128 06A9   B0            byte 147 ^ RE                                       ; TWOK 'B', 'E' Token 104:    "BEAM LASER"
2129                      .char 'A'                                           ;
     **** ****     > CHAR
0004 06AA 62              byte 'A' ^ RE
                   < elite.a99
2130                      .char 'M'                                           ; Encoded as:   "<147>AM[27]"
     **** ****     > CHAR
0004 06AB   6E            byte 'M' ^ RE
                   < elite.a99
2131                      .rtok 27
     **** ****     > RTOK
0003 06AC 98              byte (27 + 160) ^ RE
                   < elite.a99
2132 06AD   00            byte >00
2133               
2134                      .char 'F'                                           ; Token 105:    "FUEL"
     **** ****     > CHAR
0004 06AE 65              byte 'F' ^ RE
                   < elite.a99
2135                      .char 'U'                                           ;
     **** ****     > CHAR
0004 06AF   76            byte 'U' ^ RE
                   < elite.a99
2136                      .char 'E'                                           ; Encoded as:   "FUEL"
     **** ****     > CHAR
0004 06B0 66              byte 'E' ^ RE
                   < elite.a99
2137                      .char 'L'
     **** ****     > CHAR
0004 06B1   6F            byte 'L' ^ RE
                   < elite.a99
2138 06B2 00              byte >00
2139               
2140                      .char 'M'                                           ; Token 106:    "MISSILE"
     **** ****     > CHAR
0004 06B3   6E            byte 'M' ^ RE
                   < elite.a99
2141 06B4 BE              byte 157 ^ RE                                       ; TWOK 'I', 'S'
2142                      .char 'S'                                           ; Encoded as:   "M<157>SI<129>"
     **** ****     > CHAR
0004 06B5   70            byte 'S' ^ RE
                   < elite.a99
2143                      .char 'I'
     **** ****     > CHAR
0004 06B6 6A              byte 'I' ^ RE
                   < elite.a99
2144 06B7   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2145 06B8 00              byte >00
2146               
2147                      .rtok 67                                            ; Token 107:    "LARGE CARGO{sentence case} BAY"
     **** ****     > RTOK
0003 06B9   C0            byte (67 + 160) ^ RE
                   < elite.a99
2148                      .rtok 46                                            ;
     **** ****     > RTOK
0003 06BA ED              byte (46 + 160) ^ RE
                   < elite.a99
2149                      .char ' '                                           ; Encoded as:   "[67][46] BAY"
     **** ****     > CHAR
0004 06BB   03            byte ' ' ^ RE
                   < elite.a99
2150                      .char 'B'
     **** ****     > CHAR
0004 06BC 61              byte 'B' ^ RE
                   < elite.a99
2151                      .char 'A'
     **** ****     > CHAR
0004 06BD   62            byte 'A' ^ RE
                   < elite.a99
2152                      .char 'Y'
     **** ****     > CHAR
0004 06BE 7A              byte 'Y' ^ RE
                   < elite.a99
2153 06BF   00            byte >00
2154               
2155                      .char 'E'                                           ; Token 108:    "E.C.M.SYSTEM"
     **** ****     > CHAR
0004 06C0 66              byte 'E' ^ RE
                   < elite.a99
2156                      .char '.'                                           ;
     **** ****     > CHAR
0004 06C1   0D            byte '.' ^ RE
                   < elite.a99
2157                      .char 'C'                                           ; Encoded as:   "E.C.M.[5]"
     **** ****     > CHAR
0004 06C2 60              byte 'C' ^ RE
                   < elite.a99
2158                      .char '.'
     **** ****     > CHAR
0004 06C3   0D            byte '.' ^ RE
                   < elite.a99
2159                      .char 'M'
     **** ****     > CHAR
0004 06C4 6E              byte 'M' ^ RE
                   < elite.a99
2160                      .char '.'
     **** ****     > CHAR
0004 06C5   0D            byte '.' ^ RE
                   < elite.a99
2161                      .rtok 5
     **** ****     > RTOK
0003 06C6 86              byte (5 + 160) ^ RE
                   < elite.a99
2162 06C7   00            byte >00
2163               
2164                      .rtok 102                                           ; Token 109:    "EXTRA PULSE LASERS"
     **** ****     > RTOK
0008 06C8 45              byte 102 ^ RE
                   < elite.a99
2165                      .rtok 103                                           ;
     **** ****     > RTOK
0008 06C9   44            byte 103 ^ RE
                   < elite.a99
2166                      .char 'S'                                           ; Encoded as:   "[102][103]S"
     **** ****     > CHAR
0004 06CA 70              byte 'S' ^ RE
                   < elite.a99
2167 06CB   00            byte >00
2168               
2169                      .rtok 102                                           ; Token 110:    "EXTRA BEAM LASERS"
     **** ****     > RTOK
0008 06CC 45              byte 102 ^ RE
                   < elite.a99
2170                      .rtok 104                                           ;
     **** ****     > RTOK
0008 06CD   4B            byte 104 ^ RE
                   < elite.a99
2171                      .char 'S'                                           ; Encoded as:   "[102][104]S"
     **** ****     > CHAR
0004 06CE 70              byte 'S' ^ RE
                   < elite.a99
2172 06CF   00            byte >00
2173               
2174                      .rtok 105                                           ; Token 111:    "FUEL SCOOPS"
     **** ****     > RTOK
0008 06D0 4A              byte 105 ^ RE
                   < elite.a99
2175                      .char ' '                                           ;
     **** ****     > CHAR
0004 06D1   03            byte ' ' ^ RE
                   < elite.a99
2176                      .char 'S'                                           ; Encoded as:   "[105] SCOOPS"
     **** ****     > CHAR
0004 06D2 70              byte 'S' ^ RE
                   < elite.a99
2177                      .char 'C'
     **** ****     > CHAR
0004 06D3   60            byte 'C' ^ RE
                   < elite.a99
2178                      .char 'O'
     **** ****     > CHAR
0004 06D4 6C              byte 'O' ^ RE
                   < elite.a99
2179                      .char 'O'
     **** ****     > CHAR
0004 06D5   6C            byte 'O' ^ RE
                   < elite.a99
2180                      .char 'P'
     **** ****     > CHAR
0004 06D6 73              byte 'P' ^ RE
                   < elite.a99
2181                      .char 'S'
     **** ****     > CHAR
0004 06D7   70            byte 'S' ^ RE
                   < elite.a99
2182 06D8 00              byte >00
2183               
2184 06D9   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' Token 112:    "ESCAPE POD"
2185                      .char 'C'                                           ;
     **** ****     > CHAR
0004 06DA 60              byte 'C' ^ RE
                   < elite.a99
2186                      .char 'A'                                           ; Encoded as:   "<137>CAPE POD"
     **** ****     > CHAR
0004 06DB   62            byte 'A' ^ RE
                   < elite.a99
2187                      .char 'P'
     **** ****     > CHAR
0004 06DC 73              byte 'P' ^ RE
                   < elite.a99
2188                      .char 'E'
     **** ****     > CHAR
0004 06DD   66            byte 'E' ^ RE
                   < elite.a99
2189                      .char ' '
     **** ****     > CHAR
0004 06DE 03              byte ' ' ^ RE
                   < elite.a99
2190                      .char 'P'
     **** ****     > CHAR
0004 06DF   73            byte 'P' ^ RE
                   < elite.a99
2191                      .char 'O'
     **** ****     > CHAR
0004 06E0 6C              byte 'O' ^ RE
                   < elite.a99
2192                      .char 'D'
     **** ****     > CHAR
0004 06E1   67            byte 'D' ^ RE
                   < elite.a99
2193 06E2 00              byte >00
2194               
2195                      .rtok 121                                           ; Token 113:    "ENERGY BOMB"
     **** ****     > RTOK
0008 06E3   5A            byte 121 ^ RE
                   < elite.a99
2196                      .char 'B'                                           ;
     **** ****     > CHAR
0004 06E4 61              byte 'B' ^ RE
                   < elite.a99
2197                      .char 'O'                                           ; Encoded as:   "[121]BOMB"
     **** ****     > CHAR
0004 06E5   6C            byte 'O' ^ RE
                   < elite.a99
2198                      .char 'M'
     **** ****     > CHAR
0004 06E6 6E              byte 'M' ^ RE
                   < elite.a99
2199                      .char 'B'
     **** ****     > CHAR
0004 06E7   61            byte 'B' ^ RE
                   < elite.a99
2200 06E8 00              byte >00
2201               
2202                      .rtok 121                                           ; Token 114:    "ENERGY UNIT"
     **** ****     > RTOK
0008 06E9   5A            byte 121 ^ RE
                   < elite.a99
2203                      .rtok 14                                            ;
     **** ****     > RTOK
0003 06EA 8D              byte (14 + 160) ^ RE
                   < elite.a99
2204 06EB   00            byte >00                                            ; Encoded as:   "[121][14]"
2205               
2206                      .rtok 124                                           ; Token 115:    "DOCKING COMPUTERS"
     **** ****     > RTOK
0008 06EC 5F              byte 124 ^ RE
                   < elite.a99
2207 06ED   AF            byte 140 ^ RE                                       ; TWOK 'I', 'N'
2208                      .char 'G'                                           ; Encoded as:   "[124]<140>G [55]"
     **** ****     > CHAR
0004 06EE 64              byte 'G' ^ RE
                   < elite.a99
2209                      .char ' '
     **** ****     > CHAR
0004 06EF   03            byte ' ' ^ RE
                   < elite.a99
2210                      .rtok 55
     **** ****     > RTOK
0003 06F0 F4              byte (55 + 160) ^ RE
                   < elite.a99
2211 06F1   00            byte >00
2212               
2213                      .rtok 122                                           ; Token 116:    "GALACTIC HYPERSPACE "
     **** ****     > RTOK
0008 06F2 59              byte 122 ^ RE
                   < elite.a99
2214                      .char ' '                                           ;
     **** ****     > CHAR
0004 06F3   03            byte ' ' ^ RE
                   < elite.a99
2215                      .rtok 29                                            ; Encoded as:   "[122] [29]"
     **** ****     > RTOK
0003 06F4 9E              byte (29 + 160) ^ RE
                   < elite.a99
2216 06F5   00            byte >00
2217               
2218                      .char 'A'                                           ; Token 117:    "ALL"
     **** ****     > CHAR
0004 06F6 62              byte 'A' ^ RE
                   < elite.a99
2219                      .rtok 118                                           ;
     **** ****     > RTOK
0008 06F7   55            byte 118 ^ RE
                   < elite.a99
2220 06F8 00              byte >00                                            ; Encoded as:   "A[118]"
2221               
2222                      .char 'L'                                           ; Token 118:    "LL"
     **** ****     > CHAR
0004 06F9   6F            byte 'L' ^ RE
                   < elite.a99
2223                      .char 'L'                                           ;
     **** ****     > CHAR
0004 06FA 6F              byte 'L' ^ RE
                   < elite.a99
2224 06FB   00            byte >00                                            ; Encoded as:   "LL"
2225               
2226                      .rtok 37                                            ; Token 119:    "CASH:{cash} CR{crlf}
     **** ****     > RTOK
0003 06FC E6              byte (37 + 160) ^ RE
                   < elite.a99
2227                      .char ':'                                           ; "
     **** ****     > CHAR
0004 06FD   19            byte ':' ^ RE
                   < elite.a99
2228                      .cont 0                                             ;
     **** ****     > CONT
0001 06FE 23              byte 0 ^ RE
                   < elite.a99
2229 06FF   00            byte >00                                            ; Encoded as:   "[37]:{0}"
2230               
2231 0700 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Token 120:    "INCOMING MISSILE"
2232                      .rtok 91                                            ;
     **** ****     > RTOK
0003 0701   D8            byte (91 + 160) ^ RE
                   < elite.a99
2233 0702 AF              byte 140 ^ RE                                       ; TWOK 'I', 'N' Encoded as:   "<140>[91]<140>G [106]"
2234                      .char 'G'
     **** ****     > CHAR
0004 0703   64            byte 'G' ^ RE
                   < elite.a99
2235                      .char ' '
     **** ****     > CHAR
0004 0704 03              byte ' ' ^ RE
                   < elite.a99
2236                      .rtok 106
     **** ****     > RTOK
0008 0705   49            byte 106 ^ RE
                   < elite.a99
2237 0706 00              byte >00
2238               
2239 0707   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' Token 121:    "ENERGY "
2240 0708 B3              byte 144 ^ RE                                       ; TWOK 'E', 'R'
2241                      .char 'G'                                           ; Encoded as:   "<146><144>GY "
     **** ****     > CHAR
0004 0709   64            byte 'G' ^ RE
                   < elite.a99
2242                      .char 'Y'
     **** ****     > CHAR
0004 070A 7A              byte 'Y' ^ RE
                   < elite.a99
2243                      .char ' '
     **** ****     > CHAR
0004 070B   03            byte ' ' ^ RE
                   < elite.a99
2244 070C 00              byte >00
2245               
2246                      .char 'G'                                           ; Token 122:    "GALACTIC"
     **** ****     > CHAR
0004 070D   64            byte 'G' ^ RE
                   < elite.a99
2247                      .char 'A'                                           ;
     **** ****     > CHAR
0004 070E 62              byte 'A' ^ RE
                   < elite.a99
2248 070F   B6            byte 149 ^ RE                                       ; TWOK 'L', 'A' Encoded as:   "GA<149>C<151>C"
2249                      .char 'C'
     **** ****     > CHAR
0004 0710 60              byte 'C' ^ RE
                   < elite.a99
2250 0711   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2251                      .char 'C'
     **** ****     > CHAR
0004 0712 60              byte 'C' ^ RE
                   < elite.a99
2252 0713   00            byte >00
2253               
2254                      .cont 13                                            ; Token 123:    "{crlf}
     **** ****     > CONT
0001 0714 2E              byte 13 ^ RE
                   < elite.a99
2255                      .rtok 92                                            ; COMMANDER'S NAME? "
     **** ****     > RTOK
0003 0715   DF            byte (92 + 160) ^ RE
                   < elite.a99
2256                      .char '`'                                           ;
     **** ****     > CHAR
0002 0716 04              byte 39 ^ RE
                   < elite.a99
2257                      .char 'S'                                           ; Encoded as:   "{13}[92]'S NAME? "
     **** ****     > CHAR
0004 0717   70            byte 'S' ^ RE
                   < elite.a99
2258                      .char ' '
     **** ****     > CHAR
0004 0718 03              byte ' ' ^ RE
                   < elite.a99
2259                      .char 'N'
     **** ****     > CHAR
0004 0719   6D            byte 'N' ^ RE
                   < elite.a99
2260                      .char 'A'
     **** ****     > CHAR
0004 071A 62              byte 'A' ^ RE
                   < elite.a99
2261                      .char 'M'
     **** ****     > CHAR
0004 071B   6E            byte 'M' ^ RE
                   < elite.a99
2262                      .char 'E'
     **** ****     > CHAR
0004 071C 66              byte 'E' ^ RE
                   < elite.a99
2263                      .char '?'
     **** ****     > CHAR
0004 071D   1C            byte '?' ^ RE
                   < elite.a99
2264                      .char ' '
     **** ****     > CHAR
0004 071E 03              byte ' ' ^ RE
                   < elite.a99
2265 071F   00            byte >00
2266               
2267                      .char 'D'                                           ; Token 124:    "DOCK"
     **** ****     > CHAR
0004 0720 67              byte 'D' ^ RE
                   < elite.a99
2268                      .char 'O'                                           ;
     **** ****     > CHAR
0004 0721   6C            byte 'O' ^ RE
                   < elite.a99
2269                      .char 'C'                                           ; Encoded as:   "DOCK"
     **** ****     > CHAR
0004 0722 60              byte 'C' ^ RE
                   < elite.a99
2270                      .char 'K'
     **** ****     > CHAR
0004 0723   68            byte 'K' ^ RE
                   < elite.a99
2271 0724 00              byte >00
2272               
2273                      .cont 5                                             ; Token 125:    "FUEL: {fuel level} LIGHT YEARS{crlf}
     **** ****     > CONT
0001 0725   26            byte 5 ^ RE
                   < elite.a99
2274 0726 A2              byte 129 ^ RE                                       ; TWOK 'L', 'E' CASH:{cash} CR{crlf}
2275                      .char 'G'                                           ; LEGAL STATUS:"
     **** ****     > CHAR
0004 0727   64            byte 'G' ^ RE
                   < elite.a99
2276 0728 A3              byte 128 ^ RE                                       ; TWOK 'A', 'L'
2277                      .char ' '                                           ; Encoded as:   "{5}<129>G<128> [43]<145><136>:"
     **** ****     > CHAR
0004 0729   03            byte ' ' ^ RE
                   < elite.a99
2278                      .rtok 43
     **** ****     > RTOK
0003 072A E8              byte (43 + 160) ^ RE
                   < elite.a99
2279 072B   B2            byte 145 ^ RE                                       ; TWOK 'A', 'T' null
2280 072C AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2281                      .char ':'
     **** ****     > CHAR
0004 072D   19            byte ':' ^ RE
                   < elite.a99
2282 072E 00              byte >00
2283               
2284                      .rtok 92                                            ; Token 126:    "COMMANDER {commander name}{crlf}
     **** ****     > RTOK
0003 072F   DF            byte (92 + 160) ^ RE
                   < elite.a99
2285                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 0730 03              byte ' ' ^ RE
                   < elite.a99
2286                      .cont 4                                             ; {crlf}
     **** ****     > CONT
0001 0731   27            byte 4 ^ RE
                   < elite.a99
2287                      .cont 13                                            ; {sentence case}PRESENT SYSTEM{tab to
     **** ****     > CONT
0001 0732 2E              byte 13 ^ RE
                   < elite.a99
2288                      .cont 13                                            ; column 21}:{current system name}{crlf}
     **** ****     > CONT
0001 0733   2E            byte 13 ^ RE
                   < elite.a99
2289                      .cont 13                                            ; HYPERSPACE SYSTEM{tab to column 21}:
     **** ****     > CONT
0001 0734 2E              byte 13 ^ RE
                   < elite.a99
2290                      .cont 6                                             ; {selected system name}{crlf}
     **** ****     > CONT
0001 0735   25            byte 6 ^ RE
                   < elite.a99
2291                      .rtok 145                                           ; CONDITION{tab to column 21}:"
     **** ****     > RTOK
0006 0736 3C              byte (145 - 114) ^ RE
                   < elite.a99
2292                      .char ' '                                           ;
     **** ****     > CHAR
0004 0737   03            byte ' ' ^ RE
                   < elite.a99
2293                      .rtok 5                                             ; Encoded as:   "[92] {4}{13}{13}{13}{6}[145] [5]{9}{2}
     **** ****     > RTOK
0003 0738 86              byte (5 + 160) ^ RE
                   < elite.a99
2294                      .cont 9                                             ; {13}[29][5]{9}{3}{13}C<159><141><151>
     **** ****     > CONT
0001 0739   2A            byte 9 ^ RE
                   < elite.a99
2295                      .cont 2                                             ; <159>{9}"
     **** ****     > CONT
0001 073A 21              byte 2 ^ RE
                   < elite.a99
2296                      .cont 13
     **** ****     > CONT
0001 073B   2E            byte 13 ^ RE
                   < elite.a99
2297                      .rtok 29
     **** ****     > RTOK
0003 073C 9E              byte (29 + 160) ^ RE
                   < elite.a99
2298                      .rtok 5
     **** ****     > RTOK
0003 073D   86            byte (5 + 160) ^ RE
                   < elite.a99
2299                      .cont 9
     **** ****     > CONT
0001 073E 2A              byte 9 ^ RE
                   < elite.a99
2300                      .cont 3
     **** ****     > CONT
0001 073F   20            byte 3 ^ RE
                   < elite.a99
2301                      .cont 13
     **** ****     > CONT
0001 0740 2E              byte 13 ^ RE
                   < elite.a99
2302                      .char 'C'
     **** ****     > CHAR
0004 0741   60            byte 'C' ^ RE
                   < elite.a99
2303 0742 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2304 0743   AE            byte 141 ^ RE                                       ; TWOK 'D', 'I' null
2305 0744 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2306 0745   BC            byte 159 ^ RE                                       ; TWOK 'O', 'N' null
2307                      .cont 9
     **** ****     > CONT
0001 0746 2A              byte 9 ^ RE
                   < elite.a99
2308 0747   00            byte >00
2309               
2310                      .char 'I'                                           ; Token 127:    "ITEM"
     **** ****     > CHAR
0004 0748 6A              byte 'I' ^ RE
                   < elite.a99
2311 0749   BF            byte 156 ^ RE                                       ; TWOK 'T', 'E'
2312                      .char 'M'                                           ; Encoded as:   "I<156>M"
     **** ****     > CHAR
0004 074A 6E              byte 'M' ^ RE
                   < elite.a99
2313 074B   00            byte >00
2314               
2315                      .char ' '                                           ; Token 128:    "  LOAD NEW COMMANDER (Y/N)?{crlf}
     **** ****     > CHAR
0004 074C 03              byte ' ' ^ RE
                   < elite.a99
2316                      .char ' '                                           ; {crlf}
     **** ****     > CHAR
0004 074D   03            byte ' ' ^ RE
                   < elite.a99
2317                      .char 'L'                                           ; "
     **** ****     > CHAR
0004 074E 6F              byte 'L' ^ RE
                   < elite.a99
2318                      .char 'O'                                           ;
     **** ****     > CHAR
0004 074F   6C            byte 'O' ^ RE
                   < elite.a99
2319                      .char 'A'                                           ; Encoded as:   "  LOAD NEW [92] [65]{13}{13}"
     **** ****     > CHAR
0004 0750 62              byte 'A' ^ RE
                   < elite.a99
2320                      .char 'D'
     **** ****     > CHAR
0004 0751   67            byte 'D' ^ RE
                   < elite.a99
2321                      .char ' '
     **** ****     > CHAR
0004 0752 03              byte ' ' ^ RE
                   < elite.a99
2322                      .char 'N'
     **** ****     > CHAR
0004 0753   6D            byte 'N' ^ RE
                   < elite.a99
2323                      .char 'E'
     **** ****     > CHAR
0004 0754 66              byte 'E' ^ RE
                   < elite.a99
2324                      .char 'W'
     **** ****     > CHAR
0004 0755   74            byte 'W' ^ RE
                   < elite.a99
2325                      .char ' '
     **** ****     > CHAR
0004 0756 03              byte ' ' ^ RE
                   < elite.a99
2326                      .rtok 92
     **** ****     > RTOK
0003 0757   DF            byte (92 + 160) ^ RE
                   < elite.a99
2327                      .char ' '
     **** ****     > CHAR
0004 0758 03              byte ' ' ^ RE
                   < elite.a99
2328                      .rtok 65
     **** ****     > RTOK
0003 0759   C2            byte (65 + 160) ^ RE
                   < elite.a99
2329                      .cont 13
     **** ****     > CONT
0001 075A 2E              byte 13 ^ RE
                   < elite.a99
2330                      .cont 13
     **** ****     > CONT
0001 075B   2E            byte 13 ^ RE
                   < elite.a99
2331 075C 00              byte >00
2332               
2333                      .cont 6                                             ; Token 129:    "{sentence case}DOCKED"
     **** ****     > CONT
0001 075D   25            byte 6 ^ RE
                   < elite.a99
2334                      .rtok 124                                           ;
     **** ****     > RTOK
0008 075E 5F              byte 124 ^ RE
                   < elite.a99
2335 075F   BB            byte 152 ^ RE                                       ; TWOK 'E', 'D' Encoded as:   "{6}[124]<152>"
2336 0760 00              byte >00
2337               
2338 0761   B7            byte 148 ^ RE                                       ; TWOK 'R', 'A' Token 130:    "RATING:"
2339 0762 B4              byte 151 ^ RE                                       ; TWOK 'T', 'I'
2340                      .char 'N'                                           ; Encoded as:   "<148><151>NG:"
     **** ****     > CHAR
0004 0763   6D            byte 'N' ^ RE
                   < elite.a99
2341                      .char 'G'
     **** ****     > CHAR
0004 0764 64              byte 'G' ^ RE
                   < elite.a99
2342                      .char ':'
     **** ****     > CHAR
0004 0765   19            byte ':' ^ RE
                   < elite.a99
2343 0766 00              byte >00
2344               
2345                      .char ' '                                           ; Token 131:    " ON "
     **** ****     > CHAR
0004 0767   03            byte ' ' ^ RE
                   < elite.a99
2346 0768 BC              byte 159 ^ RE                                       ; TWOK 'O', 'N'
2347                      .char ' '                                           ; Encoded as:   " <159> "
     **** ****     > CHAR
0004 0769   03            byte ' ' ^ RE
                   < elite.a99
2348 076A 00              byte >00
2349               
2350                      .cont 13                                            ; Token 132:    "{crlf}
     **** ****     > CONT
0001 076B   2E            byte 13 ^ RE
                   < elite.a99
2351                      .cont 8                                             ; {all caps}EQUIPMENT: {sentence case}"
     **** ****     > CONT
0001 076C 2B              byte 8 ^ RE
                   < elite.a99
2352                      .rtok 47                                            ;
     **** ****     > RTOK
0003 076D   EC            byte (47 + 160) ^ RE
                   < elite.a99
2353                      .char 'M'                                           ; Encoded as:   "{13}{8}[47]M<146>T:{6}"
     **** ****     > CHAR
0004 076E 6E              byte 'M' ^ RE
                   < elite.a99
2354 076F   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2355                      .char 'T'
     **** ****     > CHAR
0004 0770 77              byte 'T' ^ RE
                   < elite.a99
2356                      .char ':'
     **** ****     > CHAR
0004 0771   19            byte ':' ^ RE
                   < elite.a99
2357                      .cont 6
     **** ****     > CONT
0001 0772 25              byte 6 ^ RE
                   < elite.a99
2358 0773   00            byte >00
2359               
2360                      .char 'C'                                           ; Token 133:    "CLEAN"
     **** ****     > CHAR
0004 0774 60              byte 'C' ^ RE
                   < elite.a99
2361 0775   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E'
2362 0776 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N' Encoded as:   "C<129><155>"
2363 0777   00            byte >00
2364               
2365                      .char 'O'                                           ; Token 134:    "OFFENDER"
     **** ****     > CHAR
0004 0778 6C              byte 'O' ^ RE
                   < elite.a99
2366                      .char 'F'                                           ;
     **** ****     > CHAR
0004 0779   65            byte 'F' ^ RE
                   < elite.a99
2367                      .char 'F'                                           ; Encoded as:   "OFF<146>D<144>"
     **** ****     > CHAR
0004 077A 65              byte 'F' ^ RE
                   < elite.a99
2368 077B   B1            byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2369                      .char 'D'
     **** ****     > CHAR
0004 077C 67              byte 'D' ^ RE
                   < elite.a99
2370 077D   B3            byte 144 ^ RE                                       ; TWOK 'E', 'R' null
2371 077E 00              byte >00
2372               
2373                      .char 'F'                                           ; Token 135:    "FUGITIVE"
     **** ****     > CHAR
0004 077F   65            byte 'F' ^ RE
                   < elite.a99
2374                      .char 'U'                                           ;
     **** ****     > CHAR
0004 0780 76              byte 'U' ^ RE
                   < elite.a99
2375                      .char 'G'                                           ; Encoded as:   "FUGI<151><150>"
     **** ****     > CHAR
0004 0781   64            byte 'G' ^ RE
                   < elite.a99
2376                      .char 'I'
     **** ****     > CHAR
0004 0782 6A              byte 'I' ^ RE
                   < elite.a99
2377 0783   B4            byte 151 ^ RE                                       ; TWOK 'T', 'I' null
2378 0784 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2379 0785   00            byte >00
2380               
2381                      .char 'H'                                           ; Token 136:    "HARMLESS"
     **** ****     > CHAR
0004 0786 6B              byte 'H' ^ RE
                   < elite.a99
2382 0787   A9            byte 138 ^ RE                                       ; TWOK 'A', 'R'
2383                      .char 'M'                                           ; Encoded as:   "H<138>M<129>SS"
     **** ****     > CHAR
0004 0788 6E              byte 'M' ^ RE
                   < elite.a99
2384 0789   A2            byte 129 ^ RE                                       ; TWOK 'L', 'E' null
2385                      .char 'S'
     **** ****     > CHAR
0004 078A 70              byte 'S' ^ RE
                   < elite.a99
2386                      .char 'S'
     **** ****     > CHAR
0004 078B   70            byte 'S' ^ RE
                   < elite.a99
2387 078C 00              byte >00
2388               
2389                      .char 'M'                                           ; Token 137:    "MOSTLY HARMLESS"
     **** ****     > CHAR
0004 078D   6E            byte 'M' ^ RE
                   < elite.a99
2390                      .char 'O'                                           ;
     **** ****     > CHAR
0004 078E 6C              byte 'O' ^ RE
                   < elite.a99
2391                      .rtok 43                                            ; Encoded as:   "MO[43]LY [136]"
     **** ****     > RTOK
0003 078F   E8            byte (43 + 160) ^ RE
                   < elite.a99
2392                      .char 'L'
     **** ****     > CHAR
0004 0790 6F              byte 'L' ^ RE
                   < elite.a99
2393                      .char 'Y'
     **** ****     > CHAR
0004 0791   7A            byte 'Y' ^ RE
                   < elite.a99
2394                      .char ' '
     **** ****     > CHAR
0004 0792 03              byte ' ' ^ RE
                   < elite.a99
2395                      .rtok 136
     **** ****     > RTOK
0006 0793   35            byte (136 - 114) ^ RE
                   < elite.a99
2396 0794 00              byte >00
2397               
2398                      .rtok 12                                            ; Token 138:    "POOR "
     **** ****     > RTOK
0003 0795   8F            byte (12 + 160) ^ RE
                   < elite.a99
2399 0796 00              byte >00                                            ;
2400                                                                          ; Encoded as:   "[12]"
2401               
2402                      .rtok 11                                            ; Token 139:    "AVERAGE "
     **** ****     > RTOK
0003 0797   88            byte (11 + 160) ^ RE
                   < elite.a99
2403 0798 00              byte >00                                            ;
2404                                                                          ; Encoded as:   "[11]"
2405               
2406                      .char 'A'                                           ; Token 140:    "ABOVE AVERAGE "
     **** ****     > CHAR
0004 0799   62            byte 'A' ^ RE
                   < elite.a99
2407                      .char 'B'                                           ;
     **** ****     > CHAR
0004 079A 61              byte 'B' ^ RE
                   < elite.a99
2408                      .char 'O'                                           ; Encoded as:   "ABO<150> [11]"
     **** ****     > CHAR
0004 079B   6C            byte 'O' ^ RE
                   < elite.a99
2409 079C B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2410                      .char ' '
     **** ****     > CHAR
0004 079D   03            byte ' ' ^ RE
                   < elite.a99
2411                      .rtok 11
     **** ****     > RTOK
0003 079E 88              byte (11 + 160) ^ RE
                   < elite.a99
2412 079F   00            byte >00
2413               
2414                      .rtok 91                                            ; Token 141:    "COMPETENT"
     **** ****     > RTOK
0003 07A0 D8              byte (91 + 160) ^ RE
                   < elite.a99
2415                      .char 'P'                                           ;
     **** ****     > CHAR
0004 07A1   73            byte 'P' ^ RE
                   < elite.a99
2416                      .char 'E'                                           ; Encoded as:   "[91]PET<146>T"
     **** ****     > CHAR
0004 07A2 66              byte 'E' ^ RE
                   < elite.a99
2417                      .char 'T'
     **** ****     > CHAR
0004 07A3   77            byte 'T' ^ RE
                   < elite.a99
2418 07A4 B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2419                      .char 'T'
     **** ****     > CHAR
0004 07A5   77            byte 'T' ^ RE
                   < elite.a99
2420 07A6 00              byte >00
2421               
2422                      .char 'D'                                           ; Token 142:    "DANGEROUS"
     **** ****     > CHAR
0004 07A7   67            byte 'D' ^ RE
                   < elite.a99
2423 07A8 B8              byte 155 ^ RE                                       ; TWOK 'A', 'N'
2424 07A9   A0            byte 131 ^ RE                                       ; TWOK 'G', 'E' Encoded as:   "D<155><131>RO<136>"
2425                      .char 'R'
     **** ****     > CHAR
0004 07AA 71              byte 'R' ^ RE
                   < elite.a99
2426                      .char 'O'
     **** ****     > CHAR
0004 07AB   6C            byte 'O' ^ RE
                   < elite.a99
2427 07AC AB              byte 136 ^ RE                                       ; TWOK 'U', 'S' null
2428 07AD   00            byte >00
2429               
2430                      .char 'D'                                           ; Token 143:    "DEADLY"
     **** ****     > CHAR
0004 07AE 67              byte 'D' ^ RE
                   < elite.a99
2431                      .char 'E'                                           ;
     **** ****     > CHAR
0004 07AF   66            byte 'E' ^ RE
                   < elite.a99
2432                      .char 'A'                                           ; Encoded as:   "DEADLY"
     **** ****     > CHAR
0004 07B0 62              byte 'A' ^ RE
                   < elite.a99
2433                      .char 'D'
     **** ****     > CHAR
0004 07B1   67            byte 'D' ^ RE
                   < elite.a99
2434                      .char 'L'
     **** ****     > CHAR
0004 07B2 6F              byte 'L' ^ RE
                   < elite.a99
2435                      .char 'Y'
     **** ****     > CHAR
0004 07B3   7A            byte 'Y' ^ RE
                   < elite.a99
2436 07B4 00              byte >00
2437               
2438                      .char '-'                                           ; Token 144:    "---- E L I T E ----"
     **** ****     > CHAR
0004 07B5   0E            byte '-' ^ RE
                   < elite.a99
2439                      .char '-'                                           ;
     **** ****     > CHAR
0004 07B6 0E              byte '-' ^ RE
                   < elite.a99
2440                      .char '-'                                           ; Encoded as:   "---- E L I T E ----"
     **** ****     > CHAR
0004 07B7   0E            byte '-' ^ RE
                   < elite.a99
2441                      .char '-'
     **** ****     > CHAR
0004 07B8 0E              byte '-' ^ RE
                   < elite.a99
2442                      .char ' '
     **** ****     > CHAR
0004 07B9   03            byte ' ' ^ RE
                   < elite.a99
2443                      .char 'E'
     **** ****     > CHAR
0004 07BA 66              byte 'E' ^ RE
                   < elite.a99
2444                      .char ' '
     **** ****     > CHAR
0004 07BB   03            byte ' ' ^ RE
                   < elite.a99
2445                      .char 'L'
     **** ****     > CHAR
0004 07BC 6F              byte 'L' ^ RE
                   < elite.a99
2446                      .char ' '
     **** ****     > CHAR
0004 07BD   03            byte ' ' ^ RE
                   < elite.a99
2447                      .char 'I'
     **** ****     > CHAR
0004 07BE 6A              byte 'I' ^ RE
                   < elite.a99
2448                      .char ' '
     **** ****     > CHAR
0004 07BF   03            byte ' ' ^ RE
                   < elite.a99
2449                      .char 'T'
     **** ****     > CHAR
0004 07C0 77              byte 'T' ^ RE
                   < elite.a99
2450                      .char ' '
     **** ****     > CHAR
0004 07C1   03            byte ' ' ^ RE
                   < elite.a99
2451                      .char 'E'
     **** ****     > CHAR
0004 07C2 66              byte 'E' ^ RE
                   < elite.a99
2452                      .char ' '
     **** ****     > CHAR
0004 07C3   03            byte ' ' ^ RE
                   < elite.a99
2453                      .char '-'
     **** ****     > CHAR
0004 07C4 0E              byte '-' ^ RE
                   < elite.a99
2454                      .char '-'
     **** ****     > CHAR
0004 07C5   0E            byte '-' ^ RE
                   < elite.a99
2455                      .char '-'
     **** ****     > CHAR
0004 07C6 0E              byte '-' ^ RE
                   < elite.a99
2456                      .char '-'
     **** ****     > CHAR
0004 07C7   0E            byte '-' ^ RE
                   < elite.a99
2457 07C8 00              byte >00
2458               
2459                      .char 'P'                                           ; Token 145:    "PRESENT"
     **** ****     > CHAR
0004 07C9   73            byte 'P' ^ RE
                   < elite.a99
2460 07CA AD              byte 142 ^ RE                                       ; TWOK 'R', 'E'
2461                      .char 'S'                                           ; Encoded as:   "P<142>S<146>T"
     **** ****     > CHAR
0004 07CB   70            byte 'S' ^ RE
                   < elite.a99
2462 07CC B1              byte 146 ^ RE                                       ; TWOK 'E', 'N' null
2463                      .char 'T'
     **** ****     > CHAR
0004 07CD   77            byte 'T' ^ RE
                   < elite.a99
2464 07CE 00              byte >00
2465               
2466                      .cont 8                                             ; Token 146:    "{all caps}GAME OVER"
     **** ****     > CONT
0001 07CF   2B            byte 8 ^ RE
                   < elite.a99
2467                      .char 'G'                                           ;
     **** ****     > CHAR
0004 07D0 64              byte 'G' ^ RE
                   < elite.a99
2468                      .char 'A'                                           ; Encoded as:   "{8}GAME O<150>R"
     **** ****     > CHAR
0004 07D1   62            byte 'A' ^ RE
                   < elite.a99
2469                      .char 'M'
     **** ****     > CHAR
0004 07D2 6E              byte 'M' ^ RE
                   < elite.a99
2470                      .char 'E'
     **** ****     > CHAR
0004 07D3   66            byte 'E' ^ RE
                   < elite.a99
2471                      .char ' '
     **** ****     > CHAR
0004 07D4 03              byte ' ' ^ RE
                   < elite.a99
2472                      .char 'O'
     **** ****     > CHAR
0004 07D5   6C            byte 'O' ^ RE
                   < elite.a99
2473 07D6 B5              byte 150 ^ RE                                       ; TWOK 'V', 'E' null
2474                      .char 'R'
     **** ****     > CHAR
0004 07D7   71            byte 'R' ^ RE
                   < elite.a99
2475 07D8 00              byte >00
2476               
2477                      .char 'P'                                           ; Token 147:    "PRESS FIRE OR SPACE,COMMANDER.{crlf}
     **** ****     > CHAR
0004 07D9   73            byte 'P' ^ RE
                   < elite.a99
2478                      .char 'R'                                           ; {crlf}
     **** ****     > CHAR
0004 07DA 71              byte 'R' ^ RE
                   < elite.a99
2479 07DB   AA            byte 137 ^ RE                                       ; TWOK 'E', 'S' "
2480                      .char 'S'                                           ;
     **** ****     > CHAR
0004 07DC 70              byte 'S' ^ RE
                   < elite.a99
2481                      .char ' '                                           ; Encoded as:   "PR<137>S FI<142> <153> SPA<133>,[92].
     **** ****     > CHAR
0004 07DD   03            byte ' ' ^ RE
                   < elite.a99
2482                      .char 'F'                                           ; {13}{13}"
     **** ****     > CHAR
0004 07DE 65              byte 'F' ^ RE
                   < elite.a99
2483                      .char 'I'
     **** ****     > CHAR
0004 07DF   6A            byte 'I' ^ RE
                   < elite.a99
2484 07E0 AD              byte 142 ^ RE                                       ; TWOK 'R', 'E' null
2485                      .char ' '
     **** ****     > CHAR
0004 07E1   03            byte ' ' ^ RE
                   < elite.a99
2486 07E2 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2487                      .char ' '
     **** ****     > CHAR
0004 07E3   03            byte ' ' ^ RE
                   < elite.a99
2488                      .char 'S'
     **** ****     > CHAR
0004 07E4 70              byte 'S' ^ RE
                   < elite.a99
2489                      .char 'P'
     **** ****     > CHAR
0004 07E5   73            byte 'P' ^ RE
                   < elite.a99
2490                      .char 'A'
     **** ****     > CHAR
0004 07E6 62              byte 'A' ^ RE
                   < elite.a99
2491 07E7   A6            byte 133 ^ RE                                       ; TWOK 'C', 'E' null
2492                      .char ','
     **** ****     > CHAR
0004 07E8 0F              byte ',' ^ RE
                   < elite.a99
2493                      .rtok 92
     **** ****     > RTOK
0003 07E9   DF            byte (92 + 160) ^ RE
                   < elite.a99
2494                      .char '.'
     **** ****     > CHAR
0004 07EA 0D              byte '.' ^ RE
                   < elite.a99
2495                      .cont 13
     **** ****     > CONT
0001 07EB   2E            byte 13 ^ RE
                   < elite.a99
2496                      .cont 13
     **** ****     > CONT
0001 07EC 2E              byte 13 ^ RE
                   < elite.a99
2497 07ED   00            byte >00
2498               
2499                      .char '('                                           ; Token 148:    "(C) ACORNSOFT 1984"
     **** ****     > CHAR
0004 07EE 0B              byte '(' ^ RE
                   < elite.a99
2500                      .char 'C'                                           ;
     **** ****     > CHAR
0004 07EF   60            byte 'C' ^ RE
                   < elite.a99
2501                      .char ')'                                           ; Encoded as:   "(C) AC<153>N<135>FT 1984"
     **** ****     > CHAR
0004 07F0 0A              byte ')' ^ RE
                   < elite.a99
2502                      .char ' '
     **** ****     > CHAR
0004 07F1   03            byte ' ' ^ RE
                   < elite.a99
2503                      .char 'A'
     **** ****     > CHAR
0004 07F2 62              byte 'A' ^ RE
                   < elite.a99
2504                      .char 'C'
     **** ****     > CHAR
0004 07F3   60            byte 'C' ^ RE
                   < elite.a99
2505 07F4 BA              byte 153 ^ RE                                       ; TWOK 'O', 'R' null
2506                      .char 'N'
     **** ****     > CHAR
0004 07F5   6D            byte 'N' ^ RE
                   < elite.a99
2507 07F6 A4              byte 135 ^ RE                                       ; TWOK 'S', 'O' null
2508                      .char 'F'
     **** ****     > CHAR
0004 07F7   65            byte 'F' ^ RE
                   < elite.a99
2509                      .char 'T'
     **** ****     > CHAR
0004 07F8 77              byte 'T' ^ RE
                   < elite.a99
2510                      .char ' '
     **** ****     > CHAR
0004 07F9   03            byte ' ' ^ RE
                   < elite.a99
2511                      .char '1'
     **** ****     > CHAR
0004 07FA 12              byte '1' ^ RE
                   < elite.a99
2512                      .char '9'
     **** ****     > CHAR
0004 07FB   1A            byte '9' ^ RE
                   < elite.a99
2513                      .char '8'
     **** ****     > CHAR
0004 07FC 1B              byte '8' ^ RE
                   < elite.a99
2514                      .char '4'
     **** ****     > CHAR
0004 07FD   17            byte '4' ^ RE
                   < elite.a99
2515 07FE 00              byte >00
2516               
2517               * ******************************************************************************
2518               *
2519               * Save WORDS9.bin
2520               *
2521               * ******************************************************************************
2522               
2523                      ; PRINT "WORDS9"
2524                      ; PRINT "Assembled at ", ~CODE_WORDS%
2525                      ; PRINT "Ends at ", ~P%
2526                      ; PRINT "Code size is ", ~(P% - CODE_WORDS%)
2527                      ; PRINT "Execute at ", ~LOAD_WORDS%
2528                      ; PRINT "Reload at ", ~LOAD_WORDS%
2529               
2530                      ; PRINT "S.WORDS9 ",~CODE_WORDS%," ",~P%," ",~LOAD_WORDS%," ",~LOAD_WORDS%
2531                      ; SAVE "3-assembled-output/WORDS9.bin", CODE_WORDS%, P%, LOAD_WORDS%
2532               
2533               * ******************************************************************************
2534               *
2535               * Name: K%
2536               * Type: Workspace
2537               * Address: &0900 to &0AAF
2538               * Category: Workspaces
2539               * Summary: Ship data blocks and ship line heaps
2540               * Deep dive: Ship data blocks
2541               * The local bubble of universe
2542               *
2543               * ------------------------------------------------------------------------------
2544               *
2545               * Contains ship data for all the ships, planets, suns and space stations in our
2546               * local bubble of universe, along with their corresponding ship line heaps.
2547               *
2548               * The blocks are pointed to by the lookup table at location UNIV. The first 432
2549               * bytes of the K% workspace hold ship data on up to 12 ships, with 36 (NI%)
2550               * bytes per ship, and the ship line heap grows downwards from WP at the end of
2551               * the K% workspace.
2552               *
2553               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
2554               * the deep dive on "The local bubble of universe" for details of how Elite
2555               * stores the local universe in K%, FRIN and UNIV.
2556               *
2557               * ******************************************************************************
2558               
2559                      aorg K.
2560               
2561 0900                 bss NOSH * NI.                                      ; Ship data blocks and ship line heap
2562               
2563               * ******************************************************************************
2564               *
2565               * Name: WP
2566               * Type: Workspace
2567               * Address: &0D40 to &0F33
2568               * Category: Workspaces
2569               * Summary: Ship slots, variables
2570               *
2571               * ******************************************************************************
2572               
2573                      aorg WP.
2574               
2575 0D40                 bss 0                                               ; The start of the WP workspace
2576               
2577               FRIN:
2578 0D40                 bss NOSH + 1                                        ; Slots for the ships in the local bubble of universe
2579                                                                          ;
2580                                                                          ; There are #NOSH + 1 slots, but the ship-spawning
2581                                                                          ; routine at NWSHP only populates #NOSH of them, so
2582                                                                          ; there are 13 slots but only 12 are used for ships
2583                                                                          ; (the last slot is effectively used as a null
2584                                                                          ; terminator when shuffling the slots down in the
2585                                                                          ; KILLSHP routine)
2586                                                                          ;
2587                                                                          ; See the deep dive on "The local bubble of universe"
2588                                                                          ; for details of how Elite stores the local universe in
2589                                                                          ; FRIN, UNIV and K%
2590               
2591               CABTMP:
2592 0D4D                 bss 0                                               ; Cabin temperature
2593                                                                          ;
2594                                                                          ; The ambient cabin temperature in deep space is 30,
2595                                                                          ; which is displayed as one notch on the dashboard bar
2596                                                                          ;
2597                                                                          ; We get higher temperatures closer to the sun
2598                                                                          ;
2599                                                                          ; CABTMP shares a location with MANY, but that's OK as
2600                                                                          ; MANY+0 would contain the number of ships of type 0,
2601                                                                          ; and as there is no ship type 0 (they start at 1), the
2602                                                                          ; byte at MANY+0 is not used for storing a ship type
2603                                                                          ; and can be used for the cabin temperature instead
2604               
2605               MANY:
2606 0D4D                 bss SST                                             ; The number of ships of each type in the local bubble
2607                                                                          ; of universe
2608                                                                          ;
2609                                                                          ; The number of ships of type X in the local bubble is
2610                                                                          ; stored at MANY+X
2611                                                                          ;
2612                                                                          ; See the deep dive on "Ship blueprints" for a list of
2613                                                                          ; ship types
2614               
2615               SSPR:
2616 0D55                 bss NTY + 1 - SST                                   ; "Space station present" flag
2617                                                                          ;
2618                                                                          ; * Non-zero if we are inside the space station's safe
2619                                                                          ; zone
2620                                                                          ;
2621                                                                          ; * 0 if we aren't (in which case we can show the sun)
2622                                                                          ;
2623                                                                          ; This flag is at MANY+SST, which is no coincidence, as
2624                                                                          ; MANY+SST is a count of how many space stations there
2625                                                                          ; are in our local bubble, which is the same as saying
2626                                                                          ; "space station present"
2627               
2628               ECMP:
2629 0D5B                 bss 1                                               ; Our E.C.M. status
2630                                                                          ;
2631                                                                          ; * 0 = E.C.M. is off
2632                                                                          ;
2633                                                                          ; * Non-zero = E.C.M. is on
2634               
2635               MJ:
2636 0D5C                 bss 1                                               ; Are we in witchspace (i.e. have we mis-jumped)?
2637                                                                          ;
2638                                                                          ; * 0 = no, we are in normal space
2639                                                                          ;
2640                                                                          ; * &FF = yes, we are in witchspace
2641               
2642               LAS2:
2643 0D5D                 bss 1                                               ; Laser power for the current laser
2644                                                                          ;
2645                                                                          ; * Bits 0-6 contain the laser power of the current
2646                                                                          ; space view
2647                                                                          ;
2648                                                                          ; * Bit 7 denotes whether or not the laser pulses:
2649                                                                          ;
2650                                                                          ; * 0 = pulsing laser
2651                                                                          ;
2652                                                                          ; * 1 = beam laser (i.e. always on)
2653               
2654               MSAR:
2655 0D5E                 bss 1                                               ; The targeting state of our leftmost missile
2656                                                                          ;
2657                                                                          ; * 0 = missile is not looking for a target, or it
2658                                                                          ; already has a target lock (indicator is not
2659                                                                          ; yellow/white)
2660                                                                          ;
2661                                                                          ; * Non-zero = missile is currently looking for a
2662                                                                          ; target (indicator is yellow/white)
2663               
2664               VIEW:
2665 0D5F                 bss 1                                               ; The number of the current space view
2666                                                                          ;
2667                                                                          ; * 0 = front
2668                                                                          ; * 1 = rear
2669                                                                          ; * 2 = left
2670                                                                          ; * 3 = right
2671               
2672               LASCT:
2673 0D60                 bss 1                                               ; The laser pulse count for the current laser
2674                                                                          ;
2675                                                                          ; This is a counter that defines the gap between the
2676                                                                          ; pulses of a pulse laser. It is set as follows:
2677                                                                          ;
2678                                                                          ; * 0 for a beam laser
2679                                                                          ;
2680                                                                          ; * 10 for a pulse laser
2681                                                                          ;
2682                                                                          ; It gets decremented every vertical sync (in the LINSCN
2683                                                                          ; routine, which is called 50 times a second) and is set
2684                                                                          ; to a non-zero value for pulse lasers only
2685                                                                          ;
2686                                                                          ; The laser only fires when the value of LASCT hits
2687                                                                          ; zero, so for pulse lasers with a value of 10, that
2688                                                                          ; means the laser fires once every 10 vertical syncs (or
2689                                                                          ; 5 times a second)
2690                                                                          ;
2691                                                                          ; In comparison, beam lasers fire continuously as the
2692                                                                          ; value of LASCT is always 0
2693               
2694               GNTMP:
2695 0D61                 bss 1                                               ; Laser temperature (or "gun temperature")
2696                                                                          ;
2697                                                                          ; If the laser temperature exceeds 242 then the laser
2698                                                                          ; overheats and cannot be fired again until it has
2699                                                                          ; cooled down
2700               
2701               HFX:
2702 0D62                 bss 1                                               ; A flag that toggles the hyperspace colour effect
2703                                                                          ;
2704                                                                          ; * 0 = no colour effect
2705                                                                          ;
2706                                                                          ; * Non-zero = hyperspace colour effect enabled
2707                                                                          ;
2708                                                                          ; When HFX is set to 1, the mode 4 screen that makes
2709                                                                          ; up the top part of the display is temporarily switched
2710                                                                          ; to mode 5 (the same screen mode as the dashboard),
2711                                                                          ; which has the effect of blurring and colouring the
2712                                                                          ; hyperspace rings in the top part of the screen. The
2713                                                                          ; code to do this is in the LINSCN routine, which is
2714                                                                          ; called as part of the screen mode routine at IRQ1.
2715                                                                          ; It's in LINSCN that HFX is checked, and if it is
2716                                                                          ; non-zero, the top part of the screen is not switched
2717                                                                          ; to mode 4, thus leaving the top part of the screen in
2718                                                                          ; the more colourful mode 5
2719               
2720               EV:
2721 0D63                 bss 1                                               ; The "extra vessels" spawning counter
2722                                                                          ;
2723                                                                          ; This counter is set to 0 on arrival in a system and
2724                                                                          ; following an in-system jump, and is bumped up when we
2725                                                                          ; spawn bounty hunters or pirates (i.e. "extra vessels")
2726                                                                          ;
2727                                                                          ; It decreases by 1 each time we consider spawning more
2728                                                                          ; "extra vessels" in part 4 of the main game loop, so
2729                                                                          ; increasing the value of EV has the effect of delaying
2730                                                                          ; the spawning of more vessels
2731                                                                          ;
2732                                                                          ; In other words, this counter stops bounty hunters and
2733                                                                          ; pirates from continually appearing, and ensures that
2734                                                                          ; there's a delay between spawnings
2735               
2736               DLY:
2737 0D64                 bss 1                                               ; In-flight message delay
2738                                                                          ;
2739                                                                          ; This counter is used to keep an in-flight message up
2740                                                                          ; for a specified time before it gets removed. The value
2741                                                                          ; in DLY is decremented each time we start another
2742                                                                          ; iteration of the main game loop at TT100
2743               
2744               de_:
2745 0D65                 bss 1                                               ; Equipment destruction flag
2746                                                                          ;
2747                                                                          ; * Bit 1 denotes whether or not the in-flight message
2748                                                                          ; about to be shown by the MESS routine is about
2749                                                                          ; destroyed equipment:
2750                                                                          ;
2751                                                                          ; * 0 = the message is shown normally
2752                                                                          ;
2753                                                                          ; * 1 = the string " DESTROYED" gets added to the
2754                                                                          ; end of the message
2755               
2756               LSX:
2757 0D66                 bss 0                                               ; LSX is an alias that points to the first byte of the
2758                                                                          ; sun line heap at LSO
2759                                                                          ;
2760                                                                          ; * &FF indicates the sun line heap is empty
2761                                                                          ;
2762                                                                          ; * Otherwise the LSO heap contains the line data for
2763                                                                          ; the sun
2764               
2765               LSO:
2766 0D66                 bss 192                                             ; The ship line heap for the space station (see NWSPS)
2767                                                                          ; and the sun line heap (see SUN)
2768                                                                          ;
2769                                                                          ; The spaces can be shared as our local bubble of
2770                                                                          ; universe can support either the sun or a space
2771                                                                          ; station, but not both
2772               
2773               LSX2:
2774 0E26                 bss 78                                              ; The ball line heap for storing x-coordinates (see the
2775                                                                          ; deep dive on "The ball line heap" for details)
2776               
2777               LSY2:
2778 0E74                 bss 78                                              ; The ball line heap for storing y-coordinates (see the
2779                                                                          ; deep dive on "The ball line heap" for details)
2780               
2781               SY:
2782 0EC2                 bss NOST + 1                                        ; This is where we store the y_hi coordinates for all
2783                                                                          ; the stardust particles
2784               
2785               SYL:
2786 0ED5                 bss NOST + 1                                        ; This is where we store the y_lo coordinates for all
2787                                                                          ; the stardust particles
2788               
2789               SZ:
2790 0EE8                 bss NOST + 1                                        ; This is where we store the z_hi coordinates for all
2791                                                                          ; the stardust particles
2792               
2793               SZL:
2794 0EFB                 bss NOST + 1                                        ; This is where we store the z_lo coordinates for all
2795                                                                          ; the stardust particles
2796               
2797               XSAV2:
2798 0F0E                 bss 1                                               ; Temporary storage, used for storing the value of the X
2799                                                                          ; register in the TT26 routine
2800               
2801               YSAV2:
2802 0F0F                 bss 1                                               ; Temporary storage, used for storing the value of the Y
2803                                                                          ; register in the TT26 routine
2804               
2805               MCH:
2806 0F10                 bss 1                                               ; The text token number of the in-flight message that is
2807                                                                          ; currently being shown, and which will be removed by
2808                                                                          ; the me2 routine when the counter in DLY reaches zero
2809               
2810               FSH:
2811 0F11                 bss 1                                               ; Forward shield status
2812                                                                          ;
2813                                                                          ; * 0 = empty
2814                                                                          ;
2815                                                                          ; * &FF = full
2816               
2817               ASH:
2818 0F12                 bss 1                                               ; Aft shield status
2819                                                                          ;
2820                                                                          ; * 0 = empty
2821                                                                          ;
2822                                                                          ; * &FF = full
2823               
2824               ENERGY:
2825 0F13                 bss 1                                               ; Energy bank status
2826                                                                          ;
2827                                                                          ; * 0 = empty
2828                                                                          ;
2829                                                                          ; * &FF = full
2830               
2831               LASX:
2832 0F14                 bss 1                                               ; The x-coordinate of the tip of the laser line
2833               
2834               LASY:
2835 0F15                 bss 1                                               ; The y-coordinate of the tip of the laser line
2836               
2837               COMX:
2838 0F16                 bss 1                                               ; The x-coordinate of the compass dot
2839               
2840               COMY:
2841 0F17                 bss 1                                               ; The y-coordinate of the compass dot
2842               
2843               QQ24:
2844 0F18                 bss 1                                               ; Temporary storage, used to store the current market
2845                                                                          ; item's price in routine TT151
2846               
2847               QQ25:
2848 0F19                 bss 1                                               ; Temporary storage, used to store the current market
2849                                                                          ; item's availability in routine TT151
2850               
2851               QQ28:
2852 0F1A                 bss 1                                               ; The current system's economy (0-7)
2853                                                                          ;
2854                                                                          ; * 0 = Rich Industrial
2855                                                                          ; * 1 = Average Industrial
2856                                                                          ; * 2 = Poor Industrial
2857                                                                          ; * 3 = Mainly Industrial
2858                                                                          ; * 4 = Mainly Agricultural
2859                                                                          ; * 5 = Rich Agricultural
2860                                                                          ; * 6 = Average Agricultural
2861                                                                          ; * 7 = Poor Agricultural
2862                                                                          ;
2863                                                                          ; See the deep dive on "Generating system data" for more
2864                                                                          ; information on economies
2865               
2866               QQ29:
2867 0F1B                 bss 1                                               ; Temporary storage, used in a number of places
2868               
2869               gov_:
2870 0F1C                 bss 1                                               ; The current system's government type (0-7)
2871                                                                          ;
2872                                                                          ; See the deep dive on "Generating system data" for
2873                                                                          ; details of the various government types
2874               
2875               tek_:
2876 0F1D                 bss 1                                               ; The current system's tech level (0-14)
2877                                                                          ;
2878                                                                          ; See the deep dive on "Generating system data" for more
2879                                                                          ; information on tech levels
2880               
2881               SLSP:
2882 0F1E                 bss 2                                               ; The address of the bottom of the ship line heap
2883                                                                          ;
2884                                                                          ; The ship line heap is a descending block of memory
2885                                                                          ; that starts at WP and descends down to SLSP. It can be
2886                                                                          ; extended downwards by the NWSHP routine when adding
2887                                                                          ; new ships (and their associated ship line heaps), in
2888                                                                          ; which case SLSP is lowered to provide more heap space,
2889                                                                          ; assuming there is enough free memory to do so
2890               
2891               XX24:
2892 0F20                 bss 1                                               ; This byte appears to be unused
2893               
2894               ALTIT:
2895 0F21                 bss 1                                               ; Our altitude above the surface of the planet or sun
2896                                                                          ;
2897                                                                          ; * 255 = we are a long way above the surface
2898                                                                          ;
2899                                                                          ; * 1-254 = our altitude as the square root of:
2900                                                                          ;
2901                                                                          ; x_hi^2 + y_hi^2 + z_hi^2 - 6^2
2902                                                                          ;
2903                                                                          ; where our ship is at the origin, the centre of the
2904                                                                          ; planet/sun is at (x_hi, y_hi, z_hi), and the
2905                                                                          ; radius of the planet/sun is 6
2906                                                                          ;
2907                                                                          ; * 0 = we have crashed into the surface
2908               
2909               QQ2:
2910 0F22                 bss 6                                               ; The three 16-bit seeds for the current system, i.e.
2911                                                                          ; the one we are currently in
2912                                                                          ;
2913                                                                          ; See the deep dives on "Galaxy and system seeds" and
2914                                                                          ; "Twisting the system seeds" for more details
2915               
2916               QQ3:
2917 0F28                 bss 1                                               ; The selected system's economy (0-7)
2918                                                                          ;
2919                                                                          ; * 0 = Rich Industrial
2920                                                                          ; * 1 = Average Industrial
2921                                                                          ; * 2 = Poor Industrial
2922                                                                          ; * 3 = Mainly Industrial
2923                                                                          ; * 4 = Mainly Agricultural
2924                                                                          ; * 5 = Rich Agricultural
2925                                                                          ; * 6 = Average Agricultural
2926                                                                          ; * 7 = Poor Agricultural
2927                                                                          ;
2928                                                                          ; See the deep dive on "Generating system data" for more
2929                                                                          ; information on economies
2930               
2931               QQ4:
2932 0F29                 bss 1                                               ; The selected system's government (0-7)
2933                                                                          ;
2934                                                                          ; See the deep dive on "Generating system data" for more
2935                                                                          ; details of the various government types
2936               
2937               QQ5:
2938 0F2A                 bss 1                                               ; The selected system's tech level (0-14)
2939                                                                          ;
2940                                                                          ; See the deep dive on "Generating system data" for more
2941                                                                          ; information on tech levels
2942               
2943               QQ6:
2944 0F2B                 bss 2                                               ; The selected system's population in billions * 10
2945                                                                          ; (1-71), so the maximum population is 7.1 billion
2946                                                                          ;
2947                                                                          ; See the deep dive on "Generating system data" for more
2948                                                                          ; details on population levels
2949               
2950               QQ7:
2951 0F2D                 bss 2                                               ; The selected system's productivity in M CR (96-62480)
2952                                                                          ;
2953                                                                          ; See the deep dive on "Generating system data" for more
2954                                                                          ; details about productivity levels
2955               
2956               QQ8:
2957 0F2F                 bss 2                                               ; The distance from the current system to the selected
2958                                                                          ; system in light years * 10, stored as a 16-bit number
2959                                                                          ;
2960                                                                          ; The distance will be 0 if the selected system is the
2961                                                                          ; current system
2962                                                                          ;
2963                                                                          ; The galaxy chart is 102.4 light years wide and 51.2
2964                                                                          ; light years tall (see the intra-system distance
2965                                                                          ; calculations in routine TT111 for details), which
2966                                                                          ; equates to 1024 x 512 in terms of QQ8
2967               
2968               QQ9:
2969 0F31                 bss 1                                               ; The galactic x-coordinate of the crosshairs in the
2970                                                                          ; galaxy chart (and, most of the time, the selected
2971                                                                          ; system's galactic x-coordinate)
2972               
2973               QQ10:
2974 0F32                 bss 1                                               ; The galactic y-coordinate of the crosshairs in the
2975                                                                          ; galaxy chart (and, most of the time, the selected
2976                                                                          ; system's galactic y-coordinate)
2977               
2978               NOSTM:
2979 0F33                 bss 1                                               ; The number of stardust particles shown on screen,
2980                                                                          ; which is 18 (#NOST) for normal space, and 3 for
2981                                                                          ; witchspace
2982               
2983                      ; PRINT "WP workspace from  ", ~WP," to ", ~P%
2984               
2985               * ******************************************************************************
2986               *
2987               * ELITE A FILE
2988               *
2989               * Produces the binary file ELTA.bin that gets loaded by elite-bcfs.asm.
2990               *
2991               * The main game code (ELITE A through G, plus the ship data) is loaded at &1128
2992               * and is moved down to &0F40 as part of elite-loader.asm.
2993               *
2994               * ******************************************************************************
2995               
2996                      aorg CODE.
2997               
2998               LOAD_A.:
2999                      equ LOAD.
3000               
3001               * ******************************************************************************
3002               *
3003               * Name: S%
3004               * Type: Workspace
3005               * Address: &0F40 to &0F50
3006               * Category: Workspaces
3007               * Summary: Vector addresses, compass colour and configuration settings
3008               *
3009               * ------------------------------------------------------------------------------
3010               *
3011               * Contains addresses that are used by the loader to set up vectors, the current
3012               * compass colour, and the game's configuration settings.
3013               *
3014               * ******************************************************************************
3015               
3016               S.:
3017 0F40 CCFC            data TT170                                          ; The entry point for the main game; once the main code
3018                                                                          ; has been loaded, decrypted and moved to the right
3019                                                                          ; place by elite-loader.asm, the game is started by a
3020                                                                          ; JMP (S%) instruction, which jumps to the main entry
3021                                                                          ; point at TT170 via this location
3022               
3023 0F42 341A            data TT26                                           ; WRCHV is set to point here by elite-loader.asm
3024               
3025 0F44 38CA            data IRQ1                                           ; IRQ1V is set to point here by elite-loader.asm
3026               
3027 0F46 CD04            data BR1                                            ; BRKV is set to point here by elite-loader.asm
3028               
3029               COMC:
3030 0F48                 bss 1                                               ; The colour of the dot on the compass
3031                                                                          ;
3032                                                                          ; * &F0 = the object in the compass is in front of us,
3033                                                                          ; so the dot is yellow/white
3034                                                                          ;
3035                                                                          ; * &FF = the object in the compass is behind us, so
3036                                                                          ; the dot is green/cyan
3037               
3038               DNOIZ:
3039 0F49                 bss 1                                               ; Sound on/off configuration setting
3040                                                                          ;
3041                                                                          ; * 0 = sound is on (default)
3042                                                                          ;
3043                                                                          ; * Non-zero = sound is off
3044                                                                          ;
3045                                                                          ; Toggled by pressing "S" when paused, see the DK4
3046                                                                          ; routine for details
3047               
3048               DAMP:
3049 0F4A                 bss 1                                               ; Keyboard damping configuration setting
3050                                                                          ;
3051                                                                          ; * 0 = damping is enabled (default)
3052                                                                          ;
3053                                                                          ; * &FF = damping is disabled
3054                                                                          ;
3055                                                                          ; Toggled by pressing CAPS LOCK when paused, see the
3056                                                                          ; DKS3 routine for details
3057               
3058               DJD:
3059 0F4B                 bss 1                                               ; Keyboard auto-recentre configuration setting
3060                                                                          ;
3061                                                                          ; * 0 = auto-recentre is enabled (default)
3062                                                                          ;
3063                                                                          ; * &FF = auto-recentre is disabled
3064                                                                          ;
3065                                                                          ; Toggled by pressing "A" when paused, see the DKS3
3066                                                                          ; routine for details
3067               
3068               PATG:
3069 0F4C                 bss 1                                               ; Configuration setting to show the author names on the
3070                                                                          ; start-up screen and enable manual hyperspace mis-jumps
3071                                                                          ;
3072                                                                          ; * 0 = no author names or manual mis-jumps (default)
3073                                                                          ;
3074                                                                          ; * &FF = show author names and allow manual mis-jumps
3075                                                                          ;
3076                                                                          ; Toggled by pressing "X" when paused, see the DKS3
3077                                                                          ; routine for details
3078                                                                          ;
3079                                                                          ; This needs to be turned on for manual mis-jumps to be
3080                                                                          ; possible. To do a manual mis-jump, first toggle the
3081                                                                          ; author display by pausing the game (COPY) and pressing
3082                                                                          ; "X", and during the next hyperspace, hold down CTRL to
3083                                                                          ; force a mis-jump. See routine ee5 for the "AND PATG"
3084                                                                          ; instruction that implements this logic
3085               
3086               FLH:
3087 0F4D                 bss 1                                               ; Flashing console bars configuration setting
3088                                                                          ;
3089                                                                          ; * 0 = static bars (default)
3090                                                                          ;
3091                                                                          ; * &FF = flashing bars
3092                                                                          ;
3093                                                                          ; Toggled by pressing "F" when paused, see the DKS3
3094                                                                          ; routine for details
3095               
3096               JSTGY:
3097 0F4E                 bss 1                                               ; Reverse joystick Y-channel configuration setting
3098                                                                          ;
3099                                                                          ; * 0 = standard Y-channel (default)
3100                                                                          ;
3101                                                                          ; * &FF = reversed Y-channel
3102                                                                          ;
3103                                                                          ; Toggled by pressing "Y" when paused, see the DKS3
3104                                                                          ; routine for details
3105               
3106               JSTE:
3107 0F4F                 bss 1                                               ; Reverse both joystick channels configuration setting
3108                                                                          ;
3109                                                                          ; * 0 = standard channels (default)
3110                                                                          ;
3111                                                                          ; * &FF = reversed channels
3112                                                                          ;
3113                                                                          ; Toggled by pressing "J" when paused, see the DKS3
3114                                                                          ; routine for details
3115               
3116               JSTK:
3117 0F50                 bss 1                                               ; Keyboard or joystick configuration setting
3118                                                                          ;
3119                                                                          ; * 0 = keyboard (default)
3120                                                                          ;
3121                                                                          ; * &FF = joystick
3122                                                                          ;
3123                                                                          ; Toggled by pressing "K" when paused, see the DKS3
3124                                                                          ; routine for details
3125               
3126               * ******************************************************************************
3127               *
3128               * Name: Main flight loop (Part 1 of 16)
3129               * Type: Subroutine
3130               * Category: Main loop
3131               * Summary: Seed the random number generator
3132               * Deep dive: Program flow of the main game loop
3133               * Generating random numbers
3134               *
3135               * ------------------------------------------------------------------------------
3136               *
3137               * The main flight loop covers most of the flight-specific aspects of Elite. This
3138               * section covers the following:
3139               *
3140               * * Seed the random number generator
3141               *
3142               * ------------------------------------------------------------------------------
3143               *
3144               * Other entry points:
3145               *
3146               * M%                  The entry point for the main flight loop
3147               *
3148               * ******************************************************************************
3149               
3150               M.:
3151 0F52 D360  22        movb @K.,ra                     ; LDA K%            ; We want to seed the random number generator with a
     0F54 0900     
3152                                                                          ; pretty random number, so fetch the contents of K%,
3153                                                                          ; which is the x_lo coordinate of the planet. This value
3154                                                                          ; will be fairly unpredictable, so it's a pretty good
3155                                                                          ; candidate
3156               
3157 0F56 D80D  22        movb ra,@RAND                   ; STA RAND          ; Store the seed in the first byte of the four-byte
     0F58 0000     
3158                                                                          ; random number seed that's stored in RAND
3159               
3160               * ******************************************************************************
3161               *
3162               * Name: Main flight loop (Part 2 of 16)
3163               * Type: Subroutine
3164               * Category: Main loop
3165               * Summary: Calculate the alpha and beta angles from the current pitch and
3166               * roll of our ship
3167               * Deep dive: Program flow of the main game loop
3168               * Pitching and rolling
3169               *
3170               * ------------------------------------------------------------------------------
3171               *
3172               * The main flight loop covers most of the flight-specific aspects of Elite. This
3173               * section covers the following:
3174               *
3175               * * Calculate the alpha and beta angles from the current pitch and roll
3176               *
3177               * Here we take the current rate of pitch and roll, as set by the joystick or
3178               * keyboard, and convert them into alpha and beta angles that we can use in the
3179               * matrix functions to rotate space around our ship. The alpha angle covers
3180               * roll, while the beta angle covers pitch (there is no yaw in this version of
3181               * Elite). The angles are in radians, which allows us to use the small angle
3182               * approximation when moving objects in the sky (see the MVEIT routine for more
3183               * on this). Also, the signs of the two angles are stored separately, in both
3184               * the sign and the flipped sign, as this makes calculations easier.
3185               *
3186               * ******************************************************************************
3187               
3188 0F5A D3A0  22        movb @JSTX,rx                   ; LDX JSTX          ; Set X to the current rate of roll in JSTX
     0F5C 009C     
3189               
3190 0F5E 0200  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping twice (if enabled) so the roll
     0F60 4AC0     
3191 0F62 06A0  24        bl   @jsr                       ;
     0F64 FE28     
3192 0F66 0200  12        li   rtmp,cntr_                 ; JSR cntr          ; rate in X creeps towards the centre by 2
     0F68 4AC0     
3193 0F6A 06A0  24        bl   @jsr                       ;
     0F6C FE28     
3194               
3195                                                                          ; The roll rate in JSTX increases if we press ">" (and
3196                                                                          ; the RL indicator on the dashboard goes to the right)
3197                                                                          ;
3198                                                                          ; This rolls our ship to the right (clockwise), but we
3199                                                                          ; actually implement this by rolling everything else
3200                                                                          ; to the left (anti-clockwise), so a positive roll rate
3201                                                                          ; in JSTX translates to a negative roll angle alpha
3202               
3203 0F6E D34E  14        movb rx,ra                      ; TXA               ; Set A and Y to the roll rate but with the sign bit
3204                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped (i.e. set them to the sign we want for alpha)
     **** ****     > EOI
0001 0F70 0200  12        li   rtmp,(>80*256)
     0F72 8000     
0002 0F74 2B40  14        xor  rtmp,ra
                   < elite.a99
3205 0F76 D3CD  14        movb ra,ry                      ; TAY
3206               
3207 0F78 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the roll rate and store
     0F7A 8000     
3208 0F7C D80D  22        movb ra,@ALP2                   ; STA ALP2          ; in ALP2 (so ALP2 contains the sign of the roll angle
     0F7E 0088     
3209                                                                          ; alpha)
3210               
3211 0F80 D80E  22        movb rx,@JSTX                   ; STX JSTX          ; Update JSTX with the damped value that's still in X
     0F82 009C     
3212               
3213                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the roll rate and store
     **** ****     > EOI
0001 0F84 0200  12        li   rtmp,(>80*256)
     0F86 8000     
0002 0F88 2B40  14        xor  rtmp,ra
                   < elite.a99
3214 0F8A D80D  22        movb ra,@ALP2+1                 ; STA ALP2+1        ; in ALP2+1 (so ALP2+1 contains the flipped sign of the
     0F8C 0089     
3215                                                                          ; roll angle alpha)
3216               
3217 0F8E D34F  14        movb ry,ra                      ; TYA               ; Set A to the roll rate but with the sign bit flipped
3218               
3219 0F90 1508  10        jgt  B01                        ; BPL B01           ; If the value of A is positive, skip the following
3220                                                                          ; three instructions
3221               
3222                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so change the sign of A using two's
     **** ****     > EOI
0001 0F92 0200  12        li   rtmp,(>FF*256)
     0F94 FF00     
0002 0F96 2B40  14        xor  rtmp,ra
                   < elite.a99
3223                      .clc                            ; CLC               ; complement so that A is now positive and contains
     **** ****     > CLC
0001 0F98 0A16  14        sla  rzero,1
                   < elite.a99
3224                      .adi (>01*256)                  ; ADC #1            ; the absolute value of the roll rate, i.e. |JSTX|
     **** ****     > ADI
0001 0F9A 1701  10        jnc  !
0002 0F9C B347  14        ab   rone,ra
0003               !:
0004 0F9E 022D  14        ai   ra,(>01*256)
     0FA0 0100     
                   < elite.a99
3225               
3226               B01:
3227 0FA2 091D  14        srl  ra,1                       ; LSR A             ; Divide the (positive) roll rate in A by 4
3228 0FA4 091D  14        srl  ra,1                       ; LSR A
3229               
3230 0FA6 028D  14        ci   ra,>08*256                 ; CMP #8            ; If A >= 8, skip the following two instructions
     0FA8 0800     
3231 0FAA 1802  10        joc  B02                        ; BCS B02
3232               
3233 0FAC 091D  14        srl  ra,1                       ; LSR A             ; A < 8, so halve A again
3234               
3235                      .clc                            ; CLC               ; This instruction has no effect, as we only get here
     **** ****     > CLC
0001 0FAE 0A16  14        sla  rzero,1
                   < elite.a99
3236                                                                          ; if the C flag is clear (if it is set, we skip this
3237                                                                          ; instruction)
3238               B02:
3239 0FB0 D80D  22        movb ra,@ALP1                   ; STA ALP1          ; Store A in ALP1, so we now have:
     0FB2 0087     
3240                                                                          ;
3241                                                                          ; ALP1 = |JSTX| / 8    if |JSTX| < 32
3242                                                                          ;
3243                                                                          ; ALP1 = |JSTX| / 4    if |JSTX| >= 32
3244                                                                          ;
3245                                                                          ; This means that at lower roll rates, the roll angle is
3246                                                                          ; reduced closer to zero than at higher roll rates,
3247                                                                          ; which gives us finer control over the ship's roll at
3248                                                                          ; lower roll rates
3249                                                                          ;
3250                                                                          ; Because JSTX is in the range -127 to +127, ALP1 is
3251                                                                          ; in the range 0 to 31
3252               
3253 0FB4 F360  22        socb @ALP2,ra                   ; ORA ALP2          ; Store A in ALPHA, but with the sign set to ALP2 (so
     0FB6 0088     
3254 0FB8 D80D  22        movb ra,@ALPHA                  ; STA ALPHA         ; ALPHA has a different sign to the actual roll rate)
     0FBA 009E     
3255               
3256 0FBC D3A0  22        movb @JSTY,rx                   ; LDX JSTY          ; Set X to the current rate of pitch in JSTY
     0FBE 009D     
3257               
3258 0FC0 0200  12        li   rtmp,cntr_                 ; JSR cntr          ; Apply keyboard damping so the pitch rate in X creeps
     0FC2 4AC0     
3259 0FC4 06A0  24        bl   @jsr                       ;
     0FC6 FE28     
3260                                                                          ; towards the centre by 1
3261               
3262 0FC8 D34E  14        movb rx,ra                      ; TXA               ; Set A and Y to the pitch rate but with the sign bit
3263                      .eoi (>80*256)                  ; EOR #%10000000    ; flipped
     **** ****     > EOI
0001 0FCA 0200  12        li   rtmp,(>80*256)
     0FCC 8000     
0002 0FCE 2B40  14        xor  rtmp,ra
                   < elite.a99
3264 0FD0 D3CD  14        movb ra,ry                      ; TAY
3265               
3266 0FD2 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the pitch rate into A
     0FD4 8000     
3267               
3268 0FD6 D80E  22        movb rx,@JSTY                   ; STX JSTY          ; Update JSTY with the damped value that's still in X
     0FD8 009D     
3269               
3270 0FDA D80D  22        movb ra,@BET2+1                 ; STA BET2+1        ; Store the flipped sign of the pitch rate in BET2+1
     0FDC 008B     
3271               
3272                      .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the pitch rate and store
     **** ****     > EOI
0001 0FDE 0200  12        li   rtmp,(>80*256)
     0FE0 8000     
0002 0FE2 2B40  14        xor  rtmp,ra
                   < elite.a99
3273 0FE4 D80D  22        movb ra,@BET2                   ; STA BET2          ; it in BET2
     0FE6 008A     
3274               
3275 0FE8 D34F  14        movb ry,ra                      ; TYA               ; Set A to the pitch rate but with the sign bit flipped
3276               
3277 0FEA 1503  10        jgt  B03                        ; BPL B03           ; If the value of A is positive, skip the following
3278                                                                          ; instruction
3279               
3280                      .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so flip the bits
     **** ****     > EOI
0001 0FEC 0200  12        li   rtmp,(>FF*256)
     0FEE FF00     
0002 0FF0 2B40  14        xor  rtmp,ra
                   < elite.a99
3281               
3282               B03:
3283                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the (positive) pitch rate, so the maximum
     **** ****     > ADI
0001 0FF2 1701  10        jnc  !
0002 0FF4 B347  14        ab   rone,ra
0003               !:
0004 0FF6 022D  14        ai   ra,(>04*256)
     0FF8 0400     
                   < elite.a99
3284                                                                          ; value is now up to 131 (rather than 127)
3285               
3286 0FFA 091D  14        srl  ra,1                       ; LSR A             ; Divide the (positive) pitch rate in A by 16
3287 0FFC 091D  14        srl  ra,1                       ; LSR A
3288 0FFE 091D  14        srl  ra,1                       ; LSR A
3289 1000 091D  14        srl  ra,1                       ; LSR A
3290               
3291 1002 028D  14        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, skip the following instruction
     1004 0300     
3292 1006 1801  10        joc  B04                        ; BCS B04
3293               
3294 1008 091D  14        srl  ra,1                       ; LSR A             ; A < 3, so halve A again
3295               
3296               B04:
3297 100A D80D  22        movb ra,@BET1                   ; STA BET1          ; Store A in BET1, so we now have:
     100C 002B     
3298                                                                          ;
3299                                                                          ; BET1 = |JSTY| / 32    if |JSTY| < 48
3300                                                                          ;
3301                                                                          ; BET1 = |JSTY| / 16    if |JSTY| >= 48
3302                                                                          ;
3303                                                                          ; This means that at lower pitch rates, the pitch angle
3304                                                                          ; is reduced closer to zero than at higher pitch rates,
3305                                                                          ; which gives us finer control over the ship's pitch at
3306                                                                          ; lower pitch rates
3307                                                                          ;
3308                                                                          ; Because JSTY is in the range -131 to +131, BET1 is in
3309                                                                          ; the range 0 to 8
3310               
3311 100E F360  22        socb @BET2,ra                   ; ORA BET2          ; Store A in BETA, but with the sign set to BET2 (so
     1010 008A     
3312 1012 D80D  22        movb ra,@BETA                   ; STA BETA          ; BETA has the same sign as the actual pitch rate)
     1014 002A     
3313               
3314               * ******************************************************************************
3315               *
3316               * Name: Main flight loop (Part 3 of 16)
3317               * Type: Subroutine
3318               * Category: Main loop
3319               * Summary: Scan for flight keys and process the results
3320               * Deep dive: Program flow of the main game loop
3321               * The key logger
3322               *
3323               * ------------------------------------------------------------------------------
3324               *
3325               * The main flight loop covers most of the flight-specific aspects of Elite. This
3326               * section covers the following:
3327               *
3328               * * Scan for flight keys and process the results
3329               *
3330               * Flight keys are logged in the key logger at location KY1 onwards, with a
3331               * non-zero value in the relevant location indicating a key press. See the deep
3332               * dive on "The key logger" for more details.
3333               *
3334               * The key presses that are processed are as follows:
3335               *
3336               * * Space and "?" to speed up and slow down
3337               * * "U", "T" and "M" to disarm, arm and fire missiles
3338               * * TAB to fire an energy bomb
3339               * * ESCAPE to launch an escape pod
3340               * * "J" to initiate an in-system jump
3341               * * "E" to deploy E.C.M. anti-missile countermeasures
3342               * * "C" to use the docking computer
3343               * * "A" to fire lasers
3344               *
3345               * ******************************************************************************
3346               
3347 1016 D360  22        movb @KY2,ra                    ; LDA KY2           ; If Space is being pressed, keep going, otherwise jump
     1018 0043     
3348 101A 1306  10        jeq  MA17                       ; BEQ MA17          ; down to MA17 to skip the following
3349               
3350 101C D360  22        movb @DELTA,ra                  ; LDA DELTA         ; The "go faster" key is being pressed, so first we
     101E 008C     
3351 1020 028D  14        ci   ra,>28*256                 ; CMP #40           ; fetch the current speed from DELTA into A, and if
     1022 2800     
3352 1024 1801  10        joc  MA17                       ; BCS MA17          ; A >= 40, we are already going at full pelt, so jump
3353                                                                          ; down to MA17 to skip the following
3354               
3355 1026 B347  14        ab   rone,ra                    ; INC DELTA         ; We can go a bit faster, so increment the speed in
3356                                                                          ; location DELTA
3357               
3358               MA17:
3359 1028 D360  22        movb @KY1,ra                    ; LDA KY1           ; If "?" is being pressed, keep going, otherwise jump
     102A 0042     
3360 102C 1303  10        jeq  MA4                        ; BEQ MA4           ; down to MA4 to skip the following
3361               
3362 102E 7347  14        sb   rone,ra                    ; DEC DELTA         ; The "slow down" key is being pressed, so we decrement
3363                                                                          ; the current ship speed in DELTA
3364               
3365 1030 1601  10        jne  MA4                        ; BNE MA4           ; If the speed is still greater than zero, jump to MA4
3366               
3367 1032 B347  14        ab   rone,ra                    ; INC DELTA         ; Otherwise we just braked a little too hard, so bump
3368                                                                          ; the speed back up to the minimum value of 1
3369               
3370               MA4:
3371 1034 D360  22        movb @KY15,ra                   ; LDA KY15          ; If "U" is being pressed and the number of missiles
     1036 004C     
3372                      .and @NOMSL                     ; AND NOMSL         ; in NOMSL is non-zero, keep going, otherwise jump down
     **** ****     > AND
0001 1038 D020  22        movb @NOMSL,rtmp
     103A 0333     
0002 103C 0540  10        inv  rtmp
0003 103E 5340  14        szcb rtmp,ra
                   < elite.a99
3373 1040 1310  10        jeq  MA20                       ; BEQ MA20          ; to MA20 to skip the following
3374               
3375 1042 020F  12        li   ry,>ee*256                 ; LDY #&EE          ; The "disarm missiles" key is being pressed, so call
     1044 EE00     
3376 1046 0200  12        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     1048 B72E     
3377 104A 06A0  24        bl   @jsr                       ;
     104C FE28     
3378                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
3379               
3380 104E 020D  12        li   ra,>28*256                 ; LDA #40           ; Call the NOISE routine with A = 40 to make a low,
     1050 2800     
3381 1052 0200  12        li   rtmp,NOISE                 ; JSR NOISE         ; long beep to indicate the missile is now disarmed
     1054 D340     
3382 1056 06A0  24        bl   @jsr                       ;
     1058 FE28     
3383               
3384               MA31:
3385 105A 020D  12        li   ra,>00*256                 ; LDA #0            ; Set MSAR to 0 to indicate that no missiles are
     105C 0000     
3386 105E D80D  22        movb ra,@MSAR                   ; STA MSAR          ; currently armed
     1060 0D5E     
3387               
3388               MA20:
3389 1062 D360  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG is positive (i.e. it does not have bit 7 set),
     1064 0052     
3390 1066 150E  10        jgt  MA25                       ; BPL MA25          ; then it indicates we already have a missile locked on
3391                                                                          ; a target (in which case MSTG contains the ship number
3392                                                                          ; of the target), so jump to MA25 to skip targeting. Or
3393                                                                          ; to put it another way, if MSTG = &FF, which means
3394                                                                          ; there is no current target lock, keep going
3395               
3396 1068 D360  22        movb @KY14,ra                   ; LDA KY14          ; If "T" is being pressed, keep going, otherwise jump
     106A 004B     
3397 106C 130B  10        jeq  MA25                       ; BEQ MA25          ; down to MA25 to skip the following
3398               
3399 106E D3A0  22        movb @NOMSL,rx                  ; LDX NOMSL         ; If the number of missiles in NOMSL is zero, jump down
     1070 0333     
3400 1072 1308  10        jeq  MA25                       ; BEQ MA25          ; to MA25 to skip the following
3401               
3402 1074 D80D  22        movb ra,@MSAR                   ; STA MSAR          ; The "target missile" key is being pressed and we have
     1076 0D5E     
3403                                                                          ; at least one missile, so set MSAR = &FF to denote that
3404                                                                          ; our missile is currently armed (we know A has the
3405                                                                          ; value &FF, as we just loaded it from MSTG and checked
3406                                                                          ; that it was negative)
3407               
3408 1078 020F  12        li   ry,>e0*256                 ; LDY #&E0          ; Change the leftmost missile indicator to yellow/white
     107A E000     
3409 107C 0200  12        li   rtmp,MSBAR                 ; JSR MSBAR         ; on the missile bar (this call changes the leftmost
     107E B79A     
3410 1080 06A0  24        bl   @jsr                       ;
     1082 FE28     
3411                                                                          ; indicator because we set X to the number of missiles
3412                                                                          ; in NOMSL above, and the indicators are numbered from
3413                                                                          ; right to left, so X is the number of the leftmost
3414                                                                          ; indicator)
3415               
3416               MA25:
3417 1084 D360  22        movb @KY16,ra                   ; LDA KY16          ; If "M" is being pressed, keep going, otherwise jump
     1086 004D     
3418 1088 1307  10        jeq  MA24                       ; BEQ MA24          ; down to MA24 to skip the following
3419               
3420 108A D360  22        movb @MSTG,ra                   ; LDA MSTG          ; If MSTG = &FF then there is no target lock, so jump to
     108C 0052     
3421 108E 112D  10        jlt  MA64                       ; BMI MA64          ; MA64 to skip the following (also skipping the checks
3422                                                                          ; for TAB, ESCAPE, "J" and "E")
3423               
3424 1090 0200  12        li   rtmp,FRMIS                 ; JSR FRMIS         ; The "fire missile" key is being pressed and we have
     1092 3F5E     
3425 1094 06A0  24        bl   @jsr                       ;
     1096 FE28     
3426                                                                          ; a missile lock, so call the FRMIS routine to fire
3427                                                                          ; the missile
3428               
3429               MA24:
3430 1098 D360  22        movb @KY12,ra                   ; LDA KY12          ; If TAB is being pressed, keep going, otherwise jump
     109A 0049     
3431 109C 1307  10        jeq  MA76                       ; BEQ MA76          ; down to MA76 to skip the following
3432               
3433                      .asl @BOMB                      ; ASL BOMB          ; The "energy bomb" key is being pressed, so double
     **** ****     > ASL
0001 109E D020  22        movb @BOMB,rtmp
     10A0 032A     
0002 10A2 0240  14        andi rtmp,>ff00
     10A4 FF00     
0003 10A6 0A10  14        sla  rtmp,1
0004 10A8 D800  22        movb rtmp,@BOMB
     10AA 032A     
                   < elite.a99
3434                                                                          ; the value in BOMB. If we have an energy bomb fitted,
3435                                                                          ; BOMB will contain &7F (%01111111) before this shift
3436                                                                          ; and will contain &FE (%11111110) after the shift; if
3437                                                                          ; we don't have an energy bomb fitted, BOMB will still
3438                                                                          ; contain 0. The bomb explosion is dealt with in the
3439                                                                          ; MAL1 routine below - this just registers the fact that
3440                                                                          ; we've set the bomb ticking
3441               
3442               MA76:
3443 10AC D360  22        movb @KY13,ra                   ; LDA KY13          ; If ESCAPE is being pressed and we have an escape pod
     10AE 004A     
3444                      .and @ESCP                      ; AND ESCP          ; fitted, keep going, otherwise skip the next
     **** ****     > AND
0001 10B0 D020  22        movb @ESCP,rtmp
     10B2 032E     
0002 10B4 0540  10        inv  rtmp
0003 10B6 5340  14        szcb rtmp,ra
                   < elite.a99
3445 10B8 1302  10        jeq  B05                        ; BEQ B05           ; instruction
3446               
3447 10BA 0460  20        b    @ESCAPE                    ; JMP ESCAPE        ; The button is being pressed to launch an escape pod
     10BC 392E     
3448                                                                          ; and we have an escape pod fitted, so jump to ESCAPE to
3449                                                                          ; launch it, and exit the main flight loop using a tail
3450                                                                          ; call
3451               
3452               B05:
3453 10BE D360  22        movb @KY18,ra                   ; LDA KY18          ; If "J" is being pressed, keep going, otherwise skip
     10C0 004F     
3454 10C2 1304  10        jeq  B06                        ; BEQ B06           ; the next instruction
3455               
3456 10C4 0200  12        li   rtmp,WARP                  ; JSR WARP          ; Call the WARP routine to do an in-system jump
     10C6 4BE8     
3457 10C8 06A0  24        bl   @jsr                       ;
     10CA FE28     
3458               
3459               B06:
3460 10CC D360  22        movb @KY17,ra                   ; LDA KY17          ; If "E" is being pressed and we have an E.C.M. fitted,
     10CE 004E     
3461                      .and @ECM                       ; AND ECM           ; keep going, otherwise jump down to MA64 to skip the
     **** ****     > AND
0001 10D0 D020  22        movb @ECM,rtmp
     10D2 0328     
0002 10D4 0540  10        inv  rtmp
0003 10D6 5340  14        szcb rtmp,ra
                   < elite.a99
3462 10D8 1308  10        jeq  MA64                       ; BEQ MA64          ; following
3463               
3464 10DA D360  22        movb @ECMA,ra                   ; LDA ECMA          ; If ECMA is non-zero, that means an E.C.M. is already
     10DC 0030     
3465 10DE 1605  10        jne  MA64                       ; BNE MA64          ; operating and is counting down (this can be either
3466                                                                          ; our E.C.M. or an opponent's), so jump down to MA64 to
3467                                                                          ; skip the following (as we can't have two E.C.M.
3468                                                                          ; systems operating at the same time)
3469               
3470 10E0 7347  14        sb   rone,ra                    ; DEC ECMP          ; The E.C.M. button is being pressed and nobody else
3471                                                                          ; is operating their E.C.M., so decrease the value of
3472                                                                          ; ECMP to make it non-zero, to denote that our E.C.M.
3473                                                                          ; is now on
3474               
3475 10E2 0200  12        li   rtmp,ECBLB2                ; JSR ECBLB2        ; Call ECBLB2 to light up the E.C.M. indicator bulb on
     10E4 B74A     
3476 10E6 06A0  24        bl   @jsr                       ;
     10E8 FE28     
3477                                                                          ; the dashboard, set the E.C.M. countdown timer to 32,
3478                                                                          ; and start making the E.C.M. sound
3479               
3480               MA64:
3481 10EA D360  22        movb @KY19,ra                   ; LDA KY19          ; If "C" is being pressed, and we have a docking
     10EC 0050     
3482                      .and @DKCMP                     ; AND DKCMP         ; computer fitted, and we are inside the space station's
     **** ****     > AND
0001 10EE D020  22        movb @DKCMP,rtmp
     10F0 032C     
0002 10F2 0540  10        inv  rtmp
0003 10F4 5340  14        szcb rtmp,ra
                   < elite.a99
3483                      .and @SSPR                      ; AND SSPR          ; safe zone, keep going, otherwise jump down to MA68 to
     **** ****     > AND
0001 10F6 D020  22        movb @SSPR,rtmp
     10F8 0D55     
0002 10FA 0540  10        inv  rtmp
0003 10FC 5340  14        szcb rtmp,ra
                   < elite.a99
3484 10FE 1305  10        jeq  MA68                       ; BEQ MA68          ; skip the following
3485               
3486 1100 D360  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     1102 0944     
3487 1104 1102  10        jlt  MA68                       ; BMI MA68          ; from the ship data workspace at K%, which is reserved
3488                                                                          ; for the sun or the space station (in this case it's
3489                                                                          ; the latter as we are in the safe zone). If byte #32 is
3490                                                                          ; negative, meaning the station is hostile, then jump
3491                                                                          ; down to MA68 to skip the following (so we can't use
3492                                                                          ; the docking computer to dock at a station that has
3493                                                                          ; turned against us)
3494               
3495 1106 0460  16        b    @GOIN                      ; JMP GOIN          ; The Docking Computer button has been pressed and
     1108 1332     
3496                                                                          ; we are allowed to dock at the station, so jump to
3497                                                                          ; GOIN to dock (or "go in"), and exit the main flight
3498                                                                          ; loop using a tail call
3499               
3500               MA68:
3501 110A 020D  12        li   ra,>00*256                 ; LDA #0            ; Set LAS = 0, to switch the laser off while we do the
     110C 0000     
3502 110E D80D  22        movb ra,@LAS                    ; STA LAS           ; following logic
     1110 0051     
3503               
3504 1112 D80D  22        movb ra,@DELT4                  ; STA DELT4         ; Take the 16-bit value (DELTA 0) - i.e. a two-byte
     1114 008D     
3505 1116 D360  22        movb @DELTA,ra                  ; LDA DELTA         ; number with DELTA as the high byte and 0 as the low
     1118 008C     
3506 111A 091D  14        srl  ra,1                       ; LSR A             ; byte - and divide it by 4, storing the 16-bit result
3507 111C 0204  12        li   rarg1,DELT4                ; ROR DELT4         ; in DELT4(1 0). This has the effect of storing the
     111E 008D     
3508 1120 06A0  24        bl   @ror                       ;
     1122 FE7A     
3509 1124 091D  14        srl  ra,1                       ; LSR A             ; current speed * 64 in the 16-bit location DELT4(1 0)
3510 1126 0204  12        li   rarg1,DELT4                ; ROR DELT4
     1128 008D     
3511 112A 06A0  24        bl   @ror                       ;
     112C FE7A     
3512 112E D80D  22        movb ra,@DELT4+1                ; STA DELT4+1
     1130 008E     
3513               
3514 1132 D360  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT is zero, keep going, otherwise the laser is
     1134 0D60     
3515 1136 162A  10        jne  MA3                        ; BNE MA3           ; a pulse laser that is between pulses, so jump down to
3516                                                                          ; MA3 to skip the following
3517               
3518 1138 D360  22        movb @KY7,ra                    ; LDA KY7           ; If "A" is being pressed, keep going, otherwise jump
     113A 0048     
3519 113C 1327  10        jeq  MA3                        ; BEQ MA3           ; down to MA3 to skip the following
3520               
3521 113E D360  22        movb @GNTMP,ra                  ; LDA GNTMP         ; If the laser temperature >= 242 then the laser has
     1140 0D61     
3522 1142 028D  14        ci   ra,>f2*256                 ; CMP #242          ; overheated, so jump down to MA3 to skip the following
     1144 F200     
3523 1146 1822  10        joc  MA3                        ; BCS MA3
3524               
3525 1148 D3A0  22        movb @VIEW,rx                   ; LDX VIEW          ; If the current space view has a laser fitted (i.e. the
     114A 0D5F     
3526 114C 06CE  10        swpb rx                         ;
3527 114E D36E  26        movb @LASER(rx),ra              ; LDA LASER,X       ; laser power for this view is greater than zero), then
     1150 0310     
3528 1152 06CE  10        swpb rx                         ;
3529 1154 131B  10        jeq  MA3                        ; BEQ MA3           ; keep going, otherwise jump down to MA3 to skip the
3530                                                                          ; following
3531               
3532                                                                          ; If we get here, then the "fire" button is being
3533                                                                          ; pressed, our laser hasn't overheated and isn't already
3534                                                                          ; being fired, and we actually have a laser fitted to
3535                                                                          ; the current space view, so it's time to hit me with
3536                                                                          ; those laser beams
3537               
3538                      .pha                            ; PHA               ; Store the current view's laser power on the stack
     **** ****     > PHA
0001 1156 D68D  26        movb ra,*rsp
0002 1158 060A  10        dec  rsp
                   < elite.a99
3539               
3540 115A 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Set LAS and LAS2 to bits 0-6 of the laser power
     115C 7F00     
3541 115E D80D  22        movb ra,@LAS                    ; STA LAS
     1160 0051     
3542 1162 D80D  22        movb ra,@LAS2                   ; STA LAS2
     1164 0D5D     
3543               
3544 1166 020D  12        li   ra,>00*256                 ; LDA #0            ; Call the NOISE routine with A = 0 to make the sound
     1168 0000     
3545 116A 0200  12        li   rtmp,NOISE                 ; JSR NOISE         ; of our laser firing
     116C D340     
3546 116E 06A0  24        bl   @jsr                       ;
     1170 FE28     
3547               
3548 1172 0200  12        li   rtmp,LASLI                 ; JSR LASLI         ; Call LASLI to draw the laser lines
     1174 4C8E     
3549 1176 06A0  24        bl   @jsr                       ;
     1178 FE28     
3550               
3551                      .pla                            ; PLA               ; Restore the current view's laser power into A
     **** ****     > PLA
0001 117A 058A  10        inc  rsp
0002 117C D35A  22        movb *rsp,ra
                   < elite.a99
3552               
3553 117E 1502  10        jgt  ma1_                       ; BPL ma1           ; If the laser power has bit 7 set, then it's an "always
3554                                                                          ; on" laser rather than a pulsing laser, so keep going,
3555                                                                          ; otherwise jump down to ma1 to skip the following
3556                                                                          ; instruction
3557               
3558 1180 020D  12        li   ra,>00*256                 ; LDA #0            ; This is an "always on" laser (i.e. a beam laser,
     1182 0000     
3559                                                                          ; as this version of Elite doesn't have military
3560                                                                          ; lasers), so set A = 0, which will be stored in LASCT
3561                                                                          ; to denote that this is not a pulsing laser
3562               
3563               ma1_:
3564 1184 024D  14        andi ra,>fa*256                 ; AND #%11111010    ; LASCT will be set to 0 for beam lasers, and to the
     1186 FA00     
3565 1188 D80D  22        movb ra,@LASCT                  ; STA LASCT         ; laser power AND %11111010 for pulse lasers, which
     118A 0D60     
3566                                                                          ; comes to 10 (as pulse lasers have a power of 15). See
3567                                                                          ; MA23 below for more on laser pulsing and LASCT
3568               
3569               * ******************************************************************************
3570               *
3571               * Name: Main flight loop (Part 4 of 16)
3572               * Type: Subroutine
3573               * Category: Main loop
3574               * Summary: For each nearby ship: Copy the ship's data block from K% to the
3575               * zero-page workspace at INWK
3576               * Deep dive: Program flow of the main game loop
3577               * Ship data blocks
3578               *
3579               * ------------------------------------------------------------------------------
3580               *
3581               * The main flight loop covers most of the flight-specific aspects of Elite. This
3582               * section covers the following:
3583               *
3584               * * Start looping through all the ships in the local bubble, and for each
3585               * one:
3586               *
3587               * * Copy the ship's data block from K% to INWK
3588               *
3589               * * Set XX0 to point to the ship's blueprint (if this is a ship)
3590               *
3591               * ------------------------------------------------------------------------------
3592               *
3593               * Other entry points:
3594               *
3595               * MAL1                Marks the beginning of the ship analysis loop, so we
3596               * can jump back here from part 12 of the main flight loop
3597               * to work our way through each ship in the local bubble.
3598               * We also jump back here when a ship is removed from the
3599               * bubble, so we can continue processing from the next ship
3600               *
3601               * ******************************************************************************
3602               
3603               MA3:
3604 118C 020E  12        li   rx,>00*256                 ; LDX #0            ; We're about to work our way through all the ships in
     118E 0000     
3605                                                                          ; our local bubble of universe, so set a counter in X,
3606                                                                          ; starting from 0, to refer to each ship slot in turn
3607               
3608               MAL1:
3609 1190 D80E  22        movb rx,@XSAV                   ; STX XSAV          ; Store the current slot number in XSAV
     1192 0093     
3610               
3611 1194 06CE  10        swpb rx                         ;
3612 1196 D36E  26        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the contents of this slot into A. If it is 0
     1198 0D40     
3613 119A 06CE  10        swpb rx                         ;
3614 119C 1602  10        jne  B07                        ; BNE B07           ; then this slot is empty and we have no more ships to
3615 119E 0460  16        b    @MA18                      ; JMP MA18          ; process, so jump to MA18 below, otherwise A contains
     11A0 1552     
3616                                                                          ; the type of ship that's in this slot, so skip over the
3617                                                                          ; JMP MA18 instruction and keep going
3618               
3619               B07:
3620 11A2 D80D  22        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     11A4 009B     
3621               
3622 11A6 0200  12        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to fetch the address of the ship data block
     11A8 B564     
3623 11AA 06A0  24        bl   @jsr                       ;
     11AC FE28     
3624                                                                          ; for the ship in slot X and store it in INF. The data
3625                                                                          ; block is in the K% workspace, which is where all the
3626                                                                          ; ship data blocks are stored
3627               
3628                                                                          ; Next we want to copy the ship data block from INF to
3629                                                                          ; the zero-page workspace at INWK, so we can process it
3630                                                                          ; more efficiently
3631               
3632 11AE 020F  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in each ship data block (and in
     11B0 2300     
3633                                                                          ; the INWK workspace, so we set a counter in Y so we can
3634                                                                          ; loop through them
3635               
3636               MAL2:
3637                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Load the Y-th byte of INF and store it in the Y-th
     **** ****     > LD_IND_Y_IDX
0001 11B2 D820  30        movb @INF,@rtmplb
     11B4 0020     
     11B6 8301     
0002 11B8 D020  22        movb @INF+1,rtmp
     11BA 0021     
0003 11BC 06CF  10        swpb ry
0004 11BE A00F  14        a    ry,rtmp
0005 11C0 06CF  10        swpb ry
0006 11C2 D350  22        movb *rtmp,RA
                   < elite.a99
3638 11C4 06CF  10        swpb ry                         ;
3639 11C6 DBCD  30        movb ra,@INWK(ry)               ; STA INWK,Y        ; byte of INWK
     11C8 0053     
3640 11CA 06CF  10        swpb ry                         ;
3641               
3642 11CC 73C7  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3643               
3644 11CE 15F1  10        jgt  MAL2                       ; BPL MAL2          ; Loop back for the next byte until we have copied the
3645                                                                          ; last byte from INF to INWK
3646               
3647 11D0 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     11D2 009B     
3648 11D4 1125  10        jlt  MA21                       ; BMI MA21          ; planet or sun, so jump down to MA21, as the next bit
3649                                                                          ; sets up a pointer to the ship blueprint, and then
3650                                                                          ; checks for energy bomb damage, and neither of these
3651                                                                          ; apply to planets and suns
3652               
3653                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 11D6 024D  14        andi ra,>ff00
     11D8 FF00     
0002 11DA 0A1D  14        sla  ra,1
                   < elite.a99
3654 11DC D3CD  14        movb ra,ry                      ; TAY
3655               
3656 11DE 06CF  10        swpb ry                         ;
3657 11E0 D36F  26        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     11E2 F14C     
3658 11E4 06CF  10        swpb ry                         ;
3659 11E6 D80D  22        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     11E8 001E     
3660                                                                          ; so this fetches the low byte of this particular ship
3661                                                                          ; type's blueprint and stores it in XX0
3662               
3663 11EA 06CF  10        swpb ry                         ;
3664 11EC D36F  26        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     11EE F14D     
3665 11F0 06CF  10        swpb ry                         ;
3666 11F2 D80D  22        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1
     11F4 001F     
3667               
3668               * ******************************************************************************
3669               *
3670               * Name: Main flight loop (Part 5 of 16)
3671               * Type: Subroutine
3672               * Category: Main loop
3673               * Summary: For each nearby ship: If an energy bomb has been set off,
3674               * potentially kill this ship
3675               * Deep dive: Program flow of the main game loop
3676               *
3677               * ------------------------------------------------------------------------------
3678               *
3679               * The main flight loop covers most of the flight-specific aspects of Elite. This
3680               * section covers the following:
3681               *
3682               * * Continue looping through all the ships in the local bubble, and for each
3683               * one:
3684               *
3685               * * If an energy bomb has been set off and this ship can be killed, kill it
3686               * and increase the kill tally
3687               *
3688               * ******************************************************************************
3689               
3690 11F6 D360  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     11F8 032A     
3691 11FA 1512  10        jgt  MA21                       ; BPL MA21          ; BOMB is now negative, so this skips to MA21 if our
3692                                                                          ; energy bomb is not going off
3693               
3694 11FC 028F  14        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship in Y is the space station, jump to BA21
     11FE 1000     
3695 1200 130F  10        jeq  MA21                       ; BEQ MA21          ; as energy bombs are useless against space stations
3696               
3697 1202 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; If the ship we are checking has bit 5 set in its ship
     1204 0072     
3698 1206 024D  14        andi ra,>20*256                 ; AND #%00100000    ; byte #31, then it is already exploding, so jump to
     1208 2000     
3699 120A 160A  10        jne  MA21                       ; BNE MA21          ; BA21 as ships can't explode more than once
3700               
3701 120C D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; The energy bomb is killing this ship, so set bit 7 of
     120E 0072     
3702 1210 026D  14        ori  ra,>80*256                 ; ORA #%10000000    ; the ship byte #31 to indicate that it has now been
     1212 8000     
3703 1214 D80D  22        movb ra,@INWK+31                ; STA INWK+31       ; killed
     1216 0072     
3704               
3705 1218 0200  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     121A D2F0     
3706 121C 06A0  24        bl   @jsr                       ;
     121E FE28     
3707                                                                          ; ship (so increase the kill tally, make an explosion
3708                                                                          ; sound and possibly display "RIGHT ON COMMANDER!")
3709               
3710               * ******************************************************************************
3711               *
3712               * Name: Main flight loop (Part 6 of 16)
3713               * Type: Subroutine
3714               * Category: Main loop
3715               * Summary: For each nearby ship: Move the ship in space and copy the updated
3716               * INWK data block back to K%
3717               * Deep dive: Program flow of the main game loop
3718               * Program flow of the ship-moving routine
3719               * Ship data blocks
3720               *
3721               * ------------------------------------------------------------------------------
3722               *
3723               * The main flight loop covers most of the flight-specific aspects of Elite. This
3724               * section covers the following:
3725               *
3726               * * Continue looping through all the ships in the local bubble, and for each
3727               * one:
3728               *
3729               * * Move the ship in space
3730               *
3731               * * Copy the updated ship's data block from INWK back to K%
3732               *
3733               * ******************************************************************************
3734               
3735               MA21:
3736 1220 0200  12        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the ship we are processing in space
     1222 184A     
3737 1224 06A0  24        bl   @jsr                       ;
     1226 FE28     
3738               
3739                                                                          ; Now that we are done processing this ship, we need to
3740                                                                          ; copy the ship data back from INWK to the correct place
3741                                                                          ; in the K% workspace. We already set INF in part 4 to
3742                                                                          ; point to the ship's data block in K%, so we can simply
3743                                                                          ; do the reverse of the copy we did before, this time
3744                                                                          ; copying from INWK to INF
3745               
3746 1228 020F  12        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Set a counter in Y so we can loop through the NI%
     122A 2300     
3747                                                                          ; bytes in the ship data block
3748               
3749               MAL3:
3750 122C 06CF  10        swpb ry                         ;
3751 122E D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store it in the Y-th
     1230 0053     
3752 1232 06CF  10        swpb ry                         ;
3753                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; byte of INF
     **** ****     > ST_IND_Y_IDX
0001 1234 D820  30        movb @INF,@rtmplb
     1236 0020     
     1238 8301     
0002 123A D020  22        movb @INF+1,rtmp
     123C 0021     
0003 123E 06CF  10        swpb ry
0004 1240 A00F  14        a    ry,rtmp
0005 1242 06CF  10        swpb ry
0006 1244 D40D  26        movb RA,*rtmp
                   < elite.a99
3754               
3755 1246 73C7  14        sb   rone,ry                    ; DEY               ; Decrement the loop counter
3756               
3757 1248 15F1  10        jgt  MAL3                       ; BPL MAL3          ; Loop back for the next byte, until we have copied the
3758                                                                          ; last byte from INWK back to INF
3759               
3760               * ******************************************************************************
3761               *
3762               * Name: Main flight loop (Part 7 of 16)
3763               * Type: Subroutine
3764               * Category: Main loop
3765               * Summary: For each nearby ship: Check whether we are docking, scooping or
3766               * colliding with it
3767               * Deep dive: Program flow of the main game loop
3768               *
3769               * ------------------------------------------------------------------------------
3770               *
3771               * The main flight loop covers most of the flight-specific aspects of Elite. This
3772               * section covers the following:
3773               *
3774               * * Continue looping through all the ships in the local bubble, and for each
3775               * one:
3776               *
3777               * * Check how close we are to this ship and work out if we are docking,
3778               * scooping or colliding with it
3779               *
3780               * ******************************************************************************
3781               
3782 124A D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the status of this ship from bits 5 (is ship
     124C 0072     
3783 124E 024D  14        andi ra,>a0*256                 ; AND #%10100000    ; exploding?) and bit 7 (has ship been killed?) from
     1250 A000     
3784                                                                          ; ship byte #31 into A
3785               
3786 1252 0200  12        li   rtmp,MAS4                  ; JSR MAS4          ; Or this value with x_hi, y_hi and z_hi
     1254 CBC2     
3787 1256 06A0  24        bl   @jsr                       ;
     1258 FE28     
3788               
3789 125A 1650  10        jne  MA65                       ; BNE MA65          ; If this value is non-zero, then either the ship is
3790                                                                          ; far away (i.e. has a non-zero high byte in at least
3791                                                                          ; one of the three axes), or it is already exploding,
3792                                                                          ; or has been flagged as being killed - in which case
3793                                                                          ; jump to MA65 to skip the following, as we can't dock
3794                                                                          ; scoop or collide with it
3795               
3796 125C D360  22        movb @INWK,ra                   ; LDA INWK          ; Set A = (x_lo OR y_lo OR z_lo), and if bit 7 of the
     125E 0053     
3797 1260 F360  22        socb @INWK+3,ra                 ; ORA INWK+3        ; result is set, the ship is still a fair distance
     1262 0056     
3798 1264 F360  22        socb @INWK+6,ra                 ; ORA INWK+6        ; away (further than 127 in at least one axis), so jump
     1266 0059     
3799 1268 1149  10        jlt  MA65                       ; BMI MA65          ; to MA65 to skip the following, as it's too far away to
3800                                                                          ; dock, scoop or collide with
3801               
3802 126A D3A0  22        movb @TYPE,rx                   ; LDX TYPE          ; If the current ship type is negative then it's either
     126C 009B     
3803 126E 1146  10        jlt  MA65                       ; BMI MA65          ; a planet or a sun, so jump down to MA65 to skip the
3804                                                                          ; following, as we can't dock with it or scoop it
3805               
3806 1270 028E  14        ci   rx,(SST)*256               ; CPX #SST          ; If this ship is the space station, jump to ISDK to
     1272 0800     
3807 1274 1345  10        jeq  ISDK                       ; BEQ ISDK          ; check whether we are docking with it
3808               
3809 1276 024D  14        andi ra,>c0*256                 ; AND #%11000000    ; If bit 6 of (x_lo OR y_lo OR z_lo) is set, then the
     1278 C000     
3810 127A 1640  10        jne  MA65                       ; BNE MA65          ; ship is still a reasonable distance away (further than
3811                                                                          ; 63 in at least one axis), so jump to MA65 to skip the
3812                                                                          ; following, as it's too far away to dock, scoop or
3813                                                                          ; collide with
3814               
3815 127C 028E  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If this ship is a missile, jump down to MA65 to skip
     127E 0900     
3816 1280 133D  10        jeq  MA65                       ; BEQ MA65          ; the following, as we can't scoop or dock with a
3817                                                                          ; missile, and it has its own dedicated collision
3818                                                                          ; checks in the TACTICS routine
3819               
3820 1282 028E  14        ci   rx,(OIL)*256               ; CPX #OIL          ; If ship type >= OIL (i.e. it's a cargo canister,
     1284 0B00     
3821 1286 1802  10        joc  B08                        ; BCS B08           ; Thargon or escape pod), skip the JMP instruction and
3822 1288 0460  16        b    @MA58                      ; JMP MA58          ; continue on, otherwise jump to MA58 to process a
     128A 1390     
3823                                                                          ; potential collision
3824               
3825               B08:
3826 128C D360  22        movb @BST,ra                    ; LDA BST           ; If we have fuel scoops fitted then BST will be &FF,
     128E 0329     
3827                                                                          ; otherwise it will be 0
3828               
3829                      .and @INWK+5                    ; AND INWK+5        ; Ship byte #5 contains the y_sign of this ship, so a
     **** ****     > AND
0001 1290 D020  22        movb @INWK+5,rtmp
     1292 0058     
0002 1294 0540  10        inv  rtmp
0003 1296 5340  14        szcb rtmp,ra
                   < elite.a99
3830                                                                          ; negative value here means the canister is below us,
3831                                                                          ; which means the result of the AND will be negative if
3832                                                                          ; the canister is below us and we have a fuel scoop
3833                                                                          ; fitted
3834               
3835 1298 157B  10        jgt  MA58                       ; BPL MA58          ; If the result is positive, then we either have no
3836                                                                          ; scoop or the canister is above us, and in both cases
3837                                                                          ; this means we can't scoop the item, so jump to MA58
3838                                                                          ; to process a collision
3839               
3840               * ******************************************************************************
3841               *
3842               * Name: Main flight loop (Part 8 of 16)
3843               * Type: Subroutine
3844               * Category: Main loop
3845               * Summary: For each nearby ship: Process us potentially scooping this item
3846               * Deep dive: Program flow of the main game loop
3847               *
3848               * ------------------------------------------------------------------------------
3849               *
3850               * The main flight loop covers most of the flight-specific aspects of Elite. This
3851               * section covers the following:
3852               *
3853               * * Continue looping through all the ships in the local bubble, and for each
3854               * one:
3855               *
3856               * * Process us potentially scooping this item
3857               *
3858               * ******************************************************************************
3859               
3860 129A 020D  12        li   ra,>03*256                 ; LDA #3            ; Set A to 3 to denote we may be scooping an escape pod
     129C 0300     
3861               
3862 129E 028E  14        ci   rx,(TGL)*256               ; CPX #TGL          ; If ship type < Thargon, i.e. it's a canister, jump
     12A0 0C00     
3863 12A2 1704  10        jnc  oily_                      ; BCC oily          ; to oily to randomly decide the canister's contents
3864               
3865 12A4 1609  10        jne  slvy2_                     ; BNE slvy2         ; If ship type <> Thargon, i.e. it's an escape pod,
3866                                                                          ; jump to slvy2 with A set to 3, so we scoop up the
3867                                                                          ; escape pod as slaves
3868               
3869 12A6 020D  12        li   ra,>10*256                 ; LDA #16           ; Otherwise this is a Thargon, so jump to slvy2 with
     12A8 1000     
3870 12AA 1606  10        jne  slvy2_                     ; BNE slvy2         ; A set to 16, so we scoop up the Thargon as alien items
3871                                                                          ; (this BNE is effectively a JMP as A will never be
3872                                                                          ; zero)
3873               
3874               oily_:
3875 12AC 0200  12        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers and reduce A to a
     12AE C7D0     
3876 12B0 06A0  24        bl   @jsr                       ;
     12B2 FE28     
3877 12B4 024D  14        andi ra,>07*256                 ; AND #7            ; random number in the range 0-7
     12B6 0700     
3878               
3879               slvy2_:
3880                                                                          ; By the time we get here, we are scooping, and A
3881                                                                          ; contains the type of item we are scooping (a random
3882                                                                          ; number 0-7 if we are scooping a cargo canister, 3 if
3883                                                                          ; we are scooping an escape pod, or 16 if we are
3884                                                                          ; scooping a Thargon). These numbers correspond to the
3885                                                                          ; relevant market items (see QQ23 for a list), so a
3886                                                                          ; cargo canister can contain anything from food to
3887                                                                          ; computers, while escape pods contain slaves, and
3888                                                                          ; Thargons become alien items when scooped
3889 12B8 D80D  22        movb ra,@QQ29                   ; STA QQ29          ; Call tnpr with the scooped cargo type stored in QQ29
     12BA 0F1B     
3890 12BC 020D  12        li   ra,>01*256                 ; LDA #1            ; and A set to 1, to work out whether we have room in
     12BE 0100     
3891 12C0 0200  12        li   rtmp,tnpr_                 ; JSR tnpr          ; the hold for the scooped item (A is preserved by this
     12C2 51D4     
3892 12C4 06A0  24        bl   @jsr                       ;
     12C6 FE28     
3893                                                                          ; call, and the C flag contains the result)
3894               
3895 12C8 020F  12        li   ry,>4e*256                 ; LDY #78           ; This instruction has no effect, so presumably it used
     12CA 4E00     
3896                                                                          ; to do something, but didn't get removed
3897               
3898 12CC 1849  10        joc  MA59                       ; BCS MA59          ; If the C flag is set then we have no room in the hold
3899                                                                          ; for the scooped item, so jump down to MA59 make a
3900                                                                          ; sound to indicate failure, before destroying the
3901                                                                          ; canister
3902               
3903 12CE D3E0  22        movb @QQ29,ry                   ; LDY QQ29          ; Scooping was successful, so set Y to the type of
     12D0 0F1B     
3904                                                                          ; item we just scooped, which we stored in QQ29 above
3905               
3906 12D2 06CF  10        swpb ry                         ;
3907                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Add A (which we set to 1 above) to the number of items
     **** ****     > ADC
0001 12D4 1701  10        jnc  !
0002 12D6 B347  14        ab   rone,ra
0003               !:
0004 12D8 B36F  26        ab   @QQ20(RY),ra
     12DA 0317     
                   < elite.a99
3908 12DC 06CF  10        swpb ry                         ;
3909 12DE 06CF  10        swpb ry                         ;
3910 12E0 DBCD  30        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; of type Y in the cargo hold, as we just successfully
     12E2 0317     
3911 12E4 06CF  10        swpb ry                         ;
3912                                                                          ; scooped one canister of type Y
3913               
3914 12E6 D34F  14        movb ry,ra                      ; TYA               ; Print recursive token 48 + Y as an in-flight token,
3915                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 12E8 1701  10        jnc  !
0002 12EA B347  14        ab   rone,ra
0003               !:
0004 12EC 022D  14        ai   ra,(>D0*256)
     12EE D000     
                   < elite.a99
3916 12F0 0200  12        li   rtmp,MESS                  ; JSR MESS          ; ITEMS"), so this prints the scooped item's name
     12F2 D616     
3917 12F4 06A0  24        bl   @jsr                       ;
     12F6 FE28     
3918               
3919 12F8 0460  16        b    @MA60                      ; JMP MA60          ; We are done scooping, so jump down to MA60 to set the
     12FA 1368     
3920                                                                          ; kill flag on the canister, as it no longer exists in
3921                                                                          ; the local bubble
3922               
3923               MA65:
3924 12FC 0460  16        b    @MA26                      ; JMP MA26          ; If we get here, then the ship we are processing was
     12FE 13C2     
3925                                                                          ; too far away to be scooped, docked or collided with,
3926                                                                          ; so jump to MA26 to skip over the collision routines
3927                                                                          ; and move on to missile targeting
3928               
3929               * ******************************************************************************
3930               *
3931               * Name: Main flight loop (Part 9 of 16)
3932               * Type: Subroutine
3933               * Category: Main loop
3934               * Summary: For each nearby ship: If it is a space station, check whether we
3935               * are successfully docking with it
3936               * Deep dive: Program flow of the main game loop
3937               * Docking checks
3938               *
3939               * ------------------------------------------------------------------------------
3940               *
3941               * The main flight loop covers most of the flight-specific aspects of Elite. This
3942               * section covers the following:
3943               *
3944               * * Process docking with a space station
3945               *
3946               * For details on the various docking checks in this routine, see the deep dive
3947               * on "Docking checks".
3948               *
3949               * ------------------------------------------------------------------------------
3950               *
3951               * Other entry points:
3952               *
3953               * GOIN                We jump here from part 3 of the main flight loop if the
3954               * docking computer is activated by pressing "C"
3955               *
3956               * ******************************************************************************
3957               
3958               ISDK:
3959 1300 D360  22        movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; 1. Fetch the AI counter (byte #32) of the second ship
     1302 0944     
3960 1304 1126  10        jlt  MA62                       ; BMI MA62          ; in the ship data workspace at K%, which is reserved
3961                                                                          ; for the sun or the space station (in this case it's
3962                                                                          ; the latter), and if it's negative, i.e. bit 7 is set,
3963                                                                          ; meaning the station is hostile, jump down to MA62 to
3964                                                                          ; fail docking (so trying to dock at a station that we
3965                                                                          ; have annoyed does not end well)
3966               
3967 1306 D360  22        movb @INWK+14,ra                ; LDA INWK+14       ; 2. If nosev_z_hi < 214, jump down to MA62 to fail
     1308 0061     
3968 130A 028D  14        ci   ra,>d6*256                 ; CMP #214          ; docking, as the angle of approach is greater than 26
     130C D600     
3969 130E 1721  10        jnc  MA62                       ; BCC MA62          ; degrees
3970               
3971 1310 0200  12        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to get the vector to the space station
     1312 B37C     
3972 1314 06A0  24        bl   @jsr                       ;
     1316 FE28     
3973                                                                          ; into XX15
3974               
3975 1318 D360  22        movb @XX15+2,ra                 ; LDA XX15+2        ; 3. Check the sign of the z-axis (bit 7 of XX15+2) and
     131A 0033     
3976 131C 111A  10        jlt  MA62                       ; BMI MA62          ; if it is negative, we are facing away from the
3977                                                                          ; station, so jump to MA62 to fail docking
3978               
3979 131E 028D  14        ci   ra,>59*256                 ; CMP #89           ; 4. If z-axis < 89, jump to MA62 to fail docking, as
     1320 5900     
3980 1322 1717  10        jnc  MA62                       ; BCC MA62          ; we are not in the 22.0 degree safe cone of approach
3981               
3982 1324 D360  22        movb @INWK+16,ra                ; LDA INWK+16       ; 5. If |roofv_x_hi| < 80, jump to MA62 to fail docking,
     1326 0063     
3983 1328 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; as the slot is more than 36.6 degrees from horizontal
     132A 7F00     
3984 132C 028D  14        ci   ra,>50*256                 ; CMP #80
     132E 5000     
3985 1330 1710  10        jnc  MA62                       ; BCC MA62
3986               
3987               GOIN:
3988                                                                          ; If we arrive here, either the docking computer has
3989                                                                          ; been activated, or we just docked successfully
3990 1332 020D  12        li   ra,>00*256                 ; LDA #0            ; Set the on-screen hyperspace counter to 0
     1334 0000     
3991 1336 D80D  22        movb ra,@QQ22+1                 ; STA QQ22+1
     1338 002F     
3992               
3993 133A 020D  12        li   ra,>08*256                 ; LDA #8            ; This instruction has no effect, so presumably it used
     133C 0800     
3994                                                                          ; to do something, and didn't get removed
3995               
3996 133E 0200  12        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     1340 41C2     
3997 1342 06A0  24        bl   @jsr                       ;
     1344 FE28     
3998               
3999 1346 0200  12        li   rtmp,RES4                  ; JSR RES4          ; Reset the shields and energy banks, stardust and INWK
     1348 C66E     
4000 134A 06A0  24        bl   @jsr                       ;
     134C FE28     
4001                                                                          ; workspace
4002               
4003 134E 0460  20        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     1350 CDBC     
4004                                                                          ; screen)
4005               
4006               MA62:
4007                                                                          ; If we arrive here, docking has just failed
4008 1352 D360  22        movb @DELTA,ra                  ; LDA DELTA         ; If the ship's speed is < 5, jump to MA67 to register
     1354 008C     
4009 1356 028D  14        ci   ra,>05*256                 ; CMP #5            ; some damage, but not a huge amount
     1358 0500     
4010 135A 1713  10        jnc  MA67                       ; BCC MA67
4011               
4012 135C 0460  20        b    @DEATH                     ; JMP DEATH         ; Otherwise we have just crashed into the station, so
     135E CBD2     
4013                                                                          ; process our death
4014               
4015               * ******************************************************************************
4016               *
4017               * Name: Main flight loop (Part 10 of 16)
4018               * Type: Subroutine
4019               * Category: Main loop
4020               * Summary: For each nearby ship: Remove if scooped, or process collisions
4021               * Deep dive: Program flow of the main game loop
4022               *
4023               * ------------------------------------------------------------------------------
4024               *
4025               * The main flight loop covers most of the flight-specific aspects of Elite. This
4026               * section covers the following:
4027               *
4028               * * Continue looping through all the ships in the local bubble, and for each
4029               * one:
4030               *
4031               * * Remove scooped item after both successful and failed scooping attempts
4032               *
4033               * * Process collisions
4034               *
4035               * ******************************************************************************
4036               
4037               MA59:
4038                                                                          ; If we get here then scooping failed
4039 1360 0200  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the cargo canister being destroyed
     1362 D2BE     
4040 1364 06A0  24        bl   @jsr                       ;
     1366 FE28     
4041                                                                          ; and fall through into MA60 to remove the canister
4042                                                                          ; from our local bubble
4043               
4044               MA60:
4045                                                                          ; If we get here then scooping was successful
4046                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the scooped or destroyed item, to denote
     **** ****     > ASL
0001 1368 D020  22        movb @INWK+31,rtmp
     136A 0072     
0002 136C 0240  14        andi rtmp,>ff00
     136E FF00     
0003 1370 0A10  14        sla  rtmp,1
0004 1372 D800  22        movb rtmp,@INWK+31
     1374 0072     
                   < elite.a99
4047                      .sec                            ; SEC               ; that it has been killed and should be removed from
     **** ****     > SEC
0001 1376 0A18  14        sla  rmone,1
                   < elite.a99
4048 1378 0204  12        li   rarg1,INWK+31              ; ROR INWK+31       ; the local bubble
     137A 0072     
4049 137C 06A0  24        bl   @ror                       ;
     137E FE7A     
4050               
4051               MA61:
4052 1380 1620  10        jne  MA26                       ; BNE MA26          ; Jump to MA26 to skip over the collision routines and
4053                                                                          ; to move on to missile targeting (this BNE is
4054                                                                          ; effectively a JMP as A will never be zero)
4055               
4056               MA67:
4057                                                                          ; If we get here then we have collided with something,
4058                                                                          ; but not fatally
4059 1382 020D  12        li   ra,>01*256                 ; LDA #1            ; Set the speed in DELTA to 1 (i.e. a sudden stop)
     1384 0100     
4060 1386 D80D  22        movb ra,@DELTA                  ; STA DELTA
     1388 008C     
4061               
4062 138A 020D  12        li   ra,>05*256                 ; LDA #5            ; Set the amount of damage in A to 5 (a small dent) and
     138C 0500     
4063 138E 1611  10        jne  MA63                       ; BNE MA63          ; jump down to MA63 to process the damage (this BNE is
4064                                                                          ; effectively a JMP as A will never be zero)
4065               
4066               MA58:
4067                                                                          ; If we get here, we have collided with something in a
4068                                                                          ; potentially fatal way
4069                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the ship we just collided with, to
     **** ****     > ASL
0001 1390 D020  22        movb @INWK+31,rtmp
     1392 0072     
0002 1394 0240  14        andi rtmp,>ff00
     1396 FF00     
0003 1398 0A10  14        sla  rtmp,1
0004 139A D800  22        movb rtmp,@INWK+31
     139C 0072     
                   < elite.a99
4070                      .sec                            ; SEC               ; denote that it has been killed and should be removed
     **** ****     > SEC
0001 139E 0A18  14        sla  rmone,1
                   < elite.a99
4071 13A0 0204  12        li   rarg1,INWK+31              ; ROR INWK+31       ; from the local bubble
     13A2 0072     
4072 13A4 06A0  24        bl   @ror                       ;
     13A6 FE7A     
4073               
4074 13A8 D360  22        movb @INWK+35,ra                ; LDA INWK+35       ; Load A with the energy level of the ship we just hit
     13AA 0076     
4075               
4076                      .sec                            ; SEC               ; Set the amount of damage in A to 128 + A / 2, so
     **** ****     > SEC
0001 13AC 0A18  14        sla  rmone,1
                   < elite.a99
4077 13AE 06A0  24        bl   @rora                      ; ROR A             ; this is quite a big dent, and colliding with higher
     13B0 FE62     
4078                                                                          ; energy ships will cause more damage
4079               
4080               MA63:
4081 13B2 0200  12        li   rtmp,OOPS                  ; JSR OOPS          ; The amount of damage is in A, so call OOPS to reduce
     13B4 B4B6     
4082 13B6 06A0  24        bl   @jsr                       ;
     13B8 FE28     
4083                                                                          ; our shields, and if the shields are gone, there's a
4084                                                                          ; chance of cargo loss or even death
4085               
4086 13BA 0200  12        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of colliding with the other ship and
     13BC D2BE     
4087 13BE 06A0  24        bl   @jsr                       ;
     13C0 FE28     
4088                                                                          ; fall through into MA26 to try targeting a missile
4089               
4090               * ******************************************************************************
4091               *
4092               * Name: Main flight loop (Part 11 of 16)
4093               * Type: Subroutine
4094               * Category: Main loop
4095               * Summary: For each nearby ship: Process missile lock and firing our laser
4096               * Deep dive: Program flow of the main game loop
4097               * Flipping axes between space views
4098               *
4099               * ------------------------------------------------------------------------------
4100               *
4101               * The main flight loop covers most of the flight-specific aspects of Elite. This
4102               * section covers the following:
4103               *
4104               * * Continue looping through all the ships in the local bubble, and for each
4105               * one:
4106               *
4107               * * If this is not the front space view, flip the axes of the ship's
4108               * coordinates in INWK
4109               *
4110               * * Process missile lock
4111               *
4112               * * Process our laser firing
4113               *
4114               * ******************************************************************************
4115               
4116               MA26:
4117 13C2 D360  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to MA15 to skip
     13C4 0096     
4118 13C6 1664  10        jne  MA15                       ; BNE MA15          ; missile and laser locking
4119               
4120 13C8 0200  12        li   rtmp,PLUT                  ; JSR PLUT          ; Call PLUT to update the geometric axes in INWK to
     13CA 4D38     
4121 13CC 06A0  24        bl   @jsr                       ;
     13CE FE28     
4122                                                                          ; match the view (front, rear, left, right)
4123               
4124 13D0 0200  12        li   rtmp,HITCH                 ; JSR HITCH         ; Call HITCH to see if this ship is in the crosshairs,
     13D2 3E6A     
4125 13D4 06A0  24        bl   @jsr                       ;
     13D6 FE28     
4126 13D8 1757  10        jnc  MA8                        ; BCC MA8           ; in which case the C flag will be set (so if there is
4127                                                                          ; no missile or laser lock, we jump to MA8 to skip the
4128                                                                          ; following)
4129               
4130 13DA D360  22        movb @MSAR,ra                   ; LDA MSAR          ; We have missile lock, so check whether the leftmost
     13DC 0D5E     
4131 13DE 130C  10        jeq  MA47                       ; BEQ MA47          ; missile is currently armed, and if not, jump to MA47
4132                                                                          ; to process laser fire, as we can't lock an unarmed
4133                                                                          ; missile
4134               
4135 13E0 0200  12        li   rtmp,BEEP                  ; JSR BEEP          ; We have missile lock and an armed missile, so call
     13E2 D33C     
4136 13E4 06A0  24        bl   @jsr                       ;
     13E6 FE28     
4137                                                                          ; the BEEP subroutine to make a short, high beep
4138               
4139 13E8 D3A0  22        movb @XSAV,rx                   ; LDX XSAV          ; Call ABORT2 to store the details of this missile
     13EA 0093     
4140 13EC 020F  12        li   ry,>0e*256                 ; LDY #&0E          ; lock, with the targeted ship's slot number in X
     13EE 0E00     
4141 13F0 0200  12        li   rtmp,ABORT2                ; JSR ABORT2        ; (which we stored in XSAV at the start of this ship's
     13F2 B732     
4142 13F4 06A0  24        bl   @jsr                       ;
     13F6 FE28     
4143                                                                          ; loop at MAL1), and set the colour of the missile
4144                                                                          ; indicator to the colour in Y (red = &0E)
4145               
4146               MA47:
4147                                                                          ; If we get here then the ship is in our sights, but
4148                                                                          ; we didn't lock a missile, so let's see if we're
4149                                                                          ; firing the laser
4150 13F8 D360  22        movb @LAS,ra                    ; LDA LAS           ; If we are firing the laser then LAS will contain the
     13FA 0051     
4151 13FC 1345  10        jeq  MA8                        ; BEQ MA8           ; laser power (which we set in MA68 above), so if this
4152                                                                          ; is zero, jump down to MA8 to skip the following
4153               
4154 13FE 020E  12        li   rx,>0f*256                 ; LDX #15           ; We are firing our laser and the ship in INWK is in
     1400 0F00     
4155 1402 0200  12        li   rtmp,EXNO                  ; JSR EXNO          ; the crosshairs, so call EXNO to make the sound of
     1404 D306     
4156 1406 06A0  24        bl   @jsr                       ;
     1408 FE28     
4157                                                                          ; us making a laser strike on another ship
4158               
4159 140A D360  22        movb @INWK+35,ra                ; LDA INWK+35       ; Fetch the hit ship's energy from byte #35 and subtract
     140C 0076     
4160                      .sec                            ; SEC               ; our current laser power, and if the result is greater
     **** ****     > SEC
0001 140E 0A18  14        sla  rmone,1
                   < elite.a99
4161                      .sbc @LAS,ra                    ; SBC LAS           ; than zero, the other ship has survived the hit, so
     **** ****     > SBC
0001 1410 1801  10        joc  !
0002 1412 7347  14        sb   rone,ra
0003               !:
0004 1414 7360  22        sb   @LAS,ra
     1416 0051     
                   < elite.a99
4162 1418 182F  10        joc  MA14                       ; BCS MA14          ; jump down to MA14 to make it angry
4163               
4164 141A D360  22        movb @TYPE,ra                   ; LDA TYPE          ; Did we just hit the space station? If so, jump to
     141C 009B     
4165 141E 028D  14        ci   ra,(SST)*256               ; CMP #SST          ; MA14+2 to make the station hostile, skipping the
     1420 0800     
4166 1422 132B  10        jeq  MA14+2                     ; BEQ MA14+2        ; following as we can't destroy a space station
4167               
4168 1424 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 7 of the enemy ship's byte #31, to indicate
     1426 0072     
4169 1428 026D  14        ori  ra,>80*256                 ; ORA #%10000000    ; that it has been killed
     142A 8000     
4170 142C D80D  22        movb ra,@INWK+31                ; STA INWK+31
     142E 0072     
4171               
4172 1430 182B  10        joc  MA8                        ; BCS MA8           ; If the enemy ship type is >= SST (i.e. missile,
4173                                                                          ; asteroid, canister, Thargon or escape pod) then
4174                                                                          ; jump down to MA8
4175               
4176 1432 0200  12        li   rtmp,DORND                 ; JSR DORND         ; Fetch a random number, and jump to oh if it is
     1434 C7D0     
4177 1436 06A0  24        bl   @jsr                       ;
     1438 FE28     
4178 143A 151A  10        jgt  oh_                        ; BPL oh            ; positive (50% chance)
4179               
4180 143C 020F  12        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte of the hit ship's blueprint,
     143E 0000     
4181                      .and_ind_y_idx @XX0,ra          ; AND (XX0),Y       ; which determines the maximum number of bits of
     **** ****     > AND_IND_Y_IDX
0001 1440 D820  30        movb @XX0,@rtmplb
     1442 001E     
     1444 8301     
0002 1446 D020  22        movb @XX0+1,rtmp
     1448 001F     
0003 144A 06CF  10        swpb ry
0004 144C A00F  14        a    ry,rtmp
0005 144E 06CF  10        swpb ry
0006 1450 D010  22        movb *rtmp,rtmp
0007 1452 0540  10        inv  rtmp
0008 1454 5340  14        szcb rtmp,RA
                   < elite.a99
4182                                                                          ; debris shown when the ship is destroyed, and AND
4183                                                                          ; with the random number we just fetched
4184               
4185 1456 D80D  22        movb ra,@CNT                    ; STA CNT           ; Store the result in CNT, so CNT contains a random
     1458 00A4     
4186                                                                          ; number between 0 and the maximum number of bits of
4187                                                                          ; debris that this ship will release when destroyed
4188               
4189               um_:
4190 145A 130A  10        jeq  oh_                        ; BEQ oh            ; We're going to go round a loop using CNT as a counter
4191                                                                          ; so this checks whether the counter is zero and jumps
4192                                                                          ; to oh when it gets there (which might be straight
4193                                                                          ; away)
4194               
4195 145C 020E  12        li   rx,(OIL)*256               ; LDX #OIL          ; Call SFS1 to spawn a cargo canister from the now
     145E 0B00     
4196 1460 020D  12        li   ra,>00*256                 ; LDA #0            ; deceased parent ship, giving the spawned canister an
     1462 0000     
4197 1464 0200  12        li   rtmp,SFS1                  ; JSR SFS1          ; AI flag of 0 (no AI, no E.C.M., non-hostile)
     1466 404A     
4198 1468 06A0  24        bl   @jsr                       ;
     146A FE28     
4199               
4200 146C 7347  14        sb   rone,ra                    ; DEC CNT           ; Decrease the loop counter
4201               
4202 146E 15F5  10        jgt  um_                        ; BPL um            ; Jump back up to um (this BPL is effectively a JMP as
4203                                                                          ; CNT will never be negative)
4204               
4205               oh_:
4206 1470 0200  12        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     1472 D2F0     
4207 1474 06A0  24        bl   @jsr                       ;
     1476 FE28     
4208                                                                          ; ship (so increase the kill tally, make an explosion
4209                                                                          ; sound and so on)
4210               
4211               MA14:
4212 1478 D80D  22        movb ra,@INWK+35                ; STA INWK+35       ; Store the hit ship's updated energy in ship byte #35
     147A 0076     
4213               
4214 147C D360  22        movb @TYPE,ra                   ; LDA TYPE          ; Call ANGRY to make this ship hostile, now that we
     147E 009B     
4215 1480 0200  12        li   rtmp,ANGRY                 ; JSR ANGRY         ; have hit it
     1482 3F9E     
4216 1484 06A0  24        bl   @jsr                       ;
     1486 FE28     
4217               
4218               * ******************************************************************************
4219               *
4220               * Name: Main flight loop (Part 12 of 16)
4221               * Type: Subroutine
4222               * Category: Main loop
4223               * Summary: For each nearby ship: Draw the ship, remove if killed, loop back
4224               * Deep dive: Program flow of the main game loop
4225               * Drawing ships
4226               *
4227               * ------------------------------------------------------------------------------
4228               *
4229               * The main flight loop covers most of the flight-specific aspects of Elite. This
4230               * section covers the following:
4231               *
4232               * * Continue looping through all the ships in the local bubble, and for each
4233               * one:
4234               *
4235               * * Draw the ship
4236               *
4237               * * Process removal of killed ships
4238               *
4239               * * Loop back up to MAL1 to move onto the next ship in the local bubble
4240               *
4241               * ******************************************************************************
4242               
4243               MA8:
4244 1488 0200  12        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the ship we're processing on-screen
     148A DCBC     
4245 148C 06A0  24        bl   @jsr                       ;
     148E FE28     
4246               
4247               MA15:
4248 1490 020F  12        li   ry,>23*256                 ; LDY #35           ; Fetch the ship's energy from byte #35 and copy it to
     1492 2300     
4249 1494 D360  22        movb @INWK+35,ra                ; LDA INWK+35       ; byte #35 in INF (so the ship's data in K% gets
     1496 0076     
4250                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; updated)
     **** ****     > ST_IND_Y_IDX
0001 1498 D820  30        movb @INF,@rtmplb
     149A 0020     
     149C 8301     
0002 149E D020  22        movb @INF+1,rtmp
     14A0 0021     
0003 14A2 06CF  10        swpb ry
0004 14A4 A00F  14        a    ry,rtmp
0005 14A6 06CF  10        swpb ry
0006 14A8 D40D  26        movb RA,*rtmp
                   < elite.a99
4251               
4252 14AA D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 7 of the ship's byte #31 is clear, then the
     14AC 0072     
4253 14AE 1537  10        jgt  MAC1                       ; BPL MAC1          ; ship hasn't been killed by energy bomb, collision or
4254                                                                          ; laser fire, so jump to MAC1 to skip the following
4255               
4256 14B0 024D  14        andi ra,>20*256                 ; AND #%00100000    ; If bit 5 of the ship's byte #31 is clear then the
     14B2 2000     
4257 14B4 1334  10        jeq  NBOUN                      ; BEQ NBOUN         ; ship is no longer exploding, so jump to NBOUN to skip
4258                                                                          ; the following
4259               
4260 14B6 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we just destroyed was a cop, keep going,
     14B8 009B     
4261 14BA 028D  14        ci   ra,(COPS)*256              ; CMP #COPS         ; otherwise jump to q2 to skip the following
     14BC 0200     
4262 14BE 1606  10        jne  q2_                        ; BNE q2
4263               
4264 14C0 D360  22        movb @FIST,ra                   ; LDA FIST          ; We shot the sheriff, so update our FIST flag
     14C2 0334     
4265 14C4 026D  14        ori  ra,>40*256                 ; ORA #64           ; ("fugitive/innocent status") to at least 64, which
     14C6 4000     
4266 14C8 D80D  22        movb ra,@FIST                   ; STA FIST          ; will instantly make us a fugitive
     14CA 0334     
4267               
4268               q2_:
4269 14CC D360  22        movb @DLY,ra                    ; LDA DLY           ; If we already have an in-flight message on-screen (in
     14CE 0D64     
4270 14D0 F360  22        socb @MJ,ra                     ; ORA MJ            ; which case DLY > 0), or we are in witchspace (in
     14D2 0D5C     
4271 14D4 1622  10        jne  KS1S                       ; BNE KS1S          ; which case MJ > 0), jump to KS1S to skip showing an
4272                                                                          ; on-screen bounty for this kill
4273               
4274 14D6 020F  12        li   ry,>0a*256                 ; LDY #10           ; Fetch byte #10 of the ship's blueprint, which is the
     14D8 0A00     
4275                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the bounty awarded when this ship is
     **** ****     > LD_IND_Y_IDX
0001 14DA D820  30        movb @XX0,@rtmplb
     14DC 001E     
     14DE 8301     
0002 14E0 D020  22        movb @XX0+1,rtmp
     14E2 001F     
0003 14E4 06CF  10        swpb ry
0004 14E6 A00F  14        a    ry,rtmp
0005 14E8 06CF  10        swpb ry
0006 14EA D350  22        movb *rtmp,RA
                   < elite.a99
4276 14EC 1316  10        jeq  KS1S                       ; BEQ KS1S          ; killed (in Cr * 10), and if it's zero jump to KS1S as
4277                                                                          ; there is no on-screen bounty to display
4278               
4279 14EE D38D  14        movb ra,rx                      ; TAX               ; Put the low byte of the bounty into X
4280               
4281 14F0 B3C7  14        ab   rone,ry                    ; INY               ; Fetch byte #11 of the ship's blueprint, which is the
4282                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; high byte of the bounty awarded (in Cr * 10), and put
     **** ****     > LD_IND_Y_IDX
0001 14F2 D820  30        movb @XX0,@rtmplb
     14F4 001E     
     14F6 8301     
0002 14F8 D020  22        movb @XX0+1,rtmp
     14FA 001F     
0003 14FC 06CF  10        swpb ry
0004 14FE A00F  14        a    ry,rtmp
0005 1500 06CF  10        swpb ry
0006 1502 D350  22        movb *rtmp,RA
                   < elite.a99
4283 1504 D3CD  14        movb ra,ry                      ; TAY               ; it into Y
4284               
4285 1506 0200  12        li   rtmp,MCASH                 ; JSR MCASH         ; Call MCASH to add (Y X) to the cash pot
     1508 A736     
4286 150A 06A0  24        bl   @jsr                       ;
     150C FE28     
4287               
4288 150E 020D  12        li   ra,>00*256                 ; LDA #0            ; Print control code 0 (current cash, right-aligned to
     1510 0000     
4289 1512 0200  12        li   rtmp,MESS                  ; JSR MESS          ; width 9, then " CR", newline) as an in-flight message
     1514 D616     
4290 1516 06A0  24        bl   @jsr                       ;
     1518 FE28     
4291               
4292               KS1S:
4293 151A 0460  20        b    @KS1                       ; JMP KS1           ; Process the killing of this ship (which removes this
     151C C330     
4294                                                                          ; ship from its slot and shuffles all the other ships
4295                                                                          ; down to close up the gap)
4296               
4297               NBOUN:
4298                      equ  $
4299               MAC1:
4300 151E D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship we are processing is a planet or sun,
     1520 009B     
4301 1522 1105  10        jlt  MA27                       ; BMI MA27          ; jump to MA27 to skip the following two instructions
4302               
4303 1524 0200  12        li   rtmp,FAROF                 ; JSR FAROF         ; If the ship we are processing is a long way away (its
     1526 CBAA     
4304 1528 06A0  24        bl   @jsr                       ;
     152A FE28     
4305 152C 17F6  10        jnc  KS1S                       ; BCC KS1S          ; distance in any one direction is > 224, jump to KS1S
4306                                                                          ; to remove the ship from our local bubble, as it's just
4307                                                                          ; left the building
4308               
4309               MA27:
4310 152E 020F  12        li   ry,>1f*256                 ; LDY #31           ; Fetch the ship's explosion/killed state from byte #31
     1530 1F00     
4311 1532 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; and copy it to byte #31 in INF (so the ship's data in
     1534 0072     
4312                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; K% gets updated)
     **** ****     > ST_IND_Y_IDX
0001 1536 D820  30        movb @INF,@rtmplb
     1538 0020     
     153A 8301     
0002 153C D020  22        movb @INF+1,rtmp
     153E 0021     
0003 1540 06CF  10        swpb ry
0004 1542 A00F  14        a    ry,rtmp
0005 1544 06CF  10        swpb ry
0006 1546 D40D  26        movb RA,*rtmp
                   < elite.a99
4313               
4314 1548 D3A0  22        movb @XSAV,rx                   ; LDX XSAV          ; We're done processing this ship, so fetch the ship's
     154A 0093     
4315                                                                          ; slot number, which we saved in XSAV back at the start
4316                                                                          ; of the loop
4317               
4318 154C B387  14        ab   rone,rx                    ; INX               ; Increment the slot number to move on to the next slot
4319               
4320 154E 0460  16        b    @MAL1                      ; JMP MAL1          ; And jump back up to the beginning of the loop to get
     1550 1190     
4321                                                                          ; the next ship in the local bubble for processing
4322               
4323               * ******************************************************************************
4324               *
4325               * Name: Main flight loop (Part 13 of 16)
4326               * Type: Subroutine
4327               * Category: Main loop
4328               * Summary: Show energy bomb effect, charge shields and energy banks
4329               * Deep dive: Program flow of the main game loop
4330               * Scheduling tasks with the main loop counter
4331               *
4332               * ------------------------------------------------------------------------------
4333               *
4334               * The main flight loop covers most of the flight-specific aspects of Elite. This
4335               * section covers the following:
4336               *
4337               * * Show energy bomb effect (if applicable)
4338               *
4339               * * Charge shields and energy banks (every 7 iterations of the main loop)
4340               *
4341               * ******************************************************************************
4342               
4343               MA18:
4344 1552 D360  22        movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
     1554 032A     
4345 1556 150F  10        jgt  MA77                       ; BPL MA77          ; BOMB is now negative, so this skips to MA21 if our
4346                                                                          ; energy bomb is not going off
4347               
4348                      .asl @BOMB                      ; ASL BOMB          ; We set off our energy bomb, so rotate BOMB to the
     **** ****     > ASL
0001 1558 D020  22        movb @BOMB,rtmp
     155A 032A     
0002 155C 0240  14        andi rtmp,>ff00
     155E FF00     
0003 1560 0A10  14        sla  rtmp,1
0004 1562 D800  22        movb rtmp,@BOMB
     1564 032A     
                   < elite.a99
4349                                                                          ; left by one place. BOMB was rotated left once already
4350                                                                          ; during this iteration of the main loop, back at MA24,
4351                                                                          ; so if this is the first pass it will already be
4352                                                                          ; %11111110, and this will shift it to %11111100 - so
4353                                                                          ; if we set off an energy bomb, it stays activated
4354                                                                          ; (BOMB > 0) for four iterations of the main loop
4355               
4356 1566 0200  12        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     1568 51C2     
4357 156A 06A0  24        bl   @jsr                       ;
     156C FE28     
4358                                                                          ; screen gets drawn and the following palette change
4359                                                                          ; won't kick in while the screen is still refreshing
4360               
4361 156E 020D  12        li   ra,>30*256                 ; LDA #%00110000    ; Set the palette byte at SHEILA &21 to map logical
     1570 3000     
4362 1572 D80D  30        movb ra,@VIA+>21                ; STA VIA+&21       ; colour 0 to physical colour 7 (white), but with only
     1574 FE21     
4363                                                                          ; one mapping (rather than the 7 mappings required to
4364                                                                          ; do the mapping properly). This makes the space screen
4365                                                                          ; flash with black and white stripes. See p.382 of the
4366                                                                          ; Advanced User Guide for details of why this single
4367                                                                          ; palette change creates a special effect
4368               
4369               MA77:
4370 1576 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 7,
     1578 0099     
4371 157A 024D  14        andi ra,>07*256                 ; AND #7            ; jumping to MA22 if it is non-zero (so the following
     157C 0700     
4372 157E 1668  10        jne  MA22                       ; BNE MA22          ; code only runs every 8 iterations of the main loop)
4373               
4374 1580 D3A0  22        movb @ENERGY,rx                 ; LDX ENERGY        ; Fetch our ship's energy levels and skip to b if bit 7
     1582 0F13     
4375 1584 1510  10        jgt  b_                         ; BPL b             ; is not set, i.e. only charge the shields from the
4376                                                                          ; energy banks if they are at more than 50% charge
4377               
4378 1586 D3A0  22        movb @ASH,rx                    ; LDX ASH           ; Call SHD to recharge our aft shield and update the
     1588 0F12     
4379 158A 0200  12        li   rtmp,SHD                   ; JSR SHD           ; shield status in ASH
     158C B302     
4380 158E 06A0  24        bl   @jsr                       ;
     1590 FE28     
4381 1592 D80E  22        movb rx,@ASH                    ; STX ASH
     1594 0F12     
4382               
4383 1596 D3A0  22        movb @FSH,rx                    ; LDX FSH           ; Call SHD to recharge our forward shield and update
     1598 0F11     
4384 159A 0200  12        li   rtmp,SHD                   ; JSR SHD           ; the shield status in FSH
     159C B302     
4385 159E 06A0  24        bl   @jsr                       ;
     15A0 FE28     
4386 15A2 D80E  22        movb rx,@FSH                    ; STX FSH
     15A4 0F11     
4387               
4388               b_:
4389                      .sec                            ; SEC               ; Set A = ENERGY + ENGY + 1, so our ship's energy
     **** ****     > SEC
0001 15A6 0A18  14        sla  rmone,1
                   < elite.a99
4390 15A8 D360  22        movb @ENGY,ra                   ; LDA ENGY          ; level goes up by 2 if we have an energy unit fitted,
     15AA 032B     
4391                      .adc @ENERGY,ra                 ; ADC ENERGY        ; otherwise it goes up by 1
     **** ****     > ADC
0001 15AC 1701  10        jnc  !
0002 15AE B347  14        ab   rone,ra
0003               !:
0004 15B0 B360  22        ab   @ENERGY,ra
     15B2 0F13     
                   < elite.a99
4392               
4393 15B4 1802  10        joc  B09                        ; BCS B09           ; If the value of A did not overflow (the maximum
4394 15B6 D80D  22        movb ra,@ENERGY                 ; STA ENERGY        ; energy level is &FF), then store A in ENERGY
     15B8 0F13     
4395               
4396               * ******************************************************************************
4397               *
4398               * Name: Main flight loop (Part 14 of 16)
4399               * Type: Subroutine
4400               * Category: Main loop
4401               * Summary: Spawn a space station if we are close enough to the planet
4402               * Deep dive: Program flow of the main game loop
4403               * Scheduling tasks with the main loop counter
4404               * Ship data blocks
4405               * The space station safe zone
4406               *
4407               * ------------------------------------------------------------------------------
4408               *
4409               * The main flight loop covers most of the flight-specific aspects of Elite. This
4410               * section covers the following:
4411               *
4412               * * Spawn a space station if we are close enough to the planet (every 32
4413               * iterations of the main loop)
4414               *
4415               * ******************************************************************************
4416               
4417               B09:
4418 15BA D360  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23S to skip
     15BC 0D5C     
4419 15BE 1646  10        jne  MA23S                      ; BNE MA23S         ; the following, as there are no space stations in
4420                                                                          ; witchspace
4421               
4422 15C0 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     15C2 0099     
4423 15C4 024D  14        andi ra,>1f*256                 ; AND #31           ; jumping to MA93 if it is on-zero (so the following
     15C6 1F00     
4424 15C8 164A  10        jne  MA93                       ; BNE MA93          ; code only runs every 32 iterations of the main loop)
4425               
4426 15CA D360  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     15CC 0D55     
4427 15CE 163E  10        jne  MA23S                      ; BNE MA23S         ; MA23S to skip the following, as we already have a
4428                                                                          ; space station and don't need another
4429               
4430 15D0 D3CD  14        movb ra,ry                      ; TAY               ; Set Y = A = 0 (A is 0 as we didn't branch with the
4431                                                                          ; previous BNE instruction)
4432               
4433 15D2 0200  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     15D4 17D6     
4434 15D6 06A0  24        bl   @jsr                       ;
     15D8 FE28     
4435 15DA 1638  10        jne  MA23S                      ; BNE MA23S         ; planet in any of the three axes, and if it's
4436                                                                          ; non-zero, jump to MA23S to skip the following, as we
4437                                                                          ; are too far from the planet to bump into a space
4438                                                                          ; station
4439               
4440                                                                          ; We now want to spawn a space station, so first we
4441                                                                          ; need to set up a ship data block for the station in
4442                                                                          ; INWK that we can then pass to NWSPS to add a new
4443                                                                          ; station to our bubble of universe. We do this by
4444                                                                          ; copying the planet data block from K% to INWK so we
4445                                                                          ; can work on it, but we only need the first 29 bytes,
4446                                                                          ; as we don't need to worry about bytes #29 to #35
4447                                                                          ; for planets (as they don't have rotation counters,
4448                                                                          ; AI, explosions, missiles, a ship line heap or energy
4449                                                                          ; levels)
4450               
4451 15DC 020E  12        li   rx,>1c*256                 ; LDX #28           ; So we set a counter in X to copy 29 bytes from K%+0
     15DE 1C00     
4452                                                                          ; to K%+28
4453               
4454               MAL4:
4455 15E0 06CE  10        swpb rx                         ;
4456 15E2 D36E  26        movb @K.(rx),ra                 ; LDA K%,X          ; Load the X-th byte of K% and store in the X-th byte
     15E4 0900     
4457 15E6 06CE  10        swpb rx                         ;
4458 15E8 06CE  10        swpb rx                         ;
4459 15EA DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; of the INWK workspace
     15EC 0053     
4460 15EE 06CE  10        swpb rx                         ;
4461               
4462 15F0 7387  14        sb   rone,rx                    ; DEX               ; Decrement the loop counter
4463               
4464 15F2 15F6  10        jgt  MAL4                       ; BPL MAL4          ; Loop back for the next byte until we have copied the
4465                                                                          ; first 28 bytes of K% to INWK
4466               
4467                                                                          ; We now check the distance from our ship (at the
4468                                                                          ; origin) towards the point where we will spawn the
4469                                                                          ; space station if we are close enough
4470                                                                          ;
4471                                                                          ; This point is calculated by starting at the planet's
4472                                                                          ; centre and adding 2 * nosev, which takes us to a point
4473                                                                          ; above the planet's surface, at an altitude that
4474                                                                          ; matches the planet's radius
4475                                                                          ;
4476                                                                          ; This point pitches and rolls around the planet as the
4477                                                                          ; nosev vector rotates with the planet, and if our ship
4478                                                                          ; is within a distance of (192 0) from this point in all
4479                                                                          ; three axes, then we spawn the space station at this
4480                                                                          ; point, with the station's slot facing towards the
4481                                                                          ; planet, along the nosev vector
4482                                                                          ;
4483                                                                          ; This works because in the following, we calculate the
4484                                                                          ; station's coordinates one axis at a time, and store
4485                                                                          ; the results in the INWK block, so by the time we have
4486                                                                          ; calculated and checked all three, the ship data block
4487                                                                          ; is set up with the correct spawning coordinates
4488               
4489 15F4 B387  14        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X as &FF)
4490               
4491 15F6 020F  12        li   ry,>09*256                 ; LDY #9            ; Call MAS1 with X = 0, Y = 9 to do the following:
     15F8 0900     
4492 15FA 0200  12        li   rtmp,MAS1                  ; JSR MAS1          ;
     15FC 177C     
4493 15FE 06A0  24        bl   @jsr                       ;
     1600 FE28     
4494                                                                          ; (x_sign x_hi x_lo) += (nosev_x_hi nosev_x_lo) * 2
4495                                                                          ;
4496                                                                          ; A = |x_sign|
4497               
4498 1602 1624  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4499                                                                          ; are too far from the planet in the x-direction to
4500                                                                          ; bump into a space station
4501               
4502 1604 020E  12        li   rx,>03*256                 ; LDX #3            ; Call MAS1 with X = 3, Y = 11 to do the following:
     1606 0300     
4503 1608 020F  12        li   ry,>0b*256                 ; LDY #11           ;
     160A 0B00     
4504 160C 0200  12        li   rtmp,MAS1                  ; JSR MAS1          ; (y_sign y_hi y_lo) += (nosev_y_hi nosev_y_lo) * 2
     160E 177C     
4505 1610 06A0  24        bl   @jsr                       ;
     1612 FE28     
4506                                                                          ;
4507                                                                          ; A = |y_sign|
4508               
4509 1614 161B  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4510                                                                          ; are too far from the planet in the y-direction to
4511                                                                          ; bump into a space station
4512               
4513 1616 020E  12        li   rx,>06*256                 ; LDX #6            ; Call MAS1 with X = 6, Y = 13 to do the following:
     1618 0600     
4514 161A 020F  12        li   ry,>0d*256                 ; LDY #13           ;
     161C 0D00     
4515 161E 0200  12        li   rtmp,MAS1                  ; JSR MAS1          ; (z_sign z_hi z_lo) += (nosev_z_hi nosev_z_lo) * 2
     1620 177C     
4516 1622 06A0  24        bl   @jsr                       ;
     1624 FE28     
4517                                                                          ;
4518                                                                          ; A = |z_sign|
4519               
4520 1626 1612  10        jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
4521                                                                          ; are too far from the planet in the z-direction to
4522                                                                          ; bump into a space station
4523               
4524 1628 020D  12        li   ra,>c0*256                 ; LDA #192          ; Call FAROF2 to compare x_hi, y_hi and z_hi with 192,
     162A C000     
4525 162C 0200  12        li   rtmp,FAROF2                ; JSR FAROF2        ; which will set the C flag if all three are < 192, or
     162E CBAE     
4526 1630 06A0  24        bl   @jsr                       ;
     1632 FE28     
4527                                                                          ; clear the C flag if any of them are >= 192
4528               
4529 1634 170B  10        jnc  MA23S                      ; BCC MA23S         ; Jump to MA23S if any one of x_hi, y_hi or z_hi are
4530                                                                          ; >= 192 (i.e. they must all be < 192 for us to be near
4531                                                                          ; enough to the planet to bump into a space station)
4532               
4533 1636 D360  22        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, skip the
     1638 0096     
4534 163A 1604  10        jne  B10                        ; BNE B10           ; following instruction (so we only remove the sun from
4535                                                                          ; the screen if we are potentially looking at it)
4536               
4537 163C 0200  12        li   rtmp,WPLS                  ; JSR WPLS          ; Call WPLS to remove the sun from the screen, as we
     163E C048     
4538 1640 06A0  24        bl   @jsr                       ;
     1642 FE28     
4539                                                                          ; can't have both the sun and the space station at the
4540                                                                          ; same time
4541               
4542               B10:
4543 1644 0200  12        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     1646 B58A     
4544 1648 06A0  24        bl   @jsr                       ;
     164A FE28     
4545                                                                          ; universe
4546               
4547               MA23S:
4548 164C 0460  16        b    @MA23                      ; JMP MA23          ; Jump to MA23 to skip the following planet and sun
     164E 1730     
4549                                                                          ; altitude checks
4550               
4551               * ******************************************************************************
4552               *
4553               * Name: Main flight loop (Part 15 of 16)
4554               * Type: Subroutine
4555               * Category: Main loop
4556               * Summary: Perform altitude checks with the planet and sun and process fuel
4557               * scooping if appropriate
4558               * Deep dive: Program flow of the main game loop
4559               * Scheduling tasks with the main loop counter
4560               *
4561               * ------------------------------------------------------------------------------
4562               *
4563               * The main flight loop covers most of the flight-specific aspects of Elite. This
4564               * section covers the following:
4565               *
4566               * * Perform an altitude check with the planet (every 32 iterations of the main
4567               * loop, on iteration 10 of each 32)
4568               *
4569               * * Perform an altitude check with the sun and process fuel scooping (every
4570               * 32 iterations of the main loop, on iteration 20 of each 32)
4571               *
4572               * ******************************************************************************
4573               
4574               MA22:
4575 1650 D360  22        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23 to skip
     1652 0D5C     
4576 1654 166D  10        jne  MA23                       ; BNE MA23          ; the following, as there are no planets or suns to
4577                                                                          ; bump into in witchspace
4578               
4579 1656 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
     1658 0099     
4580 165A 024D  14        andi ra,>1f*256                 ; AND #31           ; which tells us the position of this loop in each block
     165C 1F00     
4581                                                                          ; of 32 iterations
4582               
4583               MA93:
4584 165E 028D  14        ci   ra,>0a*256                 ; CMP #10           ; If this is the tenth iteration in this block of 32,
     1660 0A00     
4585 1662 162D  10        jne  MA29                       ; BNE MA29          ; do the following, otherwise jump to MA29 to skip the
4586                                                                          ; planet altitude check and move on to the sun distance
4587                                                                          ; check
4588               
4589 1664 020D  12        li   ra,>32*256                 ; LDA #50           ; If our energy bank status in ENERGY is >= 50, skip
     1666 3200     
4590 1668 9360  22        cb   @ENERGY,ra                 ; CMP ENERGY        ; printing the following message (so the message is
     166A 0F13     
4591 166C 1707  10        jnc  B11                        ; BCC B11           ; only shown if our energy is low)
4592               
4593                      .asla                           ; ASL A             ; Print recursive token 100 ("ENERGY LOW{beep}") as an
     **** ****     > ASLA
0001 166E 024D  14        andi ra,>ff00
     1670 FF00     
0002 1672 0A1D  14        sla  ra,1
                   < elite.a99
4594 1674 0200  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     1676 D616     
4595 1678 06A0  24        bl   @jsr                       ;
     167A FE28     
4596               
4597               B11:
4598 167C 020F  12        li   ry,>ff*256                 ; LDY #&FF          ; Set our altitude in ALTIT to &FF, the maximum
     167E FF00     
4599 1680 D80F  22        movb ry,@ALTIT                  ; STY ALTIT
     1682 0F21     
4600               
4601 1684 B3C7  14        ab   rone,ry                    ; INY               ; Set Y = 0
4602               
4603 1686 0200  12        li   rtmp,m_                    ; JSR m             ; Call m to calculate the maximum distance to the
     1688 17D2     
4604 168A 06A0  24        bl   @jsr                       ;
     168C FE28     
4605                                                                          ; planet in any of the three axes, returned in A
4606               
4607 168E 1650  10        jne  MA23                       ; BNE MA23          ; If A > 0 then we are a fair distance away from the
4608                                                                          ; planet in at least one axis, so jump to MA23 to skip
4609                                                                          ; the rest of the altitude check
4610               
4611 1690 0200  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     1692 17F6     
4612 1694 06A0  24        bl   @jsr                       ;
     1696 FE28     
4613                                                                          ; we now know that A now contains the square of the
4614                                                                          ; distance between our ship (at the origin) and the
4615                                                                          ; centre of the planet at (x_hi, y_hi, z_hi)
4616               
4617 1698 184B  10        joc  MA23                       ; BCS MA23          ; If the C flag was set by MAS3, then the result
4618                                                                          ; overflowed (was greater than &FF) and we are still a
4619                                                                          ; fair distance from the planet, so jump to MA23 as we
4620                                                                          ; haven't crashed into the planet
4621               
4622                      .sbi (>24*256)                  ; SBC #36           ; Subtract 36 from x_hi^2 + y_hi^2 + z_hi^2
     **** ****     > SBI
0001 169A 1801  10        joc  !
0002 169C 7347  14        sb   rone,ra
0003               !:
0004 169E 022D  14        ai   ra,-(>24*256)
     16A0 DC00     
                   < elite.a99
4623                                                                          ;
4624                                                                          ; When we do the 3D Pythagoras calculation, we only use
4625                                                                          ; the high bytes of the coordinates, so that's x_hi,
4626                                                                          ; y_hi and z_hi and
4627                                                                          ;
4628                                                                          ; The planet radius is (0 96 0), as defined in the
4629                                                                          ; PLANET routine, so the high byte is 96
4630                                                                          ;
4631                                                                          ; When we square the coordinates above and add them,
4632                                                                          ; the result gets divided by 256 (otherwise the result
4633                                                                          ; wouldn't fit into one byte), so if we do the same for
4634                                                                          ; the planet's radius, we get:
4635                                                                          ;
4636                                                                          ; 96 * 96 / 256 = 36
4637                                                                          ;
4638                                                                          ; So for the planet, the equivalent figure to test the
4639                                                                          ; sum of the _hi bytes against is 36, so A now contains
4640                                                                          ; the high byte of our altitude above the planet
4641                                                                          ; surface, squared
4642               
4643 16A2 170B  10        jnc  MA28                       ; BCC MA28          ; If A < 0 then jump to MA28 as we have crashed into
4644                                                                          ; the planet
4645               
4646 16A4 D80D  22        movb ra,@R                      ; STA R             ; We are getting close to the planet, so we need to
     16A6 0091     
4647 16A8 0200  12        li   rtmp,LL5                   ; JSR LL5           ; work out how close. We know from the above that A
     16AA DA9E     
4648 16AC 06A0  24        bl   @jsr                       ;
     16AE FE28     
4649                                                                          ; contains our altitude squared, so we store A in R
4650                                                                          ; and call LL5 to calculate:
4651                                                                          ;
4652                                                                          ; Q = SQRT(R Q) = SQRT(A Q)
4653                                                                          ;
4654                                                                          ; Interestingly, Q doesn't appear to be set to 0 for
4655                                                                          ; this calculation, so presumably this doesn't make a
4656                                                                          ; difference
4657               
4658 16B0 D360  22        movb @Q,ra                      ; LDA Q             ; Store the result in ALTIT, our altitude
     16B2 0090     
4659 16B4 D80D  22        movb ra,@ALTIT                  ; STA ALTIT
     16B6 0F21     
4660               
4661 16B8 163B  10        jne  MA23                       ; BNE MA23          ; If our altitude is non-zero then we haven't crashed,
4662                                                                          ; so jump to MA23 to skip to the next section
4663               
4664               MA28:
4665 16BA 0460  20        b    @DEATH                     ; JMP DEATH         ; If we get here then we just crashed into the planet
     16BC CBD2     
4666                                                                          ; or got too close to the sun, so jump to DEATH to start
4667                                                                          ; the funeral preparations and return from the main
4668                                                                          ; flight loop using a tail call
4669               
4670               MA29:
4671 16BE 028D  14        ci   ra,>14*256                 ; CMP #20           ; If this is the 20th iteration in this block of 32,
     16C0 1400     
4672 16C2 1636  10        jne  MA23                       ; BNE MA23          ; do the following, otherwise jump to MA23 to skip the
4673                                                                          ; sun altitude check
4674               
4675 16C4 020D  12        li   ra,>1e*256                 ; LDA #30           ; Set CABTMP to 30, the cabin temperature in deep space
     16C6 1E00     
4676 16C8 D80D  22        movb ra,@CABTMP                 ; STA CABTMP        ; (i.e. one notch on the dashboard bar)
     16CA 0D4D     
4677               
4678 16CC D360  22        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     16CE 0D55     
4679 16D0 162F  10        jne  MA23                       ; BNE MA23          ; MA23 to skip the following, as we can't have both the
4680                                                                          ; sun and space station at the same time, so we clearly
4681                                                                          ; can't be flying near the sun
4682               
4683 16D2 020F  12        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to NI%, which is the offset in K% for the sun's
     16D4 2400     
4684                                                                          ; data block, as the second block at K% is reserved for
4685                                                                          ; the sun (or space station)
4686               
4687 16D6 0200  12        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
     16D8 17D6     
4688 16DA 06A0  24        bl   @jsr                       ;
     16DC FE28     
4689 16DE 1628  10        jne  MA23                       ; BNE MA23          ; sun in any of the three axes, and if it's non-zero,
4690                                                                          ; jump to MA23 to skip the following, as we are too far
4691                                                                          ; from the sun for scooping or temperature changes
4692               
4693 16E0 0200  12        li   rtmp,MAS3                  ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
     16E2 17F6     
4694 16E4 06A0  24        bl   @jsr                       ;
     16E6 FE28     
4695                                                                          ; we now know that A now contains the square of the
4696                                                                          ; distance between our ship (at the origin) and the
4697                                                                          ; heart of the sun at (x_hi, y_hi, z_hi)
4698               
4699                      .eoi (>ff*256)                  ; EOR #%11111111    ; Invert A, so A is now small if we are far from the
     **** ****     > EOI
0001 16E8 0200  12        li   rtmp,(>FF*256)
     16EA FF00     
0002 16EC 2B40  14        xor  rtmp,ra
                   < elite.a99
4700                                                                          ; sun and large if we are close to the sun, in the
4701                                                                          ; range 0 = far away to &FF = extremely close, ouch,
4702                                                                          ; hot, hot, hot!
4703               
4704                      .adi (>1e*256)                  ; ADC #30           ; Add the minimum cabin temperature of 30, so we get
     **** ****     > ADI
0001 16EE 1701  10        jnc  !
0002 16F0 B347  14        ab   rone,ra
0003               !:
0004 16F2 022D  14        ai   ra,(>1E*256)
     16F4 1E00     
                   < elite.a99
4705                                                                          ; one of the following:
4706                                                                          ;
4707                                                                          ; * If the C flag is clear, A contains the cabin
4708                                                                          ; temperature, ranging from 30 to 255, that's hotter
4709                                                                          ; the closer we are to the sun
4710                                                                          ;
4711                                                                          ; * If the C flag is set, the addition has rolled over
4712                                                                          ; and the cabin temperature is over 255
4713               
4714 16F6 D80D  22        movb ra,@CABTMP                 ; STA CABTMP        ; Store the updated cabin temperature
     16F8 0D4D     
4715               
4716 16FA 18DF  10        joc  MA28                       ; BCS MA28          ; If the C flag is set then jump to MA28 to die, as
4717                                                                          ; our temperature is off the scale
4718               
4719 16FC 028D  14        ci   ra,>e0*256                 ; CMP #224          ; If the cabin temperature < 224 then jump to MA23 to
     16FE E000     
4720 1700 1717  10        jnc  MA23                       ; BCC MA23          ; skip fuel scooping, as we aren't close enough
4721               
4722 1702 D360  22        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, jump to BA23 to
     1704 0329     
4723 1706 1314  10        jeq  MA23                       ; BEQ MA23          ; skip fuel scooping, as we can't scoop without fuel
4724                                                                          ; scoops
4725               
4726 1708 D360  22        movb @DELT4+1,ra                ; LDA DELT4+1       ; We are now successfully fuel scooping, so it's time
     170A 008E     
4727 170C 091D  14        srl  ra,1                       ; LSR A             ; to work out how much fuel we're scooping. Fetch the
4728                                                                          ; high byte of DELT4, which contains our current speed
4729                                                                          ; divided by 4, and halve it to get our current speed
4730                                                                          ; divided by 8 (so it's now a value between 1 and 5, as
4731                                                                          ; our speed is normally between 1 and 40). This gives
4732                                                                          ; us the amount of fuel that's being scooped in A, so
4733                                                                          ; the faster we go, the more fuel we scoop, and because
4734                                                                          ; the fuel levels are stored as 10 * the fuel in light
4735                                                                          ; years, that means we just scooped between 0.1 and 0.5
4736                                                                          ; light years of free fuel
4737               
4738                      .adc @QQ14,ra                   ; ADC QQ14          ; Set A = A + the current fuel level * 10 (from QQ14)
     **** ****     > ADC
0001 170E 1701  10        jnc  !
0002 1710 B347  14        ab   rone,ra
0003               !:
0004 1712 B360  22        ab   @QQ14,ra
     1714 030D     
                   < elite.a99
4739               
4740 1716 028D  14        ci   ra,>46*256                 ; CMP #70           ; If A > 70 then set A = 70 (as 70 is the maximum fuel
     1718 4600     
4741 171A 1702  10        jnc  B12                        ; BCC B12           ; level, or 7.0 light years)
4742 171C 020D  12        li   ra,>46*256                 ; LDA #70
     171E 4600     
4743               
4744               B12:
4745 1720 D80D  22        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel level in QQ14
     1722 030D     
4746               
4747 1724 020D  12        li   ra,>a0*256                 ; LDA #160          ; Print recursive token 0 ("FUEL SCOOPS ON") as an
     1726 A000     
4748 1728 0200  12        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     172A D616     
4749 172C 06A0  24        bl   @jsr                       ;
     172E FE28     
4750               
4751               * ******************************************************************************
4752               *
4753               * Name: Main flight loop (Part 16 of 16)
4754               * Type: Subroutine
4755               * Category: Main loop
4756               * Summary: Process laser pulsing, E.C.M. energy drain, call stardust routine
4757               * Deep dive: Program flow of the main game loop
4758               *
4759               * ------------------------------------------------------------------------------
4760               *
4761               * The main flight loop covers most of the flight-specific aspects of Elite. This
4762               * section covers the following:
4763               *
4764               * * Process laser pulsing
4765               *
4766               * * Process E.C.M. energy drain
4767               *
4768               * * Jump to the stardust routine if we are in a space view
4769               *
4770               * * Return from the main flight loop
4771               *
4772               * ******************************************************************************
4773               
4774               MA23:
4775 1730 D360  22        movb @LAS2,ra                   ; LDA LAS2          ; If the current view has no laser, jump to MA16 to skip
     1732 0D5D     
4776 1734 130D  10        jeq  MA16                       ; BEQ MA16          ; the following
4777               
4778 1736 D360  22        movb @LASCT,ra                  ; LDA LASCT         ; If LASCT >= 8, jump to MA16 to skip the following, so
     1738 0D60     
4779 173A 028D  14        ci   ra,>08*256                 ; CMP #8            ; for a pulse laser with a LASCT between 8 and 10, the
     173C 0800     
4780 173E 1808  10        joc  MA16                       ; BCS MA16          ; laser stays on, but for a LASCT of 7 or less it gets
4781                                                                          ; turned off and stays off until LASCT reaches zero and
4782                                                                          ; the next pulse can start (if the fire button is still
4783                                                                          ; being pressed)
4784                                                                          ;
4785                                                                          ; For pulse lasers, LASCT gets set to 10 in ma1 above,
4786                                                                          ; and it decrements every vertical sync (50 times a
4787                                                                          ; second), so this means it pulses five times a second,
4788                                                                          ; with the laser being on for the first 3/10 of each
4789                                                                          ; pulse and off for the rest of the pulse
4790                                                                          ;
4791                                                                          ; If this is a beam laser, LASCT is 0 so we always keep
4792                                                                          ; going here. This means the laser doesn't pulse, but it
4793                                                                          ; does get drawn and removed every cycle, in a slightly
4794                                                                          ; different place each time, so the beams still flicker
4795                                                                          ; around the screen
4796               
4797 1740 0200  12        li   rtmp,LASLI2                ; JSR LASLI2        ; Redraw the existing laser lines, which has the effect
     1742 4CD6     
4798 1744 06A0  24        bl   @jsr                       ;
     1746 FE28     
4799                                                                          ; of removing them from the screen
4800               
4801 1748 020D  12        li   ra,>00*256                 ; LDA #0            ; Set LAS2 to 0 so if this is a pulse laser, it will
     174A 0000     
4802 174C D80D  22        movb ra,@LAS2                   ; STA LAS2          ; skip over the above until the next pulse (this has no
     174E 0D5D     
4803                                                                          ; effect if this is a beam laser)
4804               
4805               MA16:
4806 1750 D360  22        movb @ECMP,ra                   ; LDA ECMP          ; If our E.C.M is not on, skip to MA69, otherwise keep
     1752 0D5B     
4807 1754 1305  10        jeq  MA69                       ; BEQ MA69          ; going to drain some energy
4808               
4809 1756 0200  12        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     1758 B306     
4810 175A 06A0  24        bl   @jsr                       ;
     175C FE28     
4811               
4812 175E 1305  10        jeq  MA70                       ; BEQ MA70          ; If we have no energy left, jump to MA70 to turn our
4813                                                                          ; E.C.M. off
4814               
4815               MA69:
4816 1760 D360  22        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M is going off (ours or an opponent's) then
     1762 0030     
4817 1764 1306  10        jeq  MA66                       ; BEQ MA66          ; keep going, otherwise skip to MA66
4818               
4819 1766 7347  14        sb   rone,ra                    ; DEC ECMA          ; Decrement the E.C.M. countdown timer, and if it has
4820 1768 1604  10        jne  MA66                       ; BNE MA66          ; reached zero, keep going, otherwise skip to MA66
4821               
4822               MA70:
4823 176A 0200  12        li   rtmp,ECMOF                 ; JSR ECMOF         ; If we get here then either we have either run out of
     176C D2A4     
4824 176E 06A0  24        bl   @jsr                       ;
     1770 FE28     
4825                                                                          ; energy, or the E.C.M. timer has run down, so switch
4826                                                                          ; off the E.C.M.
4827               
4828               MA66:
4829 1772 D360  22        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     1774 0096     
4830 1776 162B  10        jne  MA9                        ; BNE MA9           ; then jump to MA9 to return from the main flight loop
4831                                                                          ; (as MA9 is an RTS)
4832               
4833 1778 0460  20        b    @STARS                     ; JMP STARS         ; This is a space view, so jump to the STARS routine to
     177A 2B92     
4834                                                                          ; process the stardust, and return from the main flight
4835                                                                          ; loop using a tail call
4836               
4837               * ******************************************************************************
4838               *
4839               * Name: MAS1
4840               * Type: Subroutine
4841               * Category: Maths (Geometry)
4842               * Summary: Add an orientation vector coordinate to an INWK coordinate
4843               * Deep dive: The space station safe zone
4844               *
4845               * ------------------------------------------------------------------------------
4846               *
4847               * Add a doubled nosev vector coordinate, e.g. (nosev_y_hi nosev_y_lo) * 2, to
4848               * an INWK coordinate, e.g. (x_sign x_hi x_lo), storing the result in the INWK
4849               * coordinate. The axes used in each side of the addition are specified by the
4850               * arguments X and Y.
4851               *
4852               * In the comments below, we document the routine as if we are doing the
4853               * following, i.e. if X = 0 and Y = 11:
4854               *
4855               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (nosev_y_hi nosev_y_lo) * 2
4856               *
4857               * as that way the variable names in the comments contain "x" and "y" to match
4858               * the registers that specify the vector axis to use.
4859               *
4860               * ------------------------------------------------------------------------------
4861               *
4862               * Arguments:
4863               *
4864               * X                   The coordinate to add, as follows:
4865               *
4866               * * If X = 0, add (x_sign x_hi x_lo)
4867               * * If X = 3, add (y_sign y_hi y_lo)
4868               * * If X = 6, add (z_sign z_hi z_lo)
4869               *
4870               * Y                   The vector to add, as follows:
4871               *
4872               * * If Y = 9,  add (nosev_x_hi nosev_x_lo)
4873               * * If Y = 11, add (nosev_y_hi nosev_y_lo)
4874               * * If Y = 13, add (nosev_z_hi nosev_z_lo)
4875               *
4876               * ------------------------------------------------------------------------------
4877               *
4878               * Returns:
4879               *
4880               * A                   The highest byte of the result with the sign cleared
4881               * (e.g. |x_sign| when X = 0, etc.)
4882               *
4883               * ------------------------------------------------------------------------------
4884               *
4885               * Other entry points:
4886               *
4887               * MA9                 Contains an RTS
4888               *
4889               * ******************************************************************************
4890               
4891               MAS1:
4892 177C 06CF  10        swpb ry                         ;
4893 177E D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set K(2 1) = (nosev_y_hi nosev_y_lo) * 2
     1780 0053     
4894 1782 06CF  10        swpb ry                         ;
4895                      .asla                           ; ASL A
     **** ****     > ASLA
0001 1784 024D  14        andi ra,>ff00
     1786 FF00     
0002 1788 0A1D  14        sla  ra,1
                   < elite.a99
4896 178A D80D  22        movb ra,@K+1                    ; STA K+1
     178C 003E     
4897 178E 06CF  10        swpb ry                         ;
4898 1790 D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y
     1792 0054     
4899 1794 06CF  10        swpb ry                         ;
4900 1796 06A0  24        bl   @rola                      ; ROL A
     1798 FE3E     
4901 179A D80D  22        movb ra,@K+2                    ; STA K+2
     179C 003F     
4902               
4903 179E 020D  12        li   ra,>00*256                 ; LDA #0            ; Set K+3 bit 7 to the C flag, so the sign bit of the
     17A0 0000     
4904 17A2 06A0  24        bl   @rora                      ; ROR A             ; above result goes into K+3
     17A4 FE62     
4905 17A6 D80D  22        movb ra,@K+3                    ; STA K+3
     17A8 0040     
4906               
4907 17AA 0200  12        li   rtmp,MVT3                  ; JSR MVT3          ; Add (x_sign x_hi x_lo) to K(3 2 1)
     17AC 1D44     
4908 17AE 06A0  24        bl   @jsr                       ;
     17B0 FE28     
4909               
4910 17B2 06CE  10        swpb rx                         ;
4911 17B4 DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; Store the sign of the result in x_sign
     17B6 0055     
4912 17B8 06CE  10        swpb rx                         ;
4913               
4914 17BA D3E0  22        movb @K+1,ry                    ; LDY K+1           ; Store K(2 1) in (x_hi x_lo)
     17BC 003E     
4915 17BE DB8F  30        movb ry,@INWK(rx)               ; STY INWK,X
     17C0 0053     
4916 17C2 D3E0  22        movb @K+2,ry                    ; LDY K+2
     17C4 003F     
4917 17C6 DB8F  30        movb ry,@INWK+1(rx)             ; STY INWK+1,X
     17C8 0054     
4918               
4919 17CA 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Set A to the sign byte with the sign cleared,
     17CC 7F00     
4920                                                                          ; i.e. |x_sign| when X = 0
4921               
4922               MA9:
4923 17CE 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     17D0 FE34     
4924               
4925               * ******************************************************************************
4926               *
4927               * Name: MAS2
4928               * Type: Subroutine
4929               * Category: Maths (Geometry)
4930               * Summary: Calculate a cap on the maximum distance to the planet or sun
4931               *
4932               * ------------------------------------------------------------------------------
4933               *
4934               * Given a value in Y that points to the start of a ship data block as an offset
4935               * from K%, calculate the following:
4936               *
4937               * A = A OR x_sign OR y_sign OR z_sign
4938               *
4939               * and clear the sign bit of the result. The K% workspace contains the ship data
4940               * blocks, so the offset in Y must be 0 or a multiple of NI% (as each block in
4941               * K% contains NI% bytes).
4942               *
4943               * The result effectively contains a maximum cap of the three values (though it
4944               * might not be one of the three input values - it's just guaranteed to be
4945               * larger than all of them).
4946               *
4947               * If Y = 0 and A = 0, then this calculates the maximum cap of the highest byte
4948               * containing the distance to the planet, as K%+2 = x_sign, K%+5 = y_sign and
4949               * K%+8 = z_sign (the first slot in the K% workspace represents the planet).
4950               *
4951               * ------------------------------------------------------------------------------
4952               *
4953               * Arguments:
4954               *
4955               * Y                   The offset from K% for the start of the ship data block
4956               * to use
4957               *
4958               * ------------------------------------------------------------------------------
4959               *
4960               * Returns:
4961               *
4962               * A                   A OR K%+2+Y OR K%+5+Y OR K%+8+Y, with bit 7 cleared
4963               *
4964               * ------------------------------------------------------------------------------
4965               *
4966               * Other entry points:
4967               *
4968               * m                   Do not include A in the calculation
4969               *
4970               * ******************************************************************************
4971               
4972               m_:
4973 17D2 020D  12        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and fall through into MAS2 to calculate the
     17D4 0000     
4974                                                                          ; OR of the three bytes at K%+2+Y, K%+5+Y and K%+8+Y
4975               
4976               MAS2:
4977 17D6 06CF  10        swpb ry                         ;
4978 17D8 F36F  26        socb @K.+2(ry),ra               ; ORA K%+2,Y        ; Set A = A OR x_sign OR y_sign OR z_sign
     17DA 0902     
4979 17DC 06CF  10        swpb ry                         ;
4980 17DE 06CF  10        swpb ry                         ;
4981 17E0 F36F  26        socb @K.+5(ry),ra               ; ORA K%+5,Y
     17E2 0905     
4982 17E4 06CF  10        swpb ry                         ;
4983 17E6 06CF  10        swpb ry                         ;
4984 17E8 F36F  26        socb @K.+8(ry),ra               ; ORA K%+8,Y
     17EA 0908     
4985 17EC 06CF  10        swpb ry                         ;
4986               
4987 17EE 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 in A
     17F0 7F00     
4988               
4989 17F2 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     17F4 FE34     
4990               
4991               * ******************************************************************************
4992               *
4993               * Name: MAS3
4994               * Type: Subroutine
4995               * Category: Maths (Arithmetic)
4996               * Summary: Calculate A = x_hi^2 + y_hi^2 + z_hi^2 in the K% block
4997               *
4998               * ------------------------------------------------------------------------------
4999               *
5000               * Given a value in Y that points to the start of a ship data block as an offset
5001               * from K%, calculate the following:
5002               *
5003               * A = x_hi^2 + y_hi^2 + z_hi^2
5004               *
5005               * returning A = &FF if the calculation overflows a one-byte result. The K%
5006               * workspace contains the ship data blocks, so the offset in Y must be 0 or a
5007               * multiple of NI% (as each block in K% contains NI% bytes).
5008               *
5009               * ------------------------------------------------------------------------------
5010               *
5011               * Arguments:
5012               *
5013               * Y                   The offset from K% for the start of the ship data block
5014               * to use
5015               *
5016               * Returns
5017               *
5018               * A                   A = x_hi^2 + y_hi^2 + z_hi^2
5019               *
5020               * A = &FF if the calculation overflows a one-byte result
5021               *
5022               * ******************************************************************************
5023               
5024               MAS3:
5025 17F6 06CF  10        swpb ry                         ;
5026 17F8 D36F  26        movb @K.+1(ry),ra               ; LDA K%+1,Y        ; Set (A P) = x_hi * x_hi
     17FA 0901     
5027 17FC 06CF  10        swpb ry                         ;
5028 17FE 0200  12        li   rtmp,SQUA2                 ; JSR SQUA2
     1800 464E     
5029 1802 06A0  24        bl   @jsr                       ;
     1804 FE28     
5030               
5031 1806 D80D  22        movb ra,@R                      ; STA R             ; Store A (high byte of result) in R
     1808 0091     
5032               
5033 180A 06CF  10        swpb ry                         ;
5034 180C D36F  26        movb @K.+4(ry),ra               ; LDA K%+4,Y        ; Set (A P) = y_hi * y_hi
     180E 0904     
5035 1810 06CF  10        swpb ry                         ;
5036 1812 0200  12        li   rtmp,SQUA2                 ; JSR SQUA2
     1814 464E     
5037 1816 06A0  24        bl   @jsr                       ;
     1818 FE28     
5038               
5039                      .adc @R,ra                      ; ADC R             ; Add A (high byte of second result) to R
     **** ****     > ADC
0001 181A 1701  10        jnc  !
0002 181C B347  14        ab   rone,ra
0003               !:
0004 181E B360  22        ab   @R,ra
     1820 0091     
                   < elite.a99
5040               
5041 1822 180F  10        joc  MA30                       ; BCS MA30          ; If the addition of the two high bytes caused a carry
5042                                                                          ; (i.e. they overflowed), jump to MA30 to return A = &FF
5043               
5044 1824 D80D  22        movb ra,@R                      ; STA R             ; Store A (sum of the two high bytes) in R
     1826 0091     
5045               
5046 1828 06CF  10        swpb ry                         ;
5047 182A D36F  26        movb @K.+7(ry),ra               ; LDA K%+7,Y        ; Set (A P) = z_hi * z_hi
     182C 0907     
5048 182E 06CF  10        swpb ry                         ;
5049 1830 0200  12        li   rtmp,SQUA2                 ; JSR SQUA2
     1832 464E     
5050 1834 06A0  24        bl   @jsr                       ;
     1836 FE28     
5051               
5052                      .adc @R,ra                      ; ADC R             ; Add A (high byte of third result) to R, so R now
     **** ****     > ADC
0001 1838 1701  10        jnc  !
0002 183A B347  14        ab   rone,ra
0003               !:
0004 183C B360  22        ab   @R,ra
     183E 0091     
                   < elite.a99
5053                                                                          ; contains the sum of x_hi^2 + y_hi^2 + z_hi^2
5054               
5055 1840 1702  10        jnc  B13                        ; BCC B13           ; If there is no carry, skip the following instruction
5056                                                                          ; to return straight from the subroutine
5057               
5058               MA30:
5059 1842 020D  12        li   ra,>ff*256                 ; LDA #&FF          ; The calculation has overflowed, so set A = &FF
     1844 FF00     
5060               
5061               B13:
5062 1846 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1848 FE34     
5063               
5064               * ******************************************************************************
5065               *
5066               * Name: MVEIT (Part 1 of 9)
5067               * Type: Subroutine
5068               * Category: Moving
5069               * Summary: Move current ship: Tidy the orientation vectors
5070               * Deep dive: Program flow of the ship-moving routine
5071               * Scheduling tasks with the main loop counter
5072               *
5073               * ------------------------------------------------------------------------------
5074               *
5075               * This routine has multiple stages. This stage does the following:
5076               *
5077               * * Tidy the orientation vectors for one of the ship slots
5078               *
5079               * ------------------------------------------------------------------------------
5080               *
5081               * Arguments:
5082               *
5083               * INWK                The current ship/planet/sun's data block
5084               *
5085               * XSAV                The slot number of the current ship/planet/sun
5086               *
5087               * TYPE                The type of the current ship/planet/sun
5088               *
5089               * ******************************************************************************
5090               
5091               MVEIT:
5092 184A D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; If bits 5 or 7 of ship byte #31 are set, jump to MV30
     184C 0072     
5093 184E 024D  14        andi ra,>a0*256                 ; AND #%10100000    ; as the ship is either exploding or has been killed, so
     1850 A000     
5094 1852 1623  10        jne  MV30                       ; BNE MV30          ; we don't need to tidy its orientation vectors or apply
5095                                                                          ; tactics
5096               
5097 1854 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     1856 0099     
5098               
5099                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 1858 D020  22        movb @XSAV,rtmp
     185A 0093     
0002 185C 2B40  14        xor  rtmp,ra
                   < elite.a99
5100 185E 024D  14        andi ra,>0f*256                 ; AND #15           ; with the loop counter and apply mod 15 to the result.
     1860 0F00     
5101 1862 1604  10        jne  MV3                        ; BNE MV3           ; The result will be zero when "counter mod 15" matches
5102                                                                          ; the slot number, so this makes sure we call TIDY 12
5103                                                                          ; times every 16 main loop iterations, like this:
5104                                                                          ;
5105                                                                          ; Iteration 0, tidy the ship in slot 0
5106                                                                          ; Iteration 1, tidy the ship in slot 1
5107                                                                          ; Iteration 2, tidy the ship in slot 2
5108                                                                          ; ...
5109                                                                          ; Iteration 11, tidy the ship in slot 11
5110                                                                          ; Iteration 12, do nothing
5111                                                                          ; Iteration 13, do nothing
5112                                                                          ; Iteration 14, do nothing
5113                                                                          ; Iteration 15, do nothing
5114                                                                          ; Iteration 16, tidy the ship in slot 0
5115                                                                          ; ...
5116                                                                          ;
5117                                                                          ; and so on
5118               
5119 1864 0200  12        li   rtmp,TIDY                  ; JSR TIDY          ; Call TIDY to tidy up the orientation vectors, to
     1866 D768     
5120 1868 06A0  24        bl   @jsr                       ;
     186A FE28     
5121                                                                          ; prevent the ship from getting elongated and out of
5122                                                                          ; shape due to the imprecise nature of trigonometry
5123                                                                          ; in assembly language
5124               
5125               * ******************************************************************************
5126               *
5127               * Name: MVEIT (Part 2 of 9)
5128               * Type: Subroutine
5129               * Category: Moving
5130               * Summary: Move current ship: Call tactics routine, remove ship from scanner
5131               * Deep dive: Scheduling tasks with the main loop counter
5132               *
5133               * ------------------------------------------------------------------------------
5134               *
5135               * This routine has multiple stages. This stage does the following:
5136               *
5137               * * Apply tactics to ships with AI enabled (by calling the TACTICS routine)
5138               *
5139               * * Remove the ship from the scanner, so we can move it
5140               *
5141               * ******************************************************************************
5142               
5143               MV3:
5144 186C D3A0  22        movb @TYPE,rx                   ; LDX TYPE          ; If the type of the ship we are moving is positive,
     186E 009B     
5145 1870 1502  10        jgt  B14                        ; BPL B14           ; i.e. it is not a planet (types 128 and 130) or sun
5146                                                                          ; (type 129), then skip the following instruction
5147               
5148 1872 0460  20        b    @MV40                      ; JMP MV40          ; This item is the planet or sun, so jump to MV40 to
     1874 2172     
5149                                                                          ; move it, which ends by jumping back into this routine
5150                                                                          ; at MV45 (after all the rotation, tactics and scanner
5151                                                                          ; code, which we don't need to apply to planets or suns)
5152               
5153               B14:
5154 1876 D360  22        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the ship's byte #32 (AI flag) into A
     1878 0073     
5155               
5156 187A 150F  10        jgt  MV30                       ; BPL MV30          ; If bit 7 of the AI flag is clear, then if this is a
5157                                                                          ; ship or missile it is dumb and has no AI, and if this
5158                                                                          ; is the space station it is not hostile, so in both
5159                                                                          ; cases skip the following as it has no tactics
5160               
5161 187C 028E  14        ci   rx,(MSL)*256               ; CPX #MSL          ; If the ship is a missile, skip straight to MV26 to
     187E 0900     
5162 1880 1308  10        jeq  MV26                       ; BEQ MV26          ; call the TACTICS routine, as we do this every
5163                                                                          ; iteration of the main loop for missiles only
5164               
5165 1882 D360  22        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter
     1884 0099     
5166               
5167                      .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
     **** ****     > EOR
0001 1886 D020  22        movb @XSAV,rtmp
     1888 0093     
0002 188A 2B40  14        xor  rtmp,ra
                   < elite.a99
5168 188C 024D  14        andi ra,>07*256                 ; AND #7            ; with the loop counter and apply mod 8 to the result.
     188E 0700     
5169 1890 1604  10        jne  MV30                       ; BNE MV30          ; The result will be zero when "counter mod 8" matches
5170                                                                          ; the slot number mod 8, so this makes sure we call
5171                                                                          ; TACTICS 12 times every 8 main loop iterations, like
5172                                                                          ; this:
5173                                                                          ;
5174                                                                          ; Iteration 0, apply tactics to slots 0 and 8
5175                                                                          ; Iteration 1, apply tactics to slots 1 and 9
5176                                                                          ; Iteration 2, apply tactics to slots 2 and 10
5177                                                                          ; Iteration 3, apply tactics to slots 3 and 11
5178                                                                          ; Iteration 4, apply tactics to slot 4
5179                                                                          ; Iteration 5, apply tactics to slot 5
5180                                                                          ; Iteration 6, apply tactics to slot 6
5181                                                                          ; Iteration 7, apply tactics to slot 7
5182                                                                          ; Iteration 8, apply tactics to slots 0 and 8
5183                                                                          ; ...
5184                                                                          ;
5185                                                                          ; and so on
5186               
5187               MV26:
5188 1892 0200  12        li   rtmp,TACTICS               ; JSR TACTICS       ; Call TACTICS to apply AI tactics to this ship
     1894 3AFC     
5189 1896 06A0  24        bl   @jsr                       ;
     1898 FE28     
5190               
5191               MV30:
5192 189A 0200  12        li   rtmp,SCAN                  ; JSR SCAN          ; Draw the ship on the scanner, which has the effect of
     189C 505A     
5193 189E 06A0  24        bl   @jsr                       ;
     18A0 FE28     
5194                                                                          ; removing it, as it's already at this point and hasn't
5195                                                                          ; yet moved
5196               
5197               * ******************************************************************************
5198               *
5199               * Name: MVEIT (Part 3 of 9)
5200               * Type: Subroutine
5201               * Category: Moving
5202               * Summary: Move current ship: Move ship forward according to its speed
5203               *
5204               * ------------------------------------------------------------------------------
5205               *
5206               * This routine has multiple stages. This stage does the following:
5207               *
5208               * * Move the ship forward (along the vector pointing in the direction of
5209               * travel) according to its speed:
5210               *
5211               * (x, y, z) += nosev_hi * speed / 64
5212               *
5213               * ******************************************************************************
5214               
5215 18A2 D360  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set Q = the ship's speed byte #27 * 4
     18A4 006E     
5216                      .asla                           ; ASL A
     **** ****     > ASLA
0001 18A6 024D  14        andi ra,>ff00
     18A8 FF00     
0002 18AA 0A1D  14        sla  ra,1
                   < elite.a99
5217                      .asla                           ; ASL A
     **** ****     > ASLA
0001 18AC 024D  14        andi ra,>ff00
     18AE FF00     
0002 18B0 0A1D  14        sla  ra,1
                   < elite.a99
5218 18B2 D80D  22        movb ra,@Q                      ; STA Q
     18B4 0090     
5219               
5220 18B6 D360  22        movb @INWK+10,ra                ; LDA INWK+10       ; Set A = |nosev_x_hi|
     18B8 005D     
5221 18BA 024D  14        andi ra,>7f*256                 ; AND #%01111111
     18BC 7F00     
5222               
5223 18BE 0200  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     18C0 46D4     
5224 18C2 06A0  24        bl   @jsr                       ;
     18C4 FE28     
5225 18C6 D80D  22        movb ra,@R                      ; STA R             ; = |nosev_x_hi| * speed / 64
     18C8 0091     
5226               
5227 18CA D360  22        movb @INWK+10,ra                ; LDA INWK+10       ; If nosev_x_hi is positive, then:
     18CC 005D     
5228 18CE 020E  12        li   rx,>00*256                 ; LDX #0            ;
     18D0 0000     
5229 18D2 0200  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + R
     18D4 1C18     
5230 18D6 06A0  24        bl   @jsr                       ;
     18D8 FE28     
5231                                                                          ;
5232                                                                          ; If nosev_x_hi is negative, then:
5233                                                                          ;
5234                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - R
5235                                                                          ;
5236                                                                          ; So in effect, this does:
5237                                                                          ;
5238                                                                          ; (x_sign x_hi x_lo) += nosev_x_hi * speed / 64
5239               
5240 18DA D360  22        movb @INWK+12,ra                ; LDA INWK+12       ; Set A = |nosev_y_hi|
     18DC 005F     
5241 18DE 024D  14        andi ra,>7f*256                 ; AND #%01111111
     18E0 7F00     
5242               
5243 18E2 0200  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     18E4 46D4     
5244 18E6 06A0  24        bl   @jsr                       ;
     18E8 FE28     
5245 18EA D80D  22        movb ra,@R                      ; STA R             ; = |nosev_y_hi| * speed / 64
     18EC 0091     
5246               
5247 18EE D360  22        movb @INWK+12,ra                ; LDA INWK+12       ; If nosev_y_hi is positive, then:
     18F0 005F     
5248 18F2 020E  12        li   rx,>03*256                 ; LDX #3            ;
     18F4 0300     
5249 18F6 0200  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) + R
     18F8 1C18     
5250 18FA 06A0  24        bl   @jsr                       ;
     18FC FE28     
5251                                                                          ;
5252                                                                          ; If nosev_y_hi is negative, then:
5253                                                                          ;
5254                                                                          ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) - R
5255                                                                          ;
5256                                                                          ; So in effect, this does:
5257                                                                          ;
5258                                                                          ; (y_sign y_hi y_lo) += nosev_y_hi * speed / 64
5259               
5260 18FE D360  22        movb @INWK+14,ra                ; LDA INWK+14       ; Set A = |nosev_z_hi|
     1900 0061     
5261 1902 024D  14        andi ra,>7f*256                 ; AND #%01111111
     1904 7F00     
5262               
5263 1906 0200  12        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     1908 46D4     
5264 190A 06A0  24        bl   @jsr                       ;
     190C FE28     
5265 190E D80D  22        movb ra,@R                      ; STA R             ; = |nosev_z_hi| * speed / 64
     1910 0091     
5266               
5267 1912 D360  22        movb @INWK+14,ra                ; LDA INWK+14       ; If nosev_y_hi is positive, then:
     1914 0061     
5268 1916 020E  12        li   rx,>06*256                 ; LDX #6            ;
     1918 0600     
5269 191A 0200  12        li   rtmp,MVT1-2                ; JSR MVT1-2        ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + R
     191C 1C18     
5270 191E 06A0  24        bl   @jsr                       ;
     1920 FE28     
5271                                                                          ;
5272                                                                          ; If nosev_z_hi is negative, then:
5273                                                                          ;
5274                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) - R
5275                                                                          ;
5276                                                                          ; So in effect, this does:
5277                                                                          ;
5278                                                                          ; (z_sign z_hi z_lo) += nosev_z_hi * speed / 64
5279               
5280               * ******************************************************************************
5281               *
5282               * Name: MVEIT (Part 4 of 9)
5283               * Type: Subroutine
5284               * Category: Moving
5285               * Summary: Move current ship: Apply acceleration to ship's speed as a one-off
5286               *
5287               * ------------------------------------------------------------------------------
5288               *
5289               * This routine has multiple stages. This stage does the following:
5290               *
5291               * * Apply acceleration to the ship's speed (if acceleration is non-zero),
5292               * and then zero the acceleration as it's a one-off change
5293               *
5294               * ******************************************************************************
5295               
5296 1922 D360  22        movb @INWK+27,ra                ; LDA INWK+27       ; Set A = the ship's speed in byte #24 + the ship's
     1924 006E     
5297                      .clc                            ; CLC               ; acceleration in byte #28
     **** ****     > CLC
0001 1926 0A16  14        sla  rzero,1
                   < elite.a99
5298                      .adc @INWK+28,ra                ; ADC INWK+28
     **** ****     > ADC
0001 1928 1701  10        jnc  !
0002 192A B347  14        ab   rone,ra
0003               !:
0004 192C B360  22        ab   @INWK+28,ra
     192E 006F     
                   < elite.a99
5299               
5300 1930 1502  10        jgt  B15                        ; BPL B15           ; If the result is positive, skip the following
5301                                                                          ; instruction
5302               
5303 1932 020D  12        li   ra,>00*256                 ; LDA #0            ; Set A to 0 to stop the speed from going negative
     1934 0000     
5304               
5305               B15:
5306 1936 020F  12        li   ry,>0f*256                 ; LDY #15           ; We now fetch byte #15 from the ship's blueprint, which
     1938 0F00     
5307                                                                          ; contains the ship's maximum speed, so set Y = 15 to
5308                                                                          ; use as an index
5309               
5310                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; If A < the ship's maximum speed, skip the following
     **** ****     > CMP_IND_Y_IDX
0001 193A D820  30        movb @XX0,@rtmplb
     193C 001E     
     193E 8301     
0002 1940 D020  22        movb @XX0+1,rtmp
     1942 001F     
0003 1944 06CF  10        swpb ry
0004 1946 A00F  14        a    ry,rtmp
0005 1948 06CF  10        swpb ry
0006 194A D010  22        movb *rtmp,rtmp
0007 194C 900D  14        cb   ra,rtmp
                   < elite.a99
5311 194E 1709  10        jnc  B16                        ; BCC B16           ; instruction
5312               
5313                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Set A to the ship's maximum speed
     **** ****     > LD_IND_Y_IDX
0001 1950 D820  30        movb @XX0,@rtmplb
     1952 001E     
     1954 8301     
0002 1956 D020  22        movb @XX0+1,rtmp
     1958 001F     
0003 195A 06CF  10        swpb ry
0004 195C A00F  14        a    ry,rtmp
0005 195E 06CF  10        swpb ry
0006 1960 D350  22        movb *rtmp,RA
                   < elite.a99
5314               
5315               B16:
5316 1962 D80D  22        movb ra,@INWK+27                ; STA INWK+27       ; We have now calculated the new ship's speed after
     1964 006E     
5317                                                                          ; accelerating and keeping the speed within the ship's
5318                                                                          ; limits, so store the updated speed in byte #27
5319               
5320 1966 020D  12        li   ra,>00*256                 ; LDA #0            ; We have added the ship's acceleration, so we now set
     1968 0000     
5321 196A D80D  22        movb ra,@INWK+28                ; STA INWK+28       ; it back to 0 in byte #28, as it's a one-off change
     196C 006F     
5322               
5323               * ******************************************************************************
5324               *
5325               * Name: MVEIT (Part 5 of 9)
5326               * Type: Subroutine
5327               * Category: Moving
5328               * Summary: Move current ship: Rotate ship's location by our pitch and roll
5329               * Deep dive: Rotating the universe
5330               *
5331               * ------------------------------------------------------------------------------
5332               *
5333               * This routine has multiple stages. This stage does the following:
5334               *
5335               * * Rotate the ship's location in space by the amount of pitch and roll of
5336               * our ship. See below for a deeper explanation of this routine
5337               *
5338               * ******************************************************************************
5339               
5340 196E D3A0  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1970 0087     
5341                                                                          ; if the roll angle is alpha, X contains |alpha|
5342               
5343 1972 D360  22        movb @INWK,ra                   ; LDA INWK          ; Set P = ~x_lo (i.e. with all its bits flipped) so that
     1974 0053     
5344                      .eoi (>ff*256)                  ; EOR #%11111111    ; we can pass x_lo to MLTU2 below)
     **** ****     > EOI
0001 1976 0200  12        li   rtmp,(>FF*256)
     1978 FF00     
0002 197A 2B40  14        xor  rtmp,ra
                   < elite.a99
5345 197C D80D  22        movb ra,@P                      ; STA P
     197E 001B     
5346               
5347 1980 D360  22        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     1982 0054     
5348               
5349 1984 0200  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     1986 471A     
5350 1988 06A0  24        bl   @jsr                       ;
     198A FE28     
5351                                                                          ; = (x_hi x_lo) * alpha
5352               
5353 198C D80D  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     198E 001D     
5354                                                                          ; have:
5355                                                                          ;
5356                                                                          ; P(2 1 0) = (x_hi x_lo) * alpha
5357               
5358 1990 D360  22        movb @ALP2+1,ra                 ; LDA ALP2+1        ; Fetch the flipped sign of the current roll angle alpha
     1992 0089     
5359                      .eor @INWK+2                    ; EOR INWK+2        ; from ALP2+1 and EOR with byte #2 (x_sign), so if the
     **** ****     > EOR
0001 1994 D020  22        movb @INWK+2,rtmp
     1996 0055     
0002 1998 2B40  14        xor  rtmp,ra
                   < elite.a99
5360                                                                          ; flipped roll angle and x_sign have the same sign, A
5361                                                                          ; will be positive, else it will be negative. So A will
5362                                                                          ; contain the sign bit of x_sign * flipped alpha sign,
5363                                                                          ; which is the opposite to the sign of the above result,
5364                                                                          ; so we now have:
5365                                                                          ;
5366                                                                          ; (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256
5367               
5368 199A 020E  12        li   rx,>03*256                 ; LDX #3            ; Set (A P+2 P+1) = (y_sign y_hi y_lo) + (A P+2 P+1)
     199C 0300     
5369 199E 0200  12        li   rtmp,MVT6                  ; JSR MVT6          ; = y - x * alpha / 256
     19A0 20D6     
5370 19A2 06A0  24        bl   @jsr                       ;
     19A4 FE28     
5371               
5372 19A6 D80D  22        movb ra,@K2+3                   ; STA K2+3          ; Set K2(3) = A = the sign of the result
     19A8 00AF     
5373               
5374 19AA D360  22        movb @P+1,ra                    ; LDA P+1           ; Set K2(1) = P+1, the low byte of the result
     19AC 001C     
5375 19AE D80D  22        movb ra,@K2+1                   ; STA K2+1
     19B0 00AD     
5376               
5377                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~K2+1 (i.e. with all its bits flipped) so
     **** ****     > EOI
0001 19B2 0200  12        li   rtmp,(>FF*256)
     19B4 FF00     
0002 19B6 2B40  14        xor  rtmp,ra
                   < elite.a99
5378 19B8 D80D  22        movb ra,@P                      ; STA P             ; that we can pass K2+1 to MLTU2 below)
     19BA 001B     
5379               
5380 19BC D360  22        movb @P+2,ra                    ; LDA P+2           ; Set K2(2) = A = P+2
     19BE 001D     
5381 19C0 D80D  22        movb ra,@K2+2                   ; STA K2+2
     19C2 00AE     
5382               
5383                                                                          ; So we now have result 1 above:
5384                                                                          ;
5385                                                                          ; K2(3 2 1) = (A P+2 P+1)
5386                                                                          ; = y - x * alpha / 256
5387               
5388 19C4 D3A0  22        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the current pitch into X, so
     19C6 002B     
5389                                                                          ; if the pitch angle is beta, X contains |beta|
5390               
5391 19C8 0200  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     19CA 471A     
5392 19CC 06A0  24        bl   @jsr                       ;
     19CE FE28     
5393                                                                          ; = K2(2 1) * beta
5394               
5395 19D0 D80D  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     19D2 001D     
5396                                                                          ; have:
5397                                                                          ;
5398                                                                          ; P(2 1 0) = K2(2 1) * beta
5399               
5400 19D4 D360  22        movb @K2+3,ra                   ; LDA K2+3          ; Fetch the sign of the above result in K(3 2 1) from
     19D6 00AF     
5401                      .eor @BET2                      ; EOR BET2          ; K2+3 and EOR with BET2, the sign of the current pitch
     **** ****     > EOR
0001 19D8 D020  22        movb @BET2,rtmp
     19DA 008A     
0002 19DC 2B40  14        xor  rtmp,ra
                   < elite.a99
5402                                                                          ; rate, so if the pitch and K(3 2 1) have the same sign,
5403                                                                          ; A will be positive, else it will be negative. So A
5404                                                                          ; will contain the sign bit of K(3 2 1) * beta, which is
5405                                                                          ; the same as the sign of the above result, so we now
5406                                                                          ; have:
5407                                                                          ;
5408                                                                          ; (A P+2 P+1) = K2(3 2 1) * beta / 256
5409               
5410 19DE 020E  12        li   rx,>06*256                 ; LDX #6            ; Set (A P+2 P+1) = (z_sign z_hi z_lo) + (A P+2 P+1)
     19E0 0600     
5411 19E2 0200  12        li   rtmp,MVT6                  ; JSR MVT6          ; = z + K2 * beta / 256
     19E4 20D6     
5412 19E6 06A0  24        bl   @jsr                       ;
     19E8 FE28     
5413               
5414 19EA D80D  22        movb ra,@INWK+8                 ; STA INWK+8        ; Set z_sign = A = the sign of the result
     19EC 005B     
5415               
5416 19EE D360  22        movb @P+1,ra                    ; LDA P+1           ; Set z_lo = P+1, the low byte of the result
     19F0 001C     
5417 19F2 D80D  22        movb ra,@INWK+6                 ; STA INWK+6
     19F4 0059     
5418               
5419                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~z_lo (i.e. with all its bits flipped) so that
     **** ****     > EOI
0001 19F6 0200  12        li   rtmp,(>FF*256)
     19F8 FF00     
0002 19FA 2B40  14        xor  rtmp,ra
                   < elite.a99
5420 19FC D80D  22        movb ra,@P                      ; STA P             ; we can pass z_lo to MLTU2 below)
     19FE 001B     
5421               
5422 1A00 D360  22        movb @P+2,ra                    ; LDA P+2           ; Set z_hi = P+2
     1A02 001D     
5423 1A04 D80D  22        movb ra,@INWK+7                 ; STA INWK+7
     1A06 005A     
5424               
5425                                                                          ; So we now have result 2 above:
5426                                                                          ;
5427                                                                          ; (z_sign z_hi z_lo) = (A P+2 P+1)
5428                                                                          ; = z + K2 * beta / 256
5429               
5430 1A08 0200  12        li   rtmp,MLTU2                 ; JSR MLTU2         ; MLTU2 doesn't change Q, and Q was set to beta in
     1A0A 471C     
5431 1A0C 06A0  24        bl   @jsr                       ;
     1A0E FE28     
5432                                                                          ; the previous call to MLTU2, so this call does:
5433                                                                          ;
5434                                                                          ; (A P+1 P) = (A ~P) * Q
5435                                                                          ; = (z_hi z_lo) * beta
5436               
5437 1A10 D80D  22        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A = the high byte of the result, so we
     1A12 001D     
5438                                                                          ; now have:
5439                                                                          ;
5440                                                                          ; P(2 1 0) = (z_hi z_lo) * beta
5441               
5442 1A14 D360  22        movb @K2+3,ra                   ; LDA K2+3          ; Set y_sign = K2+3
     1A16 00AF     
5443 1A18 D80D  22        movb ra,@INWK+5                 ; STA INWK+5
     1A1A 0058     
5444               
5445                      .eor @BET2                      ; EOR BET2          ; EOR y_sign with BET2, the sign of the current pitch
     **** ****     > EOR
0001 1A1C D020  22        movb @BET2,rtmp
     1A1E 008A     
0002 1A20 2B40  14        xor  rtmp,ra
                   < elite.a99
5446                      .eor @INWK+8                    ; EOR INWK+8        ; rate, and z_sign. If the result is positive jump to
     **** ****     > EOR
0001 1A22 D020  22        movb @INWK+8,rtmp
     1A24 005B     
0002 1A26 2B40  14        xor  rtmp,ra
                   < elite.a99
5447 1A28 1512  10        jgt  MV43                       ; BPL MV43          ; MV43, otherwise this means beta * z and y have
5448                                                                          ; different signs, i.e. P(2 1) and K2(3 2 1) have
5449                                                                          ; different signs, so we need to add them in order to
5450                                                                          ; calculate K2(2 1) - P(2 1)
5451               
5452 1A2A D360  22        movb @P+1,ra                    ; LDA P+1           ; Set (y_hi y_lo) = K2(2 1) + P(2 1)
     1A2C 001C     
5453                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 1A2E 1701  10        jnc  !
0002 1A30 B347  14        ab   rone,ra
0003               !:
0004 1A32 B360  22        ab   @K2+1,ra
     1A34 00AD     
                   < elite.a99
5454 1A36 D80D  22        movb ra,@INWK+3                 ; STA INWK+3
     1A38 0056     
5455 1A3A D360  22        movb @P+2,ra                    ; LDA P+2
     1A3C 001D     
5456                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 1A3E 1701  10        jnc  !
0002 1A40 B347  14        ab   rone,ra
0003               !:
0004 1A42 B360  22        ab   @K2+2,ra
     1A44 00AE     
                   < elite.a99
5457 1A46 D80D  22        movb ra,@INWK+4                 ; STA INWK+4
     1A48 0057     
5458               
5459 1A4A 0460  16        b    @MV44                      ; JMP MV44          ; Jump to MV44 to continue the calculation
     1A4C 1A9E     
5460               
5461               MV43:
5462 1A4E D360  22        movb @K2+1,ra                   ; LDA K2+1          ; Reversing the logic above, we need to subtract P(2 1)
     1A50 00AD     
5463                      .sbc @P+1,ra                    ; SBC P+1           ; and K2(3 2 1) to calculate K2(2 1) - P(2 1), so this
     **** ****     > SBC
0001 1A52 1801  10        joc  !
0002 1A54 7347  14        sb   rone,ra
0003               !:
0004 1A56 7360  22        sb   @P+1,ra
     1A58 001C     
                   < elite.a99
5464 1A5A D80D  22        movb ra,@INWK+3                 ; STA INWK+3        ; sets (y_hi y_lo) = K2(2 1) - P(2 1)
     1A5C 0056     
5465 1A5E D360  22        movb @K2+2,ra                   ; LDA K2+2
     1A60 00AE     
5466                      .sbc @P+2,ra                    ; SBC P+2
     **** ****     > SBC
0001 1A62 1801  10        joc  !
0002 1A64 7347  14        sb   rone,ra
0003               !:
0004 1A66 7360  22        sb   @P+2,ra
     1A68 001D     
                   < elite.a99
5467 1A6A D80D  22        movb ra,@INWK+4                 ; STA INWK+4
     1A6C 0057     
5468               
5469 1A6E 1817  10        joc  MV44                       ; BCS MV44          ; If the above subtraction did not underflow, then
5470                                                                          ; jump to MV44, otherwise we need to negate the result
5471               
5472 1A70 020D  12        li   ra,>01*256                 ; LDA #1            ; Negate (y_sign y_hi y_lo) using two's complement,
     1A72 0100     
5473                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; first doing the low bytes:
     **** ****     > SBC
0001 1A74 1801  10        joc  !
0002 1A76 7347  14        sb   rone,ra
0003               !:
0004 1A78 7360  22        sb   @INWK+3,ra
     1A7A 0056     
                   < elite.a99
5474 1A7C D80D  22        movb ra,@INWK+3                 ; STA INWK+3        ;
     1A7E 0056     
5475                                                                          ; y_lo = 1 - y_lo
5476               
5477 1A80 020D  12        li   ra,>00*256                 ; LDA #0            ; Then the high bytes:
     1A82 0000     
5478                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 1A84 1801  10        joc  !
0002 1A86 7347  14        sb   rone,ra
0003               !:
0004 1A88 7360  22        sb   @INWK+4,ra
     1A8A 0057     
                   < elite.a99
5479 1A8C D80D  22        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     1A8E 0057     
5480               
5481 1A90 D360  22        movb @INWK+5,ra                 ; LDA INWK+5        ; And finally flip the sign in y_sign
     1A92 0058     
5482                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1A94 0200  12        li   rtmp,(>80*256)
     1A96 8000     
0002 1A98 2B40  14        xor  rtmp,ra
                   < elite.a99
5483 1A9A D80D  22        movb ra,@INWK+5                 ; STA INWK+5
     1A9C 0058     
5484               
5485               MV44:
5486                                                                          ; So we now have result 3 above:
5487                                                                          ;
5488                                                                          ; (y_sign y_hi y_lo) = K2(2 1) - P(2 1)
5489                                                                          ; = K2 - beta * z
5490 1A9E D3A0  22        movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
     1AA0 0087     
5491                                                                          ; if the roll angle is alpha, X contains |alpha|
5492               
5493 1AA2 D360  22        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P = ~y_lo (i.e. with all its bits flipped) so that
     1AA4 0056     
5494                      .eoi (>ff*256)                  ; EOR #&FF          ; we can pass y_lo to MLTU2 below)
     **** ****     > EOI
0001 1AA6 0200  12        li   rtmp,(>FF*256)
     1AA8 FF00     
0002 1AAA 2B40  14        xor  rtmp,ra
                   < elite.a99
5495 1AAC D80D  22        movb ra,@P                      ; STA P
     1AAE 001B     
5496               
5497 1AB0 D360  22        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi
     1AB2 0057     
5498               
5499 1AB4 0200  12        li   rtmp,MLTU2-2               ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
     1AB6 471A     
5500 1AB8 06A0  24        bl   @jsr                       ;
     1ABA FE28     
5501                                                                          ; = (y_hi y_lo) * alpha
5502               
5503 1ABC D80D  22        movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
     1ABE 001D     
5504                                                                          ; have:
5505                                                                          ;
5506                                                                          ; P(2 1 0) = (y_hi y_lo) * alpha
5507               
5508 1AC0 D360  22        movb @ALP2,ra                   ; LDA ALP2          ; Fetch the correct sign of the current roll angle alpha
     1AC2 0088     
5509                      .eor @INWK+5                    ; EOR INWK+5        ; from ALP2 and EOR with byte #5 (y_sign), so if the
     **** ****     > EOR
0001 1AC4 D020  22        movb @INWK+5,rtmp
     1AC6 0058     
0002 1AC8 2B40  14        xor  rtmp,ra
                   < elite.a99
5510                                                                          ; correct roll angle and y_sign have the same sign, A
5511                                                                          ; will be positive, else it will be negative. So A will
5512                                                                          ; contain the sign bit of x_sign * correct alpha sign,
5513                                                                          ; which is the same as the sign of the above result,
5514                                                                          ; so we now have:
5515                                                                          ;
5516                                                                          ; (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256
5517               
5518 1ACA 020E  12        li   rx,>00*256                 ; LDX #0            ; Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
     1ACC 0000     
5519 1ACE 0200  12        li   rtmp,MVT6                  ; JSR MVT6          ; = x + y * alpha / 256
     1AD0 20D6     
5520 1AD2 06A0  24        bl   @jsr                       ;
     1AD4 FE28     
5521               
5522 1AD6 D80D  22        movb ra,@INWK+2                 ; STA INWK+2        ; Set x_sign = A = the sign of the result
     1AD8 0055     
5523               
5524 1ADA D360  22        movb @P+2,ra                    ; LDA P+2           ; Set x_hi = P+2, the high byte of the result
     1ADC 001D     
5525 1ADE D80D  22        movb ra,@INWK+1                 ; STA INWK+1
     1AE0 0054     
5526               
5527 1AE2 D360  22        movb @P+1,ra                    ; LDA P+1           ; Set x_lo = P+1, the low byte of the result
     1AE4 001C     
5528 1AE6 D80D  22        movb ra,@INWK                   ; STA INWK
     1AE8 0053     
5529               
5530                                                                          ; So we now have result 4 above:
5531                                                                          ;
5532                                                                          ; x = x + alpha * y
5533                                                                          ;
5534                                                                          ; and the rotation of (x, y, z) is done
5535               
5536               * ******************************************************************************
5537               *
5538               * Name: MVEIT (Part 6 of 9)
5539               * Type: Subroutine
5540               * Category: Moving
5541               * Summary: Move current ship: Move the ship in space according to our speed
5542               *
5543               * ------------------------------------------------------------------------------
5544               *
5545               * This routine has multiple stages. This stage does the following:
5546               *
5547               * * Move the ship in space according to our speed (we already moved it
5548               * according to its own speed in part 3).
5549               *
5550               * We do this by subtracting our speed (i.e. the distance we travel in this
5551               * iteration of the loop) from the other ship's z-coordinate. We subtract because
5552               * they appear to be "moving" in the opposite direction to us, and the whole
5553               * MVEIT routine is about moving the other ships rather than us (even though we
5554               * are the one doing the moving).
5555               *
5556               * ------------------------------------------------------------------------------
5557               *
5558               * Other entry points:
5559               *
5560               * MV45                Rejoin the MVEIT routine after the rotation, tactics and
5561               * scanner code
5562               *
5563               * ******************************************************************************
5564               
5565               MV45:
5566 1AEA D360  22        movb @DELTA,ra                  ; LDA DELTA         ; Set R to our speed in DELTA
     1AEC 008C     
5567 1AEE D80D  22        movb ra,@R                      ; STA R
     1AF0 0091     
5568               
5569 1AF2 020D  12        li   ra,>80*256                 ; LDA #%10000000    ; Set A to zeroes but with bit 7 set, so that (A R) is
     1AF4 8000     
5570                                                                          ; a 16-bit number containing -R, or -speed
5571               
5572 1AF6 020E  12        li   rx,>06*256                 ; LDX #6            ; Set X to the z-axis so the call to MVT1 does this:
     1AF8 0600     
5573 1AFA 0200  12        li   rtmp,MVT1                  ; JSR MVT1          ;
     1AFC 1C1A     
5574 1AFE 06A0  24        bl   @jsr                       ;
     1B00 FE28     
5575                                                                          ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + (A R)
5576                                                                          ; = (z_sign z_hi z_lo) - speed
5577               
5578 1B02 D360  22        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is not the sun (129) then skip the
     1B04 009B     
5579 1B06 024D  14        andi ra,>81*256                 ; AND #%10000001    ; next instruction, otherwise return from the subroutine
     1B08 8100     
5580 1B0A 028D  14        ci   ra,>81*256                 ; CMP #129          ; as we don't need to rotate the sun around its origin.
     1B0C 8100     
5581 1B0E 1602  10        jne  B17                        ; BNE B17           ; Having both the AND and the CMP is a little odd, as
5582                                                                          ; the sun is the only ship type with bits 0 and 7 set,
5583                                                                          ; so the AND has no effect and could be removed
5584               
5585 1B10 0460  20        b    @rts                       ; RTS               ; Return from the subroutine, as the ship we are moving
     1B12 FE34     
5586                                                                          ; is the sun and doesn't need any of the following
5587               
5588               * ******************************************************************************
5589               *
5590               * Name: MVEIT (Part 7 of 9)
5591               * Type: Subroutine
5592               * Category: Moving
5593               * Summary: Move current ship: Rotate ship's orientation vectors by pitch/roll
5594               * Deep dive: Orientation vectors
5595               * Pitching and rolling
5596               *
5597               * ------------------------------------------------------------------------------
5598               *
5599               * This routine has multiple stages. This stage does the following:
5600               *
5601               * * Rotate the ship's orientation vectors according to our pitch and roll
5602               *
5603               * As with the previous step, this is all about moving the other ships rather
5604               * than us (even though we are the one doing the moving). So we rotate the
5605               * current ship's orientation vectors (which defines its orientation in space),
5606               * by the angles we are "moving" the rest of the sky through (alpha and beta, our
5607               * roll and pitch), so the ship appears to us to be stationary while we rotate.
5608               *
5609               * ******************************************************************************
5610               
5611               B17:
5612 1B14 020F  12        li   ry,>09*256                 ; LDY #9            ; Apply our pitch and roll rotations to the current
     1B16 0900     
5613 1B18 0200  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's nosev vector
     1B1A 1E40     
5614 1B1C 06A0  24        bl   @jsr                       ;
     1B1E FE28     
5615               
5616 1B20 020F  12        li   ry,>0f*256                 ; LDY #15           ; Apply our pitch and roll rotations to the current
     1B22 0F00     
5617 1B24 0200  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's roofv vector
     1B26 1E40     
5618 1B28 06A0  24        bl   @jsr                       ;
     1B2A FE28     
5619               
5620 1B2C 020F  12        li   ry,>15*256                 ; LDY #21           ; Apply our pitch and roll rotations to the current
     1B2E 1500     
5621 1B30 0200  12        li   rtmp,MVS4                  ; JSR MVS4          ; ship's sidev vector
     1B32 1E40     
5622 1B34 06A0  24        bl   @jsr                       ;
     1B36 FE28     
5623               
5624               * ******************************************************************************
5625               *
5626               * Name: MVEIT (Part 8 of 9)
5627               * Type: Subroutine
5628               * Category: Moving
5629               * Summary: Move current ship: Rotate ship about itself by its own pitch/roll
5630               * Deep dive: Orientation vectors
5631               * Pitching and rolling by a fixed angle
5632               *
5633               * ------------------------------------------------------------------------------
5634               *
5635               * This routine has multiple stages. This stage does the following:
5636               *
5637               * * If the ship we are processing is rolling or pitching itself, rotate it and
5638               * apply damping if required
5639               *
5640               * ******************************************************************************
5641               
5642 1B38 D360  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the sign
     1B3A 0071     
5643 1B3C 024D  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1B3E 8000     
5644 1B40 D80D  22        movb ra,@RAT2                   ; STA RAT2
     1B42 00AB     
5645               
5646 1B44 D360  22        movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the value
     1B46 0071     
5647 1B48 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1B4A 7F00     
5648               
5649 1B4C 1322  10        jeq  MV8                        ; BEQ MV8           ; If the pitch counter is 0, then jump to MV8 to skip
5650                                                                          ; the following, as the ship is not pitching
5651               
5652 1B4E 028D  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the pitch counter (i.e. the
     1B50 7F00     
5653                                                                          ; ship's pitch is not damping down), then the C flag
5654                                                                          ; will be set by this instruction
5655               
5656                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1B52 1801  10        joc  !
0002 1B54 7347  14        sb   rone,ra
0003               !:
0004 1B56 022D  14        ai   ra,-(>00*256)
     1B58 0000     
                   < elite.a99
5657                                                                          ; reduce A by 1, otherwise it is unchanged
5658               
5659 1B5A F360  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1B5C 00AB     
5660                                                                          ; the updated pitch counter in A retains its sign
5661               
5662 1B5E D80D  22        movb ra,@INWK+30                ; STA INWK+30       ; Store the updated pitch counter in byte #30
     1B60 0071     
5663               
5664 1B62 020E  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, nosev_x) by a small angle (pitch)
     1B64 0F00     
5665 1B66 020F  12        li   ry,>09*256                 ; LDY #9
     1B68 0900     
5666 1B6A 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B6C 1F54     
5667 1B6E 06A0  24        bl   @jsr                       ;
     1B70 FE28     
5668               
5669 1B72 020E  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, nosev_y) by a small angle (pitch)
     1B74 1100     
5670 1B76 020F  12        li   ry,>0b*256                 ; LDY #11
     1B78 0B00     
5671 1B7A 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B7C 1F54     
5672 1B7E 06A0  24        bl   @jsr                       ;
     1B80 FE28     
5673               
5674 1B82 020E  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, nosev_z) by a small angle (pitch)
     1B84 1300     
5675 1B86 020F  12        li   ry,>0d*256                 ; LDY #13
     1B88 0D00     
5676 1B8A 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1B8C 1F54     
5677 1B8E 06A0  24        bl   @jsr                       ;
     1B90 FE28     
5678               
5679               MV8:
5680 1B92 D360  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the sign
     1B94 0070     
5681 1B96 024D  14        andi ra,>80*256                 ; AND #%10000000    ; into RAT2
     1B98 8000     
5682 1B9A D80D  22        movb ra,@RAT2                   ; STA RAT2
     1B9C 00AB     
5683               
5684 1B9E D360  22        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the value
     1BA0 0070     
5685 1BA2 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A
     1BA4 7F00     
5686               
5687 1BA6 1322  10        jeq  MV5                        ; BEQ MV5           ; If the roll counter is 0, then jump to MV5 to skip the
5688                                                                          ; following, as the ship is not rolling
5689               
5690 1BA8 028D  14        ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the roll counter (i.e. the
     1BAA 7F00     
5691                                                                          ; ship's roll is not damping down), then the C flag
5692                                                                          ; will be set by this instruction
5693               
5694                      .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
     **** ****     > SBI
0001 1BAC 1801  10        joc  !
0002 1BAE 7347  14        sb   rone,ra
0003               !:
0004 1BB0 022D  14        ai   ra,-(>00*256)
     1BB2 0000     
                   < elite.a99
5695                                                                          ; reduce A by 1, otherwise it is unchanged
5696               
5697 1BB4 F360  22        socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
     1BB6 00AB     
5698                                                                          ; the updated roll counter in A retains its sign
5699               
5700 1BB8 D80D  22        movb ra,@INWK+29                ; STA INWK+29       ; Store the updated pitch counter in byte #29
     1BBA 0070     
5701               
5702 1BBC 020E  12        li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, sidev_x) by a small angle (roll)
     1BBE 0F00     
5703 1BC0 020F  12        li   ry,>15*256                 ; LDY #21
     1BC2 1500     
5704 1BC4 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1BC6 1F54     
5705 1BC8 06A0  24        bl   @jsr                       ;
     1BCA FE28     
5706               
5707 1BCC 020E  12        li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, sidev_y) by a small angle (roll)
     1BCE 1100     
5708 1BD0 020F  12        li   ry,>17*256                 ; LDY #23
     1BD2 1700     
5709 1BD4 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1BD6 1F54     
5710 1BD8 06A0  24        bl   @jsr                       ;
     1BDA FE28     
5711               
5712 1BDC 020E  12        li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, sidev_z) by a small angle (roll)
     1BDE 1300     
5713 1BE0 020F  12        li   ry,>19*256                 ; LDY #25
     1BE2 1900     
5714 1BE4 0200  12        li   rtmp,MVS5                  ; JSR MVS5
     1BE6 1F54     
5715 1BE8 06A0  24        bl   @jsr                       ;
     1BEA FE28     
5716               
5717               * ******************************************************************************
5718               *
5719               * Name: MVEIT (Part 9 of 9)
5720               * Type: Subroutine
5721               * Category: Moving
5722               * Summary: Move current ship: Redraw on scanner, if it hasn't been destroyed
5723               *
5724               * ------------------------------------------------------------------------------
5725               *
5726               * This routine has multiple stages. This stage does the following:
5727               *
5728               * * If the ship is exploding or being removed, hide it on the scanner
5729               *
5730               * * Otherwise redraw the ship on the scanner, now that it's been moved
5731               *
5732               * ******************************************************************************
5733               
5734               MV5:
5735 1BEC D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's exploding/killed state from byte #31
     1BEE 0072     
5736               
5737 1BF0 024D  14        andi ra,>a0*256                 ; AND #%10100000    ; If we are exploding or removing this ship then jump to
     1BF2 A000     
5738 1BF4 1608  10        jne  MVD1                       ; BNE MVD1          ; MVD1 to remove it from the scanner permanently
5739               
5740 1BF6 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 4 to keep the ship visible on the scanner
     1BF8 0072     
5741 1BFA 026D  14        ori  ra,>10*256                 ; ORA #%00010000
     1BFC 1000     
5742 1BFE D80D  22        movb ra,@INWK+31                ; STA INWK+31
     1C00 0072     
5743               
5744 1C02 0460  20        b    @SCAN                      ; JMP SCAN          ; Display the ship on the scanner, returning from the
     1C04 505A     
5745                                                                          ; subroutine using a tail call
5746               
5747               MVD1:
5748 1C06 D360  22        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 4 to hide the ship on the scanner
     1C08 0072     
5749 1C0A 024D  14        andi ra,>ef*256                 ; AND #%11101111
     1C0C EF00     
5750 1C0E D80D  22        movb ra,@INWK+31                ; STA INWK+31
     1C10 0072     
5751               
5752 1C12 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1C14 FE34     
5753               
5754               * ******************************************************************************
5755               *
5756               * Name: MVT1
5757               * Type: Subroutine
5758               * Category: Moving
5759               * Summary: Calculate (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5760               *
5761               * ------------------------------------------------------------------------------
5762               *
5763               * Add the signed delta (A R) to a ship's coordinate, along the axis given in X.
5764               * Mathematically speaking, this routine translates the ship along a single axis
5765               * by a signed delta. Taking the example of X = 0, the x-axis, it does the
5766               * following:
5767               *
5768               * (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
5769               *
5770               * (In practice, MVT1 is only ever called directly with A = 0 or 128, otherwise
5771               * it is always called via MVT-2, which clears A apart from the sign bit. The
5772               * routine is written to cope with a non-zero delta_hi, so it supports a full
5773               * 16-bit delta, but it appears that delta_hi is only ever used to hold the
5774               * sign of the delta.)
5775               *
5776               * The comments below assume we are adding delta to the x-axis, though the axis
5777               * is determined by the value of X.
5778               *
5779               * ------------------------------------------------------------------------------
5780               *
5781               * Arguments:
5782               *
5783               * (A R)               The signed delta, so A = delta_hi and R = delta_lo
5784               *
5785               * X                   Determines which coordinate axis of INWK to change:
5786               *
5787               * * X = 0 adds the delta to (x_lo, x_hi, x_sign)
5788               *
5789               * * X = 3 adds the delta to (y_lo, y_hi, y_sign)
5790               *
5791               * * X = 6 adds the delta to (z_lo, z_hi, z_sign)
5792               *
5793               * ------------------------------------------------------------------------------
5794               *
5795               * Other entry points:
5796               *
5797               * MVT1-2              Clear bits 0-6 of A before entering MVT1
5798               *
5799               * ******************************************************************************
5800               
5801 1C16 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Clear bits 0-6 of A
     1C18 8000     
5802               
5803               MVT1:
5804                      .asla                           ; ASL A             ; Set the C flag to the sign bit of the delta, leaving
     **** ****     > ASLA
0001 1C1A 024D  14        andi ra,>ff00
     1C1C FF00     
0002 1C1E 0A1D  14        sla  ra,1
                   < elite.a99
5805                                                                          ; delta_hi << 1 in A
5806               
5807 1C20 D80D  22        movb ra,@S                      ; STA S             ; Set S = delta_hi << 1
     1C22 0092     
5808                                                                          ;
5809                                                                          ; This also clears bit 0 of S
5810               
5811 1C24 020D  12        li   ra,>00*256                 ; LDA #0            ; Set T = just the sign bit of delta (in bit 7)
     1C26 0000     
5812 1C28 06A0  24        bl   @rora                      ; ROR A
     1C2A FE62     
5813 1C2C D80D  22        movb ra,@T                      ; STA T
     1C2E 00D1     
5814               
5815                      .lsr @S                         ; LSR S             ; Set S = delta_hi >> 1
     **** ****     > LSR
0001 1C30 D020  22        movb @S,rtmp
     1C32 0092     
0002 1C34 0910  14        srl  rtmp,1
0003 1C36 D800  22        movb rtmp,@S
     1C38 0092     
                   < elite.a99
5816                                                                          ; = |delta_hi|
5817                                                                          ;
5818                                                                          ; This also clear the C flag, as we know that bit 0 of
5819                                                                          ; S was clear before the LSR
5820               
5821 1C3A 06CE  10        swpb rx                         ;
5822                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If T EOR x_sign has bit 7 set, then x_sign and delta
     **** ****     > EOR
0001 1C3C D02E  26        movb @INWK+2(RX),rtmp
     1C3E 0055     
0002 1C40 2B40  14        xor  rtmp,ra
                   < elite.a99
5823 1C42 06CE  10        swpb rx                         ;
5824 1C44 1128  10        jlt  MV10                       ; BMI MV10          ; have different signs, so jump to MV10
5825               
5826                                                                          ; At this point, we know x_sign and delta have the same
5827                                                                          ; sign, that sign is in T, and S contains |delta_hi|,
5828                                                                          ; so now we want to do:
5829                                                                          ;
5830                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (S R)
5831                                                                          ;
5832                                                                          ; and then set the sign of the result to the same sign
5833                                                                          ; as x_sign and delta
5834               
5835 1C46 D360  22        movb @R,ra                      ; LDA R             ; First we add the low bytes, so:
     1C48 0091     
5836 1C4A 06CE  10        swpb rx                         ;
5837                      .adc @INWK(rx),ra               ; ADC INWK,X        ;
     **** ****     > ADC
0001 1C4C 1701  10        jnc  !
0002 1C4E B347  14        ab   rone,ra
0003               !:
0004 1C50 B36E  26        ab   @INWK(RX),ra
     1C52 0053     
                   < elite.a99
5838 1C54 06CE  10        swpb rx                         ;
5839 1C56 06CE  10        swpb rx                         ;
5840 1C58 DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = x_lo + R
     1C5A 0053     
5841 1C5C 06CE  10        swpb rx                         ;
5842               
5843 1C5E D360  22        movb @S,ra                      ; LDA S             ; Then we add the high bytes:
     1C60 0092     
5844 1C62 06CE  10        swpb rx                         ;
5845                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 1C64 1701  10        jnc  !
0002 1C66 B347  14        ab   rone,ra
0003               !:
0004 1C68 B36E  26        ab   @INWK+1(RX),ra
     1C6A 0054     
                   < elite.a99
5846 1C6C 06CE  10        swpb rx                         ;
5847 1C6E 06CE  10        swpb rx                         ;
5848 1C70 DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi + S
     1C72 0054     
5849 1C74 06CE  10        swpb rx                         ;
5850               
5851 1C76 06CE  10        swpb rx                         ;
5852 1C78 D36E  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we add any carry into x_sign, and if the
     1C7A 0055     
5853 1C7C 06CE  10        swpb rx                         ;
5854                      .adi (>00*256)                  ; ADC #0            ; sign of x_sign and delta in T is negative, make sure
     **** ****     > ADI
0001 1C7E 1701  10        jnc  !
0002 1C80 B347  14        ab   rone,ra
0003               !:
0004 1C82 022D  14        ai   ra,(>00*256)
     1C84 0000     
                   < elite.a99
5855 1C86 F360  22        socb @T,ra                      ; ORA T             ; the result is negative (by OR'ing with T)
     1C88 00D1     
5856 1C8A 06CE  10        swpb rx                         ;
5857 1C8C DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1C8E 0055     
5858 1C90 06CE  10        swpb rx                         ;
5859               
5860 1C92 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1C94 FE34     
5861               
5862               MV10:
5863                                                                          ; If we get here, we know x_sign and delta have
5864                                                                          ; different signs, with delta's sign in T, and
5865                                                                          ; |delta_hi| in S, so now we want to do:
5866                                                                          ;
5867                                                                          ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - (S R)
5868                                                                          ;
5869                                                                          ; and then set the sign of the result according to
5870                                                                          ; the signs of x_sign and delta
5871 1C96 06CE  10        swpb rx                         ;
5872 1C98 D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes, so:
     1C9A 0053     
5873 1C9C 06CE  10        swpb rx                         ;
5874                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1C9E 0A18  14        sla  rmone,1
                   < elite.a99
5875                      .sbc @R,ra                      ; SBC R             ; x_lo = x_lo - R
     **** ****     > SBC
0001 1CA0 1801  10        joc  !
0002 1CA2 7347  14        sb   rone,ra
0003               !:
0004 1CA4 7360  22        sb   @R,ra
     1CA6 0091     
                   < elite.a99
5876 1CA8 06CE  10        swpb rx                         ;
5877 1CAA DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X
     1CAC 0053     
5878 1CAE 06CE  10        swpb rx                         ;
5879               
5880 1CB0 06CE  10        swpb rx                         ;
5881 1CB2 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then we subtract the high bytes:
     1CB4 0054     
5882 1CB6 06CE  10        swpb rx                         ;
5883                      .sbc @S,ra                      ; SBC S             ;
     **** ****     > SBC
0001 1CB8 1801  10        joc  !
0002 1CBA 7347  14        sb   rone,ra
0003               !:
0004 1CBC 7360  22        sb   @S,ra
     1CBE 0092     
                   < elite.a99
5884 1CC0 06CE  10        swpb rx                         ;
5885 1CC2 DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi - S
     1CC4 0054     
5886 1CC6 06CE  10        swpb rx                         ;
5887               
5888 1CC8 06CE  10        swpb rx                         ;
5889 1CCA D36E  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we subtract any borrow from bits 0-6 of
     1CCC 0055     
5890 1CCE 06CE  10        swpb rx                         ;
5891 1CD0 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; x_sign, and give the result the opposite sign bit to T
     1CD2 7F00     
5892                      .sbi (>00*256)                  ; SBC #0            ; (i.e. give it the sign of the original x_sign)
     **** ****     > SBI
0001 1CD4 1801  10        joc  !
0002 1CD6 7347  14        sb   rone,ra
0003               !:
0004 1CD8 022D  14        ai   ra,-(>00*256)
     1CDA 0000     
                   < elite.a99
5893 1CDC 026D  14        ori  ra,>80*256                 ; ORA #%10000000
     1CDE 8000     
5894                      .eor @T                         ; EOR T
     **** ****     > EOR
0001 1CE0 D020  22        movb @T,rtmp
     1CE2 00D1     
0002 1CE4 2B40  14        xor  rtmp,ra
                   < elite.a99
5895 1CE6 06CE  10        swpb rx                         ;
5896 1CE8 DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X
     1CEA 0055     
5897 1CEC 06CE  10        swpb rx                         ;
5898               
5899 1CEE 1828  10        joc  MV11                       ; BCS MV11          ; If the C flag is set by the above SBC, then our sum
5900                                                                          ; above didn't underflow and is correct - to put it
5901                                                                          ; another way, (x_sign x_hi x_lo) >= (S R) so the result
5902                                                                          ; should indeed have the same sign as x_sign, so jump to
5903                                                                          ; MV11 to return from the subroutine
5904               
5905                                                                          ; Otherwise our subtraction underflowed because
5906                                                                          ; (x_sign x_hi x_lo) < (S R), so we now need to flip the
5907                                                                          ; subtraction around by using two's complement to this:
5908                                                                          ;
5909                                                                          ; (S R) - (x_sign x_hi x_lo)
5910                                                                          ;
5911                                                                          ; and then we need to give the result the same sign as
5912                                                                          ; (S R), the delta, as that's the dominant figure in the
5913                                                                          ; sum
5914               
5915 1CF0 020D  12        li   ra,>01*256                 ; LDA #1            ; First we subtract the low bytes, so:
     1CF2 0100     
5916 1CF4 06CE  10        swpb rx                         ;
5917                      .sbc @INWK(rx),ra               ; SBC INWK,X        ;
     **** ****     > SBC
0001 1CF6 1801  10        joc  !
0002 1CF8 7347  14        sb   rone,ra
0003               !:
0004 1CFA 736E  26        sb   @INWK(RX),ra
     1CFC 0053     
                   < elite.a99
5918 1CFE 06CE  10        swpb rx                         ;
5919 1D00 06CE  10        swpb rx                         ;
5920 1D02 DB8D  30        movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = 1 - x_lo
     1D04 0053     
5921 1D06 06CE  10        swpb rx                         ;
5922               
5923 1D08 020D  12        li   ra,>00*256                 ; LDA #0            ; Then we subtract the high bytes:
     1D0A 0000     
5924 1D0C 06CE  10        swpb rx                         ;
5925                      .sbc @INWK+1(rx),ra             ; SBC INWK+1,X      ;
     **** ****     > SBC
0001 1D0E 1801  10        joc  !
0002 1D10 7347  14        sb   rone,ra
0003               !:
0004 1D12 736E  26        sb   @INWK+1(RX),ra
     1D14 0054     
                   < elite.a99
5926 1D16 06CE  10        swpb rx                         ;
5927 1D18 06CE  10        swpb rx                         ;
5928 1D1A DB8D  30        movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = 0 - x_hi
     1D1C 0054     
5929 1D1E 06CE  10        swpb rx                         ;
5930               
5931 1D20 020D  12        li   ra,>00*256                 ; LDA #0            ; And then we subtract the sign bytes:
     1D22 0000     
5932 1D24 06CE  10        swpb rx                         ;
5933                      .sbc @INWK+2(rx),ra             ; SBC INWK+2,X      ;
     **** ****     > SBC
0001 1D26 1801  10        joc  !
0002 1D28 7347  14        sb   rone,ra
0003               !:
0004 1D2A 736E  26        sb   @INWK+2(RX),ra
     1D2C 0055     
                   < elite.a99
5934 1D2E 06CE  10        swpb rx                         ;
5935                                                                          ; x_sign = 0 - x_sign
5936               
5937 1D30 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Finally, we set the sign bit to the sign in T, the
     1D32 7F00     
5938 1D34 F360  22        socb @T,ra                      ; ORA T             ; sign of the original delta, as the delta is the
     1D36 00D1     
5939 1D38 06CE  10        swpb rx                         ;
5940 1D3A DB8D  30        movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; dominant figure in the sum
     1D3C 0055     
5941 1D3E 06CE  10        swpb rx                         ;
5942               
5943               MV11:
5944 1D40 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1D42 FE34     
5945               
5946               * ******************************************************************************
5947               *
5948               * Name: MVT3
5949               * Type: Subroutine
5950               * Category: Moving
5951               * Summary: Calculate K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5952               *
5953               * ------------------------------------------------------------------------------
5954               *
5955               * Add an INWK position coordinate - i.e. x, y or z - to K(3 2 1), like this:
5956               *
5957               * K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
5958               *
5959               * The INWK coordinate to add to K(3 2 1) is specified by X.
5960               *
5961               * ------------------------------------------------------------------------------
5962               *
5963               * Arguments:
5964               *
5965               * X                   The coordinate to add to K(3 2 1), as follows:
5966               *
5967               * * If X = 0, add (x_sign x_hi x_lo)
5968               *
5969               * * If X = 3, add (y_sign y_hi y_lo)
5970               *
5971               * * If X = 6, add (z_sign z_hi z_lo)
5972               *
5973               * ------------------------------------------------------------------------------
5974               *
5975               * Returns:
5976               *
5977               * A                   Contains a copy of the high byte of the result, K+3
5978               *
5979               * X                   X is preserved
5980               *
5981               * ******************************************************************************
5982               
5983               MVT3:
5984 1D44 D360  22        movb @K+3,ra                    ; LDA K+3           ; Set S = K+3
     1D46 0040     
5985 1D48 D80D  22        movb ra,@S                      ; STA S
     1D4A 0092     
5986               
5987 1D4C 024D  14        andi ra,>80*256                 ; AND #%10000000    ; Set T = sign bit of K(3 2 1)
     1D4E 8000     
5988 1D50 D80D  22        movb ra,@T                      ; STA T
     1D52 00D1     
5989               
5990 1D54 06CE  10        swpb rx                         ;
5991                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If x_sign has a different sign to K(3 2 1), jump to
     **** ****     > EOR
0001 1D56 D02E  26        movb @INWK+2(RX),rtmp
     1D58 0055     
0002 1D5A 2B40  14        xor  rtmp,ra
                   < elite.a99
5992 1D5C 06CE  10        swpb rx                         ;
5993 1D5E 1125  10        jlt  MV13                       ; BMI MV13          ; MV13 to process the addition as a subtraction
5994               
5995 1D60 D360  22        movb @K+1,ra                    ; LDA K+1           ; Set K(3 2 1) = K(3 2 1) + (x_sign x_hi x_lo)
     1D62 003E     
5996                      .clc                            ; CLC               ; starting with the low bytes
     **** ****     > CLC
0001 1D64 0A16  14        sla  rzero,1
                   < elite.a99
5997 1D66 06CE  10        swpb rx                         ;
5998                      .adc @INWK(rx),ra               ; ADC INWK,X
     **** ****     > ADC
0001 1D68 1701  10        jnc  !
0002 1D6A B347  14        ab   rone,ra
0003               !:
0004 1D6C B36E  26        ab   @INWK(RX),ra
     1D6E 0053     
                   < elite.a99
5999 1D70 06CE  10        swpb rx                         ;
6000 1D72 D80D  22        movb ra,@K+1                    ; STA K+1
     1D74 003E     
6001               
6002 1D76 D360  22        movb @K+2,ra                    ; LDA K+2           ; Then the middle bytes
     1D78 003F     
6003 1D7A 06CE  10        swpb rx                         ;
6004                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X
     **** ****     > ADC
0001 1D7C 1701  10        jnc  !
0002 1D7E B347  14        ab   rone,ra
0003               !:
0004 1D80 B36E  26        ab   @INWK+1(RX),ra
     1D82 0054     
                   < elite.a99
6005 1D84 06CE  10        swpb rx                         ;
6006 1D86 D80D  22        movb ra,@K+2                    ; STA K+2
     1D88 003F     
6007               
6008 1D8A D360  22        movb @K+3,ra                    ; LDA K+3           ; And finally the high bytes
     1D8C 0040     
6009 1D8E 06CE  10        swpb rx                         ;
6010                      .adc @INWK+2(rx),ra             ; ADC INWK+2,X
     **** ****     > ADC
0001 1D90 1701  10        jnc  !
0002 1D92 B347  14        ab   rone,ra
0003               !:
0004 1D94 B36E  26        ab   @INWK+2(RX),ra
     1D96 0055     
                   < elite.a99
6011 1D98 06CE  10        swpb rx                         ;
6012               
6013 1D9A 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Setting the sign bit of K+3 to T, the original sign
     1D9C 7F00     
6014 1D9E F360  22        socb @T,ra                      ; ORA T             ; of K(3 2 1)
     1DA0 00D1     
6015 1DA2 D80D  22        movb ra,@K+3                    ; STA K+3
     1DA4 0040     
6016               
6017 1DA6 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1DA8 FE34     
6018               
6019               MV13:
6020 1DAA D360  22        movb @S,ra                      ; LDA S             ; Set S = |K+3| (i.e. K+3 with the sign bit cleared)
     1DAC 0092     
6021 1DAE 024D  14        andi ra,>7f*256                 ; AND #%01111111
     1DB0 7F00     
6022 1DB2 D80D  22        movb ra,@S                      ; STA S
     1DB4 0092     
6023               
6024 1DB6 06CE  10        swpb rx                         ;
6025 1DB8 D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Set K(3 2 1) = (x_sign x_hi x_lo) - K(3 2 1)
     1DBA 0053     
6026 1DBC 06CE  10        swpb rx                         ;
6027                      .sec                            ; SEC               ; starting with the low bytes
     **** ****     > SEC
0001 1DBE 0A18  14        sla  rmone,1
                   < elite.a99
6028                      .sbc @K+1,ra                    ; SBC K+1
     **** ****     > SBC
0001 1DC0 1801  10        joc  !
0002 1DC2 7347  14        sb   rone,ra
0003               !:
0004 1DC4 7360  22        sb   @K+1,ra
     1DC6 003E     
                   < elite.a99
6029 1DC8 D80D  22        movb ra,@K+1                    ; STA K+1
     1DCA 003E     
6030               
6031 1DCC 06CE  10        swpb rx                         ;
6032 1DCE D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then the middle bytes
     1DD0 0054     
6033 1DD2 06CE  10        swpb rx                         ;
6034                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1DD4 1801  10        joc  !
0002 1DD6 7347  14        sb   rone,ra
0003               !:
0004 1DD8 7360  22        sb   @K+2,ra
     1DDA 003F     
                   < elite.a99
6035 1DDC D80D  22        movb ra,@K+2                    ; STA K+2
     1DDE 003F     
6036               
6037 1DE0 06CE  10        swpb rx                         ;
6038 1DE2 D36E  26        movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally the high bytes, doing A = |x_sign| - |K+3|
     1DE4 0055     
6039 1DE6 06CE  10        swpb rx                         ;
6040 1DE8 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; and setting the C flag for testing below
     1DEA 7F00     
6041                      .sbc @S,ra                      ; SBC S
     **** ****     > SBC
0001 1DEC 1801  10        joc  !
0002 1DEE 7347  14        sb   rone,ra
0003               !:
0004 1DF0 7360  22        sb   @S,ra
     1DF2 0092     
                   < elite.a99
6042               
6043 1DF4 026D  14        ori  ra,>80*256                 ; ORA #%10000000    ; Set the sign bit of K+3 to the opposite sign of T,
     1DF6 8000     
6044                      .eor @T                         ; EOR T             ; i.e. the opposite sign to the original K(3 2 1)
     **** ****     > EOR
0001 1DF8 D020  22        movb @T,rtmp
     1DFA 00D1     
0002 1DFC 2B40  14        xor  rtmp,ra
                   < elite.a99
6045 1DFE D80D  22        movb ra,@K+3                    ; STA K+3
     1E00 0040     
6046               
6047 1E02 181C  10        joc  MV14                       ; BCS MV14          ; If the C flag is set, i.e. |x_sign| >= |K+3|, then
6048                                                                          ; the sign of K(3 2 1). In this case, we want the
6049                                                                          ; result to have the same sign as the largest argument,
6050                                                                          ; which is (x_sign x_hi x_lo), which we know has the
6051                                                                          ; opposite sign to K(3 2 1), and that's what we just set
6052                                                                          ; the sign of K(3 2 1) to... so we can jump to MV14 to
6053                                                                          ; return from the subroutine
6054               
6055 1E04 020D  12        li   ra,>01*256                 ; LDA #1            ; We need to swap the sign of the result in K(3 2 1),
     1E06 0100     
6056                      .sbc @K+1,ra                    ; SBC K+1           ; which we do by calculating 0 - K(3 2 1), which we can
     **** ****     > SBC
0001 1E08 1801  10        joc  !
0002 1E0A 7347  14        sb   rone,ra
0003               !:
0004 1E0C 7360  22        sb   @K+1,ra
     1E0E 003E     
                   < elite.a99
6057 1E10 D80D  22        movb ra,@K+1                    ; STA K+1           ; do with 1 - C - K(3 2 1), as we know the C flag is
     1E12 003E     
6058                                                                          ; clear. We start with the low bytes
6059               
6060 1E14 020D  12        li   ra,>00*256                 ; LDA #0            ; Then the middle bytes
     1E16 0000     
6061                      .sbc @K+2,ra                    ; SBC K+2
     **** ****     > SBC
0001 1E18 1801  10        joc  !
0002 1E1A 7347  14        sb   rone,ra
0003               !:
0004 1E1C 7360  22        sb   @K+2,ra
     1E1E 003F     
                   < elite.a99
6062 1E20 D80D  22        movb ra,@K+2                    ; STA K+2
     1E22 003F     
6063               
6064 1E24 020D  12        li   ra,>00*256                 ; LDA #0            ; And finally the high bytes
     1E26 0000     
6065                      .sbc @K+3,ra                    ; SBC K+3
     **** ****     > SBC
0001 1E28 1801  10        joc  !
0002 1E2A 7347  14        sb   rone,ra
0003               !:
0004 1E2C 7360  22        sb   @K+3,ra
     1E2E 0040     
                   < elite.a99
6066               
6067 1E30 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; Set the sign bit of K+3 to the same sign as T,
     1E32 7F00     
6068 1E34 F360  22        socb @T,ra                      ; ORA T             ; i.e. the same sign as the original K(3 2 1), as
     1E36 00D1     
6069 1E38 D80D  22        movb ra,@K+3                    ; STA K+3           ; that's the largest argument
     1E3A 0040     
6070               
6071               MV14:
6072 1E3C 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1E3E FE34     
6073               
6074               * ******************************************************************************
6075               *
6076               * Name: MVS4
6077               * Type: Subroutine
6078               * Category: Moving
6079               * Summary: Apply pitch and roll to an orientation vector
6080               * Deep dive: Orientation vectors
6081               * Pitching and rolling
6082               *
6083               * ------------------------------------------------------------------------------
6084               *
6085               * Apply pitch and roll angles alpha and beta to the orientation vector in Y.
6086               *
6087               * Specifically, this routine rotates a point (x, y, z) around the origin by
6088               * pitch alpha and roll beta, using the small angle approximation to make the
6089               * maths easier, and incorporating the Minsky circle algorithm to make the
6090               * rotation more stable (though more elliptic).
6091               *
6092               * If that paragraph makes sense to you, then you should probably be writing
6093               * this commentary! For the rest of us, there's a detailed explanation of all
6094               * this in the deep dive on "Pitching and rolling".
6095               *
6096               * ------------------------------------------------------------------------------
6097               *
6098               * Arguments:
6099               *
6100               * Y                   Determines which of the INWK orientation vectors to
6101               * transform:
6102               *
6103               * * Y = 9 rotates nosev: (nosev_x, nosev_y, nosev_z)
6104               *
6105               * * Y = 15 rotates roofv: (roofv_x, roofv_y, roofv_z)
6106               *
6107               * * Y = 21 rotates sidev: (sidev_x, sidev_y, sidev_z)
6108               *
6109               * ******************************************************************************
6110               
6111               MVS4:
6112 1E40 D360  22        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = alpha (the roll angle to rotate through)
     1E42 009E     
6113 1E44 D80D  22        movb ra,@Q                      ; STA Q
     1E46 0090     
6114               
6115 1E48 06CF  10        swpb ry                         ;
6116 1E4A D3AF  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1E4C 0055     
6117 1E4E 06CF  10        swpb ry                         ;
6118 1E50 D80E  22        movb rx,@R                      ; STX R
     1E52 0091     
6119 1E54 06CF  10        swpb ry                         ;
6120 1E56 D3AF  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1E58 0056     
6121 1E5A 06CF  10        swpb ry                         ;
6122 1E5C D80E  22        movb rx,@S                      ; STX S
     1E5E 0092     
6123               
6124 1E60 06CF  10        swpb ry                         ;
6125 1E62 D3AF  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; These instructions have no effect as MAD overwrites
     1E64 0053     
6126 1E66 06CF  10        swpb ry                         ;
6127 1E68 D80E  22        movb rx,@P                      ; STX P             ; X and P when called, but they set X = P = nosev_x_lo
     1E6A 001B     
6128               
6129 1E6C 06CF  10        swpb ry                         ;
6130 1E6E D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Set A = -nosev_x_hi
     1E70 0054     
6131 1E72 06CF  10        swpb ry                         ;
6132                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1E74 0200  12        li   rtmp,(>80*256)
     1E76 8000     
0002 1E78 2B40  14        xor  rtmp,ra
                   < elite.a99
6133               
6134 1E7A 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1E7C 485A     
6135 1E7E 06A0  24        bl   @jsr                       ;
     1E80 FE28     
6136 1E82 06CF  10        swpb ry                         ;
6137 1E84 DBCD  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = alpha * -nosev_x_hi + nosev_y
     1E86 0056     
6138 1E88 06CF  10        swpb ry                         ;
6139 1E8A DBCE  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1E8C 0055     
6140                                                                          ; and store (A X) in nosev_y, so this does:
6141                                                                          ;
6142                                                                          ; nosev_y = nosev_y - alpha * nosev_x_hi
6143               
6144 1E8E D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1E90 001B     
6145                                                                          ; but it sets P = nosev_y_lo
6146               
6147 1E92 06CF  10        swpb ry                         ;
6148 1E94 D3AF  26        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set (S R) = nosev_x
     1E96 0053     
6149 1E98 06CF  10        swpb ry                         ;
6150 1E9A D80E  22        movb rx,@R                      ; STX R
     1E9C 0091     
6151 1E9E 06CF  10        swpb ry                         ;
6152 1EA0 D3AF  26        movb @INWK+1(ry),rx             ; LDX INWK+1,Y
     1EA2 0054     
6153 1EA4 06CF  10        swpb ry                         ;
6154 1EA6 D80E  22        movb rx,@S                      ; STX S
     1EA8 0092     
6155               
6156 1EAA 06CF  10        swpb ry                         ;
6157 1EAC D36F  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1EAE 0056     
6158 1EB0 06CF  10        swpb ry                         ;
6159               
6160 1EB2 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1EB4 485A     
6161 1EB6 06A0  24        bl   @jsr                       ;
     1EB8 FE28     
6162 1EBA 06CF  10        swpb ry                         ;
6163 1EBC DBCD  30        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; = alpha * nosev_y_hi + nosev_x
     1EBE 0054     
6164 1EC0 06CF  10        swpb ry                         ;
6165 1EC2 DBCE  30        movb rx,@INWK(ry)               ; STX INWK,Y        ;
     1EC4 0053     
6166                                                                          ; and store (A X) in nosev_x, so this does:
6167                                                                          ;
6168                                                                          ; nosev_x = nosev_x + alpha * nosev_y_hi
6169               
6170 1EC6 D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1EC8 001B     
6171                                                                          ; but it sets P = nosev_x_lo
6172               
6173 1ECA D360  22        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta (the pitch angle to rotate through)
     1ECC 002A     
6174 1ECE D80D  22        movb ra,@Q                      ; STA Q
     1ED0 0090     
6175               
6176 1ED2 06CF  10        swpb ry                         ;
6177 1ED4 D3AF  26        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
     1ED6 0055     
6178 1ED8 06CF  10        swpb ry                         ;
6179 1EDA D80E  22        movb rx,@R                      ; STX R
     1EDC 0091     
6180 1EDE 06CF  10        swpb ry                         ;
6181 1EE0 D3AF  26        movb @INWK+3(ry),rx             ; LDX INWK+3,Y
     1EE2 0056     
6182 1EE4 06CF  10        swpb ry                         ;
6183 1EE6 D80E  22        movb rx,@S                      ; STX S
     1EE8 0092     
6184 1EEA 06CF  10        swpb ry                         ;
6185 1EEC D3AF  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y
     1EEE 0057     
6186 1EF0 06CF  10        swpb ry                         ;
6187               
6188 1EF2 D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1EF4 001B     
6189                                                                          ; but it sets P = nosev_y
6190               
6191 1EF6 06CF  10        swpb ry                         ;
6192 1EF8 D36F  26        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; Set A = -nosev_z_hi
     1EFA 0058     
6193 1EFC 06CF  10        swpb ry                         ;
6194                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 1EFE 0200  12        li   rtmp,(>80*256)
     1F00 8000     
0002 1F02 2B40  14        xor  rtmp,ra
                   < elite.a99
6195               
6196 1F04 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1F06 485A     
6197 1F08 06A0  24        bl   @jsr                       ;
     1F0A FE28     
6198 1F0C 06CF  10        swpb ry                         ;
6199 1F0E DBCD  30        movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = beta * -nosev_z_hi + nosev_y
     1F10 0056     
6200 1F12 06CF  10        swpb ry                         ;
6201 1F14 DBCE  30        movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ;
     1F16 0055     
6202                                                                          ; and store (A X) in nosev_y, so this does:
6203                                                                          ;
6204                                                                          ; nosev_y = nosev_y - beta * nosev_z_hi
6205               
6206 1F18 D80E  22        movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
     1F1A 001B     
6207                                                                          ; but it sets P = nosev_y_lo
6208               
6209 1F1C 06CF  10        swpb ry                         ;
6210 1F1E D3AF  26        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set (S R) = nosev_z
     1F20 0057     
6211 1F22 06CF  10        swpb ry                         ;
6212 1F24 D80E  22        movb rx,@R                      ; STX R
     1F26 0091     
6213 1F28 06CF  10        swpb ry                         ;
6214 1F2A D3AF  26        movb @INWK+5(ry),rx             ; LDX INWK+5,Y
     1F2C 0058     
6215 1F2E 06CF  10        swpb ry                         ;
6216 1F30 D80E  22        movb rx,@S                      ; STX S
     1F32 0092     
6217               
6218 1F34 06CF  10        swpb ry                         ;
6219 1F36 D36F  26        movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi
     1F38 0056     
6220 1F3A 06CF  10        swpb ry                         ;
6221               
6222 1F3C 0200  12        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     1F3E 485A     
6223 1F40 06A0  24        bl   @jsr                       ;
     1F42 FE28     
6224 1F44 06CF  10        swpb ry                         ;
6225 1F46 DBCD  30        movb ra,@INWK+5(ry)             ; STA INWK+5,Y      ; = beta * nosev_y_hi + nosev_z
     1F48 0058     
6226 1F4A 06CF  10        swpb ry                         ;
6227 1F4C DBCE  30        movb rx,@INWK+4(ry)             ; STX INWK+4,Y      ;
     1F4E 0057     
6228                                                                          ; and store (A X) in nosev_z, so this does:
6229                                                                          ;
6230                                                                          ; nosev_z = nosev_z + beta * nosev_y_hi
6231               
6232 1F50 0460  20        b    @rts                       ; RTS               ; Return from the subroutine
     1F52 FE34     
6233               
6234               * ******************************************************************************
6235               *
6236               * Name: MVS5
6237               * Type: Subroutine
6238               * Category: Moving
6239               * Summary: Apply a 3.6 degree pitch or roll to an orientation vector
6240               * Deep dive: Orientation vectors
6241               * Pitching and rolling by a fixed angle
6242               *
6243               * ------------------------------------------------------------------------------
6244               *
6245               * Pitch or roll a ship by a small, fixed amount (1/16 radians, or 3.6 degrees),
6246               * in a specified direction, by rotating the orientation vectors. The vectors to
6247               * rotate are given in X and Y, and the direction of the rotation is given in
6248               * RAT2. The calculation is as follows:
6249               *
6250               * * If the direction is positive:
6251               *
6252               * X = X * (1 - 1/512) + Y / 16
6253               * Y = Y * (1 - 1/512) - X / 16
6254               *
6255               * * If the direction is negative:
6256               *
6257               * X = X * (1 - 1/512) - Y / 16
6258               * Y = Y * (1 - 1/512) + X / 16
6259               *
6260               * So if X = 15 (roofv_x), Y = 21 (sidev_x) and RAT2 is positive, it does this:
6261               *
6262               * roofv_x = roofv_x * (1 - 1/512)  + sidev_x / 16
6263               * sidev_x = sidev_x * (1 - 1/512)  - roofv_x / 16
6264               *
6265               * ------------------------------------------------------------------------------
6266               *
6267               * Arguments:
6268               *
6269               * X                   The first vector to rotate:
6270               *
6271               * * If X = 15, rotate roofv_x
6272               *
6273               * * If X = 17, rotate roofv_y
6274               *
6275               * * If X = 19, rotate roofv_z
6276               *
6277               * * If X = 21, rotate sidev_x
6278               *
6279               * * If X = 23, rotate sidev_y
6280               *
6281               * * If X = 25, rotate sidev_z
6282               *
6283               * Y                   The second vector to rotate:
6284               *
6285               * * If Y = 9,  rotate nosev_x
6286               *
6287               * * If Y = 11, rotate nosev_y
6288               *
6289               * * If Y = 13, rotate nosev_z
6290               *
6291               * * If Y = 21, rotate sidev_x
6292               *
6293               * * If Y = 23, rotate sidev_y
6294               *
6295               * * If Y = 25, rotate sidev_z
6296               *
6297               * RAT2                The direction of the pitch or roll to perform, positive
6298               * or negative (i.e. the sign of the roll or pitch counter
6299               * in bit 7)
6300               *
6301               * ******************************************************************************
6302               
6303               MVS5:
6304 1F54 06CE  10        swpb rx                         ;
6305 1F56 D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi, clear the sign bit, divide by 2 and
     1F58 0054     
6306 1F5A 06CE  10        swpb rx                         ;
6307 1F5C 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     1F5E 7F00     
6308 1F60 091D  14        srl  ra,1                       ; LSR A             ;
6309 1F62 D80D  22        movb ra,@T                      ; STA T             ; T = |roofv_x_hi| / 2
     1F64 00D1     
6310                                                                          ; = |roofv_x| / 512
6311                                                                          ;
6312                                                                          ; The above is true because:
6313                                                                          ;
6314                                                                          ; |roofv_x| = |roofv_x_hi| * 256 + roofv_x_lo
6315                                                                          ;
6316                                                                          ; so:
6317                                                                          ;
6318                                                                          ; |roofv_x| / 512 = |roofv_x_hi| * 256 / 512
6319                                                                          ; + roofv_x_lo / 512
6320                                                                          ; = |roofv_x_hi| / 2
6321               
6322 1F66 06CE  10        swpb rx                         ;
6323 1F68 D36E  26        movb @INWK(rx),ra               ; LDA INWK,X        ; Now we do the following subtraction:
     1F6A 0053     
6324 1F6C 06CE  10        swpb rx                         ;
6325                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 1F6E 0A18  14        sla  rmone,1
                   < elite.a99
6326                      .sbc @T,ra                      ; SBC T             ; (S R) = (roofv_x_hi roofv_x_lo) - |roofv_x| / 512
     **** ****     > SBC
0001 1F70 1801  10        joc  !
0002 1F72 7347  14        sb   rone,ra
0003               !:
0004 1F74 7360  22        sb   @T,ra
     1F76 00D1     
                   < elite.a99
6327 1F78 D80D  22        movb ra,@R                      ; STA R             ; = (1 - 1/512) * roofv_x
     1F7A 0091     
6328                                                                          ;
6329                                                                          ; by doing the low bytes first
6330               
6331 1F7C 06CE  10        swpb rx                         ;
6332 1F7E D36E  26        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes (the high byte of the right
     1F80 0054     
6333 1F82 06CE  10        swpb rx                         ;
6334                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 1F84 1801  10        joc  !
0002 1F86 7347  14        sb   rone,ra
0003               !:
0004 1F88 022D  14        ai   ra,-(>00*256)
     1F8A 0000     
                   < elite.a99
6335 1F8C D80D  22        movb ra,@S                      ; STA S
     1F8E 0092     
6336               
6337 1F90 06CF  10        swpb ry                         ;
6338 1F92 D36F  26        movb @INWK(ry),ra               ; LDA INWK,Y        ; Set P = nosev_x_lo
     1F94 0053     
6339 1F96 06CF  10        swpb ry                         ;
6340 1F98 D80D  22        movb ra,@P                      ; STA P
     1F9A 001B     
6341               
6342 1F9C 06CF  10        swpb ry                         ;
6343 1F9E D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch the sign of nosev_x_hi (bit 7) and store in T
     1FA0 0054     
6344 1FA2 06CF  10        swpb ry                         ;
6345 1FA4 024D  14        andi ra,>80*256                 ; AND #%10000000
     1FA6 8000     
6346 1FA8 D80D  22        movb ra,@T                      ; STA T
     1FAA 00D1     
6347               
6348 1FAC 06CF  10        swpb ry                         ;
6349 1FAE D36F  26        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi into A and clear the sign bit, so
     1FB0 0054     
6350 1FB2 06CF  10        swpb ry                         ;
6351 1FB4 024D  14        andi ra,>7f*256                 ; AND #%01111111    ; A = |nosev_x_hi|
     1FB6 7F00     
6352               
6353 1FB8 091D  14        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6354 1FBA 0204  12        li   rarg1,P                    ; ROR P             ; = |nosev_x_hi nosev_x_lo| / 16
     1FBC 001B     
6355 1FBE 06A0  24        bl   @ror                       ;
     1FC0 FE7A     
6356 1FC2 091D  14        srl  ra,1                       ; LSR A             ; = |nosev_x| / 16
6357 1FC4 0204  12        li   rarg1,P                    ; ROR P
     1FC6 001B     
6358 1FC8 06A0  24        bl   @ror                       ;
     1FCA FE7A     
6359 1FCC 091D  14        srl  ra,1                       ; LSR A
6360 1FCE 0204  12        li   rarg1,P                    ; ROR P
     1FD0 001B     
6361 1FD2 06A0  24        bl   @ror                       ;
     1FD4 FE7A     
6362 1FD6 091D  14        srl  ra,1                       ; LSR A
6363 1FD8 0204  12        li   rarg1,P                    ; ROR P
     1FDA 001B     
6364 1FDC 06A0  24        bl   @ror                       ;
     1FDE FE7A     
6365               
6366 1FE0 F360  22        socb @T,ra                      ; ORA T             ; Set the sign of A to the sign in T (i.e. the sign of
     1FE2 00D1     
6367                                                                          ; the original nosev_x), so now:
6368                                                                          ;
6369                                                                          ; (A P) = nosev_x / 16
6370               
6371                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 1FE4 D020  22        movb @RAT2,rtmp
     1FE6 00AB     
0002 1FE8 2B40  14        xor  rtmp,ra
                   < elite.a99
6372                                                                          ; by the pitch or roll direction
6373               
6374 1FEA D80E  22        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     1FEC 0090     
6375                                                                          ; call to ADD
6376               
6377 1FEE 0200  12        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     1FF0 4862     
6378 1FF2 06A0  24        bl   @jsr                       ;
     1FF4 FE28     
6379                                                                          ; = +/-nosev_x / 16 + (1 - 1/512) * roofv_x
6380               
6381 1FF6 D80D  22        movb ra,@K+1                    ; STA K+1           ; Set K(1 0) = (1 - 1/512) * roofv_x +/- nosev_x / 16
     1FF8 003E     
6382 1FFA D80E  22        movb rx,@K                      ; STX K
     1FFC 003D     
6383               
6384 1FFE D3A0  22        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     2000 0090     
6385               
6386 2002 06CF  14        swpb ry                         ;
6387 2004 D36F  34        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi, clear the sign bit, divide by 2 and
     2006 0054     
6388 2008 06CF  14        swpb ry                         ;
6389 200A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
     200C 7F00     
6390 200E 091D  18        srl  ra,1                       ; LSR A             ;
6391 2010 D80D  30        movb ra,@T                      ; STA T             ; T = |nosev_x_hi| / 2
     2012 00D1     
6392                                                                          ; = |nosev_x| / 512
6393               
6394 2014 06CF  14        swpb ry                         ;
6395 2016 D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Now we do the following subtraction:
     2018 0053     
6396 201A 06CF  14        swpb ry                         ;
6397                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 201C 0A18  18        sla  rmone,1
                   < elite.a99
6398                      .sbc @T,ra                      ; SBC T             ; (S R) = (nosev_x_hi nosev_x_lo) - |nosev_x| / 512
     **** ****     > SBC
0001 201E 1801  14        joc  !
0002 2020 7347  18        sb   rone,ra
0003               !:
0004 2022 7360  30        sb   @T,ra
     2024 00D1     
                   < elite.a99
6399 2026 D80D  30        movb ra,@R                      ; STA R             ; = (1 - 1/512) * nosev_x
     2028 0091     
6400                                                                          ;
6401                                                                          ; by doing the low bytes first
6402               
6403 202A 06CF  14        swpb ry                         ;
6404 202C D36F  34        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; And then the high bytes (the high byte of the right
     202E 0054     
6405 2030 06CF  14        swpb ry                         ;
6406                      .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
     **** ****     > SBI
0001 2032 1801  14        joc  !
0002 2034 7347  18        sb   rone,ra
0003               !:
0004 2036 022D  22        ai   ra,-(>00*256)
     2038 0000     
                   < elite.a99
6407 203A D80D  30        movb ra,@S                      ; STA S
     203C 0092     
6408               
6409 203E 06CE  14        swpb rx                         ;
6410 2040 D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = roofv_x_lo
     2042 0053     
6411 2044 06CE  14        swpb rx                         ;
6412 2046 D80D  30        movb ra,@P                      ; STA P
     2048 001B     
6413               
6414 204A 06CE  14        swpb rx                         ;
6415 204C D36E  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch the sign of roofv_x_hi (bit 7) and store in T
     204E 0054     
6416 2050 06CE  14        swpb rx                         ;
6417 2052 024D  22        andi ra,>80*256                 ; AND #%10000000
     2054 8000     
6418 2056 D80D  30        movb ra,@T                      ; STA T
     2058 00D1     
6419               
6420 205A 06CE  14        swpb rx                         ;
6421 205C D36E  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi into A and clear the sign bit, so
     205E 0054     
6422 2060 06CE  14        swpb rx                         ;
6423 2062 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; A = |roofv_x_hi|
     2064 7F00     
6424               
6425 2066 091D  18        srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
6426 2068 0204  20        li   rarg1,P                    ; ROR P             ; = |roofv_x_hi roofv_x_lo| / 16
     206A 001B     
6427 206C 06A0  32        bl   @ror                       ;
     206E FE7A     
6428 2070 091D  18        srl  ra,1                       ; LSR A             ; = |roofv_x| / 16
6429 2072 0204  20        li   rarg1,P                    ; ROR P
     2074 001B     
6430 2076 06A0  32        bl   @ror                       ;
     2078 FE7A     
6431 207A 091D  18        srl  ra,1                       ; LSR A
6432 207C 0204  20        li   rarg1,P                    ; ROR P
     207E 001B     
6433 2080 06A0  32        bl   @ror                       ;
     2082 FE7A     
6434 2084 091D  18        srl  ra,1                       ; LSR A
6435 2086 0204  20        li   rarg1,P                    ; ROR P
     2088 001B     
6436 208A 06A0  32        bl   @ror                       ;
     208C FE7A     
6437               
6438 208E F360  30        socb @T,ra                      ; ORA T             ; Set the sign of A to the opposite sign to T (i.e. the
     2090 00D1     
6439                      .eoi (>80*256)                  ; EOR #%10000000    ; sign of the original -roofv_x), so now:
     **** ****     > EOI
0001 2092 0200  20        li   rtmp,(>80*256)
     2094 8000     
0002 2096 2B40  18        xor  rtmp,ra
                   < elite.a99
6440                                                                          ;
6441                                                                          ; (A P) = -roofv_x / 16
6442               
6443                      .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
     **** ****     > EOR
0001 2098 D020  30        movb @RAT2,rtmp
     209A 00AB     
0002 209C 2B40  18        xor  rtmp,ra
                   < elite.a99
6444                                                                          ; by the pitch or roll direction
6445               
6446 209E D80E  30        movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
     20A0 0090     
6447                                                                          ; call to ADD
6448               
6449 20A2 0200  20        li   rtmp,ADD                   ; JSR ADD           ; (A X) = (A P) + (S R)
     20A4 4862     
6450 20A6 06A0  32        bl   @jsr                       ;
     20A8 FE28     
6451                                                                          ; = -/+roofv_x / 16 + (1 - 1/512) * nosev_x
6452               
6453 20AA 06CF  14        swpb ry                         ;
6454 20AC DBCD  38        movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; Set nosev_x = (1-1/512) * nosev_x -/+ roofv_x / 16
     20AE 0054     
6455 20B0 06CF  14        swpb ry                         ;
6456 20B2 DBCE  38        movb rx,@INWK(ry)               ; STX INWK,Y
     20B4 0053     
6457               
6458 20B6 D3A0  30        movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD
     20B8 0090     
6459               
6460 20BA D360  30        movb @K,ra                      ; LDA K             ; Set roofv_x = K(1 0)
     20BC 003D     
6461 20BE 06CE  14        swpb rx                         ;
6462 20C0 DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X        ; = (1-1/512) * roofv_x +/- nosev_x / 16
     20C2 0053     
6463 20C4 06CE  14        swpb rx                         ;
6464 20C6 D360  30        movb @K+1,ra                    ; LDA K+1
     20C8 003E     
6465 20CA 06CE  14        swpb rx                         ;
6466 20CC DB8D  38        movb ra,@INWK+1(rx)             ; STA INWK+1,X
     20CE 0054     
6467 20D0 06CE  14        swpb rx                         ;
6468               
6469 20D2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     20D4 FE34     
6470               
6471               * ******************************************************************************
6472               *
6473               * Name: MVT6
6474               * Type: Subroutine
6475               * Category: Moving
6476               * Summary: Calculate (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6477               *
6478               * ------------------------------------------------------------------------------
6479               *
6480               * Do the following calculation, for the coordinate given by X (so this is what
6481               * it does for the x-coordinate):
6482               *
6483               * (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
6484               *
6485               * A is a sign bit and is not included in the calculation, but bits 0-6 of A are
6486               * preserved. Bit 7 is set to the sign of the result.
6487               *
6488               * ------------------------------------------------------------------------------
6489               *
6490               * Arguments:
6491               *
6492               * A                   The sign of P(2 1) in bit 7
6493               *
6494               * P(2 1)              The 16-bit value we want to add the coordinate to
6495               *
6496               * X                   The coordinate to add, as follows:
6497               *
6498               * * If X = 0, add to (x_sign x_hi x_lo)
6499               *
6500               * * If X = 3, add to (y_sign y_hi y_lo)
6501               *
6502               * * If X = 6, add to (z_sign z_hi z_lo)
6503               *
6504               * ------------------------------------------------------------------------------
6505               *
6506               * Returns:
6507               *
6508               * A                   The sign of the result (in bit 7)
6509               *
6510               * ******************************************************************************
6511               
6512               MVT6:
6513 20D6 D3CD  18        movb ra,ry                      ; TAY               ; Store argument A into Y, for later use
6514               
6515 20D8 06CE  14        swpb rx                         ;
6516                      .eor @INWK+2(rx)                ; EOR INWK+2,X      ; Set A = A EOR x_sign
     **** ****     > EOR
0001 20DA D02E  34        movb @INWK+2(RX),rtmp
     20DC 0055     
0002 20DE 2B40  18        xor  rtmp,ra
                   < elite.a99
6517 20E0 06CE  14        swpb rx                         ;
6518               
6519 20E2 1118  14        jlt  MV50                       ; BMI MV50          ; If the sign is negative, i.e. A and x_sign have
6520                                                                          ; different signs, jump to MV50
6521               
6522                                                                          ; The signs are the same, so we can add the two
6523                                                                          ; arguments and keep the sign to get the result
6524               
6525 20E4 D360  30        movb @P+1,ra                    ; LDA P+1           ; First we add the low bytes:
     20E6 001C     
6526                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 20E8 0A16  18        sla  rzero,1
                   < elite.a99
6527 20EA 06CE  14        swpb rx                         ;
6528                      .adc @INWK(rx),ra               ; ADC INWK,X        ; P+1 = P+1 + x_lo
     **** ****     > ADC
0001 20EC 1701  14        jnc  !
0002 20EE B347  18        ab   rone,ra
0003               !:
0004 20F0 B36E  34        ab   @INWK(RX),ra
     20F2 0053     
                   < elite.a99
6529 20F4 06CE  14        swpb rx                         ;
6530 20F6 D80D  30        movb ra,@P+1                    ; STA P+1
     20F8 001C     
6531               
6532 20FA D360  30        movb @P+2,ra                    ; LDA P+2           ; And then the high bytes:
     20FC 001D     
6533 20FE 06CE  14        swpb rx                         ;
6534                      .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ;
     **** ****     > ADC
0001 2100 1701  14        jnc  !
0002 2102 B347  18        ab   rone,ra
0003               !:
0004 2104 B36E  34        ab   @INWK+1(RX),ra
     2106 0054     
                   < elite.a99
6535 2108 06CE  14        swpb rx                         ;
6536 210A D80D  30        movb ra,@P+2                    ; STA P+2           ; P+2 = P+2 + x_hi
     210C 001D     
6537               
6538 210E D34F  18        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6539                                                                          ; so that we keep the original sign
6540               
6541 2110 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2112 FE34     
6542               
6543               MV50:
6544 2114 06CE  14        swpb rx                         ;
6545 2116 D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes:
     2118 0053     
6546 211A 06CE  14        swpb rx                         ;
6547                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 211C 0A18  18        sla  rmone,1
                   < elite.a99
6548                      .sbc @P+1,ra                    ; SBC P+1           ; P+1 = x_lo - P+1
     **** ****     > SBC
0001 211E 1801  14        joc  !
0002 2120 7347  18        sb   rone,ra
0003               !:
0004 2122 7360  30        sb   @P+1,ra
     2124 001C     
                   < elite.a99
6549 2126 D80D  30        movb ra,@P+1                    ; STA P+1
     2128 001C     
6550               
6551 212A 06CE  14        swpb rx                         ;
6552 212C D36E  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes:
     212E 0054     
6553 2130 06CE  14        swpb rx                         ;
6554                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 2132 1801  14        joc  !
0002 2134 7347  18        sb   rone,ra
0003               !:
0004 2136 7360  30        sb   @P+2,ra
     2138 001D     
                   < elite.a99
6555 213A D80D  30        movb ra,@P+2                    ; STA P+2           ; P+2 = x_hi - P+2
     213C 001D     
6556               
6557 213E 1706  14        jnc  MV51                       ; BCC MV51          ; If the last subtraction underflowed, then the C flag
6558                                                                          ; will be clear and x_hi < P+2, so jump to MV51 to
6559                                                                          ; negate the result
6560               
6561 2140 D34F  18        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6562                      .eoi (>80*256)                  ; EOR #%10000000    ; but flip bit 7, which flips the sign. We do this
     **** ****     > EOI
0001 2142 0200  20        li   rtmp,(>80*256)
     2144 8000     
0002 2146 2B40  18        xor  rtmp,ra
                   < elite.a99
6563                                                                          ; because x_hi >= P+2 so we want the result to have the
6564                                                                          ; same sign as x_hi (as it's the dominant side in this
6565                                                                          ; calculation). The sign of x_hi is x_sign, and x_sign
6566                                                                          ; has the opposite sign to A, so we flip the sign in A
6567                                                                          ; to return the correct result
6568               
6569 2148 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     214A FE34     
6570               
6571               MV51:
6572 214C 020D  20        li   ra,>01*256                 ; LDA #1            ; Our subtraction underflowed, so we negate the result
     214E 0100     
6573                      .sbc @P+1,ra                    ; SBC P+1           ; using two's complement, first with the low byte:
     **** ****     > SBC
0001 2150 1801  14        joc  !
0002 2152 7347  18        sb   rone,ra
0003               !:
0004 2154 7360  30        sb   @P+1,ra
     2156 001C     
                   < elite.a99
6574 2158 D80D  30        movb ra,@P+1                    ; STA P+1           ;
     215A 001C     
6575                                                                          ; P+1 = 1 - P+1
6576               
6577 215C 020D  20        li   ra,>00*256                 ; LDA #0            ; And then the high byte:
     215E 0000     
6578                      .sbc @P+2,ra                    ; SBC P+2           ;
     **** ****     > SBC
0001 2160 1801  14        joc  !
0002 2162 7347  18        sb   rone,ra
0003               !:
0004 2164 7360  30        sb   @P+2,ra
     2166 001D     
                   < elite.a99
6579 2168 D80D  30        movb ra,@P+2                    ; STA P+2           ; P+2 = 0 - P+2
     216A 001D     
6580               
6581 216C D34F  18        movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
6582                                                                          ; as this is the correct sign for the result. This is
6583                                                                          ; because x_hi < P+2, so we want to return the same sign
6584                                                                          ; as P+2, the dominant side
6585               
6586 216E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2170 FE34     
6587               
6588               * ******************************************************************************
6589               *
6590               * Name: MV40
6591               * Type: Subroutine
6592               * Category: Moving
6593               * Summary: Rotate the planet or sun's location in space by the amount of
6594               * pitch and roll of our ship
6595               * Deep dive: Rotating the universe
6596               *
6597               * ------------------------------------------------------------------------------
6598               *
6599               * We implement this using the same equations as in part 5 of MVEIT, where we
6600               * rotated the current ship's location by our pitch and roll. Specifically, the
6601               * calculation is as follows:
6602               *
6603               * 1. K2 = y - alpha * x
6604               * 2. z = z + beta * K2
6605               * 3. y = K2 - beta * z
6606               * 4. x = x + alpha * y
6607               *
6608               * See the deep dive on "Rotating the universe" for more details on the above.
6609               *
6610               * ******************************************************************************
6611               
6612               MV40:
6613 2172 D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = -ALPHA, so Q contains the angle we want to
     2174 009E     
6614                      .eoi (>80*256)                  ; EOR #%10000000    ; roll the planet through (i.e. in the opposite
     **** ****     > EOI
0001 2176 0200  20        li   rtmp,(>80*256)
     2178 8000     
0002 217A 2B40  18        xor  rtmp,ra
                   < elite.a99
6615 217C D80D  30        movb ra,@Q                      ; STA Q             ; direction to our ship's roll angle alpha)
     217E 0090     
6616               
6617 2180 D360  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     2182 0053     
6618 2184 D80D  30        movb ra,@P                      ; STA P
     2186 001B     
6619 2188 D360  30        movb @INWK+1,ra                 ; LDA INWK+1
     218A 0054     
6620 218C D80D  30        movb ra,@P+1                    ; STA P+1
     218E 001C     
6621               
6622 2190 D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     2192 0055     
6623               
6624 2194 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     2196 44DC     
6625 2198 06A0  32        bl   @jsr                       ;
     219A FE28     
6626                                                                          ;
6627                                                                          ; which also means:
6628                                                                          ;
6629                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6630                                                                          ; = x * -alpha / 256
6631                                                                          ; = - alpha * x / 256
6632               
6633 219C 020E  20        li   rx,>03*256                 ; LDX #3            ; Set K(3 2 1) = (y_sign y_hi y_lo) + K(3 2 1)
     219E 0300     
6634 21A0 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; = y - alpha * x / 256
     21A2 1D44     
6635 21A4 06A0  32        bl   @jsr                       ;
     21A6 FE28     
6636               
6637 21A8 D360  30        movb @K+1,ra                    ; LDA K+1           ; Set K2(2 1) = P(1 0) = K(2 1)
     21AA 003E     
6638 21AC D80D  30        movb ra,@K2+1                   ; STA K2+1
     21AE 00AD     
6639 21B0 D80D  30        movb ra,@P                      ; STA P
     21B2 001B     
6640               
6641 21B4 D360  30        movb @K+2,ra                    ; LDA K+2           ; Set K2+2 = K+2
     21B6 003F     
6642 21B8 D80D  30        movb ra,@K2+2                   ; STA K2+2
     21BA 00AE     
6643               
6644 21BC D80D  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = K+2
     21BE 001C     
6645               
6646 21C0 D360  30        movb @BETA,ra                   ; LDA BETA          ; Set Q = beta, the pitch angle of our ship
     21C2 002A     
6647 21C4 D80D  30        movb ra,@Q                      ; STA Q
     21C6 0090     
6648               
6649 21C8 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to K2+3, so now we have result 1 above:
     21CA 0040     
6650 21CC D80D  30        movb ra,@K2+3                   ; STA K2+3          ;
     21CE 00AF     
6651                                                                          ; K2(3 2 1) = K(3 2 1)
6652                                                                          ; = y - alpha * x / 256
6653               
6654                                                                          ; We also have:
6655                                                                          ;
6656                                                                          ; A = K+3
6657                                                                          ;
6658                                                                          ; P(1 0) = K(2 1)
6659                                                                          ;
6660                                                                          ; so combined, these mean:
6661                                                                          ;
6662                                                                          ; (A P+1 P) = K(3 2 1)
6663                                                                          ; = K2(3 2 1)
6664               
6665 21D0 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     21D2 44DC     
6666 21D4 06A0  32        bl   @jsr                       ;
     21D6 FE28     
6667                                                                          ;
6668                                                                          ; which also means:
6669                                                                          ;
6670                                                                          ; K(3 2 1) = (A P+1 P) * Q / 256
6671                                                                          ; = K2(3 2 1) * beta / 256
6672                                                                          ; = beta * K2 / 256
6673               
6674 21D8 020E  20        li   rx,>06*256                 ; LDX #6            ; K(3 2 1) = (z_sign z_hi z_lo) + K(3 2 1)
     21DA 0600     
6675 21DC 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; = z + beta * K2 / 256
     21DE 1D44     
6676 21E0 06A0  32        bl   @jsr                       ;
     21E2 FE28     
6677               
6678 21E4 D360  30        movb @K+1,ra                    ; LDA K+1           ; Set P = K+1
     21E6 003E     
6679 21E8 D80D  30        movb ra,@P                      ; STA P
     21EA 001B     
6680               
6681 21EC D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; Set z_lo = K+1
     21EE 0059     
6682               
6683 21F0 D360  30        movb @K+2,ra                    ; LDA K+2           ; Set P+1 = K+2
     21F2 003F     
6684 21F4 D80D  30        movb ra,@P+1                    ; STA P+1
     21F6 001C     
6685               
6686 21F8 D80D  30        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi = K+2
     21FA 005A     
6687               
6688 21FC D360  30        movb @K+3,ra                    ; LDA K+3           ; Set A = z_sign = K+3, so now we have:
     21FE 0040     
6689 2200 D80D  30        movb ra,@INWK+8                 ; STA INWK+8        ;
     2202 005B     
6690                                                                          ; (z_sign z_hi z_lo) = K(3 2 1)
6691                                                                          ; = z + beta * K2 / 256
6692               
6693                                                                          ; So we now have result 2 above:
6694                                                                          ;
6695                                                                          ; z = z + beta * K2
6696               
6697                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit of A to give A = -z_sign
     **** ****     > EOI
0001 2204 0200  20        li   rtmp,(>80*256)
     2206 8000     
0002 2208 2B40  18        xor  rtmp,ra
                   < elite.a99
6698               
6699 220A 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     220C 44DC     
6700 220E 06A0  32        bl   @jsr                       ;
     2210 FE28     
6701                                                                          ; = (-z_sign z_hi z_lo) * beta
6702                                                                          ; = -z * beta
6703               
6704 2212 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set T to the sign bit of K(3 2 1 0), i.e. to the sign
     2214 0040     
6705 2216 024D  22        andi ra,>80*256                 ; AND #%10000000    ; bit of -z * beta
     2218 8000     
6706 221A D80D  30        movb ra,@T                      ; STA T
     221C 00D1     
6707               
6708                      .eor @K2+3                      ; EOR K2+3          ; If K2(3 2 1 0) has a different sign to K(3 2 1 0),
     **** ****     > EOR
0001 221E D020  30        movb @K2+3,rtmp
     2220 00AF     
0002 2222 2B40  18        xor  rtmp,ra
                   < elite.a99
6709 2224 111E  14        jlt  MV1                        ; BMI MV1           ; then EOR'ing them will produce a 1 in bit 7, so jump
6710                                                                          ; to MV1 to take this into account
6711               
6712                                                                          ; If we get here, K and K2 have the same sign, so we can
6713                                                                          ; add them together to get the result we're after, and
6714                                                                          ; then set the sign afterwards
6715               
6716 2226 D360  30        movb @K,ra                      ; LDA K             ; We now do the following sum:
     2228 003D     
6717               * CLC                    \
6718                      .adc @K2,ra                     ; ADC K2            ; (A y_hi y_lo -) = K(3 2 1 0) + K2(3 2 1 0)
     **** ****     > ADC
0001 222A 1701  14        jnc  !
0002 222C B347  18        ab   rone,ra
0003               !:
0004 222E B360  30        ab   @K2,ra
     2230 00AC     
                   < elite.a99
6719                                                                          ;
6720                                                                          ; starting with the low bytes (which we don't keep)
6721                                                                          ;
6722                                                                          ; The CLC instruction is commented out in the original
6723                                                                          ; source. It isn't needed because MULT3 clears the C
6724                                                                          ; flag, so this is an example of the authors finding
6725                                                                          ; one more precious byte to save
6726               
6727 2232 D360  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     2234 003E     
6728                      .adc @K2+1,ra                   ; ADC K2+1
     **** ****     > ADC
0001 2236 1701  14        jnc  !
0002 2238 B347  18        ab   rone,ra
0003               !:
0004 223A B360  30        ab   @K2+1,ra
     223C 00AD     
                   < elite.a99
6729 223E D80D  30        movb ra,@INWK+3                 ; STA INWK+3
     2240 0056     
6730               
6731 2242 D360  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     2244 003F     
6732                      .adc @K2+2,ra                   ; ADC K2+2
     **** ****     > ADC
0001 2246 1701  14        jnc  !
0002 2248 B347  18        ab   rone,ra
0003               !:
0004 224A B360  30        ab   @K2+2,ra
     224C 00AE     
                   < elite.a99
6733 224E D80D  30        movb ra,@INWK+4                 ; STA INWK+4
     2250 0057     
6734               
6735 2252 D360  30        movb @K+3,ra                    ; LDA K+3           ; And then the sign bytes into A, so overall we have the
     2254 0040     
6736                      .adc @K2+3,ra                   ; ADC K2+3          ; following, if we drop the low bytes from the result:
     **** ****     > ADC
0001 2256 1701  14        jnc  !
0002 2258 B347  18        ab   rone,ra
0003               !:
0004 225A B360  30        ab   @K2+3,ra
     225C 00AF     
                   < elite.a99
6737                                                                          ;
6738                                                                          ; (A y_hi y_lo) = (K + K2) / 256
6739               
6740 225E 0460  28        b    @MV2                       ; JMP MV2           ; Jump to MV2 to skip the calculation for when K and K2
     2260 22E2     
6741                                                                          ; have different signs
6742               
6743               MV1:
6744 2262 D360  30        movb @K,ra                      ; LDA K             ; If we get here then K2 and K have different signs, so
     2264 003D     
6745                      .sec                            ; SEC               ; instead of adding, we need to subtract to get the
     **** ****     > SEC
0001 2266 0A18  18        sla  rmone,1
                   < elite.a99
6746                      .sbc @K2,ra                     ; SBC K2            ; result we want, like this:
     **** ****     > SBC
0001 2268 1801  14        joc  !
0002 226A 7347  18        sb   rone,ra
0003               !:
0004 226C 7360  30        sb   @K2,ra
     226E 00AC     
                   < elite.a99
6747                                                                          ;
6748                                                                          ; (A y_hi y_lo -) = K(3 2 1 0) - K2(3 2 1 0)
6749                                                                          ;
6750                                                                          ; starting with the low bytes (which we don't keep)
6751               
6752 2270 D360  30        movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
     2272 003E     
6753                      .sbc @K2+1,ra                   ; SBC K2+1
     **** ****     > SBC
0001 2274 1801  14        joc  !
0002 2276 7347  18        sb   rone,ra
0003               !:
0004 2278 7360  30        sb   @K2+1,ra
     227A 00AD     
                   < elite.a99
6754 227C D80D  30        movb ra,@INWK+3                 ; STA INWK+3
     227E 0056     
6755               
6756 2280 D360  30        movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
     2282 003F     
6757                      .sbc @K2+2,ra                   ; SBC K2+2
     **** ****     > SBC
0001 2284 1801  14        joc  !
0002 2286 7347  18        sb   rone,ra
0003               !:
0004 2288 7360  30        sb   @K2+2,ra
     228A 00AE     
                   < elite.a99
6758 228C D80D  30        movb ra,@INWK+4                 ; STA INWK+4
     228E 0057     
6759               
6760 2290 D360  30        movb @K2+3,ra                   ; LDA K2+3          ; Now for the sign bytes, so first we extract the sign
     2292 00AF     
6761 2294 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; byte from K2 without the sign bit, so P = |K2+3|
     2296 7F00     
6762 2298 D80D  30        movb ra,@P                      ; STA P
     229A 001B     
6763               
6764 229C D360  30        movb @K+3,ra                    ; LDA K+3           ; And then we extract the sign byte from K without the
     229E 0040     
6765 22A0 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |K+3|
     22A2 7F00     
6766               
6767                      .sbc @P,ra                      ; SBC P             ; And finally we subtract the sign bytes, so P = A - P
     **** ****     > SBC
0001 22A4 1801  14        joc  !
0002 22A6 7347  18        sb   rone,ra
0003               !:
0004 22A8 7360  30        sb   @P,ra
     22AA 001B     
                   < elite.a99
6768 22AC D80D  30        movb ra,@P                      ; STA P
     22AE 001B     
6769               
6770                                                                          ; By now we have the following, if we drop the low bytes
6771                                                                          ; from the result:
6772                                                                          ;
6773                                                                          ; (A y_hi y_lo) = (K - K2) / 256
6774                                                                          ;
6775                                                                          ; so now we just need to make sure the sign of the
6776                                                                          ; result is correct
6777               
6778 22B0 1818  14        joc  MV2                        ; BCS MV2           ; If the C flag is set, then the last subtraction above
6779                                                                          ; didn't underflow and the result is correct, so jump to
6780                                                                          ; MV2 as we are done with this particular stage
6781               
6782 22B2 020D  20        li   ra,>01*256                 ; LDA #1            ; Otherwise the subtraction above underflowed, as K2 is
     22B4 0100     
6783                      .sbc @INWK+3,ra                 ; SBC INWK+3        ; the dominant part of the subtraction, so we need to
     **** ****     > SBC
0001 22B6 1801  14        joc  !
0002 22B8 7347  18        sb   rone,ra
0003               !:
0004 22BA 7360  30        sb   @INWK+3,ra
     22BC 0056     
                   < elite.a99
6784 22BE D80D  30        movb ra,@INWK+3                 ; STA INWK+3        ; negate the result using two's complement, starting
     22C0 0056     
6785                                                                          ; with the low bytes:
6786                                                                          ;
6787                                                                          ; y_lo = 1 - y_lo
6788               
6789 22C2 020D  20        li   ra,>00*256                 ; LDA #0            ; And then the high bytes:
     22C4 0000     
6790                      .sbc @INWK+4,ra                 ; SBC INWK+4        ;
     **** ****     > SBC
0001 22C6 1801  14        joc  !
0002 22C8 7347  18        sb   rone,ra
0003               !:
0004 22CA 7360  30        sb   @INWK+4,ra
     22CC 0057     
                   < elite.a99
6791 22CE D80D  30        movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi
     22D0 0057     
6792               
6793 22D2 020D  20        li   ra,>00*256                 ; LDA #0            ; And finally the sign bytes:
     22D4 0000     
6794                      .sbc @P,ra                      ; SBC P             ;
     **** ****     > SBC
0001 22D6 1801  14        joc  !
0002 22D8 7347  18        sb   rone,ra
0003               !:
0004 22DA 7360  30        sb   @P,ra
     22DC 001B     
                   < elite.a99
6795                                                                          ; A = 0 - P
6796               
6797 22DE 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now force the sign bit to be negative, so that the
     22E0 8000     
6798                                                                          ; final result below gets the opposite sign to K, which
6799                                                                          ; we want as K2 is the dominant part of the sum
6800               
6801               MV2:
6802                      .eor @T                         ; EOR T             ; T contains the sign bit of K, so if K is negative,
     **** ****     > EOR
0001 22E2 D020  30        movb @T,rtmp
     22E4 00D1     
0002 22E6 2B40  18        xor  rtmp,ra
                   < elite.a99
6803                                                                          ; this flips the sign of A
6804               
6805 22E8 D80D  30        movb ra,@INWK+5                 ; STA INWK+5        ; Store A in y_sign
     22EA 0058     
6806               
6807                                                                          ; So we now have result 3 above:
6808                                                                          ;
6809                                                                          ; y = K2 + K
6810                                                                          ; = K2 - beta * z
6811               
6812 22EC D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha
     22EE 009E     
6813 22F0 D80D  30        movb ra,@Q                      ; STA Q
     22F2 0090     
6814               
6815 22F4 D360  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     22F6 0056     
6816 22F8 D80D  30        movb ra,@P                      ; STA P
     22FA 001B     
6817 22FC D360  30        movb @INWK+4,ra                 ; LDA INWK+4
     22FE 0057     
6818 2300 D80D  30        movb ra,@P+1                    ; STA P+1
     2302 001C     
6819               
6820 2304 D360  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = y_sign
     2306 0058     
6821               
6822 2308 0200  20        li   rtmp,MULT3                 ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
     230A 44DC     
6823 230C 06A0  32        bl   @jsr                       ;
     230E FE28     
6824                                                                          ; = (y_sign y_hi y_lo) * alpha
6825                                                                          ; = y * alpha
6826               
6827 2310 020E  20        li   rx,>00*256                 ; LDX #0            ; Set K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
     2312 0000     
6828 2314 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; = x + y * alpha / 256
     2316 1D44     
6829 2318 06A0  32        bl   @jsr                       ;
     231A FE28     
6830               
6831 231C D360  30        movb @K+1,ra                    ; LDA K+1           ; Set (x_sign x_hi x_lo) = K(3 2 1)
     231E 003E     
6832 2320 D80D  30        movb ra,@INWK                   ; STA INWK          ; = x + y * alpha / 256
     2322 0053     
6833 2324 D360  30        movb @K+2,ra                    ; LDA K+2
     2326 003F     
6834 2328 D80D  30        movb ra,@INWK+1                 ; STA INWK+1
     232A 0054     
6835 232C D360  30        movb @K+3,ra                    ; LDA K+3
     232E 0040     
6836 2330 D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     2332 0055     
6837               
6838                                                                          ; So we now have result 4 above:
6839                                                                          ;
6840                                                                          ; x = x + y * alpha
6841               
6842 2334 0460  24        b    @MV45                      ; JMP MV45          ; We have now finished rotating the planet or sun by
     2336 1AEA     
6843                                                                          ; our pitch and roll, so jump back into the MVEIT
6844                                                                          ; routine at MV45 to apply all the other movements
6845               
6846               * ******************************************************************************
6847               *
6848               * Save ELTA.bin
6849               *
6850               * ******************************************************************************
6851               
6852                      ; PRINT "ELITE A"
6853                      ; PRINT "Assembled at ", ~CODE%
6854                      ; PRINT "Ends at ", ~P%
6855                      ; PRINT "Code size is ", ~(P% - CODE%)
6856                      ; PRINT "Execute at ", ~LOAD%
6857                      ; PRINT "Reload at ", ~LOAD_A%
6858               
6859                      ; PRINT "S.ELTA ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_A%
6860                      ; SAVE "3-assembled-output/ELTA.bin", CODE%, P%, LOAD%
6861               
6862               * ******************************************************************************
6863               *
6864               * ELITE B FILE
6865               *
6866               * Produces the binary file ELTB.bin that gets loaded by elite-bcfs.asm.
6867               *
6868               * ******************************************************************************
6869               
6870               CODE_B.:
6871                      equ $
6872               
6873               LOAD_B.:
6874                      equ LOAD. + $ - CODE.
6875               
6876               * ******************************************************************************
6877               *
6878               * Name: NA%
6879               * Type: Variable
6880               * Category: Save and load
6881               * Summary: The data block for the last saved commander
6882               * Deep dive: Commander save files
6883               * The competition code
6884               *
6885               * ------------------------------------------------------------------------------
6886               *
6887               * Contains the last saved commander data, with the name at NA% and the data at
6888               * NA%+8 onwards. The size of the data block is given in NT% (which also includes
6889               * the two checksum bytes that follow this block). This block is initially set up
6890               * with the default commander, which can be maxed out for testing purposes by
6891               * setting Q% to TRUE.
6892               *
6893               * The commander's name is stored at NA%, and can be up to 7 characters long
6894               * (the DFS filename limit). It is terminated with a carriage return character,
6895               * ASCII 13.
6896               *
6897               * The offset of each byte within a saved commander file is also shown as #0, #1
6898               * and so on, so the kill tally, for example, is in bytes #71 and #72 of the
6899               * saved file. The related variable name from the current commander block is
6900               * also shown.
6901               *
6902               * ******************************************************************************
6903               
6904               NA.:
6905 2338 4A41            text 'JAMESON'                                      ; The current commander name, which defaults to JAMESON
     233A 4D45     
     233C 534F     
     233E 4E       
6906 233F   0D            byte >0d                                            ;
6907                                                                          ; The commander name can be up to 7 characters (the DFS
6908                                                                          ; limit for filenames), and is terminated by a carriage
6909                                                                          ; return
6910               
6911                                                                          ; NA%+8 is the start of the commander data block
6912                                                                          ;
6913                                                                          ; This block contains the last saved commander data
6914                                                                          ; block. As the game is played it uses an identical
6915                                                                          ; block at location TP to store the current commander
6916                                                                          ; state, and that block is copied here when the game is
6917                                                                          ; saved. Conversely, when the game starts up, the block
6918                                                                          ; here is copied to TP, which restores the last saved
6919                                                                          ; commander when we die
6920                                                                          ;
6921                                                                          ; The initial state of this block defines the default
6922                                                                          ; commander. Q% can be set to TRUE to give the default
6923                                                                          ; commander lots of credits and equipment
6924               
6925 2340 00              byte >00                                            ; TP = Mission status, #0
6926               
6927 2341   14            byte >14                                            ; QQ0 = Current system X-coordinate (Lave), #1
6928 2342 AD              byte >ad                                            ; QQ1 = Current system Y-coordinate (Lave), #2
6929               
6930 2344 4A5A            data >4a5a                                          ; QQ21 = Seed s0 for system 0, galaxy 0 (Tibedied), #3-4
6931 2346 4802            data >4802                                          ; QQ21 = Seed s1 for system 0, galaxy 0 (Tibedied), #5-6
6932 2348 53B7            data >53b7                                          ; QQ21 = Seed s2 for system 0, galaxy 0 (Tibedied), #7-8
6933               
6937 234A 0000            data >0000, >0000                                   ; CASH = Amount of cash (100 Cr), #9-12
     234C 0000     
6939               
6940 234E 46              byte >46                                            ; QQ14 = Fuel level, #13
6941               
6942 234F   00            byte >00                                            ; COK = Competition flags, #14
6943               
6944 2350 00              byte >00                                            ; GCNT = Galaxy number, 0-7, #15
6945               
6946 2351   0F            byte POW+(128 & Q.)                                 ; LASER = Front laser, #16
6947               
6948 2352 00              byte (POW+128) & Q.                                 ; LASER+1 = Rear laser, #17
6949               
6950 2353   00            byte >00                                            ; LASER+2 = Left laser, #18
6951               
6952 2354 00              byte >00                                            ; LASER+3 = Right laser, #19
6953               
6954 2356 0000            data >0000                                          ; These bytes appear to be unused (they were originally
6955                                                                          ; used for up/down lasers, but they were dropped),
6956                                                                          ; #20-21
6957               
6958 2358 16              byte 22 + (15 & Q.)                                 ; CRGO = Cargo capacity, #22
6959               
6960 2359   00            byte >00                                            ; QQ20+0  = Amount of food in cargo hold, #23
6961 235A 00              byte >00                                            ; QQ20+1  = Amount of textiles in cargo hold, #24
6962 235B   00            byte >00                                            ; QQ20+2  = Amount of radioactives in cargo hold, #25
6963 235C 00              byte >00                                            ; QQ20+3  = Amount of slaves in cargo hold, #26
6964 235D   00            byte >00                                            ; QQ20+4  = Amount of liquor/Wines in cargo hold, #27
6965 235E 00              byte >00                                            ; QQ20+5  = Amount of luxuries in cargo hold, #28
6966 235F   00            byte >00                                            ; QQ20+6  = Amount of narcotics in cargo hold, #29
6967 2360 00              byte >00                                            ; QQ20+7  = Amount of computers in cargo hold, #30
6968 2361   00            byte >00                                            ; QQ20+8  = Amount of machinery in cargo hold, #31
6969 2362 00              byte >00                                            ; QQ20+9  = Amount of alloys in cargo hold, #32
6970 2363   00            byte >00                                            ; QQ20+10 = Amount of firearms in cargo hold, #33
6971 2364 00              byte >00                                            ; QQ20+11 = Amount of furs in cargo hold, #34
6972 2365   00            byte >00                                            ; QQ20+12 = Amount of minerals in cargo hold, #35
6973 2366 00              byte >00                                            ; QQ20+13 = Amount of gold in cargo hold, #36
6974 2367   00            byte >00                                            ; QQ20+14 = Amount of platinum in cargo hold, #37
6975 2368 00              byte >00                                            ; QQ20+15 = Amount of gem-stones in cargo hold, #38
6976 2369   00            byte >00                                            ; QQ20+16 = Amount of alien items in cargo hold, #39
6977               
6978 236A 00              byte Q.                                             ; ECM = E.C.M. system, #40
6979               
6980 236B   00            byte Q.                                             ; BST = Fuel scoops ("barrel status"), #41
6981               
6982 236C 00              byte Q. & 127                                       ; BOMB = Energy bomb, #42
6983               
6984 236D   00            byte Q. & 1                                         ; ENGY = Energy/shield level, #43
6985               
6986 236E 00              byte Q.                                             ; DKCMP = Docking computer, #44
6987               
6988 236F   00            byte Q.                                             ; GHYP = Galactic hyperdrive, #45
6989               
6990 2370 00              byte Q.                                             ; ESCP = Escape pod, #46
6991               
6992 2372 0000            data >0000, >0000                                   ; These four bytes appear to be unused, #47-50
     2374 0000     
6993               
6994 2376 03              byte 3 + (Q. & 1)                                   ; NOMSL = Number of missiles, #51
6995               
6996 2377   00            byte >00                                            ; FIST = Legal status ("fugitive/innocent status"), #52
6997               
6998 2378 10              byte >10                                            ; AVL+0  = Market availability of food, #53
6999 2379   0F            byte >0f                                            ; AVL+1  = Market availability of textiles, #54
7000 237A 11              byte >11                                            ; AVL+2  = Market availability of radioactives, #55
7001 237B   00            byte >00                                            ; AVL+3  = Market availability of slaves, #56
7002 237C 03              byte >03                                            ; AVL+4  = Market availability of liquor/Wines, #57
7003 237D   1C            byte >1c                                            ; AVL+5  = Market availability of luxuries, #58
7004 237E 0E              byte >0e                                            ; AVL+6  = Market availability of narcotics, #59
7005 237F   00            byte >00                                            ; AVL+7  = Market availability of computers, #60
7006 2380 00              byte >00                                            ; AVL+8  = Market availability of machinery, #61
7007 2381   0A            byte >0a                                            ; AVL+9  = Market availability of alloys, #62
7008 2382 00              byte >00                                            ; AVL+10 = Market availability of firearms, #63
7009 2383   11            byte >11                                            ; AVL+11 = Market availability of furs, #64
7010 2384 3A              byte >3a                                            ; AVL+12 = Market availability of minerals, #65
7011 2385   07            byte >07                                            ; AVL+13 = Market availability of gold, #66
7012 2386 09              byte >09                                            ; AVL+14 = Market availability of platinum, #67
7013 2387   08            byte >08                                            ; AVL+15 = Market availability of gem-stones, #68
7014 2388 00              byte >00                                            ; AVL+16 = Market availability of alien items, #69
7015               
7016 2389   00            byte >00                                            ; QQ26 = Random byte that changes for each visit to a
7017                                                                          ; system, for randomising market prices, #70
7018               
7019 238A 0000            data >0000                                          ; TALLY = Number of kills, #71-72
7020               
7021 238C 80              byte >80                                            ; SVC = Save count, #73
7022               
7023               * ******************************************************************************
7024               *
7025               * Name: CHK2
7026               * Type: Variable
7027               * Category: Save and load
7028               * Summary: Second checksum byte for the saved commander data file
7029               * Deep dive: Commander save files
7030               * The competition code
7031               *
7032               * ------------------------------------------------------------------------------
7033               *
7034               * Second commander checksum byte. If the default commander is changed, a new
7035               * checksum will be calculated and inserted by the elite-checksum.py script.
7036               *
7037               * The offset of this byte within a saved commander file is also shown (it's at
7038               * byte #74).
7039               *
7040               * ******************************************************************************
7041               
7042               CHK2:
7043 238D   AA            byte >03 ^ >A9                                      ; The checksum value for the default commander, EOR'd
7044                                                                          ; with &A9 to make it harder to tamper with the checksum
7045                                                                          ; byte, #74
7046               
7047               * ******************************************************************************
7048               *
7049               * Name: CHK
7050               * Type: Variable
7051               * Category: Save and load
7052               * Summary: First checksum byte for the saved commander data file
7053               * Deep dive: Commander save files
7054               * The competition code
7055               *
7056               * ------------------------------------------------------------------------------
7057               *
7058               * Commander checksum byte. If the default commander is changed, a new checksum
7059               * will be calculated and inserted by the elite-checksum.py script.
7060               *
7061               * The offset of this byte within a saved commander file is also shown (it's at
7062               * byte #75).
7063               *
7064               * ******************************************************************************
7065               
7066               CHK:
7067 238E 03              byte >03                                            ; The checksum value for the default commander, #75
7068               
7069               * ******************************************************************************
7070               *
7071               * Name: UNIV
7072               * Type: Variable
7073               * Category: Universe
7074               * Summary: Table of pointers to the local universe's ship data blocks
7075               * Deep dive: The local bubble of universe
7076               *
7077               * ------------------------------------------------------------------------------
7078               *
7079               * See the deep dive on "Ship data blocks" for details on ship data blocks, and
7080               * the deep dive on "The local bubble of universe" for details of how Elite
7081               * stores the local universe in K%, FRIN and UNIV.
7082               *
7083               * ******************************************************************************
7084               
7085               UNIV:
7086                      ; FOR I%, 0, NOSH
7087               
7088                      ; EQUW K% + I% * NI%            ;                   ; Address of block no. I%, of size NI%, in workspace K%
7089               
7090                      ; NEXT
7091               
7092 238F   00            byte (K. + 0 * NI.) % 256, (K. + 0 * NI.) / 256
     2390 44       
7093 2391   24            byte (K. + 1 * NI.) % 256, (K. + 1 * NI.) / 256
     2392 44       
7094 2393   48            byte (K. + 2 * NI.) % 256, (K. + 2 * NI.) / 256
     2394 44       
7095 2395   6C            byte (K. + 3 * NI.) % 256, (K. + 3 * NI.) / 256
     2396 44       
7096 2397   90            byte (K. + 4 * NI.) % 256, (K. + 4 * NI.) / 256
     2398 44       
7097 2399   B4            byte (K. + 5 * NI.) % 256, (K. + 5 * NI.) / 256
     239A 44       
7098 239B   D8            byte (K. + 6 * NI.) % 256, (K. + 6 * NI.) / 256
     239C 44       
7099 239D   FC            byte (K. + 7 * NI.) % 256, (K. + 7 * NI.) / 256
     239E 44       
7100 239F   20            byte (K. + 8 * NI.) % 256, (K. + 8 * NI.) / 256
     23A0 45       
7101 23A1   44            byte (K. + 9 * NI.) % 256, (K. + 9 * NI.) / 256
     23A2 45       
7102 23A3   68            byte (K. + 10 * NI.) % 256, (K. + 10 * NI.) / 256
     23A4 45       
7103 23A5   8C            byte (K. + 11 * NI.) % 256, (K. + 11 * NI.) / 256
     23A6 45       
7104 23A7   B0            byte (K. + 12 * NI.) % 256, (K. + 12 * NI.) / 256
     23A8 45       
7105               
7106               * ******************************************************************************
7107               *
7108               * Name: TWOS
7109               * Type: Variable
7110               * Category: Drawing pixels
7111               * Summary: Ready-made single-pixel character row bytes for mode 4
7112               * Deep dive: Drawing monochrome pixels in mode 4
7113               *
7114               * ------------------------------------------------------------------------------
7115               *
7116               * Ready-made bytes for plotting one-pixel points in mode 4 (the top part of the
7117               * split screen). See the PIXEL routine for details.
7118               *
7119               * ******************************************************************************
7120               
7121               TWOS:
7122 23A9   80            byte >80
7123 23AA 40              byte >40
7124 23AB   20            byte >20
7125 23AC 10              byte >10
7126 23AD   08            byte >08
7127 23AE 04              byte >04
7128 23AF   02            byte >02
7129 23B0 01              byte >01
7130               
7131               * ******************************************************************************
7132               *
7133               * Name: TWOS2
7134               * Type: Variable
7135               * Category: Drawing pixels
7136               * Summary: Ready-made double-pixel character row bytes for mode 4
7137               * Deep dive: Drawing monochrome pixels in mode 4
7138               *
7139               * ------------------------------------------------------------------------------
7140               *
7141               * Ready-made bytes for plotting two-pixel dashes in mode 4 (the top part of the
7142               * split screen). See the PIXEL routine for details.
7143               *
7144               * ******************************************************************************
7145               
7146               TWOS2:
7147 23B1   C0            byte >c0
7148 23B2 60              byte >60
7149 23B3   30            byte >30
7150 23B4 18              byte >18
7151 23B5   0C            byte >0c
7152 23B6 06              byte >06
7153 23B7   03            byte >03
7154 23B8 03              byte >03
7155               
7156               * ******************************************************************************
7157               *
7158               * Name: CTWOS
7159               * Type: Variable
7160               * Category: Drawing pixels
7161               * Summary: Ready-made single-pixel character row bytes for mode 5
7162               * Deep dive: Drawing colour pixels in mode 5
7163               *
7164               * ------------------------------------------------------------------------------
7165               *
7166               * Ready-made bytes for plotting one-pixel points in mode 5 (the bottom part of
7167               * the split screen). See the dashboard routines SCAN, DIL2 and CPIX2 for
7168               * details.
7169               *
7170               * There is one extra row to support the use of CTWOS+1,X indexing in the CPIX2
7171               * routine. The extra row is a repeat of the first row, and saves us from having
7172               * to work out whether CTWOS+1+X needs to be wrapped around when drawing a
7173               * two-pixel dash that crosses from one character block into another. See CPIX2
7174               * for more details.
7175               *
7176               * ******************************************************************************
7177               
7178               CTWOS:
7179 23B9   88            byte >88
7180 23BA 44              byte >44
7181 23BB   22            byte >22
7182 23BC 11              byte >11
7183 23BD   88            byte >88
7184               
7185               * ******************************************************************************
7186               *
7187               * Name: LOIN (Part 1 of 7)
7188               * Type: Subroutine
7189               * Category: Drawing lines
7190               * Summary: Draw a line: Calculate the line gradient in the form of deltas
7191               * Deep dive: Bresenham's line algorithm
7192               *
7193               * ------------------------------------------------------------------------------
7194               *
7195               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7196               * This stage calculates the line deltas.
7197               *
7198               * ------------------------------------------------------------------------------
7199               *
7200               * Arguments:
7201               *
7202               * X1                  The screen x-coordinate of the start of the line
7203               *
7204               * Y1                  The screen y-coordinate of the start of the line
7205               *
7206               * X2                  The screen x-coordinate of the end of the line
7207               *
7208               * Y2                  The screen y-coordinate of the end of the line
7209               *
7210               * ------------------------------------------------------------------------------
7211               *
7212               * Returns:
7213               *
7214               * Y                   Y is preserved
7215               *
7216               * ------------------------------------------------------------------------------
7217               *
7218               * Other entry points:
7219               *
7220               * LL30                LL30 is a synonym for LOIN and draws a line from
7221               * (X1, Y1) to (X2, Y2)
7222               *
7223               * ******************************************************************************
7224               
7225               LL30:
7226 23BE                 bss 0                                               ; LL30 is a synonym for LOIN
7227                                                                          ;
7228                                                                          ; In the cassette and disc versions of Elite, LL30 and
7229                                                                          ; LOIN are synonyms for the same routine, presumably
7230                                                                          ; because the two developers each had their own line
7231                                                                          ; routines to start with, and then chose one of them for
7232                                                                          ; the final game
7233               
7234               LOIN:
7235 23BE D80F  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     23C0 0094     
7236                                                                          ; call to this subroutine
7237               
7238 23C2 020D  20        li   ra,>80*256                 ; LDA #128          ; Set S = 128, which is the starting point for the
     23C4 8000     
7239 23C6 D80D  30        movb ra,@S                      ; STA S             ; slope error (representing half a pixel)
     23C8 0092     
7240               
7241                      .asla                           ; ASL A             ; Set SWAP = 0, as %10000000 << 1 = 0
     **** ****     > ASLA
0001 23CA 024D  22        andi ra,>ff00
     23CC FF00     
0002 23CE 0A1D  18        sla  ra,1
                   < elite.a99
7242 23D0 D80D  30        movb ra,@SWAP                   ; STA SWAP
     23D2 00A1     
7243               
7244 23D4 D360  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1
     23D6 0033     
7245                      .sbc @X1,ra                     ; SBC X1            ; = delta_x
     **** ****     > SBC
0001 23D8 1801  14        joc  !
0002 23DA 7347  18        sb   rone,ra
0003               !:
0004 23DC 7360  30        sb   @X1,ra
     23DE 0031     
                   < elite.a99
7246                                                                          ;
7247                                                                          ; This subtraction works as the ASL A above sets the C
7248                                                                          ; flag
7249               
7250 23E0 1808  14        joc  LI1                        ; BCS LI1           ; If X2 > X1 then A is already positive and we can skip
7251                                                                          ; the next three instructions
7252               
7253                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 23E2 0200  20        li   rtmp,(>FF*256)
     23E4 FF00     
0002 23E6 2B40  18        xor  rtmp,ra
                   < elite.a99
7254                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 23E8 1701  14        jnc  !
0002 23EA B347  18        ab   rone,ra
0003               !:
0004 23EC 022D  22        ai   ra,(>01*256)
     23EE 0100     
                   < elite.a99
7255                                                                          ; positive
7256               
7257                      .sec                            ; SEC               ; Set the C flag, ready for the subtraction below
     **** ****     > SEC
0001 23F0 0A18  18        sla  rmone,1
                   < elite.a99
7258               
7259               LI1:
7260 23F2 D80D  30        movb ra,@P                      ; STA P             ; Store A in P, so P = |X2 - X1|, or |delta_x|
     23F4 001B     
7261               
7262 23F6 D360  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1
     23F8 0034     
7263                      .sbc @Y1,ra                     ; SBC Y1            ; = delta_y
     **** ****     > SBC
0001 23FA 1801  14        joc  !
0002 23FC 7347  18        sb   rone,ra
0003               !:
0004 23FE 7360  30        sb   @Y1,ra
     2400 0032     
                   < elite.a99
7264                                                                          ;
7265                                                                          ; This subtraction works as we either set the C flag
7266                                                                          ; above, or we skipped that SEC instruction with a BCS
7267               
7268 2402 1807  14        joc  LI2                        ; BCS LI2           ; If Y2 > Y1 then A is already positive and we can skip
7269                                                                          ; the next two instructions
7270               
7271                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
     **** ****     > EOI
0001 2404 0200  20        li   rtmp,(>FF*256)
     2406 FF00     
0002 2408 2B40  18        xor  rtmp,ra
                   < elite.a99
7272                      .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
     **** ****     > ADI
0001 240A 1701  14        jnc  !
0002 240C B347  18        ab   rone,ra
0003               !:
0004 240E 022D  22        ai   ra,(>01*256)
     2410 0100     
                   < elite.a99
7273                                                                          ; positive
7274               
7275               LI2:
7276 2412 D80D  30        movb ra,@Q                      ; STA Q             ; Store A in Q, so Q = |Y2 - Y1|, or |delta_y|
     2414 0090     
7277               
7278 2416 9360  30        cb   @P,ra                      ; CMP P             ; If Q < P, jump to STPX to step along the x-axis, as
     2418 001B     
7279 241A 1702  14        jnc  STPX                       ; BCC STPX          ; the line is closer to being horizontal than vertical
7280               
7281 241C 0460  28        b    @STPY                      ; JMP STPY          ; Otherwise Q >= P so jump to STPY to step along the
     241E 25AA     
7282                                                                          ; y-axis, as the line is closer to being vertical than
7283                                                                          ; horizontal
7284               
7285               * ******************************************************************************
7286               *
7287               * Name: LOIN (Part 2 of 7)
7288               * Type: Subroutine
7289               * Category: Drawing lines
7290               * Summary: Draw a line: Line has a shallow gradient, step right along x-axis
7291               * Deep dive: Bresenham's line algorithm
7292               *
7293               * ------------------------------------------------------------------------------
7294               *
7295               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7296               * If we get here, then:
7297               *
7298               * * |delta_y| < |delta_x|
7299               *
7300               * * The line is closer to being horizontal than vertical
7301               *
7302               * * We are going to step right along the x-axis
7303               *
7304               * * We potentially swap coordinates to make sure X1 < X2
7305               *
7306               * ******************************************************************************
7307               
7308               STPX:
7309 2420 D3A0  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     2422 0031     
7310               
7311 2424 93A0  30        cb   @X2,rx                     ; CPX X2            ; If X1 < X2, jump down to LI3, as the coordinates are
     2426 0033     
7312 2428 1710  14        jnc  LI3                        ; BCC LI3           ; already in the order that we want
7313               
7314 242A 7347  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7315                                                                          ; we are swapping the coordinates around
7316               
7317 242C D360  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     242E 0033     
7318 2430 D80D  30        movb ra,@X1                     ; STA X1
     2432 0031     
7319 2434 D80E  30        movb rx,@X2                     ; STX X2
     2436 0033     
7320               
7321 2438 D38D  18        movb ra,rx                      ; TAX               ; Set X = X1
7322               
7323 243A D360  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     243C 0034     
7324 243E D3E0  30        movb @Y1,ry                     ; LDY Y1
     2440 0032     
7325 2442 D80D  30        movb ra,@Y1                     ; STA Y1
     2444 0032     
7326 2446 D80F  30        movb ry,@Y2                     ; STY Y2
     2448 0034     
7327               
7328               LI3:
7329                                                                          ; By this point we know the line is horizontal-ish and
7330                                                                          ; X1 < X2, so we're going from left to right as we go
7331                                                                          ; from X1 to X2
7332 244A D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     244C 0032     
7333 244E 091D  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7334 2450 091D  18        srl  ra,1                       ; LSR A
7335 2452 091D  18        srl  ra,1                       ; LSR A
7336               
7337 2454 026D  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     2456 6000     
7338                                                                          ; us the screen address of the character row (as each
7339                                                                          ; character row takes up 256 bytes, and the first
7340                                                                          ; character row is at screen address &6000, or page &60)
7341               
7342 2458 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     245A 0008     
7343                                                                          ; the high byte of SC is set correctly for drawing the
7344                                                                          ; start of our line
7345               
7346 245C D360  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     245E 0032     
7347 2460 024D  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     2462 0700     
7348 2464 D3CD  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7349               
7350 2466 D34E  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7351 2468 024D  22        andi ra,>f8*256                 ; AND #%11111000
     246A F800     
7352               
7353 246C D80D  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     246E 0007     
7354                                                                          ; screen address of the far left end (x-coordinate = 0)
7355                                                                          ; of the horizontal pixel row that we want to draw the
7356                                                                          ; start of our line on
7357               
7358 2470 D34E  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7359 2472 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     2474 0700     
7360 2476 D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7361                                                                          ; wide)
7362               
7363 2478 06CE  14        swpb rx                         ;
7364 247A D36E  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     247C 23A9     
7365 247E 06CE  14        swpb rx                         ;
7366 2480 D80D  30        movb ra,@R                      ; STA R             ; and store it in R
     2482 0091     
7367               
7368                                                                          ; The following calculates:
7369                                                                          ;
7370                                                                          ; Q = Q / P
7371                                                                          ; = |delta_y| / |delta_x|
7372                                                                          ;
7373                                                                          ; using the same shift-and-subtract algorithm that's
7374                                                                          ; documented in TIS2
7375               
7376 2484 D360  30        movb @Q,ra                      ; LDA Q             ; Set A = |delta_y|
     2486 0090     
7377               
7378 2488 020E  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set Q to have bits 1-7 set, so we can rotate through 7
     248A FE00     
7379 248C D80E  30        movb rx,@Q                      ; STX Q             ; loop iterations, getting a 1 each time, and then
     248E 0090     
7380                                                                          ; getting a 0 on the 8th iteration... and we can also
7381                                                                          ; use Q to catch our result bits into bit 0 each time
7382               
7383               LIL1:
7384                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 2490 024D  22        andi ra,>ff00
     2492 FF00     
0002 2494 0A1D  18        sla  ra,1
                   < elite.a99
7385               
7386 2496 1803  14        joc  LI4                        ; BCS LI4           ; If bit 7 of A was set, then jump straight to the
7387                                                                          ; subtraction
7388               
7389 2498 9360  30        cb   @P,ra                      ; CMP P             ; If A < P, skip the following subtraction
     249A 001B     
7390 249C 1705  14        jnc  LI5                        ; BCC LI5
7391               
7392               LI4:
7393                      .sbc @P,ra                      ; SBC P             ; A >= P, so set A = A - P
     **** ****     > SBC
0001 249E 1801  14        joc  !
0002 24A0 7347  18        sb   rone,ra
0003               !:
0004 24A2 7360  30        sb   @P,ra
     24A4 001B     
                   < elite.a99
7394               
7395                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 24A6 0A18  18        sla  rmone,1
                   < elite.a99
7396               
7397               LI5:
7398 24A8 0204  20        li   rarg1,Q                    ; ROL Q             ; Rotate the counter in Q to the left, and catch the
     24AA 0090     
7399 24AC 06A0  32        bl   @rol                       ;
     24AE FE4E     
7400                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7401                                                                          ; do the subtraction, or 1 if we did)
7402               
7403 24B0 18EF  14        joc  LIL1                       ; BCS LIL1          ; If we still have set bits in Q, loop back to TIL2 to
7404                                                                          ; do the next iteration of 7
7405               
7406                                                                          ; We now have:
7407                                                                          ;
7408                                                                          ; Q = A / P
7409                                                                          ; = |delta_y| / |delta_x|
7410                                                                          ;
7411                                                                          ; and the C flag is clear
7412               
7413 24B2 D3A0  30        movb @P,rx                      ; LDX P             ; Set X = P + 1
     24B4 001B     
7414 24B6 B387  18        ab   rone,rx                    ; INX               ; = |delta_x| + 1
7415                                                                          ;
7416                                                                          ; We add 1 so we can skip the first pixel plot if the
7417                                                                          ; line is being drawn with swapped coordinates
7418               
7419 24B8 D360  30        movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1 - 1 (as the C flag is clear following
     24BA 0034     
7420                      .sbc @Y1,ra                     ; SBC Y1            ; the above division)
     **** ****     > SBC
0001 24BC 1801  14        joc  !
0002 24BE 7347  18        sb   rone,ra
0003               !:
0004 24C0 7360  30        sb   @Y1,ra
     24C2 0032     
                   < elite.a99
7421               
7422 24C4 1838  14        joc  DOWN                       ; BCS DOWN          ; If Y2 >= Y1 - 1 then jump to DOWN, as we need to draw
7423                                                                          ; the line to the right and down
7424               
7425               * ******************************************************************************
7426               *
7427               * Name: LOIN (Part 3 of 7)
7428               * Type: Subroutine
7429               * Category: Drawing lines
7430               * Summary: Draw a shallow line going right and up or left and down
7431               * Deep dive: Bresenham's line algorithm
7432               *
7433               * ------------------------------------------------------------------------------
7434               *
7435               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7436               * If we get here, then:
7437               *
7438               * * The line is going right and up (no swap) or left and down (swap)
7439               *
7440               * * X1 < X2 and Y1-1 > Y2
7441               *
7442               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7443               * first pixel
7444               *
7445               * ******************************************************************************
7446               
7447 24C6 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP > 0 then we swapped the coordinates above, so
     24C8 00A1     
7448 24CA 160F  14        jne  LI6                        ; BNE LI6           ; jump down to LI6 to skip plotting the first pixel
7449                                                                          ;
7450                                                                          ; This appears to be a bug that omits the last pixel
7451                                                                          ; of this type of shallow line, rather than the first
7452                                                                          ; pixel, which makes the treatment of this kind of line
7453                                                                          ; different to the other kinds of slope (they all have a
7454                                                                          ; BEQ instruction at this point, rather than a BNE)
7455                                                                          ;
7456                                                                          ; The result is a rather messy line join when a shallow
7457                                                                          ; line that goes right and up or left and down joins a
7458                                                                          ; line with any of the other three types of slope
7459                                                                          ;
7460                                                                          ; This bug was fixed in the advanced versions of Elite,
7461                                                                          ; where the BNE is replaced by a BEQ to bring it in line
7462                                                                          ; with the other three slopes
7463               
7464 24CC 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7465                                                                          ; the first pixel
7466               
7467               LIL2:
7468                                                                          ; We now loop along the line from left to right, using X
7469                                                                          ; as a decreasing counter, and at each count we plot a
7470                                                                          ; single pixel using the pixel mask in R
7471 24CE D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     24D0 0091     
7472               
7473                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 24D2 D020  30        movb @SC,rtmp
     24D4 0007     
0002 24D6 2B40  18        xor  rtmp,ra
                   < elite.a99
7474                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 24D8 D820  42        movb @SC,@rtmplb
     24DA 0007     
     24DC 8301     
0002 24DE D020  30        movb @SC+1,rtmp
     24E0 0008     
0003 24E2 06CF  14        swpb ry
0004 24E4 A00F  18        a    ry,rtmp
0005 24E6 06CF  14        swpb ry
0006 24E8 D40D  30        movb RA,*rtmp
                   < elite.a99
7475               
7476               LI6:
7477                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 24EA D020  30        movb @R,rtmp
     24EC 0091     
0002 24EE 0910  18        srl  rtmp,1
0003 24F0 D800  30        movb rtmp,@R
     24F2 0091     
                   < elite.a99
7478                                                                          ; the x-axis, so the next pixel we plot will be at the
7479                                                                          ; next x-coordinate along
7480               
7481 24F4 170C  14        jnc  LI7                        ; BCC LI7           ; If the pixel didn't fall out of the right end of R
7482                                                                          ; into the C flag, then jump to LI7
7483               
7484 24F6 0204  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     24F8 0091     
7485 24FA 06A0  32        bl   @ror                       ;
     24FC FE7A     
7486                                                                          ; block, so first rotate R right so the set C flag goes
7487                                                                          ; back into the left end, giving %10000000
7488               
7489 24FE D360  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2500 0007     
7490                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 2502 1701  14        jnc  !
0002 2504 B347  18        ab   rone,ra
0003               !:
0004 2506 022D  22        ai   ra,(>08*256)
     2508 0800     
                   < elite.a99
7491 250A D80D  30        movb ra,@SC                     ; STA SC
     250C 0007     
7492               
7493               LI7:
7494 250E D360  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     2510 0092     
7495                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 2512 1701  14        jnc  !
0002 2514 B347  18        ab   rone,ra
0003               !:
0004 2516 B360  30        ab   @Q,ra
     2518 0090     
                   < elite.a99
7496 251A D80D  30        movb ra,@S                      ; STA S
     251C 0092     
7497               
7498 251E 1705  14        jnc  LIC2                       ; BCC LIC2          ; If the addition didn't overflow, jump to LIC2
7499               
7500 2520 73C7  18        sb   rone,ry                    ; DEY               ; Otherwise we just overflowed, so decrement Y to move
7501                                                                          ; to the pixel line above
7502               
7503 2522 1503  14        jgt  LIC2                       ; BPL LIC2          ; If Y is positive we are still within the same
7504                                                                          ; character block, so skip to LIC2
7505               
7506 2524 7347  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7507 2526 020F  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     2528 0700     
7508                                                                          ; address and set the pixel line to the last line in
7509                                                                          ; that character block
7510               
7511               LIC2:
7512 252A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7513               
7514 252C 16D0  14        jne  LIL2                       ; BNE LIL2          ; If we haven't yet reached the right end of the line,
7515                                                                          ; loop back to LIL2 to plot the next pixel along
7516               
7517 252E D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2530 0094     
7518               
7519 2532 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2534 FE34     
7520               
7521               * ******************************************************************************
7522               *
7523               * Name: LOIN (Part 4 of 7)
7524               * Type: Subroutine
7525               * Category: Drawing lines
7526               * Summary: Draw a shallow line going right and down or left and up
7527               * Deep dive: Bresenham's line algorithm
7528               *
7529               * ------------------------------------------------------------------------------
7530               *
7531               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7532               * If we get here, then:
7533               *
7534               * * The line is going right and down (no swap) or left and up (swap)
7535               *
7536               * * X1 < X2 and Y1-1 <= Y2
7537               *
7538               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7539               * first pixel
7540               *
7541               * ******************************************************************************
7542               
7543               DOWN:
7544 2536 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     2538 00A1     
7545 253A 130F  14        jeq  LI9                        ; BEQ LI9           ; so jump down to LI9 to skip plotting the first pixel
7546               
7547 253C 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7548                                                                          ; the first pixel
7549               
7550               LIL3:
7551                                                                          ; We now loop along the line from left to right, using X
7552                                                                          ; as a decreasing counter, and at each count we plot a
7553                                                                          ; single pixel using the pixel mask in R
7554 253E D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     2540 0091     
7555               
7556                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 2542 D020  30        movb @SC,rtmp
     2544 0007     
0002 2546 2B40  18        xor  rtmp,ra
                   < elite.a99
7557                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2548 D820  42        movb @SC,@rtmplb
     254A 0007     
     254C 8301     
0002 254E D020  30        movb @SC+1,rtmp
     2550 0008     
0003 2552 06CF  14        swpb ry
0004 2554 A00F  18        a    ry,rtmp
0005 2556 06CF  14        swpb ry
0006 2558 D40D  30        movb RA,*rtmp
                   < elite.a99
7558               
7559               LI9:
7560                      .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
     **** ****     > LSR
0001 255A D020  30        movb @R,rtmp
     255C 0091     
0002 255E 0910  18        srl  rtmp,1
0003 2560 D800  30        movb rtmp,@R
     2562 0091     
                   < elite.a99
7561                                                                          ; the x-axis, so the next pixel we plot will be at the
7562                                                                          ; next x-coordinate along
7563               
7564 2564 170C  14        jnc  LI10                       ; BCC LI10          ; If the pixel didn't fall out of the right end of R
7565                                                                          ; into the C flag, then jump to LI10
7566               
7567 2566 0204  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     2568 0091     
7568 256A 06A0  32        bl   @ror                       ;
     256C FE7A     
7569                                                                          ; block, so first rotate R right so the set C flag goes
7570                                                                          ; back into the left end, giving %10000000
7571               
7572 256E D360  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     2570 0007     
7573                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 2572 1701  14        jnc  !
0002 2574 B347  18        ab   rone,ra
0003               !:
0004 2576 022D  22        ai   ra,(>08*256)
     2578 0800     
                   < elite.a99
7574 257A D80D  30        movb ra,@SC                     ; STA SC
     257C 0007     
7575               
7576               LI10:
7577 257E D360  30        movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
     2580 0092     
7578                      .adc @Q,ra                      ; ADC Q
     **** ****     > ADC
0001 2582 1701  14        jnc  !
0002 2584 B347  18        ab   rone,ra
0003               !:
0004 2586 B360  30        ab   @Q,ra
     2588 0090     
                   < elite.a99
7579 258A D80D  30        movb ra,@S                      ; STA S
     258C 0092     
7580               
7581 258E 1707  14        jnc  LIC3                       ; BCC LIC3          ; If the addition didn't overflow, jump to LIC3
7582               
7583 2590 B3C7  18        ab   rone,ry                    ; INY               ; Otherwise we just overflowed, so increment Y to move
7584                                                                          ; to the pixel line below
7585               
7586 2592 028F  22        ci   ry,>08*256                 ; CPY #8            ; If Y < 8 we are still within the same character block,
     2594 0800     
7587 2596 1603  14        jne  LIC3                       ; BNE LIC3          ; so skip to LIC3
7588               
7589 2598 B347  18        ab   rone,ra                    ; INC SCH           ; Otherwise we need to move down into the character
7590 259A 020F  20        li   ry,>00*256                 ; LDY #0            ; block below, so increment the high byte of the screen
     259C 0000     
7591                                                                          ; address and set the pixel line to the first line in
7592                                                                          ; that character block
7593               
7594               LIC3:
7595 259E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7596               
7597 25A0 16CE  14        jne  LIL3                       ; BNE LIL3          ; If we haven't yet reached the right end of the line,
7598                                                                          ; loop back to LIL3 to plot the next pixel along
7599               
7600 25A2 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     25A4 0094     
7601               
7602 25A6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     25A8 FE34     
7603               
7604               * ******************************************************************************
7605               *
7606               * Name: LOIN (Part 5 of 7)
7607               * Type: Subroutine
7608               * Category: Drawing lines
7609               * Summary: Draw a line: Line has a steep gradient, step up along y-axis
7610               * Deep dive: Bresenham's line algorithm
7611               *
7612               * ------------------------------------------------------------------------------
7613               *
7614               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7615               * If we get here, then:
7616               *
7617               * * |delta_y| >= |delta_x|
7618               *
7619               * * The line is closer to being vertical than horizontal
7620               *
7621               * * We are going to step up along the y-axis
7622               *
7623               * * We potentially swap coordinates to make sure Y1 >= Y2
7624               *
7625               * ******************************************************************************
7626               
7627               STPY:
7628 25AA D3E0  30        movb @Y1,ry                     ; LDY Y1            ; Set A = Y = Y1
     25AC 0032     
7629 25AE D34F  18        movb ry,ra                      ; TYA
7630               
7631 25B0 D3A0  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     25B2 0031     
7632               
7633 25B4 93E0  30        cb   @Y2,ry                     ; CPY Y2            ; If Y1 >= Y2, jump down to LI15, as the coordinates are
     25B6 0034     
7634 25B8 180F  14        joc  LI15                       ; BCS LI15          ; already in the order that we want
7635               
7636 25BA 7347  18        sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
7637                                                                          ; we are swapping the coordinates around
7638               
7639 25BC D360  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
     25BE 0033     
7640 25C0 D80D  30        movb ra,@X1                     ; STA X1
     25C2 0031     
7641 25C4 D80E  30        movb rx,@X2                     ; STX X2
     25C6 0033     
7642               
7643 25C8 D38D  18        movb ra,rx                      ; TAX               ; Set X = X1
7644               
7645 25CA D360  30        movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
     25CC 0034     
7646 25CE D80D  30        movb ra,@Y1                     ; STA Y1
     25D0 0032     
7647 25D2 D80F  30        movb ry,@Y2                     ; STY Y2
     25D4 0034     
7648               
7649 25D6 D3CD  18        movb ra,ry                      ; TAY               ; Set Y = A = Y1
7650               
7651               LI15:
7652                                                                          ; By this point we know the line is vertical-ish and
7653                                                                          ; Y1 >= Y2, so we're going from top to bottom as we go
7654                                                                          ; from Y1 to Y2
7655 25D8 091D  18        srl  ra,1                       ; LSR A             ; Set A = Y1 / 8, so A now contains the character row
7656 25DA 091D  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
7657 25DC 091D  18        srl  ra,1                       ; LSR A
7658               
7659 25DE 026D  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     25E0 6000     
7660                                                                          ; us the screen address of the character row (as each
7661                                                                          ; character row takes up 256 bytes, and the first
7662                                                                          ; character row is at screen address &6000, or page &60)
7663               
7664 25E2 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     25E4 0008     
7665                                                                          ; the high byte of SC is set correctly for drawing the
7666                                                                          ; start of our line
7667               
7668 25E6 D34E  18        movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
7669 25E8 024D  22        andi ra,>f8*256                 ; AND #%11111000
     25EA F800     
7670               
7671 25EC D80D  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     25EE 0007     
7672                                                                          ; screen address of the far left end (x-coordinate = 0)
7673                                                                          ; of the horizontal pixel row that we want to draw the
7674                                                                          ; start of our line on
7675               
7676 25F0 D34E  18        movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
7677 25F2 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     25F4 0700     
7678 25F6 D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
7679                                                                          ; wide)
7680               
7681 25F8 06CE  14        swpb rx                         ;
7682 25FA D36E  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
     25FC 23A9     
7683 25FE 06CE  14        swpb rx                         ;
7684 2600 D80D  30        movb ra,@R                      ; STA R             ; and store it in R
     2602 0091     
7685               
7686 2604 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
     2606 0032     
7687 2608 024D  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
     260A 0700     
7688 260C D3CD  18        movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)
7689               
7690                                                                          ; The following calculates:
7691                                                                          ;
7692                                                                          ; P = P / Q
7693                                                                          ; = |delta_x| / |delta_y|
7694                                                                          ;
7695                                                                          ; using the same shift-and-subtract algorithm
7696                                                                          ; documented in TIS2
7697               
7698 260E D360  30        movb @P,ra                      ; LDA P             ; Set A = |delta_x|
     2610 001B     
7699               
7700 2612 020E  20        li   rx,>01*256                 ; LDX #1            ; Set Q to have bits 1-7 clear, so we can rotate through
     2614 0100     
7701 2616 D80E  30        movb rx,@P                      ; STX P             ; 7 loop iterations, getting a 1 each time, and then
     2618 001B     
7702                                                                          ; getting a 1 on the 8th iteration... and we can also
7703                                                                          ; use P to catch our result bits into bit 0 each time
7704               
7705               LIL4:
7706                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 261A 024D  22        andi ra,>ff00
     261C FF00     
0002 261E 0A1D  18        sla  ra,1
                   < elite.a99
7707               
7708 2620 1803  14        joc  LI13                       ; BCS LI13          ; If bit 7 of A was set, then jump straight to the
7709                                                                          ; subtraction
7710               
7711 2622 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     2624 0090     
7712 2626 1705  14        jnc  LI14                       ; BCC LI14
7713               
7714               LI13:
7715                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 2628 1801  14        joc  !
0002 262A 7347  18        sb   rone,ra
0003               !:
0004 262C 7360  30        sb   @Q,ra
     262E 0090     
                   < elite.a99
7716               
7717                      .sec                            ; SEC               ; Set the C flag to rotate into the result in Q
     **** ****     > SEC
0001 2630 0A18  18        sla  rmone,1
                   < elite.a99
7718               
7719               LI14:
7720 2632 0204  20        li   rarg1,P                    ; ROL P             ; Rotate the counter in P to the left, and catch the
     2634 001B     
7721 2636 06A0  32        bl   @rol                       ;
     2638 FE4E     
7722                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
7723                                                                          ; do the subtraction, or 1 if we did)
7724               
7725 263A 17EF  14        jnc  LIL4                       ; BCC LIL4          ; If we still have set bits in P, loop back to TIL2 to
7726                                                                          ; do the next iteration of 7
7727               
7728                                                                          ; We now have:
7729                                                                          ;
7730                                                                          ; P = A / Q
7731                                                                          ; = |delta_x| / |delta_y|
7732                                                                          ;
7733                                                                          ; and the C flag is set
7734               
7735 263C D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X = Q + 1
     263E 0090     
7736 2640 B387  18        ab   rone,rx                    ; INX               ; = |delta_y| + 1
7737                                                                          ;
7738                                                                          ; We add 1 so we can skip the first pixel plot if the
7739                                                                          ; line is being drawn with swapped coordinates
7740               
7741 2642 D360  30        movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1 (the C flag is set as we didn't take
     2644 0033     
7742                      .sbc @X1,ra                     ; SBC X1            ; the above BCC)
     **** ****     > SBC
0001 2646 1801  14        joc  !
0002 2648 7347  18        sb   rone,ra
0003               !:
0004 264A 7360  30        sb   @X1,ra
     264C 0031     
                   < elite.a99
7743               
7744 264E 1739  14        jnc  LFT                        ; BCC LFT           ; If X2 < X1 then jump to LFT, as we need to draw the
7745                                                                          ; line to the left and down
7746               
7747               * ******************************************************************************
7748               *
7749               * Name: LOIN (Part 6 of 7)
7750               * Type: Subroutine
7751               * Category: Drawing lines
7752               * Summary: Draw a steep line going up and left or down and right
7753               * Deep dive: Bresenham's line algorithm
7754               *
7755               * ------------------------------------------------------------------------------
7756               *
7757               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7758               * If we get here, then:
7759               *
7760               * * The line is going up and left (no swap) or down and right (swap)
7761               *
7762               * * X1 < X2 and Y1 >= Y2
7763               *
7764               * * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
7765               * first pixel
7766               *
7767               * ******************************************************************************
7768               
7769                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 2650 0A16  18        sla  rzero,1
                   < elite.a99
7770               
7771 2652 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     2654 00A1     
7772 2656 130F  14        jeq  LI17                       ; BEQ LI17          ; so jump down to LI17 to skip plotting the first pixel
7773               
7774 2658 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7775                                                                          ; the first pixel
7776               
7777               LIL5:
7778                                                                          ; We now loop along the line from left to right, using X
7779                                                                          ; as a decreasing counter, and at each count we plot a
7780                                                                          ; single pixel using the pixel mask in R
7781 265A D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     265C 0091     
7782               
7783                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 265E D020  30        movb @SC,rtmp
     2660 0007     
0002 2662 2B40  18        xor  rtmp,ra
                   < elite.a99
7784                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2664 D820  42        movb @SC,@rtmplb
     2666 0007     
     2668 8301     
0002 266A D020  30        movb @SC+1,rtmp
     266C 0008     
0003 266E 06CF  14        swpb ry
0004 2670 A00F  18        a    ry,rtmp
0005 2672 06CF  14        swpb ry
0006 2674 D40D  30        movb RA,*rtmp
                   < elite.a99
7785               
7786               LI17:
7787 2676 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7788               
7789 2678 1503  14        jgt  LI16                       ; BPL LI16          ; If Y is positive we are still within the same
7790                                                                          ; character block, so skip to LI16
7791               
7792 267A 7347  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7793 267C 020F  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     267E 0700     
7794                                                                          ; address and set the pixel line to the last line in
7795                                                                          ; that character block
7796               
7797               LI16:
7798 2680 D360  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     2682 0092     
7799                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 2684 1701  14        jnc  !
0002 2686 B347  18        ab   rone,ra
0003               !:
0004 2688 B360  30        ab   @P,ra
     268A 001B     
                   < elite.a99
7800 268C D80D  30        movb ra,@S                      ; STA S
     268E 0092     
7801               
7802 2690 1712  14        jnc  LIC5                       ; BCC LIC5          ; If the addition didn't overflow, jump to LIC5
7803               
7804                      .lsr @R                         ; LSR R             ; Otherwise we just overflowed, so shift the single
     **** ****     > LSR
0001 2692 D020  30        movb @R,rtmp
     2694 0091     
0002 2696 0910  18        srl  rtmp,1
0003 2698 D800  30        movb rtmp,@R
     269A 0091     
                   < elite.a99
7805                                                                          ; pixel in R to the right, so the next pixel we plot
7806                                                                          ; will be at the next x-coordinate along
7807               
7808 269C 170C  14        jnc  LIC5                       ; BCC LIC5          ; If the pixel didn't fall out of the right end of R
7809                                                                          ; into the C flag, then jump to LIC5
7810               
7811 269E 0204  20        li   rarg1,R                    ; ROR R             ; Otherwise we need to move over to the next character
     26A0 0091     
7812 26A2 06A0  32        bl   @ror                       ;
     26A4 FE7A     
7813                                                                          ; block, so first rotate R right so the set C flag goes
7814                                                                          ; back into the left end, giving %10000000
7815               
7816 26A6 D360  30        movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
     26A8 0007     
7817                      .adi (>08*256)                  ; ADC #8            ; character along to the right
     **** ****     > ADI
0001 26AA 1701  14        jnc  !
0002 26AC B347  18        ab   rone,ra
0003               !:
0004 26AE 022D  22        ai   ra,(>08*256)
     26B0 0800     
                   < elite.a99
7818 26B2 D80D  30        movb ra,@SC                     ; STA SC
     26B4 0007     
7819               
7820               LIC5:
7821 26B6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7822               
7823 26B8 16D0  14        jne  LIL5                       ; BNE LIL5          ; If we haven't yet reached the right end of the line,
7824                                                                          ; loop back to LIL5 to plot the next pixel along
7825               
7826 26BA D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     26BC 0094     
7827               
7828 26BE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     26C0 FE34     
7829               
7830               * ******************************************************************************
7831               *
7832               * Name: LOIN (Part 7 of 7)
7833               * Type: Subroutine
7834               * Category: Drawing lines
7835               * Summary: Draw a steep line going up and right or down and left
7836               * Deep dive: Bresenham's line algorithm
7837               *
7838               * ------------------------------------------------------------------------------
7839               *
7840               * This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
7841               * If we get here, then:
7842               *
7843               * * The line is going up and right (no swap) or down and left (swap)
7844               *
7845               * * X1 >= X2 and Y1 >= Y2
7846               *
7847               * * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
7848               * first pixel
7849               *
7850               * ------------------------------------------------------------------------------
7851               *
7852               * Other entry points:
7853               *
7854               * HL6                 Contains an RTS
7855               *
7856               * ******************************************************************************
7857               
7858               LFT:
7859 26C2 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
     26C4 00A1     
7860 26C6 130F  14        jeq  LI18                       ; BEQ LI18          ; so jump down to LI18 to skip plotting the first pixel
7861               
7862 26C8 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
7863                                                                          ; the first pixel
7864               
7865               LIL6:
7866 26CA D360  30        movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R
     26CC 0091     
7867               
7868                      .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 26CE D020  30        movb @SC,rtmp
     26D0 0007     
0002 26D2 2B40  18        xor  rtmp,ra
                   < elite.a99
7869                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 26D4 D820  42        movb @SC,@rtmplb
     26D6 0007     
     26D8 8301     
0002 26DA D020  30        movb @SC+1,rtmp
     26DC 0008     
0003 26DE 06CF  14        swpb ry
0004 26E0 A00F  18        a    ry,rtmp
0005 26E2 06CF  14        swpb ry
0006 26E4 D40D  30        movb RA,*rtmp
                   < elite.a99
7870               
7871               LI18:
7872 26E6 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis
7873               
7874 26E8 1503  14        jgt  LI19                       ; BPL LI19          ; If Y is positive we are still within the same
7875                                                                          ; character block, so skip to LI19
7876               
7877 26EA 7347  18        sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
7878 26EC 020F  20        li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
     26EE 0700     
7879                                                                          ; address and set the pixel line to the last line in
7880                                                                          ; that character block
7881               
7882               LI19:
7883 26F0 D360  30        movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
     26F2 0092     
7884                      .adc @P,ra                      ; ADC P
     **** ****     > ADC
0001 26F4 1701  14        jnc  !
0002 26F6 B347  18        ab   rone,ra
0003               !:
0004 26F8 B360  30        ab   @P,ra
     26FA 001B     
                   < elite.a99
7885 26FC D80D  30        movb ra,@S                      ; STA S
     26FE 0092     
7886               
7887 2700 1715  14        jnc  LIC6                       ; BCC LIC6          ; If the addition didn't overflow, jump to LIC6
7888               
7889                      .asl @R                         ; ASL R             ; Otherwise we just overflowed, so shift the single
     **** ****     > ASL
0001 2702 D020  30        movb @R,rtmp
     2704 0091     
0002 2706 0240  22        andi rtmp,>ff00
     2708 FF00     
0003 270A 0A10  18        sla  rtmp,1
0004 270C D800  30        movb rtmp,@R
     270E 0091     
                   < elite.a99
7890                                                                          ; pixel in R to the left, so the next pixel we plot
7891                                                                          ; will be at the previous x-coordinate
7892               
7893 2710 170D  14        jnc  LIC6                       ; BCC LIC6          ; If the pixel didn't fall out of the left end of R
7894                                                                          ; into the C flag, then jump to LIC6
7895               
7896 2712 0204  20        li   rarg1,R                    ; ROL R             ; Otherwise we need to move over to the next character
     2714 0091     
7897 2716 06A0  32        bl   @rol                       ;
     2718 FE4E     
7898                                                                          ; block, so first rotate R left so the set C flag goes
7899                                                                          ; back into the right end, giving %0000001
7900               
7901 271A D360  30        movb @SC,ra                     ; LDA SC            ; Subtract 7 from SC, so SC(1 0) now points to the
     271C 0007     
7902                      .sbi (>07*256)                  ; SBC #7            ; previous character along to the left
     **** ****     > SBI
0001 271E 1801  14        joc  !
0002 2720 7347  18        sb   rone,ra
0003               !:
0004 2722 022D  22        ai   ra,-(>07*256)
     2724 F900     
                   < elite.a99
7903 2726 D80D  30        movb ra,@SC                     ; STA SC
     2728 0007     
7904               
7905                      .clc                            ; CLC               ; Clear the C flag so it doesn't affect the additions
     **** ****     > CLC
0001 272A 0A16  18        sla  rzero,1
                   < elite.a99
7906                                                                          ; below
7907               
7908               LIC6:
7909 272C 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter in X
7910               
7911 272E 16CD  14        jne  LIL6                       ; BNE LIL6          ; If we haven't yet reached the left end of the line,
7912                                                                          ; loop back to LIL6 to plot the next pixel along
7913               
7914 2730 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     2732 0094     
7915               
7916               HL6:
7917 2734 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2736 FE34     
7918               
7919               * ******************************************************************************
7920               *
7921               * Name: NLIN3
7922               * Type: Subroutine
7923               * Category: Drawing lines
7924               * Summary: Print a title and draw a horizontal line at row 19 to box it in
7925               *
7926               * ------------------------------------------------------------------------------
7927               *
7928               * This routine print a text token at the cursor position and draws a horizontal
7929               * line at pixel row 19. It is used for the Status Mode screen, the Short-range
7930               * Chart, the Market Price screen and the Equip Ship screen.
7931               *
7932               * ******************************************************************************
7933               
7934               NLIN3:
7935 2738 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     273A ACA0     
7936 273C 06A0  32        bl   @jsr                       ;
     273E FE28     
7937               
7938                                                                          ; Fall through into NLIN4 to draw a horizontal line at
7939                                                                          ; pixel row 19
7940               
7941               * ******************************************************************************
7942               *
7943               * Name: NLIN4
7944               * Type: Subroutine
7945               * Category: Drawing lines
7946               * Summary: Draw a horizontal line at pixel row 19 to box in a title
7947               *
7948               * ------------------------------------------------------------------------------
7949               *
7950               * This routine is used on the Inventory screen to draw a horizontal line at
7951               * pixel row 19 to box in the title.
7952               *
7953               * ******************************************************************************
7954               
7955               NLIN4:
7956 2740 020D  20        li   ra,>13*256                 ; LDA #19           ; Jump to NLIN2 to draw a horizontal line at pixel row
     2742 1300     
7957 2744 1603  14        jne  NLIN2                      ; BNE NLIN2         ; 19, returning from the subroutine with using a tail
7958                                                                          ; call (this BNE is effectively a JMP as A will never
7959                                                                          ; be zero)
7960               
7961               * ******************************************************************************
7962               *
7963               * Name: NLIN
7964               * Type: Subroutine
7965               * Category: Drawing lines
7966               * Summary: Draw a horizontal line at pixel row 23 to box in a title
7967               *
7968               * ------------------------------------------------------------------------------
7969               *
7970               * Draw a horizontal line at pixel row 23 and move the text cursor down one
7971               * line.
7972               *
7973               * ******************************************************************************
7974               
7975               NLIN:
7976 2746 020D  20        li   ra,>17*256                 ; LDA #23           ; Set A = 23 so NLIN2 below draws a horizontal line at
     2748 1700     
7977                                                                          ; pixel row 23
7978               
7979 274A B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
7980               
7981                                                                          ; Fall through into NLIN2 to draw the horizontal line
7982                                                                          ; at row 23
7983               
7984               * ******************************************************************************
7985               *
7986               * Name: NLIN2
7987               * Type: Subroutine
7988               * Category: Drawing lines
7989               * Summary: Draw a screen-wide horizontal line at the pixel row in A
7990               *
7991               * ------------------------------------------------------------------------------
7992               *
7993               * This draws a line from (2, A) to (254, A), which is almost screen-wide and
7994               * fits in nicely between the white borders without clashing with it.
7995               *
7996               * ------------------------------------------------------------------------------
7997               *
7998               * Arguments:
7999               *
8000               * A                   The pixel row on which to draw the horizontal line
8001               *
8002               * ******************************************************************************
8003               
8004               NLIN2:
8005 274C D80D  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A
     274E 0032     
8006               
8007 2750 020E  20        li   rx,>02*256                 ; LDX #2            ; Set X1 = 2, so (X1, Y1) = (2, A)
     2752 0200     
8008 2754 D80E  30        movb rx,@X1                     ; STX X1
     2756 0031     
8009               
8010 2758 020E  20        li   rx,>fe*256                 ; LDX #254          ; Set X2 = 254, so (X2, Y2) = (254, A)
     275A FE00     
8011 275C D80E  30        movb rx,@X2                     ; STX X2
     275E 0033     
8012               
8013 2760 160C  14        jne  HLOIN                      ; BNE HLOIN         ; Call HLOIN to draw a horizontal line from (2, A) to
8014                                                                          ; (254, A) and return from the subroutine (this BNE is
8015                                                                          ; effectively a JMP as A will never be zero)
8016               
8017               * ******************************************************************************
8018               *
8019               * Name: HLOIN2
8020               * Type: Subroutine
8021               * Category: Drawing lines
8022               * Summary: Remove a line from the sun line heap and draw it on-screen
8023               *
8024               * ------------------------------------------------------------------------------
8025               *
8026               * Specifically, this does the following:
8027               *
8028               * * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
8029               * centre YY(1 0) and length A to the left and right
8030               *
8031               * * Set the Y-th byte of the LSO block to 0 (i.e. remove this line from the
8032               * sun line heap)
8033               *
8034               * * Draw a horizontal line from (X1, Y) to (X2, Y)
8035               *
8036               * ------------------------------------------------------------------------------
8037               *
8038               * Arguments:
8039               *
8040               * YY(1 0)             The x-coordinate of the centre point of the line
8041               *
8042               * A                   The half-width of the line, i.e. the contents of the
8043               * Y-th byte of the sun line heap
8044               *
8045               * Y                   The number of the entry in the sun line heap (which is
8046               * also the y-coordinate of the line)
8047               *
8048               * ------------------------------------------------------------------------------
8049               *
8050               * Returns:
8051               *
8052               * Y                   Y is preserved
8053               *
8054               * ******************************************************************************
8055               
8056               HLOIN2:
8057 2762 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     2764 C082     
8058 2766 06A0  32        bl   @jsr                       ;
     2768 FE28     
8059                                                                          ; line centred on YY(1 0) and with half-width A
8060               
8061 276A D80F  30        movb ry,@Y1                     ; STY Y1            ; Set Y1 = Y
     276C 0032     
8062               
8063 276E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     2770 0000     
8064 2772 06CF  14        swpb ry                         ;
8065 2774 DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y
     2776 0D66     
8066 2778 06CF  14        swpb ry                         ;
8067               
8068                                                                          ; Fall through into HLOIN to draw a horizontal line from
8069                                                                          ; (X1, Y) to (X2, Y)
8070               
8071               * ******************************************************************************
8072               *
8073               * Name: HLOIN
8074               * Type: Subroutine
8075               * Category: Drawing lines
8076               * Summary: Draw a horizontal line from (X1, Y1) to (X2, Y1)
8077               * Deep dive: Drawing monochrome pixels in mode 4
8078               *
8079               * ------------------------------------------------------------------------------
8080               *
8081               * We do not draw a pixel at the right end of the line.
8082               *
8083               * To understand how this routine works, you might find it helpful to read the
8084               * deep dive on "Drawing monochrome pixels in mode 4".
8085               *
8086               * ------------------------------------------------------------------------------
8087               *
8088               * Returns:
8089               *
8090               * Y                   Y is preserved
8091               *
8092               * ******************************************************************************
8093               
8094               HLOIN:
8095 277A D80F  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
     277C 0094     
8096                                                                          ; call to this subroutine
8097               
8098 277E D3A0  30        movb @X1,rx                     ; LDX X1            ; Set X = X1
     2780 0031     
8099               
8100 2782 93A0  30        cb   @X2,rx                     ; CPX X2            ; If X1 = X2 then the start and end points are the same,
     2784 0033     
8101 2786 13D6  14        jeq  HL6                        ; BEQ HL6           ; so return from the subroutine (as HL6 contains an RTS)
8102               
8103 2788 1707  14        jnc  HL5                        ; BCC HL5           ; If X1 < X2, jump to HL5 to skip the following code, as
8104                                                                          ; (X1, Y1) is already the left point
8105               
8106 278A D360  30        movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2, so we know that (X1, Y1)
     278C 0033     
8107 278E D80D  30        movb ra,@X1                     ; STA X1            ; is on the left and (X2, Y1) is on the right
     2790 0031     
8108 2792 D80E  30        movb rx,@X2                     ; STX X2
     2794 0033     
8109               
8110 2796 D38D  18        movb ra,rx                      ; TAX               ; Set X = X1
8111               
8112               HL5:
8113 2798 7347  18        sb   rone,ra                    ; DEC X2            ; Decrement X2 so we do not draw a pixel at the end
8114                                                                          ; point
8115               
8116 279A D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
     279C 0032     
8117 279E 091D  18        srl  ra,1                       ; LSR A             ; that will contain our horizontal line
8118 27A0 091D  18        srl  ra,1                       ; LSR A
8119 27A2 091D  18        srl  ra,1                       ; LSR A
8120               
8121 27A4 026D  22        ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
     27A6 6000     
8122                                                                          ; us the screen address of the character row (as each
8123                                                                          ; character row takes up 256 bytes, and the first
8124                                                                          ; character row is at screen address &6000, or page &60)
8125               
8126 27A8 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
     27AA 0008     
8127                                                                          ; the high byte of SC is set correctly for drawing our
8128                                                                          ; line
8129               
8130 27AC D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 mod 8, which is the pixel row within the
     27AE 0032     
8131 27B0 024D  22        andi ra,>07*256                 ; AND #7            ; character block at which we want to draw our line (as
     27B2 0700     
8132                                                                          ; each character block has 8 rows)
8133               
8134 27B4 D80D  30        movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
     27B6 0007     
8135                                                                          ; screen address of the far left end (x-coordinate = 0)
8136                                                                          ; of the horizontal pixel row that we want to draw our
8137                                                                          ; horizontal line on
8138               
8139 27B8 D34E  18        movb rx,ra                      ; TXA               ; Set Y = bits 3-7 of X1
8140 27BA 024D  22        andi ra,>f8*256                 ; AND #%11111000
     27BC F800     
8141 27BE D3CD  18        movb ra,ry                      ; TAY
8142               
8143               HL1:
8144 27C0 D34E  18        movb rx,ra                      ; TXA               ; Set T = bits 3-7 of X1, which will contain the
8145 27C2 024D  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the start of the line * 8
     27C4 F800     
8146 27C6 D80D  30        movb ra,@T                      ; STA T
     27C8 00D1     
8147               
8148 27CA D360  30        movb @X2,ra                     ; LDA X2            ; Set A = bits 3-7 of X2, which will contain the
     27CC 0033     
8149 27CE 024D  22        andi ra,>f8*256                 ; AND #%11111000    ; character number of the end of the line * 8
     27D0 F800     
8150               
8151                      .sec                            ; SEC               ; Set A = A - T, which will contain the number of
     **** ****     > SEC
0001 27D2 0A18  18        sla  rmone,1
                   < elite.a99
8152                      .sbc @T,ra                      ; SBC T             ; character blocks we need to fill - 1 * 8
     **** ****     > SBC
0001 27D4 1801  14        joc  !
0002 27D6 7347  18        sb   rone,ra
0003               !:
0004 27D8 7360  30        sb   @T,ra
     27DA 00D1     
                   < elite.a99
8153               
8154 27DC 1354  14        jeq  HL2                        ; BEQ HL2           ; If A = 0 then the start and end character blocks are
8155                                                                          ; the same, so the whole line fits within one block, so
8156                                                                          ; jump down to HL2 to draw the line
8157               
8158                                                                          ; Otherwise the line spans multiple characters, so we
8159                                                                          ; start with the left character, then do any characters
8160                                                                          ; in the middle, and finish with the right character
8161               
8162 27DE 091D  18        srl  ra,1                       ; LSR A             ; Set R = A / 8, so R now contains the number of
8163 27E0 091D  18        srl  ra,1                       ; LSR A             ; character blocks we need to fill - 1
8164 27E2 091D  18        srl  ra,1                       ; LSR A
8165 27E4 D80D  30        movb ra,@R                      ; STA R
     27E6 0091     
8166               
8167 27E8 D360  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     27EA 0031     
8168 27EC 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     27EE 0700     
8169 27F0 D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
8170                                                                          ; wide)
8171               
8172 27F2 06CE  14        swpb rx                         ;
8173 27F4 D36E  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     27F6 28DD     
8174 27F8 06CE  14        swpb rx                         ;
8175                                                                          ; right end of the byte (so the filled pixels start at
8176                                                                          ; point X and go all the way to the end of the byte),
8177                                                                          ; which is the shape we want for the left end of the
8178                                                                          ; line
8179               
8180                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 27FA D020  30        movb @SC,rtmp
     27FC 0007     
0002 27FE 2B40  18        xor  rtmp,ra
                   < elite.a99
8181                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 2800 D820  42        movb @SC,@rtmplb
     2802 0007     
     2804 8301     
0002 2806 D020  30        movb @SC+1,rtmp
     2808 0008     
0003 280A 06CF  14        swpb ry
0004 280C A00F  18        a    ry,rtmp
0005 280E 06CF  14        swpb ry
0006 2810 D40D  30        movb RA,*rtmp
                   < elite.a99
8182                                                                          ; so we have now drawn the line's left cap
8183               
8184 2812 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8185                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 2814 1701  14        jnc  !
0002 2816 B347  18        ab   rone,ra
0003               !:
0004 2818 022D  22        ai   ra,(>08*256)
     281A 0800     
                   < elite.a99
8186 281C D3CD  18        movb ra,ry                      ; TAY
8187               
8188 281E D3A0  30        movb @R,rx                      ; LDX R             ; Fetch the number of character blocks we need to fill
     2820 0091     
8189                                                                          ; from R
8190               
8191 2822 7387  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8192               
8193 2824 1317  14        jeq  HL3                        ; BEQ HL3           ; If X = 0 then we only have the last block to do (i.e.
8194                                                                          ; the right cap), so jump down to HL3 to draw it
8195               
8196                      .clc                            ; CLC               ; Otherwise clear the C flag so we can do some additions
     **** ****     > CLC
0001 2826 0A16  18        sla  rzero,1
                   < elite.a99
8197                                                                          ; while we draw the character blocks with full-width
8198                                                                          ; lines in them
8199               
8200               HLL1:
8201 2828 020D  20        li   ra,>ff*256                 ; LDA #%11111111    ; Store a full-width 8-pixel horizontal line in SC(1 0)
     282A FF00     
8202                      .eor @SC                        ; EOR (SC),Y        ; so that it draws the line on-screen, using EOR logic
     **** ****     > EOR
0001 282C D020  30        movb @SC,rtmp
     282E 0007     
0002 2830 2B40  18        xor  rtmp,ra
                   < elite.a99
8203                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; so it merges with whatever is already on-screen
     **** ****     > ST_IND_Y_IDX
0001 2832 D820  42        movb @SC,@rtmplb
     2834 0007     
     2836 8301     
0002 2838 D020  30        movb @SC+1,rtmp
     283A 0008     
0003 283C 06CF  14        swpb ry
0004 283E A00F  18        a    ry,rtmp
0005 2840 06CF  14        swpb ry
0006 2842 D40D  30        movb RA,*rtmp
                   < elite.a99
8204               
8205 2844 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
8206                      .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
     **** ****     > ADI
0001 2846 1701  14        jnc  !
0002 2848 B347  18        ab   rone,ra
0003               !:
0004 284A 022D  22        ai   ra,(>08*256)
     284C 0800     
                   < elite.a99
8207 284E D3CD  18        movb ra,ry                      ; TAY
8208               
8209 2850 7387  18        sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X
8210               
8211 2852 16EA  14        jne  HLL1                       ; BNE HLL1          ; Loop back to draw more full-width lines, if we have
8212                                                                          ; any more to draw
8213               
8214               HL3:
8215 2854 D360  30        movb @X2,ra                     ; LDA X2            ; Now to draw the last character block at the right end
     2856 0033     
8216 2858 024D  22        andi ra,>07*256                 ; AND #7            ; of the line, so set X = X2 mod 8, which is the
     285A 0700     
8217 285C D38D  18        movb ra,rx                      ; TAX               ; horizontal pixel number where the line ends
8218               
8219 285E 06CE  14        swpb rx                         ;
8220 2860 D36E  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     2862 28D6     
8221 2864 06CE  14        swpb rx                         ;
8222                                                                          ; left end of the byte (so the filled pixels start at
8223                                                                          ; the left edge and go up to point X), which is the
8224                                                                          ; shape we want for the right end of the line
8225               
8226                      .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
     **** ****     > EOR
0001 2866 D020  30        movb @SC,rtmp
     2868 0007     
0002 286A 2B40  18        xor  rtmp,ra
                   < elite.a99
8227                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
     **** ****     > ST_IND_Y_IDX
0001 286C D820  42        movb @SC,@rtmplb
     286E 0007     
     2870 8301     
0002 2872 D020  30        movb @SC+1,rtmp
     2874 0008     
0003 2876 06CF  14        swpb ry
0004 2878 A00F  18        a    ry,rtmp
0005 287A 06CF  14        swpb ry
0006 287C D40D  30        movb RA,*rtmp
                   < elite.a99
8228                                                                          ; so we have now drawn the line's right cap
8229               
8230 287E D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved across the
     2880 0094     
8231                                                                          ; call to this subroutine
8232               
8233 2882 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2884 FE34     
8234               
8235               HL2:
8236                                                                          ; If we get here then the entire horizontal line fits
8237                                                                          ; into one character block
8238 2886 D360  30        movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
     2888 0031     
8239 288A 024D  22        andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
     288C 0700     
8240 288E D38D  18        movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
8241                                                                          ; wide)
8242               
8243 2890 06CE  14        swpb rx                         ;
8244 2892 D36E  34        movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
     2894 28DD     
8245 2896 06CE  14        swpb rx                         ;
8246 2898 D80D  30        movb ra,@T                      ; STA T             ; right end of the byte (so the filled pixels start at
     289A 00D1     
8247                                                                          ; point X and go all the way to the end of the byte)
8248               
8249 289C D360  30        movb @X2,ra                     ; LDA X2            ; Set X = X2 mod 8, which is the horizontal pixel number
     289E 0033     
8250 28A0 024D  22        andi ra,>07*256                 ; AND #7            ; where the line ends
     28A2 0700     
8251 28A4 D38D  18        movb ra,rx                      ; TAX
8252               
8253 28A6 06CE  14        swpb rx                         ;
8254 28A8 D36E  34        movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
     28AA 28D6     
8255 28AC 06CE  14        swpb rx                         ;
8256                                                                          ; left end of the byte (so the filled pixels start at
8257                                                                          ; the left edge and go up to point X)
8258               
8259                      .and @T                         ; AND T             ; We now have two bytes, one (T) containing pixels from
     **** ****     > AND
0001 28AE D020  30        movb @T,rtmp
     28B0 00D1     
0002 28B2 0540  14        inv  rtmp
0003 28B4 5340  18        szcb rtmp,ra
                   < elite.a99
8260                                                                          ; the starting point X1 onwards, and the other (A)
8261                                                                          ; containing pixels up to the end point at X2, so we can
8262                                                                          ; get the actual line we want to draw by AND'ing them
8263                                                                          ; together. For example, if we want to draw a line from
8264                                                                          ; point 2 to point 5 (within the row of 8 pixels
8265                                                                          ; numbered from 0 to 7), we would have this:
8266                                                                          ;
8267                                                                          ; T       = %00111111
8268                                                                          ; A       = %11111100
8269                                                                          ; T AND A = %00111100
8270                                                                          ;
8271                                                                          ; So we can stick T AND A in screen memory to get the
8272                                                                          ; line we want, which is what we do here by setting
8273                                                                          ; A = A AND T
8274               
8275                      .eor @SC                        ; EOR (SC),Y        ; Store our horizontal line byte into screen memory at
     **** ****     > EOR
0001 28B6 D020  30        movb @SC,rtmp
     28B8 0007     
0002 28BA 2B40  18        xor  rtmp,ra
                   < elite.a99
8276                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; SC(1 0), using EOR logic so it merges with whatever is
     **** ****     > ST_IND_Y_IDX
0001 28BC D820  42        movb @SC,@rtmplb
     28BE 0007     
     28C0 8301     
0002 28C2 D020  30        movb @SC+1,rtmp
     28C4 0008     
0003 28C6 06CF  14        swpb ry
0004 28C8 A00F  18        a    ry,rtmp
0005 28CA 06CF  14        swpb ry
0006 28CC D40D  30        movb RA,*rtmp
                   < elite.a99
8277                                                                          ; already on-screen
8278               
8279 28CE D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved
     28D0 0094     
8280               
8281 28D2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     28D4 FE34     
8282               
8283               * ******************************************************************************
8284               *
8285               * Name: TWFL
8286               * Type: Variable
8287               * Category: Drawing lines
8288               * Summary: Ready-made character rows for the left end of a horizontal line in
8289               * mode 4
8290               *
8291               * ------------------------------------------------------------------------------
8292               *
8293               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8294               * of the split screen). This table provides a byte with pixels at the left end,
8295               * which is used for the right end of the line.
8296               *
8297               * See the HLOIN routine for details.
8298               *
8299               * ******************************************************************************
8300               
8301               TWFL:
8302 28D6 80              byte >80
8303 28D7   C0            byte >c0
8304 28D8 E0              byte >e0
8305 28D9   F0            byte >f0
8306 28DA F8              byte >f8
8307 28DB   FC            byte >fc
8308 28DC FE              byte >fe
8309               
8310               * ******************************************************************************
8311               *
8312               * Name: TWFR
8313               * Type: Variable
8314               * Category: Drawing lines
8315               * Summary: Ready-made character rows for the right end of a horizontal line
8316               * in mode 4
8317               *
8318               * ------------------------------------------------------------------------------
8319               *
8320               * Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
8321               * of the split screen). This table provides a byte with pixels at the right end,
8322               * which is used for the left end of the line.
8323               *
8324               * See the HLOIN routine for details.
8325               *
8326               * ******************************************************************************
8327               
8328               TWFR:
8329 28DD   FF            byte >ff
8330 28DE 7F              byte >7f
8331 28DF   3F            byte >3f
8332 28E0 1F              byte >1f
8333 28E1   0F            byte >0f
8334 28E2 07              byte >07
8335 28E3   03            byte >03
8336 28E4 01              byte >01
8337               
8338               * ******************************************************************************
8339               *
8340               * Name: PX3
8341               * Type: Subroutine
8342               * Category: Drawing pixels
8343               * Summary: Plot a single pixel at (X, Y) within a character block
8344               *
8345               * ------------------------------------------------------------------------------
8346               *
8347               * This routine is called from PIXEL to set 1 pixel within a character block for
8348               * a distant point (i.e. where the distance ZZ >= &90). See the PIXEL routine for
8349               * details, as this routine is effectively part of PIXEL.
8350               *
8351               * ------------------------------------------------------------------------------
8352               *
8353               * Arguments:
8354               *
8355               * X                   The x-coordinate of the pixel within the character block
8356               *
8357               * Y                   The y-coordinate of the pixel within the character block
8358               *
8359               * SC(1 0)             The screen address of the character block
8360               *
8361               * T1                  The value of Y to restore on exit, so Y is preserved by
8362               * the call to PIXEL
8363               *
8364               * ******************************************************************************
8365               
8366               PX3:
8367 28E6 06CE  14        swpb rx                         ;
8368 28E8 D36E  34        movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS and EOR it into SC+Y
     28EA 23A9     
8369 28EC 06CE  14        swpb rx                         ;
8370                      .eor @SC                        ; EOR (SC),Y
     **** ****     > EOR
0001 28EE D020  30        movb @SC,rtmp
     28F0 0007     
0002 28F2 2B40  18        xor  rtmp,ra
                   < elite.a99
8371                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 28F4 D820  42        movb @SC,@rtmplb
     28F6 0007     
     28F8 8301     
0002 28FA D020  30        movb @SC+1,rtmp
     28FC 0008     
0003 28FE 06CF  14        swpb ry
0004 2900 A00F  18        a    ry,rtmp
0005 2902 06CF  14        swpb ry
0006 2904 D40D  30        movb RA,*rtmp
                   < elite.a99
8372               
8373 2906 D3E0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     2908 0006     
8374               
8375 290A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     290C FE34     
8376               
8377               * ******************************************************************************
8378               *
8379               * Name: PIX1
8380               * Type: Subroutine
8381               * Category: Maths (Arithmetic)
8382               * Summary: Calculate (YY+1 SYL+Y) = (A P) + (S R) and draw stardust particle
8383               *
8384               * ------------------------------------------------------------------------------
8385               *
8386               * Calculate the following:
8387               *
8388               * (YY+1 SYL+Y) = (A P) + (S R)
8389               *
8390               * and draw a stardust particle at (X1,Y1) with distance ZZ.
8391               *
8392               * ------------------------------------------------------------------------------
8393               *
8394               * Arguments:
8395               *
8396               * (A P)               A is the angle ALPHA or BETA, P is always 0
8397               *
8398               * (S R)               YY(1 0) or YY(1 0) + Q * A
8399               *
8400               * Y                   Stardust particle number
8401               *
8402               * X1                  The x-coordinate offset
8403               *
8404               * Y1                  The y-coordinate offset
8405               *
8406               * ZZ                  The distance of the point (further away = smaller point)
8407               *
8408               * ******************************************************************************
8409               
8410               PIX1:
8411 290E 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     2910 4862     
8412 2912 06A0  32        bl   @jsr                       ;
     2914 FE28     
8413               
8414 2916 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY+1 to A, the high byte of the result
     2918 0027     
8415               
8416 291A D34E  18        movb rx,ra                      ; TXA               ; Set SYL+Y to X, the low byte of the result
8417 291C 06CF  14        swpb ry                         ;
8418 291E DBCD  38        movb ra,@SYL(ry)                ; STA SYL,Y
     2920 0ED5     
8419 2922 06CF  14        swpb ry                         ;
8420               
8421                                                                          ; Fall through into PIX1 to draw the stardust particle
8422                                                                          ; at (X1,Y1)
8423               
8424               * ******************************************************************************
8425               *
8426               * Name: PIXEL2
8427               * Type: Subroutine
8428               * Category: Drawing pixels
8429               * Summary: Draw a stardust particle relative to the screen centre
8430               *
8431               * ------------------------------------------------------------------------------
8432               *
8433               * Draw a point (X1, Y1) from the middle of the screen with a size determined by
8434               * a distance value. Used to draw stardust particles.
8435               *
8436               * ------------------------------------------------------------------------------
8437               *
8438               * Arguments:
8439               *
8440               * X1                  The x-coordinate offset
8441               *
8442               * Y1                  The y-coordinate offset (positive means up the screen
8443               * from the centre, negative means down the screen)
8444               *
8445               * ZZ                  The distance of the point (further away = smaller point)
8446               *
8447               * ******************************************************************************
8448               
8449               PIXEL2:
8450 2924 D360  30        movb @X1,ra                     ; LDA X1            ; Fetch the x-coordinate offset into A
     2926 0031     
8451               
8452 2928 1508  14        jgt  PX1                        ; BPL PX1           ; If the x-coordinate offset is positive, jump to PX1
8453                                                                          ; to skip the following negation
8454               
8455                      .eoi (>7f*256)                  ; EOR #%01111111    ; The x-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 292A 0200  20        li   rtmp,(>7F*256)
     292C 7F00     
0002 292E 2B40  18        xor  rtmp,ra
                   < elite.a99
8456                      .clc                            ; CLC               ; bits apart from the sign bit and add 1, to convert it
     **** ****     > CLC
0001 2930 0A16  18        sla  rzero,1
                   < elite.a99
8457                      .adi (>01*256)                  ; ADC #1            ; from a sign-magnitude number to a signed number
     **** ****     > ADI
0001 2932 1701  14        jnc  !
0002 2934 B347  18        ab   rone,ra
0003               !:
0004 2936 022D  22        ai   ra,(>01*256)
     2938 0100     
                   < elite.a99
8458               
8459               PX1:
8460                      .eoi (>80*256)                  ; EOR #%10000000    ; Set X = X1 + 128
     **** ****     > EOI
0001 293A 0200  20        li   rtmp,(>80*256)
     293C 8000     
0002 293E 2B40  18        xor  rtmp,ra
                   < elite.a99
8461 2940 D38D  18        movb ra,rx                      ; TAX               ;
8462                                                                          ; So X is now the offset converted to an x-coordinate,
8463                                                                          ; centred on x-coordinate 128
8464               
8465 2942 D360  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A and clear the
     2944 0032     
8466 2946 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |Y1|
     2948 7F00     
8467               
8468 294A 028D  22        ci   ra,>60*256                 ; CMP #96           ; If |Y1| >= 96 then it's off the screen (as 96 is half
     294C 6000     
8469 294E 1859  14        joc  PX4                        ; BCS PX4           ; the screen height), so return from the subroutine (as
8470                                                                          ; PX4 contains an RTS)
8471               
8472 2950 D360  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A
     2952 0032     
8473               
8474 2954 1507  14        jgt  PX2                        ; BPL PX2           ; If the y-coordinate offset is positive, jump to PX2
8475                                                                          ; to skip the following negation
8476               
8477                      .eoi (>7f*256)                  ; EOR #%01111111    ; The y-coordinate offset is negative, so flip all the
     **** ****     > EOI
0001 2956 0200  20        li   rtmp,(>7F*256)
     2958 7F00     
0002 295A 2B40  18        xor  rtmp,ra
                   < elite.a99
8478                      .adi (>01*256)                  ; ADC #1            ; bits apart from the sign bit and subtract 1, to negate
     **** ****     > ADI
0001 295C 1701  14        jnc  !
0002 295E B347  18        ab   rone,ra
0003               !:
0004 2960 022D  22        ai   ra,(>01*256)
     2962 0100     
                   < elite.a99
8479                                                                          ; it to a positive number, i.e. A is now |Y1|
8480               
8481               PX2:
8482 2964 D80D  30        movb ra,@T                      ; STA T             ; Set A = 97 - Y1
     2966 00D1     
8483 2968 020D  20        li   ra,>61*256                 ; LDA #97           ;
     296A 6100     
8484                      .sbc @T,ra                      ; SBC T             ; So if Y is positive we display the point up from the
     **** ****     > SBC
0001 296C 1801  14        joc  !
0002 296E 7347  18        sb   rone,ra
0003               !:
0004 2970 7360  30        sb   @T,ra
     2972 00D1     
                   < elite.a99
8485                                                                          ; centre at y-coordinate 97, while a negative Y means
8486                                                                          ; down from the centre
8487               
8488                                                                          ; Fall through into PIXEL to draw the stardust at the
8489                                                                          ; screen coordinates in (X, A)
8490               
8491               * ******************************************************************************
8492               *
8493               * Name: PIXEL
8494               * Type: Subroutine
8495               * Category: Drawing pixels
8496               * Summary: Draw a 1-pixel dot, 2-pixel dash or 4-pixel square
8497               * Deep dive: Drawing monochrome pixels in mode 4
8498               *
8499               * ------------------------------------------------------------------------------
8500               *
8501               * Draw a point at screen coordinate (X, A) with the point size determined by the
8502               * distance in ZZ. This applies to the top part of the screen (the monochrome
8503               * mode 4 portion).
8504               *
8505               * ------------------------------------------------------------------------------
8506               *
8507               * Arguments:
8508               *
8509               * X                   The screen x-coordinate of the point to draw
8510               *
8511               * A                   The screen y-coordinate of the point to draw
8512               *
8513               * ZZ                  The distance of the point (further away = smaller point)
8514               *
8515               * ------------------------------------------------------------------------------
8516               *
8517               * Returns:
8518               *
8519               * Y                   Y is preserved
8520               *
8521               * ------------------------------------------------------------------------------
8522               *
8523               * Other entry points:
8524               *
8525               * PX4                 Contains an RTS
8526               *
8527               * ******************************************************************************
8528               
8529               PIXEL:
8530 2974 D80F  30        movb ry,@T1                     ; STY T1            ; Store Y in T1
     2976 0006     
8531               
8532 2978 D3CD  18        movb ra,ry                      ; TAY               ; Copy A into Y, for use later
8533               
8534 297A 091D  18        srl  ra,1                       ; LSR A             ; Set SCH = &60 + A >> 3
8535 297C 091D  18        srl  ra,1                       ; LSR A
8536 297E 091D  18        srl  ra,1                       ; LSR A
8537 2980 026D  22        ori  ra,>60*256                 ; ORA #&60
     2982 6000     
8538 2984 D80D  30        movb ra,@SCH                    ; STA SCH
     2986 0008     
8539               
8540 2988 D34E  18        movb rx,ra                      ; TXA               ; Set SC = (X >> 3) * 8
8541 298A 024D  22        andi ra,>f8*256                 ; AND #%11111000
     298C F800     
8542 298E D80D  30        movb ra,@SC                     ; STA SC
     2990 0007     
8543               
8544 2992 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y AND %111
8545 2994 024D  22        andi ra,>07*256                 ; AND #%00000111
     2996 0700     
8546 2998 D3CD  18        movb ra,ry                      ; TAY
8547               
8548 299A D34E  18        movb rx,ra                      ; TXA               ; Set X = X AND %111
8549 299C 024D  22        andi ra,>07*256                 ; AND #%00000111
     299E 0700     
8550 29A0 D38D  18        movb ra,rx                      ; TAX
8551               
8552 29A2 D360  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 144, then this point is a very
     29A4 0097     
8553 29A6 028D  22        ci   ra,>90*256                 ; CMP #144          ; long way away, so jump to PX3 to fetch a 1-pixel point
     29A8 9000     
8554 29AA 189D  14        joc  PX3                        ; BCS PX3           ; from TWOS and EOR it into SC+Y
8555               
8556 29AC 06CE  14        swpb rx                         ;
8557 29AE D36E  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Otherwise fetch a 2-pixel dash from TWOS2 and EOR it
     29B0 23B1     
8558 29B2 06CE  14        swpb rx                         ;
8559                      .eor @SC                        ; EOR (SC),Y        ; into SC+Y
     **** ****     > EOR
0001 29B4 D020  30        movb @SC,rtmp
     29B6 0007     
0002 29B8 2B40  18        xor  rtmp,ra
                   < elite.a99
8560                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 29BA D820  42        movb @SC,@rtmplb
     29BC 0007     
     29BE 8301     
0002 29C0 D020  30        movb @SC+1,rtmp
     29C2 0008     
0003 29C4 06CF  14        swpb ry
0004 29C6 A00F  18        a    ry,rtmp
0005 29C8 06CF  14        swpb ry
0006 29CA D40D  30        movb RA,*rtmp
                   < elite.a99
8561               
8562 29CC D360  30        movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 80, then this point is a medium
     29CE 0097     
8563 29D0 028D  22        ci   ra,>50*256                 ; CMP #80           ; distance away, so jump to PX13 to stop drawing, as a
     29D2 5000     
8564 29D4 1814  14        joc  PX13                       ; BCS PX13          ; 2-pixel dash is enough
8565               
8566                                                                          ; Otherwise we keep going to draw another 2 pixel point
8567                                                                          ; either above or below the one we just drew, to make a
8568                                                                          ; 4-pixel square
8569               
8570 29D6 73C7  18        sb   rone,ry                    ; DEY               ; Reduce Y by 1 to point to the pixel row above the one
8571 29D8 1502  14        jgt  PX14                       ; BPL PX14          ; we just plotted, and if it is still positive, jump to
8572                                                                          ; PX14 to draw our second 2-pixel dash
8573               
8574 29DA 020F  20        li   ry,>01*256                 ; LDY #1            ; Reducing Y by 1 made it negative, which means Y was
     29DC 0100     
8575                                                                          ; 0 before we did the DEY above, so set Y to 1 to point
8576                                                                          ; to the pixel row after the one we just plotted
8577               
8578               PX14:
8579 29DE 06CE  14        swpb rx                         ;
8580 29E0 D36E  34        movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Fetch a 2-pixel dash from TWOS2 and EOR it into this
     29E2 23B1     
8581 29E4 06CE  14        swpb rx                         ;
8582                      .eor @SC                        ; EOR (SC),Y        ; second row to make a 4-pixel square
     **** ****     > EOR
0001 29E6 D020  30        movb @SC,rtmp
     29E8 0007     
0002 29EA 2B40  18        xor  rtmp,ra
                   < elite.a99
8583                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 29EC D820  42        movb @SC,@rtmplb
     29EE 0007     
     29F0 8301     
0002 29F2 D020  30        movb @SC+1,rtmp
     29F4 0008     
0003 29F6 06CF  14        swpb ry
0004 29F8 A00F  18        a    ry,rtmp
0005 29FA 06CF  14        swpb ry
0006 29FC D40D  30        movb RA,*rtmp
                   < elite.a99
8584               
8585               PX13:
8586 29FE D3E0  30        movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine
     2A00 0006     
8587               
8588               PX4:
8589 2A02 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2A04 FE34     
8590               
8591               * ******************************************************************************
8592               *
8593               * Name: BLINE
8594               * Type: Subroutine
8595               * Category: Drawing circles
8596               * Summary: Draw a circle segment and add it to the ball line heap
8597               * Deep dive: The ball line heap
8598               * Drawing circles
8599               *
8600               * ------------------------------------------------------------------------------
8601               *
8602               * Draw a single segment of a circle, adding the point to the ball line heap.
8603               *
8604               * ------------------------------------------------------------------------------
8605               *
8606               * Arguments:
8607               *
8608               * CNT                 The number of this segment
8609               *
8610               * STP                 The step size for the circle
8611               *
8612               * K6(1 0)             The x-coordinate of the new point on the circle, as
8613               * a screen coordinate
8614               *
8615               * (T X)               The y-coordinate of the new point on the circle, as
8616               * an offset from the centre of the circle
8617               *
8618               * FLAG                Set to &FF for the first call, so it sets up the first
8619               * point in the heap but waits until the second call before
8620               * drawing anything (as we need two points, i.e. two calls,
8621               * before we can draw a line)
8622               *
8623               * K4(1 0)             Pixel y-coordinate of the centre of the circle
8624               *
8625               * K5(1 0)             Screen x-coordinate of the previous point added to the
8626               * ball line heap (if this is not the first point)
8627               *
8628               * K5(3 2)             Screen y-coordinate of the previous point added to the
8629               * ball line heap (if this is not the first point)
8630               *
8631               * ------------------------------------------------------------------------------
8632               *
8633               * Returns:
8634               *
8635               * CNT                 CNT is updated to CNT + STP
8636               *
8637               * A                   The new value of CNT
8638               *
8639               * K5(1 0)             Screen x-coordinate of the point that we just added to
8640               * the ball line heap
8641               *
8642               * K5(3 2)             Screen y-coordinate of the point that we just added to
8643               * the ball line heap
8644               *
8645               * FLAG                Set to 0
8646               *
8647               * ******************************************************************************
8648               
8649               BLINE:
8650 2A06 D34E  18        movb rx,ra                      ; TXA               ; Set K6(3 2) = (T X) + K4(1 0)
8651                      .adc @K4,ra                     ; ADC K4            ; = y-coord of centre + y-coord of new point
     **** ****     > ADC
0001 2A08 1701  14        jnc  !
0002 2A0A B347  18        ab   rone,ra
0003               !:
0004 2A0C B360  30        ab   @K4,ra
     2A0E 00E0     
                   < elite.a99
8652 2A10 D80D  30        movb ra,@K6+2                   ; STA K6+2          ;
     2A12 0084     
8653 2A14 D360  30        movb @K4+1,ra                   ; LDA K4+1          ; so K6(3 2) now contains the y-coordinate of the new
     2A16 00E1     
8654                      .adc @T,ra                      ; ADC T             ; point on the circle but as a screen coordinate, to go
     **** ****     > ADC
0001 2A18 1701  14        jnc  !
0002 2A1A B347  18        ab   rone,ra
0003               !:
0004 2A1C B360  30        ab   @T,ra
     2A1E 00D1     
                   < elite.a99
8655 2A20 D80D  30        movb ra,@K6+3                   ; STA K6+3          ; along with the screen x-coordinate in K6(1 0)
     2A22 0085     
8656               
8657 2A24 D360  30        movb @FLAG,ra                   ; LDA FLAG          ; If FLAG = 0, jump down to BL1
     2A26 00A3     
8658 2A28 1310  14        jeq  BL1                        ; BEQ BL1
8659               
8660 2A2A B347  18        ab   rone,ra                    ; INC FLAG          ; Flag is &FF so this is the first call to BLINE, so
8661                                                                          ; increment FLAG to set it to 0, as then the next time
8662                                                                          ; we call BLINE it can draw the first line, from this
8663                                                                          ; point to the next
8664               
8665               BL5:
8666                                                                          ; The following inserts a &FF marker into the LSY2 line
8667                                                                          ; heap to indicate that the next call to BLINE should
8668                                                                          ; store both the (X1, Y1) and (X2, Y2) points. We do
8669                                                                          ; this on the very first call to BLINE (when FLAG is
8670                                                                          ; &FF), and on subsequent calls if the segment does not
8671                                                                          ; fit on-screen, in which case we don't draw or store
8672                                                                          ; that segment, and we start a new segment with the next
8673                                                                          ; call to BLINE that does fit on-screen
8674 2A2C D3E0  30        movb @LSP,ry                    ; LDY LSP           ; If byte LSP-1 of LSY2 = &FF, jump to BL7 to tidy up
     2A2E 0077     
8675 2A30 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; and return from the subroutine, as the point that has
     2A32 FF00     
8676 2A34 06CF  14        swpb ry                         ;
8677 2A36 936F  34        cb   @LSY2-1(ry),ra             ; CMP LSY2-1,Y      ; been passed to BLINE is the start of a segment, so all
     2A38 0E73     
8678 2A3A 06CF  14        swpb ry                         ;
8679 2A3C 136A  14        jeq  BL7                        ; BEQ BL7           ; we need to do is save the coordinate in K5, without
8680                                                                          ; moving the pointer in LSP
8681               
8682 2A3E 06CF  14        swpb ry                         ;
8683 2A40 DBCD  38        movb ra,@LSY2(ry)               ; STA LSY2,Y        ; Otherwise we just tried to plot a segment but it
     2A42 0E74     
8684 2A44 06CF  14        swpb ry                         ;
8685                                                                          ; didn't fit on-screen, so put the &FF marker into the
8686                                                                          ; heap for this point, so the next call to BLINE starts
8687                                                                          ; a new segment
8688               
8689 2A46 B347  18        ab   rone,ra                    ; INC LSP           ; Increment LSP to point to the next point in the heap
8690               
8691 2A48 1664  14        jne  BL7                        ; BNE BL7           ; Jump to BL7 to tidy up and return from the subroutine
8692                                                                          ; (this BNE is effectively a JMP, as LSP will never be
8693                                                                          ; zero)
8694               
8695               BL1:
8696 2A4A D360  30        movb @K5,ra                     ; LDA K5            ; Set XX15 = K5 = x_lo of previous point
     2A4C 007E     
8697 2A4E D80D  30        movb ra,@XX15                   ; STA XX15
     2A50 0031     
8698               
8699 2A52 D360  30        movb @K5+1,ra                   ; LDA K5+1          ; Set XX15+1 = K5+1 = x_hi of previous point
     2A54 007F     
8700 2A56 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     2A58 0032     
8701               
8702 2A5A D360  30        movb @K5+2,ra                   ; LDA K5+2          ; Set XX15+2 = K5+2 = y_lo of previous point
     2A5C 0080     
8703 2A5E D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     2A60 0033     
8704               
8705 2A62 D360  30        movb @K5+3,ra                   ; LDA K5+3          ; Set XX15+3 = K5+3 = y_hi of previous point
     2A64 0081     
8706 2A66 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     2A68 0034     
8707               
8708 2A6A D360  30        movb @K6,ra                     ; LDA K6            ; Set XX15+4 = x_lo of new point
     2A6C 0082     
8709 2A6E D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     2A70 0035     
8710               
8711 2A72 D360  30        movb @K6+1,ra                   ; LDA K6+1          ; Set XX15+5 = x_hi of new point
     2A74 0083     
8712 2A76 D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     2A78 0036     
8713               
8714 2A7A D360  30        movb @K6+2,ra                   ; LDA K6+2          ; Set XX12 = y_lo of new point
     2A7C 0084     
8715 2A7E D80D  30        movb ra,@XX12                   ; STA XX12
     2A80 0037     
8716               
8717 2A82 D360  30        movb @K6+3,ra                   ; LDA K6+3          ; Set XX12+1 = y_hi of new point
     2A84 0085     
8718 2A86 D80D  30        movb ra,@XX12+1                 ; STA XX12+1
     2A88 0038     
8719               
8720 2A8A 0200  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the new line segment needs to be
     2A8C EED8     
8721 2A8E 06A0  32        bl   @jsr                       ;
     2A90 FE28     
8722                                                                          ; clipped to fit on-screen, returning the clipped line's
8723                                                                          ; end-points in (X1, Y1) and (X2, Y2)
8724               
8725 2A92 18CC  14        joc  BL5                        ; BCS BL5           ; If the C flag is set then the line is not visible on
8726                                                                          ; screen anyway, so jump to BL5, to avoid drawing and
8727                                                                          ; storing this line
8728               
8729 2A94 D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0, then we didn't have to swap the line
     2A96 00A1     
8730 2A98 1310  14        jeq  BL9                        ; BEQ BL9           ; coordinates around during the clipping process, so
8731                                                                          ; jump to BL9 to skip the following swap
8732               
8733 2A9A D360  30        movb @X1,ra                     ; LDA X1            ; Otherwise the coordinates were swapped by the call to
     2A9C 0031     
8734 2A9E D3E0  30        movb @X2,ry                     ; LDY X2            ; LL145 above, so we swap (X1, Y1) and (X2, Y2) back
     2AA0 0033     
8735 2AA2 D80D  30        movb ra,@X2                     ; STA X2            ; again
     2AA4 0033     
8736 2AA6 D80F  30        movb ry,@X1                     ; STY X1
     2AA8 0031     
8737 2AAA D360  30        movb @Y1,ra                     ; LDA Y1
     2AAC 0032     
8738 2AAE D3E0  30        movb @Y2,ry                     ; LDY Y2
     2AB0 0034     
8739 2AB2 D80D  30        movb ra,@Y2                     ; STA Y2
     2AB4 0034     
8740 2AB6 D80F  30        movb ry,@Y1                     ; STY Y1
     2AB8 0032     
8741               
8742               BL9:
8743 2ABA D3E0  30        movb @LSP,ry                    ; LDY LSP           ; Set Y = LSP
     2ABC 0077     
8744               
8745 2ABE 06CF  14        swpb ry                         ;
8746 2AC0 D36F  34        movb @LSY2-1(ry),ra             ; LDA LSY2-1,Y      ; If byte LSP-1 of LSY2 is not &FF, jump down to BL8
     2AC2 0E73     
8747 2AC4 06CF  14        swpb ry                         ;
8748 2AC6 028D  22        ci   ra,>ff*256                 ; CMP #&FF          ; to skip the following (X1, Y1) code
     2AC8 FF00     
8749 2ACA 160D  14        jne  BL8                        ; BNE BL8
8750               
8751                                                                          ; Byte LSP-1 of LSY2 is &FF, which indicates that we
8752                                                                          ; need to store (X1, Y1) in the heap
8753               
8754 2ACC D360  30        movb @X1,ra                     ; LDA X1            ; Store X1 in the LSP-th byte of LSX2
     2ACE 0031     
8755 2AD0 06CF  14        swpb ry                         ;
8756 2AD2 DBCD  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     2AD4 0E26     
8757 2AD6 06CF  14        swpb ry                         ;
8758               
8759 2AD8 D360  30        movb @Y1,ra                     ; LDA Y1            ; Store Y1 in the LSP-th byte of LSY2
     2ADA 0032     
8760 2ADC 06CF  14        swpb ry                         ;
8761 2ADE DBCD  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2AE0 0E74     
8762 2AE2 06CF  14        swpb ry                         ;
8763               
8764 2AE4 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8765               
8766               BL8:
8767 2AE6 D360  30        movb @X2,ra                     ; LDA X2            ; Store X2 in the LSP-th byte of LSX2
     2AE8 0033     
8768 2AEA 06CF  14        swpb ry                         ;
8769 2AEC DBCD  38        movb ra,@LSX2(ry)               ; STA LSX2,Y
     2AEE 0E26     
8770 2AF0 06CF  14        swpb ry                         ;
8771               
8772 2AF2 D360  30        movb @Y2,ra                     ; LDA Y2            ; Store Y2 in the LSP-th byte of LSX2
     2AF4 0034     
8773 2AF6 06CF  14        swpb ry                         ;
8774 2AF8 DBCD  38        movb ra,@LSY2(ry)               ; STA LSY2,Y
     2AFA 0E74     
8775 2AFC 06CF  14        swpb ry                         ;
8776               
8777 2AFE B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2
8778               
8779 2B00 D80F  30        movb ry,@LSP                    ; STY LSP           ; Update LSP to point to the same as Y
     2B02 0077     
8780               
8781 2B04 0200  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     2B06 23BE     
8782 2B08 06A0  32        bl   @jsr                       ;
     2B0A FE28     
8783               
8784 2B0C D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, jump up to BL5 to add a &FF
     2B0E 0098     
8785 2B10 168D  14        jne  BL5                        ; BNE BL5           ; marker to the end of the line heap. XX13 is non-zero
8786                                                                          ; after the call to the clipping routine LL145 above if
8787                                                                          ; the end of the line was clipped, meaning the next line
8788                                                                          ; sent to BLINE can't join onto the end but has to start
8789                                                                          ; a new segment, and that's what inserting the &FF
8790                                                                          ; marker does
8791               
8792               BL7:
8793 2B12 D360  30        movb @K6,ra                     ; LDA K6            ; Copy the data for this step point from K6(3 2 1 0)
     2B14 0082     
8794 2B16 D80D  30        movb ra,@K5                     ; STA K5            ; into K5(3 2 1 0), for use in the next call to BLINE:
     2B18 007E     
8795 2B1A D360  30        movb @K6+1,ra                   ; LDA K6+1          ;
     2B1C 0083     
8796 2B1E D80D  30        movb ra,@K5+1                   ; STA K5+1          ; * K5(1 0) = screen x-coordinate of this point
     2B20 007F     
8797 2B22 D360  30        movb @K6+2,ra                   ; LDA K6+2          ;
     2B24 0084     
8798 2B26 D80D  30        movb ra,@K5+2                   ; STA K5+2          ; * K5(3 2) = screen y-coordinate of this point
     2B28 0080     
8799 2B2A D360  30        movb @K6+3,ra                   ; LDA K6+3          ;
     2B2C 0085     
8800 2B2E D80D  30        movb ra,@K5+3                   ; STA K5+3          ; They now become the "previous point" in the next call
     2B30 0081     
8801               
8802 2B32 D360  30        movb @CNT,ra                    ; LDA CNT           ; Set CNT = CNT + STP
     2B34 00A4     
8803                      .clc                            ; CLC
     **** ****     > CLC
0001 2B36 0A16  18        sla  rzero,1
                   < elite.a99
8804                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 2B38 1701  14        jnc  !
0002 2B3A B347  18        ab   rone,ra
0003               !:
0004 2B3C B360  30        ab   @STP,ra
     2B3E 00A6     
                   < elite.a99
8805 2B40 D80D  30        movb ra,@CNT                    ; STA CNT
     2B42 00A4     
8806               
8807 2B44 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2B46 FE34     
8808               
8809               * ******************************************************************************
8810               *
8811               * Name: FLIP
8812               * Type: Subroutine
8813               * Category: Stardust
8814               * Summary: Reflect the stardust particles in the screen diagonal and redraw
8815               * the stardust field
8816               *
8817               * ------------------------------------------------------------------------------
8818               *
8819               * Swap the x- and y-coordinates of all the stardust particles and draw the new
8820               * set of particles. Called by LOOK1 when we switch views.
8821               *
8822               * This is a quick way of making the stardust field in the new view feel
8823               * different without having to generate a whole new field. If you look carefully
8824               * at the stardust field when you switch views, you can just about see that the
8825               * new field is a reflection of the previous field in the screen diagonal, i.e.
8826               * in the line from bottom left to top right. This is the line where x = y when
8827               * the origin is in the middle of the screen, and positive x and y are right and
8828               * up, which is the coordinate system we use for stardust).
8829               *
8830               * ******************************************************************************
8831               
8832               FLIP:
8833               * LDA MJ                 \ These instructions are commented out in the original
8834               * BNE FLIP-1             \ source. They would have the effect of not swapping the
8835                                                                          ; stardust if we had mis-jumped into witchspace
8836 2B48 D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2B4A 0F33     
8837                                                                          ; we can use it as a counter through all the stardust
8838               
8839               FLL1:
8840 2B4C 06CF  14        swpb ry                         ;
8841 2B4E D3AF  34        movb @SY(ry),rx                 ; LDX SY,Y          ; Copy the Y-th particle's y-coordinate from SY+Y into X
     2B50 0EC2     
8842 2B52 06CF  14        swpb ry                         ;
8843               
8844 2B54 06CF  14        swpb ry                         ;
8845 2B56 D36F  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Copy the Y-th particle's x-coordinate from SX+Y into
     2B58 034C     
8846 2B5A 06CF  14        swpb ry                         ;
8847 2B5C D80D  30        movb ra,@Y1                     ; STA Y1            ; both Y1 and the particle's y-coordinate
     2B5E 0032     
8848 2B60 06CF  14        swpb ry                         ;
8849 2B62 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y
     2B64 0EC2     
8850 2B66 06CF  14        swpb ry                         ;
8851               
8852 2B68 D34E  18        movb rx,ra                      ; TXA               ; Copy the Y-th particle's original y-coordinate into
8853 2B6A D80D  30        movb ra,@X1                     ; STA X1            ; both X1 and the particle's x-coordinate, so the x- and
     2B6C 0031     
8854 2B6E 06CF  14        swpb ry                         ;
8855 2B70 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; y-coordinates are now swapped and (X1, Y1) contains
     2B72 034C     
8856 2B74 06CF  14        swpb ry                         ;
8857                                                                          ; the particle's new coordinates
8858               
8859 2B76 06CF  14        swpb ry                         ;
8860 2B78 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th particle's distance from SZ+Y into ZZ
     2B7A 0EE8     
8861 2B7C 06CF  14        swpb ry                         ;
8862 2B7E D80D  30        movb ra,@ZZ                     ; STA ZZ
     2B80 0097     
8863               
8864 2B82 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     2B84 2924     
8865 2B86 06A0  32        bl   @jsr                       ;
     2B88 FE28     
8866               
8867 2B8A 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
8868                                                                          ; stardust
8869               
8870 2B8C 16DF  14        jne  FLL1                       ; BNE FLL1          ; Loop back to FLL1 until we have moved all the stardust
8871                                                                          ; particles
8872               
8873 2B8E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2B90 FE34     
8874               
8875               * ******************************************************************************
8876               *
8877               * Name: STARS
8878               * Type: Subroutine
8879               * Category: Stardust
8880               * Summary: The main routine for processing the stardust
8881               *
8882               * ------------------------------------------------------------------------------
8883               *
8884               * Called at the very end of the main flight loop.
8885               *
8886               * ******************************************************************************
8887               
8888               STARS:
8889               * LDA #&FF               \ These instructions are commented out in the original
8890               * STA COL                \ source, but they would set the stardust colour to
8891                                                                          ; white. That said, COL is only used when updating the
8892                                                                          ; dashboard, so this would have no effect - perhaps it's
8893                                                                          ; left over from experiments with a colour top part of
8894                                                                          ; the screen? Who knows...
8895 2B92 D3A0  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     2B94 0D5F     
8896                                                                          ;
8897                                                                          ; 0 = front
8898                                                                          ; 1 = rear
8899                                                                          ; 2 = left
8900                                                                          ; 3 = right
8901               
8902 2B96 1306  14        jeq  STARS1                     ; BEQ STARS1        ; If this 0, jump to STARS1 to process the stardust for
8903                                                                          ; the front view
8904               
8905 2B98 7387  18        sb   rone,rx                    ; DEX               ; If this is view 2 or 3, jump to STARS2 (via ST11) to
8906 2B9A 1602  14        jne  ST11                       ; BNE ST11          ; process the stardust for the left or right views
8907               
8908 2B9C 0460  28        b    @STARS6                    ; JMP STARS6        ; Otherwise this is the rear view, so jump to STARS6 to
     2B9E 2DEA     
8909                                                                          ; process the stardust for the rear view
8910               
8911               ST11:
8912 2BA0 0460  28        b    @STARS2                    ; JMP STARS2        ; Jump to STARS2 for the left or right views, as it's
     2BA2 4264     
8913                                                                          ; too far for the branch instruction above
8914               
8915               * ******************************************************************************
8916               *
8917               * Name: STARS1
8918               * Type: Subroutine
8919               * Category: Stardust
8920               * Summary: Process the stardust for the front view
8921               * Deep dive: Stardust in the front view
8922               *
8923               * ------------------------------------------------------------------------------
8924               *
8925               * This moves the stardust towards us according to our speed (so the dust rushes
8926               * past us), and applies our current pitch and roll to each particle of dust, so
8927               * the stardust moves correctly when we steer our ship.
8928               *
8929               * When a stardust particle rushes past us and falls off the side of the screen,
8930               * its memory is recycled as a new particle that's positioned randomly on-screen.
8931               *
8932               * These are the calculations referred to in the commentary:
8933               *
8934               * 1. q = 64 * speed / z_hi
8935               * 2. z = z - speed * 64
8936               * 3. y = y + |y_hi| * q
8937               * 4. x = x + |x_hi| * q
8938               *
8939               * 5. y = y + alpha * x / 256
8940               * 6. x = x - alpha * y / 256
8941               *
8942               * 7. x = x + 2 * (beta * y / 256) ^ 2
8943               * 8. y = y - beta * 256
8944               *
8945               * For more information see the deep dive on "Stardust in the front view".
8946               *
8947               * ******************************************************************************
8948               
8949               STARS1:
8950 2BA4 D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2BA6 0F33     
8951                                                                          ; we can use it as a counter through all the stardust
8952               
8953                                                                          ; In the following, we're going to refer to the 16-bit
8954                                                                          ; space coordinates of the current particle of stardust
8955                                                                          ; (i.e. the Y-th particle) like this:
8956                                                                          ;
8957                                                                          ; x = (x_hi x_lo)
8958                                                                          ; y = (y_hi y_lo)
8959                                                                          ; z = (z_hi z_lo)
8960                                                                          ;
8961                                                                          ; These values are stored in (SX+Y SXL+Y), (SY+Y SYL+Y)
8962                                                                          ; and (SZ+Y SZL+Y) respectively
8963               
8964               STL1:
8965 2BA8 0200  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     2BAA 494C     
8966 2BAC 06A0  32        bl   @jsr                       ;
     2BAE FE28     
8967                                                                          ;
8968                                                                          ; (P R) = 256 * DELTA / z_hi
8969                                                                          ; = 256 * speed / z_hi
8970                                                                          ;
8971                                                                          ; The maximum value returned is P = 2 and R = 128 (see
8972                                                                          ; DV42 for an explanation)
8973               
8974 2BB0 D360  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     2BB2 0091     
8975                                                                          ;
8976                                                                          ; (P A) = 256 * speed / z_hi
8977               
8978                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 2BB4 D020  30        movb @P,rtmp
     2BB6 001B     
0002 2BB8 0910  18        srl  rtmp,1
0003 2BBA D800  30        movb rtmp,@P
     2BBC 001B     
                   < elite.a99
8979 2BBE 06A0  32        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     2BC0 FE62     
8980                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 2BC2 D020  30        movb @P,rtmp
     2BC4 001B     
0002 2BC6 0910  18        srl  rtmp,1
0003 2BC8 D800  30        movb rtmp,@P
     2BCA 001B     
                   < elite.a99
8981 2BCC 06A0  32        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     2BCE FE62     
8982               
8983 2BD0 026D  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     2BD2 0100     
8984 2BD4 D80D  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     2BD6 0090     
8985                                                                          ;
8986                                                                          ; Q = 64 * speed / z_hi
8987               
8988 2BD8 06CF  14        swpb ry                         ;
8989 2BDA D36F  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     2BDC 0EFB     
8990 2BDE 06CF  14        swpb ry                         ;
8991                      .sbc @DELT4,ra                  ; SBC DELT4         ;
     **** ****     > SBC
0001 2BE0 1801  14        joc  !
0002 2BE2 7347  18        sb   rone,ra
0003               !:
0004 2BE4 7360  30        sb   @DELT4,ra
     2BE6 008D     
                   < elite.a99
8992 2BE8 06CF  14        swpb ry                         ;
8993 2BEA DBCD  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) - DELT4(1 0)
     2BEC 0EFB     
8994 2BEE 06CF  14        swpb ry                         ;
8995                                                                          ;
8996                                                                          ; starting with the low bytes
8997               
8998 2BF0 06CF  14        swpb ry                         ;
8999 2BF2 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     2BF4 0EE8     
9000 2BF6 06CF  14        swpb ry                         ;
9001 2BF8 D80D  30        movb ra,@ZZ                     ; STA ZZ            ;
     2BFA 0097     
9002                      .sbc @DELT4+1,ra                ; SBC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > SBC
0001 2BFC 1801  14        joc  !
0002 2BFE 7347  18        sb   rone,ra
0003               !:
0004 2C00 7360  30        sb   @DELT4+1,ra
     2C02 008E     
                   < elite.a99
9003 2C04 06CF  14        swpb ry                         ;
9004 2C06 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2C08 0EE8     
9005 2C0A 06CF  14        swpb ry                         ;
9006                                                                          ;
9007                                                                          ; So now we have result 2 above:
9008                                                                          ;
9009                                                                          ; z = z - DELT4(1 0)
9010                                                                          ; = z - speed * 64
9011               
9012 2C0C 0200  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2C0E 4662     
9013 2C10 06A0  32        bl   @jsr                       ;
     2C12 FE28     
9014                                                                          ;
9015                                                                          ; Y1 = y_hi
9016                                                                          ;
9017                                                                          ; (A P) = |y_hi| * Q
9018                                                                          ;
9019                                                                          ; So Y1 contains the original value of y_hi, which we
9020                                                                          ; use below to remove the existing particle
9021               
9022                                                                          ; We now calculate:
9023                                                                          ;
9024                                                                          ; (S R) = YY(1 0) = (A P) + y
9025               
9026 2C14 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2C16 0027     
9027 2C18 D360  30        movb @P,ra                      ; LDA P             ;
     2C1A 001B     
9028 2C1C 06CF  14        swpb ry                         ;
9029                      .adc @SYL(ry),ra                ; ADC SYL,Y         ; YY+1 = A
     **** ****     > ADC
0001 2C1E 1701  14        jnc  !
0002 2C20 B347  18        ab   rone,ra
0003               !:
0004 2C22 B36F  34        ab   @SYL(RY),ra
     2C24 0ED5     
                   < elite.a99
9030 2C26 06CF  14        swpb ry                         ;
9031 2C28 D80D  30        movb ra,@YY                     ; STA YY            ; R = YY = P + y_lo
     2C2A 0026     
9032 2C2C D80D  30        movb ra,@R                      ; STA R             ;
     2C2E 0091     
9033                                                                          ; so we get this:
9034                                                                          ;
9035                                                                          ; (? R) = YY(1 0) = (A P) + y_lo
9036               
9037 2C30 D360  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2C32 0032     
9038                      .adc @YY+1,ra                   ; ADC YY+1          ;
     **** ****     > ADC
0001 2C34 1701  14        jnc  !
0002 2C36 B347  18        ab   rone,ra
0003               !:
0004 2C38 B360  30        ab   @YY+1,ra
     2C3A 0027     
                   < elite.a99
9039 2C3C D80D  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi + YY+1
     2C3E 0027     
9040 2C40 D80D  30        movb ra,@S                      ; STA S             ;
     2C42 0092     
9041                                                                          ; so we get our result:
9042                                                                          ;
9043                                                                          ; (S R) = YY(1 0) = (A P) + (y_hi y_lo)
9044                                                                          ; = |y_hi| * Q + y
9045                                                                          ;
9046                                                                          ; which is result 3 above, and (S R) is set to the new
9047                                                                          ; value of y
9048               
9049 2C44 06CF  14        swpb ry                         ;
9050 2C46 D36F  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2C48 034C     
9051 2C4A 06CF  14        swpb ry                         ;
9052 2C4C D80D  30        movb ra,@X1                     ; STA X1            ;
     2C4E 0031     
9053                                                                          ; So X1 contains the original value of x_hi, which we
9054                                                                          ; use below to remove the existing particle
9055               
9056 2C50 0200  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2C52 466E     
9057 2C54 06A0  32        bl   @jsr                       ;
     2C56 FE28     
9058               
9059                                                                          ; We now calculate:
9060                                                                          ;
9061                                                                          ; XX(1 0) = (A P) + x
9062               
9063 2C58 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2C5A 0025     
9064 2C5C D360  30        movb @P,ra                      ; LDA P             ;
     2C5E 001B     
9065 2C60 06CF  14        swpb ry                         ;
9066                      .adc @SXL(ry),ra                ; ADC SXL,Y         ; XX(1 0) = (A P) + x_lo
     **** ****     > ADC
0001 2C62 1701  14        jnc  !
0002 2C64 B347  18        ab   rone,ra
0003               !:
0004 2C66 B36F  34        ab   @SXL(RY),ra
     2C68 035F     
                   < elite.a99
9067 2C6A 06CF  14        swpb ry                         ;
9068 2C6C D80D  30        movb ra,@XX                     ; STA XX
     2C6E 0024     
9069               
9070 2C70 D360  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2C72 0031     
9071                      .adc @XX+1,ra                   ; ADC XX+1          ;
     **** ****     > ADC
0001 2C74 1701  14        jnc  !
0002 2C76 B347  18        ab   rone,ra
0003               !:
0004 2C78 B360  30        ab   @XX+1,ra
     2C7A 0025     
                   < elite.a99
9072 2C7C D80D  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = XX(1 0) + (x_hi 0)
     2C7E 0025     
9073                                                                          ;
9074                                                                          ; so we get our result:
9075                                                                          ;
9076                                                                          ; XX(1 0) = (A P) + x
9077                                                                          ; = |x_hi| * Q + x
9078                                                                          ;
9079                                                                          ; which is result 4 above, and we also have:
9080                                                                          ;
9081                                                                          ; A = XX+1 = (|x_hi| * Q + x) / 256
9082                                                                          ;
9083                                                                          ; i.e. A is the new value of x, divided by 256
9084               
9085                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2C80 D020  30        movb @ALP2+1,rtmp
     2C82 0089     
0002 2C84 2B40  18        xor  rtmp,ra
                   < elite.a99
9086                                                                          ; A has the opposite sign to the flipped roll angle
9087                                                                          ; alpha, i.e. it gets the same sign as alpha
9088               
9089 2C86 0200  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2C88 4582     
9090 2C8A 06A0  32        bl   @jsr                       ;
     2C8C FE28     
9091                                                                          ;
9092                                                                          ; (A P) = A * ALP1
9093                                                                          ; = (x / 256) * alpha
9094               
9095 2C8E 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2C90 4862     
9096 2C92 06A0  32        bl   @jsr                       ;
     2C94 FE28     
9097                                                                          ;
9098                                                                          ; (A X) = (A P) + (S R)
9099                                                                          ; = (x / 256) * alpha + y
9100                                                                          ; = y + alpha * x / 256
9101               
9102 2C96 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2C98 0027     
9103 2C9A D80E  30        movb rx,@YY                     ; STX YY            ;
     2C9C 0026     
9104                                                                          ; YY(1 0) = y + alpha * x / 256
9105                                                                          ;
9106                                                                          ; which is result 5 above, and we also have:
9107                                                                          ;
9108                                                                          ; A = YY+1 = y + alpha * x / 256
9109                                                                          ;
9110                                                                          ; i.e. A is the new value of y, divided by 256
9111               
9112                      .eor @ALP2                      ; EOR ALP2          ; EOR A with the correct sign of the roll angle alpha,
     **** ****     > EOR
0001 2C9E D020  30        movb @ALP2,rtmp
     2CA0 0088     
0002 2CA2 2B40  18        xor  rtmp,ra
                   < elite.a99
9113                                                                          ; so A has the opposite sign to the roll angle alpha
9114               
9115 2CA4 0200  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2CA6 4572     
9116 2CA8 06A0  32        bl   @jsr                       ;
     2CAA FE28     
9117                                                                          ;
9118                                                                          ; (S R) = XX(1 0)
9119                                                                          ; = x
9120                                                                          ;
9121                                                                          ; (A P) = A * ALP1
9122                                                                          ; = -y / 256 * alpha
9123               
9124 2CAC 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2CAE 4862     
9125 2CB0 06A0  32        bl   @jsr                       ;
     2CB2 FE28     
9126                                                                          ;
9127                                                                          ; (A X) = (A P) + (S R)
9128                                                                          ; = -y / 256 * alpha + x
9129               
9130 2CB4 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2CB6 0025     
9131 2CB8 D80E  30        movb rx,@XX                     ; STX XX            ;
     2CBA 0024     
9132                                                                          ; x = x - alpha * y / 256
9133               
9134 2CBC D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2CBE 002B     
9135               
9136 2CC0 D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2CC2 0027     
9137                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2CC4 D020  30        movb @BET2+1,rtmp
     2CC6 008B     
0002 2CC8 2B40  18        xor  rtmp,ra
                   < elite.a99
9138               
9139 2CCA 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2CCC 4588     
9140 2CCE 06A0  32        bl   @jsr                       ;
     2CD0 FE28     
9141                                                                          ;
9142                                                                          ; (A P) = X * A
9143                                                                          ; = -beta * y_hi
9144               
9145 2CD2 D80D  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2CD4 0090     
9146                                                                          ;
9147                                                                          ; Q = -beta * y_hi / 256
9148               
9149 2CD6 0200  20        li   rtmp,MUT2                  ; JSR MUT2          ; Call MUT2 to calculate:
     2CD8 4780     
9150 2CDA 06A0  32        bl   @jsr                       ;
     2CDC FE28     
9151                                                                          ;
9152                                                                          ; (S R) = XX(1 0) = x
9153                                                                          ;
9154                                                                          ; (A P) = Q * A
9155                                                                          ; = (-beta * y_hi / 256) * (-beta * y_hi / 256)
9156                                                                          ; = (beta * y / 256) ^ 2
9157               
9158                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2CDE D020  30        movb @P,rtmp
     2CE0 001B     
0002 2CE2 0240  22        andi rtmp,>ff00
     2CE4 FF00     
0003 2CE6 0A10  18        sla  rtmp,1
0004 2CE8 D800  30        movb rtmp,@P
     2CEA 001B     
                   < elite.a99
9159 2CEC 06A0  32        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2CEE FE3E     
9160 2CF0 D80D  30        movb ra,@T                      ; STA T             ;
     2CF2 00D1     
9161                                                                          ; (T P) = (A P) << 1
9162                                                                          ; = 2 * (beta * y / 256) ^ 2
9163               
9164 2CF4 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2CF6 0000     
9165 2CF8 06A0  32        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2CFA FE62     
9166 2CFC F360  30        socb @T,ra                      ; ORA T             ;
     2CFE 00D1     
9167                                                                          ; (A P) = (A P) * 2
9168                                                                          ; = 2 * (beta * y / 256) ^ 2
9169                                                                          ;
9170                                                                          ; with the doubling retaining the sign of (A P)
9171               
9172 2D00 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2D02 4862     
9173 2D04 06A0  32        bl   @jsr                       ;
     2D06 FE28     
9174                                                                          ;
9175                                                                          ; (A X) = (A P) + (S R)
9176                                                                          ; = 2 * (beta * y / 256) ^ 2 + x
9177               
9178 2D08 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2D0A 0025     
9179               
9180 2D0C D34E  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
9181 2D0E 06CF  14        swpb ry                         ;
9182 2D10 DBCD  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2D12 035F     
9183 2D14 06CF  14        swpb ry                         ;
9184               
9185                                                                          ; So (XX+1 x_lo) now contains:
9186                                                                          ;
9187                                                                          ; x = x + 2 * (beta * y / 256) ^ 2
9188                                                                          ;
9189                                                                          ; which is result 7 above
9190               
9191 2D16 D360  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2D18 0026     
9192 2D1A D80D  30        movb ra,@R                      ; STA R
     2D1C 0091     
9193 2D1E D360  30        movb @YY+1,ra                   ; LDA YY+1
     2D20 0027     
9194               * JSR MAD                \ These instructions are commented out in the original
9195               * STA S                  \ source
9196               * STX R
9197 2D22 D80D  30        movb ra,@S                      ; STA S
     2D24 0092     
9198               
9199 2D26 020D  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2D28 0000     
9200 2D2A D80D  30        movb ra,@P                      ; STA P
     2D2C 001B     
9201               
9202 2D2E D360  30        movb @BETA,ra                   ; LDA BETA          ; Set A = -beta, so:
     2D30 002A     
9203                      .eoi (>80*256)                  ; EOR #%10000000    ;
     **** ****     > EOI
0001 2D32 0200  20        li   rtmp,(>80*256)
     2D34 8000     
0002 2D36 2B40  18        xor  rtmp,ra
                   < elite.a99
9204                                                                          ; (A P) = (-beta 0)
9205                                                                          ; = -beta * 256
9206               
9207 2D38 0200  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2D3A 290E     
9208 2D3C 06A0  32        bl   @jsr                       ;
     2D3E FE28     
9209                                                                          ;
9210                                                                          ; (YY+1 y_lo) = (A P) + (S R)
9211                                                                          ; = -beta * 256 + y
9212                                                                          ;
9213                                                                          ; i.e. y = y - beta * 256, which is result 8 above
9214                                                                          ;
9215                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
9216                                                                          ; ZZ, which will remove the old stardust particle, as we
9217                                                                          ; set X1, Y1 and ZZ to the original values for this
9218                                                                          ; particle during the calculations above
9219               
9220                                                                          ; We now have our newly moved stardust particle at
9221                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
9222                                                                          ; and distance z_hi, so we draw it if it's still on
9223                                                                          ; screen, otherwise we recycle it as a new bit of
9224                                                                          ; stardust and draw that
9225               
9226 2D40 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2D42 0025     
9227 2D44 D80D  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2D46 0031     
9228 2D48 06CF  14        swpb ry                         ;
9229 2D4A DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2D4C 034C     
9230 2D4E 06CF  14        swpb ry                         ;
9231               
9232 2D50 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 120 then jump to KILL1 to recycle this
     2D52 7F00     
9233 2D54 028D  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the side of the screen,
     2D56 7800     
9234 2D58 1820  14        joc  KILL1                      ; BCS KILL1         ; and rejoin at STC1 with the new particle
9235               
9236 2D5A D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2D5C 0027     
9237 2D5E 06CF  14        swpb ry                         ;
9238 2D60 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2D62 0EC2     
9239 2D64 06CF  14        swpb ry                         ;
9240 2D66 D80D  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2D68 0032     
9241               
9242 2D6A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 120 then jump to KILL1 to recycle this
     2D6C 7F00     
9243 2D6E 028D  22        ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the top or bottom of the
     2D70 7800     
9244 2D72 1813  14        joc  KILL1                      ; BCS KILL1         ; screen, and rejoin at STC1 with the new particle
9245               
9246 2D74 06CF  14        swpb ry                         ;
9247 2D76 D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi < 16 then jump to KILL1 to recycle this
     2D78 0EE8     
9248 2D7A 06CF  14        swpb ry                         ;
9249 2D7C 028D  22        ci   ra,>10*256                 ; CMP #16           ; particle, as it's so close that it's effectively gone
     2D7E 1000     
9250 2D80 170C  14        jnc  KILL1                      ; BCC KILL1         ; past us, and rejoin at STC1 with the new particle
9251               
9252 2D82 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2D84 0097     
9253               
9254               STC1:
9255 2D86 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2D88 2924     
9256 2D8A 06A0  32        bl   @jsr                       ;
     2D8C FE28     
9257                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9258                                                                          ; with distance z_hi
9259               
9260 2D8E 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9261                                                                          ; stardust particle
9262               
9263 2D90 1302  14        jeq  B18                        ; BEQ B18           ; If we have just done the last particle, skip the next
9264                                                                          ; instruction to return from the subroutine
9265               
9266 2D92 0460  28        b    @STL1                      ; JMP STL1          ; We have more stardust to process, so jump back up to
     2D94 2BA8     
9267                                                                          ; STL1 for the next particle
9268               
9269               B18:
9270 2D96 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2D98 FE34     
9271               
9272               KILL1:
9273                                                                          ; Our particle of stardust just flew past us, so let's
9274                                                                          ; recycle that particle, starting it at a random
9275                                                                          ; position that isn't too close to the centre point
9276 2D9A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2D9C C7D0     
9277 2D9E 06A0  32        bl   @jsr                       ;
     2DA0 FE28     
9278               
9279 2DA2 026D  22        ori  ra,>04*256                 ; ORA #4            ; Make sure A is at least 4 and store it in Y1 and y_hi,
     2DA4 0400     
9280 2DA6 D80D  30        movb ra,@Y1                     ; STA Y1            ; so the new particle starts at least 4 pixels above or
     2DA8 0032     
9281 2DAA 06CF  14        swpb ry                         ;
9282 2DAC DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; below the centre of the screen
     2DAE 0EC2     
9283 2DB0 06CF  14        swpb ry                         ;
9284               
9285 2DB2 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2DB4 C7D0     
9286 2DB6 06A0  32        bl   @jsr                       ;
     2DB8 FE28     
9287               
9288 2DBA 026D  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in X1 and x_hi,
     2DBC 0800     
9289 2DBE D80D  30        movb ra,@X1                     ; STA X1            ; so the new particle starts at least 8 pixels either
     2DC0 0031     
9290 2DC2 06CF  14        swpb ry                         ;
9291 2DC4 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; side of the centre of the screen
     2DC6 034C     
9292 2DC8 06CF  14        swpb ry                         ;
9293               
9294 2DCA 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2DCC C7D0     
9295 2DCE 06A0  32        bl   @jsr                       ;
     2DD0 FE28     
9296               
9297 2DD2 026D  22        ori  ra,>90*256                 ; ORA #144          ; Make sure A is at least 144 and store it in ZZ and
     2DD4 9000     
9298 2DD6 06CF  14        swpb ry                         ;
9299 2DD8 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; z_hi so the new particle starts in the far distance
     2DDA 0EE8     
9300 2DDC 06CF  14        swpb ry                         ;
9301 2DDE D80D  30        movb ra,@ZZ                     ; STA ZZ
     2DE0 0097     
9302               
9303 2DE2 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A to the new value of y_hi. This has no effect as
     2DE4 0032     
9304                                                                          ; STC1 starts with a jump to PIXEL2, which starts with a
9305                                                                          ; LDA instruction
9306               
9307 2DE6 0460  28        b    @STC1                      ; JMP STC1          ; Jump up to STC1 to draw this new particle
     2DE8 2D86     
9308               
9309               * ******************************************************************************
9310               *
9311               * Name: STARS6
9312               * Type: Subroutine
9313               * Category: Stardust
9314               * Summary: Process the stardust for the rear view
9315               *
9316               * ------------------------------------------------------------------------------
9317               *
9318               * This routine is very similar to STARS1, which processes stardust for the front
9319               * view. The main difference is that the direction of travel is reversed, so the
9320               * signs in the calculations are different, as well as the order of the first
9321               * batch of calculations.
9322               *
9323               * When a stardust particle falls away into the far distance, it is removed from
9324               * the screen and its memory is recycled as a new particle, positioned randomly
9325               * along one of the four edges of the screen.
9326               *
9327               * These are the calculations referred to in the commentary:
9328               *
9329               * 1. q = 64 * speed / z_hi
9330               * 2. z = z - speed * 64
9331               * 3. y = y + |y_hi| * q
9332               * 4. x = x + |x_hi| * q
9333               *
9334               * 5. y = y + alpha * x / 256
9335               * 6. x = x - alpha * y / 256
9336               *
9337               * 7. x = x + 2 * (beta * y / 256) ^ 2
9338               * 8. y = y - beta * 256
9339               *
9340               * For more information see the deep dive on "Stardust in the front view".
9341               *
9342               * ******************************************************************************
9343               
9344               STARS6:
9345 2DEA D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     2DEC 0F33     
9346                                                                          ; we can use it as a counter through all the stardust
9347               
9348               STL6:
9349 2DEE 0200  20        li   rtmp,DV42                  ; JSR DV42          ; Call DV42 to set the following:
     2DF0 494C     
9350 2DF2 06A0  32        bl   @jsr                       ;
     2DF4 FE28     
9351                                                                          ;
9352                                                                          ; (P R) = 256 * DELTA / z_hi
9353                                                                          ; = 256 * speed / z_hi
9354                                                                          ;
9355                                                                          ; The maximum value returned is P = 2 and R = 128 (see
9356                                                                          ; DV42 for an explanation)
9357               
9358 2DF6 D360  30        movb @R,ra                      ; LDA R             ; Set A = R, so now:
     2DF8 0091     
9359                                                                          ;
9360                                                                          ; (P A) = 256 * speed / z_hi
9361               
9362                      .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
     **** ****     > LSR
0001 2DFA D020  30        movb @P,rtmp
     2DFC 001B     
0002 2DFE 0910  18        srl  rtmp,1
0003 2E00 D800  30        movb rtmp,@P
     2E02 001B     
                   < elite.a99
9363 2E04 06A0  32        bl   @rora                      ; ROR A             ; has a maximum value of 2) and leaves:
     2E06 FE62     
9364                      .lsr @P                         ; LSR P             ;
     **** ****     > LSR
0001 2E08 D020  30        movb @P,rtmp
     2E0A 001B     
0002 2E0C 0910  18        srl  rtmp,1
0003 2E0E D800  30        movb rtmp,@P
     2E10 001B     
                   < elite.a99
9365 2E12 06A0  32        bl   @rora                      ; ROR A             ; A = 64 * speed / z_hi
     2E14 FE62     
9366               
9367 2E16 026D  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
     2E18 0100     
9368 2E1A D80D  30        movb ra,@Q                      ; STA Q             ; now have result 1 above:
     2E1C 0090     
9369                                                                          ;
9370                                                                          ; Q = 64 * speed / z_hi
9371               
9372 2E1E 06CF  14        swpb ry                         ;
9373 2E20 D36F  34        movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
     2E22 034C     
9374 2E24 06CF  14        swpb ry                         ;
9375 2E26 D80D  30        movb ra,@X1                     ; STA X1            ;
     2E28 0031     
9376                                                                          ; So X1 contains the original value of x_hi, which we
9377                                                                          ; use below to remove the existing particle
9378               
9379 2E2A 0200  20        li   rtmp,MLU2                  ; JSR MLU2          ; Set (A P) = |x_hi| * Q
     2E2C 466E     
9380 2E2E 06A0  32        bl   @jsr                       ;
     2E30 FE28     
9381               
9382                                                                          ; We now calculate:
9383                                                                          ;
9384                                                                          ; XX(1 0) = x - (A P)
9385               
9386 2E32 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
     2E34 0025     
9387 2E36 06CF  14        swpb ry                         ;
9388 2E38 D36F  34        movb @SXL(ry),ra                ; LDA SXL,Y         ;
     2E3A 035F     
9389 2E3C 06CF  14        swpb ry                         ;
9390                      .sbc @P,ra                      ; SBC P             ; XX(1 0) = x_lo - (A P)
     **** ****     > SBC
0001 2E3E 1801  14        joc  !
0002 2E40 7347  18        sb   rone,ra
0003               !:
0004 2E42 7360  30        sb   @P,ra
     2E44 001B     
                   < elite.a99
9391 2E46 D80D  30        movb ra,@XX                     ; STA XX
     2E48 0024     
9392               
9393 2E4A D360  30        movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
     2E4C 0031     
9394                      .sbc @XX+1,ra                   ; SBC XX+1          ;
     **** ****     > SBC
0001 2E4E 1801  14        joc  !
0002 2E50 7347  18        sb   rone,ra
0003               !:
0004 2E52 7360  30        sb   @XX+1,ra
     2E54 0025     
                   < elite.a99
9395 2E56 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = (x_hi 0) - XX(1 0)
     2E58 0025     
9396                                                                          ;
9397                                                                          ; so we get our result:
9398                                                                          ;
9399                                                                          ; XX(1 0) = x - (A P)
9400                                                                          ; = x - |x_hi| * Q
9401                                                                          ;
9402                                                                          ; which is result 2 above, and we also have:
9403               
9404 2E5A 0200  20        li   rtmp,MLU1                  ; JSR MLU1          ; Call MLU1 to set:
     2E5C 4662     
9405 2E5E 06A0  32        bl   @jsr                       ;
     2E60 FE28     
9406                                                                          ;
9407                                                                          ; Y1 = y_hi
9408                                                                          ;
9409                                                                          ; (A P) = |y_hi| * Q
9410                                                                          ;
9411                                                                          ; So Y1 contains the original value of y_hi, which we
9412                                                                          ; use below to remove the existing particle
9413               
9414                                                                          ; We now calculate:
9415                                                                          ;
9416                                                                          ; (S R) = YY(1 0) = y - (A P)
9417               
9418 2E62 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
     2E64 0027     
9419 2E66 06CF  14        swpb ry                         ;
9420 2E68 D36F  34        movb @SYL(ry),ra                ; LDA SYL,Y         ;
     2E6A 0ED5     
9421 2E6C 06CF  14        swpb ry                         ;
9422                      .sbc @P,ra                      ; SBC P             ; YY+1 = A
     **** ****     > SBC
0001 2E6E 1801  14        joc  !
0002 2E70 7347  18        sb   rone,ra
0003               !:
0004 2E72 7360  30        sb   @P,ra
     2E74 001B     
                   < elite.a99
9423 2E76 D80D  30        movb ra,@YY                     ; STA YY            ; R = YY = y_lo - P
     2E78 0026     
9424 2E7A D80D  30        movb ra,@R                      ; STA R             ;
     2E7C 0091     
9425                                                                          ; so we get this:
9426                                                                          ;
9427                                                                          ; (? R) = YY(1 0) = y_lo - (A P)
9428               
9429 2E7E D360  30        movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
     2E80 0032     
9430                      .sbc @YY+1,ra                   ; SBC YY+1          ;
     **** ****     > SBC
0001 2E82 1801  14        joc  !
0002 2E84 7347  18        sb   rone,ra
0003               !:
0004 2E86 7360  30        sb   @YY+1,ra
     2E88 0027     
                   < elite.a99
9431 2E8A D80D  30        movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi - YY+1
     2E8C 0027     
9432 2E8E D80D  30        movb ra,@S                      ; STA S             ;
     2E90 0092     
9433                                                                          ; so we get our result:
9434                                                                          ;
9435                                                                          ; (S R) = YY(1 0) = (y_hi y_lo) - (A P)
9436                                                                          ; = y - |y_hi| * Q
9437                                                                          ;
9438                                                                          ; which is result 3 above, and (S R) is set to the new
9439                                                                          ; value of y
9440               
9441 2E92 06CF  14        swpb ry                         ;
9442 2E94 D36F  34        movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
     2E96 0EFB     
9443 2E98 06CF  14        swpb ry                         ;
9444                      .adc @DELT4,ra                  ; ADC DELT4         ;
     **** ****     > ADC
0001 2E9A 1701  14        jnc  !
0002 2E9C B347  18        ab   rone,ra
0003               !:
0004 2E9E B360  30        ab   @DELT4,ra
     2EA0 008D     
                   < elite.a99
9445 2EA2 06CF  14        swpb ry                         ;
9446 2EA4 DBCD  38        movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) + DELT4(1 0)
     2EA6 0EFB     
9447 2EA8 06CF  14        swpb ry                         ;
9448                                                                          ;
9449                                                                          ; starting with the low bytes
9450               
9451 2EAA 06CF  14        swpb ry                         ;
9452 2EAC D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
     2EAE 0EE8     
9453 2EB0 06CF  14        swpb ry                         ;
9454 2EB2 D80D  30        movb ra,@ZZ                     ; STA ZZ            ;
     2EB4 0097     
9455                      .adc @DELT4+1,ra                ; ADC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
     **** ****     > ADC
0001 2EB6 1701  14        jnc  !
0002 2EB8 B347  18        ab   rone,ra
0003               !:
0004 2EBA B360  30        ab   @DELT4+1,ra
     2EBC 008E     
                   < elite.a99
9456 2EBE 06CF  14        swpb ry                         ;
9457 2EC0 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
     2EC2 0EE8     
9458 2EC4 06CF  14        swpb ry                         ;
9459                                                                          ;
9460                                                                          ; So now we have result 4 above:
9461                                                                          ;
9462                                                                          ; z = z + DELT4(1 0)
9463                                                                          ; = z + speed * 64
9464               
9465 2EC6 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; EOR x with the correct sign of the roll angle alpha,
     2EC8 0025     
9466                      .eor @ALP2                      ; EOR ALP2          ; so A has the opposite sign to the roll angle alpha
     **** ****     > EOR
0001 2ECA D020  30        movb @ALP2,rtmp
     2ECC 0088     
0002 2ECE 2B40  18        xor  rtmp,ra
                   < elite.a99
9467               
9468 2ED0 0200  20        li   rtmp,MLS1                  ; JSR MLS1          ; Call MLS1 to calculate:
     2ED2 4582     
9469 2ED4 06A0  32        bl   @jsr                       ;
     2ED6 FE28     
9470                                                                          ;
9471                                                                          ; (A P) = A * ALP1
9472                                                                          ; = (-x / 256) * alpha
9473               
9474 2ED8 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2EDA 4862     
9475 2EDC 06A0  32        bl   @jsr                       ;
     2EDE FE28     
9476                                                                          ;
9477                                                                          ; (A X) = (A P) + (S R)
9478                                                                          ; = (-x / 256) * alpha + y
9479                                                                          ; = y - alpha * x / 256
9480               
9481 2EE0 D80D  30        movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
     2EE2 0027     
9482 2EE4 D80E  30        movb rx,@YY                     ; STX YY            ;
     2EE6 0026     
9483                                                                          ; YY(1 0) = y - alpha * x / 256
9484                                                                          ;
9485                                                                          ; which is result 5 above, and we also have:
9486                                                                          ;
9487                                                                          ; A = YY+1 = y - alpha * x / 256
9488                                                                          ;
9489                                                                          ; i.e. A is the new value of y, divided by 256
9490               
9491                      .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
     **** ****     > EOR
0001 2EE8 D020  30        movb @ALP2+1,rtmp
     2EEA 0089     
0002 2EEC 2B40  18        xor  rtmp,ra
                   < elite.a99
9492                                                                          ; A has the opposite sign to the flipped roll angle
9493                                                                          ; alpha, i.e. it gets the same sign as alpha
9494               
9495 2EEE 0200  20        li   rtmp,MLS2                  ; JSR MLS2          ; Call MLS2 to calculate:
     2EF0 4572     
9496 2EF2 06A0  32        bl   @jsr                       ;
     2EF4 FE28     
9497                                                                          ;
9498                                                                          ; (S R) = XX(1 0)
9499                                                                          ; = x
9500                                                                          ;
9501                                                                          ; (A P) = A * ALP1
9502                                                                          ; = y / 256 * alpha
9503               
9504 2EF6 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2EF8 4862     
9505 2EFA 06A0  32        bl   @jsr                       ;
     2EFC FE28     
9506                                                                          ;
9507                                                                          ; (A X) = (A P) + (S R)
9508                                                                          ; = y / 256 * alpha + x
9509               
9510 2EFE D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
     2F00 0025     
9511 2F02 D80E  30        movb rx,@XX                     ; STX XX            ;
     2F04 0024     
9512                                                                          ; x = x + alpha * y / 256
9513               
9514 2F06 D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
     2F08 0027     
9515                      .eor @BET2+1                    ; EOR BET2+1
     **** ****     > EOR
0001 2F0A D020  30        movb @BET2+1,rtmp
     2F0C 008B     
0002 2F0E 2B40  18        xor  rtmp,ra
                   < elite.a99
9516               
9517 2F10 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X
     2F12 002B     
9518               
9519 2F14 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     2F16 4588     
9520 2F18 06A0  32        bl   @jsr                       ;
     2F1A FE28     
9521                                                                          ;
9522                                                                          ; (A P) = X * A
9523                                                                          ; = beta * y_hi
9524               
9525 2F1C D80D  30        movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
     2F1E 0090     
9526                                                                          ;
9527                                                                          ; Q = beta * y_hi / 256
9528               
9529 2F20 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set S = x_hi
     2F22 0025     
9530 2F24 D80D  30        movb ra,@S                      ; STA S
     2F26 0092     
9531               
9532                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A, so A now contains -x
     **** ****     > EOI
0001 2F28 0200  20        li   rtmp,(>80*256)
     2F2A 8000     
0002 2F2C 2B40  18        xor  rtmp,ra
                   < elite.a99
9533               
9534 2F2E 0200  20        li   rtmp,MUT1                  ; JSR MUT1          ; Call MUT1 to calculate:
     2F30 4788     
9535 2F32 06A0  32        bl   @jsr                       ;
     2F34 FE28     
9536                                                                          ;
9537                                                                          ; R = XX = x_lo
9538                                                                          ;
9539                                                                          ; (A P) = Q * A
9540                                                                          ; = (beta * y_hi / 256) * (-beta * y_hi / 256)
9541                                                                          ; = (-beta * y / 256) ^ 2
9542               
9543                      .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
     **** ****     > ASL
0001 2F36 D020  30        movb @P,rtmp
     2F38 001B     
0002 2F3A 0240  22        andi rtmp,>ff00
     2F3C FF00     
0003 2F3E 0A10  18        sla  rtmp,1
0004 2F40 D800  30        movb rtmp,@P
     2F42 001B     
                   < elite.a99
9544 2F44 06A0  32        bl   @rola                      ; ROL A             ; flag to bit 7 of the original A, so this does:
     2F46 FE3E     
9545 2F48 D80D  30        movb ra,@T                      ; STA T             ;
     2F4A 00D1     
9546                                                                          ; (T P) = (A P) << 1
9547                                                                          ; = 2 * (-beta * y / 256) ^ 2
9548               
9549 2F4C 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
     2F4E 0000     
9550 2F50 06A0  32        bl   @rora                      ; ROR A             ; calculation above and apply it to T, so we now have:
     2F52 FE62     
9551 2F54 F360  30        socb @T,ra                      ; ORA T             ;
     2F56 00D1     
9552                                                                          ; (A P) = -2 * (beta * y / 256) ^ 2
9553                                                                          ;
9554                                                                          ; with the doubling retaining the sign of (A P)
9555               
9556 2F58 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     2F5A 4862     
9557 2F5C 06A0  32        bl   @jsr                       ;
     2F5E FE28     
9558                                                                          ;
9559                                                                          ; (A X) = (A P) + (S R)
9560                                                                          ; = -2 * (beta * y / 256) ^ 2 + x
9561               
9562 2F60 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     2F62 0025     
9563               
9564 2F64 D34E  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
9565 2F66 06CF  14        swpb ry                         ;
9566 2F68 DBCD  38        movb ra,@SXL(ry)                ; STA SXL,Y
     2F6A 035F     
9567 2F6C 06CF  14        swpb ry                         ;
9568               
9569                                                                          ; So (XX+1 x_lo) now contains:
9570                                                                          ;
9571                                                                          ; x = x - 2 * (beta * y / 256) ^ 2
9572                                                                          ;
9573                                                                          ; which is result 7 above
9574               
9575 2F6E D360  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
     2F70 0026     
9576 2F72 D80D  30        movb ra,@R                      ; STA R
     2F74 0091     
9577 2F76 D360  30        movb @YY+1,ra                   ; LDA YY+1
     2F78 0027     
9578 2F7A D80D  30        movb ra,@S                      ; STA S
     2F7C 0092     
9579               
9580               * EOR #128               \ These instructions are commented out in the original
9581               * JSR MAD                \ source
9582               * STA S
9583               * STX R
9584               
9585 2F7E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     2F80 0000     
9586 2F82 D80D  30        movb ra,@P                      ; STA P
     2F84 001B     
9587               
9588 2F86 D360  30        movb @BETA,ra                   ; LDA BETA          ; Set A = beta, so (A P) = (beta 0) = beta * 256
     2F88 002A     
9589               
9590 2F8A 0200  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     2F8C 290E     
9591 2F8E 06A0  32        bl   @jsr                       ;
     2F90 FE28     
9592                                                                          ;
9593                                                                          ; (YY+1 y_lo) = (A P) + (S R)
9594                                                                          ; = beta * 256 + y
9595                                                                          ;
9596                                                                          ; i.e. y = y + beta * 256, which is result 8 above
9597                                                                          ;
9598                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
9599                                                                          ; ZZ, which will remove the old stardust particle, as we
9600                                                                          ; set X1, Y1 and ZZ to the original values for this
9601                                                                          ; particle during the calculations above
9602               
9603                                                                          ; We now have our newly moved stardust particle at
9604                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
9605                                                                          ; and distance z_hi, so we draw it if it's still on
9606                                                                          ; screen, otherwise we recycle it as a new bit of
9607                                                                          ; stardust and draw that
9608               
9609 2F92 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     2F94 0025     
9610 2F96 D80D  30        movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
     2F98 0031     
9611 2F9A 06CF  14        swpb ry                         ;
9612 2F9C DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1
     2F9E 034C     
9613 2FA0 06CF  14        swpb ry                         ;
9614               
9615 2FA2 D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     2FA4 0027     
9616 2FA6 06CF  14        swpb ry                         ;
9617 2FA8 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     2FAA 0EC2     
9618 2FAC 06CF  14        swpb ry                         ;
9619 2FAE D80D  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     2FB0 0032     
9620               
9621 2FB2 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 110 then jump to KILL6 to recycle this
     2FB4 7F00     
9622 2FB6 028D  22        ci   ra,>6e*256                 ; CMP #110          ; particle, as it's gone off the top or bottom of the
     2FB8 6E00     
9623 2FBA 1813  14        joc  KILL6                      ; BCS KILL6         ; screen, and rejoin at STC6 with the new particle
9624               
9625 2FBC 06CF  14        swpb ry                         ;
9626 2FBE D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi >= 160 then jump to KILL6 to recycle this
     2FC0 0EE8     
9627 2FC2 06CF  14        swpb ry                         ;
9628 2FC4 028D  22        ci   ra,>a0*256                 ; CMP #160          ; particle, as it's so far away that it's too far to
     2FC6 A000     
9629 2FC8 180C  14        joc  KILL6                      ; BCS KILL6         ; see, and rejoin at STC1 with the new particle
9630               
9631 2FCA D80D  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi
     2FCC 0097     
9632               
9633               STC6:
9634 2FCE 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     2FD0 2924     
9635 2FD2 06A0  32        bl   @jsr                       ;
     2FD4 FE28     
9636                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
9637                                                                          ; with distance z_hi
9638               
9639 2FD6 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
9640                                                                          ; stardust particle
9641               
9642 2FD8 1302  14        jeq  ST3                        ; BEQ ST3           ; If we have just done the last particle, skip the next
9643                                                                          ; instruction to return from the subroutine
9644               
9645 2FDA 0460  28        b    @STL6                      ; JMP STL6          ; We have more stardust to process, so jump back up to
     2FDC 2DEE     
9646                                                                          ; STL6 for the next particle
9647               
9648               ST3:
9649 2FDE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     2FE0 FE34     
9650               
9651               KILL6:
9652 2FE2 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     2FE4 C7D0     
9653 2FE6 06A0  32        bl   @jsr                       ;
     2FE8 FE28     
9654               
9655 2FEA 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of A to get |A|
     2FEC 7F00     
9656               
9657                      .adi (>0a*256)                  ; ADC #10           ; Make sure A is at least 10 and store it in z_hi and
     **** ****     > ADI
0001 2FEE 1701  14        jnc  !
0002 2FF0 B347  18        ab   rone,ra
0003               !:
0004 2FF2 022D  22        ai   ra,(>0A*256)
     2FF4 0A00     
                   < elite.a99
9658 2FF6 06CF  14        swpb ry                         ;
9659 2FF8 DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; ZZ, so the new particle starts close to us
     2FFA 0EE8     
9660 2FFC 06CF  14        swpb ry                         ;
9661 2FFE D80D  30        movb ra,@ZZ                     ; STA ZZ
     3000 0097     
9662               
9663 3002 091D  18        srl  ra,1                       ; LSR A             ; Divide A by 2 and randomly set the C flag
9664               
9665 3004 1817  14        joc  ST4                        ; BCS ST4           ; Jump to ST4 half the time
9666               
9667 3006 091D  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag again
9668               
9669 3008 020D  20        li   ra,>fc*256                 ; LDA #252          ; Set A to either +126 or -126 (252 >> 1) depending on
     300A FC00     
9670 300C 06A0  32        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     300E FE62     
9671                                                                          ; the C flag rotated into its sign bit
9672               
9673 3010 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on
     3012 0031     
9674 3014 06CF  14        swpb ry                         ;
9675 3016 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; either the left or right edge of the screen
     3018 034C     
9676 301A 06CF  14        swpb ry                         ;
9677               
9678 301C 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     301E C7D0     
9679 3020 06A0  32        bl   @jsr                       ;
     3022 FE28     
9680               
9681 3024 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     3026 0032     
9682 3028 06CF  14        swpb ry                         ;
9683 302A DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along either the left or right edge
     302C 0EC2     
9684 302E 06CF  14        swpb ry                         ;
9685               
9686 3030 0460  28        b    @STC6                      ; JMP STC6          ; Jump up to STC6 to draw this new particle
     3032 2FCE     
9687               
9688               ST4:
9689 3034 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3036 C7D0     
9690 3038 06A0  32        bl   @jsr                       ;
     303A FE28     
9691               
9692 303C D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     303E 0031     
9693 3040 06CF  14        swpb ry                         ;
9694 3042 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     3044 034C     
9695 3046 06CF  14        swpb ry                         ;
9696               
9697 3048 091D  18        srl  ra,1                       ; LSR A             ; Randomly set the C flag
9698               
9699 304A 020D  20        li   ra,>e6*256                 ; LDA #230          ; Set A to either +115 or -115 (230 >> 1) depending on
     304C E600     
9700 304E 06A0  32        bl   @rora                      ; ROR A             ; the C flag, as this is a sign-magnitude number with
     3050 FE62     
9701                                                                          ; the C flag rotated into its sign bit
9702               
9703 3052 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts anywhere
     3054 0032     
9704 3056 06CF  14        swpb ry                         ;
9705 3058 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; along either the top or bottom edge of the screen
     305A 0EC2     
9706 305C 06CF  14        swpb ry                         ;
9707               
9708 305E 16B7  14        jne  STC6                       ; BNE STC6          ; Jump up to STC6 to draw this new particle (this BNE is
9709                                                                          ; effectively a JMP as A will never be zero)
9710               
9711               * ******************************************************************************
9712               *
9713               * Name: PRXS
9714               * Type: Variable
9715               * Category: Equipment
9716               * Summary: Equipment prices
9717               *
9718               * ------------------------------------------------------------------------------
9719               *
9720               * Equipment prices are stored as 10 * the actual value, so we can support prices
9721               * with fractions of credits (0.1 Cr). This is used for the price of fuel only.
9722               *
9723               * ******************************************************************************
9724               
9725               PRXS:
9726 3060 0100            data >0100                                          ; 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)
9727 3062 2C01            data >2c01                                          ; 1  Missile                     30.0 Cr
9728 3064 A00F            data >a00f                                          ; 2  Large Cargo Bay            400.0 Cr
9729 3066 7017            data >7017                                          ; 3  E.C.M. System              600.0 Cr
9730 3068 A00F            data >a00f                                          ; 4  Extra Pulse Lasers         400.0 Cr
9731 306A 1027            data >1027                                          ; 5  Extra Beam Lasers         1000.0 Cr
9732 306C 8214            data >8214                                          ; 6  Fuel Scoops                525.0 Cr
9733 306E 1027            data >1027                                          ; 7  Escape Pod                1000.0 Cr
9734 3070 2823            data >2823                                          ; 8  Energy Bomb                900.0 Cr
9735 3072 983A            data >983a                                          ; 9  Energy Unit               1500.0 Cr
9736 3074 1027            data >1027                                          ; 10 Docking Computer          1000.0 Cr
9737 3076 50C3            data >50c3                                          ; 11 Galactic Hyperspace       5000.0 Cr
9738               
9739               * ******************************************************************************
9740               *
9741               * Name: STATUS
9742               * Type: Subroutine
9743               * Category: Status
9744               * Summary: Show the Status Mode screen (red key f8)
9745               * Deep dive: Combat rank
9746               *
9747               * ******************************************************************************
9748               
9749               st4_:
9750                                                                          ; We call this from st5 below with the high byte of the
9751                                                                          ; kill tally in A, which is non-zero, and want to return
9752                                                                          ; with the following in X, depending on our rating:
9753                                                                          ;
9754                                                                          ; Competent = 6
9755                                                                          ; Dangerous = 7
9756                                                                          ; Deadly    = 8
9757                                                                          ; Elite     = 9
9758                                                                          ;
9759                                                                          ; The high bytes of the top tier ratings are as follows,
9760                                                                          ; so this a relatively simple calculation:
9761                                                                          ;
9762                                                                          ; Competent       = 1 to 2
9763                                                                          ; Dangerous       = 2 to 9
9764                                                                          ; Deadly          = 10 to 24
9765                                                                          ; Elite           = 25 and up
9766 3078 020E  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 for an Elite rating
     307A 0900     
9767               
9768 307C 028D  22        ci   ra,>19*256                 ; CMP #25           ; If A >= 25, jump to st3 to print out our rating, as we
     307E 1900     
9769 3080 185E  14        joc  st3_                       ; BCS st3           ; are Elite
9770               
9771 3082 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to 8 for a Deadly rating
9772               
9773 3084 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to st3 to print out our rating, as we
     3086 0A00     
9774 3088 185A  14        joc  st3_                       ; BCS st3           ; are Deadly
9775               
9776 308A 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to 7 for a Dangerous rating
9777               
9778 308C 028D  22        ci   ra,>02*256                 ; CMP #2            ; If A >= 2, jump to st3 to print out our rating, as we
     308E 0200     
9779 3090 1856  14        joc  st3_                       ; BCS st3           ; are Dangerous
9780               
9781 3092 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to 6 for a Competent rating
9782               
9783 3094 1654  14        jne  st3_                       ; BNE st3           ; Jump to st3 to print out our rating, as we are
9784                                                                          ; Competent (this BNE is effectively a JMP as A will
9785                                                                          ; never be zero)
9786               
9787               STATUS:
9788 3096 020D  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     3098 0800     
9789 309A 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Status
     309C 4EFA     
9790 309E 06A0  32        bl   @jsr                       ;
     30A0 FE28     
9791                                                                          ; Mode screen)
9792               
9793 30A2 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     30A4 A000     
9794 30A6 06A0  32        bl   @jsr                       ;
     30A8 FE28     
9795                                                                          ; (QQ9, QQ10)
9796               
9797 30AA 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     30AC 0700     
9798 30AE D80D  30        movb ra,@XC                     ; STA XC
     30B0 002C     
9799               
9800 30B2 020D  20        li   ra,>7e*256                 ; LDA #126          ; Print recursive token 126, which prints the top
     30B4 7E00     
9801 30B6 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; four lines of the Status Mode screen:
     30B8 2738     
9802 30BA 06A0  32        bl   @jsr                       ;
     30BC FE28     
9803                                                                          ;
9804                                                                          ; COMMANDER {commander name}
9805                                                                          ;
9806                                                                          ;
9807                                                                          ; Present System      : {current system name}
9808                                                                          ; Hyperspace System   : {selected system name}
9809                                                                          ; Condition           :
9810                                                                          ;
9811                                                                          ; and draw a horizontal line at pixel row 19 to box
9812                                                                          ; in the title
9813               
9814 30BE 020D  20        li   ra,>0f*256                 ; LDA #15           ; Set A to token 129 ("{sentence case}DOCKED")
     30C0 0F00     
9815               
9816 30C2 D3E0  30        movb @QQ12,ry                   ; LDY QQ12          ; Fetch the docked status from QQ12, and if we are
     30C4 009F     
9817 30C6 1611  14        jne  st6_                       ; BNE st6           ; docked, jump to st6 to print "Docked" for our
9818                                                                          ; ship's condition
9819               
9820 30C8 020D  20        li   ra,>e6*256                 ; LDA #230          ; Otherwise we are in space, so start off by setting A
     30CA E600     
9821                                                                          ; to token 70 ("GREEN")
9822               
9823 30CC D3E0  30        movb @MANY+AST,ry               ; LDY MANY+AST      ; Set Y to the number of asteroids in our local bubble
     30CE 0D57     
9824                                                                          ; of universe
9825               
9826 30D0 06CF  14        swpb ry                         ;
9827 30D2 D3AF  34        movb @FRIN+2(ry),rx             ; LDX FRIN+2,Y      ; The ship slots at FRIN are ordered with the first two
     30D4 0D42     
9828 30D6 06CF  14        swpb ry                         ;
9829                                                                          ; slots reserved for the planet and sun/space station,
9830                                                                          ; and then any ships, so if the slot at FRIN+2+Y is not
9831                                                                          ; empty (i.e. is non-zero), then that means the number
9832                                                                          ; of non-asteroids in the vicinity is at least 1
9833               
9834 30D8 1308  14        jeq  st6_                       ; BEQ st6           ; So if X = 0, there are no ships in the vicinity, so
9835                                                                          ; jump to st6 to print "Green" for our ship's condition
9836               
9837 30DA D3E0  30        movb @ENERGY,ry                 ; LDY ENERGY        ; Otherwise we have ships in the vicinity, so we load
     30DC 0F13     
9838                                                                          ; our energy levels into Y
9839               
9840 30DE 028F  22        ci   ry,>80*256                 ; CPY #128          ; Set the C flag if Y >= 128, so C is set if we have
     30E0 8000     
9841                                                                          ; more than half of our energy banks charged
9842               
9843                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have low
     **** ****     > ADI
0001 30E2 1701  14        jnc  !
0002 30E4 B347  18        ab   rone,ra
0003               !:
0004 30E6 022D  22        ai   ra,(>01*256)
     30E8 0100     
                   < elite.a99
9844                                                                          ; energy levels) then A is set to token 231 ("RED"),
9845                                                                          ; and if C is set (i.e. we have healthy energy levels)
9846                                                                          ; then A is set to token 232 ("YELLOW")
9847               
9848               st6_:
9849 30EA 0200  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our ship's
     30EC AC88     
9850 30EE 06A0  32        bl   @jsr                       ;
     30F0 FE28     
9851                                                                          ; condition) followed by a newline
9852               
9853 30F2 020D  20        li   ra,>7d*256                 ; LDA #125          ; Print recursive token 125, which prints the next
     30F4 7D00     
9854 30F6 0200  20        li   rtmp,spc_                  ; JSR spc           ; three lines of the Status Mode screen:
     30F8 52E6     
9855 30FA 06A0  32        bl   @jsr                       ;
     30FC FE28     
9856                                                                          ;
9857                                                                          ; Fuel: {fuel level} Light Years
9858                                                                          ; Cash: {cash} Cr
9859                                                                          ; Legal Status:
9860                                                                          ;
9861                                                                          ; followed by a space
9862               
9863 30FE 020D  20        li   ra,>13*256                 ; LDA #19           ; Set A to token 133 ("CLEAN")
     3100 1300     
9864               
9865 3102 D3E0  30        movb @FIST,ry                   ; LDY FIST          ; Fetch our legal status, and if it is 0, we are clean,
     3104 0334     
9866 3106 1306  14        jeq  st5_                       ; BEQ st5           ; so jump to st5 to print "Clean"
9867               
9868 3108 028F  22        ci   ry,>32*256                 ; CPY #50           ; Set the C flag if Y >= 50, so C is set if we have
     310A 3200     
9869                                                                          ; a legal status of 50+ (i.e. we are a fugitive)
9870               
9871                      .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have a
     **** ****     > ADI
0001 310C 1701  14        jnc  !
0002 310E B347  18        ab   rone,ra
0003               !:
0004 3110 022D  22        ai   ra,(>01*256)
     3112 0100     
                   < elite.a99
9872                                                                          ; legal status between 1 and 49) then A is set to token
9873                                                                          ; 134 ("OFFENDER"), and if C is set (i.e. we have a
9874                                                                          ; legal status of 50+) then A is set to token 135
9875                                                                          ; ("FUGITIVE")
9876               
9877               st5_:
9878 3114 0200  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A (which contains our legal
     3116 AC88     
9879 3118 06A0  32        bl   @jsr                       ;
     311A FE28     
9880                                                                          ; status) followed by a newline
9881               
9882 311C 020D  20        li   ra,>10*256                 ; LDA #16           ; Print recursive token 130 ("RATING:") followed by a
     311E 1000     
9883 3120 0200  20        li   rtmp,spc_                  ; JSR spc           ; space
     3122 52E6     
9884 3124 06A0  32        bl   @jsr                       ;
     3126 FE28     
9885               
9886 3128 D360  30        movb @TALLY+1,ra                ; LDA TALLY+1       ; Fetch the high byte of the kill tally, and if it is
     312A 0348     
9887 312C 16A5  14        jne  st4_                       ; BNE st4           ; not zero, then we have more than 256 kills, so jump
9888                                                                          ; to st4 to work out whether we are Competent,
9889                                                                          ; Dangerous, Deadly or Elite
9890               
9891                                                                          ; Otherwise we have fewer than 256 kills, so we are one
9892                                                                          ; of Harmless, Mostly Harmless, Poor, Average or Above
9893                                                                          ; Average
9894               
9895 312E D38D  18        movb ra,rx                      ; TAX               ; Set X to 0 (as A is 0)
9896               
9897 3130 D360  30        movb @TALLY,ra                  ; LDA TALLY         ; Set A = lower byte of tally / 4
     3132 0347     
9898 3134 091D  18        srl  ra,1                       ; LSR A
9899 3136 091D  18        srl  ra,1                       ; LSR A
9900               
9901               st5L:
9902                                                                          ; We now loop through bits 2 to 7, shifting each of them
9903                                                                          ; off the end of A until there are no set bits left, and
9904                                                                          ; incrementing X for each shift, so at the end of the
9905                                                                          ; process, X contains the position of the leftmost 1 in
9906                                                                          ; A. Looking at the rank values in TALLY:
9907                                                                          ;
9908                                                                          ; Harmless        = %00000000 to %00000011
9909                                                                          ; Mostly Harmless = %00000100 to %00000111
9910                                                                          ; Poor            = %00001000 to %00001111
9911                                                                          ; Average         = %00010000 to %00011111
9912                                                                          ; Above Average   = %00100000 to %11111111
9913                                                                          ;
9914                                                                          ; we can see that the values returned by this process
9915                                                                          ; are:
9916                                                                          ;
9917                                                                          ; Harmless        = 1
9918                                                                          ; Mostly Harmless = 2
9919                                                                          ; Poor            = 3
9920                                                                          ; Average         = 4
9921                                                                          ; Above Average   = 5
9922 3138 B387  18        ab   rone,rx                    ; INX               ; Increment X for each shift
9923               
9924 313A 091D  18        srl  ra,1                       ; LSR A             ; Shift A to the right
9925               
9926 313C 16FD  14        jne  st5L                       ; BNE st5L          ; Keep looping around until A = 0, which means there are
9927                                                                          ; no set bits left in A
9928               
9929               st3_:
9930 313E D34E  18        movb rx,ra                      ; TXA               ; A now contains our rating as a value of 1 to 9, so
9931                                                                          ; transfer X to A, so we can print it out
9932               
9933                      .clc                            ; CLC               ; Print recursive token 135 + A, which will be in the
     **** ****     > CLC
0001 3140 0A16  18        sla  rzero,1
                   < elite.a99
9934                      .adi (>15*256)                  ; ADC #21           ; range 136 ("HARMLESS") to 144 ("---- E L I T E ----")
     **** ****     > ADI
0001 3142 1701  14        jnc  !
0002 3144 B347  18        ab   rone,ra
0003               !:
0004 3146 022D  22        ai   ra,(>15*256)
     3148 1500     
                   < elite.a99
9935 314A 0200  20        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     314C AC88     
9936 314E 06A0  32        bl   @jsr                       ;
     3150 FE28     
9937               
9938 3152 020D  20        li   ra,>12*256                 ; LDA #18           ; Print recursive token 132, which prints the next bit
     3154 1200     
9939 3156 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; of the Status Mode screen:
     3158 3214     
9940 315A 06A0  32        bl   @jsr                       ;
     315C FE28     
9941                                                                          ;
9942                                                                          ; EQUIPMENT:
9943                                                                          ;
9944                                                                          ; followed by a newline and an indent of 6 characters
9945               
9946 315E D360  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     3160 0316     
9947 3162 028D  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     3164 1A00     
9948 3166 1706  14        jnc  B19                        ; BCC B19           ; instructions
9949               
9950 3168 020D  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     316A 6B00     
9951 316C 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; token 107 ("LARGE CARGO{sentence case} BAY"), followed
     316E 3214     
9952 3170 06A0  32        bl   @jsr                       ;
     3172 FE28     
9953                                                                          ; by a newline and an indent of 6 characters
9954               
9955               B19:
9956 3174 D360  30        movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, skip the
     3176 0329     
9957 3178 1306  14        jeq  B20                        ; BEQ B20           ; following two instructions
9958               
9959 317A 020D  20        li   ra,>6f*256                 ; LDA #111          ; We do have fuel scoops fitted, so print recursive
     317C 6F00     
9960 317E 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; token 111 ("FUEL SCOOPS"), followed by a newline and
     3180 3214     
9961 3182 06A0  32        bl   @jsr                       ;
     3184 FE28     
9962                                                                          ; an indent of 6 characters
9963               
9964               B20:
9965 3186 D360  30        movb @ECM,ra                    ; LDA ECM           ; If we don't have an E.C.M. fitted, skip the following
     3188 0328     
9966 318A 1306  14        jeq  B21                        ; BEQ B21           ; two instructions
9967               
9968 318C 020D  20        li   ra,>6c*256                 ; LDA #108          ; We do have an E.C.M. fitted, so print recursive token
     318E 6C00     
9969 3190 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; 108 ("E.C.M.SYSTEM"), followed by a newline and an
     3192 3214     
9970 3194 06A0  32        bl   @jsr                       ;
     3196 FE28     
9971                                                                          ; indent of 6 characters
9972               
9973               B21:
9974 3198 020D  20        li   ra,>71*256                 ; LDA #113          ; We now cover the four pieces of equipment whose flags
     319A 7100     
9975 319C D80D  30        movb ra,@XX4                    ; STA XX4           ; are stored in BOMB through BOMB+3, and whose names
     319E 00A7     
9976                                                                          ; correspond with text tokens 113 through 116:
9977                                                                          ;
9978                                                                          ; BOMB+0 = BOMB  = token 113 = Energy bomb
9979                                                                          ; BOMB+1 = ENGY  = token 114 = Energy unit
9980                                                                          ; BOMB+2 = DKCMP = token 115 = Docking computer
9981                                                                          ; BOMB+3 = GHYP  = token 116 = Galactic hyperdrive
9982                                                                          ;
9983                                                                          ; We can print these out using a loop, so we set XX4 to
9984                                                                          ; 113 as a counter (and we also set A as well, to pass
9985                                                                          ; through to plf2)
9986               
9987               stqv_:
9988 31A0 D3CD  18        movb ra,ry                      ; TAY               ; Fetch byte BOMB+0 through BOMB+4 for values of XX4
9989 31A2 06CF  14        swpb ry                         ;
9990 31A4 D3AF  34        movb @BOMB-113(ry),rx           ; LDX BOMB-113,Y    ; from 113 through 117
     31A6 02B9     
9991 31A8 06CF  14        swpb ry                         ;
9992               
9993 31AA 1304  14        jeq  B22                        ; BEQ B22           ; If it is zero then we do not own that piece of
9994                                                                          ; equipment, so skip the next instruction
9995               
9996 31AC 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the recursive token in A from 113 ("ENERGY
     31AE 3214     
9997 31B0 06A0  32        bl   @jsr                       ;
     31B2 FE28     
9998                                                                          ; BOMB") through 116 ("GALACTIC HYPERSPACE "), followed
9999                                                                          ; by a newline and an indent of 6 characters
10000               
10001               B22:
10002 31B4 B347  18        ab   rone,ra                    ; INC XX4           ; Increment the counter (and A as well)
10003 31B6 D360  30        movb @XX4,ra                    ; LDA XX4
     31B8 00A7     
10004               
10005 31BA 028D  22        ci   ra,>75*256                 ; CMP #117          ; If A < 117, loop back up to stqv to print the next
     31BC 7500     
10006 31BE 17F0  14        jnc  stqv_                      ; BCC stqv          ; piece of equipment
10007               
10008 31C0 020E  20        li   rx,>00*256                 ; LDX #0            ; Now to print our ship's lasers, so set a counter in X
     31C2 0000     
10009                                                                          ; to count through the four views (0 = front, 1 = rear,
10010                                                                          ; 2 = left, 3 = right)
10011               
10012               st_:
10013 31C4 D80E  30        movb rx,@CNT                    ; STX CNT           ; Store the view number in CNT
     31C6 00A4     
10014               
10015 31C8 06CE  14        swpb rx                         ;
10016 31CA D3AE  34        movb @LASER(rx),rx              ; LDY LASER,X       ; Fetch the laser power for view X, and if we do not
     31CC 0310     
10017 31CE 06CE  14        swpb rx                         ;
10018 31D0 1319  14        jeq  st1_                       ; BEQ st1           ; have a laser fitted to that view, jump to st1 to move
10019                                                                          ; on to the next one
10020               
10021 31D2 D34E  18        movb rx,ra                      ; TXA               ; Print recursive token 96 + X, which will print from 96
10022                      .clc                            ; CLC               ; ("FRONT") through to 99 ("RIGHT"), followed by a space
     **** ****     > CLC
0001 31D4 0A16  18        sla  rzero,1
                   < elite.a99
10023                      .adi (>60*256)                  ; ADC #96
     **** ****     > ADI
0001 31D6 1701  14        jnc  !
0002 31D8 B347  18        ab   rone,ra
0003               !:
0004 31DA 022D  22        ai   ra,(>60*256)
     31DC 6000     
                   < elite.a99
10024 31DE 0200  20        li   rtmp,spc_                  ; JSR spc
     31E0 52E6     
10025 31E2 06A0  32        bl   @jsr                       ;
     31E4 FE28     
10026               
10027 31E6 020D  20        li   ra,>67*256                 ; LDA #103          ; Set A to token 103 ("PULSE LASER")
     31E8 6700     
10028               
10029 31EA D3A0  30        movb @CNT,rx                    ; LDX CNT           ; If the laser power for view X has bit 7 clear, then it
     31EC 00A4     
10030 31EE 06CE  14        swpb rx                         ;
10031 31F0 D3AE  34        movb @LASER(rx),rx              ; LDY LASER,X       ; is a pulse laser, so skip the following instruction
     31F2 0310     
10032 31F4 06CE  14        swpb rx                         ;
10033 31F6 1502  14        jgt  B23                        ; BPL B23
10034               
10035 31F8 020D  20        li   ra,>68*256                 ; LDA #104          ; Set A to token 104 ("BEAM LASER")
     31FA 6800     
10036               
10037               B23:
10038 31FC 0200  20        li   rtmp,plf2_                 ; JSR plf2          ; Print the text token in A (which contains the laser
     31FE 3214     
10039 3200 06A0  32        bl   @jsr                       ;
     3202 FE28     
10040                                                                          ; type) followed by a newline and an indent of 6
10041                                                                          ; characters
10042               
10043               st1_:
10044 3204 D3A0  30        movb @CNT,rx                    ; LDX CNT           ; Increment the counter in X and CNT to point to the
     3206 00A4     
10045 3208 B387  18        ab   rone,rx                    ; INX               ; next view
10046               
10047 320A 028E  22        ci   rx,>04*256                 ; CPX #4            ; If this isn't the last of the four views, jump back up
     320C 0400     
10048 320E 17DA  14        jnc  st_                        ; BCC st            ; to st to print out the next one
10049               
10050 3210 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3212 FE34     
10051               
10052               * ******************************************************************************
10053               *
10054               * Name: plf2
10055               * Type: Subroutine
10056               * Category: Text
10057               * Summary: Print text followed by a newline and indent of 6 characters
10058               *
10059               * ------------------------------------------------------------------------------
10060               *
10061               * Print a text token followed by a newline, and indent the next line to text
10062               * column 6.
10063               *
10064               * ------------------------------------------------------------------------------
10065               *
10066               * Arguments:
10067               *
10068               * A                   The text token to be printed
10069               *
10070               * ******************************************************************************
10071               
10072               plf2_:
10073 3214 0200  20        li   rtmp,plf_                  ; JSR plf           ; Print the text token in A followed by a newline
     3216 AC88     
10074 3218 06A0  32        bl   @jsr                       ;
     321A FE28     
10075               
10076 321C 020E  20        li   rx,>06*256                 ; LDX #6            ; Move the text cursor to column 6
     321E 0600     
10077 3220 D80E  30        movb rx,@XC                     ; STX XC
     3222 002C     
10078               
10079 3224 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3226 FE34     
10080               
10081               * ******************************************************************************
10082               *
10083               * Name: TENS
10084               * Type: Variable
10085               * Category: Text
10086               * Summary: A constant used when printing large numbers in BPRNT
10087               * Deep dive: Printing decimal numbers
10088               *
10089               * ------------------------------------------------------------------------------
10090               *
10091               * Contains the four low bytes of the value 100,000,000,000 (100 billion).
10092               *
10093               * The maximum number of digits that we can print with the BPRNT routine is 11,
10094               * so the biggest number we can print is 99,999,999,999. This maximum number
10095               * plus 1 is 100,000,000,000, which in hexadecimal is:
10096               *
10097               * & 17 48 76 E8 00
10098               *
10099               * The TENS variable contains the lowest four bytes in this number, with the
10100               * most significant byte first, i.e. 48 76 E8 00. This value is used in the
10101               * BPRNT routine when working out which decimal digits to print when printing a
10102               * number.
10103               *
10104               * ******************************************************************************
10105               
10106               TENS:
10107 3228 0000            data >0000, >0000
     322A 0000     
10108               
10109               * ******************************************************************************
10110               *
10111               * Name: pr2
10112               * Type: Subroutine
10113               * Category: Text
10114               * Summary: Print an 8-bit number, left-padded to 3 digits, and optional point
10115               *
10116               * ------------------------------------------------------------------------------
10117               *
10118               * Print the 8-bit number in X to 3 digits, left-padding with spaces for numbers
10119               * with fewer than 3 digits (so numbers < 100 are right-aligned). Optionally
10120               * include a decimal point.
10121               *
10122               * ------------------------------------------------------------------------------
10123               *
10124               * Arguments:
10125               *
10126               * X                   The number to print
10127               *
10128               * C flag              If set, include a decimal point
10129               *
10130               * ------------------------------------------------------------------------------
10131               *
10132               * Other entry points:
10133               *
10134               * pr2+2               Print the 8-bit number in X to the number of digits in A
10135               *
10136               * ******************************************************************************
10137               
10138               pr2_:
10139 322C 020D  20        li   ra,>03*256                 ; LDA #3            ; Set A to the number of digits (3)
     322E 0300     
10140               
10141 3230 020F  20        li   ry,>00*256                 ; LDY #0            ; Zero the Y register, so we can fall through into TT11
     3232 0000     
10142                                                                          ; to print the 16-bit number (Y X) to 3 digits, which
10143                                                                          ; effectively prints X to 3 digits as the high byte is
10144                                                                          ; zero
10145               
10146               * ******************************************************************************
10147               *
10148               * Name: TT11
10149               * Type: Subroutine
10150               * Category: Text
10151               * Summary: Print a 16-bit number, left-padded to n digits, and optional point
10152               *
10153               * ------------------------------------------------------------------------------
10154               *
10155               * Print the 16-bit number in (Y X) to a specific number of digits, left-padding
10156               * with spaces for numbers with fewer digits (so lower numbers will be right-
10157               * aligned). Optionally include a decimal point.
10158               *
10159               * ------------------------------------------------------------------------------
10160               *
10161               * Arguments:
10162               *
10163               * X                   The low byte of the number to print
10164               *
10165               * Y                   The high byte of the number to print
10166               *
10167               * A                   The number of digits
10168               *
10169               * C flag              If set, include a decimal point
10170               *
10171               * ******************************************************************************
10172               
10173               TT11:
10174 3234 D80D  30        movb ra,@U                      ; STA U             ; We are going to use the BPRNT routine (below) to
     3236 008F     
10175                                                                          ; print this number, so we store the number of digits
10176                                                                          ; in U, as that's what BPRNT takes as an argument
10177               
10178 3238 020D  20        li   ra,>00*256                 ; LDA #0            ; BPRNT takes a 32-bit number in K to K+3, with the
     323A 0000     
10179 323C D80D  30        movb ra,@K                      ; STA K             ; most significant byte first (big-endian), so we set
     323E 003D     
10180 3240 D80D  30        movb ra,@K+1                    ; STA K+1           ; the two most significant bytes to zero (K and K+1)
     3242 003E     
10181 3244 D80F  30        movb ry,@K+2                    ; STY K+2           ; and store (Y X) in the least two significant bytes
     3246 003F     
10182 3248 D80E  30        movb rx,@K+3                    ; STX K+3           ; (K+2 and K+3), so we are going to print the 32-bit
     324A 0040     
10183                                                                          ; number (0 0 Y X)
10184               
10185                                                                          ; Finally we fall through into BPRNT to print out the
10186                                                                          ; number in K to K+3, which now contains (Y X), to 3
10187                                                                          ; digits (as U = 3), using the same C flag as when pr2
10188                                                                          ; was called to control the decimal point
10189               
10190               * ******************************************************************************
10191               *
10192               * Name: BPRNT
10193               * Type: Subroutine
10194               * Category: Text
10195               * Summary: Print a 32-bit number, left-padded to a specific number of digits,
10196               * with an optional decimal point
10197               * Deep dive: Printing decimal numbers
10198               *
10199               * ------------------------------------------------------------------------------
10200               *
10201               * Print the 32-bit number stored in K(0 1 2 3) to a specific number of digits,
10202               * left-padding with spaces for numbers with fewer digits (so lower numbers are
10203               * right-aligned). Optionally include a decimal point.
10204               *
10205               * See the deep dive on "Printing decimal numbers" for details of the algorithm
10206               * used in this routine.
10207               *
10208               * ------------------------------------------------------------------------------
10209               *
10210               * Arguments:
10211               *
10212               * K(0 1 2 3)          The number to print, stored with the most significant
10213               * byte in K and the least significant in K+3 (i.e. as a
10214               * big-endian number, which is the opposite way to how the
10215               * 6502 assembler stores addresses, for example)
10216               *
10217               * U                   The maximum number of digits to print, including the
10218               * decimal point (spaces will be used on the left to pad
10219               * out the result to this width, so the number is right-
10220               * aligned to this width). U must be 11 or less
10221               *
10222               * C flag              If set, include a decimal point followed by one
10223               * fractional digit (i.e. show the number to 1 decimal
10224               * place). In this case, the number in K(0 1 2 3) contains
10225               * 10 * the number we end up printing, so to print 123.4,
10226               * we would pass 1234 in K(0 1 2 3) and would set the C
10227               * flag to include the decimal point
10228               *
10229               * ******************************************************************************
10230               
10231               BPRNT:
10232 324C 020E  20        li   rx,>0b*256                 ; LDX #11           ; Set T to the maximum number of digits allowed (11
     324E 0B00     
10233 3250 D80E  30        movb rx,@T                      ; STX T             ; characters, which is the number of digits in 10
     3252 00D1     
10234                                                                          ; billion). We will use this as a flag when printing
10235                                                                          ; characters in TT37 below
10236               
10237                      .php                            ; PHP               ; Make a copy of the status register (in particular
     **** ****     > PHP
0001 3254 02C0  12        stst rtmp
0002 3256 D680  30        movb rtmp,*rsp
0003 3258 060A  14        dec  rsp
                   < elite.a99
10238                                                                          ; the C flag) so we can retrieve it later
10239               
10240 325A 1702  14        jnc  TT30                       ; BCC TT30          ; If the C flag is clear, we do not want to print a
10241                                                                          ; decimal point, so skip the next two instructions
10242               
10243 325C 7347  18        sb   rone,ra                    ; DEC T             ; As we are going to show a decimal point, decrement
10244 325E 7347  18        sb   rone,ra                    ; DEC U             ; both the number of characters and the number of
10245                                                                          ; digits (as one of them is now a decimal point)
10246               
10247               TT30:
10248 3260 020D  20        li   ra,>0b*256                 ; LDA #11           ; Set A to 11, the maximum number of digits allowed
     3262 0B00     
10249               
10250                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 3264 0A18  18        sla  rmone,1
                   < elite.a99
10251                                                                          ; C flag affecting the result
10252               
10253 3266 D80D  30        movb ra,@XX17                   ; STA XX17          ; Store the maximum number of digits allowed (11) in
     3268 0095     
10254                                                                          ; XX17
10255               
10256                      .sbc @U,ra                      ; SBC U             ; Set U = 11 - U + 1, so U now contains the maximum
     **** ****     > SBC
0001 326A 1801  14        joc  !
0002 326C 7347  18        sb   rone,ra
0003               !:
0004 326E 7360  30        sb   @U,ra
     3270 008F     
                   < elite.a99
10257 3272 D80D  30        movb ra,@U                      ; STA U             ; number of digits minus the number of digits we want
     3274 008F     
10258 3276 B347  18        ab   rone,ra                    ; INC U             ; to display, plus 1 (so this is the number of digits
10259                                                                          ; we should skip before starting to print the number
10260                                                                          ; itself, and the plus 1 is there to ensure we print at
10261                                                                          ; least one digit)
10262               
10263 3278 020F  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     327A 0000     
10264                                                                          ; of times we subtract 10 billion to get the leftmost
10265                                                                          ; digit, so set this to zero
10266               
10267 327C D80F  30        movb ry,@S                      ; STY S             ; In the main loop below, we use location S as an
     327E 0092     
10268                                                                          ; 8-bit overflow for the 32-bit calculations, so
10269                                                                          ; we need to set this to 0 before joining the loop
10270               
10271 3280 0460  28        b    @TT36                      ; JMP TT36          ; Jump to TT36 to start the process of printing this
     3282 3368     
10272                                                                          ; number's digits
10273               
10274               TT35:
10275                                                                          ; This subroutine multiplies K(S 0 1 2 3) by 10 and
10276                                                                          ; stores the result back in K(S 0 1 2 3), using the fact
10277                                                                          ; that K * 10 = (K * 2) + (K * 2 * 2 * 2)
10278                      .asl @K+3                       ; ASL K+3           ; Set K(S 0 1 2 3) = K(S 0 1 2 3) * 2 by rotating left
     **** ****     > ASL
0001 3284 D020  30        movb @K+3,rtmp
     3286 0040     
0002 3288 0240  22        andi rtmp,>ff00
     328A FF00     
0003 328C 0A10  18        sla  rtmp,1
0004 328E D800  30        movb rtmp,@K+3
     3290 0040     
                   < elite.a99
10279 3292 0204  20        li   rarg1,K+2                  ; ROL K+2
     3294 003F     
10280 3296 06A0  32        bl   @rol                       ;
     3298 FE4E     
10281 329A 0204  20        li   rarg1,K+1                  ; ROL K+1
     329C 003E     
10282 329E 06A0  32        bl   @rol                       ;
     32A0 FE4E     
10283 32A2 0204  20        li   rarg1,K                    ; ROL K
     32A4 003D     
10284 32A6 06A0  32        bl   @rol                       ;
     32A8 FE4E     
10285 32AA 0204  20        li   rarg1,S                    ; ROL S
     32AC 0092     
10286 32AE 06A0  32        bl   @rol                       ;
     32B0 FE4E     
10287               
10288 32B2 020E  20        li   rx,>03*256                 ; LDX #3            ; Now we want to make a copy of the newly doubled K in
     32B4 0300     
10289                                                                          ; XX15, so we can use it for the first (K * 2) in the
10290                                                                          ; equation above, so set up a counter in X for copying
10291                                                                          ; four bytes, starting with the last byte in memory
10292                                                                          ; (i.e. the least significant)
10293               
10294               tt35_:
10295 32B6 06CE  14        swpb rx                         ;
10296 32B8 D36E  34        movb @K(rx),ra                  ; LDA K,X           ; Copy the X-th byte of K(0 1 2 3) to the X-th byte of
     32BA 003D     
10297 32BC 06CE  14        swpb rx                         ;
10298 32BE 06CE  14        swpb rx                         ;
10299 32C0 DB8D  38        movb ra,@XX15(rx)               ; STA XX15,X        ; XX15(0 1 2 3), so that XX15 will contain a copy of
     32C2 0031     
10300 32C4 06CE  14        swpb rx                         ;
10301                                                                          ; K(0 1 2 3) once we've copied all four bytes
10302               
10303 32C6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10304               
10305 32C8 15F6  14        jgt  tt35_                      ; BPL tt35          ; Loop back to copy the next byte until we have copied
10306                                                                          ; all four
10307               
10308 32CA D360  30        movb @S,ra                      ; LDA S             ; Store the value of location S, our overflow byte, in
     32CC 0092     
10309 32CE D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; XX15+4, so now XX15(4 0 1 2 3) contains a copy of
     32D0 0035     
10310                                                                          ; K(S 0 1 2 3), which is the value of (K * 2) that we
10311                                                                          ; want to use in our calculation
10312               
10313                      .asl @K+3                       ; ASL K+3           ; Now to calculate the (K * 2 * 2 * 2) part. We still
     **** ****     > ASL
0001 32D2 D020  30        movb @K+3,rtmp
     32D4 0040     
0002 32D6 0240  22        andi rtmp,>ff00
     32D8 FF00     
0003 32DA 0A10  18        sla  rtmp,1
0004 32DC D800  30        movb rtmp,@K+3
     32DE 0040     
                   < elite.a99
10314 32E0 0204  20        li   rarg1,K+2                  ; ROL K+2           ; have (K * 2) in K(S 0 1 2 3), so we just need to shift
     32E2 003F     
10315 32E4 06A0  32        bl   @rol                       ;
     32E6 FE4E     
10316 32E8 0204  20        li   rarg1,K+1                  ; ROL K+1           ; it twice. This is the first one, so we do this:
     32EA 003E     
10317 32EC 06A0  32        bl   @rol                       ;
     32EE FE4E     
10318 32F0 0204  20        li   rarg1,K                    ; ROL K             ;
     32F2 003D     
10319 32F4 06A0  32        bl   @rol                       ;
     32F6 FE4E     
10320 32F8 0204  20        li   rarg1,S                    ; ROL S             ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 4
     32FA 0092     
10321 32FC 06A0  32        bl   @rol                       ;
     32FE FE4E     
10322               
10323                      .asl @K+3                       ; ASL K+3           ; And then we do it again, so that means:
     **** ****     > ASL
0001 3300 D020  30        movb @K+3,rtmp
     3302 0040     
0002 3304 0240  22        andi rtmp,>ff00
     3306 FF00     
0003 3308 0A10  18        sla  rtmp,1
0004 330A D800  30        movb rtmp,@K+3
     330C 0040     
                   < elite.a99
10324 330E 0204  20        li   rarg1,K+2                  ; ROL K+2           ;
     3310 003F     
10325 3312 06A0  32        bl   @rol                       ;
     3314 FE4E     
10326 3316 0204  20        li   rarg1,K+1                  ; ROL K+1           ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 8
     3318 003E     
10327 331A 06A0  32        bl   @rol                       ;
     331C FE4E     
10328 331E 0204  20        li   rarg1,K                    ; ROL K
     3320 003D     
10329 3322 06A0  32        bl   @rol                       ;
     3324 FE4E     
10330 3326 0204  20        li   rarg1,S                    ; ROL S
     3328 0092     
10331 332A 06A0  32        bl   @rol                       ;
     332C FE4E     
10332               
10333                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 332E 0A16  18        sla  rzero,1
                   < elite.a99
10334                                                                          ; C flag affecting the result
10335               
10336 3330 020E  20        li   rx,>03*256                 ; LDX #3            ; By now we've got (K * 2) in XX15(4 0 1 2 3) and
     3332 0300     
10337                                                                          ; (K * 8) in K(S 0 1 2 3), so the final step is to add
10338                                                                          ; these two 32-bit numbers together to get K * 10.
10339                                                                          ; So we set a counter in X for four bytes, starting
10340                                                                          ; with the last byte in memory (i.e. the least
10341                                                                          ; significant)
10342               
10343               tt36_:
10344 3334 06CE  14        swpb rx                         ;
10345 3336 D36E  34        movb @K(rx),ra                  ; LDA K,X           ; Fetch the X-th byte of K into A
     3338 003D     
10346 333A 06CE  14        swpb rx                         ;
10347               
10348 333C 06CE  14        swpb rx                         ;
10349                      .adc @XX15(rx),ra               ; ADC XX15,X        ; Add the X-th byte of XX15 to A, with carry
     **** ****     > ADC
0001 333E 1701  14        jnc  !
0002 3340 B347  18        ab   rone,ra
0003               !:
0004 3342 B36E  34        ab   @XX15(RX),ra
     3344 0031     
                   < elite.a99
10350 3346 06CE  14        swpb rx                         ;
10351               
10352 3348 06CE  14        swpb rx                         ;
10353 334A DB8D  38        movb ra,@K(rx)                  ; STA K,X           ; Store the result in the X-th byte of K
     334C 003D     
10354 334E 06CE  14        swpb rx                         ;
10355               
10356 3350 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10357               
10358 3352 15F0  14        jgt  tt36_                      ; BPL tt36          ; Loop back to add the next byte, moving from the least
10359                                                                          ; significant byte to the most significant, until we
10360                                                                          ; have added all four
10361               
10362 3354 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Finally, fetch the overflow byte from XX15(4 0 1 2 3)
     3356 0035     
10363               
10364                      .adc @S,ra                      ; ADC S             ; And add it to the overflow byte from K(S 0 1 2 3),
     **** ****     > ADC
0001 3358 1701  14        jnc  !
0002 335A B347  18        ab   rone,ra
0003               !:
0004 335C B360  30        ab   @S,ra
     335E 0092     
                   < elite.a99
10365                                                                          ; with carry
10366               
10367 3360 D80D  30        movb ra,@S                      ; STA S             ; And store the result in the overflow byte from
     3362 0092     
10368                                                                          ; K(S 0 1 2 3), so now we have our desired result, i.e.
10369                                                                          ;
10370                                                                          ; K(S 0 1 2 3) = K(S 0 1 2 3) * 10
10371               
10372 3364 020F  20        li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
     3366 0000     
10373                                                                          ; of times we subtract 10 billion to get the leftmost
10374                                                                          ; digit, so set this to zero so we can rejoin the main
10375                                                                          ; loop for another subtraction process
10376               
10377               TT36:
10378                                                                          ; This is the main loop of our digit-printing routine.
10379                                                                          ; In the following loop, we are going to count the
10380                                                                          ; number of times that we can subtract 10 million and
10381                                                                          ; store that count in Y, which we have already set to 0
10382 3368 020E  20        li   rx,>03*256                 ; LDX #3            ; Our first calculation concerns 32-bit numbers, so
     336A 0300     
10383                                                                          ; set up a counter for a four-byte loop
10384               
10385                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 336C 0A18  18        sla  rmone,1
                   < elite.a99
10386                                                                          ; C flag affecting the result
10387               
10388               tt37_:
10389                                                                          ; We now loop through each byte in turn to do this:
10390                                                                          ;
10391                                                                          ; XX15(4 0 1 2 3) = K(S 0 1 2 3) - 100,000,000,000
10392 336E 06CE  14        swpb rx                         ;
10393 3370 D36E  34        movb @K(rx),ra                  ; LDA K,X           ; Subtract the X-th byte of TENS (i.e. 10 billion) from
     3372 003D     
10394 3374 06CE  14        swpb rx                         ;
10395 3376 06CE  14        swpb rx                         ;
10396                      .sbc @TENS(rx),ra               ; SBC TENS,X        ; the X-th byte of K
     **** ****     > SBC
0001 3378 1801  14        joc  !
0002 337A 7347  18        sb   rone,ra
0003               !:
0004 337C 736E  34        sb   @TENS(RX),ra
     337E 3228     
                   < elite.a99
10397 3380 06CE  14        swpb rx                         ;
10398               
10399 3382 06CE  14        swpb rx                         ;
10400 3384 DB8D  38        movb ra,@XX15(rx)               ; STA XX15,X        ; Store the result in the X-th byte of XX15
     3386 0031     
10401 3388 06CE  14        swpb rx                         ;
10402               
10403 338A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10404               
10405 338C 15F0  14        jgt  tt37_                      ; BPL tt37          ; Loop back to subtract the next byte, moving from the
10406                                                                          ; least significant byte to the most significant, until
10407                                                                          ; we have subtracted all four
10408               
10409 338E D360  30        movb @S,ra                      ; LDA S             ; Subtract the fifth byte of 10 billion (i.e. &17) from
     3390 0092     
10410                      .sbi (>17*256)                  ; SBC #&17          ; the fifth (overflow) byte of K, which is S
     **** ****     > SBI
0001 3392 1801  14        joc  !
0002 3394 7347  18        sb   rone,ra
0003               !:
0004 3396 022D  22        ai   ra,-(>17*256)
     3398 E900     
                   < elite.a99
10411               
10412 339A D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; Store the result in the overflow byte of XX15
     339C 0035     
10413               
10414 339E 1713  14        jnc  TT37                       ; BCC TT37          ; If subtracting 10 billion took us below zero, jump to
10415                                                                          ; TT37 to print out this digit, which is now in Y
10416               
10417 33A0 020E  20        li   rx,>03*256                 ; LDX #3            ; We now want to copy XX15(4 0 1 2 3) back into
     33A2 0300     
10418                                                                          ; K(S 0 1 2 3), so we can loop back up to do the next
10419                                                                          ; subtraction, so set up a counter for a four-byte loop
10420               
10421               tt38_:
10422 33A4 06CE  14        swpb rx                         ;
10423 33A6 D36E  34        movb @XX15(rx),ra               ; LDA XX15,X        ; Copy the X-th byte of XX15(0 1 2 3) to the X-th byte
     33A8 0031     
10424 33AA 06CE  14        swpb rx                         ;
10425 33AC 06CE  14        swpb rx                         ;
10426 33AE DB8D  38        movb ra,@K(rx)                  ; STA K,X           ; of K(0 1 2 3), so that K(0 1 2 3) will contain a copy
     33B0 003D     
10427 33B2 06CE  14        swpb rx                         ;
10428                                                                          ; of XX15(0 1 2 3) once we've copied all four bytes
10429               
10430 33B4 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
10431               
10432 33B6 15F6  14        jgt  tt38_                      ; BPL tt38          ; Loop back to copy the next byte, until we have copied
10433                                                                          ; all four
10434               
10435 33B8 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Store the value of location XX15+4, our overflow
     33BA 0035     
10436 33BC D80D  30        movb ra,@S                      ; STA S             ; byte in S, so now K(S 0 1 2 3) contains a copy of
     33BE 0092     
10437                                                                          ; XX15(4 0 1 2 3)
10438               
10439 33C0 B3C7  18        ab   rone,ry                    ; INY               ; We have now managed to subtract 10 billion from our
10440                                                                          ; number, so increment Y, which is where we are keeping
10441                                                                          ; a count of the number of subtractions so far
10442               
10443 33C2 0460  28        b    @TT36                      ; JMP TT36          ; Jump back to TT36 to subtract the next 10 billion
     33C4 3368     
10444               
10445               TT37:
10446 33C6 D34F  18        movb ry,ra                      ; TYA               ; If we get here then Y contains the digit that we want
10447                                                                          ; to print (as Y has now counted the total number of
10448                                                                          ; subtractions of 10 billion), so transfer Y into A
10449               
10450 33C8 1608  14        jne  TT32                       ; BNE TT32          ; If the digit is non-zero, jump to TT32 to print it
10451               
10452 33CA D360  30        movb @T,ra                      ; LDA T             ; Otherwise the digit is zero. If we are already
     33CC 00D1     
10453                                                                          ; printing the number then we will want to print a 0,
10454                                                                          ; but if we haven't started printing the number yet,
10455                                                                          ; then we probably don't, as we don't want to print
10456                                                                          ; leading zeroes unless this is the only digit before
10457                                                                          ; the decimal point
10458                                                                          ;
10459                                                                          ; To help with this, we are going to use T as a flag
10460                                                                          ; that tells us whether we have already started
10461                                                                          ; printing digits:
10462                                                                          ;
10463                                                                          ; * If T <> 0 we haven't printed anything yet
10464                                                                          ;
10465                                                                          ; * If T = 0 then we have started printing digits
10466                                                                          ;
10467                                                                          ; We initially set T above to the maximum number of
10468                                                                          ; characters allowed, less 1 if we are printing a
10469                                                                          ; decimal point, so the first time we enter the digit
10470                                                                          ; printing routine at TT37, it is definitely non-zero
10471               
10472 33CE 1305  14        jeq  TT32                       ; BEQ TT32          ; If T = 0, jump straight to the print routine at TT32,
10473                                                                          ; as we have already started printing the number, so we
10474                                                                          ; definitely want to print this digit too
10475               
10476 33D0 7347  18        sb   rone,ra                    ; DEC U             ; We initially set U to the number of digits we want to
10477 33D2 1510  14        jgt  TT34                       ; BPL TT34          ; skip before starting to print the number. If we get
10478                                                                          ; here then we haven't printed any digits yet, so
10479                                                                          ; decrement U to see if we have reached the point where
10480                                                                          ; we should start printing the number, and if not, jump
10481                                                                          ; to TT34 to set up things for the next digit
10482               
10483 33D4 020D  20        li   ra,(' ')*256               ; LDA #' '          ; We haven't started printing any digits yet, but we
     33D6 2000     
10484 33D8 1609  14        jne  tt34_                      ; BNE tt34          ; have reached the point where we should start printing
10485                                                                          ; our number, so call TT26 (via tt34) to print a space
10486                                                                          ; so that the number is left-padded with spaces (this
10487                                                                          ; BNE is effectively a JMP as A will never be zero)
10488               
10489               TT32:
10490 33DA 020F  20        li   ry,>00*256                 ; LDY #0            ; We are printing an actual digit, so first set T to 0,
     33DC 0000     
10491 33DE D80F  30        movb ry,@T                      ; STY T             ; to denote that we have now started printing digits as
     33E0 00D1     
10492                                                                          ; opposed to spaces
10493               
10494                      .clc                            ; CLC               ; The digit value is in A, so add ASCII "0" to get the
     **** ****     > CLC
0001 33E2 0A16  18        sla  rzero,1
                   < elite.a99
10495                      .adi (('0')*256)                ; ADC #'0'          ; ASCII character number to print
     **** ****     > ADI
0001 33E4 1701  14        jnc  !
0002 33E6 B347  18        ab   rone,ra
0003               !:
0004 33E8 022D  22        ai   ra,(('0')*256)
     33EA 3000     
                   < elite.a99
10496               
10497               tt34_:
10498 33EC 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Call TT26 to print the character in A and fall through
     33EE 341A     
10499 33F0 06A0  32        bl   @jsr                       ;
     33F2 FE28     
10500                                                                          ; into TT34 to get things ready for the next digit
10501               
10502               TT34:
10503 33F4 7347  18        sb   rone,ra                    ; DEC T             ; Decrement T but keep T >= 0 (by incrementing it
10504 33F6 1501  14        jgt  B24                        ; BPL B24           ; again if the above decrement made T negative)
10505 33F8 B347  18        ab   rone,ra                    ; INC T
10506               
10507               B24:
10508 33FA 7347  18        sb   rone,ra                    ; DEC XX17          ; Decrement the total number of characters left to
10509                                                                          ; print, which we stored in XX17
10510               
10511 33FC 1166  14        jlt  RR3+1                      ; BMI RR3+1         ; If the result is negative, we have printed all the
10512                                                                          ; characters, so return from the subroutine (as RR3
10513                                                                          ; contains an ORA #&60 instruction, so RR3+1 is &60,
10514                                                                          ; which is the opcode for an RTS)
10515               
10516 33FE 1609  14        jne  B25                        ; BNE B25           ; If the result is positive (> 0) then we still have
10517                                                                          ; characters left to print, so loop back to TT35 (via
10518                                                                          ; the JMP TT35 instruction below) to print the next
10519                                                                          ; digit
10520               
10521                      .plp                            ; PLP               ; If we get here then we have printed the exact number
     **** ****     > PLP
0001 3400 058A  14        inc  rsp
0002 3402 D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
10522                                                                          ; of digits that we wanted to, so restore the C flag
10523                                                                          ; that we stored at the start of the routine
10524               
10525 3404 1706  14        jnc  B25                        ; BCC B25           ; If the C flag is clear, we don't want a decimal point,
10526                                                                          ; so loop back to TT35 (via the JMP TT35 instruction
10527                                                                          ; below) to print the next digit
10528               
10529 3406 020D  20        li   ra,('.')*256               ; LDA #'.'          ; Otherwise the C flag is set, so print the decimal
     3408 2E00     
10530 340A 0200  20        li   rtmp,TT26                  ; JSR TT26          ; point
     340C 341A     
10531 340E 06A0  32        bl   @jsr                       ;
     3410 FE28     
10532               
10533               B25:
10534 3412 0460  28        b    @TT35                      ; JMP TT35          ; Loop back to TT35 to print the next digit
     3414 3284     
10535               
10536               * ******************************************************************************
10537               *
10538               * Name: BELL
10539               * Type: Subroutine
10540               * Category: Sound
10541               * Summary: Make a standard system beep
10542               *
10543               * ------------------------------------------------------------------------------
10544               *
10545               * This is the standard system beep, as made by the ASCII 7 "BELL" control code.
10546               *
10547               * ******************************************************************************
10548               
10549               BELL:
10550 3416 020D  20        li   ra,>07*256                 ; LDA #7            ; Control code 7 makes a beep, so load this into A
     3418 0700     
10551               
10552                                                                          ; Fall through into the TT26 print routine to
10553                                                                          ; actually make the sound
10554               
10555               * ******************************************************************************
10556               *
10557               * Name: TT26
10558               * Type: Subroutine
10559               * Category: Text
10560               * Summary: Print a character at the text cursor by poking into screen memory
10561               * Deep dive: Drawing text
10562               *
10563               * ------------------------------------------------------------------------------
10564               *
10565               * Print a character at the text cursor (XC, YC), do a beep, print a newline,
10566               * or delete left (backspace).
10567               *
10568               * WRCHV is set to point here by the loading process.
10569               *
10570               * ------------------------------------------------------------------------------
10571               *
10572               * Arguments:
10573               *
10574               * A                   The character to be printed. Can be one of the
10575               * following:
10576               *
10577               * * 7 (beep)
10578               *
10579               * * 10-13 (line feeds and carriage returns)
10580               *
10581               * * 32-95 (ASCII capital letters, numbers and
10582               * punctuation)
10583               *
10584               * * 127 (delete the character to the left of the text
10585               * cursor and move the cursor to the left)
10586               *
10587               * XC                  Contains the text column to print at (the x-coordinate)
10588               *
10589               * YC                  Contains the line number to print on (the y-coordinate)
10590               *
10591               * ------------------------------------------------------------------------------
10592               *
10593               * Returns:
10594               *
10595               * A                   A is preserved
10596               *
10597               * X                   X is preserved
10598               *
10599               * Y                   Y is preserved
10600               *
10601               * C flag              The C flag is cleared
10602               *
10603               * ------------------------------------------------------------------------------
10604               *
10605               * Other entry points:
10606               *
10607               * RR3+1               Contains an RTS
10608               *
10609               * RREN                Prints the character definition pointed to by P(2 1) at
10610               * the screen address pointed to by (A SC). Used by the
10611               * BULB routine
10612               *
10613               * rT9                 Contains an RTS
10614               *
10615               * ******************************************************************************
10616               
10617               TT26:
10618 341A D80D  30        movb ra,@K3                     ; STA K3            ; Store the A, X and Y registers, so we can restore
     341C 00D2     
10619 341E D80F  30        movb ry,@YSAV2                  ; STY YSAV2         ; them at the end (so they don't get changed by this
     3420 0F0F     
10620 3422 D80E  30        movb rx,@XSAV2                  ; STX XSAV2         ; routine)
     3424 0F0E     
10621               
10622 3426 D3E0  30        movb @QQ17,ry                   ; LDY QQ17          ; Load the QQ17 flag, which contains the text printing
     3428 007E     
10623                                                                          ; flags
10624               
10625 342A 028F  22        ci   ry,>ff*256                 ; CPY #255          ; If QQ17 = 255 then printing is disabled, so jump to
     342C FF00     
10626 342E 136A  14        jeq  RR4                        ; BEQ RR4           ; RR4, which doesn't print anything, it just restores
10627                                                                          ; the registers and returns from the subroutine
10628               
10629 3430 028D  22        ci   ra,>07*256                 ; CMP #7            ; If this is a beep character (A = 7), jump to R5,
     3432 0700     
10630 3434 1370  14        jeq  R5_                        ; BEQ R5_           ; which will emit the beep, restore the registers and
10631                                                                          ; return from the subroutine
10632               
10633 3436 028D  22        ci   ra,>20*256                 ; CMP #32           ; If this is an ASCII character (A >= 32), jump to RR1
     3438 2000     
10634 343A 1809  14        joc  RR1                        ; BCS RR1           ; below, which will print the character, restore the
10635                                                                          ; registers and return from the subroutine
10636               
10637 343C 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If this is control code 10 (line feed) then jump to
     343E 0A00     
10638 3440 1304  14        jeq  RRX1                       ; BEQ RRX1          ; RRX1, which will move down a line, restore the
10639                                                                          ; registers and return from the subroutine
10640               
10641 3442 020E  20        li   rx,>01*256                 ; LDX #1            ; If we get here, then this is control code 11-13, of
     3444 0100     
10642 3446 D80E  30        movb rx,@XC                     ; STX XC            ; which only 13 is used. This code prints a newline,
     3448 002C     
10643                                                                          ; which we can achieve by moving the text cursor
10644                                                                          ; to the start of the line (carriage return) and down
10645                                                                          ; one line (line feed). These two lines do the first
10646                                                                          ; bit by setting XC = 1, and we then fall through into
10647                                                                          ; the line feed routine that's used by control code 10
10648               
10649               RRX1:
10650 344A B347  18        ab   rone,ra                    ; INC YC            ; Print a line feed, simply by incrementing the row
10651                                                                          ; number (y-coordinate) of the text cursor, which is
10652                                                                          ; stored in YC
10653               
10654 344C 165B  14        jne  RR4                        ; BNE RR4           ; Jump to RR4 to restore the registers and return from
10655                                                                          ; the subroutine (this BNE is effectively a JMP as Y
10656                                                                          ; will never be zero)
10657               
10658               RR1:
10659                                                                          ; If we get here, then the character to print is an
10660                                                                          ; ASCII character in the range 32-95. The quickest way
10661                                                                          ; to display text on-screen is to poke the character
10662                                                                          ; pixel by pixel, directly into screen memory, so
10663                                                                          ; that's what the rest of this routine does
10664                                                                          ;
10665                                                                          ; The first step, then, is to get hold of the bitmap
10666                                                                          ; definition for the character we want to draw on the
10667                                                                          ; screen (i.e. we need the pixel shape of this
10668                                                                          ; character). The MOS ROM contains bitmap definitions
10669                                                                          ; of the system's ASCII characters, starting from &C000
10670                                                                          ; for space (ASCII 32) and ending with the  symbol
10671                                                                          ; (ASCII 126)
10672                                                                          ;
10673                                                                          ; There are definitions for 32 characters in each of the
10674                                                                          ; three pages of MOS memory, as each definition takes up
10675                                                                          ; 8 bytes (8 rows of 8 pixels) and 32 * 8 = 256 bytes =
10676                                                                          ; 1 page. So:
10677                                                                          ;
10678                                                                          ; ASCII 32-63  are defined in &C000-&C0FF (page 0)
10679                                                                          ; ASCII 64-95  are defined in &C100-&C1FF (page 1)
10680                                                                          ; ASCII 96-126 are defined in &C200-&C2F0 (page 2)
10681                                                                          ;
10682                                                                          ; The following code reads the relevant character
10683                                                                          ; bitmap from the above locations in ROM and pokes
10684                                                                          ; those values into the correct position in screen
10685                                                                          ; memory, thus printing the character on-screen
10686                                                                          ;
10687                                                                          ; It's a long way from 10 PRINT "Hello world!":GOTO 10
10688               * LDX #LO(K3)            \ These instructions are commented out in the original
10689               * INX                    \ source, but they call OSWORD 10, which reads the
10690               * STX P+1                \ character bitmap for the character number in K3 and
10691               * DEX                    \ stores it in the block at K3+1, while also setting
10692               * LDY #HI(K3)            \ P+1 to point to the character definition. This is
10693               * STY P+2                \ exactly what the following uncommented code does,
10694               * LDA #10                \ just without calling OSWORD. Presumably the code
10695               * JSR OSWORD             \ below is faster than using the system call, as this
10696                                                                          ; version takes up 15 bytes, while the version below
10697                                                                          ; (which ends with STA P+1 and SYX P+2) is 17 bytes.
10698                                                                          ; Every efficiency saving helps, especially as this
10699                                                                          ; routine is run each time the game prints a character
10700                                                                          ;
10701                                                                          ; If you want to switch this code back on, uncomment
10702                                                                          ; the above block, and comment out the code below from
10703                                                                          ; TAY to STX P+2. You will also need to uncomment the
10704                                                                          ; LDA YC instruction a few lines down (in RR2), just to
10705                                                                          ; make sure the rest of the code doesn't shift in
10706                                                                          ; memory. To be honest I can't see a massive difference
10707                                                                          ; in speed, but there you go
10708 344E D3CD  18        movb ra,ry                      ; TAY               ; Copy the character number from A to Y, as we are
10709                                                                          ; about to pull A apart to work out where this
10710                                                                          ; character definition lives in memory
10711               
10712                                                                          ; Now we want to set X to point to the relevant page
10713                                                                          ; number for this character - i.e. &C0, &C1 or &C2.
10714               
10715                                                                          ; The following logic is easier to follow if we look
10716                                                                          ; at the three character number ranges in binary:
10717                                                                          ;
10718                                                                          ; Bit #  76543210
10719                                                                          ;
10720                                                                          ; 32  = %00100000     Page 0 of bitmap definitions
10721                                                                          ; 63  = %00111111
10722                                                                          ;
10723                                                                          ; 64  = %01000000     Page 1 of bitmap definitions
10724                                                                          ; 95  = %01011111
10725                                                                          ;
10726                                                                          ; 96  = %01100000     Page 2 of bitmap definitions
10727                                                                          ; 125 = %01111101
10728                                                                          ;
10729                                                                          ; We'll refer to this below
10730               
10731 3450 020E  20        li   rx,>bf*256                 ; LDX #&BF          ; Set X to point to the first font page in ROM minus 1,
     3452 BF00     
10732                                                                          ; which is &C0 - 1, or &BF
10733               
10734                      .asla                           ; ASL A             ; If bit 6 of the character is clear (A is 32-63)
     **** ****     > ASLA
0001 3454 024D  22        andi ra,>ff00
     3456 FF00     
0002 3458 0A1D  18        sla  ra,1
                   < elite.a99
10735                      .asla                           ; ASL A             ; then skip the following instruction
     **** ****     > ASLA
0001 345A 024D  22        andi ra,>ff00
     345C FF00     
0002 345E 0A1D  18        sla  ra,1
                   < elite.a99
10736 3460 1702  14        jnc  B26                        ; BCC B26
10737               
10738 3462 020E  20        li   rx,>c1*256                 ; LDX #&C1          ; A is 64-126, so set X to point to page &C1
     3464 C100     
10739               
10740               B26:
10741                      .asla                           ; ASL A             ; If bit 5 of the character is clear (A is 64-95)
     **** ****     > ASLA
0001 3466 024D  22        andi ra,>ff00
     3468 FF00     
0002 346A 0A1D  18        sla  ra,1
                   < elite.a99
10742 346C 1701  14        jnc  B27                        ; BCC B27           ; then skip the following instruction
10743               
10744 346E B387  18        ab   rone,rx                    ; INX               ; Increment X
10745                                                                          ;
10746                                                                          ; By this point, we started with X = &BF, and then
10747                                                                          ; we did the following:
10748                                                                          ;
10749                                                                          ; If A = 32-63:   skip    then INX  so X = &C0
10750                                                                          ; If A = 64-95:   X = &C1 then skip so X = &C1
10751                                                                          ; If A = 96-126:  X = &C1 then INX  so X = &C2
10752                                                                          ;
10753                                                                          ; In other words, X points to the relevant page. But
10754                                                                          ; what about the value of A? That gets shifted to the
10755                                                                          ; left three times during the above code, which
10756                                                                          ; multiplies the number by 8 but also drops bits 7, 6
10757                                                                          ; and 5 in the process. Look at the above binary
10758                                                                          ; figures and you can see that if we cleared bits 5-7,
10759                                                                          ; then that would change 32-53 to 0-31... but it would
10760                                                                          ; do exactly the same to 64-95 and 96-125. And because
10761                                                                          ; we also multiply this figure by 8, A now points to
10762                                                                          ; the start of the character's definition within its
10763                                                                          ; page (because there are 8 bytes per character
10764                                                                          ; definition)
10765                                                                          ;
10766                                                                          ; Or, to put it another way, X contains the high byte
10767                                                                          ; (the page) of the address of the definition that we
10768                                                                          ; want, while A contains the low byte (the offset into
10769                                                                          ; the page) of the address
10770               
10771               B27:
10772 3470 D80D  30        movb ra,@P+1                    ; STA P+1           ; Store the address of this character's definition in
     3472 001C     
10773 3474 D80E  30        movb rx,@P+2                    ; STX P+2           ; P(2 1)
     3476 001D     
10774               
10775 3478 D360  30        movb @XC,ra                     ; LDA XC            ; Fetch XC, the x-coordinate (column) of the text cursor
     347A 002C     
10776                                                                          ; into A
10777               
10778                      .asla                           ; ASL A             ; Multiply A by 8, and store in SC. As each character is
     **** ****     > ASLA
0001 347C 024D  22        andi ra,>ff00
     347E FF00     
0002 3480 0A1D  18        sla  ra,1
                   < elite.a99
10779                      .asla                           ; ASL A             ; 8 pixels wide, and the special screen mode Elite uses
     **** ****     > ASLA
0001 3482 024D  22        andi ra,>ff00
     3484 FF00     
0002 3486 0A1D  18        sla  ra,1
                   < elite.a99
10780                      .asla                           ; ASL A             ; for the top part of the screen is 256 pixels across
     **** ****     > ASLA
0001 3488 024D  22        andi ra,>ff00
     348A FF00     
0002 348C 0A1D  18        sla  ra,1
                   < elite.a99
10781 348E D80D  30        movb ra,@SC                     ; STA SC            ; with one bit per pixel, this value is not only the
     3490 0007     
10782                                                                          ; screen address offset of the text cursor from the left
10783                                                                          ; side of the screen, it's also the least significant
10784                                                                          ; byte of the screen address where we want to print this
10785                                                                          ; character, as each row of on-screen pixels corresponds
10786                                                                          ; to one page. To put this more explicitly, the screen
10787                                                                          ; starts at &6000, so the text rows are stored in screen
10788                                                                          ; memory like this:
10789                                                                          ;
10790                                                                          ; Row 1: &6000 - &60FF    YC = 1, XC = 0 to 31
10791                                                                          ; Row 2: &6100 - &61FF    YC = 2, XC = 0 to 31
10792                                                                          ; Row 3: &6200 - &62FF    YC = 3, XC = 0 to 31
10793                                                                          ;
10794                                                                          ; and so on
10795               
10796 3492 D360  30        movb @YC,ra                     ; LDA YC            ; Fetch YC, the y-coordinate (row) of the text cursor
     3494 002D     
10797               
10798 3496 028F  22        ci   ry,>7f*256                 ; CPY #127          ; If the character number (which is in Y) <> 127, then
     3498 7F00     
10799 349A 160D  14        jne  RR2                        ; BNE RR2           ; skip to RR2 to print that character, otherwise this is
10800                                                                          ; the delete character, so continue on
10801               
10802 349C 7347  18        sb   rone,ra                    ; DEC XC            ; We want to delete the character to the left of the
10803                                                                          ; text cursor and move the cursor back one, so let's
10804                                                                          ; do that by decrementing YC. Note that this doesn't
10805                                                                          ; have anything to do with the actual deletion below,
10806                                                                          ; we're just updating the cursor so it's in the right
10807                                                                          ; position following the deletion
10808               
10809                      .adi (>5e*256)                  ; ADC #&5E          ; A contains YC (from above) and the C flag is set (from
     **** ****     > ADI
0001 349E 1701  14        jnc  !
0002 34A0 B347  18        ab   rone,ra
0003               !:
0004 34A2 022D  22        ai   ra,(>5E*256)
     34A4 5E00     
                   < elite.a99
10810 34A6 D38D  18        movb ra,rx                      ; TAX               ; the CPY #127 above), so these instructions do this:
10811                                                                          ;
10812                                                                          ; X = YC + &5E + 1
10813                                                                          ; = YC + &5F
10814               
10815                                                                          ; Because YC starts at 0 for the first text row, this
10816                                                                          ; means that X will be &5F for row 0, &60 for row 1 and
10817                                                                          ; so on. In other words, X is now set to the page number
10818                                                                          ; for the row before the one containing the text cursor,
10819                                                                          ; and given that we set SC above to point to the offset
10820                                                                          ; in memory of the text cursor within the row's page,
10821                                                                          ; this means that (X SC) now points to the character
10822                                                                          ; above the text cursor
10823               
10824 34A8 020F  20        li   ry,>f8*256                 ; LDY #&F8          ; Set Y = &F8, so the following call to ZES2 will count
     34AA F800     
10825                                                                          ; Y upwards from &F8 to &FF
10826               
10827 34AC 0200  20        li   rtmp,ZES2                  ; JSR ZES2          ; Call ZES2, which zero-fills from address (X SC) + Y to
     34AE CF9E     
10828 34B0 06A0  32        bl   @jsr                       ;
     34B2 FE28     
10829                                                                          ; (X SC) + &FF. (X SC) points to the character above the
10830                                                                          ; text cursor, and adding &FF to this would point to the
10831                                                                          ; cursor, so adding &F8 points to the character before
10832                                                                          ; the cursor, which is the one we want to delete. So
10833                                                                          ; this call zero-fills the character to the left of the
10834                                                                          ; cursor, which erases it from the screen
10835               
10836 34B4 1327  14        jeq  RR4                        ; BEQ RR4           ; We are done deleting, so restore the registers and
10837                                                                          ; return from the subroutine (this BNE is effectively
10838                                                                          ; a JMP as ZES2 always returns with the Z flag set)
10839               
10840               RR2:
10841                                                                          ; Now to actually print the character
10842 34B6 B347  18        ab   rone,ra                    ; INC XC            ; Once we print the character, we want to move the text
10843                                                                          ; cursor to the right, so we do this by incrementing
10844                                                                          ; XC. Note that this doesn't have anything to do
10845                                                                          ; with the actual printing below, we're just updating
10846                                                                          ; the cursor so it's in the right position following
10847                                                                          ; the print
10848               
10849               * LDA YC                 \ This instruction is commented out in the original
10850                                                                          ; source. It isn't required because we only just did a
10851                                                                          ; LDA YC before jumping to RR2, so this is presumably
10852                                                                          ; an example of the authors squeezing the code to save
10853                                                                          ; 2 bytes and 3 cycles
10854                                                                          ;
10855                                                                          ; If you want to re-enable the commented block near the
10856                                                                          ; start of this routine, you should uncomment this
10857                                                                          ; instruction as well
10858               
10859 34B8 028D  22        ci   ra,>18*256                 ; CMP #24           ; If the text cursor is on the screen (i.e. YC < 24, so
     34BA 1800     
10860 34BC 1706  14        jnc  RR3                        ; BCC RR3           ; we are on rows 0-23), then jump to RR3 to print the
10861                                                                          ; character
10862               
10863 34BE 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise we are off the bottom of the screen, so
     34C0 4EFE     
10864 34C2 06A0  32        bl   @jsr                       ;
     34C4 FE28     
10865                                                                          ; clear the screen and draw a white border
10866               
10867 34C6 0460  28        b    @RR4                       ; JMP RR4           ; And restore the registers and return from the
     34C8 3504     
10868                                                                          ; subroutine
10869               
10870               RR3:
10871                                                                          ; A contains the value of YC - the screen row where we
10872                                                                          ; want to print this character - so now we need to
10873                                                                          ; convert this into a screen address, so we can poke
10874                                                                          ; the character data to the right place in screen
10875                                                                          ; memory
10876 34CA 026D  22        ori  ra,>60*256                 ; ORA #&60          ; We already stored the least significant byte
     34CC 6000     
10877                                                                          ; of this screen address in SC above (see the STA SC
10878                                                                          ; instruction above), so all we need is the most
10879                                                                          ; significant byte. As mentioned above, in Elite's
10880                                                                          ; square mode 4 screen, each row of text on-screen
10881                                                                          ; takes up exactly one page, so the first row is page
10882                                                                          ; &60xx, the second row is page &61xx, so we can get
10883                                                                          ; the page for character (XC, YC) by OR'ing with &60.
10884                                                                          ; To see this in action, consider that our two values
10885                                                                          ; are, in binary:
10886                                                                          ;
10887                                                                          ; YC is between:  %00000000
10888                                                                          ; and:  %00010111
10889                                                                          ; &60 is:  %01100000
10890                                                                          ;
10891                                                                          ; so YC OR &60 effectively adds &60 to YC, giving us
10892                                                                          ; the page number that we want
10893               
10894               RREN:
10895 34CE D80D  30        movb ra,@SC+1                   ; STA SC+1          ; Store the page number of the destination screen
     34D0 0008     
10896                                                                          ; location in SC+1, so SC now points to the full screen
10897                                                                          ; location where this character should go
10898               
10899 34D2 020F  20        li   ry,>07*256                 ; LDY #7            ; We want to print the 8 bytes of character data to the
     34D4 0700     
10900                                                                          ; screen (one byte per row), so set up a counter in Y
10901                                                                          ; to count these bytes
10902               
10903               RRL1:
10904                      .ld_ind_y_idx @P+1,ra           ; LDA (P+1),Y       ; The character definition is at P(2 1) - we set this up
     **** ****     > LD_IND_Y_IDX
0001 34D6 D820  42        movb @P+1,@rtmplb
     34D8 001C     
     34DA 8301     
0002 34DC D020  30        movb @P+1+1,rtmp
     34DE 001D     
0003 34E0 06CF  14        swpb ry
0004 34E2 A00F  18        a    ry,rtmp
0005 34E4 06CF  14        swpb ry
0006 34E6 D350  26        movb *rtmp,RA
                   < elite.a99
10905                                                                          ; above - so load the Y-th byte from P(2 1), which will
10906                                                                          ; contain the bitmap for the Y-th row of the character
10907               
10908                      .eor @SC                        ; EOR (SC),Y        ; If we EOR this value with the existing screen
     **** ****     > EOR
0001 34E8 D020  30        movb @SC,rtmp
     34EA 0007     
0002 34EC 2B40  18        xor  rtmp,ra
                   < elite.a99
10909                                                                          ; contents, then it's reversible (so reprinting the
10910                                                                          ; same character in the same place will revert the
10911                                                                          ; screen to what it looked like before we printed
10912                                                                          ; anything); this means that printing a white pixel
10913                                                                          ; onto a white background results in a black pixel, but
10914                                                                          ; that's a small price to pay for easily erasable text
10915               
10916                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store the Y-th byte at the screen address for this
     **** ****     > ST_IND_Y_IDX
0001 34EE D820  42        movb @SC,@rtmplb
     34F0 0007     
     34F2 8301     
0002 34F4 D020  30        movb @SC+1,rtmp
     34F6 0008     
0003 34F8 06CF  14        swpb ry
0004 34FA A00F  18        a    ry,rtmp
0005 34FC 06CF  14        swpb ry
0006 34FE D40D  30        movb RA,*rtmp
                   < elite.a99
10917                                                                          ; character location
10918               
10919 3500 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
10920               
10921 3502 15E9  14        jgt  RRL1                       ; BPL RRL1          ; Loop back for the next byte to print to the screen
10922               
10923               RR4:
10924 3504 D3E0  30        movb @YSAV2,ry                  ; LDY YSAV2         ; We're done printing, so restore the values of the
     3506 0F0F     
10925 3508 D3A0  30        movb @XSAV2,rx                  ; LDX XSAV2         ; A, X and Y registers that we saved above and clear
     350A 0F0E     
10926 350C D360  30        movb @K3,ra                     ; LDA K3            ; the C flag, so everything is back to how it was
     350E 00D2     
10927                      .clc                            ; CLC
     **** ****     > CLC
0001 3510 0A16  18        sla  rzero,1
                   < elite.a99
10928               
10929               rT9:
10930 3512 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3514 FE34     
10931               
10932               R5_:
10933 3516 0200  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     3518 D33C     
10934 351A 06A0  32        bl   @jsr                       ;
     351C FE28     
10935               
10936 351E 0460  28        b    @RR4                       ; JMP RR4           ; Jump to RR4 to restore the registers and return from
     3520 3504     
10937                                                                          ; the subroutine using a tail call
10938               
10939               * ******************************************************************************
10940               *
10941               * Name: DIALS (Part 1 of 4)
10942               * Type: Subroutine
10943               * Category: Dashboard
10944               * Summary: Update the dashboard: speed indicator
10945               * Deep dive: The dashboard indicators
10946               *
10947               * ------------------------------------------------------------------------------
10948               *
10949               * This routine updates the dashboard. First we draw all the indicators in the
10950               * right part of the dashboard, from top (speed) to bottom (energy banks), and
10951               * then we move on to the left part, again drawing from top (forward shield) to
10952               * bottom (altitude).
10953               *
10954               * This first section starts us off with the speedometer in the top right.
10955               *
10956               * ******************************************************************************
10957               
10958               DIALS:
10959 3522 020D  20        li   ra,>d0*256                 ; LDA #&D0          ; Set SC(1 0) = &78D0, which is the screen address for
     3524 D000     
10960 3526 D80D  30        movb ra,@SC                     ; STA SC            ; the character block containing the left end of the
     3528 0007     
10961 352A 020D  20        li   ra,>78*256                 ; LDA #&78          ; top indicator in the right part of the dashboard, the
     352C 7800     
10962 352E D80D  30        movb ra,@SC+1                   ; STA SC+1          ; one showing our speed
     3530 0008     
10963               
10964 3532 0200  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     3534 36BE     
10965 3536 06A0  32        bl   @jsr                       ;
     3538 FE28     
10966                                                                          ; and X to the colour for safe values
10967               
10968 353A D80E  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     353C 003E     
10969                                                                          ; X (the colour to use for safe values)
10970               
10971 353E D80D  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     3540 003D     
10972                                                                          ; A (the colour to use for dangerous values)
10973               
10974                                                                          ; The above sets the following indicators to show red
10975                                                                          ; for high values and yellow/white for low values
10976               
10977 3542 020D  20        li   ra,>0e*256                 ; LDA #14           ; Set T1 to 14, the threshold at which we change the
     3544 0E00     
10978 3546 D80D  30        movb ra,@T1                     ; STA T1            ; indicator's colour
     3548 0006     
10979               
10980 354A D360  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch our ship's speed into A, in the range 0-40
     354C 008C     
10981               
10982               * LSR A                  \ Draw the speed indicator using a range of 0-31, and
10983 354E 0200  20        li   rtmp,DIL-1                 ; JSR DIL-1         ; increment SC to point to the next indicator (the roll
     3550 36E7     
10984 3552 06A0  32        bl   @jsr                       ;
     3554 FE28     
10985                                                                          ; indicator). The LSR is commented out as it isn't
10986                                                                          ; required with a call to DIL-1, so perhaps this was
10987                                                                          ; originally a call to DIL that got optimised
10988               
10989               * ******************************************************************************
10990               *
10991               * Name: DIALS (Part 2 of 4)
10992               * Type: Subroutine
10993               * Category: Dashboard
10994               * Summary: Update the dashboard: pitch and roll indicators
10995               * Deep dive: The dashboard indicators
10996               *
10997               * ******************************************************************************
10998               
10999 3556 020D  20        li   ra,>00*256                 ; LDA #0            ; Set R = P = 0 for the low bytes in the call to the ADD
     3558 0000     
11000 355A D80D  30        movb ra,@R                      ; STA R             ; routine below
     355C 0091     
11001 355E D80D  30        movb ra,@P                      ; STA P
     3560 001B     
11002               
11003 3562 020D  20        li   ra,>08*256                 ; LDA #8            ; Set S = 8, which is the value of the centre of the
     3564 0800     
11004 3566 D80D  30        movb ra,@S                      ; STA S             ; roll indicator
     3568 0092     
11005               
11006 356A D360  30        movb @ALP1,ra                   ; LDA ALP1          ; Fetch the roll angle alpha as a value between 0 and
     356C 0087     
11007 356E 091D  18        srl  ra,1                       ; LSR A             ; 31, and divide by 4 to get a value of 0 to 7
11008 3570 091D  18        srl  ra,1                       ; LSR A
11009               
11010 3572 F360  30        socb @ALP2,ra                   ; ORA ALP2          ; Apply the roll sign to the value, and flip the sign,
     3574 0088     
11011                      .eoi (>80*256)                  ; EOR #%10000000    ; so it's now in the range -7 to +7, with a positive
     **** ****     > EOI
0001 3576 0200  20        li   rtmp,(>80*256)
     3578 8000     
0002 357A 2B40  18        xor  rtmp,ra
                   < elite.a99
11012                                                                          ; roll angle alpha giving a negative value in A
11013               
11014 357C 0200  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     357E 4862     
11015 3580 06A0  32        bl   @jsr                       ;
     3582 FE28     
11016                                                                          ; 15, which we can pass to DIL2 to draw the vertical
11017                                                                          ; bar on the indicator at this position. We use the ADD
11018                                                                          ; routine like this:
11019                                                                          ;
11020                                                                          ; (A X) = (A 0) + (S 0)
11021                                                                          ;
11022                                                                          ; and just take the high byte of the result. We use ADD
11023                                                                          ; rather than a normal ADC because ADD separates out the
11024                                                                          ; sign bit and does the arithmetic using absolute values
11025                                                                          ; and separate sign bits, which we want here rather than
11026                                                                          ; the two's complement that ADC uses
11027               
11028 3584 0200  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the roll indicator at offset A
     3586 37BE     
11029 3588 06A0  32        bl   @jsr                       ;
     358A FE28     
11030                                                                          ; and increment SC to point to the next indicator (the
11031                                                                          ; pitch indicator)
11032               
11033 358C D360  30        movb @BETA,ra                   ; LDA BETA          ; Fetch the pitch angle beta as a value between -8 and
     358E 002A     
11034                                                                          ; +8
11035               
11036 3590 D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the pitch angle beta, and if it
     3592 002B     
11037 3594 1304  14        jeq  B28                        ; BEQ B28           ; is 0 (i.e. we are not pitching), skip the next
11038                                                                          ; instruction
11039               
11040                      .sbi (>01*256)                  ; SBC #1            ; The pitch angle beta is non-zero, so set A = A - 1
     **** ****     > SBI
0001 3596 1801  14        joc  !
0002 3598 7347  18        sb   rone,ra
0003               !:
0004 359A 022D  22        ai   ra,-(>01*256)
     359C FF00     
                   < elite.a99
11041                                                                          ; (the C flag is set by the call to DIL2 above, so we
11042                                                                          ; don't need to do a SEC). This gives us a value of A
11043                                                                          ; from -7 to +7 because these are magnitude-based
11044                                                                          ; numbers with sign bits, rather than two's complement
11045                                                                          ; numbers
11046               
11047               B28:
11048 359E 0200  20        li   rtmp,ADD                   ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
     35A0 4862     
11049 35A2 06A0  32        bl   @jsr                       ;
     35A4 FE28     
11050                                                                          ; 15, which we can pass to DIL2 to draw the vertical
11051                                                                          ; bar on the indicator at this position (see the JSR ADD
11052                                                                          ; above for more on this)
11053               
11054 35A6 0200  20        li   rtmp,DIL2                  ; JSR DIL2          ; Draw a vertical bar on the pitch indicator at offset A
     35A8 37BE     
11055 35AA 06A0  32        bl   @jsr                       ;
     35AC FE28     
11056                                                                          ; and increment SC to point to the next indicator (the
11057                                                                          ; four energy banks)
11058               
11059               * ******************************************************************************
11060               *
11061               * Name: DIALS (Part 3 of 4)
11062               * Type: Subroutine
11063               * Category: Dashboard
11064               * Summary: Update the dashboard: four energy banks
11065               * Deep dive: The dashboard indicators
11066               *
11067               * ------------------------------------------------------------------------------
11068               *
11069               * This and the next section only run once every four iterations of the main
11070               * loop, so while the speed, pitch and roll indicators update every iteration,
11071               * the other indicators update less often.
11072               *
11073               * ******************************************************************************
11074               
11075 35AE D360  30        movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 4,
     35B0 0099     
11076 35B2 024D  22        andi ra,>03*256                 ; AND #3            ; jumping to rT9 if it is non-zero. rT9 contains an RTS,
     35B4 0300     
11077 35B6 16AD  14        jne  rT9                        ; BNE rT9           ; so the following code only runs every 4 iterations of
11078                                                                          ; the main loop, otherwise we return from the subroutine
11079               
11080 35B8 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, for use in various places below
     35BA 0000     
11081               
11082 35BC 0200  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     35BE 36BE     
11083 35C0 06A0  32        bl   @jsr                       ;
     35C2 FE28     
11084                                                                          ; and X to the colour for safe values
11085               
11086 35C4 D80E  30        movb rx,@K                      ; STX K             ; Set K (the colour we should show for high values) to X
     35C6 003D     
11087                                                                          ; (the colour to use for safe values)
11088               
11089 35C8 D80D  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     35CA 003E     
11090                                                                          ; A (the colour to use for dangerous values)
11091               
11092                                                                          ; The above sets the following indicators to show red
11093                                                                          ; for low values and yellow/white for high values, which
11094                                                                          ; we use not only for the energy banks, but also for the
11095                                                                          ; shield levels and current fuel
11096               
11097 35CC 020E  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X so we can zero the four bytes at
     35CE 0300     
11098                                                                          ; XX12, so we can then calculate each of the four energy
11099                                                                          ; banks' values before drawing them later
11100               
11101 35D0 D80E  30        movb rx,@T1                     ; STX T1            ; Set T1 to 3, the threshold at which we change the
     35D2 0006     
11102                                                                          ; indicator's colour
11103               
11104               DLL23:
11105 35D4 DB8F  38        movb ry,@XX12(rx)               ; STY XX12,X        ; Set the X-th byte of XX12 to 0
     35D6 0037     
11106               
11107 35D8 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11108               
11109 35DA 15FC  14        jgt  DLL23                      ; BPL DLL23         ; Loop back for the next byte until the four bytes at
11110                                                                          ; XX12 are all zeroed
11111               
11112 35DC 020E  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X to loop through the 4 energy
     35DE 0300     
11113                                                                          ; bank indicators, so we can calculate each of the four
11114                                                                          ; energy banks' values and store them in XX12
11115               
11116 35E0 D360  30        movb @ENERGY,ra                 ; LDA ENERGY        ; Set A = Q = ENERGY / 4, so they are both now in the
     35E2 0F13     
11117 35E4 091D  18        srl  ra,1                       ; LSR A             ; range 0-63 (so that's a maximum of 16 in each of the
11118 35E6 091D  18        srl  ra,1                       ; LSR A             ; banks, and a maximum of 15 in the top bank)
11119               
11120 35E8 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q to A, so we can use Q to hold the remaining
     35EA 0090     
11121                                                                          ; energy as we work our way through each bank, from the
11122                                                                          ; full ones at the bottom to the empty ones at the top
11123               
11124               DLL24:
11125                      .sec                            ; SEC               ; Set A = A - 16 to reduce the energy count by a full
     **** ****     > SEC
0001 35EC 0A18  18        sla  rmone,1
                   < elite.a99
11126                      .sbi (>10*256)                  ; SBC #16           ; bank
     **** ****     > SBI
0001 35EE 1801  14        joc  !
0002 35F0 7347  18        sb   rone,ra
0003               !:
0004 35F2 022D  22        ai   ra,-(>10*256)
     35F4 F000     
                   < elite.a99
11127               
11128 35F6 170D  14        jnc  DLL26                      ; BCC DLL26         ; If the C flag is clear then A < 16, so this bank is
11129                                                                          ; not full to the brim, and is therefore the last one
11130                                                                          ; with any energy in it, so jump to DLL26
11131               
11132 35F8 D80D  30        movb ra,@Q                      ; STA Q             ; This bank is full, so update Q with the energy of the
     35FA 0090     
11133                                                                          ; remaining banks
11134               
11135 35FC 020D  20        li   ra,>10*256                 ; LDA #16           ; Store this bank's level in XX12 as 16, as it is full,
     35FE 1000     
11136 3600 06CE  14        swpb rx                         ;
11137 3602 DB8D  38        movb ra,@XX12(rx)               ; STA XX12,X        ; with XX12+3 for the bottom bank and XX12+0 for the top
     3604 0037     
11138 3606 06CE  14        swpb rx                         ;
11139               
11140 3608 D360  30        movb @Q,ra                      ; LDA Q             ; Set A to the remaining energy level again
     360A 0090     
11141               
11142 360C 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to point to the next bank, i.e. the one
11143                                                                          ; above the bank we just processed
11144               
11145 360E 15EE  14        jgt  DLL24                      ; BPL DLL24         ; Loop back to DLL24 until we have either processed all
11146                                                                          ; four banks, or jumped out early to DLL26 if the top
11147                                                                          ; banks have no charge
11148               
11149 3610 1106  14        jlt  DLL9                       ; BMI DLL9          ; Jump to DLL9 as we have processed all four banks (this
11150                                                                          ; BMI is effectively a JMP as A will never be positive)
11151               
11152               DLL26:
11153 3612 D360  30        movb @Q,ra                      ; LDA Q             ; If we get here then the bank we just checked is not
     3614 0090     
11154 3616 06CE  14        swpb rx                         ;
11155 3618 DB8D  38        movb ra,@XX12(rx)               ; STA XX12,X        ; fully charged, so store its value in XX12 (using Q,
     361A 0037     
11156 361C 06CE  14        swpb rx                         ;
11157                                                                          ; which contains the energy of the remaining banks -
11158                                                                          ; i.e. this one)
11159               
11160                                                                          ; Now that we have the four energy bank values in XX12,
11161                                                                          ; we can draw them, starting with the top bank in XX12
11162                                                                          ; and looping down to the bottom bank in XX12+3, using Y
11163                                                                          ; as a loop counter, which was set to 0 above
11164               
11165               DLL9:
11166 361E 06CF  14        swpb ry                         ;
11167 3620 D36F  34        movb @XX12(ry),ra               ; LDA XX12,Y        ; Fetch the value of the Y-th indicator, starting from
     3622 0037     
11168 3624 06CF  14        swpb ry                         ;
11169                                                                          ; the top
11170               
11171 3626 D80F  30        movb ry,@P                      ; STY P             ; Store the indicator number in P for retrieval later
     3628 001B     
11172               
11173 362A 0200  20        li   rtmp,DIL                   ; JSR DIL           ; Draw the energy bank using a range of 0-15, and
     362C 36E8     
11174 362E 06A0  32        bl   @jsr                       ;
     3630 FE28     
11175                                                                          ; increment SC to point to the next indicator (the
11176                                                                          ; next energy bank down)
11177               
11178 3632 D3E0  30        movb @P,ry                      ; LDY P             ; Restore the indicator number into Y
     3634 001B     
11179               
11180 3636 B3C7  18        ab   rone,ry                    ; INY               ; Increment the indicator number
11181               
11182 3638 028F  22        ci   ry,>04*256                 ; CPY #4            ; Check to see if we have drawn the last energy bank
     363A 0400     
11183               
11184 363C 16F0  14        jne  DLL9                       ; BNE DLL9          ; Loop back to DLL9 if we have more banks to draw,
11185                                                                          ; otherwise we are done
11186               
11187               * ******************************************************************************
11188               *
11189               * Name: DIALS (Part 4 of 4)
11190               * Type: Subroutine
11191               * Category: Dashboard
11192               * Summary: Update the dashboard: shields, fuel, laser & cabin temp, altitude
11193               * Deep dive: The dashboard indicators
11194               *
11195               * ******************************************************************************
11196               
11197 363E 020D  20        li   ra,>78*256                 ; LDA #&78          ; Set SC(1 0) = &7810, which is the screen address for
     3640 7800     
11198 3642 D80D  30        movb ra,@SC+1                   ; STA SC+1          ; the character block containing the left end of the
     3644 0008     
11199 3646 020D  20        li   ra,>10*256                 ; LDA #&10          ; top indicator in the left part of the dashboard, the
     3648 1000     
11200 364A D80D  30        movb ra,@SC                     ; STA SC            ; one showing the forward shield
     364C 0007     
11201               
11202 364E D360  30        movb @FSH,ra                    ; LDA FSH           ; Draw the forward shield indicator using a range of
     3650 0F11     
11203 3652 0200  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     3654 36E0     
11204 3656 06A0  32        bl   @jsr                       ;
     3658 FE28     
11205                                                                          ; (the aft shield)
11206               
11207 365A D360  30        movb @ASH,ra                    ; LDA ASH           ; Draw the aft shield indicator using a range of 0-255,
     365C 0F12     
11208 365E 0200  20        li   rtmp,DILX                  ; JSR DILX          ; and increment SC to point to the next indicator (the
     3660 36E0     
11209 3662 06A0  32        bl   @jsr                       ;
     3664 FE28     
11210                                                                          ; fuel level)
11211               
11212 3666 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Draw the fuel level indicator using a range of 0-63,
     3668 030D     
11213 366A 0200  20        li   rtmp,DILX+2                ; JSR DILX+2        ; and increment SC to point to the next indicator (the
     366C 36E2     
11214 366E 06A0  32        bl   @jsr                       ;
     3670 FE28     
11215                                                                          ; cabin temperature)
11216               
11217 3672 0200  20        li   rtmp,PZW                   ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
     3674 36BE     
11218 3676 06A0  32        bl   @jsr                       ;
     3678 FE28     
11219                                                                          ; and X to the colour for safe values
11220               
11221 367A D80E  30        movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
     367C 003E     
11222                                                                          ; X (the colour to use for safe values)
11223               
11224 367E D80D  30        movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
     3680 003D     
11225                                                                          ; A (the colour to use for dangerous values)
11226               
11227                                                                          ; The above sets the following indicators to show red
11228                                                                          ; for high values and yellow/white for low values, which
11229                                                                          ; we use for the cabin and laser temperature bars
11230               
11231 3682 020E  20        li   rx,>0b*256                 ; LDX #11           ; Set T1 to 11, the threshold at which we change the
     3684 0B00     
11232 3686 D80E  30        movb rx,@T1                     ; STX T1            ; cabin and laser temperature indicators' colours
     3688 0006     
11233               
11234 368A D360  30        movb @CABTMP,ra                 ; LDA CABTMP        ; Draw the cabin temperature indicator using a range of
     368C 0D4D     
11235 368E 0200  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     3690 36E0     
11236 3692 06A0  32        bl   @jsr                       ;
     3694 FE28     
11237                                                                          ; (the laser temperature)
11238               
11239 3696 D360  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Draw the laser temperature indicator using a range of
     3698 0D61     
11240 369A 0200  20        li   rtmp,DILX                  ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
     369C 36E0     
11241 369E 06A0  32        bl   @jsr                       ;
     36A0 FE28     
11242                                                                          ; (the altitude)
11243               
11244 36A2 020D  20        li   ra,>f0*256                 ; LDA #240          ; Set T1 to 240, the threshold at which we change the
     36A4 F000     
11245 36A6 D80D  30        movb ra,@T1                     ; STA T1            ; altitude indicator's colour. As the altitude has a
     36A8 0006     
11246                                                                          ; range of 0-255, pixel 16 will not be filled in, and
11247                                                                          ; 240 would change the colour when moving between pixels
11248                                                                          ; 15 and 16, so this effectively switches off the colour
11249                                                                          ; change for the altitude indicator
11250               
11251 36AA D80D  30        movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
     36AC 003E     
11252                                                                          ; 240, or &F0 (dashboard colour 2, yellow/white), so the
11253                                                                          ; altitude indicator always shows in this colour
11254               
11255 36AE D360  30        movb @ALTIT,ra                  ; LDA ALTIT         ; Draw the altitude indicator using a range of 0-255
     36B0 0F21     
11256 36B2 0200  20        li   rtmp,DILX                  ; JSR DILX
     36B4 36E0     
11257 36B6 06A0  32        bl   @jsr                       ;
     36B8 FE28     
11258               
11259 36BA 0460  28        b    @COMPAS                    ; JMP COMPAS        ; We have now drawn all the indicators, so jump to
     36BC B31A     
11260                                                                          ; COMPAS to draw the compass, returning from the
11261                                                                          ; subroutine using a tail call
11262               
11263               * ******************************************************************************
11264               *
11265               * Name: PZW
11266               * Type: Subroutine
11267               * Category: Dashboard
11268               * Summary: Fetch the current dashboard colours, to support flashing
11269               *
11270               * ------------------------------------------------------------------------------
11271               *
11272               * Set A and X to the colours we should use for indicators showing dangerous and
11273               * safe values respectively. This enables us to implement flashing indicators,
11274               * which is one of the game's configurable options.
11275               *
11276               * If flashing is enabled, the colour returned in A (dangerous values) will be
11277               * red for 8 iterations of the main loop, and yellow/white for the next 8, before
11278               * going back to red. If we always use PZW to decide which colours we should use
11279               * when updating indicators, flashing colours will be automatically taken care of
11280               * for us.
11281               *
11282               * The values returned are &F0 for yellow/white and &0F for red. These are mode 5
11283               * bytes that contain 4 pixels, with the colour of each pixel given in two bits,
11284               * the high bit from the first nibble (bits 4-7) and the low bit from the second
11285               * nibble (bits 0-3). So in &F0 each pixel is %10, or colour 2 (yellow or white,
11286               * depending on the dashboard palette), while in &0F each pixel is %01, or colour
11287               * 1 (red).
11288               *
11289               * ------------------------------------------------------------------------------
11290               *
11291               * Returns:
11292               *
11293               * A                   The colour to use for indicators with dangerous values
11294               *
11295               * X                   The colour to use for indicators with safe values
11296               *
11297               * ******************************************************************************
11298               
11299               PZW:
11300 36BE 020E  20        li   rx,>f0*256                 ; LDX #&F0          ; Set X to dashboard colour 2 (yellow/white)
     36C0 F000     
11301               
11302 36C2 D360  30        movb @MCNT,ra                   ; LDA MCNT          ; A will be non-zero for 8 out of every 16 main loop
     36C4 0099     
11303 36C6 024D  22        andi ra,>08*256                 ; AND #%00001000    ; counts, when bit 4 is set, so this is what we use to
     36C8 0800     
11304                                                                          ; flash the "danger" colour
11305               
11306                      .and @FLH                       ; AND FLH           ; A will be zeroed if flashing colours are disabled
     **** ****     > AND
0001 36CA D020  30        movb @FLH,rtmp
     36CC 0F4D     
0002 36CE 0540  14        inv  rtmp
0003 36D0 5340  18        szcb rtmp,ra
                   < elite.a99
11307               
11308 36D2 1302  14        jeq  B29                        ; BEQ B29           ; If A is zero, skip to the LDA instruction below
11309               
11310 36D4 D34E  18        movb rx,ra                      ; TXA               ; Otherwise flashing colours are enabled and it's the
11311                                                                          ; main loop iteration where we flash them, so set A to
11312                                                                          ; colour 2 (yellow/white) and use the BIT trick below to
11313                                                                          ; return from the subroutine
11314               
11315 36D6 2C              byte >2c                                            ; Skip the next instruction by turning it into
11316                                                                          ; &2C &A9 &0F, or BIT &0FA9, which does nothing apart
11317                                                                          ; from affect the flags
11318               
11319               B29:
11320 36D8 020D  20        li   ra,>0f*256                 ; LDA #&0F          ; Set A to dashboard colour 1 (red)
     36DA 0F00     
11321               
11322 36DC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     36DE FE34     
11323               
11324               * ******************************************************************************
11325               *
11326               * Name: DILX
11327               * Type: Subroutine
11328               * Category: Dashboard
11329               * Summary: Update a bar-based indicator on the dashboard
11330               * Deep dive: The dashboard indicators
11331               *
11332               * ------------------------------------------------------------------------------
11333               *
11334               * The range of values shown on the indicator depends on which entry point is
11335               * called. For the default entry point of DILX, the range is 0-255 (as the value
11336               * passed in A is one byte). The other entry points are shown below.
11337               *
11338               * ------------------------------------------------------------------------------
11339               *
11340               * Arguments:
11341               *
11342               * A                   The value to be shown on the indicator (so the larger
11343               * the value, the longer the bar)
11344               *
11345               * T1                  The threshold at which we change the indicator's colour
11346               * from the low value colour to the high value colour. The
11347               * threshold is in pixels, so it should have a value from
11348               * 0-16, as each bar indicator is 16 pixels wide
11349               *
11350               * K                   The colour to use when A is a high value, as a 4-pixel
11351               * mode 5 character row byte
11352               *
11353               * K+1                 The colour to use when A is a low value, as a 4-pixel
11354               * mode 5 character row byte
11355               *
11356               * SC(1 0)             The screen address of the first character block in the
11357               * indicator
11358               *
11359               * ------------------------------------------------------------------------------
11360               *
11361               * Other entry points:
11362               *
11363               * DILX+2              The range of the indicator is 0-64 (for the fuel
11364               * indicator)
11365               *
11366               * DIL-1               The range of the indicator is 0-32 (for the speed
11367               * indicator)
11368               *
11369               * DIL                 The range of the indicator is 0-16 (for the energy
11370               * banks)
11371               *
11372               * ******************************************************************************
11373               
11374               DILX:
11375 36E0 091D  18        srl  ra,1                       ; LSR A             ; If we call DILX, we set A = A / 16, so A is 0-15
11376 36E2 091D  18        srl  ra,1                       ; LSR A
11377               
11378 36E4 091D  18        srl  ra,1                       ; LSR A             ; If we call DILX+2, we set A = A / 4, so A is 0-15
11379               
11380 36E6 091D  18        srl  ra,1                       ; LSR A             ; If we call DIL-1, we set A = A / 2, so A is 0-15
11381               
11382               DIL:
11383                                                                          ; If we call DIL, we leave A alone, so A is 0-15
11384 36E8 D80D  30        movb ra,@Q                      ; STA Q             ; Store the indicator value in Q, now reduced to 0-15,
     36EA 0090     
11385                                                                          ; which is the length of the indicator to draw in pixels
11386               
11387 36EC 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set R = &FF, to use as a mask for drawing each row of
     36EE FF00     
11388 36F0 D80E  30        movb rx,@R                      ; STX R             ; each character block of the bar, starting with a full
     36F2 0091     
11389                                                                          ; character's width of 4 pixels
11390               
11391 36F4 9360  30        cb   @T1,ra                     ; CMP T1            ; If A >= T1 then we have passed the threshold where we
     36F6 0006     
11392 36F8 1803  14        joc  DL30                       ; BCS DL30          ; change bar colour, so jump to DL30 to set A to the
11393                                                                          ; "high value" colour
11394               
11395 36FA D360  30        movb @K+1,ra                    ; LDA K+1           ; Set A to K+1, the "low value" colour to use
     36FC 003E     
11396               
11397 36FE 1602  14        jne  DL31                       ; BNE DL31          ; Jump down to DL31 (this BNE is effectively a JMP as A
11398                                                                          ; will never be zero)
11399               
11400               DL30:
11401 3700 D360  30        movb @K,ra                      ; LDA K             ; Set A to K, the "high value" colour to use
     3702 003D     
11402               
11403               DL31:
11404 3704 D80D  30        movb ra,@COL                    ; STA COL           ; Store the colour of the indicator in COL
     3706 00A2     
11405               
11406 3708 020F  20        li   ry,>02*256                 ; LDY #2            ; We want to start drawing the indicator on the third
     370A 0200     
11407                                                                          ; line in this character row, so set Y to point to that
11408                                                                          ; row's offset
11409               
11410 370C 020E  20        li   rx,>03*256                 ; LDX #3            ; Set up a counter in X for the width of the indicator,
     370E 0300     
11411                                                                          ; which is 4 characters (each of which is 4 pixels wide,
11412                                                                          ; to give a total width of 16 pixels)
11413               
11414               DL1:
11415 3710 D360  30        movb @Q,ra                      ; LDA Q             ; Fetch the indicator value (0-15) from Q into A
     3712 0090     
11416               
11417 3714 028D  22        ci   ra,>04*256                 ; CMP #4            ; If Q < 4, then we need to draw the end cap of the
     3716 0400     
11418 3718 1733  14        jnc  DL2                        ; BCC DL2           ; indicator, which is less than a full character's
11419                                                                          ; width, so jump down to DL2 to do this
11420               
11421                      .sbi (>04*256)                  ; SBC #4            ; Otherwise we can draw a 4-pixel wide block, so
     **** ****     > SBI
0001 371A 1801  14        joc  !
0002 371C 7347  18        sb   rone,ra
0003               !:
0004 371E 022D  22        ai   ra,-(>04*256)
     3720 FC00     
                   < elite.a99
11422 3722 D80D  30        movb ra,@Q                      ; STA Q             ; subtract 4 from Q so it contains the amount of the
     3724 0090     
11423                                                                          ; indicator that's left to draw after this character
11424               
11425 3726 D360  30        movb @R,ra                      ; LDA R             ; Fetch the shape of the indicator row that we need to
     3728 0091     
11426                                                                          ; display from R, so we can use it as a mask when
11427                                                                          ; painting the indicator. It will be &FF at this point
11428                                                                          ; (i.e. a full 4-pixel row)
11429               
11430               DL5:
11431                      .and @COL                       ; AND COL           ; Fetch the 4-pixel mode 5 colour byte from COL, and
     **** ****     > AND
0001 372A D020  30        movb @COL,rtmp
     372C 00A2     
0002 372E 0540  14        inv  rtmp
0003 3730 5340  18        szcb rtmp,ra
                   < elite.a99
11432                                                                          ; only keep pixels that have their equivalent bits set
11433                                                                          ; in the mask byte in A
11434               
11435                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 3732 D820  42        movb @SC,@rtmplb
     3734 0007     
     3736 8301     
0002 3738 D020  30        movb @SC+1,rtmp
     373A 0008     
0003 373C 06CF  14        swpb ry
0004 373E A00F  18        a    ry,rtmp
0005 3740 06CF  14        swpb ry
0006 3742 D40D  30        movb RA,*rtmp
                   < elite.a99
11436                                                                          ; character block we are processing
11437               
11438 3744 B3C7  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11439                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 3746 D820  42        movb @SC,@rtmplb
     3748 0007     
     374A 8301     
0002 374C D020  30        movb @SC+1,rtmp
     374E 0008     
0003 3750 06CF  14        swpb ry
0004 3752 A00F  18        a    ry,rtmp
0005 3754 06CF  14        swpb ry
0006 3756 D40D  30        movb RA,*rtmp
                   < elite.a99
11440               
11441 3758 B3C7  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11442                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 375A D820  42        movb @SC,@rtmplb
     375C 0007     
     375E 8301     
0002 3760 D020  30        movb @SC+1,rtmp
     3762 0008     
0003 3764 06CF  14        swpb ry
0004 3766 A00F  18        a    ry,rtmp
0005 3768 06CF  14        swpb ry
0006 376A D40D  30        movb RA,*rtmp
                   < elite.a99
11443               
11444 376C D34F  18        movb ry,ra                      ; TYA               ; Add 6 to Y, so Y is now 8 more than when we started
11445                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 376E 0A16  18        sla  rzero,1
                   < elite.a99
11446                      .adi (>06*256)                  ; ADC #6            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 3770 1701  14        jnc  !
0002 3772 B347  18        ab   rone,ra
0003               !:
0004 3774 022D  22        ai   ra,(>06*256)
     3776 0600     
                   < elite.a99
11447 3778 D3CD  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11448                                                                          ; screen memory)
11449               
11450 377A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter for the next character
11451                                                                          ; block along in the indicator
11452               
11453 377C 111D  14        jlt  DL6                        ; BMI DL6           ; If we just drew the last character block then we are
11454                                                                          ; done drawing, so jump down to DL6 to finish off
11455               
11456 377E 15C8  14        jgt  DL1                        ; BPL DL1           ; Loop back to DL1 to draw the next character block of
11457                                                                          ; the indicator (this BPL is effectively a JMP as A will
11458                                                                          ; never be negative following the previous BMI)
11459               
11460               DL2:
11461                      .eoi (>03*256)                  ; EOR #3            ; If we get here then we are drawing the indicator's
     **** ****     > EOI
0001 3780 0200  20        li   rtmp,(>03*256)
     3782 0300     
0002 3784 2B40  18        xor  rtmp,ra
                   < elite.a99
11462 3786 D80D  30        movb ra,@Q                      ; STA Q             ; end cap, so Q is < 4, and this EOR flips the bits, so
     3788 0090     
11463                                                                          ; instead of containing the number of indicator columns
11464                                                                          ; we need to fill in on the left side of the cap's
11465                                                                          ; character block, Q now contains the number of blank
11466                                                                          ; columns there should be on the right side of the cap's
11467                                                                          ; character block
11468               
11469 378A D360  30        movb @R,ra                      ; LDA R             ; Fetch the current mask from R, which will be &FF at
     378C 0091     
11470                                                                          ; this point, so we need to turn Q of the columns on the
11471                                                                          ; right side of the mask to black to get the correct end
11472                                                                          ; cap shape for the indicator
11473               
11474               DL3:
11475                      .asla                           ; ASL A             ; Shift the mask left so bit 0 is cleared, and then
     **** ****     > ASLA
0001 378E 024D  22        andi ra,>ff00
     3790 FF00     
0002 3792 0A1D  18        sla  ra,1
                   < elite.a99
11476 3794 024D  22        andi ra,>ef*256                 ; AND #%11101111    ; clear bit 4, which has the effect of shifting zeroes
     3796 EF00     
11477                                                                          ; from the left into each nibble (i.e. xxxx xxxx becomes
11478                                                                          ; xxx0 xxx0, which blanks out the last column in the
11479                                                                          ; 4-pixel mode 5 character block)
11480               
11481 3798 7347  18        sb   rone,ra                    ; DEC Q             ; Decrement the counter for the number of columns to
11482                                                                          ; blank out
11483               
11484 379A 15F9  14        jgt  DL3                        ; BPL DL3           ; If we still have columns to blank out in the mask,
11485                                                                          ; loop back to DL3 until the mask is correct for the
11486                                                                          ; end cap
11487               
11488                      .pha                            ; PHA               ; Store the mask byte on the stack while we use the
     **** ****     > PHA
0001 379C D68D  30        movb ra,*rsp
0002 379E 060A  14        dec  rsp
                   < elite.a99
11489                                                                          ; accumulator for a bit
11490               
11491 37A0 020D  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so the characters
     37A2 0000     
11492 37A4 D80D  30        movb ra,@R                      ; STA R             ; after the one we're about to draw will be all blank
     37A6 0091     
11493               
11494 37A8 020D  20        li   ra,>63*256                 ; LDA #99           ; Set Q to a high number (99, why not) so we will keep
     37AA 6300     
11495 37AC D80D  30        movb ra,@Q                      ; STA Q             ; drawing blank characters until we reach the end of
     37AE 0090     
11496                                                                          ; the indicator row
11497               
11498                      .pla                            ; PLA               ; Restore the mask byte from the stack so we can use it
     **** ****     > PLA
0001 37B0 058A  14        inc  rsp
0002 37B2 D35A  26        movb *rsp,ra
                   < elite.a99
11499                                                                          ; to draw the end cap of the indicator
11500               
11501 37B4 0460  28        b    @DL5                       ; JMP DL5           ; Jump back up to DL5 to draw the mask byte on-screen
     37B6 372A     
11502               
11503               DL6:
11504 37B8 B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11505                                                                          ; character row on-screen (as each row takes up exactly
11506                                                                          ; one page of 256 bytes) - so this sets up SC to point
11507                                                                          ; to the next indicator, i.e. the one below the one we
11508                                                                          ; just drew
11509               
11510               DL9:
11511 37BA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     37BC FE34     
11512               
11513               * ******************************************************************************
11514               *
11515               * Name: DIL2
11516               * Type: Subroutine
11517               * Category: Dashboard
11518               * Summary: Update the roll or pitch indicator on the dashboard
11519               * Deep dive: The dashboard indicators
11520               *
11521               * ------------------------------------------------------------------------------
11522               *
11523               * The indicator can show a vertical bar in 16 positions, with a value of 8
11524               * showing the bar in the middle of the indicator.
11525               *
11526               * In practice this routine is only ever called with A in the range 1 to 15, so
11527               * the vertical bar never appears in the leftmost position (though it does appear
11528               * in the rightmost).
11529               *
11530               * ------------------------------------------------------------------------------
11531               *
11532               * Arguments:
11533               *
11534               * A                   The offset of the vertical bar to show in the indicator,
11535               * from 0 at the far left, to 8 in the middle, and 15 at
11536               * the far right
11537               *
11538               * ------------------------------------------------------------------------------
11539               *
11540               * Returns:
11541               *
11542               * C flag              The C flag is set
11543               *
11544               * ******************************************************************************
11545               
11546               DIL2:
11547 37BE 020F  20        li   ry,>01*256                 ; LDY #1            ; We want to start drawing the vertical indicator bar on
     37C0 0100     
11548                                                                          ; the second line in the indicator's character block, so
11549                                                                          ; set Y to point to that row's offset
11550               
11551 37C2 D80D  30        movb ra,@Q                      ; STA Q             ; Store the offset of the vertical bar to draw in Q
     37C4 0090     
11552               
11553                                                                          ; We are now going to work our way along the indicator
11554                                                                          ; on the dashboard, from left to right, working our way
11555                                                                          ; along one character block at a time. Y will be used as
11556                                                                          ; a pixel row counter to work our way through the
11557                                                                          ; character blocks, so each time we draw a character
11558                                                                          ; block, we will increment Y by 8 to move on to the next
11559                                                                          ; block (as each character block contains 8 rows)
11560               
11561               DLL10:
11562                      .sec                            ; SEC               ; Set A = Q - 4, so that A contains the offset of the
     **** ****     > SEC
0001 37C6 0A18  18        sla  rmone,1
                   < elite.a99
11563 37C8 D360  30        movb @Q,ra                      ; LDA Q             ; vertical bar from the start of this character block
     37CA 0090     
11564                      .sbi (>04*256)                  ; SBC #4
     **** ****     > SBI
0001 37CC 1801  14        joc  !
0002 37CE 7347  18        sb   rone,ra
0003               !:
0004 37D0 022D  22        ai   ra,-(>04*256)
     37D2 FC00     
                   < elite.a99
11565               
11566 37D4 180D  14        joc  DLL11                      ; BCS DLL11         ; If Q >= 4 then the character block we are drawing does
11567                                                                          ; not contain the vertical indicator bar, so jump to
11568                                                                          ; DLL11 to draw a blank character block
11569               
11570 37D6 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to a high number (and &FF is as high as they go)
     37D8 FF00     
11571               
11572 37DA D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X to the offset of the vertical bar, which we know
     37DC 0090     
11573                                                                          ; is within this character block
11574               
11575 37DE D80D  30        movb ra,@Q                      ; STA Q             ; Set Q to a high number (&FF, why not) so we will keep
     37E0 0090     
11576                                                                          ; drawing blank characters after this one until we reach
11577                                                                          ; the end of the indicator row
11578               
11579 37E2 06CE  14        swpb rx                         ;
11580 37E4 D36E  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; CTWOS is a table of ready-made 1-pixel mode 5 bytes,
     37E6 23B9     
11581 37E8 06CE  14        swpb rx                         ;
11582                                                                          ; just like the TWOS and TWOS2 tables for mode 4 (see
11583                                                                          ; the PIXEL routine for details of how they work). This
11584                                                                          ; fetches a mode 5 1-pixel byte with the pixel position
11585                                                                          ; at X, so the pixel is at the offset that we want for
11586                                                                          ; our vertical bar
11587               
11588 37EA 024D  22        andi ra,>f0*256                 ; AND #&F0          ; The 4-pixel mode 5 colour byte &F0 represents four
     37EC F000     
11589                                                                          ; pixels of colour %10 (3), which is yellow in the
11590                                                                          ; normal dashboard palette and white if we have an
11591                                                                          ; escape pod fitted. We AND this with A so that we only
11592                                                                          ; keep the pixel that matches the position of the
11593                                                                          ; vertical bar (i.e. A is acting as a mask on the
11594                                                                          ; 4-pixel colour byte)
11595               
11596 37EE 1604  14        jne  DLL12                      ; BNE DLL12         ; Jump to DLL12 to skip the code for drawing a blank,
11597                                                                          ; and move on to drawing the indicator (this BNE is
11598                                                                          ; effectively a JMP as A is always non-zero)
11599               
11600               DLL11:
11601                                                                          ; If we get here then we want to draw a blank for this
11602                                                                          ; character block
11603 37F0 D80D  30        movb ra,@Q                      ; STA Q             ; Update Q with the new offset of the vertical bar, so
     37F2 0090     
11604                                                                          ; it becomes the offset after the character block we
11605                                                                          ; are about to draw
11606               
11607 37F4 020D  20        li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so all of the
     37F6 0000     
11608                                                                          ; character blocks we display from now on will be blank
11609               DLL12:
11610                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
     **** ****     > ST_IND_Y_IDX
0001 37F8 D820  42        movb @SC,@rtmplb
     37FA 0007     
     37FC 8301     
0002 37FE D020  30        movb @SC+1,rtmp
     3800 0008     
0003 3802 06CF  14        swpb ry
0004 3804 A00F  18        a    ry,rtmp
0005 3806 06CF  14        swpb ry
0006 3808 D40D  30        movb RA,*rtmp
                   < elite.a99
11611                                                                          ; character block we are processing
11612               
11613 380A B3C7  18        ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
11614                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 380C D820  42        movb @SC,@rtmplb
     380E 0007     
     3810 8301     
0002 3812 D020  30        movb @SC+1,rtmp
     3814 0008     
0003 3816 06CF  14        swpb ry
0004 3818 A00F  18        a    ry,rtmp
0005 381A 06CF  14        swpb ry
0006 381C D40D  30        movb RA,*rtmp
                   < elite.a99
11615               
11616 381E B3C7  18        ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
11617                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 3820 D820  42        movb @SC,@rtmplb
     3822 0007     
     3824 8301     
0002 3826 D020  30        movb @SC+1,rtmp
     3828 0008     
0003 382A 06CF  14        swpb ry
0004 382C A00F  18        a    ry,rtmp
0005 382E 06CF  14        swpb ry
0006 3830 D40D  30        movb RA,*rtmp
                   < elite.a99
11618               
11619 3832 B3C7  18        ab   rone,ry                    ; INY               ; And draw the fourth pixel row, incrementing Y
11620                      .st_ind_y_idx @SC,ra            ; STA (SC),Y
     **** ****     > ST_IND_Y_IDX
0001 3834 D820  42        movb @SC,@rtmplb
     3836 0007     
     3838 8301     
0002 383A D020  30        movb @SC+1,rtmp
     383C 0008     
0003 383E 06CF  14        swpb ry
0004 3840 A00F  18        a    ry,rtmp
0005 3842 06CF  14        swpb ry
0006 3844 D40D  30        movb RA,*rtmp
                   < elite.a99
11621               
11622 3846 D34F  18        movb ry,ra                      ; TYA               ; Add 5 to Y, so Y is now 8 more than when we started
11623                      .clc                            ; CLC               ; this loop iteration, so Y now points to the address
     **** ****     > CLC
0001 3848 0A16  18        sla  rzero,1
                   < elite.a99
11624                      .adi (>05*256)                  ; ADC #5            ; of the first line of the indicator bar in the next
     **** ****     > ADI
0001 384A 1701  14        jnc  !
0002 384C B347  18        ab   rone,ra
0003               !:
0004 384E 022D  22        ai   ra,(>05*256)
     3850 0500     
                   < elite.a99
11625 3852 D3CD  18        movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
11626                                                                          ; screen memory)
11627               
11628 3854 028F  22        ci   ry,>1e*256                 ; CPY #30           ; If Y < 30 then we still have some more character
     3856 1E00     
11629 3858 17B6  14        jnc  DLL10                      ; BCC DLL10         ; blocks to draw, so loop back to DLL10 to display the
11630                                                                          ; next one along
11631               
11632 385A B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
11633                                                                          ; character row on-screen (as each row takes up exactly
11634                                                                          ; one page of 256 bytes) - so this sets up SC to point
11635                                                                          ; to the next indicator, i.e. the one below the one we
11636                                                                          ; just drew
11637               
11638 385C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     385E FE34     
11639               
11640               * ******************************************************************************
11641               *
11642               * Name: TVT1
11643               * Type: Variable
11644               * Category: Drawing the screen
11645               * Summary: Palette data for space and the two dashboard colour schemes
11646               *
11647               * ------------------------------------------------------------------------------
11648               *
11649               * Palette bytes for use with the split-screen mode (see IRQ1 below for more
11650               * details).
11651               *
11652               * Palette data is given as a set of bytes, with each byte mapping a logical
11653               * colour to a physical one. In each byte, the logical colour is given in bits
11654               * 4-7 and the physical colour in bits 0-3. See p.379 of the Advanced User Guide
11655               * for details of how palette mapping works, as in modes 4 and 5 we have to do
11656               * multiple palette commands to change the colours correctly, and the physical
11657               * colour value is EOR'd with 7, just to make things even more confusing.
11658               *
11659               * Similarly, the palette at TVT1+16 is for the monochrome space view, where
11660               * logical colour 1 is mapped to physical colour 0 EOR 7 = 7 (white), and
11661               * logical colour 0 is mapped to physical colour 7 EOR 7 = 0 (black). Each of
11662               * these mappings requires six calls to SHEILA &21 - see p.379 of the Advanced
11663               * User Guide for an explanation.
11664               *
11665               * The mode 5 palette table has two blocks which overlap. The block used depends
11666               * on whether or not we have an escape pod fitted. The block at TVT1 is used for
11667               * the standard dashboard colours, while TVT1+8 is used for the dashboard when an
11668               * escape pod is fitted. The colours are as follows:
11669               *
11670               * Normal (TVT1)     Escape pod (TVT1+8)
11671               *
11672               * Colour 0      Black             Black
11673               * Colour 1      Red               Red
11674               * Colour 2      Yellow            White
11675               * Colour 3      Green             Cyan
11676               *
11677               * ******************************************************************************
11678               
11679               TVT1:
11680 3860 D4C4            byte >d4,>c4                                        ; This block of palette data is used to create two
11681 3862 9484            byte >94,>84                                        ; palettes used in three different places, all of them
11682 3864 F5E5            byte >f5,>e5                                        ; redefining four colours in mode 5:
11683 3866 B5A5            byte >b5,>a5                                        ;
11684                                                                          ; 12 bytes from TVT1 (i.e. the first 6 rows): applied
11685 3868 7666            byte >76,>66                                        ; when the T1 timer runs down at the switch from the
11686 386A 3626            byte >36,>26                                        ; space view to the dashboard, so this is the standard
11687                                                                          ; dashboard palette
11688 386C E1F1            byte >e1,>f1                                        ;
11689 386E B1A1            byte >b1,>a1                                        ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11690                                                                          ; when the T1 timer runs down at the switch from the
11691                                                                          ; space view to the dashboard, and we have an escape
11692                                                                          ; pod fitted, so this is the escape pod dashboard
11693                                                                          ; palette
11694                                                                          ;
11695                                                                          ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
11696                                                                          ; at vertical sync in LINSCN when HFX is non-zero, to
11697                                                                          ; create the hyperspace effect in LINSCN (where the
11698                                                                          ; whole screen is switched to mode 5 at vertical sync)
11699               
11700 3870 F0E0            byte >f0,>e0                                        ; 12 bytes of palette data at TVT1+16, used to set the
11701 3872 B0A0            byte >b0,>a0                                        ; mode 4 palette in LINSCN when we hit vertical sync,
11702 3874 D0C0            byte >d0,>c0                                        ; so the palette is set to monochrome when we start to
11703 3876 9080            byte >90,>80                                        ; draw the first row of the screen
11704 3878 7767            byte >77,>67
11705 387A 3727            byte >37,>27
11706               
11707               * ******************************************************************************
11708               *
11709               * Name: IRQ1
11710               * Type: Subroutine
11711               * Category: Drawing the screen
11712               * Summary: The main screen-mode interrupt handler (IRQ1V points here)
11713               * Deep dive: The split-screen mode in BBC Micro Elite
11714               *
11715               * ------------------------------------------------------------------------------
11716               *
11717               * The main interrupt handler, which implements Elite's split-screen mode (see
11718               * the deep dive on "The split-screen mode in BBC Micro Elite" for details).
11719               *
11720               * IRQ1V is set to point to IRQ1 by the loading process.
11721               *
11722               * ******************************************************************************
11723               
11724               LINSCN:
11725                                                                          ; This is called from the interrupt handler below, at
11726                                                                          ; the start of each vertical sync (i.e. when the screen
11727                                                                          ; refresh starts)
11728 387C 020D  20        li   ra,>1e*256                 ; LDA #30           ; Set the line scan counter to a non-zero value, so
     387E 1E00     
11729 3880 D80D  30        movb ra,@DL                     ; STA DL            ; routines like WSCAN can set DL to 0 and then wait for
     3882 009A     
11730                                                                          ; it to change to non-zero to catch the vertical sync
11731               
11732 3884 D80D  38        movb ra,@VIA+>44                ; STA VIA+&44       ; Set 6522 System VIA T1C-L timer 1 low-order counter
     3886 FE44     
11733                                                                          ; (SHEILA &44) to 30
11734               
11735 3888 020D  20        li   ra,(VSCAN)*256             ; LDA #VSCAN        ; Set 6522 System VIA T1C-L timer 1 high-order counter
     388A 3900     
11736 388C D80D  38        movb ra,@VIA+>45                ; STA VIA+&45       ; (SHEILA &45) to VSCAN (57) to start the T1 counter
     388E FE45     
11737                                                                          ; counting down from 14622 at a rate of 1 MHz
11738               
11739 3890 D360  30        movb @HFX,ra                    ; LDA HFX           ; If HFX is non-zero, jump to VNT1 to set the mode 5
     3892 0D62     
11740 3894 1641  14        jne  VNT1                       ; BNE VNT1          ; palette instead of switching to mode 4, which will
11741                                                                          ; have the effect of blurring and colouring the top
11742                                                                          ; screen. This is how the white hyperspace rings turn
11743                                                                          ; to colour when we do a hyperspace jump, and is
11744                                                                          ; triggered by setting HFX to 1 in routine LL164
11745               
11746 3896 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; Set the Video ULA control register (SHEILA &20) to
     3898 0800     
11747 389A D80D  38        movb ra,@VIA+>20                ; STA VIA+&20       ; %00001000, which is the same as switching to mode 4
     389C FE20     
11748                                                                          ; (i.e. the top part of the screen) but with no cursor
11749               
11750               VNT3:
11751 389E 06CF  14        swpb ry                         ;
11752 38A0 D36F  34        movb @TVT1+16(ry),ra            ; LDA TVT1+16,Y     ; Copy the Y-th palette byte from TVT1+16 to SHEILA &21
     38A2 3870     
11753 38A4 06CF  14        swpb ry                         ;
11754 38A6 D80D  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     38A8 FE21     
11755                                                                          ; of the screen (i.e. the dashboard)
11756               
11757 38AA 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11758               
11759 38AC 15F8  14        jgt  VNT3                       ; BPL VNT3          ; Loop back to VNT3 until we have copied all the
11760                                                                          ; palette bytes
11761               
11762 38AE D360  30        movb @LASCT,ra                  ; LDA LASCT         ; Decrement the value of LASCT, but if we go too far
     38B0 0D60     
11763 38B2 1301  14        jeq  B30                        ; BEQ B30           ; and it becomes negative, bump it back up again (this
11764 38B4 7347  18        sb   rone,ra                    ; DEC LASCT         ; controls the pulsing of pulse lasers)
11765               
11766               B30:
11767 38B6 D360  34        movb @SVN,ra                    ; LDA SVN           ; If SVN is non-zero, we are in the process of saving
     38B8 FC29     
11768 38BA 1625  14        jne  jvec_                      ; BNE jvec          ; the commander file, so jump to jvec to pass control
11769                                                                          ; to the next interrupt handler, so we don't break file
11770                                                                          ; saving by blocking the interrupt chain
11771               
11772                      .pla                            ; PLA               ; Otherwise restore Y from the stack
     **** ****     > PLA
0001 38BC 058A  14        inc  rsp
0002 38BE D35A  26        movb *rsp,ra
                   < elite.a99
11773 38C0 D3CD  18        movb ra,ry                      ; TAY
11774               
11775 38C2 D360  34        movb @VIA+>41,ra                ; LDA VIA+&41       ; Read 6522 System VIA input register IRA (SHEILA &41)
     38C4 FE41     
11776               
11777 38C6 D360  30        movb @>FC,ra                    ; LDA &FC           ; Set A to the interrupt accumulator save register,
     38C8 00FC     
11778                                                                          ; which restores A to the value it had on entering the
11779                                                                          ; interrupt
11780               
11781                      ; RTI                           ; RTI               ; Return from interrupts, so this interrupt is not
11782                                                                          ; passed on to the next interrupt handler, but instead
11783                                                                          ; the interrupt terminates here
11784               
11785               IRQ1:
11786 38CA D34F  18        movb ry,ra                      ; TYA               ; Store Y on the stack
11787                      .pha                            ; PHA
     **** ****     > PHA
0001 38CC D68D  30        movb ra,*rsp
0002 38CE 060A  14        dec  rsp
                   < elite.a99
11788               
11789 38D0 020F  20        li   ry,>0b*256                 ; LDY #11           ; Set Y as a counter for 12 bytes, to use when setting
     38D2 0B00     
11790                                                                          ; the dashboard palette below
11791               
11792 38D4 020D  20        li   ra,>02*256                 ; LDA #%00000010    ; Read the 6522 System VIA status byte bit 1 (SHEILA
     38D6 0200     
11793                      .bit @VIA+>4D                   ; BIT VIA+&4D       ; &4D), which is set if vertical sync has occurred on
     **** ****     > BIT
0001 38D8 D020  34        movb @VIA+>4D,rtmp
     38DA FE4D     
0002 38DC 0540  14        inv  rtmp
0003 38DE D047  18        movb rone,rtmp2
0004 38E0 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
11794                                                                          ; the video system
11795               
11796 38E2 16CC  14        jne  LINSCN                     ; BNE LINSCN        ; If we are on the vertical sync pulse, jump to LINSCN
11797                                                                          ; to set up the timers to enable us to switch the
11798                                                                          ; screen mode between the space view and dashboard
11799               
11800 38E4 1910  14        jno  jvec_                      ; BVC jvec          ; Read the 6522 System VIA status byte bit 6, which is
11801                                                                          ; set if timer 1 has timed out. We set the timer in
11802                                                                          ; LINSCN above, so this means we only run the next bit
11803                                                                          ; if the screen redraw has reached the boundary between
11804                                                                          ; the space view and the dashboard. Otherwise bit 6 is
11805                                                                          ; clear and we aren't at the boundary, so we jump to
11806                                                                          ; jvec to pass control to the next interrupt handler
11807               
11808                      .asla                           ; ASL A             ; Double the value in A to 4
     **** ****     > ASLA
0001 38E6 024D  22        andi ra,>ff00
     38E8 FF00     
0002 38EA 0A1D  18        sla  ra,1
                   < elite.a99
11809               
11810 38EC D80D  38        movb ra,@VIA+>20                ; STA VIA+&20       ; Set the Video ULA control register (SHEILA &20) to
     38EE FE20     
11811                                                                          ; %00000100, which is the same as switching to mode 5,
11812                                                                          ; (i.e. the bottom part of the screen) but with no
11813                                                                          ; cursor
11814               
11815 38F0 D360  30        movb @ESCP,ra                   ; LDA ESCP          ; If an escape pod is fitted, jump to VNT1 to set the
     38F2 032E     
11816 38F4 1611  14        jne  VNT1                       ; BNE VNT1          ; mode 5 palette differently (so the dashboard is a
11817                                                                          ; different colour if we have an escape pod)
11818               
11819               B31:
11820 38F6 06CF  14        swpb ry                         ;
11821 38F8 D36F  34        movb @TVT1(ry),ra               ; LDA TVT1,Y        ; Copy the Y-th palette byte from TVT1 to SHEILA &21
     38FA 3860     
11822 38FC 06CF  14        swpb ry                         ;
11823 38FE D80D  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     3900 FE21     
11824                                                                          ; of the screen (i.e. the dashboard)
11825               
11826 3902 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11827               
11828 3904 15F8  14        jgt  B31                        ; BPL B31           ; Loop back to the LDA TVT1,Y instruction until we have
11829                                                                          ; copied all the palette bytes
11830               
11831               jvec_:
11832                      .pla                            ; PLA               ; Restore Y from the stack
     **** ****     > PLA
0001 3906 058A  14        inc  rsp
0002 3908 D35A  26        movb *rsp,ra
                   < elite.a99
11833 390A D3CD  18        movb ra,ry                      ; TAY
11834               
11835                      .jmpi @VEC                      ; JMP (VEC)         ; Jump to the address in VEC, which was set to the
     **** ****     > JMPI
0001 390C D82E  46        movb @VEC(rx),@rtmplb
     390E FC2A     
     3910 8301     
0002 3912 D02E  34        movb @VEC+1(rx),rtmp
     3914 FC2B     
0003 3916 0450  20        b    *rtmp
                   < elite.a99
11836                                                                          ; original IRQ1V vector by the loading process, so this
11837                                                                          ; instruction passes control to the next interrupt
11838                                                                          ; handler
11839               
11840               VNT1:
11841 3918 020F  20        li   ry,>07*256                 ; LDY #7            ; Set Y as a counter for 8 bytes
     391A 0700     
11842               
11843 391C 06CF  14        swpb ry                         ;
11844 391E D36F  34        movb @TVT1+8(ry),ra             ; LDA TVT1+8,Y      ; Copy the Y-th palette byte from TVT1+8 to SHEILA &21
     3920 3868     
11845 3922 06CF  14        swpb ry                         ;
11846 3924 D80D  38        movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
     3926 FE21     
11847                                                                          ; of the screen (i.e. the dashboard)
11848               
11849 3928 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the palette byte counter
11850               
11851 392A 15F7  14        jgt  VNT1+2                     ; BPL VNT1+2        ; Loop back to the LDA TVT1+8,Y instruction until we
11852                                                                          ; have copied all the palette bytes
11853               
11854 392C 11EC  14        jlt  jvec_                      ; BMI jvec          ; Jump up to jvec to pass control to the next interrupt
11855                                                                          ; handler (this BMI is effectively a JMP as we didn't
11856                                                                          ; loop back with the BPL above, so BMI is always true)
11857               
11858               * ******************************************************************************
11859               *
11860               * Name: ESCAPE
11861               * Type: Subroutine
11862               * Category: Flight
11863               * Summary: Launch our escape pod
11864               *
11865               * ------------------------------------------------------------------------------
11866               *
11867               * This routine displays our doomed Cobra Mk III disappearing off into the ether
11868               * before arranging our replacement ship. Called when we press ESCAPE during
11869               * flight and have an escape pod fitted.
11870               *
11871               * ******************************************************************************
11872               
11873               ESCAPE:
11874 392E D360  30        movb @MJ,ra                     ; LDA MJ            ; Store the value of MJ on the stack (the "are we in
     3930 0D5C     
11875                      .pha                            ; PHA               ; witchspace?" flag)
     **** ****     > PHA
0001 3932 D68D  30        movb ra,*rsp
0002 3934 060A  14        dec  rsp
                   < elite.a99
11876               
11877 3936 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     3938 C682     
11878 393A 06A0  32        bl   @jsr                       ;
     393C FE28     
11879               
11880 393E 020E  20        li   rx,(CYL)*256               ; LDX #CYL          ; Set the current ship type to a Cobra Mk III, so we
     3940 0700     
11881 3942 D80E  30        movb rx,@TYPE                   ; STX TYPE          ; can show our ship disappear into the distance when we
     3944 009B     
11882                                                                          ; eject in our pod
11883               
11884 3946 0200  20        li   rtmp,FRS1                  ; JSR FRS1          ; Call FRS1 to launch the Cobra Mk III straight ahead,
     3948 3F0C     
11885 394A 06A0  32        bl   @jsr                       ;
     394C FE28     
11886                                                                          ; like a missile launch, but with our ship instead
11887               
11888 394E 020D  20        li   ra,>08*256                 ; LDA #8            ; Set the Cobra's byte #27 (speed) to 8
     3950 0800     
11889 3952 D80D  30        movb ra,@INWK+27                ; STA INWK+27
     3954 006E     
11890               
11891 3956 020D  20        li   ra,>c2*256                 ; LDA #194          ; Set the Cobra's byte #30 (pitch counter) to 194, so it
     3958 C200     
11892 395A D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; pitches up as we pull away
     395C 0071     
11893               
11894 395E 091D  18        srl  ra,1                       ; LSR A             ; Set the Cobra's byte #32 (AI flag) to %01100001, so it
11895 3960 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; has no AI, and we can use this value as a counter to
     3962 0073     
11896                                                                          ; do the following loop 97 times
11897               
11898               ESL1:
11899 3964 0200  20        li   rtmp,MVEIT                 ; JSR MVEIT         ; Call MVEIT to move the Cobra in space
     3966 184A     
11900 3968 06A0  32        bl   @jsr                       ;
     396A FE28     
11901               
11902 396C 0200  20        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to draw the Cobra on-screen
     396E DCBC     
11903 3970 06A0  32        bl   @jsr                       ;
     3972 FE28     
11904               
11905 3974 7347  18        sb   rone,ra                    ; DEC INWK+32       ; Decrement the counter in byte #32
11906               
11907 3976 16F6  14        jne  ESL1                       ; BNE ESL1          ; Loop back to keep moving the Cobra until the AI flag
11908                                                                          ; is 0, which gives it time to drift away from our pod
11909               
11910 3978 0200  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to remove the Cobra from the scanner (by
     397A 505A     
11911 397C 06A0  32        bl   @jsr                       ;
     397E FE28     
11912                                                                          ; redrawing it)
11913               
11914 3980 0200  20        li   rtmp,RESET                 ; JSR RESET         ; Call RESET to reset our ship and various controls
     3982 C652     
11915 3984 06A0  32        bl   @jsr                       ;
     3986 FE28     
11916               
11917                      .pla                            ; PLA               ; Restore the witchspace flag from before the escape pod
     **** ****     > PLA
0001 3988 058A  14        inc  rsp
0002 398A D35A  26        movb *rsp,ra
                   < elite.a99
11918 398C 1302  14        jeq  B32                        ; BEQ B32           ; launch, and if we were in normal space, skip the
11919                                                                          ; following instruction
11920               
11921 398E 0460  28        b    @DEATH                     ; JMP DEATH         ; Launching an escape pod in witchspace is fatal, so
     3990 CBD2     
11922                                                                          ; jump to DEATH to begin the funeral and return from the
11923                                                                          ; subroutine using a tail call
11924               
11925               B32:
11926 3992 020E  20        li   rx,>10*256                 ; LDX #16           ; We lose all our cargo when using our escape pod, so
     3994 1000     
11927                                                                          ; up a counter in X so we can zero the 17 cargo slots
11928                                                                          ; in QQ20
11929               
11930               ESL2:
11931 3996 06CE  14        swpb rx                         ;
11932 3998 DB8D  38        movb ra,@QQ20(rx)               ; STA QQ20,X        ; Set the X-th byte of QQ20 to zero (as we know A = 0
     399A 0317     
11933 399C 06CE  14        swpb rx                         ;
11934                                                                          ; from the BEQ above), so we no longer have any of item
11935                                                                          ; type X in the cargo hold
11936               
11937 399E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
11938               
11939 39A0 15FA  14        jgt  ESL2                       ; BPL ESL2          ; Loop back to ESL2 until we have emptied the entire
11940                                                                          ; cargo hold
11941               
11942 39A2 D80D  30        movb ra,@FIST                   ; STA FIST          ; Launching an escape pod also clears our criminal
     39A4 0334     
11943                                                                          ; record, so set our legal status in FIST to 0 ("clean")
11944               
11945 39A6 D80D  30        movb ra,@ESCP                   ; STA ESCP          ; The escape pod is a one-use item, so set ESCP to 0 so
     39A8 032E     
11946                                                                          ; we no longer have one fitted
11947               
11948 39AA 020D  20        li   ra,>46*256                 ; LDA #70           ; Our replacement ship is delivered with a full tank of
     39AC 4600     
11949 39AE D80D  30        movb ra,@QQ14                   ; STA QQ14          ; fuel, so set the current fuel level in QQ14 to 70, or
     39B0 030D     
11950                                                                          ; 7.0 light years
11951               
11952 39B2 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     39B4 CDBC     
11953                                                                          ; screen) and return from the subroutine with a tail
11954                                                                          ; call
11955               
11956               * ******************************************************************************
11957               *
11958               * Save ELTB.bin
11959               *
11960               * ******************************************************************************
11961               
11962                      ; PRINT "ELITE B"
11963                      ; PRINT "Assembled at ", ~CODE_B%
11964                      ; PRINT "Ends at ", ~P%
11965                      ; PRINT "Code size is ", ~(P% - CODE_B%)
11966                      ; PRINT "Execute at ", ~LOAD%
11967                      ; PRINT "Reload at ", ~LOAD_B%
11968               
11969                      ; PRINT "S.ELTB ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_B%
11970                      ; SAVE "3-assembled-output/ELTB.bin", CODE_B%, P%, LOAD%
11971               
11972               * ******************************************************************************
11973               *
11974               * ELITE C FILE
11975               *
11976               * Produces the binary file ELTC.bin that gets loaded by elite-bcfs.asm.
11977               *
11978               * ******************************************************************************
11979               
11980               CODE_C.:
11981                      equ $
11982               
11983               LOAD_C.:
11984                      equ LOAD. + $ - CODE.
11985               
11986               * ******************************************************************************
11987               *
11988               * Name: TACTICS (Part 1 of 7)
11989               * Type: Subroutine
11990               * Category: Tactics
11991               * Summary: Apply tactics: Process missiles, both enemy missiles and our own
11992               * Deep dive: Program flow of the tactics routine
11993               *
11994               * ------------------------------------------------------------------------------
11995               *
11996               * This section implements missile tactics and is entered at TA18 from the main
11997               * entry point below, if the current ship is a missile. Specifically:
11998               *
11999               * * If E.C.M. is active, destroy the missile
12000               *
12001               * * If the missile is hostile towards us, then check how close it is. If it
12002               * hasn't reached us, jump to part 3 so it can streak towards us, otherwise
12003               * we've been hit, so process a large amount of damage to our ship
12004               *
12005               * * Otherwise see how close the missile is to its target. If it has not yet
12006               * reached its target, give the target a chance to activate its E.C.M. if it
12007               * has one, otherwise jump to TA19 with K3 set to the vector from the target
12008               * to the missile
12009               *
12010               * * If it has reached its target and the target is the space station, destroy
12011               * the missile, potentially damaging us if we are nearby
12012               *
12013               * * If it has reached its target and the target is a ship, destroy the missile
12014               * and the ship, potentially damaging us if we are nearby
12015               *
12016               * ******************************************************************************
12017               
12018               TA34:
12019                                                                          ; If we get here, the missile is hostile
12020 39B6 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     39B8 0000     
12021 39BA 0200  20        li   rtmp,MAS4                  ; JSR MAS4
     39BC CBC2     
12022 39BE 06A0  32        bl   @jsr                       ;
     39C0 FE28     
12023               
12024 39C2 1300  14        jeq  B33                        ; BEQ B33           ; If A = 0 then the missile is very close to our ship,
12025                                                                          ; so skip the following instruction
12026               
12027               B33:
12028 39C4 0460  28        b    @TA21                      ; JMP TA21          ; Jump down to part 3 to set up the vectors and skip
     39C6 3BB2     
12029                                                                          ; straight to aggressive manoeuvring
12030               
12031 39C8 0200  20        li   rtmp,TA87+3                ; JSR TA87+3        ; The missile has hit our ship, so call TA87+3 to set
     39CA 3AAF     
12032 39CC 06A0  32        bl   @jsr                       ;
     39CE FE28     
12033                                                                          ; bit 7 of the missile's byte #31, which marks the
12034                                                                          ; missile as being killed
12035               
12036 39D0 0200  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of the missile exploding
     39D2 D2BE     
12037 39D4 06A0  32        bl   @jsr                       ;
     39D6 FE28     
12038               
12039 39D8 020D  20        li   ra,>fa*256                 ; LDA #250          ; Call OOPS to damage the ship by 250, which is a pretty
     39DA FA00     
12040 39DC 0460  28        b    @OOPS                      ; JMP OOPS          ; big hit, and return from the subroutine using a tail
     39DE B4B6     
12041                                                                          ; call
12042               
12043               TA18:
12044                                                                          ; This is the entry point for missile tactics and is
12045                                                                          ; called from the main TACTICS routine below
12046 39E0 D360  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     39E2 0030     
12047 39E4 1656  14        jne  TA35                       ; BNE TA35          ; opponent's), jump to TA35 to destroy this missile
12048               
12049 39E6 D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if bit 6 is set
     39E8 0073     
12050                      .asla                           ; ASL A             ; (i.e. missile is hostile), jump up to TA34 to check
     **** ****     > ASLA
0001 39EA 024D  22        andi ra,>ff00
     39EC FF00     
0002 39EE 0A1D  18        sla  ra,1
                   < elite.a99
12051 39F0 11E2  14        jlt  TA34                       ; BMI TA34          ; whether the missile has hit us
12052               
12053 39F2 091D  18        srl  ra,1                       ; LSR A             ; Otherwise shift A right again. We know bits 6 and 7
12054                                                                          ; are now clear, so this leaves bits 0-5. Bits 1-5
12055                                                                          ; contain the target's slot number, and bit 0 is cleared
12056                                                                          ; in FRMIS when a missile is launched, so A contains
12057                                                                          ; the slot number shifted left by 1 (i.e. doubled) so we
12058                                                                          ; can use it as an index for the two-byte address table
12059                                                                          ; at UNIV
12060               
12061 39F4 D38D  18        movb ra,rx                      ; TAX               ; Copy the address of the target ship's data block from
12062 39F6 06CE  14        swpb rx                         ;
12063 39F8 D36E  34        movb @UNIV(rx),ra               ; LDA UNIV,X        ; UNIV(X+1 X) to V(1 0)
     39FA 238F     
12064 39FC 06CE  14        swpb rx                         ;
12065 39FE D80D  30        movb ra,@V                      ; STA V
     3A00 0022     
12066 3A02 06CE  14        swpb rx                         ;
12067 3A04 D36E  34        movb @UNIV+1(rx),ra             ; LDA UNIV+1,X
     3A06 2390     
12068 3A08 06CE  14        swpb rx                         ;
12069 3A0A D80D  30        movb ra,@V+1                    ; STA V+1
     3A0C 0023     
12070               
12071 3A0E 020F  20        li   ry,>02*256                 ; LDY #2            ; K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of
     3A10 0200     
12072 3A12 0200  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3A14 3DE6     
12073 3A16 06A0  32        bl   @jsr                       ;
     3A18 FE28     
12074               
12075 3A1A 020F  20        li   ry,>05*256                 ; LDY #5            ; K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of
     3A1C 0500     
12076 3A1E 0200  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3A20 3DE6     
12077 3A22 06A0  32        bl   @jsr                       ;
     3A24 FE28     
12078               
12079 3A26 020F  20        li   ry,>08*256                 ; LDY #8            ; K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of
     3A28 0800     
12080 3A2A 0200  20        li   rtmp,TAS1                  ; JSR TAS1          ; target ship
     3A2C 3DE6     
12081 3A2E 06A0  32        bl   @jsr                       ;
     3A30 FE28     
12082               
12083                                                                          ; So K3 now contains the vector from the target ship to
12084                                                                          ; the missile
12085               
12086 3A32 D360  30        movb @K3+2,ra                   ; LDA K3+2          ; Set A = OR of all the sign and high bytes of the
     3A34 00D4     
12087 3A36 F360  30        socb @K3+5,ra                   ; ORA K3+5          ; above, clearing bit 7 (i.e. ignore the signs)
     3A38 00D7     
12088 3A3A F360  30        socb @K3+8,ra                   ; ORA K3+8
     3A3C 00DA     
12089 3A3E 024D  22        andi ra,>7f*256                 ; AND #%01111111
     3A40 7F00     
12090 3A42 F360  30        socb @K3+1,ra                   ; ORA K3+1
     3A44 00D3     
12091 3A46 F360  30        socb @K3+4,ra                   ; ORA K3+4
     3A48 00D6     
12092 3A4A F360  30        socb @K3+7,ra                   ; ORA K3+7
     3A4C 00D9     
12093               
12094 3A4E 1640  14        jne  TA64                       ; BNE TA64          ; If the result is non-zero, then the missile is some
12095                                                                          ; distance from the target, so jump down to TA64 see if
12096                                                                          ; the target activates its E.C.M.
12097               
12098 3A50 D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if only bits 7 and
     3A52 0073     
12099 3A54 028D  22        ci   ra,>82*256                 ; CMP #%10000010    ; 1 are set (AI is enabled and the target is slot 1, the
     3A56 8200     
12100 3A58 131C  14        jeq  TA35                       ; BEQ TA35          ; space station), jump to TA35 to destroy this missile,
12101                                                                          ; as the space station ain't kidding around
12102               
12103 3A5A 020F  20        li   ry,>1f*256                 ; LDY #31           ; Fetch byte #31 (the exploding flag) of the target ship
     3A5C 1F00     
12104                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into A
     **** ****     > LD_IND_Y_IDX
0001 3A5E D820  42        movb @V,@rtmplb
     3A60 0022     
     3A62 8301     
0002 3A64 D020  30        movb @V+1,rtmp
     3A66 0023     
0003 3A68 06CF  14        swpb ry
0004 3A6A A00F  18        a    ry,rtmp
0005 3A6C 06CF  14        swpb ry
0006 3A6E D350  26        movb *rtmp,RA
                   < elite.a99
12105               
12106                      .bit @M32+1                     ; BIT M32+1         ; M32 contains an LDY #32 instruction, so M32+1 contains
     **** ****     > BIT
0001 3A70 D020  34        movb @M32+1,rtmp
     3A72 3ADF     
0002 3A74 0540  14        inv  rtmp
0003 3A76 D047  18        movb rone,rtmp2
0004 3A78 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
12107                                                                          ; 32, so this instruction tests A with %00100000, which
12108                                                                          ; checks bit 5 of A (the "already exploding?" bit)
12109               
12110 3A7A 160B  14        jne  TA35                       ; BNE TA35          ; If the target ship is already exploding, jump to TA35
12111                                                                          ; to destroy this missile
12112               
12113 3A7C 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 of the target's byte #31 to mark
     3A7E 8000     
12114                      .st_ind_y_idx @V,ra             ; STA (V),Y         ; the ship as having been killed, so it explodes
     **** ****     > ST_IND_Y_IDX
0001 3A80 D820  42        movb @V,@rtmplb
     3A82 0022     
     3A84 8301     
0002 3A86 D020  30        movb @V+1,rtmp
     3A88 0023     
0003 3A8A 06CF  14        swpb ry
0004 3A8C A00F  18        a    ry,rtmp
0005 3A8E 06CF  14        swpb ry
0006 3A90 D40D  30        movb RA,*rtmp
                   < elite.a99
12115               
12116               TA35:
12117 3A92 D360  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo OR y_lo OR z_lo of the missile
     3A94 0053     
12118 3A96 F360  30        socb @INWK+3,ra                 ; ORA INWK+3
     3A98 0056     
12119 3A9A F360  30        socb @INWK+6,ra                 ; ORA INWK+6
     3A9C 0059     
12120               
12121 3A9E 1606  14        jne  TA87                       ; BNE TA87          ; If A is non-zero then the missile is not near our
12122                                                                          ; ship, so jump to TA87 to skip damaging our ship
12123               
12124 3AA0 020D  20        li   ra,>50*256                 ; LDA #80           ; Otherwise the missile just got destroyed near us, so
     3AA2 5000     
12125 3AA4 0200  20        li   rtmp,OOPS                  ; JSR OOPS          ; call OOPS to damage the ship by 80, which is nowhere
     3AA6 B4B6     
12126 3AA8 06A0  32        bl   @jsr                       ;
     3AAA FE28     
12127                                                                          ; near as bad as the 250 damage from a missile slamming
12128                                                                          ; straight into us, but it's still pretty nasty
12129               
12130               TA87:
12131 3AAC 0200  20        li   rtmp,EXNO2                 ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
     3AAE D2F0     
12132 3AB0 06A0  32        bl   @jsr                       ;
     3AB2 FE28     
12133                                                                          ; missile (so increase the kill tally, make an explosion
12134                                                                          ; sound and so on)
12135               
12136                      .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the missile's byte #31 flag to mark it as
     **** ****     > ASL
0001 3AB4 D020  30        movb @INWK+31,rtmp
     3AB6 0072     
0002 3AB8 0240  22        andi rtmp,>ff00
     3ABA FF00     
0003 3ABC 0A10  18        sla  rtmp,1
0004 3ABE D800  30        movb rtmp,@INWK+31
     3AC0 0072     
                   < elite.a99
12137                      .sec                            ; SEC               ; having been killed, so it explodes
     **** ****     > SEC
0001 3AC2 0A18  18        sla  rmone,1
                   < elite.a99
12138 3AC4 0204  20        li   rarg1,INWK+31              ; ROR INWK+31
     3AC6 0072     
12139 3AC8 06A0  32        bl   @ror                       ;
     3ACA FE7A     
12140               
12141               TA1:
12142 3ACC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3ACE FE34     
12143               
12144               TA64:
12145                                                                          ; If we get here then the missile has not reached the
12146                                                                          ; target
12147 3AD0 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3AD2 C7D0     
12148 3AD4 06A0  32        bl   @jsr                       ;
     3AD6 FE28     
12149               
12150 3AD8 028D  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 (94% chance), jump down to TA19 with the
     3ADA 1000     
12151 3ADC 1876  14        joc  TA19                       ; BCS TA19          ; vector from the target to the missile in K3
12152               
12153               M32:
12154 3ADE 020F  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 for the target and shift bit 0 (E.C.M.)
     3AE0 2000     
12155                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into the C flag
     **** ****     > LD_IND_Y_IDX
0001 3AE2 D820  42        movb @V,@rtmplb
     3AE4 0022     
     3AE6 8301     
0002 3AE8 D020  30        movb @V+1,rtmp
     3AEA 0023     
0003 3AEC 06CF  14        swpb ry
0004 3AEE A00F  18        a    ry,rtmp
0005 3AF0 06CF  14        swpb ry
0006 3AF2 D350  26        movb *rtmp,RA
                   < elite.a99
12156 3AF4 091D  18        srl  ra,1                       ; LSR A
12157               
12158 3AF6 1769  14        jnc  TA19                       ; BCC TA19          ; If the C flag is clear then the target does not have
12159                                                                          ; E.C.M. fitted, so jump down to TA19 with the vector
12160                                                                          ; from the target to the missile in K3
12161               
12162 3AF8 0460  28        b    @ECBLB2                    ; JMP ECBLB2        ; The target has E.C.M., so jump to ECBLB2 to set it
     3AFA B74A     
12163                                                                          ; off, returning from the subroutine using a tail call
12164               
12165               * ******************************************************************************
12166               *
12167               * Name: TACTICS (Part 2 of 7)
12168               * Type: Subroutine
12169               * Category: Tactics
12170               * Summary: Apply tactics: Escape pod, station, lone Thargon, safe-zone pirate
12171               * Deep dive: Program flow of the tactics routine
12172               *
12173               * ------------------------------------------------------------------------------
12174               *
12175               * This section contains the main entry point at TACTICS, which is called from
12176               * part 2 of MVEIT for ships that have the AI flag set (i.e. bit 7 of byte #32).
12177               * This part does the following:
12178               *
12179               * * If this is a missile, jump up to the missile code in part 1
12180               *
12181               * * If this is an escape pod, point it at the planet and jump to the
12182               * manoeuvring code in part 7
12183               *
12184               * * If this is the space station and it is hostile, consider spawning a cop
12185               * (45% chance, up to a maximum of four) and we're done
12186               *
12187               * * If this is a lone Thargon without a mothership, set it adrift aimlessly
12188               * and we're done
12189               *
12190               * * If this is a pirate and we are within the space station safe zone, stop
12191               * the pirate from attacking by removing all its aggression
12192               *
12193               * * Recharge the ship's energy banks by 1
12194               *
12195               * ------------------------------------------------------------------------------
12196               *
12197               * Arguments:
12198               *
12199               * X                   The ship type
12200               *
12201               * ******************************************************************************
12202               
12203               TACTICS:
12204 3AFC 028E  22        ci   rx,(MSL)*256               ; CPX #MSL          ; If this is a missile, jump up to TA18 to implement
     3AFE 0900     
12205 3B00 1602  14        jne  FIX001                     ; BNE FIX001        ; missile tactics
12206 3B02 0460  28        b    @TA18                      ; JMP TA18
     3B04 39E0     
12207               FIX001:
12208 3B06 028E  22        ci   rx,(ESC)*256               ; CPX #ESC          ; If this is not an escape pod, skip the following two
     3B08 0D00     
12209 3B0A 1606  14        jne  B34                        ; BNE B34           ; instructions
12210               
12211 3B0C 0200  20        li   rtmp,SPS1                  ; JSR SPS1          ; This is an escape pod, so call SPS1 to calculate the
     3B0E D10A     
12212 3B10 06A0  32        bl   @jsr                       ;
     3B12 FE28     
12213                                                                          ; vector to the planet and store it in XX15
12214               
12215 3B14 0460  28        b    @TA15                      ; JMP TA15          ; Jump down to TA15
     3B16 3D5C     
12216               
12217               B34:
12218 3B18 028E  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is not the space station, jump down to TA13
     3B1A 0800     
12219 3B1C 1612  14        jne  TA13                       ; BNE TA13
12220               
12221                                                                          ; We only call the tactics routine for the space station
12222                                                                          ; when it is hostile, so if we get here then this is the
12223                                                                          ; station, and we already know it's hostile, so we need
12224                                                                          ; to spawn some cops
12225               
12226 3B1E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3B20 C7D0     
12227 3B22 06A0  32        bl   @jsr                       ;
     3B24 FE28     
12228               
12229 3B26 028D  22        ci   ra,>8c*256                 ; CMP #140          ; If A < 140 (55% chance) then return from the
     3B28 8C00     
12230 3B2A 1723  14        jnc  TA14-1                     ; BCC TA14-1        ; subroutine (as TA14-1 contains an RTS)
12231               
12232 3B2C D360  30        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; We only call the tactics routine for the space station
     3B2E 0D4F     
12233 3B30 028D  22        ci   ra,>04*256                 ; CMP #4            ; when it is hostile, so first check the number of cops
     3B32 0400     
12234 3B34 181E  14        joc  TA14-1                     ; BCS TA14-1        ; in the vicinity, and if we already have 4 or more, we
12235                                                                          ; don't need to spawn any more, so return from the
12236                                                                          ; subroutine (as TA14-1 contains an RTS)
12237               
12238 3B36 020E  20        li   rx,(COPS)*256              ; LDX #COPS         ; Set X to the ship type for a cop
     3B38 0200     
12239               
12240 3B3A 020D  20        li   ra,>f1*256                 ; LDA #%11110001    ; Set the AI flag to give the ship E.C.M., enable AI and
     3B3C F100     
12241                                                                          ; make it very aggressive (60 out of 63)
12242               
12243 3B3E 0460  28        b    @SFS1                      ; JMP SFS1          ; Jump to SFS1 to spawn the ship, returning from the
     3B40 404A     
12244                                                                          ; subroutine using a tail call
12245               
12246               TA13:
12247 3B42 028E  22        ci   rx,(TGL)*256               ; CPX #TGL          ; If this is not a Thargon, jump down to TA14
     3B44 0C00     
12248 3B46 1616  14        jne  TA14                       ; BNE TA14
12249               
12250 3B48 D360  30        movb @MANY+THG,ra               ; LDA MANY+THG      ; If there is at least one Thargoid in the vicinity,
     3B4A 0D53     
12251 3B4C 1613  14        jne  TA14                       ; BNE TA14          ; jump down to TA14
12252               
12253                      .lsr @INWK+32                   ; LSR INWK+32       ; This is a Thargon but there is no Thargoid mothership,
     **** ****     > LSR
0001 3B4E D020  30        movb @INWK+32,rtmp
     3B50 0073     
0002 3B52 0910  18        srl  rtmp,1
0003 3B54 D800  30        movb rtmp,@INWK+32
     3B56 0073     
                   < elite.a99
12254                      .asl @INWK+32                   ; ASL INWK+32       ; so clear bit 0 of the AI flag to disable its E.C.M.
     **** ****     > ASL
0001 3B58 D020  30        movb @INWK+32,rtmp
     3B5A 0073     
0002 3B5C 0240  22        andi rtmp,>ff00
     3B5E FF00     
0003 3B60 0A10  18        sla  rtmp,1
0004 3B62 D800  30        movb rtmp,@INWK+32
     3B64 0073     
                   < elite.a99
12255               
12256                      .lsr @INWK+27                   ; LSR INWK+27       ; And halve the Thargon's speed
     **** ****     > LSR
0001 3B66 D020  30        movb @INWK+27,rtmp
     3B68 006E     
0002 3B6A 0910  18        srl  rtmp,1
0003 3B6C D800  30        movb rtmp,@INWK+27
     3B6E 006E     
                   < elite.a99
12257               
12258 3B70 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3B72 FE34     
12259               
12260               TA14:
12261 3B74 028E  22        ci   rx,(CYL)*256               ; CPX #CYL          ; If A >= #CYL, i.e. this is a Cobra Mk III trader (as
     3B76 0700     
12262 3B78 180C  14        joc  TA62                       ; BCS TA62          ; asteroids and cargo canisters never have AI), jump
12263                                                                          ; down to TA62
12264               
12265 3B7A 028E  22        ci   rx,(COPS)*256              ; CPX #COPS         ; If this is a cop, jump down to TA62
     3B7C 0200     
12266 3B7E 1309  14        jeq  TA62                       ; BEQ TA62
12267               
12268 3B80 D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we aren't within range of the space station, jump
     3B82 0D55     
12269 3B84 1306  14        jeq  TA62                       ; BEQ TA62          ; down to TA62
12270               
12271 3B86 D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; This is a pirate or bounty hunter, but we are inside
     3B88 0073     
12272 3B8A 024D  22        andi ra,>81*256                 ; AND #%10000001    ; the space station's safe zone, so clear bits 1-6 of
     3B8C 8100     
12273 3B8E D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; the AI flag to stop it being hostile, because even
     3B90 0073     
12274                                                                          ; pirates aren't crazy enough to breach the station's
12275                                                                          ; no-fire zone
12276               
12277               TA62:
12278 3B92 020F  20        li   ry,>0e*256                 ; LDY #14           ; If the ship's energy is greater or equal to the
     3B94 0E00     
12279 3B96 D360  30        movb @INWK+35,ra                ; LDA INWK+35       ; maximum value from the ship's blueprint pointed to by
     3B98 0076     
12280                      .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; XX0, then skip the next instruction
     **** ****     > CMP_IND_Y_IDX
0001 3B9A D820  42        movb @XX0,@rtmplb
     3B9C 001E     
     3B9E 8301     
0002 3BA0 D020  30        movb @XX0+1,rtmp
     3BA2 001F     
0003 3BA4 06CF  14        swpb ry
0004 3BA6 A00F  18        a    ry,rtmp
0005 3BA8 06CF  14        swpb ry
0006 3BAA D010  26        movb *rtmp,rtmp
0007 3BAC 900D  18        cb   ra,rtmp
                   < elite.a99
12281 3BAE 1801  14        joc  TA21                       ; BCS TA21
12282               
12283 3BB0 B347  18        ab   rone,ra                    ; INC INWK+35       ; The ship's energy is not at maximum, so recharge the
12284                                                                          ; energy banks by 1
12285               
12286               * ******************************************************************************
12287               *
12288               * Name: TACTICS (Part 3 of 7)
12289               * Type: Subroutine
12290               * Category: Tactics
12291               * Summary: Apply tactics: Calculate dot product to determine ship's aim
12292               * Deep dive: Program flow of the tactics routine
12293               *
12294               * ------------------------------------------------------------------------------
12295               *
12296               * This section sets up some vectors and calculates dot products. Specifically:
12297               *
12298               * * Calculate the dot product of the ship's nose vector (i.e. the direction it
12299               * is pointing) with the vector between us and the ship. This value will help
12300               * us work out later on whether the enemy ship is pointing towards us, and
12301               * therefore whether it can hit us with its lasers.
12302               *
12303               * ******************************************************************************
12304               
12305               TA21:
12306 3BB2 020E  20        li   rx,>08*256                 ; LDX #8            ; We now want to copy the ship's x, y and z coordinates
     3BB4 0800     
12307                                                                          ; from INWK to K3, so set up a counter for 9 bytes
12308               
12309               TAL1:
12310 3BB6 06CE  14        swpb rx                         ;
12311 3BB8 D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte from INWK to the X-th byte of K3
     3BBA 0053     
12312 3BBC 06CE  14        swpb rx                         ;
12313 3BBE 06CE  14        swpb rx                         ;
12314 3BC0 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X
     3BC2 00D2     
12315 3BC4 06CE  14        swpb rx                         ;
12316               
12317 3BC6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
12318               
12319 3BC8 15F6  14        jgt  TAL1                       ; BPL TAL1          ; Loop back until we have copied all 9 bytes
12320               
12321               TA19:
12322                                                                          ; If this is a missile that's heading for its target
12323                                                                          ; (not us, one of the other ships), then the missile
12324                                                                          ; routine at TA18 above jumps here after setting K3 to
12325                                                                          ; the vector from the target to the missile
12326 3BCA 0200  20        li   rtmp,TAS2                  ; JSR TAS2          ; Normalise the vector in K3 and store the normalised
     3BCC D12E     
12327 3BCE 06A0  32        bl   @jsr                       ;
     3BD0 FE28     
12328                                                                          ; version in XX15, so XX15 contains the normalised
12329                                                                          ; vector from our ship to the ship we are applying AI
12330                                                                          ; tactics to (or the normalised vector from the target
12331                                                                          ; to the missile - in both cases it's the vector from
12332                                                                          ; the potential victim to the attacker)
12333               
12334 3BD2 020F  20        li   ry,>0a*256                 ; LDY #10           ; Set (A X) = nosev . XX15
     3BD4 0A00     
12335 3BD6 0200  20        li   rtmp,TAS3                  ; JSR TAS3
     3BD8 4812     
12336 3BDA 06A0  32        bl   @jsr                       ;
     3BDC FE28     
12337               
12338 3BDE D80D  30        movb ra,@CNT                    ; STA CNT           ; Store the high byte of the dot product in CNT. The
     3BE0 00A4     
12339                                                                          ; bigger the value, the more aligned the two ships are,
12340                                                                          ; with a maximum magnitude of 36 (96 * 96 >> 8). If CNT
12341                                                                          ; is positive, the ships are facing in a similar
12342                                                                          ; direction, if it's negative they are facing in
12343                                                                          ; opposite directions
12344               
12345               * ******************************************************************************
12346               *
12347               * Name: TACTICS (Part 4 of 7)
12348               * Type: Subroutine
12349               * Category: Tactics
12350               * Summary: Apply tactics: Check energy levels, maybe launch escape pod if low
12351               * Deep dive: Program flow of the tactics routine
12352               *
12353               * ------------------------------------------------------------------------------
12354               *
12355               * This section works out what kind of condition the ship is in. Specifically:
12356               *
12357               * * Rarely (2.5% chance) roll the ship by a noticeable amount
12358               *
12359               * * If the ship has at least half its energy banks full, jump to part 6 to
12360               * consider firing the lasers
12361               *
12362               * * If the ship is not into the last 1/8th of its energy, jump to part 5 to
12363               * consider firing a missile
12364               *
12365               * * If the ship is into the last 1/8th of its energy, then rarely (10% chance)
12366               * the ship launches an escape pod and is left drifting in space
12367               *
12368               * ******************************************************************************
12369               
12370 3BE2 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is not a missile, skip the following
     3BE4 009B     
12371 3BE6 028D  22        ci   ra,(MSL)*256               ; CMP #MSL          ; instruction
     3BE8 0900     
12372 3BEA 1602  14        jne  B35                        ; BNE B35
12373               
12374 3BEC 0460  28        b    @TA20                      ; JMP TA20          ; This is a missile, so jump down to TA20 to get
     3BEE 3D24     
12375                                                                          ; straight into some aggressive manoeuvring
12376               
12377               B35:
12378 3BF0 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3BF2 C7D0     
12379 3BF4 06A0  32        bl   @jsr                       ;
     3BF6 FE28     
12380               
12381 3BF8 028D  22        ci   ra,>fa*256                 ; CMP #250          ; If A < 250 (97.5% chance), jump down to TA7 to skip
     3BFA FA00     
12382 3BFC 1708  14        jnc  TA7                        ; BCC TA7           ; the following
12383               
12384 3BFE 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3C00 C7D0     
12385 3C02 06A0  32        bl   @jsr                       ;
     3C04 FE28     
12386               
12387 3C06 026D  22        ori  ra,>68*256                 ; ORA #104          ; Bump A up to at least 104 and store in the roll
     3C08 6800     
12388 3C0A D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; counter, to gives the ship a noticeable roll
     3C0C 0070     
12389               
12390               TA7:
12391 3C0E 020F  20        li   ry,>0e*256                 ; LDY #14           ; Set A = the ship's maximum energy / 2
     3C10 0E00     
12392                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 3C12 D820  42        movb @XX0,@rtmplb
     3C14 001E     
     3C16 8301     
0002 3C18 D020  30        movb @XX0+1,rtmp
     3C1A 001F     
0003 3C1C 06CF  14        swpb ry
0004 3C1E A00F  18        a    ry,rtmp
0005 3C20 06CF  14        swpb ry
0006 3C22 D350  26        movb *rtmp,RA
                   < elite.a99
12393 3C24 091D  18        srl  ra,1                       ; LSR A
12394               
12395 3C26 9360  30        cb   @INWK+35,ra                ; CMP INWK+35       ; If the ship's current energy in byte #35 > A, i.e. the
     3C28 0076     
12396 3C2A 1738  14        jnc  TA3                        ; BCC TA3           ; ship has at least half of its energy banks charged,
12397                                                                          ; jump down to TA3
12398               
12399 3C2C 091D  18        srl  ra,1                       ; LSR A             ; If the ship's current energy in byte #35 > A / 4, i.e.
12400 3C2E 091D  18        srl  ra,1                       ; LSR A             ; the ship is not into the last 1/8th of its energy,
12401 3C30 9360  30        cb   @INWK+35,ra                ; CMP INWK+35       ; jump down to ta3 to consider firing a missile
     3C32 0076     
12402 3C34 1712  14        jnc  ta3_                       ; BCC ta3
12403               
12404 3C36 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3C38 C7D0     
12405 3C3A 06A0  32        bl   @jsr                       ;
     3C3C FE28     
12406               
12407 3C3E 028D  22        ci   ra,>e6*256                 ; CMP #230          ; If A < 230 (90% chance), jump down to ta3 to consider
     3C40 E600     
12408 3C42 170B  14        jnc  ta3_                       ; BCC ta3           ; firing a missile
12409               
12410 3C44 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If this is a Thargoid, jump down to ta3 to consider
     3C46 009B     
12411 3C48 028D  22        ci   ra,(THG)*256               ; CMP #THG          ; launching a Thargon
     3C4A 0600     
12412 3C4C 1306  14        jeq  ta3_                       ; BEQ ta3
12413               
12414                                                                          ; By this point, the ship has run out of both energy and
12415                                                                          ; luck, so it's time to bail
12416               
12417 3C4E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the AI flag to 0 to disable AI, hostility and
     3C50 0000     
12418 3C52 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; E.C.M., so the ship's a sitting duck
     3C54 0073     
12419               
12420 3C56 0460  28        b    @SESCP                     ; JMP SESCP         ; Jump to SESCP to spawn an escape pod from the ship,
     3C58 4042     
12421                                                                          ; returning from the subroutine using a tail call
12422               
12423               * ******************************************************************************
12424               *
12425               * Name: TACTICS (Part 5 of 7)
12426               * Type: Subroutine
12427               * Category: Tactics
12428               * Summary: Apply tactics: Consider whether to launch a missile at us
12429               * Deep dive: Program flow of the tactics routine
12430               *
12431               * ------------------------------------------------------------------------------
12432               *
12433               * This section considers whether to launch a missile. Specifically:
12434               *
12435               * * If the ship doesn't have any missiles, skip to the next part
12436               *
12437               * * If an E.C.M. is firing, skip to the next part
12438               *
12439               * * Randomly decide whether to fire a missile (or, in the case of Thargoids,
12440               * release a Thargon), and if we do, we're done
12441               *
12442               * ******************************************************************************
12443               
12444               ta3_:
12445                                                                          ; If we get here then the ship has less than half energy
12446                                                                          ; so there may not be enough juice for lasers, but let's
12447                                                                          ; see if we can fire a missile
12448 3C5A D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set A = bits 0-2 of byte #31, the number of missiles
     3C5C 0072     
12449 3C5E 024D  22        andi ra,>07*256                 ; AND #%00000111    ; the ship has left
     3C60 0700     
12450               
12451 3C62 131C  14        jeq  TA3                        ; BEQ TA3           ; If it doesn't have any missiles, jump to TA3
12452               
12453 3C64 D80D  30        movb ra,@T                      ; STA T             ; Store the number of missiles in T
     3C66 00D1     
12454               
12455 3C68 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3C6A C7D0     
12456 3C6C 06A0  32        bl   @jsr                       ;
     3C6E FE28     
12457               
12458 3C70 024D  22        andi ra,>1f*256                 ; AND #31           ; Restrict A to a random number in the range 0-31
     3C72 1F00     
12459               
12460 3C74 9360  30        cb   @T,ra                      ; CMP T             ; If A >= T, which is quite likely, though less likely
     3C76 00D1     
12461 3C78 1811  14        joc  TA3                        ; BCS TA3           ; with higher numbers of missiles, jump to TA3 to skip
12462                                                                          ; firing a missile
12463               
12464 3C7A D360  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     3C7C 0030     
12465 3C7E 160E  14        jne  TA3                        ; BNE TA3           ; opponent's), jump to TA3 to skip firing a missile
12466               
12467 3C80 7347  18        sb   rone,ra                    ; DEC INWK+31       ; We're done with the checks, so it's time to fire off a
12468                                                                          ; missile, so reduce the missile count in byte #31 by 1
12469               
12470 3C82 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type into A
     3C84 009B     
12471               
12472 3C86 028D  22        ci   ra,(THG)*256               ; CMP #THG          ; If this is not a Thargoid, jump down to TA16 to launch
     3C88 0600     
12473 3C8A 1606  14        jne  TA16                       ; BNE TA16          ; a missile
12474               
12475 3C8C 020E  20        li   rx,(TGL)*256               ; LDX #TGL          ; This is a Thargoid, so instead of launching a missile,
     3C8E 0C00     
12476 3C90 D360  30        movb @INWK+32,ra                ; LDA INWK+32       ; the mothership launches a Thargon, so call SFS1 to
     3C92 0073     
12477 3C94 0460  28        b    @SFS1                      ; JMP SFS1          ; spawn a Thargon from the parent ship, and return from
     3C96 404A     
12478                                                                          ; the subroutine using a tail call
12479               
12480               TA16:
12481 3C98 0460  28        b    @SFRMIS                    ; JMP SFRMIS        ; Jump to SFRMIS to spawn a missile as a child of the
     3C9A D2D0     
12482                                                                          ; current ship, make a noise and print a message warning
12483                                                                          ; of incoming missiles, and return from the subroutine
12484                                                                          ; using a tail call
12485               
12486               * ******************************************************************************
12487               *
12488               * Name: TACTICS (Part 6 of 7)
12489               * Type: Subroutine
12490               * Category: Tactics
12491               * Summary: Apply tactics: Consider firing a laser at us, if aim is true
12492               * Deep dive: Program flow of the tactics routine
12493               *
12494               * ------------------------------------------------------------------------------
12495               *
12496               * This section looks at potentially firing the ship's laser at us. Specifically:
12497               *
12498               * * If the ship is not pointing at us, skip to the next part
12499               *
12500               * * If the ship is pointing at us but not accurately, fire its laser at us and
12501               * skip to the next part
12502               *
12503               * * If we are in the ship's crosshairs, register some damage to our ship, slow
12504               * down the attacking ship, make the noise of us being hit by laser fire, and
12505               * we're done
12506               *
12507               * ******************************************************************************
12508               
12509               TA3:
12510                                                                          ; If we get here then the ship either has plenty of
12511                                                                          ; energy, or levels are low but it couldn't manage to
12512                                                                          ; launch a missile, so maybe we can fire the laser?
12513 3C9C 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
     3C9E 0000     
12514 3CA0 0200  20        li   rtmp,MAS4                  ; JSR MAS4
     3CA2 CBC2     
12515 3CA4 06A0  32        bl   @jsr                       ;
     3CA6 FE28     
12516               
12517 3CA8 024D  22        andi ra,>e0*256                 ; AND #%11100000    ; If any of the hi bytes have any of bits 5-7 set, then
     3CAA E000     
12518 3CAC 1626  14        jne  TA4                        ; BNE TA4           ; jump to TA4 to skip the laser checks, as the ship is
12519                                                                          ; too far away from us to hit us with a laser
12520               
12521 3CAE D3A0  30        movb @CNT,rx                    ; LDX CNT           ; Set X = the dot product set above in CNT. If this is
     3CB0 00A4     
12522                                                                          ; positive, this ship and our ship are facing in similar
12523                                                                          ; directions, but if it's negative then we are facing
12524                                                                          ; each other, so for us to be in the enemy ship's line
12525                                                                          ; of fire, X needs to be negative. The value in X can
12526                                                                          ; have a maximum magnitude of 36, which would mean we
12527                                                                          ; were facing each other square on, so in the following
12528                                                                          ; code we check X like this:
12529                                                                          ;
12530                                                                          ; X = 0 to -31, we are not in the enemy ship's line
12531                                                                          ; of fire, so they can't shoot at us
12532                                                                          ;
12533                                                                          ; X = -32 to -34, we are in the enemy ship's line
12534                                                                          ; of fire, so they can shoot at us, but they can't
12535                                                                          ; hit us as we're not dead in their crosshairs
12536                                                                          ;
12537                                                                          ; X = -35 to -36, we are bang in the middle of the
12538                                                                          ; enemy ship's crosshairs, so they can not only
12539                                                                          ; shoot us, they can hit us
12540               
12541 3CB2 028E  22        ci   rx,>a0*256                 ; CPX #160          ; If X < 160, i.e. X > -32, then we are not in the enemy
     3CB4 A000     
12542 3CB6 1721  14        jnc  TA4                        ; BCC TA4           ; ship's line of fire, so jump to TA4 to skip the laser
12543                                                                          ; checks
12544               
12545 3CB8 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 in byte #31 to denote that the ship is
     3CBA 0072     
12546 3CBC 026D  22        ori  ra,>40*256                 ; ORA #%01000000    ; firing its laser at us
     3CBE 4000     
12547 3CC0 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     3CC2 0072     
12548               
12549 3CC4 028E  22        ci   rx,>a3*256                 ; CPX #163          ; If X < 163, i.e. X > -35, then we are not in the enemy
     3CC6 A300     
12550 3CC8 1718  14        jnc  TA4                        ; BCC TA4           ; ship's crosshairs, so jump to TA4 to skip the laser
12551                                                                          ; checks
12552               
12553               HIT:
12554 3CCA 020F  20        li   ry,>13*256                 ; LDY #19           ; We are being hit by enemy laser fire, so fetch the
     3CCC 1300     
12555                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; enemy ship's byte #19 from their ship's blueprint
     **** ****     > LD_IND_Y_IDX
0001 3CCE D820  42        movb @XX0,@rtmplb
     3CD0 001E     
     3CD2 8301     
0002 3CD4 D020  30        movb @XX0+1,rtmp
     3CD6 001F     
0003 3CD8 06CF  14        swpb ry
0004 3CDA A00F  18        a    ry,rtmp
0005 3CDC 06CF  14        swpb ry
0006 3CDE D350  26        movb *rtmp,RA
                   < elite.a99
12556                                                                          ; into A
12557               
12558 3CE0 091D  18        srl  ra,1                       ; LSR A             ; Halve the enemy ship's byte #19 (which contains both
12559                                                                          ; the laser power and number of missiles) to get the
12560                                                                          ; amount of damage we should take
12561               
12562 3CE2 0200  20        li   rtmp,OOPS                  ; JSR OOPS          ; Call OOPS to take some damage, which could do anything
     3CE4 B4B6     
12563 3CE6 06A0  32        bl   @jsr                       ;
     3CE8 FE28     
12564                                                                          ; from reducing the shields and energy, all the way to
12565                                                                          ; losing cargo or dying (if the latter, we don't come
12566                                                                          ; back from this subroutine)
12567               
12568 3CEA 7347  18        sb   rone,ra                    ; DEC INWK+28       ; Halve the attacking ship's acceleration in byte #28
12569               
12570 3CEC D360  30        movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
     3CEE 0030     
12571 3CF0 1678  14        jne  TA10                       ; BNE TA10          ; opponent's), return from the subroutine without making
12572                                                                          ; the laser-strike sound (as TA10 contains an RTS)
12573               
12574 3CF2 020D  20        li   ra,>08*256                 ; LDA #8            ; Call the NOISE routine with A = 8 to make the sound
     3CF4 0800     
12575 3CF6 0460  28        b    @NOISE                     ; JMP NOISE         ; of us being hit by lasers, returning from the
     3CF8 D340     
12576                                                                          ; subroutine using a tail call
12577               
12578               * ******************************************************************************
12579               *
12580               * Name: TACTICS (Part 7 of 7)
12581               * Type: Subroutine
12582               * Category: Tactics
12583               * Summary: Apply tactics: Set pitch, roll, and acceleration
12584               * Deep dive: Program flow of the tactics routine
12585               *
12586               * ------------------------------------------------------------------------------
12587               *
12588               * This section looks at manoeuvring the ship. Specifically:
12589               *
12590               * * Work out which direction the ship should be moving, depending on whether
12591               * it's an escape pod, where it is, which direction it is pointing, and how
12592               * aggressive it is
12593               *
12594               * * Set the pitch and roll counters to head in that direction
12595               *
12596               * * Speed up or slow down, depending on where the ship is in relation to us
12597               *
12598               * ******************************************************************************
12599               
12600               TA4:
12601 3CFA D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi >= 3 then the ship is quite far away, so jump
     3CFC 005A     
12602 3CFE 028D  22        ci   ra,>03*256                 ; CMP #3            ; down to TA5
     3D00 0300     
12603 3D02 1807  14        joc  TA5                        ; BCS TA5
12604               
12605 3D04 D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Otherwise set A = x_hi OR y_hi and extract bits 1-7
     3D06 0054     
12606 3D08 F360  30        socb @INWK+4,ra                 ; ORA INWK+4
     3D0A 0057     
12607 3D0C 024D  22        andi ra,>fe*256                 ; AND #%11111110
     3D0E FE00     
12608               
12609 3D10 1325  14        jeq  TA15                       ; BEQ TA15          ; If A = 0 then the ship is pretty close to us, so jump
12610                                                                          ; to TA15 so it heads away from us
12611               
12612               TA5:
12613                                                                          ; If we get here then the ship is quite far away
12614 3D12 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     3D14 C7D0     
12615 3D16 06A0  32        bl   @jsr                       ;
     3D18 FE28     
12616               
12617 3D1A 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A, so A is at least 128
     3D1C 8000     
12618               
12619 3D1E 9360  30        cb   @INWK+32,ra                ; CMP INWK+32       ; If A >= byte #32 (the ship's AI flag) then jump down
     3D20 0073     
12620 3D22 181C  14        joc  TA15                       ; BCS TA15          ; to TA15 so it heads away from us
12621               
12622                                                                          ; We get here if A < byte #32, and the chances of this
12623                                                                          ; being true are greater with high values of byte #32,
12624                                                                          ; as long as they are at least 128
12625                                                                          ;
12626                                                                          ; In other words, higher byte #32 values increase the
12627                                                                          ; chances of a ship changing direction to head towards
12628                                                                          ; us - or, to put it another way, ships with higher
12629                                                                          ; byte #32 values of 128 or more are spoiling for a
12630                                                                          ; fight
12631                                                                          ;
12632                                                                          ; Thargoids have byte #32 set to 255, which explains
12633                                                                          ; an awful lot
12634               
12635               TA20:
12636                                                                          ; If this is a missile we will have jumped straight
12637                                                                          ; here, but we also get here if the ship is either far
12638                                                                          ; away and aggressive, or not too close
12639 3D24 D360  30        movb @XX15,ra                   ; LDA XX15          ; Reverse the signs of XX15 and the dot product in CNT,
     3D26 0031     
12640                      .eoi (>80*256)                  ; EOR #%10000000    ; starting with the x-coordinate
     **** ****     > EOI
0001 3D28 0200  20        li   rtmp,(>80*256)
     3D2A 8000     
0002 3D2C 2B40  18        xor  rtmp,ra
                   < elite.a99
12641 3D2E D80D  30        movb ra,@XX15                   ; STA XX15
     3D30 0031     
12642               
12643 3D32 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Then reverse the sign of the y-coordinate
     3D34 0032     
12644                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 3D36 0200  20        li   rtmp,(>80*256)
     3D38 8000     
0002 3D3A 2B40  18        xor  rtmp,ra
                   < elite.a99
12645 3D3C D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     3D3E 0032     
12646               
12647 3D40 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And then the z-coordinate, so now the XX15 vector goes
     3D42 0033     
12648                      .eoi (>80*256)                  ; EOR #%10000000    ; from the enemy ship to our ship (it was previously the
     **** ****     > EOI
0001 3D44 0200  20        li   rtmp,(>80*256)
     3D46 8000     
0002 3D48 2B40  18        xor  rtmp,ra
                   < elite.a99
12649 3D4A D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; other way round)
     3D4C 0033     
12650               
12651 3D4E D360  30        movb @CNT,ra                    ; LDA CNT           ; And finally change the sign of the dot product in CNT,
     3D50 00A4     
12652                      .eoi (>80*256)                  ; EOR #%10000000    ; so now it's positive if the ships are facing each
     **** ****     > EOI
0001 3D52 0200  20        li   rtmp,(>80*256)
     3D54 8000     
0002 3D56 2B40  18        xor  rtmp,ra
                   < elite.a99
12653 3D58 D80D  30        movb ra,@CNT                    ; STA CNT           ; other, and negative if they are facing the same way
     3D5A 00A4     
12654               
12655               TA15:
12656                                                                          ; If we get here, then one of the following is true:
12657                                                                          ;
12658                                                                          ; * This is an escape pod and XX15 is pointing towards
12659                                                                          ; the planet
12660                                                                          ;
12661                                                                          ; * The ship is pretty close to us, or it's just not
12662                                                                          ; very aggressive (though there is a random factor
12663                                                                          ; at play here too). XX15 is still pointing from our
12664                                                                          ; ship towards the enemy ship
12665                                                                          ;
12666                                                                          ; * The ship is aggressive (though again, there's an
12667                                                                          ; element of randomness here). XX15 is pointing from
12668                                                                          ; the enemy ship towards our ship
12669                                                                          ;
12670                                                                          ; * This is a missile heading for a target. XX15 is
12671                                                                          ; pointing from the missile towards the target
12672                                                                          ;
12673                                                                          ; We now want to move the ship in the direction of XX15,
12674                                                                          ; which will make aggressive ships head towards us, and
12675                                                                          ; ships that are too close turn away. Escape pods,
12676                                                                          ; meanwhile, head off towards the planet in search of a
12677                                                                          ; space station, and missiles home in on their targets
12678 3D5C 020F  20        li   ry,>10*256                 ; LDY #16           ; Set (A X) = roofv . XX15
     3D5E 1000     
12679 3D60 0200  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3D62 4812     
12680 3D64 06A0  32        bl   @jsr                       ;
     3D66 FE28     
12681                                                                          ; This will be positive if XX15 is pointing in the same
12682                                                                          ; direction as an arrow out of the top of the ship, in
12683                                                                          ; other words if the ship should pull up to head in the
12684                                                                          ; direction of XX15
12685               
12686                      .eoi (>80*256)                  ; EOR #%10000000    ; Set the ship's pitch counter to 3, with the opposite
     **** ****     > EOI
0001 3D68 0200  20        li   rtmp,(>80*256)
     3D6A 8000     
0002 3D6C 2B40  18        xor  rtmp,ra
                   < elite.a99
12687 3D6E 024D  22        andi ra,>80*256                 ; AND #%10000000    ; sign to the dot product result, which gently pitches
     3D70 8000     
12688 3D72 026D  22        ori  ra,>03*256                 ; ORA #%00000011    ; the ship towards the direction of the XX15 vector
     3D74 0300     
12689 3D76 D80D  30        movb ra,@INWK+30                ; STA INWK+30
     3D78 0071     
12690               
12691 3D7A D360  30        movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the roll counter from byte #29 into A and clear
     3D7C 0070     
12692 3D7E 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; the sign bit (to give an endless clockwise roll)
     3D80 7F00     
12693               
12694 3D82 028D  22        ci   ra,>10*256                 ; CMP #16           ; If A >= 16 then jump to TA6, as the ship is already
     3D84 1000     
12695 3D86 1810  14        joc  TA6                        ; BCS TA6           ; in the process of rolling
12696               
12697 3D88 020F  20        li   ry,>16*256                 ; LDY #22           ; Set (A X) = sidev . XX15
     3D8A 1600     
12698 3D8C 0200  20        li   rtmp,TAS3                  ; JSR TAS3          ;
     3D8E 4812     
12699 3D90 06A0  32        bl   @jsr                       ;
     3D92 FE28     
12700                                                                          ; This will be positive if XX15 is pointing in the same
12701                                                                          ; direction as an arrow out of the right side of the
12702                                                                          ; ship, in other words if the ship should roll right to
12703                                                                          ; head in the direction of XX15
12704               
12705                      .eor @INWK+30                   ; EOR INWK+30       ; Set the ship's roll counter to 5, with the sign set to
     **** ****     > EOR
0001 3D94 D020  30        movb @INWK+30,rtmp
     3D96 0071     
0002 3D98 2B40  18        xor  rtmp,ra
                   < elite.a99
12706 3D9A 024D  22        andi ra,>80*256                 ; AND #%10000000    ; positive (clockwise roll) if the pitch counter and dot
     3D9C 8000     
12707                      .eoi (>85*256)                  ; EOR #%10000101    ; product have different signs, negative (anti-clockwise
     **** ****     > EOI
0001 3D9E 0200  20        li   rtmp,(>85*256)
     3DA0 8500     
0002 3DA2 2B40  18        xor  rtmp,ra
                   < elite.a99
12708 3DA4 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; roll) if they have the same sign
     3DA6 0070     
12709               
12710               TA6:
12711 3DA8 D360  30        movb @CNT,ra                    ; LDA CNT           ; Fetch the dot product, and if it's negative jump to
     3DAA 00A4     
12712 3DAC 1109  14        jlt  TA9                        ; BMI TA9           ; TA9, as the ships are facing away from each other and
12713                                                                          ; the ship might want to slow down to take another shot
12714               
12715 3DAE 028D  22        ci   ra,>16*256                 ; CMP #22           ; The dot product is positive, so the ships are facing
     3DB0 1600     
12716 3DB2 1706  14        jnc  TA9                        ; BCC TA9           ; each other. If A < 22 then the ships are not heading
12717                                                                          ; directly towards each other, so jump to TA9 to slow
12718                                                                          ; down
12719               
12720 3DB4 020D  20        li   ra,>03*256                 ; LDA #3            ; Otherwise set the acceleration in byte #28 to 3
     3DB6 0300     
12721 3DB8 D80D  30        movb ra,@INWK+28                ; STA INWK+28
     3DBA 006F     
12722               
12723 3DBC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3DBE FE34     
12724               
12725               TA9:
12726 3DC0 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of the dot product in A
     3DC2 7F00     
12727               
12728 3DC4 028D  22        ci   ra,>12*256                 ; CMP #18           ; If A < 18 then the ship is way off the XX15 vector, so
     3DC6 1200     
12729 3DC8 170C  14        jnc  TA10                       ; BCC TA10          ; return from the subroutine (TA10 contains an RTS)
12730                                                                          ; without slowing down, as it still has quite a bit of
12731                                                                          ; turning to do to get on course
12732               
12733 3DCA 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Otherwise set A = -1
     3DCC FF00     
12734               
12735 3DCE D3A0  30        movb @TYPE,rx                   ; LDX TYPE          ; If this is not a missile then skip the ASL instruction
     3DD0 009B     
12736 3DD2 028E  22        ci   rx,(MSL)*256               ; CPX #MSL
     3DD4 0900     
12737 3DD6 1603  14        jne  B36                        ; BNE B36
12738               
12739                      .asla                           ; ASL A             ; This is a missile, so set A = -2, as missiles are more
     **** ****     > ASLA
0001 3DD8 024D  22        andi ra,>ff00
     3DDA FF00     
0002 3DDC 0A1D  18        sla  ra,1
                   < elite.a99
12740                                                                          ; nimble and can brake more quickly
12741               
12742               B36:
12743 3DDE D80D  30        movb ra,@INWK+28                ; STA INWK+28       ; Set the ship's acceleration to A
     3DE0 006F     
12744               
12745               TA10:
12746 3DE2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3DE4 FE34     
12747               
12748               * ******************************************************************************
12749               *
12750               * Name: TAS1
12751               * Type: Subroutine
12752               * Category: Maths (Arithmetic)
12753               * Summary: Calculate K3 = (x_sign x_hi x_lo) - V(1 0)
12754               *
12755               * ------------------------------------------------------------------------------
12756               *
12757               * Calculate one of the following, depending on the value in Y:
12758               *
12759               * K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in V(1 0)
12760               *
12761               * K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in V(1 0)
12762               *
12763               * K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in V(1 0)
12764               *
12765               * where the first coordinate is from the ship data block in INWK, and the second
12766               * coordinate is from the ship data block pointed to by V(1 0).
12767               *
12768               * ------------------------------------------------------------------------------
12769               *
12770               * Arguments:
12771               *
12772               * V(1 0)              The address of the ship data block to subtract
12773               *
12774               * Y                   The coordinate in the V(1 0) block to subtract:
12775               *
12776               * * If Y = 2, subtract the x-coordinate and store the
12777               * result in K3(2 1 0)
12778               *
12779               * * If Y = 5, subtract the y-coordinate and store the
12780               * result in K3(5 4 3)
12781               *
12782               * * If Y = 8, subtract the z-coordinate and store the
12783               * result in K3(8 7 6)
12784               *
12785               * ******************************************************************************
12786               
12787               TAS1:
12788                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Copy the sign byte of the V(1 0) coordinate into K+3,
     **** ****     > LD_IND_Y_IDX
0001 3DE6 D820  42        movb @V,@rtmplb
     3DE8 0022     
     3DEA 8301     
0002 3DEC D020  30        movb @V+1,rtmp
     3DEE 0023     
0003 3DF0 06CF  14        swpb ry
0004 3DF2 A00F  18        a    ry,rtmp
0005 3DF4 06CF  14        swpb ry
0006 3DF6 D350  26        movb *rtmp,RA
                   < elite.a99
12789                      .eoi (>80*256)                  ; EOR #%10000000    ; flipping it in the process
     **** ****     > EOI
0001 3DF8 0200  20        li   rtmp,(>80*256)
     3DFA 8000     
0002 3DFC 2B40  18        xor  rtmp,ra
                   < elite.a99
12790 3DFE D80D  30        movb ra,@K+3                    ; STA K+3
     3E00 0040     
12791               
12792 3E02 73C7  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+2
12793                      .ld_ind_y_idx @V,ra             ; LDA (V),Y
     **** ****     > LD_IND_Y_IDX
0001 3E04 D820  42        movb @V,@rtmplb
     3E06 0022     
     3E08 8301     
0002 3E0A D020  30        movb @V+1,rtmp
     3E0C 0023     
0003 3E0E 06CF  14        swpb ry
0004 3E10 A00F  18        a    ry,rtmp
0005 3E12 06CF  14        swpb ry
0006 3E14 D350  26        movb *rtmp,RA
                   < elite.a99
12794 3E16 D80D  30        movb ra,@K+2                    ; STA K+2
     3E18 003F     
12795               
12796 3E1A 73C7  18        sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+1,
12797                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; so now:
     **** ****     > LD_IND_Y_IDX
0001 3E1C D820  42        movb @V,@rtmplb
     3E1E 0022     
     3E20 8301     
0002 3E22 D020  30        movb @V+1,rtmp
     3E24 0023     
0003 3E26 06CF  14        swpb ry
0004 3E28 A00F  18        a    ry,rtmp
0005 3E2A 06CF  14        swpb ry
0006 3E2C D350  26        movb *rtmp,RA
                   < elite.a99
12798 3E2E D80D  30        movb ra,@K+1                    ; STA K+1           ;
     3E30 003E     
12799                                                                          ; K(3 2 1) = - coordinate in V(1 0)
12800               
12801 3E32 D80F  30        movb ry,@U                      ; STY U             ; Copy the index (now 0, 3 or 6) into U and X
     3E34 008F     
12802 3E36 D3A0  30        movb @U,rx                      ; LDX U
     3E38 008F     
12803               
12804 3E3A 0200  20        li   rtmp,MVT3                  ; JSR MVT3          ; Call MVT3 to add the same coordinates, but this time
     3E3C 1D44     
12805 3E3E 06A0  32        bl   @jsr                       ;
     3E40 FE28     
12806                                                                          ; from INWK, so this would look like this for the
12807                                                                          ; x-axis:
12808                                                                          ;
12809                                                                          ; K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
12810                                                                          ; = (x_sign x_hi x_lo) - coordinate in V(1 0)
12811               
12812 3E42 D3E0  30        movb @U,ry                      ; LDY U             ; Restore the index into Y, though this instruction has
     3E44 008F     
12813                                                                          ; no effect, as Y is not used again, either here or
12814                                                                          ; following calls to this routine
12815               
12816 3E46 06CE  14        swpb rx                         ;
12817 3E48 DB8D  38        movb ra,@K3+2(rx)               ; STA K3+2,X        ; Store K(3 2 1) in K3+X(2 1 0), starting with the sign
     3E4A 00D4     
12818 3E4C 06CE  14        swpb rx                         ;
12819                                                                          ; byte
12820               
12821 3E4E D360  30        movb @K+2,ra                    ; LDA K+2           ; And then doing the high byte
     3E50 003F     
12822 3E52 06CE  14        swpb rx                         ;
12823 3E54 DB8D  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     3E56 00D3     
12824 3E58 06CE  14        swpb rx                         ;
12825               
12826 3E5A D360  30        movb @K+1,ra                    ; LDA K+1           ; And finally the low byte
     3E5C 003E     
12827 3E5E 06CE  14        swpb rx                         ;
12828 3E60 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X
     3E62 00D2     
12829 3E64 06CE  14        swpb rx                         ;
12830               
12831 3E66 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3E68 FE34     
12832               
12833               * ******************************************************************************
12834               *
12835               * Name: HITCH
12836               * Type: Subroutine
12837               * Category: Tactics
12838               * Summary: Work out if the ship in INWK is in our crosshairs
12839               * Deep dive: In the crosshairs
12840               *
12841               * ------------------------------------------------------------------------------
12842               *
12843               * This is called by the main flight loop to see if we have laser or missile lock
12844               * on an enemy ship.
12845               *
12846               * ------------------------------------------------------------------------------
12847               *
12848               * Returns:
12849               *
12850               * C flag              Set if the ship is in our crosshairs, clear if it isn't
12851               *
12852               * ------------------------------------------------------------------------------
12853               *
12854               * Other entry points:
12855               *
12856               * HI1                 Contains an RTS
12857               *
12858               * ******************************************************************************
12859               
12860               HITCH:
12861                      .clc                            ; CLC               ; Clear the C flag so we can return with it cleared if
     **** ****     > CLC
0001 3E6A 0A16  18        sla  rzero,1
                   < elite.a99
12862                                                                          ; our checks fail
12863               
12864 3E6C D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign
     3E6E 005B     
12865               
12866 3E70 164B  14        jne  HI1                        ; BNE HI1           ; If A is non-zero then the ship is behind us and can't
12867                                                                          ; be in our crosshairs, so return from the subroutine
12868                                                                          ; with the C flag clear (as HI1 contains an RTS)
12869               
12870 3E72 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type has bit 7 set then it is the planet
     3E74 009B     
12871 3E76 1148  14        jlt  HI1                        ; BMI HI1           ; or sun, which we can't target or hit with lasers, so
12872                                                                          ; return from the subroutine with the C flag clear (as
12873                                                                          ; HI1 contains an RTS)
12874               
12875 3E78 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch bit 5 of byte #31 (the exploding flag) and OR
     3E7A 0072     
12876 3E7C 024D  22        andi ra,>20*256                 ; AND #%00100000    ; with x_hi and y_hi
     3E7E 2000     
12877 3E80 F360  30        socb @INWK+1,ra                 ; ORA INWK+1
     3E82 0054     
12878 3E84 F360  30        socb @INWK+4,ra                 ; ORA INWK+4
     3E86 0057     
12879               
12880 3E88 163F  14        jne  HI1                        ; BNE HI1           ; If this value is non-zero then either the ship is
12881                                                                          ; exploding (so we can't target it), or the ship is too
12882                                                                          ; far away from our line of fire to be targeted, so
12883                                                                          ; return from the subroutine with the C flag clear (as
12884                                                                          ; HI1 contains an RTS)
12885               
12886 3E8A D360  30        movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo
     3E8C 0053     
12887               
12888 3E8E 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = x_lo^2
     3E90 464E     
12889 3E92 06A0  32        bl   @jsr                       ;
     3E94 FE28     
12890               
12891 3E96 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2
     3E98 0092     
12892 3E9A D360  30        movb @P,ra                      ; LDA P
     3E9C 001B     
12893 3E9E D80D  30        movb ra,@R                      ; STA R
     3EA0 0091     
12894               
12895 3EA2 D360  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set A = y_lo
     3EA4 0056     
12896               
12897 3EA6 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A = y_lo^2
     3EA8 464E     
12898 3EAA 06A0  32        bl   @jsr                       ;
     3EAC FE28     
12899               
12900 3EAE D38D  18        movb ra,rx                      ; TAX               ; Store the high byte in X
12901               
12902 3EB0 D360  30        movb @P,ra                      ; LDA P             ; Add the two low bytes, so:
     3EB2 001B     
12903                      .adc @R,ra                      ; ADC R             ;
     **** ****     > ADC
0001 3EB4 1701  14        jnc  !
0002 3EB6 B347  18        ab   rone,ra
0003               !:
0004 3EB8 B360  30        ab   @R,ra
     3EBA 0091     
                   < elite.a99
12904 3EBC D80D  30        movb ra,@R                      ; STA R             ; R = P + R
     3EBE 0091     
12905               
12906 3EC0 D34E  18        movb rx,ra                      ; TXA               ; Restore the high byte into A and add S to give the
12907                      .adc @S,ra                      ; ADC S             ; following:
     **** ****     > ADC
0001 3EC2 1701  14        jnc  !
0002 3EC4 B347  18        ab   rone,ra
0003               !:
0004 3EC6 B360  30        ab   @S,ra
     3EC8 0092     
                   < elite.a99
12908                                                                          ;
12909                                                                          ; (A R) = (S R) + (A P) = x_lo^2 + y_lo^2
12910               
12911 3ECA 1702  14        jnc  FIX002                     ; BCC FIX002        ; If the addition just overflowed then there is no way
12912                                                                          ; our crosshairs are within the ship's targetable area,
12913                                                                          ; so return from the subroutine with the C flag clear
12914                                                                          ; (as FR1-2 contains a CLC then an RTS)
12915 3ECC 0460  28        b    @FR1-2                     ; JMP FR1-2
     3ECE 4038     
12916               FIX002:
12917 3ED0 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2 + y_lo^2
     3ED2 0092     
12918               
12919 3ED4 020F  20        li   ry,>02*256                 ; LDY #2            ; Fetch the ship's blueprint and set A to the high byte
     3ED6 0200     
12920                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; of the targetable area of the ship
     **** ****     > LD_IND_Y_IDX
0001 3ED8 D820  42        movb @XX0,@rtmplb
     3EDA 001E     
     3EDC 8301     
0002 3EDE D020  30        movb @XX0+1,rtmp
     3EE0 001F     
0003 3EE2 06CF  14        swpb ry
0004 3EE4 A00F  18        a    ry,rtmp
0005 3EE6 06CF  14        swpb ry
0006 3EE8 D350  26        movb *rtmp,RA
                   < elite.a99
12921               
12922 3EEA 9360  30        cb   @S,ra                      ; CMP S             ; We now compare the high bytes of the targetable area
     3EEC 0092     
12923                                                                          ; and the calculation in (S R):
12924                                                                          ;
12925                                                                          ; * If A >= S then then the C flag will be set
12926                                                                          ;
12927                                                                          ; * If A < S then the C flag will be C clear
12928               
12929 3EEE 160C  14        jne  HI1                        ; BNE HI1           ; If A <> S we have just set the C flag correctly, so
12930                                                                          ; return from the subroutine (as HI1 contains an RTS)
12931               
12932 3EF0 73C7  18        sb   rone,ry                    ; DEY               ; The high bytes were identical, so now we fetch the
12933                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the targetable area into A
     **** ****     > LD_IND_Y_IDX
0001 3EF2 D820  42        movb @XX0,@rtmplb
     3EF4 001E     
     3EF6 8301     
0002 3EF8 D020  30        movb @XX0+1,rtmp
     3EFA 001F     
0003 3EFC 06CF  14        swpb ry
0004 3EFE A00F  18        a    ry,rtmp
0005 3F00 06CF  14        swpb ry
0006 3F02 D350  26        movb *rtmp,RA
                   < elite.a99
12934               
12935 3F04 9360  30        cb   @R,ra                      ; CMP R             ; We now compare the low bytes of the targetable area
     3F06 0091     
12936                                                                          ; and the calculation in (S R):
12937                                                                          ;
12938                                                                          ; * If A >= R then the C flag will be set
12939                                                                          ;
12940                                                                          ; * If A < R then the C flag will be C clear
12941               
12942               HI1:
12943 3F08 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     3F0A FE34     
12944               
12945               * ******************************************************************************
12946               *
12947               * Name: FRS1
12948               * Type: Subroutine
12949               * Category: Tactics
12950               * Summary: Launch a ship straight ahead of us, below the laser sights
12951               *
12952               * ------------------------------------------------------------------------------
12953               *
12954               * This is used in two places:
12955               *
12956               * * When we launch a missile, in which case the missile is the ship that is
12957               * launched ahead of us
12958               *
12959               * * When we launch our escape pod, in which case it's our abandoned Cobra Mk
12960               * III that is launched ahead of us
12961               *
12962               * * The fq1 entry point is used to launch a bunch of cargo canisters ahead of
12963               * us as part of the death screen
12964               *
12965               * ------------------------------------------------------------------------------
12966               *
12967               * Arguments:
12968               *
12969               * X                   The type of ship to launch ahead of us
12970               *
12971               * ------------------------------------------------------------------------------
12972               *
12973               * Returns:
12974               *
12975               * C flag              Set if the ship was successfully launched, clear if it
12976               * wasn't (as there wasn't enough free memory)
12977               *
12978               * ------------------------------------------------------------------------------
12979               *
12980               * Other entry points:
12981               *
12982               * fq1                 Used to add a cargo canister to the universe
12983               *
12984               * ******************************************************************************
12985               
12986               FRS1:
12987 3F0C 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     3F0E C710     
12988 3F10 06A0  32        bl   @jsr                       ;
     3F12 FE28     
12989               
12990 3F14 020D  20        li   ra,>1c*256                 ; LDA #28           ; Set y_lo = 28
     3F16 1C00     
12991 3F18 D80D  30        movb ra,@INWK+3                 ; STA INWK+3
     3F1A 0056     
12992               
12993 3F1C 091D  18        srl  ra,1                       ; LSR A             ; Set z_lo = 14, so the launched ship starts out
12994 3F1E D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; ahead of us
     3F20 0059     
12995               
12996 3F22 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set y_sign to be negative, so the launched ship is
     3F24 8000     
12997 3F26 D80D  30        movb ra,@INWK+5                 ; STA INWK+5        ; launched just below our line of sight
     3F28 0058     
12998               
12999 3F2A D360  30        movb @MSTG,ra                   ; LDA MSTG          ; Set A to the missile lock target, shifted left so the
     3F2C 0052     
13000                      .asla                           ; ASL A             ; slot number is in bits 1-5
     **** ****     > ASLA
0001 3F2E 024D  22        andi ra,>ff00
     3F30 FF00     
0002 3F32 0A1D  18        sla  ra,1
                   < elite.a99
13001               
13002 3F34 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 and store the result in byte #32, the AI
     3F36 8000     
13003 3F38 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; flag launched ship for the launched ship. For missiles
     3F3A 0073     
13004                                                                          ; this enables AI (bit 7), makes it friendly towards us
13005                                                                          ; (bit 6), sets the target to the value of MSTG (bits
13006                                                                          ; 1-5), and sets its lock status as launched (bit 0).
13007                                                                          ; It doesn't matter what it does for our abandoned
13008                                                                          ; Cobra, as the AI flag gets overwritten once we return
13009                                                                          ; from the subroutine back to the ESCAPE routine that
13010                                                                          ; called FRS1 in the first place
13011               
13012               fq1_:
13013 3F3C 020D  20        li   ra,>60*256                 ; LDA #&60          ; Set byte #14 (nosev_z_hi) to 1 (&60), so the launched
     3F3E 6000     
13014 3F40 D80D  30        movb ra,@INWK+14                ; STA INWK+14       ; ship is pointing away from us
     3F42 0061     
13015               
13016 3F44 026D  22        ori  ra,>80*256                 ; ORA #128          ; Set byte #22 (sidev_x_hi) to -1 (&D0), so the launched
     3F46 8000     
13017 3F48 D80D  30        movb ra,@INWK+22                ; STA INWK+22       ; ship has the same orientation as spawned ships, just
     3F4A 0069     
13018                                                                          ; pointing away from us (if we set sidev to +1 instead,
13019                                                                          ; this ship would be a mirror image of all the other
13020                                                                          ; ships, which are spawned with -1 in nosev and +1 in
13021                                                                          ; sidev)
13022               
13023 3F4C D360  30        movb @DELTA,ra                  ; LDA DELTA         ; Set byte #27 (speed) to 2 * DELTA, so the launched
     3F4E 008C     
13024 3F50 06A0  32        bl   @rola                      ; ROL A             ; ship flies off at twice our speed
     3F52 FE3E     
13025 3F54 D80D  30        movb ra,@INWK+27                ; STA INWK+27
     3F56 006E     
13026               
13027 3F58 D34E  18        movb rx,ra                      ; TXA               ; Add a new ship of type X to our local bubble of
13028 3F5A 0460  28        b    @NWSHP                     ; JMP NWSHP         ; universe and return from the subroutine using a tail
     3F5C B5DA     
13029                                                                          ; call
13030               
13031               * ******************************************************************************
13032               *
13033               * Name: FRMIS
13034               * Type: Subroutine
13035               * Category: Tactics
13036               * Summary: Fire a missile from our ship
13037               *
13038               * ------------------------------------------------------------------------------
13039               *
13040               * We fired a missile, so send it streaking away from us to unleash mayhem and
13041               * destruction on our sworn enemies.
13042               *
13043               * ******************************************************************************
13044               
13045               FRMIS:
13046 3F5E 020E  20        li   rx,(MSL)*256               ; LDX #MSL          ; Call FRS1 to launch a missile straight ahead of us
     3F60 0900     
13047 3F62 0200  20        li   rtmp,FRS1                  ; JSR FRS1
     3F64 3F0C     
13048 3F66 06A0  32        bl   @jsr                       ;
     3F68 FE28     
13049               
13050 3F6A 1767  14        jnc  FR1                        ; BCC FR1           ; If FRS1 returns with the C flag clear, then there
13051                                                                          ; isn't room in the universe for our missile, so jump
13052                                                                          ; down to FR1 to display a "missile jammed" message
13053               
13054 3F6C D3A0  30        movb @MSTG,rx                   ; LDX MSTG          ; Fetch the slot number of the missile's target
     3F6E 0052     
13055               
13056 3F70 0200  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for the target ship
     3F72 B564     
13057 3F74 06A0  32        bl   @jsr                       ;
     3F76 FE28     
13058                                                                          ; and store it in INF
13059               
13060 3F78 06CE  14        swpb rx                         ;
13061 3F7A D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type of the missile's target into A
     3F7C 0D40     
13062 3F7E 06CE  14        swpb rx                         ;
13063               
13064 3F80 0200  20        li   rtmp,ANGRY                 ; JSR ANGRY         ; Call ANGRY to make the target ship hostile
     3F82 3F9E     
13065 3F84 06A0  32        bl   @jsr                       ;
     3F86 FE28     
13066               
13067 3F88 020F  20        li   ry,>00*256                 ; LDY #0            ; We have just launched a missile, so we need to remove
     3F8A 0000     
13068 3F8C 0200  20        li   rtmp,ABORT                 ; JSR ABORT         ; missile lock and hide the leftmost indicator on the
     3F8E B72E     
13069 3F90 06A0  32        bl   @jsr                       ;
     3F92 FE28     
13070                                                                          ; dashboard by setting it to black (Y = 0)
13071               
13072 3F94 7347  18        sb   rone,ra                    ; DEC NOMSL         ; Reduce the number of missiles we have by 1
13073               
13074 3F96 020D  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     3F98 3000     
13075 3F9A 0460  28        b    @NOISE                     ; JMP NOISE         ; of a missile launch, returning from the subroutine
     3F9C D340     
13076                                                                          ; using a tail call
13077               
13078               * ******************************************************************************
13079               *
13080               * Name: ANGRY
13081               * Type: Subroutine
13082               * Category: Tactics
13083               * Summary: Make a ship hostile
13084               *
13085               * ------------------------------------------------------------------------------
13086               *
13087               * All this routine does is set the ship's hostile flag, start it turning and
13088               * give it a kick of acceleration - later calls to TACTICS will make the ship
13089               * start to attack us.
13090               *
13091               * ------------------------------------------------------------------------------
13092               *
13093               * Arguments:
13094               *
13095               * A                   The type of ship we're going to irritate
13096               *
13097               * INF                 The address of the data block for the ship we're going
13098               * to infuriate
13099               *
13100               * ******************************************************************************
13101               
13102               ANGRY:
13103 3F9E 028D  22        ci   ra,(SST)*256               ; CMP #SST          ; If this is the space station, jump to AN2 to make the
     3FA0 0800     
13104 3FA2 133C  14        jeq  AN2                        ; BEQ AN2           ; space station hostile
13105               
13106 3FA4 18B1  14        joc  HI1                        ; BCS HI1           ; If A >= #SST then this is a missile, asteroid, cargo
13107                                                                          ; canister, Thargon or escape pod, and they can't get
13108                                                                          ; hostile, so return from the subroutine (as HI1
13109                                                                          ; contains an RTS)
13110               
13111 3FA6 028D  22        ci   ra,(CYL)*256               ; CMP #CYL          ; If this is not a Cobra Mk III trader, skip the
     3FA8 0700     
13112 3FAA 1604  14        jne  B37                        ; BNE B37           ; following instruction
13113               
13114 3FAC 0200  20        li   rtmp,AN2                   ; JSR AN2           ; Call AN2 to make the space station hostile
     3FAE 401C     
13115 3FB0 06A0  32        bl   @jsr                       ;
     3FB2 FE28     
13116               
13117               B37:
13118 3FB4 020F  20        li   ry,>20*256                 ; LDY #32           ; Fetch the ship's byte #32 (AI flag)
     3FB6 2000     
13119                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 3FB8 D820  42        movb @INF,@rtmplb
     3FBA 0020     
     3FBC 8301     
0002 3FBE D020  30        movb @INF+1,rtmp
     3FC0 0021     
0003 3FC2 06CF  14        swpb ry
0004 3FC4 A00F  18        a    ry,rtmp
0005 3FC6 06CF  14        swpb ry
0006 3FC8 D350  26        movb *rtmp,RA
                   < elite.a99
13120               
13121 3FCA 139E  14        jeq  HI1                        ; BEQ HI1           ; If the AI flag is zero then this ship has no AI and
13122                                                                          ; it can't get hostile, so return from the subroutine
13123                                                                          ; (as HI1 contains an RTS)
13124               
13125 3FCC 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 (AI enabled) to ensure AI is
     3FCE 8000     
13126                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; definitely enabled
     **** ****     > ST_IND_Y_IDX
0001 3FD0 D820  42        movb @INF,@rtmplb
     3FD2 0020     
     3FD4 8301     
0002 3FD6 D020  30        movb @INF+1,rtmp
     3FD8 0021     
0003 3FDA 06CF  14        swpb ry
0004 3FDC A00F  18        a    ry,rtmp
0005 3FDE 06CF  14        swpb ry
0006 3FE0 D40D  30        movb RA,*rtmp
                   < elite.a99
13127               
13128 3FE2 020F  20        li   ry,>1c*256                 ; LDY #28           ; Set the ship's byte #28 (acceleration) to 2, so it
     3FE4 1C00     
13129 3FE6 020D  20        li   ra,>02*256                 ; LDA #2            ; speeds up
     3FE8 0200     
13130                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 3FEA D820  42        movb @INF,@rtmplb
     3FEC 0020     
     3FEE 8301     
0002 3FF0 D020  30        movb @INF+1,rtmp
     3FF2 0021     
0003 3FF4 06CF  14        swpb ry
0004 3FF6 A00F  18        a    ry,rtmp
0005 3FF8 06CF  14        swpb ry
0006 3FFA D40D  30        movb RA,*rtmp
                   < elite.a99
13131               
13132                      .asla                           ; ASL A             ; Set the ship's byte #30 (pitch counter) to 4, so it
     **** ****     > ASLA
0001 3FFC 024D  22        andi ra,>ff00
     3FFE FF00     
0002 4000 0A1D  18        sla  ra,1
                   < elite.a99
13133 4002 020F  20        li   ry,>1e*256                 ; LDY #30           ; starts diving
     4004 1E00     
13134                      .st_ind_y_idx @INF,ra           ; STA (INF),Y
     **** ****     > ST_IND_Y_IDX
0001 4006 D820  42        movb @INF,@rtmplb
     4008 0020     
     400A 8301     
0002 400C D020  30        movb @INF+1,rtmp
     400E 0021     
0003 4010 06CF  14        swpb ry
0004 4012 A00F  18        a    ry,rtmp
0005 4014 06CF  14        swpb ry
0006 4016 D40D  30        movb RA,*rtmp
                   < elite.a99
13135               
13136 4018 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     401A FE34     
13137               
13138               AN2:
13139                      .asl @K.+NI.+32                 ; ASL K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
     **** ****     > ASL
0001 401C D020  30        movb @K.+NI.+32,rtmp
     401E 0944     
0002 4020 0240  22        andi rtmp,>ff00
     4022 FF00     
0003 4024 0A10  18        sla  rtmp,1
0004 4026 D800  30        movb rtmp,@K.+NI.+32
     4028 0944     
                   < elite.a99
13140                      .sec                            ; SEC               ; in the ship data workspace at K%, which is reserved
     **** ****     > SEC
0001 402A 0A18  18        sla  rmone,1
                   < elite.a99
13141 402C 0204  20        li   rarg1,K.+NI.+32            ; ROR K%+NI%+32     ; for the sun or the space station (in this case it's
     402E 0944     
13142 4030 06A0  32        bl   @ror                       ;
     4032 FE7A     
13143                                                                          ; the latter), and set bit 7 to make it hostile
13144               
13145                      .clc                            ; CLC               ; Clear the C flag, which isn't used by calls to this
     **** ****     > CLC
0001 4034 0A16  18        sla  rzero,1
                   < elite.a99
13146                                                                          ; routine, but it does set up the entry point FR1-2
13147                                                                          ; so that it clears the C flag and does an RTS
13148               
13149 4036 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4038 FE34     
13150               
13151               * ******************************************************************************
13152               *
13153               * Name: FR1
13154               * Type: Subroutine
13155               * Category: Tactics
13156               * Summary: Display the "missile jammed" message
13157               *
13158               * ------------------------------------------------------------------------------
13159               *
13160               * This is shown if there isn't room in the local bubble of universe for a new
13161               * missile.
13162               *
13163               * ------------------------------------------------------------------------------
13164               *
13165               * Other entry points:
13166               *
13167               * FR1-2               Clear the C flag and return from the subroutine
13168               *
13169               * ******************************************************************************
13170               
13171               FR1:
13172 403A 020D  20        li   ra,>c9*256                 ; LDA #201          ; Print recursive token 41 ("MISSILE JAMMED") as an
     403C C900     
13173 403E 0460  28        b    @MESS                      ; JMP MESS          ; in-flight message and return from the subroutine using
     4040 D616     
13174                                                                          ; a tail call
13175               
13176               * ******************************************************************************
13177               *
13178               * Name: SESCP
13179               * Type: Subroutine
13180               * Category: Flight
13181               * Summary: Spawn an escape pod from the current (parent) ship
13182               *
13183               * ------------------------------------------------------------------------------
13184               *
13185               * This is called when an enemy ship has run out of both energy and luck, so it's
13186               * time to bail.
13187               *
13188               * ******************************************************************************
13189               
13190               SESCP:
13191 4042 020E  20        li   rx,(ESC)*256               ; LDX #ESC          ; Set X to the ship type for an escape pod
     4044 0D00     
13192               
13193 4046 020D  20        li   ra,>fe*256                 ; LDA #%11111110    ; Set A to an AI flag that has AI enabled, is hostile,
     4048 FE00     
13194                                                                          ; but has no E.C.M.
13195               
13196                                                                          ; Fall through into SFS1 to spawn the escape pod
13197               
13198               * ******************************************************************************
13199               *
13200               * Name: SFS1
13201               * Type: Subroutine
13202               * Category: Universe
13203               * Summary: Spawn a child ship from the current (parent) ship
13204               *
13205               * ------------------------------------------------------------------------------
13206               *
13207               * If the parent is a space station then the child ship is spawned coming out of
13208               * the slot, and if the child is a cargo canister, it is sent tumbling through
13209               * space. Otherwise the child ship is spawned with the same ship data as the
13210               * parent, just with damping disabled and the ship type and AI flag that are
13211               * passed in A and X.
13212               *
13213               * ------------------------------------------------------------------------------
13214               *
13215               * Arguments:
13216               *
13217               * A                   AI flag for the new ship (see the documentation on ship
13218               * data byte #32 for details)
13219               *
13220               * X                   The ship type of the child to spawn
13221               *
13222               * INF                 Address of the parent's ship data block
13223               *
13224               * TYPE                The type of the parent ship
13225               *
13226               * ------------------------------------------------------------------------------
13227               *
13228               * Returns:
13229               *
13230               * C flag              Set if ship successfully added, clear if it failed
13231               *
13232               * INF                 INF is preserved
13233               *
13234               * XX0                 XX0 is preserved
13235               *
13236               * INWK                The whole INWK workspace is preserved
13237               *
13238               * ------------------------------------------------------------------------------
13239               *
13240               * Other entry points:
13241               *
13242               * SFS1-2              Add a missile to the local bubble that has AI enabled,
13243               * is hostile, but has no E.C.M.
13244               *
13245               * ******************************************************************************
13246               
13247               SFS1:
13248 404A D80D  30        movb ra,@T1                     ; STA T1            ; Store the child ship's AI flag in T1
     404C 0006     
13249               
13250                                                                          ; Before spawning our child ship, we need to save the
13251                                                                          ; INF and XX00 variables and the whole INWK workspace,
13252                                                                          ; so we can restore them later when returning from the
13253                                                                          ; subroutine
13254               
13255 404E D360  30        movb @XX0,ra                    ; LDA XX0           ; Store XX0(1 0) on the stack, so we can restore it
     4050 001E     
13256                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 4052 D68D  30        movb ra,*rsp
0002 4054 060A  14        dec  rsp
                   < elite.a99
13257 4056 D360  30        movb @XX0+1,ra                  ; LDA XX0+1
     4058 001F     
13258                      .pha                            ; PHA
     **** ****     > PHA
0001 405A D68D  30        movb ra,*rsp
0002 405C 060A  14        dec  rsp
                   < elite.a99
13259               
13260 405E D360  30        movb @INF,ra                    ; LDA INF           ; Store INF(1 0) on the stack, so we can restore it
     4060 0020     
13261                      .pha                            ; PHA               ; later when returning from the subroutine
     **** ****     > PHA
0001 4062 D68D  30        movb ra,*rsp
0002 4064 060A  14        dec  rsp
                   < elite.a99
13262 4066 D360  30        movb @INF+1,ra                  ; LDA INF+1
     4068 0021     
13263                      .pha                            ; PHA
     **** ****     > PHA
0001 406A D68D  30        movb ra,*rsp
0002 406C 060A  14        dec  rsp
                   < elite.a99
13264               
13265 406E 020F  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Now we want to store the current INWK data block in
     4070 2300     
13266                                                                          ; temporary memory so we can restore it when we are
13267                                                                          ; done, and we also want to copy the parent's ship data
13268                                                                          ; into INWK, which we can do at the same time, so set up
13269                                                                          ; a counter in Y for NI% bytes
13270               
13271               FRL2:
13272 4072 06CF  14        swpb ry                         ;
13273 4074 D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Copy the Y-th byte of INWK to the Y-th byte of
     4076 0053     
13274 4078 06CF  14        swpb ry                         ;
13275 407A 06CF  14        swpb ry                         ;
13276 407C DBCD  38        movb ra,@XX3(ry)                ; STA XX3,Y         ; temporary memory in XX3, so we can restore it later
     407E 0100     
13277 4080 06CF  14        swpb ry                         ;
13278                                                                          ; when returning from the subroutine
13279               
13280                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte of the parent ship's data block to
     **** ****     > LD_IND_Y_IDX
0001 4082 D820  42        movb @INF,@rtmplb
     4084 0020     
     4086 8301     
0002 4088 D020  30        movb @INF+1,rtmp
     408A 0021     
0003 408C 06CF  14        swpb ry
0004 408E A00F  18        a    ry,rtmp
0005 4090 06CF  14        swpb ry
0006 4092 D350  26        movb *rtmp,RA
                   < elite.a99
13281 4094 06CF  14        swpb ry                         ;
13282 4096 DBCD  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; the Y-th byte of INWK
     4098 0053     
13283 409A 06CF  14        swpb ry                         ;
13284               
13285 409C 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
13286               
13287 409E 15E9  14        jgt  FRL2                       ; BPL FRL2          ; Loop back to copy the next byte until we have done
13288                                                                          ; them all
13289               
13290                                                                          ; INWK now contains the ship data for the parent ship,
13291                                                                          ; so now we need to tweak the data before creating the
13292                                                                          ; new child ship (in this way, the child inherits things
13293                                                                          ; like location from the parent)
13294               
13295 40A0 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type of the parent into A
     40A2 009B     
13296               
13297 40A4 028D  22        ci   ra,(SST)*256               ; CMP #SST          ; If the parent is not a space station, jump to rx to
     40A6 0800     
13298 40A8 1622  14        jne  rx_                        ; BNE rx            ; skip the following
13299               
13300                                                                          ; The parent is a space station, so the child needs to
13301                                                                          ; launch out of the space station's slot. The space
13302                                                                          ; station's nosev vector points out of the station's
13303                                                                          ; slot, so we want to move the ship along this vector.
13304                                                                          ; We do this by taking the unit vector in nosev and
13305                                                                          ; doubling it, so we spawn our ship 2 units along the
13306                                                                          ; vector from the space station's centre
13307               
13308 40AA D34E  18        movb rx,ra                      ; TXA               ; Store the child's ship type in X on the stack
13309                      .pha                            ; PHA
     **** ****     > PHA
0001 40AC D68D  30        movb ra,*rsp
0002 40AE 060A  14        dec  rsp
                   < elite.a99
13310               
13311 40B0 020D  20        li   ra,>20*256                 ; LDA #32           ; Set the child's byte #27 (speed) to 32
     40B2 2000     
13312 40B4 D80D  30        movb ra,@INWK+27                ; STA INWK+27
     40B6 006E     
13313               
13314 40B8 020E  20        li   rx,>00*256                 ; LDX #0            ; Add 2 * nosev_x_hi to (x_lo, x_hi, x_sign) to get the
     40BA 0000     
13315 40BC D360  30        movb @INWK+10,ra                ; LDA INWK+10       ; child's x-coordinate
     40BE 005D     
13316 40C0 0200  20        li   rtmp,SFS2                  ; JSR SFS2
     40C2 4186     
13317 40C4 06A0  32        bl   @jsr                       ;
     40C6 FE28     
13318               
13319 40C8 020E  20        li   rx,>03*256                 ; LDX #3            ; Add 2 * nosev_y_hi to (y_lo, y_hi, y_sign) to get the
     40CA 0300     
13320 40CC D360  30        movb @INWK+12,ra                ; LDA INWK+12       ; child's y-coordinate
     40CE 005F     
13321 40D0 0200  20        li   rtmp,SFS2                  ; JSR SFS2
     40D2 4186     
13322 40D4 06A0  32        bl   @jsr                       ;
     40D6 FE28     
13323               
13324 40D8 020E  20        li   rx,>06*256                 ; LDX #6            ; Add 2 * nosev_z_hi to (z_lo, z_hi, z_sign) to get the
     40DA 0600     
13325 40DC D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; child's z-coordinate
     40DE 0061     
13326 40E0 0200  20        li   rtmp,SFS2                  ; JSR SFS2
     40E2 4186     
13327 40E4 06A0  32        bl   @jsr                       ;
     40E6 FE28     
13328               
13329                      .pla                            ; PLA               ; Restore the child's ship type from the stack into X
     **** ****     > PLA
0001 40E8 058A  14        inc  rsp
0002 40EA D35A  26        movb *rsp,ra
                   < elite.a99
13330 40EC D38D  18        movb ra,rx                      ; TAX
13331               
13332               rx_:
13333 40EE D360  30        movb @T1,ra                     ; LDA T1            ; Restore the child ship's AI flag from T1 and store it
     40F0 0006     
13334 40F2 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; in the child's byte #32 (AI)
     40F4 0073     
13335               
13336                      .lsr @INWK+29                   ; LSR INWK+29       ; Clear bit 0 of the child's byte #29 (roll counter) so
     **** ****     > LSR
0001 40F6 D020  30        movb @INWK+29,rtmp
     40F8 0070     
0002 40FA 0910  18        srl  rtmp,1
0003 40FC D800  30        movb rtmp,@INWK+29
     40FE 0070     
                   < elite.a99
13337                      .asl @INWK+29                   ; ASL INWK+29       ; that its roll dampens (so if we are spawning from a
     **** ****     > ASL
0001 4100 D020  30        movb @INWK+29,rtmp
     4102 0070     
0002 4104 0240  22        andi rtmp,>ff00
     4106 FF00     
0003 4108 0A10  18        sla  rtmp,1
0004 410A D800  30        movb rtmp,@INWK+29
     410C 0070     
                   < elite.a99
13338                                                                          ; space station, for example, the spawned ship won't
13339                                                                          ; keep rolling forever)
13340               
13341 410E D34E  18        movb rx,ra                      ; TXA               ; Copy the child's ship type from X into A
13342               
13343 4110 028D  22        ci   ra,(OIL)*256               ; CMP #OIL          ; If the child we are spawning is not a cargo canister,
     4112 0B00     
13344 4114 1616  14        jne  NOIL                       ; BNE NOIL          ; jump to NOIL to skip us setting up the pitch and roll
13345                                                                          ; for the canister
13346               
13347 4116 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     4118 C7D0     
13348 411A 06A0  32        bl   @jsr                       ;
     411C FE28     
13349               
13350                      .asla                           ; ASL A             ; Set the child's byte #30 (pitch counter) to a random
     **** ****     > ASLA
0001 411E 024D  22        andi ra,>ff00
     4120 FF00     
0002 4122 0A1D  18        sla  ra,1
                   < elite.a99
13351 4124 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; value, and at the same time set the C flag randomly
     4126 0071     
13352               
13353 4128 D34E  18        movb rx,ra                      ; TXA               ; Set the child's byte #27 (speed) to a random value
13354 412A 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; between 0 and 15
     412C 0F00     
13355 412E D80D  30        movb ra,@INWK+27                ; STA INWK+27
     4130 006E     
13356               
13357 4132 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set the child's byte #29 (roll counter) to a full
     4134 FF00     
13358 4136 06A0  32        bl   @rora                      ; ROR A             ; roll with no damping (as bits 0 to 6 are set), so the
     4138 FE62     
13359 413A D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; canister tumbles through space, with the direction in
     413C 0070     
13360                                                                          ; bit 7 set randomly, depending on the C flag from above
13361               
13362 413E 020D  20        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship type of a cargo canister
     4140 0B00     
13363               
13364               NOIL:
13365 4142 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add a new ship of type A to the local bubble
     4144 B5DA     
13366 4146 06A0  32        bl   @jsr                       ;
     4148 FE28     
13367               
13368                                                                          ; We have now created our child ship, so we need to
13369                                                                          ; restore all the variables we saved at the start of
13370                                                                          ; the routine, so they are preserved when we return
13371                                                                          ; from the subroutine
13372               
13373                      .pla                            ; PLA               ; Restore INF(1 0) from the stack
     **** ****     > PLA
0001 414A 058A  14        inc  rsp
0002 414C D35A  26        movb *rsp,ra
                   < elite.a99
13374 414E D80D  30        movb ra,@INF+1                  ; STA INF+1
     4150 0021     
13375                      .pla                            ; PLA
     **** ****     > PLA
0001 4152 058A  14        inc  rsp
0002 4154 D35A  26        movb *rsp,ra
                   < elite.a99
13376 4156 D80D  30        movb ra,@INF                    ; STA INF
     4158 0020     
13377               
13378 415A 020E  20        li   rx,(NI.-1)*256             ; LDX #NI%-1        ; Now to restore the INWK workspace that we saved into
     415C 2300     
13379                                                                          ; XX3 above, so set a counter in X for NI% bytes
13380               
13381               FRL3:
13382 415E 06CE  14        swpb rx                         ;
13383 4160 D36E  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Copy the Y-th byte of XX3 to the Y-th byte of INWK
     4162 0100     
13384 4164 06CE  14        swpb rx                         ;
13385 4166 06CE  14        swpb rx                         ;
13386 4168 DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X
     416A 0053     
13387 416C 06CE  14        swpb rx                         ;
13388               
13389 416E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
13390               
13391 4170 15F6  14        jgt  FRL3                       ; BPL FRL3          ; Loop back to copy the next byte until we have done
13392                                                                          ; them all
13393               
13394                      .pla                            ; PLA               ; Restore XX0(1 0) from the stack
     **** ****     > PLA
0001 4172 058A  14        inc  rsp
0002 4174 D35A  26        movb *rsp,ra
                   < elite.a99
13395 4176 D80D  30        movb ra,@XX0+1                  ; STA XX0+1
     4178 001F     
13396                      .pla                            ; PLA
     **** ****     > PLA
0001 417A 058A  14        inc  rsp
0002 417C D35A  26        movb *rsp,ra
                   < elite.a99
13397 417E D80D  30        movb ra,@XX0                    ; STA XX0
     4180 001E     
13398               
13399 4182 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4184 FE34     
13400               
13401               * ******************************************************************************
13402               *
13403               * Name: SFS2
13404               * Type: Subroutine
13405               * Category: Moving
13406               * Summary: Move a ship in space along one of the coordinate axes
13407               *
13408               * ------------------------------------------------------------------------------
13409               *
13410               * Move a ship's coordinates by a certain amount in the direction of one of the
13411               * axes, where X determines the axis. Mathematically speaking, this routine
13412               * translates the ship along a single axis by a signed delta.
13413               *
13414               * ------------------------------------------------------------------------------
13415               *
13416               * Arguments:
13417               *
13418               * A                   The amount of movement, i.e. the signed delta
13419               *
13420               * X                   Determines which coordinate axis of INWK to move:
13421               *
13422               * * X = 0 moves the ship along the x-axis
13423               *
13424               * * X = 3 moves the ship along the y-axis
13425               *
13426               * * X = 6 moves the ship along the z-axis
13427               *
13428               * ******************************************************************************
13429               
13430               SFS2:
13431                      .asla                           ; ASL A             ; Set R = |A * 2|, with the C flag set to bit 7 of A
     **** ****     > ASLA
0001 4186 024D  22        andi ra,>ff00
     4188 FF00     
0002 418A 0A1D  18        sla  ra,1
                   < elite.a99
13432 418C D80D  30        movb ra,@R                      ; STA R
     418E 0091     
13433               
13434 4190 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to the C flag, i.e. the sign bit from
     4192 0000     
13435 4194 06A0  32        bl   @rora                      ; ROR A             ; the original argument in A
     4196 FE62     
13436               
13437 4198 0460  24        b    @MVT1                      ; JMP MVT1          ; Add the delta R with sign A to (x_lo, x_hi, x_sign)
     419A 1C1A     
13438                                                                          ; (or y or z, depending on the value in X) and return
13439                                                                          ; from the subroutine using a tail call
13440               
13441               * ******************************************************************************
13442               *
13443               * Name: LL164
13444               * Type: Subroutine
13445               * Category: Drawing circles
13446               * Summary: Make the hyperspace sound and draw the hyperspace tunnel
13447               *
13448               * ------------------------------------------------------------------------------
13449               *
13450               * See the IRQ1 routine for details on the multi-coloured effect that's used.
13451               *
13452               * ******************************************************************************
13453               
13454               LL164:
13455 419C 020D  20        li   ra,>38*256                 ; LDA #56           ; Call the NOISE routine with A = 56 to make the sound
     419E 3800     
13456 41A0 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the hyperspace drive being engaged
     41A2 D340     
13457 41A4 06A0  32        bl   @jsr                       ;
     41A6 FE28     
13458               
13459 41A8 020D  20        li   ra,>01*256                 ; LDA #1            ; Set HFX to 1, which switches the screen mode to a full
     41AA 0100     
13460 41AC D80D  30        movb ra,@HFX                    ; STA HFX           ; mode 5 screen, therefore making the hyperspace rings
     41AE 0D62     
13461                                                                          ; multi-coloured and all zig-zaggy (see the IRQ1 routine
13462                                                                          ; for details)
13463               
13464 41B0 020D  20        li   ra,>04*256                 ; LDA #4            ; Set the step size for the hyperspace rings to 4, so
     41B2 0400     
13465                                                                          ; there are more sections in the rings and they are
13466                                                                          ; quite round (compared to the step size of 8 used in
13467                                                                          ; the much more polygonal launch rings)
13468               
13469 41B4 0200  20        li   rtmp,HFS2                  ; JSR HFS2          ; Call HFS2 to draw the hyperspace tunnel rings
     41B6 41D2     
13470 41B8 06A0  32        bl   @jsr                       ;
     41BA FE28     
13471               
13472 41BC 7347  18        sb   rone,ra                    ; DEC HFX           ; Set HFX back to 0, so we switch back to the normal
13473                                                                          ; split-screen mode
13474               
13475 41BE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     41C0 FE34     
13476               
13477               * ******************************************************************************
13478               *
13479               * Name: LAUN
13480               * Type: Subroutine
13481               * Category: Drawing circles
13482               * Summary: Make the launch sound and draw the launch tunnel
13483               *
13484               * ------------------------------------------------------------------------------
13485               *
13486               * This is shown when launching from or docking with the space station.
13487               *
13488               * ******************************************************************************
13489               
13490               LAUN:
13491 41C2 020D  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     41C4 3000     
13492 41C6 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the ship launching from the station
     41C8 D340     
13493 41CA 06A0  32        bl   @jsr                       ;
     41CC FE28     
13494               
13495 41CE 020D  20        li   ra,>08*256                 ; LDA #8            ; Set the step size for the launch tunnel rings to 8, so
     41D0 0800     
13496                                                                          ; there are fewer sections in the rings and they are
13497                                                                          ; quite polygonal (compared to the step size of 4 used
13498                                                                          ; in the much rounder hyperspace rings)
13499               
13500                                                                          ; Fall through into HFS2 to draw the launch tunnel rings
13501               
13502               * ******************************************************************************
13503               *
13504               * Name: HFS2
13505               * Type: Subroutine
13506               * Category: Drawing circles
13507               * Summary: Draw the launch or hyperspace tunnel
13508               *
13509               * ------------------------------------------------------------------------------
13510               *
13511               * The animation gets drawn like this. First, we draw a circle of radius 8 at the
13512               * centre, and then double the radius, draw another circle, double the radius
13513               * again and draw a circle, and we keep doing this until the radius is bigger
13514               * than 160 (which goes beyond the edge of the screen, which is 256 pixels wide,
13515               * equivalent to a radius of 128). We then repeat this whole process for an
13516               * initial circle of radius 9, then radius 10, all the way up to radius 15.
13517               *
13518               * This has the effect of making the tunnel appear to be racing towards us as we
13519               * hurtle out into hyperspace or through the space station's docking tunnel.
13520               *
13521               * The hyperspace effect is done in a full mode 5 screen, which makes the rings
13522               * all coloured and zig-zaggy, while the launch screen is in the normal
13523               * monochrome mode 4 screen.
13524               *
13525               * ------------------------------------------------------------------------------
13526               *
13527               * Arguments:
13528               *
13529               * A                   The step size of the straight lines making up the rings
13530               * (4 for launch, 8 for hyperspace)
13531               *
13532               * ******************************************************************************
13533               
13534               HFS2:
13535 41D2 D80D  30        movb ra,@STP                    ; STA STP           ; Store the step size in A
     41D4 00A6     
13536               
13537 41D6 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; Clear the screen and draw a white border
     41D8 4EFE     
13538 41DA 06A0  32        bl   @jsr                       ;
     41DC FE28     
13539               
13540 41DE 0200  20        li   rtmp,HFS1                  ; JSR HFS1          ; Call HFS1 below and then fall through into the same
     41E0 41E6     
13541 41E2 06A0  32        bl   @jsr                       ;
     41E4 FE28     
13542                                                                          ; routine, so this effectively runs HFS1 twice, and as
13543                                                                          ; HFS1 draws 8 concentric rings, this means we draw 16
13544                                                                          ; of them in all
13545               
13546               HFS1:
13547 41E6 020D  20        li   ra,>80*256                 ; LDA #128          ; Set K3 = 128 (the x-coordinate of the centre of the
     41E8 8000     
13548 41EA D80D  30        movb ra,@K3                     ; STA K3            ; screen)
     41EC 00D2     
13549               
13550 41EE 020E  20        li   rx,(Y)*256                 ; LDX #Y            ; Set K4 = #Y (the y-coordinate of the centre of the
     41F0 6000     
13551 41F2 D80E  30        movb rx,@K4                     ; STX K4            ; screen)
     41F4 00E0     
13552               
13553                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 41F6 024D  22        andi ra,>ff00
     41F8 FF00     
0002 41FA 0A1D  18        sla  ra,1
                   < elite.a99
13554               
13555 41FC D80D  30        movb ra,@XX4                    ; STA XX4           ; Set XX4 = 0, which we will use as a counter for
     41FE 00A7     
13556                                                                          ; drawing eight concentric rings
13557               
13558 4200 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     4202 00D3     
13559 4204 D80D  30        movb ra,@K4+1                   ; STA K4+1
     4206 00E1     
13560               
13561               HFL5:
13562 4208 0200  20        li   rtmp,HFL1                  ; JSR HFL1          ; Call HFL1 below to draw a set of rings, with each one
     420A 4220     
13563 420C 06A0  32        bl   @jsr                       ;
     420E FE28     
13564                                                                          ; twice the radius of the previous one, until they won't
13565                                                                          ; fit on-screen
13566               
13567 4210 B347  18        ab   rone,ra                    ; INC XX4           ; Increment the counter and fetch it into X
13568 4212 D3A0  30        movb @XX4,rx                    ; LDX XX4
     4214 00A7     
13569               
13570 4216 028E  22        ci   rx,>08*256                 ; CPX #8            ; If we haven't drawn 8 sets of rings yet, loop back to
     4218 0800     
13571 421A 16F6  14        jne  HFL5                       ; BNE HFL5          ; HFL5 to draw the next ring
13572               
13573 421C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     421E FE34     
13574               
13575               HFL1:
13576 4220 D360  30        movb @XX4,ra                    ; LDA XX4           ; Set K to the ring number in XX4 (0-7) + 8, so K has
     4222 00A7     
13577 4224 024D  22        andi ra,>07*256                 ; AND #7            ; a value of 8 to 15, which we will use as the starting
     4226 0700     
13578                      .clc                            ; CLC               ; radius for our next set of rings
     **** ****     > CLC
0001 4228 0A16  18        sla  rzero,1
                   < elite.a99
13579                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 422A 1701  14        jnc  !
0002 422C B347  18        ab   rone,ra
0003               !:
0004 422E 022D  22        ai   ra,(>08*256)
     4230 0800     
                   < elite.a99
13580 4232 D80D  30        movb ra,@K                      ; STA K
     4234 003D     
13581               
13582               HFL2:
13583 4236 020D  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap
     4238 0100     
13584 423A D80D  30        movb ra,@LSP                    ; STA LSP
     423C 0077     
13585               
13586 423E 0200  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     4240 BEE8     
13587 4242 06A0  32        bl   @jsr                       ;
     4244 FE28     
13588                                                                          ; (K3(1 0), K4(1 0)) and radius K
13589               
13590                      .asl @K                         ; ASL K             ; Double the radius in K
     **** ****     > ASL
0001 4246 D020  30        movb @K,rtmp
     4248 003D     
0002 424A 0240  22        andi rtmp,>ff00
     424C FF00     
0003 424E 0A10  18        sla  rtmp,1
0004 4250 D800  30        movb rtmp,@K
     4252 003D     
                   < elite.a99
13591               
13592 4254 1805  14        joc  HF8                        ; BCS HF8           ; If the radius had a 1 in bit 7 before the above shift,
13593                                                                          ; then doubling K will means the circle will no longer
13594                                                                          ; fit on the screen (which is width 256), so jump to
13595                                                                          ; HF8 to stop drawing circles
13596               
13597 4256 D360  30        movb @K,ra                      ; LDA K             ; If the radius in K <= 160, loop back to HFL2 to draw
     4258 003D     
13598 425A 028D  22        ci   ra,>a0*256                 ; CMP #160          ; another one
     425C A000     
13599 425E 17EB  14        jnc  HFL2                       ; BCC HFL2
13600               
13601               HF8:
13602 4260 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4262 FE34     
13603               
13604               * ******************************************************************************
13605               *
13606               * Name: STARS2
13607               * Type: Subroutine
13608               * Category: Stardust
13609               * Summary: Process the stardust for the left or right view
13610               * Deep dive: Stardust in the side views
13611               *
13612               * ------------------------------------------------------------------------------
13613               *
13614               * This moves the stardust sideways according to our speed and which side we are
13615               * looking out of, and applies our current pitch and roll to each particle of
13616               * dust, so the stardust moves correctly when we steer our ship.
13617               *
13618               * These are the calculations referred to in the commentary:
13619               *
13620               * 1. delta_x = 8 * 256 * speed / z_hi
13621               * 2. x = x + delta_x
13622               *
13623               * 3. x = x + beta * y
13624               * 4. y = y - beta * x
13625               *
13626               * 5. x = x - alpha * x * y
13627               * 6. y = y + alpha * y * y + alpha
13628               *
13629               * For more information see the deep dive on "Stardust in the side views".
13630               *
13631               * ------------------------------------------------------------------------------
13632               *
13633               * Arguments:
13634               *
13635               * X                   The view to process:
13636               *
13637               * * X = 1 for left view
13638               *
13639               * * X = 2 for right view
13640               *
13641               * ******************************************************************************
13642               
13643               STARS2:
13644 4264 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can use it to capture a sign bit
     4266 0000     
13645               
13646 4268 028E  22        ci   rx,>02*256                 ; CPX #2            ; If X >= 2 then the C flag is set
     426A 0200     
13647               
13648 426C 06A0  32        bl   @rora                      ; ROR A             ; Roll the C flag into the sign bit of A and store in
     426E FE62     
13649 4270 D80D  30        movb ra,@RAT                    ; STA RAT           ; RAT, so:
     4272 00AA     
13650                                                                          ;
13651                                                                          ; * Left view, C is clear so RAT = 0 (positive)
13652                                                                          ;
13653                                                                          ; * Right view, C is set so RAT = 128 (negative)
13654                                                                          ;
13655                                                                          ; RAT represents the end of the x-axis where we want new
13656                                                                          ; stardust particles to come from: positive for the left
13657                                                                          ; view where new particles come in from the right,
13658                                                                          ; negative for the right view where new particles come
13659                                                                          ; in from the left
13660               
13661                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT2 to the opposite sign, so:
     **** ****     > EOI
0001 4274 0200  20        li   rtmp,(>80*256)
     4276 8000     
0002 4278 2B40  18        xor  rtmp,ra
                   < elite.a99
13662 427A D80D  30        movb ra,@RAT2                   ; STA RAT2          ;
     427C 00AB     
13663                                                                          ; * Left view, RAT2 = 128 (negative)
13664                                                                          ;
13665                                                                          ; * Right view, RAT2 = 0 (positive)
13666                                                                          ;
13667                                                                          ; RAT2 represents the direction in which stardust
13668                                                                          ; particles should move along the x-axis: negative for
13669                                                                          ; the left view where particles go from right to left,
13670                                                                          ; positive for the right view where particles go from
13671                                                                          ; left to right
13672               
13673 427E 0200  20        li   rtmp,ST2                   ; JSR ST2           ; Call ST2 to flip the signs of the following if this is
     4280 43F8     
13674 4282 06A0  32        bl   @jsr                       ;
     4284 FE28     
13675                                                                          ; the right view: ALPHA, ALP2, ALP2+1, BET2 and BET2+1
13676               
13677 4286 D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     4288 0F33     
13678                                                                          ; we can use it as a counter through all the stardust
13679               
13680               STL2:
13681 428A 06CF  14        swpb ry                         ;
13682 428C D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Set A = ZZ = z_hi
     428E 0EE8     
13683 4290 06CF  14        swpb ry                         ;
13684               
13685 4292 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; We also set ZZ to the original value of z_hi, which we
     4294 0097     
13686                                                                          ; use below to remove the existing particle
13687               
13688 4296 091D  18        srl  ra,1                       ; LSR A             ; Set A = z_hi / 8
13689 4298 091D  18        srl  ra,1                       ; LSR A
13690 429A 091D  18        srl  ra,1                       ; LSR A
13691               
13692 429C 0200  20        li   rtmp,DV41                  ; JSR DV41          ; Call DV41 to set the following:
     429E 4954     
13693 42A0 06A0  32        bl   @jsr                       ;
     42A2 FE28     
13694                                                                          ;
13695                                                                          ; (P R) = 256 * DELTA / A
13696                                                                          ; = 256 * speed / (z_hi / 8)
13697                                                                          ; = 8 * 256 * speed / z_hi
13698                                                                          ;
13699                                                                          ; This represents the distance we should move this
13700                                                                          ; particle along the x-axis, let's call it delta_x
13701               
13702 42A4 D360  30        movb @P,ra                      ; LDA P             ; Set S = P but with the sign from RAT2, so we now have
     42A6 001B     
13703                      .eor @RAT2                      ; EOR RAT2          ; the distance delta_x with the correct sign in (S R):
     **** ****     > EOR
0001 42A8 D020  30        movb @RAT2,rtmp
     42AA 00AB     
0002 42AC 2B40  18        xor  rtmp,ra
                   < elite.a99
13704 42AE D80D  30        movb ra,@S                      ; STA S             ;
     42B0 0092     
13705                                                                          ; (S R) = delta_x
13706                                                                          ; = 8 * 256 * speed / z_hi
13707                                                                          ;
13708                                                                          ; So (S R) is the delta, signed to match the direction
13709                                                                          ; the stardust should move in, which is result 1 above
13710               
13711 42B2 06CF  14        swpb ry                         ;
13712 42B4 D36F  34        movb @SXL(ry),ra                ; LDA SXL,Y         ; Set (A P) = (x_hi x_lo)
     42B6 035F     
13713 42B8 06CF  14        swpb ry                         ;
13714 42BA D80D  30        movb ra,@P                      ; STA P             ; = x
     42BC 001B     
13715 42BE 06CF  14        swpb ry                         ;
13716 42C0 D36F  34        movb @SX(ry),ra                 ; LDA SX,Y
     42C2 034C     
13717 42C4 06CF  14        swpb ry                         ;
13718               
13719 42C6 D80D  30        movb ra,@X1                     ; STA X1            ; Set X1 = A, so X1 contains the original value of x_hi,
     42C8 0031     
13720                                                                          ; which we use below to remove the existing particle
13721               
13722 42CA 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     42CC 4862     
13723 42CE 06A0  32        bl   @jsr                       ;
     42D0 FE28     
13724                                                                          ;
13725                                                                          ; (A X) = (A P) + (S R)
13726                                                                          ; = x + delta_x
13727               
13728 42D2 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     42D4 0092     
13729 42D6 D80E  30        movb rx,@R                      ; STX R             ; = x + delta_x
     42D8 0091     
13730               
13731 42DA 06CF  14        swpb ry                         ;
13732 42DC D36F  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set A = y_hi
     42DE 0EC2     
13733 42E0 06CF  14        swpb ry                         ;
13734               
13735 42E2 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 = A, so Y1 contains the original value of y_hi,
     42E4 0032     
13736                                                                          ; which we use below to remove the existing particle
13737               
13738                      .eor @BET2                      ; EOR BET2          ; Give A the correct sign of A * beta, i.e. y_hi * beta
     **** ****     > EOR
0001 42E6 D020  30        movb @BET2,rtmp
     42E8 008A     
0002 42EA 2B40  18        xor  rtmp,ra
                   < elite.a99
13739               
13740 42EC D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     42EE 002B     
13741               
13742 42F0 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     42F2 4588     
13743 42F4 06A0  32        bl   @jsr                       ;
     42F6 FE28     
13744                                                                          ;
13745                                                                          ; (A P) = X * A
13746                                                                          ; = beta * y_hi
13747               
13748 42F8 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     42FA 4862     
13749 42FC 06A0  32        bl   @jsr                       ;
     42FE FE28     
13750                                                                          ;
13751                                                                          ; (A X) = (A P) + (S R)
13752                                                                          ; = beta * y + x + delta_x
13753               
13754 4300 D80E  30        movb rx,@XX                     ; STX XX            ; Set XX(1 0) = (A X), which gives us results 2 and 3
     4302 0024     
13755 4304 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; above, done at the same time:
     4306 0025     
13756                                                                          ;
13757                                                                          ; x = x + delta_x + beta * y
13758               
13759 4308 06CF  14        swpb ry                         ;
13760 430A D3AF  34        movb @SYL(ry),rx                ; LDX SYL,Y         ; Set (S R) = (y_hi y_lo)
     430C 0ED5     
13761 430E 06CF  14        swpb ry                         ;
13762 4310 D80E  30        movb rx,@R                      ; STX R             ; = y
     4312 0091     
13763 4314 D3A0  30        movb @Y1,rx                     ; LDX Y1
     4316 0032     
13764 4318 D80E  30        movb rx,@S                      ; STX S
     431A 0092     
13765               
13766 431C D3A0  30        movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle
     431E 002B     
13767               
13768                      .eor @BET2+1                    ; EOR BET2+1        ; Give A the opposite sign to x * beta
     **** ****     > EOR
0001 4320 D020  30        movb @BET2+1,rtmp
     4322 008B     
0002 4324 2B40  18        xor  rtmp,ra
                   < elite.a99
13769               
13770 4326 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     4328 4588     
13771 432A 06A0  32        bl   @jsr                       ;
     432C FE28     
13772                                                                          ;
13773                                                                          ; (A P) = X * A
13774                                                                          ; = -beta * x
13775               
13776 432E 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Call ADD to calculate:
     4330 4862     
13777 4332 06A0  32        bl   @jsr                       ;
     4334 FE28     
13778                                                                          ;
13779                                                                          ; (A X) = (A P) + (S R)
13780                                                                          ; = -beta * x + y
13781               
13782 4336 D80E  30        movb rx,@YY                     ; STX YY            ; Set YY(1 0) = (A X), which gives us result 4 above:
     4338 0026     
13783 433A D80D  30        movb ra,@YY+1                   ; STA YY+1          ;
     433C 0027     
13784                                                                          ; y = y - beta * x
13785               
13786 433E D3A0  30        movb @ALP1,rx                   ; LDX ALP1          ; Set X = |alpha| from ALP2, the roll angle
     4340 0087     
13787               
13788                      .eor @ALP2                      ; EOR ALP2          ; Give A the correct sign of A * alpha, i.e. y_hi *
     **** ****     > EOR
0001 4342 D020  30        movb @ALP2,rtmp
     4344 0088     
0002 4346 2B40  18        xor  rtmp,ra
                   < elite.a99
13789                                                                          ; alpha
13790               
13791 4348 0200  20        li   rtmp,MULTS-2               ; JSR MULTS-2       ; Call MULTS-2 to calculate:
     434A 4588     
13792 434C 06A0  32        bl   @jsr                       ;
     434E FE28     
13793                                                                          ;
13794                                                                          ; (A P) = X * A
13795                                                                          ; = alpha * y
13796               
13797 4350 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = high byte of alpha * y
     4352 0090     
13798               
13799 4354 D360  30        movb @XX,ra                     ; LDA XX            ; Set (S R) = XX(1 0)
     4356 0024     
13800 4358 D80D  30        movb ra,@R                      ; STA R             ; = x
     435A 0091     
13801 435C D360  30        movb @XX+1,ra                   ; LDA XX+1          ;
     435E 0025     
13802 4360 D80D  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     4362 0092     
13803               
13804                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A = -x_hi
     **** ****     > EOI
0001 4364 0200  20        li   rtmp,(>80*256)
     4366 8000     
0002 4368 2B40  18        xor  rtmp,ra
                   < elite.a99
13805               
13806 436A 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     436C 485A     
13807 436E 06A0  32        bl   @jsr                       ;
     4370 FE28     
13808                                                                          ;
13809                                                                          ; (A X) = Q * A + (S R)
13810                                                                          ; = alpha * y * -x + x
13811               
13812 4372 D80D  30        movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1
     4374 0025     
13813               
13814 4376 D34E  18        movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
13815 4378 06CF  14        swpb ry                         ;
13816 437A DBCD  38        movb ra,@SXL(ry)                ; STA SXL,Y
     437C 035F     
13817 437E 06CF  14        swpb ry                         ;
13818               
13819                                                                          ; So (XX+1 x_lo) now contains result 5 above:
13820                                                                          ;
13821                                                                          ; x = x - alpha * x * y
13822               
13823 4380 D360  30        movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0)
     4382 0026     
13824 4384 D80D  30        movb ra,@R                      ; STA R             ; = y
     4386 0091     
13825 4388 D360  30        movb @YY+1,ra                   ; LDA YY+1          ;
     438A 0027     
13826 438C D80D  30        movb ra,@S                      ; STA S             ; and set A = y_hi at the same time
     438E 0092     
13827               
13828 4390 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Call MAD to calculate:
     4392 485A     
13829 4394 06A0  32        bl   @jsr                       ;
     4396 FE28     
13830                                                                          ;
13831                                                                          ; (A X) = Q * A + (S R)
13832                                                                          ; = alpha * y * y_hi + y
13833               
13834 4398 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     439A 0092     
13835 439C D80E  30        movb rx,@R                      ; STX R             ; = y + alpha * y * y
     439E 0091     
13836               
13837 43A0 020D  20        li   ra,>00*256                 ; LDA #0            ; Set P = 0
     43A2 0000     
13838 43A4 D80D  30        movb ra,@P                      ; STA P
     43A6 001B     
13839               
13840 43A8 D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha, so:
     43AA 009E     
13841                                                                          ;
13842                                                                          ; (A P) = (alpha 0)
13843                                                                          ; = alpha / 256
13844               
13845 43AC 0200  20        li   rtmp,PIX1                  ; JSR PIX1          ; Call PIX1 to calculate the following:
     43AE 290E     
13846 43B0 06A0  32        bl   @jsr                       ;
     43B2 FE28     
13847                                                                          ;
13848                                                                          ; (YY+1 y_lo) = (A P) + (S R)
13849                                                                          ; = alpha * 256 + y + alpha * y * y
13850                                                                          ;
13851                                                                          ; i.e. y = y + alpha / 256 + alpha * y^2, which is
13852                                                                          ; result 6 above
13853                                                                          ;
13854                                                                          ; PIX1 also draws a particle at (X1, Y1) with distance
13855                                                                          ; ZZ, which will remove the old stardust particle, as we
13856                                                                          ; set X1, Y1 and ZZ to the original values for this
13857                                                                          ; particle during the calculations above
13858               
13859                                                                          ; We now have our newly moved stardust particle at
13860                                                                          ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
13861                                                                          ; and distance z_hi, so we draw it if it's still on
13862                                                                          ; screen, otherwise we recycle it as a new bit of
13863                                                                          ; stardust and draw that
13864               
13865 43B4 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
     43B6 0025     
13866 43B8 06CF  14        swpb ry                         ;
13867 43BA DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; the new x-coordinate is in (x_hi x_lo) and the high
     43BC 034C     
13868 43BE 06CF  14        swpb ry                         ;
13869 43C0 D80D  30        movb ra,@X1                     ; STA X1            ; byte is in X1
     43C2 0031     
13870               
13871 43C4 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 116 then jump to KILL2 to recycle this
     43C6 7F00     
13872 43C8 028D  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the side of the screen,
     43CA 7400     
13873 43CC 1836  14        joc  KILL2                      ; BCS KILL2         ; and rejoin at STC2 with the new particle
13874               
13875 43CE D360  30        movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
     43D0 0027     
13876 43D2 06CF  14        swpb ry                         ;
13877 43D4 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
     43D6 0EC2     
13878 43D8 06CF  14        swpb ry                         ;
13879 43DA D80D  30        movb ra,@Y1                     ; STA Y1            ; byte is in Y1
     43DC 0032     
13880               
13881 43DE 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 116 then jump to ST5 to recycle this
     43E0 7F00     
13882 43E2 028D  22        ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the top or bottom of the
     43E4 7400     
13883 43E6 183E  14        joc  ST5                        ; BCS ST5           ; screen, and rejoin at STC2 with the new particle
13884               
13885               STC2:
13886 43E8 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
     43EA 2924     
13887 43EC 06A0  32        bl   @jsr                       ;
     43EE FE28     
13888                                                                          ; i.e. draw the newly moved particle at (x_hi, y_hi)
13889                                                                          ; with distance z_hi
13890               
13891 43F0 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
13892                                                                          ; stardust particle
13893               
13894 43F2 1302  14        jeq  ST2                        ; BEQ ST2           ; If we have just done the last particle, skip the next
13895                                                                          ; instruction to return from the subroutine
13896               
13897 43F4 0460  28        b    @STL2                      ; JMP STL2          ; We have more stardust to process, so jump back up to
     43F6 428A     
13898                                                                          ; STL2 for the next particle
13899               
13900                                                                          ; Fall through into ST2 to restore the signs of the
13901                                                                          ; following if this is the right view: ALPHA, ALP2,
13902                                                                          ; ALP2+1, BET2 and BET2+1
13903               
13904               ST2:
13905 43F8 D360  30        movb @ALPHA,ra                  ; LDA ALPHA         ; If this is the right view, flip the sign of ALPHA
     43FA 009E     
13906                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 43FC D020  30        movb @RAT,rtmp
     43FE 00AA     
0002 4400 2B40  18        xor  rtmp,ra
                   < elite.a99
13907 4402 D80D  30        movb ra,@ALPHA                  ; STA ALPHA
     4404 009E     
13908               
13909 4406 D360  30        movb @ALP2,ra                   ; LDA ALP2          ; If this is the right view, flip the sign of ALP2
     4408 0088     
13910                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 440A D020  30        movb @RAT,rtmp
     440C 00AA     
0002 440E 2B40  18        xor  rtmp,ra
                   < elite.a99
13911 4410 D80D  30        movb ra,@ALP2                   ; STA ALP2
     4412 0088     
13912               
13913                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of ALP2+1
     **** ****     > EOI
0001 4414 0200  20        li   rtmp,(>80*256)
     4416 8000     
0002 4418 2B40  18        xor  rtmp,ra
                   < elite.a99
13914 441A D80D  30        movb ra,@ALP2+1                 ; STA ALP2+1
     441C 0089     
13915               
13916 441E D360  30        movb @BET2,ra                   ; LDA BET2          ; If this is the right view, flip the sign of BET2
     4420 008A     
13917                      .eor @RAT                       ; EOR RAT
     **** ****     > EOR
0001 4422 D020  30        movb @RAT,rtmp
     4424 00AA     
0002 4426 2B40  18        xor  rtmp,ra
                   < elite.a99
13918 4428 D80D  30        movb ra,@BET2                   ; STA BET2
     442A 008A     
13919               
13920                      .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of BET2+1
     **** ****     > EOI
0001 442C 0200  20        li   rtmp,(>80*256)
     442E 8000     
0002 4430 2B40  18        xor  rtmp,ra
                   < elite.a99
13921 4432 D80D  30        movb ra,@BET2+1                 ; STA BET2+1
     4434 008B     
13922               
13923 4436 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4438 FE34     
13924               
13925               KILL2:
13926 443A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     443C C7D0     
13927 443E 06A0  32        bl   @jsr                       ;
     4440 FE28     
13928               
13929 4442 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
     4444 0032     
13930 4446 06CF  14        swpb ry                         ;
13931 4448 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along the y-axis
     444A 0EC2     
13932 444C 06CF  14        swpb ry                         ;
13933               
13934 444E 020D  20        li   ra,>73*256                 ; LDA #115          ; Make sure A is at least 115 and has the sign in RAT
     4450 7300     
13935 4452 F360  30        socb @RAT,ra                    ; ORA RAT
     4454 00AA     
13936               
13937 4456 D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on the
     4458 0031     
13938 445A 06CF  14        swpb ry                         ;
13939 445C DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; correct edge of the screen for new particles
     445E 034C     
13940 4460 06CF  14        swpb ry                         ;
13941               
13942 4462 1614  14        jne  STF1                       ; BNE STF1          ; Jump down to STF1 to set the z-coordinate (this BNE is
13943                                                                          ; effectively a JMP as A will never be zero)
13944               
13945               ST5:
13946 4464 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     4466 C7D0     
13947 4468 06A0  32        bl   @jsr                       ;
     446A FE28     
13948               
13949 446C D80D  30        movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
     446E 0031     
13950 4470 06CF  14        swpb ry                         ;
13951 4472 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis
     4474 034C     
13952 4476 06CF  14        swpb ry                         ;
13953               
13954 4478 020D  20        li   ra,>6e*256                 ; LDA #110          ; Make sure A is at least 110 and has the sign in AL2+1,
     447A 6E00     
13955 447C F360  30        socb @ALP2+1,ra                 ; ORA ALP2+1        ; the flipped sign of the roll angle alpha
     447E 0089     
13956               
13957 4480 D80D  30        movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts at the
     4482 0032     
13958 4484 06CF  14        swpb ry                         ;
13959 4486 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; top or bottom edge, depending on the current roll
     4488 0EC2     
13960 448A 06CF  14        swpb ry                         ;
13961                                                                          ; angle alpha
13962               
13963               STF1:
13964 448C 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     448E C7D0     
13965 4490 06A0  32        bl   @jsr                       ;
     4492 FE28     
13966               
13967 4494 026D  22        ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in z_hi and
     4496 0800     
13968 4498 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; ZZ, so the new particle starts at any distance from
     449A 0097     
13969 449C 06CF  14        swpb ry                         ;
13970 449E DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; us, but not too close
     44A0 0EE8     
13971 44A2 06CF  14        swpb ry                         ;
13972               
13973 44A4 16A1  14        jne  STC2                       ; BNE STC2          ; Jump up to STC2 to draw this new particle (this BNE is
13974                                                                          ; effectively a JMP as A will never be zero)
13975               
13976               * ******************************************************************************
13977               *
13978               * Name: SNE
13979               * Type: Variable
13980               * Category: Maths (Geometry)
13981               * Summary: Sine/cosine table
13982               * Deep dive: The sine, cosine and arctan tables
13983               * Drawing circles
13984               * Drawing ellipses
13985               *
13986               * ------------------------------------------------------------------------------
13987               *
13988               * This lookup table contains sine values for the first half of a circle, from 0
13989               * to 180 degrees (0 to PI radians). In terms of circle or ellipse line segments,
13990               * there are 64 segments in a circle, so this contains sine values for segments
13991               * 0 to 31.
13992               *
13993               * In terms of segments, to calculate the sine of the angle at segment x, we look
13994               * up the value in SNE + x, and to calculate the cosine of the angle we look up
13995               * the value in SNE + ((x + 16) mod 32).
13996               *
13997               * In terms of radians, to calculate the following:
13998               *
13999               * sin(theta) * 256
14000               *
14001               * where theta is in radians, we look up the value in:
14002               *
14003               * SNE + (theta * 10)
14004               *
14005               * To calculate the following:
14006               *
14007               * cos(theta) * 256
14008               *
14009               * where theta is in radians, look up the value in:
14010               *
14011               * SNE + ((theta * 10) + 16) mod 32
14012               *
14013               * Theta must be between 0 and 3.1 radians, so theta * 10 is between 0 and 31.
14014               *
14015               * ******************************************************************************
14016               
14017               SNE:
14018                      ; FOR I%, 0, 31
14019               
14020                      ; N = ABS(SIN((I% / 64) * 2 * PI)) ;
14021               
14022                      ; IF N >= 1                     ;
14023                      ; B% = 255                      ;
14024                      ; ELSE                          ;
14025                      ; B% = INT(256 * N + 0.5)       ;
14026                      ; ENDIF                         ;
14027               
14028                      ; EQUB B%                       ;
14029               
14030                      ; NEXT
14031               
14032 44A6 00              byte >00
14033 44A7   19            byte >19
14034 44A8 32              byte >32
14035 44A9   4A            byte >4a
14036 44AA 62              byte >62
14037 44AB   79            byte >79
14038 44AC 8E              byte >8e
14039 44AD   A2            byte >a2
14040 44AE B5              byte >b5
14041 44AF   C6            byte >c6
14042 44B0 D5              byte >d5
14043 44B1   E2            byte >e2
14044 44B2 ED              byte >ed
14045 44B3   F5            byte >f5
14046 44B4 FB              byte >fb
14047 44B5   FF            byte >ff
14048 44B6 FF              byte >ff
14049 44B7   FF            byte >ff
14050 44B8 FB              byte >fb
14051 44B9   F5            byte >f5
14052 44BA ED              byte >ed
14053 44BB   E2            byte >e2
14054 44BC D5              byte >d5
14055 44BD   C6            byte >c6
14056 44BE B5              byte >b5
14057 44BF   A2            byte >a2
14058 44C0 8E              byte >8e
14059 44C1   79            byte >79
14060 44C2 62              byte >62
14061 44C3   4A            byte >4a
14062 44C4 32              byte >32
14063 44C5   19            byte >19
14064               
14065               * ******************************************************************************
14066               *
14067               * Name: MU5
14068               * Type: Subroutine
14069               * Category: Maths (Arithmetic)
14070               * Summary: Set K(3 2 1 0) = (A A A A) and clear the C flag
14071               *
14072               * ------------------------------------------------------------------------------
14073               *
14074               * In practice this is only called via a BEQ following an AND instruction, in
14075               * which case A = 0, so this routine effectively does this:
14076               *
14077               * K(3 2 1 0) = 0
14078               *
14079               * ******************************************************************************
14080               
14081               MU5:
14082 44C6 D80D  30        movb ra,@K                      ; STA K             ; Set K(3 2 1 0) to (A A A A)
     44C8 003D     
14083 44CA D80D  30        movb ra,@K+1                    ; STA K+1
     44CC 003E     
14084 44CE D80D  30        movb ra,@K+2                    ; STA K+2
     44D0 003F     
14085 44D2 D80D  30        movb ra,@K+3                    ; STA K+3
     44D4 0040     
14086               
14087                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 44D6 0A16  18        sla  rzero,1
                   < elite.a99
14088               
14089 44D8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     44DA FE34     
14090               
14091               * ******************************************************************************
14092               *
14093               * Name: MULT3
14094               * Type: Subroutine
14095               * Category: Maths (Arithmetic)
14096               * Summary: Calculate K(3 2 1 0) = (A P+1 P) * Q
14097               * Deep dive: Shift-and-add multiplication
14098               *
14099               * ------------------------------------------------------------------------------
14100               *
14101               * Calculate the following multiplication between a signed 24-bit number and a
14102               * signed 8-bit number, returning the result as a signed 32-bit number:
14103               *
14104               * K(3 2 1 0) = (A P+1 P) * Q
14105               *
14106               * The algorithm is the same shift-and-add algorithm as in routine MULT1, but
14107               * extended to cope with more bits.
14108               *
14109               * ------------------------------------------------------------------------------
14110               *
14111               * Returns:
14112               *
14113               * C flag              The C flag is cleared
14114               *
14115               * ******************************************************************************
14116               
14117               MULT3:
14118 44DC D80D  30        movb ra,@R                      ; STA R             ; Store the high byte of (A P+1 P) in R
     44DE 0091     
14119               
14120 44E0 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K+2 to |A|, the high byte of K(2 1 0)
     44E2 7F00     
14121 44E4 D80D  30        movb ra,@K+2                    ; STA K+2
     44E6 003F     
14122               
14123 44E8 D360  30        movb @Q,ra                      ; LDA Q             ; Set A to bits 0-6 of Q, so A = |Q|
     44EA 0090     
14124 44EC 024D  22        andi ra,>7f*256                 ; AND #%01111111
     44EE 7F00     
14125               
14126 44F0 13EA  14        jeq  MU5                        ; BEQ MU5           ; If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
14127                                                                          ; returning from the subroutine using a tail call
14128               
14129                      .sec                            ; SEC               ; Set T = |Q| - 1
     **** ****     > SEC
0001 44F2 0A18  18        sla  rmone,1
                   < elite.a99
14130                      .sbi (>01*256)                  ; SBC #1
     **** ****     > SBI
0001 44F4 1801  14        joc  !
0002 44F6 7347  18        sb   rone,ra
0003               !:
0004 44F8 022D  22        ai   ra,-(>01*256)
     44FA FF00     
                   < elite.a99
14131 44FC D80D  30        movb ra,@T                      ; STA T
     44FE 00D1     
14132               
14133                                                                          ; We now use the same shift-and-add algorithm as MULT1
14134                                                                          ; to calculate the following:
14135                                                                          ;
14136                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
14137                                                                          ;
14138                                                                          ; so we start with the first shift right, in which we
14139                                                                          ; take (K+2 P+1 P) and shift it right, storing the
14140                                                                          ; result in K(2 1 0), ready for the multiplication loop
14141                                                                          ; (so the multiplication loop actually calculates
14142                                                                          ; (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
14143                                                                          ; (|A| P+1 P) shifted right)
14144               
14145 4500 D360  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1
     4502 001C     
14146               
14147                      .lsr @K+2                       ; LSR K+2           ; Shift the high byte in K+2 to the right
     **** ****     > LSR
0001 4504 D020  30        movb @K+2,rtmp
     4506 003F     
0002 4508 0910  18        srl  rtmp,1
0003 450A D800  30        movb rtmp,@K+2
     450C 003F     
                   < elite.a99
14148               
14149 450E 06A0  32        bl   @rora                      ; ROR A             ; Shift the middle byte in A to the right and store in
     4510 FE62     
14150 4512 D80D  30        movb ra,@K+1                    ; STA K+1           ; K+1 (so K+1 contains P+1 shifted right)
     4514 003E     
14151               
14152 4516 D360  30        movb @P,ra                      ; LDA P             ; Shift the middle byte in P to the right and store in
     4518 001B     
14153 451A 06A0  32        bl   @rora                      ; ROR A             ; K, so K(2 1 0) now contains (|A| P+1 P) shifted right
     451C FE62     
14154 451E D80D  30        movb ra,@K                      ; STA K
     4520 003D     
14155               
14156                                                                          ; We now use the same shift-and-add algorithm as MULT1
14157                                                                          ; to calculate the following:
14158                                                                          ;
14159                                                                          ; K(2 1 0) = K(2 1 0) * |Q|
14160               
14161 4522 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4524 0000     
14162               
14163 4526 020E  20        li   rx,>18*256                 ; LDX #24           ; Set up a counter in X to count the 24 bits in K(2 1 0)
     4528 1800     
14164               
14165               MUL2:
14166 452A 1704  14        jnc  B38                        ; BCC B38           ; If C (i.e. the next bit from K) is set, do the
14167                      .adc @T,ra                      ; ADC T             ; addition for this bit of K:
     **** ****     > ADC
0001 452C 1701  14        jnc  !
0002 452E B347  18        ab   rone,ra
0003               !:
0004 4530 B360  30        ab   @T,ra
     4532 00D1     
                   < elite.a99
14168                                                                          ;
14169                                                                          ; A = A + T + C
14170                                                                          ; = A + |Q| - 1 + 1
14171                                                                          ; = A + |Q|
14172               
14173               B38:
14174 4534 06A0  32        bl   @rora                      ; ROR A             ; Shift A right by one place to catch the next digit
     4536 FE62     
14175 4538 0204  20        li   rarg1,K+2                  ; ROR K+2           ; next digit of our result in the left end of K(2 1 0),
     453A 003F     
14176 453C 06A0  32        bl   @ror                       ;
     453E FE7A     
14177 4540 0204  20        li   rarg1,K+1                  ; ROR K+1           ; while also shifting K(2 1 0) right to fetch the next
     4542 003E     
14178 4544 06A0  32        bl   @ror                       ;
     4546 FE7A     
14179 4548 0204  20        li   rarg1,K                    ; ROR K             ; bit for the calculation into the C flag
     454A 003D     
14180 454C 06A0  32        bl   @ror                       ;
     454E FE7A     
14181                                                                          ;
14182                                                                          ; On the last iteration of this loop, the bit falling
14183                                                                          ; off the end of K will be bit 0 of the original A, as
14184                                                                          ; we did one shift before the loop and we are doing 24
14185                                                                          ; iterations. We set A to 0 before looping, so this
14186                                                                          ; means the loop exits with the C flag clear
14187               
14188 4550 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14189               
14190 4552 16EB  14        jne  MUL2                       ; BNE MUL2          ; Loop back for the next bit until K(2 1 0) has been
14191                                                                          ; rotated all the way
14192               
14193                                                                          ; The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
14194                                                                          ; but it is positive and doesn't have the correct sign
14195                                                                          ; of the final result yet
14196               
14197 4554 D80D  30        movb ra,@T                      ; STA T             ; Save the high byte of the result into T
     4556 00D1     
14198               
14199 4558 D360  30        movb @R,ra                      ; LDA R             ; Fetch the sign byte from the original (A P+1 P)
     455A 0091     
14200                                                                          ; argument that we stored in R
14201               
14202                      .eor @Q                         ; EOR Q             ; EOR with Q so the sign bit is the same as that of
     **** ****     > EOR
0001 455C D020  30        movb @Q,rtmp
     455E 0090     
0002 4560 2B40  18        xor  rtmp,ra
                   < elite.a99
14203                                                                          ; (A P+1 P) * Q
14204               
14205 4562 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign bit
     4564 8000     
14206               
14207 4566 F360  30        socb @T,ra                      ; ORA T             ; Apply this to the high byte of the result in T, so
     4568 00D1     
14208                                                                          ; that A now has the correct sign for the result, and
14209                                                                          ; (A K+2 K+1 K) therefore contains the correctly signed
14210                                                                          ; result
14211               
14212 456A D80D  30        movb ra,@K+3                    ; STA K+3           ; Store A in K+3, so K(3 2 1 0) now contains the result
     456C 0040     
14213               
14214 456E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4570 FE34     
14215               
14216               * ******************************************************************************
14217               *
14218               * Name: MLS2
14219               * Type: Subroutine
14220               * Category: Maths (Arithmetic)
14221               * Summary: Calculate (S R) = XX(1 0) and (A P) = A * ALP1
14222               *
14223               * ------------------------------------------------------------------------------
14224               *
14225               * Calculate the following:
14226               *
14227               * (S R) = XX(1 0)
14228               *
14229               * (A P) = A * ALP1
14230               *
14231               * where ALP1 is the magnitude of the current roll angle alpha, in the range
14232               * 0-31.
14233               *
14234               * ******************************************************************************
14235               
14236               MLS2:
14237 4572 D3A0  30        movb @XX,rx                     ; LDX XX            ; Set (S R) = XX(1 0), starting with the low bytes
     4574 0024     
14238 4576 D80E  30        movb rx,@R                      ; STX R
     4578 0091     
14239               
14240 457A D3A0  30        movb @XX+1,rx                   ; LDX XX+1          ; And then doing the high bytes
     457C 0025     
14241 457E D80E  30        movb rx,@S                      ; STX S
     4580 0092     
14242               
14243                                                                          ; Fall through into MLS1 to calculate (A P) = A * ALP1
14244               
14245               * ******************************************************************************
14246               *
14247               * Name: MLS1
14248               * Type: Subroutine
14249               * Category: Maths (Arithmetic)
14250               * Summary: Calculate (A P) = ALP1 * A
14251               *
14252               * ------------------------------------------------------------------------------
14253               *
14254               * Calculate the following:
14255               *
14256               * (A P) = ALP1 * A
14257               *
14258               * where ALP1 is the magnitude of the current roll angle alpha, in the range
14259               * 0-31.
14260               *
14261               * This routine uses an unrolled version of MU11. MU11 calculates P * X, so we
14262               * use the same algorithm but with P set to ALP1 and X set to A. The unrolled
14263               * version here can skip the bit tests for bits 5-7 of P as we know P < 32, so
14264               * only 5 shifts with bit tests are needed (for bits 0-4), while the other 3
14265               * shifts can be done without a test (for bits 5-7).
14266               *
14267               * ------------------------------------------------------------------------------
14268               *
14269               * Other entry points:
14270               *
14271               * MULTS-2             Calculate (A P) = X * A
14272               *
14273               * ******************************************************************************
14274               
14275               MLS1:
14276 4582 D3A0  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P to the roll angle alpha magnitude in ALP1
     4584 0087     
14277 4586 D80E  30        movb rx,@P                      ; STX P             ; (0-31), so now we calculate P * A
     4588 001B     
14278               
14279               MULTS:
14280 458A D38D  18        movb ra,rx                      ; TAX               ; Set X = A, so now we can calculate P * X instead of
14281                                                                          ; P * A to get our result, and we can use the algorithm
14282                                                                          ; from MU11 to do that, just unrolled (as MU11 returns
14283                                                                          ; P * X)
14284               
14285 458C 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Set T to the sign bit of A
     458E 8000     
14286 4590 D80D  30        movb ra,@T                      ; STA T
     4592 00D1     
14287               
14288 4594 D34E  18        movb rx,ra                      ; TXA               ; Set A = |A|
14289 4596 024D  22        andi ra,>7f*256                 ; AND #127
     4598 7F00     
14290               
14291 459A 1602  14        jne  FIX003                     ; BNE FIX003        ; If A = 0, jump to MU6 to set P(1 0) = 0 and return
14292                                                                          ; from the subroutine using a tail call
14293 459C 0460  28        b    @MU6                       ; JMP MU6
     459E 46B2     
14294               FIX003:
14295 45A0 D38D  18        movb ra,rx                      ; TAX               ; Set T1 = X - 1
14296 45A2 7387  18        sb   rone,rx                    ; DEX               ;
14297 45A4 D80E  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     45A6 0006     
14298                                                                          ; to do an addition in the loop below
14299               
14300 45A8 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     45AA 0000     
14301               
14302                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 45AC D020  30        movb @P,rtmp
     45AE 001B     
0002 45B0 0910  18        srl  rtmp,1
0003 45B2 D800  30        movb rtmp,@P
     45B4 001B     
                   < elite.a99
14303                                                                          ; and C flag = bit 0 of P
14304               
14305                                                                          ; We are now going to work our way through the bits of
14306                                                                          ; P, and do a shift-add for any bits that are set,
14307                                                                          ; keeping the running total in A, but instead of using a
14308                                                                          ; loop like MU11, we just unroll it, starting with bit 0
14309               
14310 45B6 1704  14        jnc  B39                        ; BCC B39           ; If C (i.e. the next bit from P) is set, do the
14311                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 45B8 1701  14        jnc  !
0002 45BA B347  18        ab   rone,ra
0003               !:
0004 45BC B360  30        ab   @T1,ra
     45BE 0006     
                   < elite.a99
14312                                                                          ;
14313                                                                          ; A = A + T1 + C
14314                                                                          ; = A + X - 1 + 1
14315                                                                          ; = A + X
14316               
14317               B39:
14318 45C0 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     45C2 FE62     
14319                                                                          ; which the next ROR sticks into the left end of P while
14320                                                                          ; also extracting the next bit of P
14321               
14322 45C4 0204  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     45C6 001B     
14323 45C8 06A0  32        bl   @ror                       ;
     45CA FE7A     
14324                                                                          ; the start of P, and shift P right to fetch the next
14325                                                                          ; bit for the calculation into the C flag
14326               
14327 45CC 1704  14        jnc  B40                        ; BCC B40           ; Repeat the shift-and-add loop for bit 1
14328                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 45CE 1701  14        jnc  !
0002 45D0 B347  18        ab   rone,ra
0003               !:
0004 45D2 B360  30        ab   @T1,ra
     45D4 0006     
                   < elite.a99
14329               B40:
14330 45D6 06A0  32        bl   @rora                      ; ROR A
     45D8 FE62     
14331 45DA 0204  20        li   rarg1,P                    ; ROR P
     45DC 001B     
14332 45DE 06A0  32        bl   @ror                       ;
     45E0 FE7A     
14333               
14334 45E2 1704  14        jnc  B41                        ; BCC B41           ; Repeat the shift-and-add loop for bit 2
14335                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 45E4 1701  14        jnc  !
0002 45E6 B347  18        ab   rone,ra
0003               !:
0004 45E8 B360  30        ab   @T1,ra
     45EA 0006     
                   < elite.a99
14336               B41:
14337 45EC 06A0  32        bl   @rora                      ; ROR A
     45EE FE62     
14338 45F0 0204  20        li   rarg1,P                    ; ROR P
     45F2 001B     
14339 45F4 06A0  32        bl   @ror                       ;
     45F6 FE7A     
14340               
14341 45F8 1704  14        jnc  B42                        ; BCC B42           ; Repeat the shift-and-add loop for bit 3
14342                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 45FA 1701  14        jnc  !
0002 45FC B347  18        ab   rone,ra
0003               !:
0004 45FE B360  30        ab   @T1,ra
     4600 0006     
                   < elite.a99
14343               B42:
14344 4602 06A0  32        bl   @rora                      ; ROR A
     4604 FE62     
14345 4606 0204  20        li   rarg1,P                    ; ROR P
     4608 001B     
14346 460A 06A0  32        bl   @ror                       ;
     460C FE7A     
14347               
14348 460E 1704  14        jnc  B43                        ; BCC B43           ; Repeat the shift-and-add loop for bit 4
14349                      .adc @T1,ra                     ; ADC T1
     **** ****     > ADC
0001 4610 1701  14        jnc  !
0002 4612 B347  18        ab   rone,ra
0003               !:
0004 4614 B360  30        ab   @T1,ra
     4616 0006     
                   < elite.a99
14350               B43:
14351 4618 06A0  32        bl   @rora                      ; ROR A
     461A FE62     
14352 461C 0204  20        li   rarg1,P                    ; ROR P
     461E 001B     
14353 4620 06A0  32        bl   @ror                       ;
     4622 FE7A     
14354               
14355 4624 091D  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 5
14356 4626 0204  20        li   rarg1,P                    ; ROR P
     4628 001B     
14357 462A 06A0  32        bl   @ror                       ;
     462C FE7A     
14358               
14359 462E 091D  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 6
14360 4630 0204  20        li   rarg1,P                    ; ROR P
     4632 001B     
14361 4634 06A0  32        bl   @ror                       ;
     4636 FE7A     
14362               
14363 4638 091D  18        srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 7
14364 463A 0204  20        li   rarg1,P                    ; ROR P
     463C 001B     
14365 463E 06A0  32        bl   @ror                       ;
     4640 FE7A     
14366               
14367 4642 F360  30        socb @T,ra                      ; ORA T             ; Give A the sign bit of the original argument A that
     4644 00D1     
14368                                                                          ; we put into T above
14369               
14370 4646 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4648 FE34     
14371               
14372               * ******************************************************************************
14373               *
14374               * Name: SQUA
14375               * Type: Subroutine
14376               * Category: Maths (Arithmetic)
14377               * Summary: Clear bit 7 of A and calculate (A P) = A * A
14378               *
14379               * ------------------------------------------------------------------------------
14380               *
14381               * Do the following multiplication of unsigned 8-bit numbers, after first
14382               * clearing bit 7 of A:
14383               *
14384               * (A P) = A * A
14385               *
14386               * ******************************************************************************
14387               
14388               SQUA:
14389 464A 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 of A and fall through into SQUA2 to set
     464C 7F00     
14390                                                                          ; (A P) = A * A
14391               
14392               * ******************************************************************************
14393               *
14394               * Name: SQUA2
14395               * Type: Subroutine
14396               * Category: Maths (Arithmetic)
14397               * Summary: Calculate (A P) = A * A
14398               *
14399               * ------------------------------------------------------------------------------
14400               *
14401               * Do the following multiplication of unsigned 8-bit numbers:
14402               *
14403               * (A P) = A * A
14404               *
14405               * ******************************************************************************
14406               
14407               SQUA2:
14408 464E D80D  30        movb ra,@P                      ; STA P             ; Copy A into P and X
     4650 001B     
14409 4652 D38D  18        movb ra,rx                      ; TAX
14410               
14411 4654 1613  14        jne  MU11                       ; BNE MU11          ; If X = 0 fall through into MU1 to return a 0,
14412                                                                          ; otherwise jump to MU11 to return P * X
14413               
14414               * ******************************************************************************
14415               *
14416               * Name: MU1
14417               * Type: Subroutine
14418               * Category: Maths (Arithmetic)
14419               * Summary: Copy X into P and A, and clear the C flag
14420               *
14421               * ------------------------------------------------------------------------------
14422               *
14423               * Used to return a 0 result quickly from MULTU below.
14424               *
14425               * ******************************************************************************
14426               
14427               MU1:
14428                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 4656 0A16  18        sla  rzero,1
                   < elite.a99
14429               
14430 4658 D80E  30        movb rx,@P                      ; STX P             ; Copy X into P and A
     465A 001B     
14431 465C D34E  18        movb rx,ra                      ; TXA
14432               
14433 465E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4660 FE34     
14434               
14435               * ******************************************************************************
14436               *
14437               * Name: MLU1
14438               * Type: Subroutine
14439               * Category: Maths (Arithmetic)
14440               * Summary: Calculate Y1 = y_hi and (A P) = |y_hi| * Q for Y-th stardust
14441               *
14442               * ------------------------------------------------------------------------------
14443               *
14444               * Do the following assignment, and multiply the Y-th stardust particle's
14445               * y-coordinate with an unsigned number Q:
14446               *
14447               * Y1 = y_hi
14448               *
14449               * (A P) = |y_hi| * Q
14450               *
14451               * ******************************************************************************
14452               
14453               MLU1:
14454 4662 06CF  14        swpb ry                         ;
14455 4664 D36F  34        movb @SY(ry),ra                 ; LDA SY,Y          ; Set Y1 the Y-th byte of SY
     4666 0EC2     
14456 4668 06CF  14        swpb ry                         ;
14457 466A D80D  30        movb ra,@Y1                     ; STA Y1
     466C 0032     
14458               
14459                                                                          ; Fall through into MLU2 to calculate:
14460                                                                          ;
14461                                                                          ; (A P) = |A| * Q
14462               
14463               * ******************************************************************************
14464               *
14465               * Name: MLU2
14466               * Type: Subroutine
14467               * Category: Maths (Arithmetic)
14468               * Summary: Calculate (A P) = |A| * Q
14469               *
14470               * ------------------------------------------------------------------------------
14471               *
14472               * Do the following multiplication of a sign-magnitude 8-bit number P with an
14473               * unsigned number Q:
14474               *
14475               * (A P) = |A| * Q
14476               *
14477               * ******************************************************************************
14478               
14479               MLU2:
14480 466E 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit in P, so P = |A|
     4670 7F00     
14481 4672 D80D  30        movb ra,@P                      ; STA P
     4674 001B     
14482               
14483                                                                          ; Fall through into MULTU to calculate:
14484                                                                          ;
14485                                                                          ; (A P) = P * Q
14486                                                                          ; = |A| * Q
14487               
14488               * ******************************************************************************
14489               *
14490               * Name: MULTU
14491               * Type: Subroutine
14492               * Category: Maths (Arithmetic)
14493               * Summary: Calculate (A P) = P * Q
14494               *
14495               * ------------------------------------------------------------------------------
14496               *
14497               * Do the following multiplication of unsigned 8-bit numbers:
14498               *
14499               * (A P) = P * Q
14500               *
14501               * ******************************************************************************
14502               
14503               MULTU:
14504 4676 D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X = Q
     4678 0090     
14505               
14506 467A 13ED  14        jeq  MU1                        ; BEQ MU1           ; If X = Q = 0, jump to MU1 to copy X into P and A,
14507                                                                          ; clear the C flag and return from the subroutine using
14508                                                                          ; a tail call
14509               
14510                                                                          ; Otherwise fall through into MU11 to set (A P) = P * X
14511               
14512               * ******************************************************************************
14513               *
14514               * Name: MU11
14515               * Type: Subroutine
14516               * Category: Maths (Arithmetic)
14517               * Summary: Calculate (A P) = P * X
14518               * Deep dive: Shift-and-add multiplication
14519               *
14520               * ------------------------------------------------------------------------------
14521               *
14522               * Do the following multiplication of two unsigned 8-bit numbers:
14523               *
14524               * (A P) = P * X
14525               *
14526               * This uses the same shift-and-add approach as MULT1, but it's simpler as we
14527               * are dealing with unsigned numbers in P and X. See the deep dive on
14528               * "Shift-and-add multiplication" for a discussion of how this algorithm works.
14529               *
14530               * ******************************************************************************
14531               
14532               MU11:
14533 467C 7387  18        sb   rone,rx                    ; DEX               ; Set T = X - 1
14534 467E D80E  30        movb rx,@T                      ; STX T             ;
     4680 00D1     
14535                                                                          ; We subtract 1 as the C flag will be set when we want
14536                                                                          ; to do an addition in the loop below
14537               
14538 4682 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     4684 0000     
14539               
14540 4686 020E  20        li   rx,>08*256                 ; LDX #8            ; Set up a counter in X to count the 8 bits in P
     4688 0800     
14541               
14542                      .lsr @P                         ; LSR P             ; Set P = P >> 1
     **** ****     > LSR
0001 468A D020  30        movb @P,rtmp
     468C 001B     
0002 468E 0910  18        srl  rtmp,1
0003 4690 D800  30        movb rtmp,@P
     4692 001B     
                   < elite.a99
14543                                                                          ; and C flag = bit 0 of P
14544               
14545                                                                          ; We are now going to work our way through the bits of
14546                                                                          ; P, and do a shift-add for any bits that are set,
14547                                                                          ; keeping the running total in A. We just did the first
14548                                                                          ; shift right, so we now need to do the first add and
14549                                                                          ; loop through the other bits in P
14550               
14551               MUL6:
14552 4694 1704  14        jnc  B44                        ; BCC B44           ; If C (i.e. the next bit from P) is set, do the
14553                      .adc @T,ra                      ; ADC T             ; addition for this bit of P:
     **** ****     > ADC
0001 4696 1701  14        jnc  !
0002 4698 B347  18        ab   rone,ra
0003               !:
0004 469A B360  30        ab   @T,ra
     469C 00D1     
                   < elite.a99
14554                                                                          ;
14555                                                                          ; A = A + T + C
14556                                                                          ; = A + X - 1 + 1
14557                                                                          ; = A + X
14558               
14559               B44:
14560 469E 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result,
     46A0 FE62     
14561                                                                          ; which the next ROR sticks into the left end of P while
14562                                                                          ; also extracting the next bit of P
14563               
14564 46A2 0204  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     46A4 001B     
14565 46A6 06A0  32        bl   @ror                       ;
     46A8 FE7A     
14566                                                                          ; the start of P, and shift P right to fetch the next
14567                                                                          ; bit for the calculation into the C flag
14568               
14569 46AA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14570               
14571 46AC 16F3  14        jne  MUL6                       ; BNE MUL6          ; Loop back for the next bit until P has been rotated
14572                                                                          ; all the way
14573               
14574 46AE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     46B0 FE34     
14575               
14576               * ******************************************************************************
14577               *
14578               * Name: MU6
14579               * Type: Subroutine
14580               * Category: Maths (Arithmetic)
14581               * Summary: Set P(1 0) = (A A)
14582               *
14583               * ------------------------------------------------------------------------------
14584               *
14585               * In practice this is only called via a BEQ following an AND instruction, in
14586               * which case A = 0, so this routine effectively does this:
14587               *
14588               * P(1 0) = 0
14589               *
14590               * ******************************************************************************
14591               
14592               MU6:
14593 46B2 D80D  30        movb ra,@P+1                    ; STA P+1           ; Set P(1 0) = (A A)
     46B4 001C     
14594 46B6 D80D  30        movb ra,@P                      ; STA P
     46B8 001B     
14595               
14596 46BA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     46BC FE34     
14597               
14598               * ******************************************************************************
14599               *
14600               * Name: FMLTU2
14601               * Type: Subroutine
14602               * Category: Maths (Arithmetic)
14603               * Summary: Calculate A = K * sin(A)
14604               * Deep dive: The sine, cosine and arctan tables
14605               *
14606               * ------------------------------------------------------------------------------
14607               *
14608               * Calculate the following:
14609               *
14610               * A = K * sin(A)
14611               *
14612               * Because this routine uses the sine lookup table SNE, we can also call this
14613               * routine to calculate cosine multiplication. To calculate the following:
14614               *
14615               * A = K * cos(B)
14616               *
14617               * call this routine with B + 16 in the accumulator, as sin(B + 16) = cos(B).
14618               *
14619               * ******************************************************************************
14620               
14621               FMLTU2:
14622 46BE 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; Restrict A to bits 0-5 (so it's in the range 0-31)
     46C0 1F00     
14623               
14624 46C2 D38D  18        movb ra,rx                      ; TAX               ; Set Q = sin(A) * 256
14625 46C4 06CE  14        swpb rx                         ;
14626 46C6 D36E  34        movb @SNE(rx),ra                ; LDA SNE,X
     46C8 44A6     
14627 46CA 06CE  14        swpb rx                         ;
14628 46CC D80D  30        movb ra,@Q                      ; STA Q
     46CE 0090     
14629               
14630 46D0 D360  30        movb @K,ra                      ; LDA K             ; Set A to the radius in K
     46D2 003D     
14631               
14632                                                                          ; Fall through into FMLTU to do the following:
14633                                                                          ;
14634                                                                          ; (A ?) = A * Q
14635                                                                          ; = K * sin(A) * 256
14636                                                                          ;
14637                                                                          ; which is equivalent to:
14638                                                                          ;
14639                                                                          ; A = K * sin(A)
14640               
14641               * ******************************************************************************
14642               *
14643               * Name: FMLTU
14644               * Type: Subroutine
14645               * Category: Maths (Arithmetic)
14646               * Summary: Calculate A = A * Q / 256
14647               *
14648               * ------------------------------------------------------------------------------
14649               *
14650               * Do the following multiplication of two unsigned 8-bit numbers, returning only
14651               * the high byte of the result:
14652               *
14653               * (A ?) = A * Q
14654               *
14655               * or, to put it another way:
14656               *
14657               * A = A * Q / 256
14658               *
14659               * ------------------------------------------------------------------------------
14660               *
14661               * Returns:
14662               *
14663               * C flag              The C flag is set
14664               *
14665               * ******************************************************************************
14666               
14667               FMLTU:
14668                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A, set the C flag and rotate right,
     **** ****     > EOI
0001 46D4 0200  20        li   rtmp,(>FF*256)
     46D6 FF00     
0002 46D8 2B40  18        xor  rtmp,ra
                   < elite.a99
14669                      .sec                            ; SEC               ; so the C flag now contains bit 0 of A inverted, and P
     **** ****     > SEC
0001 46DA 0A18  18        sla  rmone,1
                   < elite.a99
14670 46DC 06A0  32        bl   @rora                      ; ROR A             ; contains A inverted and shifted right by one, with bit
     46DE FE62     
14671 46E0 D80D  30        movb ra,@P                      ; STA P             ; 7 set to a 1. We can now use P as our source of bits
     46E2 001B     
14672                                                                          ; to shift right, just as in MU11, just with the logic
14673                                                                          ; reversed
14674               
14675 46E4 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     46E6 0000     
14676               
14677               MUL3:
14678 46E8 180E  14        joc  MU7                        ; BCS MU7           ; If C (i.e. the next bit from P) is set, do not do the
14679                                                                          ; addition for this bit of P, and instead skip to MU7
14680                                                                          ; to just do the shifts
14681               
14682                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 46EA 1701  14        jnc  !
0002 46EC B347  18        ab   rone,ra
0003               !:
0004 46EE B360  30        ab   @Q,ra
     46F0 0090     
                   < elite.a99
14683                                                                          ;
14684                                                                          ; A = A + Q + C
14685                                                                          ; = A + Q
14686               
14687 46F2 06A0  32        bl   @rora                      ; ROR A             ; Shift A right to catch the next digit of our result.
     46F4 FE62     
14688                                                                          ; If we were interested in the low byte of the result we
14689                                                                          ; would want to save the bit that falls off the end, but
14690                                                                          ; we aren't, so we can ignore it
14691               
14692                      .lsr @P                         ; LSR P             ; Shift P right to fetch the next bit for the
     **** ****     > LSR
0001 46F6 D020  30        movb @P,rtmp
     46F8 001B     
0002 46FA 0910  18        srl  rtmp,1
0003 46FC D800  30        movb rtmp,@P
     46FE 001B     
                   < elite.a99
14693                                                                          ; calculation into the C flag
14694               
14695 4700 16F3  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14696                                                                          ; (so we loop through the bits of P until we get to the
14697                                                                          ; 1 we inserted before the loop, and then we stop)
14698               
14699                                                                          ; If we get here then the C flag is set as we just
14700                                                                          ; rotated a 1 out of the right end of P
14701               
14702 4702 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4704 FE34     
14703               
14704               MU7:
14705 4706 091D  18        srl  ra,1                       ; LSR A             ; Shift A right to catch the next digit of our result,
14706                                                                          ; pushing a 0 into bit 7 as we aren't adding anything
14707                                                                          ; here (we can't use a ROR here as the C flag is set, so
14708                                                                          ; a ROR would push a 1 into bit 7)
14709               
14710                      .lsr @P                         ; LSR P             ; Fetch the next bit from P into the C flag
     **** ****     > LSR
0001 4708 D020  30        movb @P,rtmp
     470A 001B     
0002 470C 0910  18        srl  rtmp,1
0003 470E D800  30        movb rtmp,@P
     4710 001B     
                   < elite.a99
14711               
14712 4712 16EA  14        jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
14713                                                                          ; (so we loop through the bits of P until we get to the
14714                                                                          ; 1 we inserted before the loop, and then we stop)
14715               
14716                                                                          ; If we get here then the C flag is set as we just
14717                                                                          ; rotated a 1 out of the right end of P
14718               
14719 4714 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4716 FE34     
14720               
14721               * ******************************************************************************
14722               *
14723               * Name: Unused duplicate of MULTU
14724               * Type: Subroutine
14725               * Category: Maths (Arithmetic)
14726               * Summary: An unused duplicate of the MULTU routine
14727               *
14728               * ------------------------------------------------------------------------------
14729               *
14730               * This is a duplicate of the MULTU routine, but with no entry label, so it can't
14731               * be called by name. It is unused, and could have been culled to save a few
14732               * bytes (24 to be precise), but it's still here, unnamed, unloved and unvisited,
14733               * through no fault of its own.
14734               *
14735               * ******************************************************************************
14736               
14737               * {
14738               * LDX Q
14739               * BEQ MU1
14740               * DEX
14741               * STX T
14742               * LDA #0
14743               * LDX #8
14744               * LSR P
14745               *
14746               * .MUL6
14747               *
14748               * BCC B45
14749               * ADC T
14750               * .B45
14751               * ROR A
14752               * ROR P
14753               * DEX
14754               * BNE MUL6
14755               * RTS
14756               * }
14757               
14758               * ******************************************************************************
14759               *
14760               * Name: MLTU2
14761               * Type: Subroutine
14762               * Category: Maths (Arithmetic)
14763               * Summary: Calculate (A P+1 P) = (A ~P) * Q
14764               * Deep dive: Shift-and-add multiplication
14765               *
14766               * ------------------------------------------------------------------------------
14767               *
14768               * Do the following multiplication of an unsigned 16-bit number and an unsigned
14769               * 8-bit number:
14770               *
14771               * (A P+1 P) = (A ~P) * Q
14772               *
14773               * where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
14774               * words, if you wanted to calculate &1234 * &56, you would:
14775               *
14776               * * Set A to &12
14777               * * Set P to &34 EOR %11111111 = &CB
14778               * * Set Q to &56
14779               *
14780               * before calling MLTU2.
14781               *
14782               * This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
14783               * inverted argument trick to work out whether or not to do an addition, and like
14784               * MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
14785               * extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
14786               * the algorithm is still the shift-and-add approach explained in MULT1, just
14787               * with more bits.
14788               *
14789               * ------------------------------------------------------------------------------
14790               *
14791               * Returns:
14792               *
14793               * Q                   Q is preserved
14794               *
14795               * ------------------------------------------------------------------------------
14796               *
14797               * Other entry points:
14798               *
14799               * MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
14800               *
14801               * ******************************************************************************
14802               
14803 4718 D80E  30        movb rx,@Q                      ; STX Q             ; Store X in Q
     471A 0090     
14804               
14805               MLTU2:
14806                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A and rotate right, storing the
     **** ****     > EOI
0001 471C 0200  20        li   rtmp,(>FF*256)
     471E FF00     
0002 4720 2B40  18        xor  rtmp,ra
                   < elite.a99
14807 4722 091D  18        srl  ra,1                       ; LSR A             ; result in P+1, so we now calculate (P+1 P) * Q
14808 4724 D80D  30        movb ra,@P+1                    ; STA P+1
     4726 001C     
14809               
14810 4728 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     472A 0000     
14811               
14812 472C 020E  20        li   rx,>10*256                 ; LDX #16           ; Set up a counter in X to count the 16 bits in (P+1 P)
     472E 1000     
14813               
14814 4730 0204  20        li   rarg1,P                    ; ROR P             ; Set P = P >> 1 with bit 7 = bit 0 of A
     4732 001B     
14815 4734 06A0  32        bl   @ror                       ;
     4736 FE7A     
14816                                                                          ; and C flag = bit 0 of P
14817               
14818               MUL7:
14819 4738 1812  14        joc  MU21                       ; BCS MU21          ; If C (i.e. the next bit from P) is set, do not do the
14820                                                                          ; addition for this bit of P, and instead skip to MU21
14821                                                                          ; to just do the shifts
14822               
14823                      .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
     **** ****     > ADC
0001 473A 1701  14        jnc  !
0002 473C B347  18        ab   rone,ra
0003               !:
0004 473E B360  30        ab   @Q,ra
     4740 0090     
                   < elite.a99
14824                                                                          ;
14825                                                                          ; A = A + Q + C
14826                                                                          ; = A + Q
14827               
14828 4742 06A0  32        bl   @rora                      ; ROR A             ; Rotate (A P+1 P) to the right, so we capture the next
     4744 FE62     
14829 4746 0204  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     4748 001C     
14830 474A 06A0  32        bl   @ror                       ;
     474C FE7A     
14831 474E 0204  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     4750 001B     
14832 4752 06A0  32        bl   @ror                       ;
     4754 FE7A     
14833               
14834 4756 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14835               
14836 4758 16EF  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14837                                                                          ; all the way
14838               
14839 475A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     475C FE34     
14840               
14841               MU21:
14842 475E 091D  18        srl  ra,1                       ; LSR A             ; Shift (A P+1 P) to the right, so we capture the next
14843 4760 0204  20        li   rarg1,P+1                  ; ROR P+1           ; digit of the result in P+1, and extract the next digit
     4762 001C     
14844 4764 06A0  32        bl   @ror                       ;
     4766 FE7A     
14845 4768 0204  20        li   rarg1,P                    ; ROR P             ; of (P+1 P) in the C flag
     476A 001B     
14846 476C 06A0  32        bl   @ror                       ;
     476E FE7A     
14847               
14848 4770 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14849               
14850 4772 16E2  14        jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
14851                                                                          ; all the way
14852               
14853 4774 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4776 FE34     
14854               
14855               * ******************************************************************************
14856               *
14857               * Name: MUT3
14858               * Type: Subroutine
14859               * Category: Maths (Arithmetic)
14860               * Summary: An unused routine that does the same as MUT2
14861               *
14862               * ------------------------------------------------------------------------------
14863               *
14864               * This routine is never actually called, but it is identical to MUT2, as the
14865               * extra instructions have no effect.
14866               *
14867               * ******************************************************************************
14868               
14869               MUT3:
14870 4778 D3A0  30        movb @ALP1,rx                   ; LDX ALP1          ; Set P = ALP1, though this gets overwritten by the
     477A 0087     
14871 477C D80E  30        movb rx,@P                      ; STX P             ; following, so this has no effect
     477E 001B     
14872               
14873                                                                          ; Fall through into MUT2 to do the following:
14874                                                                          ;
14875                                                                          ; (S R) = XX(1 0)
14876                                                                          ; (A P) = Q * A
14877               
14878               * ******************************************************************************
14879               *
14880               * Name: MUT2
14881               * Type: Subroutine
14882               * Category: Maths (Arithmetic)
14883               * Summary: Calculate (S R) = XX(1 0) and (A P) = Q * A
14884               *
14885               * ------------------------------------------------------------------------------
14886               *
14887               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14888               *
14889               * (S R) = XX(1 0)
14890               * (A P) = Q * A
14891               *
14892               * ******************************************************************************
14893               
14894               MUT2:
14895 4780 D3A0  30        movb @XX+1,rx                   ; LDX XX+1          ; Set S = XX+1
     4782 0025     
14896 4784 D80E  30        movb rx,@S                      ; STX S
     4786 0092     
14897               
14898                                                                          ; Fall through into MUT1 to do the following:
14899                                                                          ;
14900                                                                          ; R = XX
14901                                                                          ; (A P) = Q * A
14902               
14903               * ******************************************************************************
14904               *
14905               * Name: MUT1
14906               * Type: Subroutine
14907               * Category: Maths (Arithmetic)
14908               * Summary: Calculate R = XX and (A P) = Q * A
14909               *
14910               * ------------------------------------------------------------------------------
14911               *
14912               * Do the following assignment, and multiplication of two signed 8-bit numbers:
14913               *
14914               * R = XX
14915               * (A P) = Q * A
14916               *
14917               * ******************************************************************************
14918               
14919               MUT1:
14920 4788 D3A0  30        movb @XX,rx                     ; LDX XX            ; Set R = XX
     478A 0024     
14921 478C D80E  30        movb rx,@R                      ; STX R
     478E 0091     
14922               
14923                                                                          ; Fall through into MULT1 to do the following:
14924                                                                          ;
14925                                                                          ; (A P) = Q * A
14926               
14927               * ******************************************************************************
14928               *
14929               * Name: MULT1
14930               * Type: Subroutine
14931               * Category: Maths (Arithmetic)
14932               * Summary: Calculate (A P) = Q * A
14933               * Deep dive: Shift-and-add multiplication
14934               *
14935               * ------------------------------------------------------------------------------
14936               *
14937               * Do the following multiplication of two 8-bit sign-magnitude numbers:
14938               *
14939               * (A P) = Q * A
14940               *
14941               * ******************************************************************************
14942               
14943               MULT1:
14944 4790 D38D  18        movb ra,rx                      ; TAX               ; Store A in X
14945               
14946 4792 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Set P = |A| >> 1
     4794 7F00     
14947 4796 091D  18        srl  ra,1                       ; LSR A             ; and C flag = bit 0 of A
14948 4798 D80D  30        movb ra,@P                      ; STA P
     479A 001B     
14949               
14950 479C D34E  18        movb rx,ra                      ; TXA               ; Restore argument A
14951               
14952                      .eor @Q                         ; EOR Q             ; Set bit 7 of A and T if Q and A have different signs,
     **** ****     > EOR
0001 479E D020  30        movb @Q,rtmp
     47A0 0090     
0002 47A2 2B40  18        xor  rtmp,ra
                   < elite.a99
14953 47A4 024D  22        andi ra,>80*256                 ; AND #%10000000    ; clear bit 7 if they have the same signs, 0 all other
     47A6 8000     
14954 47A8 D80D  30        movb ra,@T                      ; STA T             ; bits, i.e. T contains the sign bit of Q * A
     47AA 00D1     
14955               
14956 47AC D360  30        movb @Q,ra                      ; LDA Q             ; Set A = |Q|
     47AE 0090     
14957 47B0 024D  22        andi ra,>7f*256                 ; AND #%01111111
     47B2 7F00     
14958               
14959 47B4 131E  14        jeq  mu10_                      ; BEQ mu10          ; If |Q| = 0 jump to mu10 (with A set to 0)
14960               
14961 47B6 D38D  18        movb ra,rx                      ; TAX               ; Set T1 = |Q| - 1
14962 47B8 7387  18        sb   rone,rx                    ; DEX               ;
14963 47BA D80E  30        movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
     47BC 0006     
14964                                                                          ; to do an addition in the loop below
14965               
14966                                                                          ; We are now going to work our way through the bits of
14967                                                                          ; P, and do a shift-add for any bits that are set,
14968                                                                          ; keeping the running total in A. We already set up
14969                                                                          ; the first shift at the start of this routine, as
14970                                                                          ; P = |A| >> 1 and C = bit 0 of A, so we now need to set
14971                                                                          ; up a loop to sift through the other 7 bits in P
14972               
14973 47BE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A
     47C0 0000     
14974               
14975 47C2 020E  20        li   rx,>07*256                 ; LDX #7            ; Set up a counter in X to count the 7 bits remaining
     47C4 0700     
14976                                                                          ; in P
14977               
14978               MUL4:
14979 47C6 1704  14        jnc  B46                        ; BCC B46           ; If C (i.e. the next bit from P) is set, do the
14980                      .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
     **** ****     > ADC
0001 47C8 1701  14        jnc  !
0002 47CA B347  18        ab   rone,ra
0003               !:
0004 47CC B360  30        ab   @T1,ra
     47CE 0006     
                   < elite.a99
14981                                                                          ;
14982                                                                          ; A = A + T1 + C
14983                                                                          ; = A + |Q| - 1 + 1
14984                                                                          ; = A + |Q|
14985               
14986               B46:
14987 47D0 06A0  32        bl   @rora                      ; ROR A             ; As mentioned above, this ROR shifts A right and
     47D2 FE62     
14988                                                                          ; catches bit 0 in C - giving another digit for our
14989                                                                          ; result - and the next ROR sticks that bit into the
14990                                                                          ; left end of P while also extracting the next bit of P
14991                                                                          ; for the next addition
14992               
14993 47D4 0204  20        li   rarg1,P                    ; ROR P             ; Add the overspill from shifting A to the right onto
     47D6 001B     
14994 47D8 06A0  32        bl   @ror                       ;
     47DA FE7A     
14995                                                                          ; the start of P, and shift P right to fetch the next
14996                                                                          ; bit for the calculation
14997               
14998 47DC 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
14999               
15000 47DE 16F3  14        jne  MUL4                       ; BNE MUL4          ; Loop back for the next bit until P has been rotated
15001                                                                          ; all the way
15002               
15003 47E0 091D  18        srl  ra,1                       ; LSR A             ; Rotate (A P) once more to get the final result, as
15004 47E2 0204  20        li   rarg1,P                    ; ROR P             ; we only pushed 7 bits through the above process
     47E4 001B     
15005 47E6 06A0  32        bl   @ror                       ;
     47E8 FE7A     
15006               
15007 47EA F360  30        socb @T,ra                      ; ORA T             ; Set the sign bit of the result that we stored in T
     47EC 00D1     
15008               
15009 47EE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     47F0 FE34     
15010               
15011               mu10_:
15012 47F2 D80D  30        movb ra,@P                      ; STA P             ; If we get here, the result is 0 and A = 0, so set
     47F4 001B     
15013                                                                          ; P = 0 so (A P) = 0
15014               
15015 47F6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     47F8 FE34     
15016               
15017               * ******************************************************************************
15018               *
15019               * Name: MULT12
15020               * Type: Subroutine
15021               * Category: Maths (Arithmetic)
15022               * Summary: Calculate (S R) = Q * A
15023               *
15024               * ------------------------------------------------------------------------------
15025               *
15026               * Calculate:
15027               *
15028               * (S R) = Q * A
15029               *
15030               * ******************************************************************************
15031               
15032               MULT12:
15033 47FA 0200  20        li   rtmp,MULT1                 ; JSR MULT1         ; Set (A P) = Q * A
     47FC 4790     
15034 47FE 06A0  32        bl   @jsr                       ;
     4800 FE28     
15035               
15036 4802 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A P)
     4804 0092     
15037 4806 D360  30        movb @P,ra                      ; LDA P             ; = Q * A
     4808 001B     
15038 480A D80D  30        movb ra,@R                      ; STA R
     480C 0091     
15039               
15040 480E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4810 FE34     
15041               
15042               * ******************************************************************************
15043               *
15044               * Name: TAS3
15045               * Type: Subroutine
15046               * Category: Maths (Geometry)
15047               * Summary: Calculate the dot product of XX15 and an orientation vector
15048               *
15049               * ------------------------------------------------------------------------------
15050               *
15051               * Calculate the dot product of the vector in XX15 and one of the orientation
15052               * vectors, as determined by the value of Y. If vect is the orientation vector,
15053               * we calculate this:
15054               *
15055               * (A X) = vect . XX15
15056               * = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
15057               *
15058               * ------------------------------------------------------------------------------
15059               *
15060               * Arguments:
15061               *
15062               * Y                   The orientation vector:
15063               *
15064               * * If Y = 10, calculate nosev . XX15
15065               *
15066               * * If Y = 16, calculate roofv . XX15
15067               *
15068               * * If Y = 22, calculate sidev . XX15
15069               *
15070               * ------------------------------------------------------------------------------
15071               *
15072               * Returns:
15073               *
15074               * (A X)               The result of the dot product
15075               *
15076               * ******************************************************************************
15077               
15078               TAS3:
15079 4812 06CF  14        swpb ry                         ;
15080 4814 D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; Set Q = the Y-th byte of INWK, i.e. vect_x
     4816 0053     
15081 4818 06CF  14        swpb ry                         ;
15082 481A D80E  30        movb rx,@Q                      ; STX Q
     481C 0090     
15083               
15084 481E D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     4820 0031     
15085               
15086 4822 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     4824 47FA     
15087 4826 06A0  32        bl   @jsr                       ;
     4828 FE28     
15088                                                                          ; = vect_x * XX15
15089               
15090 482A 06CF  14        swpb ry                         ;
15091 482C D3AF  34        movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_y
     482E 0055     
15092 4830 06CF  14        swpb ry                         ;
15093 4832 D80E  30        movb rx,@Q                      ; STX Q
     4834 0090     
15094               
15095 4836 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = XX15+1
     4838 0032     
15096               
15097 483A 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     483C 485A     
15098 483E 06A0  32        bl   @jsr                       ;
     4840 FE28     
15099                                                                          ; = vect_y * XX15+1 + vect_x * XX15
15100               
15101 4842 D80D  30        movb ra,@S                      ; STA S             ; Set (S R) = (A X)
     4844 0092     
15102 4846 D80E  30        movb rx,@R                      ; STX R
     4848 0091     
15103               
15104 484A 06CF  14        swpb ry                         ;
15105 484C D3AF  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_z
     484E 0057     
15106 4850 06CF  14        swpb ry                         ;
15107 4852 D80E  30        movb rx,@Q                      ; STX Q
     4854 0090     
15108               
15109 4856 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     4858 0033     
15110               
15111                                                                          ; Fall through into MAD to set:
15112                                                                          ;
15113                                                                          ; (A X) = Q * A + (S R)
15114                                                                          ; = vect_z * XX15+2 + vect_y * XX15+1 +
15115                                                                          ; vect_x * XX15
15116               
15117               * ******************************************************************************
15118               *
15119               * Name: MAD
15120               * Type: Subroutine
15121               * Category: Maths (Arithmetic)
15122               * Summary: Calculate (A X) = Q * A + (S R)
15123               *
15124               * ------------------------------------------------------------------------------
15125               *
15126               * Calculate
15127               *
15128               * (A X) = Q * A + (S R)
15129               *
15130               * ******************************************************************************
15131               
15132               MAD:
15133 485A 0200  20        li   rtmp,MULT1                 ; JSR MULT1         ; Call MULT1 to set (A P) = Q * A
     485C 4790     
15134 485E 06A0  32        bl   @jsr                       ;
     4860 FE28     
15135               
15136                                                                          ; Fall through into ADD to do:
15137                                                                          ;
15138                                                                          ; (A X) = (A P) + (S R)
15139                                                                          ; = Q * A + (S R)
15140               
15141               * ******************************************************************************
15142               *
15143               * Name: ADD
15144               * Type: Subroutine
15145               * Category: Maths (Arithmetic)
15146               * Summary: Calculate (A X) = (A P) + (S R)
15147               * Deep dive: Adding sign-magnitude numbers
15148               *
15149               * ------------------------------------------------------------------------------
15150               *
15151               * Add two 16-bit sign-magnitude numbers together, calculating:
15152               *
15153               * (A X) = (A P) + (S R)
15154               *
15155               * ******************************************************************************
15156               
15157               ADD:
15158 4862 D80D  30        movb ra,@T1                     ; STA T1            ; Store argument A in T1
     4864 0006     
15159               
15160 4866 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign (bit 7) of A and store it in T
     4868 8000     
15161 486A D80D  30        movb ra,@T                      ; STA T
     486C 00D1     
15162               
15163                      .eor @S                         ; EOR S             ; EOR bit 7 of A with S. If they have different bit 7s
     **** ****     > EOR
0001 486E D020  30        movb @S,rtmp
     4870 0092     
0002 4872 2B40  18        xor  rtmp,ra
                   < elite.a99
15164 4874 1112  14        jlt  MU8                        ; BMI MU8           ; (i.e. they have different signs) then bit 7 in the
15165                                                                          ; EOR result will be 1, which means the EOR result is
15166                                                                          ; negative. So the AND, EOR and BMI together mean "jump
15167                                                                          ; to MU8 if A and S have different signs"
15168               
15169                                                                          ; If we reach here, then A and S have the same sign, so
15170                                                                          ; we can add them and set the sign to get the result
15171               
15172 4876 D360  30        movb @R,ra                      ; LDA R             ; Add the least significant bytes together into X:
     4878 0091     
15173                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 487A 0A16  18        sla  rzero,1
                   < elite.a99
15174                      .adc @P,ra                      ; ADC P             ; X = P + R
     **** ****     > ADC
0001 487C 1701  14        jnc  !
0002 487E B347  18        ab   rone,ra
0003               !:
0004 4880 B360  30        ab   @P,ra
     4882 001B     
                   < elite.a99
15175 4884 D38D  18        movb ra,rx                      ; TAX
15176               
15177 4886 D360  30        movb @S,ra                      ; LDA S             ; Add the most significant bytes together into A. We
     4888 0092     
15178                      .adc @T1,ra                     ; ADC T1            ; stored the original argument A in T1 earlier, so we
     **** ****     > ADC
0001 488A 1701  14        jnc  !
0002 488C B347  18        ab   rone,ra
0003               !:
0004 488E B360  30        ab   @T1,ra
     4890 0006     
                   < elite.a99
15179                                                                          ; can do this with:
15180                                                                          ;
15181                                                                          ; A = A  + S + C
15182                                                                          ; = T1 + S + C
15183               
15184 4892 F360  30        socb @T,ra                      ; ORA T             ; If argument A was negative (and therefore S was also
     4894 00D1     
15185                                                                          ; negative) then make sure result A is negative by
15186                                                                          ; OR'ing the result with the sign bit from argument A
15187                                                                          ; (which we stored in T)
15188               
15189 4896 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4898 FE34     
15190               
15191               MU8:
15192                                                                          ; If we reach here, then A and S have different signs,
15193                                                                          ; so we can subtract their absolute values and set the
15194                                                                          ; sign to get the result
15195 489A D360  30        movb @S,ra                      ; LDA S             ; Clear the sign (bit 7) in S and store the result in
     489C 0092     
15196 489E 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; U, so U now contains |S|
     48A0 7F00     
15197 48A2 D80D  30        movb ra,@U                      ; STA U
     48A4 008F     
15198               
15199 48A6 D360  30        movb @P,ra                      ; LDA P             ; Subtract the least significant bytes into X:
     48A8 001B     
15200                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 48AA 0A18  18        sla  rmone,1
                   < elite.a99
15201                      .sbc @R,ra                      ; SBC R             ; X = P - R
     **** ****     > SBC
0001 48AC 1801  14        joc  !
0002 48AE 7347  18        sb   rone,ra
0003               !:
0004 48B0 7360  30        sb   @R,ra
     48B2 0091     
                   < elite.a99
15202 48B4 D38D  18        movb ra,rx                      ; TAX
15203               
15204 48B6 D360  30        movb @T1,ra                     ; LDA T1            ; Restore the A of the argument (A P) from T1 and
     48B8 0006     
15205 48BA 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; clear the sign (bit 7), so A now contains |A|
     48BC 7F00     
15206               
15207                      .sbc @U,ra                      ; SBC U             ; Set A = |A| - |S|
     **** ****     > SBC
0001 48BE 1801  14        joc  !
0002 48C0 7347  18        sb   rone,ra
0003               !:
0004 48C2 7360  30        sb   @U,ra
     48C4 008F     
                   < elite.a99
15208               
15209                                                                          ; At this point we have |A P| - |S R| in (A X), so we
15210                                                                          ; need to check whether the subtraction above was the
15211                                                                          ; right way round (i.e. that we subtracted the smaller
15212                                                                          ; absolute value from the larger absolute value)
15213               
15214 48C6 1813  14        joc  MU9                        ; BCS MU9           ; If |A| >= |S|, our subtraction was the right way
15215                                                                          ; round, so jump to MU9 to set the sign
15216               
15217                                                                          ; If we get here, then |A| < |S|, so our subtraction
15218                                                                          ; above was the wrong way round (we actually subtracted
15219                                                                          ; the larger absolute value from the smaller absolute
15220                                                                          ; value). So let's subtract the result we have in (A X)
15221                                                                          ; from zero, so that the subtraction is the right way
15222                                                                          ; round
15223               
15224 48C8 D80D  30        movb ra,@U                      ; STA U             ; Store A in U
     48CA 008F     
15225               
15226 48CC D34E  18        movb rx,ra                      ; TXA               ; Set X = 0 - X using two's complement (to negate a
15227                      .eoi (>ff*256)                  ; EOR #&FF          ; number in two's complement, you can invert the bits
     **** ****     > EOI
0001 48CE 0200  20        li   rtmp,(>FF*256)
     48D0 FF00     
0002 48D2 2B40  18        xor  rtmp,ra
                   < elite.a99
15228                      .adi (>01*256)                  ; ADC #1            ; and add one - and we know the C flag is clear as we
     **** ****     > ADI
0001 48D4 1701  14        jnc  !
0002 48D6 B347  18        ab   rone,ra
0003               !:
0004 48D8 022D  22        ai   ra,(>01*256)
     48DA 0100     
                   < elite.a99
15229 48DC D38D  18        movb ra,rx                      ; TAX               ; didn't take the BCS branch above, so the ADC will do
15230                                                                          ; the correct addition)
15231               
15232 48DE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 - A, which we can do this time using a
     48E0 0000     
15233                      .sbc @U,ra                      ; SBC U             ; subtraction with the C flag clear
     **** ****     > SBC
0001 48E2 1801  14        joc  !
0002 48E4 7347  18        sb   rone,ra
0003               !:
0004 48E6 7360  30        sb   @U,ra
     48E8 008F     
                   < elite.a99
15234               
15235 48EA 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now set the sign bit of A, so that the EOR on the
     48EC 8000     
15236                                                                          ; next line will give the result the opposite sign to
15237                                                                          ; argument A (as T contains the sign bit of argument
15238                                                                          ; A). This is the same as giving the result the same
15239                                                                          ; sign as argument S (as A and S have different signs),
15240                                                                          ; which is what we want, as S has the larger absolute
15241                                                                          ; value
15242               
15243               MU9:
15244                      .eor @T                         ; EOR T             ; If we get here from the BCS above, then |A| >= |S|,
     **** ****     > EOR
0001 48EE D020  30        movb @T,rtmp
     48F0 00D1     
0002 48F2 2B40  18        xor  rtmp,ra
                   < elite.a99
15245                                                                          ; so we want to give the result the same sign as
15246                                                                          ; argument A, so if argument A was negative, we flip
15247                                                                          ; the sign of the result with an EOR (to make it
15248                                                                          ; negative)
15249               
15250 48F4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     48F6 FE34     
15251               
15252               * ******************************************************************************
15253               *
15254               * Name: TIS1
15255               * Type: Subroutine
15256               * Category: Maths (Arithmetic)
15257               * Summary: Calculate (A ?) = (-X * A + (S R)) / 96
15258               * Deep dive: Shift-and-subtract division
15259               *
15260               * ------------------------------------------------------------------------------
15261               *
15262               * Calculate the following expression between sign-magnitude numbers, ignoring
15263               * the low byte of the result:
15264               *
15265               * (A ?) = (-X * A + (S R)) / 96
15266               *
15267               * This uses the same shift-and-subtract algorithm as TIS2, just with the
15268               * quotient A hard-coded to 96.
15269               *
15270               * ------------------------------------------------------------------------------
15271               *
15272               * Returns:
15273               *
15274               * Q                   Gets set to the value of argument X
15275               *
15276               * ******************************************************************************
15277               
15278               TIS1:
15279 48F8 D80E  30        movb rx,@Q                      ; STX Q             ; Set Q = X
     48FA 0090     
15280               
15281                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit in A
     **** ****     > EOI
0001 48FC 0200  20        li   rtmp,(>80*256)
     48FE 8000     
0002 4900 2B40  18        xor  rtmp,ra
                   < elite.a99
15282               
15283 4902 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     4904 485A     
15284 4906 06A0  32        bl   @jsr                       ;
     4908 FE28     
15285                                                                          ; = X * -A + (S R)
15286               
15287               DVID96:
15288 490A D38D  18        movb ra,rx                      ; TAX               ; Set T to the sign bit of the result
15289 490C 024D  22        andi ra,>80*256                 ; AND #%10000000
     490E 8000     
15290 4910 D80D  30        movb ra,@T                      ; STA T
     4912 00D1     
15291               
15292 4914 D34E  18        movb rx,ra                      ; TXA               ; Set A to the high byte of the result with the sign bit
15293 4916 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; cleared, so (A ?) = |X * A + (S R)|
     4918 7F00     
15294               
15295                                                                          ; The following is identical to TIS2, except Q is
15296                                                                          ; hard-coded to 96, so this does A = A / 96
15297               
15298 491A 020E  20        li   rx,>fe*256                 ; LDX #254          ; Set T1 to have bits 1-7 set, so we can rotate through
     491C FE00     
15299 491E D80E  30        movb rx,@T1                     ; STX T1            ; 7 loop iterations, getting a 1 each time, and then
     4920 0006     
15300                                                                          ; getting a 0 on the 8th iteration... and we can also
15301                                                                          ; use T1 to catch our result bits into bit 0 each time
15302               
15303               DVL3:
15304                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 4922 024D  22        andi ra,>ff00
     4924 FF00     
0002 4926 0A1D  18        sla  ra,1
                   < elite.a99
15305               
15306 4928 028D  22        ci   ra,>60*256                 ; CMP #96           ; If A < 96 skip the following subtraction
     492A 6000     
15307 492C 1704  14        jnc  DV4                        ; BCC DV4
15308               
15309                      .sbi (>60*256)                  ; SBC #96           ; Set A = A - 96
     **** ****     > SBI
0001 492E 1801  14        joc  !
0002 4930 7347  18        sb   rone,ra
0003               !:
0004 4932 022D  22        ai   ra,-(>60*256)
     4934 A000     
                   < elite.a99
15310                                                                          ;
15311                                                                          ; Going into this subtraction we know the C flag is
15312                                                                          ; set as we passed through the BCC above, and we also
15313                                                                          ; know that A >= 96, so the C flag will still be set
15314                                                                          ; once we are done
15315               
15316               DV4:
15317 4936 0204  20        li   rarg1,T1                   ; ROL T1            ; Rotate the counter in T1 to the left, and catch the
     4938 0006     
15318 493A 06A0  32        bl   @rol                       ;
     493C FE4E     
15319                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
15320                                                                          ; do the subtraction, or 1 if we did)
15321               
15322 493E 18F1  14        joc  DVL3                       ; BCS DVL3          ; If we still have set bits in T1, loop back to DVL3 to
15323                                                                          ; do the next iteration of 7
15324               
15325 4940 D360  30        movb @T1,ra                     ; LDA T1            ; Fetch the result from T1 into A
     4942 0006     
15326               
15327 4944 F360  30        socb @T,ra                      ; ORA T             ; Give A the sign of the result that we stored above
     4946 00D1     
15328               
15329 4948 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     494A FE34     
15330               
15331               * ******************************************************************************
15332               *
15333               * Name: DV42
15334               * Type: Subroutine
15335               * Category: Maths (Arithmetic)
15336               * Summary: Calculate (P R) = 256 * DELTA / z_hi
15337               *
15338               * ------------------------------------------------------------------------------
15339               *
15340               * Calculate the following division and remainder:
15341               *
15342               * P = DELTA / (the Y-th stardust particle's z_hi coordinate)
15343               *
15344               * R = remainder as a fraction of A, where 1.0 = 255
15345               *
15346               * Another way of saying the above is this:
15347               *
15348               * (P R) = 256 * DELTA / z_hi
15349               *
15350               * DELTA is a value between 1 and 40, and the minimum z_hi is 16 (dust particles
15351               * are removed at lower values than this), so this means P is between 0 and 2
15352               * (as 40 / 16 = 2.5, so the maximum result is P = 2 and R = 128.
15353               *
15354               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15355               * keep the remainder.
15356               *
15357               * ------------------------------------------------------------------------------
15358               *
15359               * Arguments:
15360               *
15361               * Y                   The number of the stardust particle to process
15362               *
15363               * ------------------------------------------------------------------------------
15364               *
15365               * Returns:
15366               *
15367               * C flag              The C flag is cleared
15368               *
15369               * ******************************************************************************
15370               
15371               DV42:
15372 494C 06CF  14        swpb ry                         ;
15373 494E D36F  34        movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th dust particle's z_hi coordinate into A
     4950 0EE8     
15374 4952 06CF  14        swpb ry                         ;
15375               
15376                                                                          ; Fall through into DV41 to do:
15377                                                                          ;
15378                                                                          ; (P R) = 256 * DELTA / A
15379                                                                          ; = 256 * DELTA / Y-th stardust particle's z_hi
15380               
15381               * ******************************************************************************
15382               *
15383               * Name: DV41
15384               * Type: Subroutine
15385               * Category: Maths (Arithmetic)
15386               * Summary: Calculate (P R) = 256 * DELTA / A
15387               *
15388               * ------------------------------------------------------------------------------
15389               *
15390               * Calculate the following division and remainder:
15391               *
15392               * P = DELTA / A
15393               *
15394               * R = remainder as a fraction of A, where 1.0 = 255
15395               *
15396               * Another way of saying the above is this:
15397               *
15398               * (P R) = 256 * DELTA / A
15399               *
15400               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15401               * keep the remainder.
15402               *
15403               * ------------------------------------------------------------------------------
15404               *
15405               * Returns:
15406               *
15407               * C flag              The C flag is cleared
15408               *
15409               * ******************************************************************************
15410               
15411               DV41:
15412 4954 D80D  30        movb ra,@Q                      ; STA Q             ; Store A in Q
     4956 0090     
15413               
15414 4958 D360  30        movb @DELTA,ra                  ; LDA DELTA         ; Fetch the speed from DELTA into A
     495A 008C     
15415               
15416                                                                          ; Fall through into DVID4 to do:
15417                                                                          ;
15418                                                                          ; (P R) = 256 * A / Q
15419                                                                          ; = 256 * DELTA / A
15420               
15421               * ******************************************************************************
15422               *
15423               * Name: DVID4
15424               * Type: Subroutine
15425               * Category: Maths (Arithmetic)
15426               * Summary: Calculate (P R) = 256 * A / Q
15427               * Deep dive: Shift-and-subtract division
15428               *
15429               * ------------------------------------------------------------------------------
15430               *
15431               * Calculate the following division and remainder:
15432               *
15433               * P = A / Q
15434               *
15435               * R = remainder as a fraction of Q, where 1.0 = 255
15436               *
15437               * Another way of saying the above is this:
15438               *
15439               * (P R) = 256 * A / Q
15440               *
15441               * This uses the same shift-and-subtract algorithm as TIS2, but this time we
15442               * keep the remainder.
15443               *
15444               * ------------------------------------------------------------------------------
15445               *
15446               * Returns:
15447               *
15448               * C flag              The C flag is cleared
15449               *
15450               * ******************************************************************************
15451               
15452               DVID4:
15453 495C 020E  20        li   rx,>08*256                 ; LDX #8            ; Set a counter in X to count the 8 bits in A
     495E 0800     
15454               
15455                      .asla                           ; ASL A             ; Shift A left and store in P (we will build the result
     **** ****     > ASLA
0001 4960 024D  22        andi ra,>ff00
     4962 FF00     
0002 4964 0A1D  18        sla  ra,1
                   < elite.a99
15456 4966 D80D  30        movb ra,@P                      ; STA P             ; in P)
     4968 001B     
15457               
15458 496A 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a remainder
     496C 0000     
15459               
15460               DVL4:
15461 496E 06A0  32        bl   @rola                      ; ROL A             ; Shift A to the left
     4970 FE3E     
15462               
15463 4972 1803  14        joc  DV8                        ; BCS DV8           ; If the C flag is set (i.e. bit 7 of A was set) then
15464                                                                          ; skip straight to the subtraction
15465               
15466 4974 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     4976 0090     
15467 4978 1705  14        jnc  DV5                        ; BCC DV5
15468               
15469               DV8:
15470                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 497A 1801  14        joc  !
0002 497C 7347  18        sb   rone,ra
0003               !:
0004 497E 7360  30        sb   @Q,ra
     4980 0090     
                   < elite.a99
15471               
15472                      .sec                            ; SEC               ; Set the C flag, so that P gets a 1 shifted into bit 0
     **** ****     > SEC
0001 4982 0A18  18        sla  rmone,1
                   < elite.a99
15473               
15474               DV5:
15475 4984 0204  20        li   rarg1,P                    ; ROL P             ; Shift P to the left, pulling the C flag into bit 0
     4986 001B     
15476 4988 06A0  32        bl   @rol                       ;
     498A FE4E     
15477               
15478 498C 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
15479               
15480 498E 16EF  14        jne  DVL4                       ; BNE DVL4          ; Loop back for the next bit until we have done all 8
15481                                                                          ; bits of P
15482               
15483 4990 0460  28        b    @LL28+4                    ; JMP LL28+4        ; Jump to LL28+4 to convert the remainder in A into an
     4992 DB30     
15484                                                                          ; integer representation of the fractional value A / Q,
15485                                                                          ; in R, where 1.0 = 255. LL28+4 always returns with the
15486                                                                          ; C flag cleared, and we return from the subroutine
15487                                                                          ; using a tail call
15488               
15489               * ******************************************************************************
15490               *
15491               * Name: DVID3B2
15492               * Type: Subroutine
15493               * Category: Maths (Arithmetic)
15494               * Summary: Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15495               * Deep dive: Shift-and-subtract division
15496               *
15497               * ------------------------------------------------------------------------------
15498               *
15499               * Calculate the following:
15500               *
15501               * K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
15502               *
15503               * The actual division here is done as an 8-bit calculation using LL31, but this
15504               * routine shifts both the numerator (the top part of the division) and the
15505               * denominator (the bottom part of the division) around to get the multi-byte
15506               * result we want.
15507               *
15508               * Specifically, it shifts both of them to the left as far as possible, keeping a
15509               * tally of how many shifts get done in each one - and specifically, the
15510               * difference in the number of shifts between the top and bottom (as shifting
15511               * both of them once in the same direction won't change the result). It then
15512               * divides the two highest bytes with the simple 8-bit routine in LL31, and
15513               * shifts the result by the difference in the number of shifts, which acts as a
15514               * scale factor to get the correct result.
15515               *
15516               * ------------------------------------------------------------------------------
15517               *
15518               * Returns:
15519               *
15520               * K(3 2 1 0)          The result of the division
15521               *
15522               * X                   X is preserved
15523               *
15524               * ******************************************************************************
15525               
15526               DVID3B2:
15527 4994 D80D  30        movb ra,@P+2                    ; STA P+2           ; Set P+2 = A
     4996 001D     
15528               
15529 4998 D360  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set Q = z_lo
     499A 0059     
15530 499C D80D  30        movb ra,@Q                      ; STA Q
     499E 0090     
15531               
15532 49A0 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set R = z_hi
     49A2 005A     
15533 49A4 D80D  30        movb ra,@R                      ; STA R
     49A6 0091     
15534               
15535 49A8 D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set S = z_sign
     49AA 005B     
15536 49AC D80D  30        movb ra,@S                      ; STA S
     49AE 0092     
15537               
15538               DVID3B:
15539                                                                          ; Given the above assignments, we now want to calculate
15540                                                                          ; the following to get the result we want:
15541                                                                          ;
15542                                                                          ; K(3 2 1 0) = P(2 1 0) / (S R Q)
15543 49B0 D360  30        movb @P,ra                      ; LDA P             ; Make sure P(2 1 0) is at least 1
     49B2 001B     
15544 49B4 026D  22        ori  ra,>01*256                 ; ORA #1
     49B6 0100     
15545 49B8 D80D  30        movb ra,@P                      ; STA P
     49BA 001B     
15546               
15547 49BC D360  30        movb @P+2,ra                    ; LDA P+2           ; Set T to the sign of P+2 * S (i.e. the sign of the
     49BE 001D     
15548                      .eor @S                         ; EOR S             ; result) and store it in T
     **** ****     > EOR
0001 49C0 D020  30        movb @S,rtmp
     49C2 0092     
0002 49C4 2B40  18        xor  rtmp,ra
                   < elite.a99
15549 49C6 024D  22        andi ra,>80*256                 ; AND #%10000000
     49C8 8000     
15550 49CA D80D  30        movb ra,@T                      ; STA T
     49CC 00D1     
15551               
15552 49CE 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to store the scale factor
     49D0 0000     
15553               
15554 49D2 D360  30        movb @P+2,ra                    ; LDA P+2           ; Clear the sign bit of P+2, so the division can be done
     49D4 001D     
15555 49D6 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; with positive numbers and we'll set the correct sign
     49D8 7F00     
15556                                                                          ; below, once all the maths is done
15557                                                                          ;
15558                                                                          ; This also leaves A = P+2, which we use below
15559               
15560               DVL9:
15561                                                                          ; We now shift (A P+1 P) left until A >= 64, counting
15562                                                                          ; the number of shifts in Y. This makes the top part of
15563                                                                          ; the division as large as possible, thus retaining as
15564                                                                          ; much accuracy as we can.  When we come to return the
15565                                                                          ; final result, we shift the result by the number of
15566                                                                          ; places in Y, and in the correct direction
15567 49DA 028D  22        ci   ra,>40*256                 ; CMP #64           ; If A >= 64, jump down to DV14
     49DC 4000     
15568 49DE 180F  14        joc  DV14                       ; BCS DV14
15569               
15570                      .asl @P                         ; ASL P             ; Shift (A P+1 P) to the left
     **** ****     > ASL
0001 49E0 D020  30        movb @P,rtmp
     49E2 001B     
0002 49E4 0240  22        andi rtmp,>ff00
     49E6 FF00     
0003 49E8 0A10  18        sla  rtmp,1
0004 49EA D800  30        movb rtmp,@P
     49EC 001B     
                   < elite.a99
15571 49EE 0204  20        li   rarg1,P+1                  ; ROL P+1
     49F0 001C     
15572 49F2 06A0  32        bl   @rol                       ;
     49F4 FE4E     
15573 49F6 06A0  32        bl   @rola                      ; ROL A
     49F8 FE3E     
15574               
15575 49FA B3C7  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15576               
15577 49FC 16EE  14        jne  DVL9                       ; BNE DVL9          ; Loop up to DVL9 (this BNE is effectively a JMP, as Y
15578                                                                          ; will never be zero)
15579               
15580               DV14:
15581                                                                          ; If we get here, A >= 64 and contains the highest byte
15582                                                                          ; of the numerator, scaled up by the number of left
15583                                                                          ; shifts in Y
15584 49FE D80D  30        movb ra,@P+2                    ; STA P+2           ; Store A in P+2, so we now have the scaled value of
     4A00 001D     
15585                                                                          ; the numerator in P(2 1 0)
15586               
15587 4A02 D360  30        movb @S,ra                      ; LDA S             ; Set A = |S|
     4A04 0092     
15588 4A06 024D  22        andi ra,>7f*256                 ; AND #%01111111
     4A08 7F00     
15589               
15590 4A0A 110F  14        jlt  DV9                        ; BMI DV9           ; If bit 7 of A is set, jump down to DV9 to skip the
15591                                                                          ; left-shifting of the denominator (though this branch
15592                                                                          ; instruction has no effect as bit 7 of the above AND
15593                                                                          ; can never be set, which is why this instruction was
15594                                                                          ; removed from later versions)
15595               
15596               DVL6:
15597                                                                          ; We now shift (S R Q) left until bit 7 of S is set,
15598                                                                          ; reducing Y by the number of shifts. This makes the
15599                                                                          ; bottom part of the division as large as possible, thus
15600                                                                          ; retaining as much accuracy as we can. When we come to
15601                                                                          ; return the final result, we shift the result by the
15602                                                                          ; total number of places in Y, and in the correct
15603                                                                          ; direction, to give us the correct result
15604                                                                          ;
15605                                                                          ; We set A to |S| above, so the following actually
15606                                                                          ; shifts (A R Q)
15607 4A0C 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15608               
15609                      .asl @Q                         ; ASL Q             ; Shift (A R Q) to the left
     **** ****     > ASL
0001 4A0E D020  30        movb @Q,rtmp
     4A10 0090     
0002 4A12 0240  22        andi rtmp,>ff00
     4A14 FF00     
0003 4A16 0A10  18        sla  rtmp,1
0004 4A18 D800  30        movb rtmp,@Q
     4A1A 0090     
                   < elite.a99
15610 4A1C 0204  20        li   rarg1,R                    ; ROL R
     4A1E 0091     
15611 4A20 06A0  32        bl   @rol                       ;
     4A22 FE4E     
15612 4A24 06A0  32        bl   @rola                      ; ROL A
     4A26 FE3E     
15613               
15614 4A28 15F1  14        jgt  DVL6                       ; BPL DVL6          ; Loop up to DVL6 to do another shift, until bit 7 of A
15615                                                                          ; is set and we can't shift left any further
15616               
15617               DV9:
15618                                                                          ; We have now shifted both the numerator and denominator
15619                                                                          ; left as far as they will go, keeping a tally of the
15620                                                                          ; overall scale factor of the various shifts in Y. We
15621                                                                          ; can now divide just the two highest bytes to get our
15622                                                                          ; result
15623 4A2A D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = A, the highest byte of the denominator
     4A2C 0090     
15624               
15625 4A2E 020D  20        li   ra,>fe*256                 ; LDA #254          ; Set R to have bits 1-7 set, so we can pass this to
     4A30 FE00     
15626 4A32 D80D  30        movb ra,@R                      ; STA R             ; LL31 to act as the bit counter in the division
     4A34 0091     
15627               
15628 4A36 D360  30        movb @P+2,ra                    ; LDA P+2           ; Set A to the highest byte of the numerator
     4A38 001D     
15629               
15630 4A3A 0200  20        li   rtmp,LL31                  ; JSR LL31          ; Call LL31 to calculate:
     4A3C DB3A     
15631 4A3E 06A0  32        bl   @jsr                       ;
     4A40 FE28     
15632                                                                          ;
15633                                                                          ; R = 256 * A / Q
15634                                                                          ; = 256 * numerator / denominator
15635               
15636                                                                          ; The result of our division is now in R, so we just
15637                                                                          ; need to shift it back by the scale factor in Y
15638               
15639 4A42 020D  20        li   ra,>00*256                 ; LDA #0            ; Set K(3 2 1) = 0 to hold the result (we populate K
     4A44 0000     
15640 4A46 D80D  30        movb ra,@K+1                    ; STA K+1           ; next)
     4A48 003E     
15641 4A4A D80D  30        movb ra,@K+2                    ; STA K+2
     4A4C 003F     
15642 4A4E D80D  30        movb ra,@K+3                    ; STA K+3
     4A50 0040     
15643               
15644 4A52 D34F  18        movb ry,ra                      ; TYA               ; If Y is positive, jump to DV12
15645 4A54 1527  14        jgt  DV12                       ; BPL DV12
15646               
15647                                                                          ; If we get here then Y is negative, so we need to shift
15648                                                                          ; the result R to the left by Y places, and then set the
15649                                                                          ; correct sign for the result
15650               
15651 4A56 D360  30        movb @R,ra                      ; LDA R             ; Set A = R
     4A58 0091     
15652               
15653               DVL8:
15654                      .asla                           ; ASL A             ; Shift (K+3 K+2 K+1 A) left
     **** ****     > ASLA
0001 4A5A 024D  22        andi ra,>ff00
     4A5C FF00     
0002 4A5E 0A1D  18        sla  ra,1
                   < elite.a99
15655 4A60 0204  20        li   rarg1,K+1                  ; ROL K+1
     4A62 003E     
15656 4A64 06A0  32        bl   @rol                       ;
     4A66 FE4E     
15657 4A68 0204  20        li   rarg1,K+2                  ; ROL K+2
     4A6A 003F     
15658 4A6C 06A0  32        bl   @rol                       ;
     4A6E FE4E     
15659 4A70 0204  20        li   rarg1,K+3                  ; ROL K+3
     4A72 0040     
15660 4A74 06A0  32        bl   @rol                       ;
     4A76 FE4E     
15661               
15662 4A78 B3C7  18        ab   rone,ry                    ; INY               ; Increment the scale factor in Y
15663               
15664 4A7A 16EF  14        jne  DVL8                       ; BNE DVL8          ; Loop back to DVL8 until we have shifted left by Y
15665                                                                          ; places
15666               
15667 4A7C D80D  30        movb ra,@K                      ; STA K             ; Store A in K so the result is now in K(3 2 1 0)
     4A7E 003D     
15668               
15669 4A80 D360  30        movb @K+3,ra                    ; LDA K+3           ; Set K+3 to the sign in T, which we set above to the
     4A82 0040     
15670 4A84 F360  30        socb @T,ra                      ; ORA T             ; correct sign for the result
     4A86 00D1     
15671 4A88 D80D  30        movb ra,@K+3                    ; STA K+3
     4A8A 0040     
15672               
15673 4A8C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4A8E FE34     
15674               
15675               DV13:
15676                                                                          ; If we get here then Y is zero, so we don't need to
15677                                                                          ; shift the result R, we just need to set the correct
15678                                                                          ; sign for the result
15679 4A90 D360  30        movb @R,ra                      ; LDA R             ; Store R in K so the result is now in K(3 2 1 0)
     4A92 0091     
15680 4A94 D80D  30        movb ra,@K                      ; STA K
     4A96 003D     
15681               
15682 4A98 D360  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     4A9A 00D1     
15683 4A9C D80D  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     4A9E 0040     
15684               
15685 4AA0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4AA2 FE34     
15686               
15687               DV12:
15688 4AA4 13F5  14        jeq  DV13                       ; BEQ DV13          ; We jumped here having set A to the scale factor in Y,
15689                                                                          ; so this jumps up to DV13 if Y = 0
15690               
15691                                                                          ; If we get here then Y is positive and non-zero, so we
15692                                                                          ; need to shift the result R to the right by Y places
15693                                                                          ; and then set the correct sign for the result. We also
15694                                                                          ; know that K(3 2 1) will stay 0, as we are shifting the
15695                                                                          ; lowest byte to the right, so no set bits will make
15696                                                                          ; their way into the top three bytes
15697               
15698 4AA6 D360  30        movb @R,ra                      ; LDA R             ; Set A = R
     4AA8 0091     
15699               
15700               DVL10:
15701 4AAA 091D  18        srl  ra,1                       ; LSR A             ; Shift A right
15702               
15703 4AAC 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y
15704               
15705 4AAE 16FD  14        jne  DVL10                      ; BNE DVL10         ; Loop back to DVL10 until we have shifted right by Y
15706                                                                          ; places
15707               
15708 4AB0 D80D  30        movb ra,@K                      ; STA K             ; Store the shifted A in K so the result is now in
     4AB2 003D     
15709                                                                          ; K(3 2 1 0)
15710               
15711 4AB4 D360  30        movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
     4AB6 00D1     
15712 4AB8 D80D  30        movb ra,@K+3                    ; STA K+3           ; correct sign for the result
     4ABA 0040     
15713               
15714 4ABC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4ABE FE34     
15715               
15716               * ******************************************************************************
15717               *
15718               * Name: cntr
15719               * Type: Subroutine
15720               * Category: Dashboard
15721               * Summary: Apply damping to the pitch or roll dashboard indicator
15722               *
15723               * ------------------------------------------------------------------------------
15724               *
15725               * Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
15726               * centre point (so X represents a position on a centre-based dashboard slider,
15727               * such as pitch or roll). If the value is in the left-hand side of the slider
15728               * (1-127) then it bumps the value up by 1 so it moves towards the centre, and
15729               * if it's in the right-hand side, it reduces it by 1, also moving it towards the
15730               * centre.
15731               *
15732               * ******************************************************************************
15733               
15734               cntr_:
15735 4AC0 D360  30        movb @DAMP,ra                   ; LDA DAMP          ; If DAMP is non-zero, then keyboard damping is not
     4AC2 0F4A     
15736 4AC4 1608  14        jne  RE1                        ; BNE RE1           ; enabled, so jump to RE1 to return from the subroutine
15737               
15738 4AC6 D34E  18        movb rx,ra                      ; TXA               ; If X < 128, then it's in the left-hand side of the
15739 4AC8 1502  14        jgt  BUMP                       ; BPL BUMP          ; dashboard slider, so jump to BUMP to bump it up by 1,
15740                                                                          ; to move it closer to the centre
15741               
15742 4ACA 7387  18        sb   rone,rx                    ; DEX               ; Otherwise X >= 128, so it's in the right-hand side
15743 4ACC 1104  14        jlt  RE1                        ; BMI RE1           ; of the dashboard slider, so decrement X by 1, and if
15744                                                                          ; it's still >= 128, jump to RE1 to return from the
15745                                                                          ; subroutine, otherwise fall through to BUMP to undo
15746                                                                          ; the bump and then return
15747               
15748               BUMP:
15749 4ACE B387  18        ab   rone,rx                    ; INX               ; Bump X up by 1, and if it hasn't overshot the end of
15750 4AD0 1602  14        jne  RE1                        ; BNE RE1           ; the dashboard slider, jump to RE1 to return from the
15751                                                                          ; subroutine, otherwise fall through to REDU to drop
15752                                                                          ; it down by 1 again
15753               
15754               REDU:
15755 4AD2 7387  18        sb   rone,rx                    ; DEX               ; Reduce X by 1, and if we have reached 0 jump up to
15756 4AD4 13FC  14        jeq  BUMP                       ; BEQ BUMP          ; BUMP to add 1, because we need the value to be in the
15757                                                                          ; range 1 to 255
15758               
15759               RE1:
15760 4AD6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4AD8 FE34     
15761               
15762               * ******************************************************************************
15763               *
15764               * Name: BUMP2
15765               * Type: Subroutine
15766               * Category: Dashboard
15767               * Summary: Bump up the value of the pitch or roll dashboard indicator
15768               *
15769               * ------------------------------------------------------------------------------
15770               *
15771               * Increase ("bump up") X by A, where X is either the current rate of pitch or
15772               * the current rate of roll.
15773               *
15774               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15775               * This is the amount by which the pitch or roll is currently changing, so 1
15776               * means it is decreasing at the maximum rate, 128 means it is not changing,
15777               * and 255 means it is increasing at the maximum rate. These values correspond
15778               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15779               * left, 128 meaning the middle, and 255 meaning full right.
15780               *
15781               * If bumping up X would push it past 255, then X is set to 255.
15782               *
15783               * If keyboard auto-recentre is configured and the result is less than 128, we
15784               * bump X up to the mid-point, 128. This is the equivalent of having a roll or
15785               * pitch in the left half of the indicator, when increasing the roll or pitch
15786               * should jump us straight to the mid-point.
15787               *
15788               * ------------------------------------------------------------------------------
15789               *
15790               * Other entry points:
15791               *
15792               * RE2+2               Restore A from T and return from the subroutine
15793               *
15794               * ******************************************************************************
15795               
15796               BUMP2:
15797 4ADA D80D  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     4ADC 00D1     
15798               
15799 4ADE D34E  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15800               
15801                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 4AE0 0A16  18        sla  rzero,1
                   < elite.a99
15802                                                                          ; C flag affecting the result
15803               
15804                      .adc @T,ra                      ; ADC T             ; Set X = A = argument X + argument A
     **** ****     > ADC
0001 4AE2 1701  14        jnc  !
0002 4AE4 B347  18        ab   rone,ra
0003               !:
0004 4AE6 B360  30        ab   @T,ra
     4AE8 00D1     
                   < elite.a99
15805 4AEA D38D  18        movb ra,rx                      ; TAX
15806               
15807 4AEC 1702  14        jnc  RE2                        ; BCC RE2           ; If the C flag is clear, then we didn't overflow, so
15808                                                                          ; jump to RE2 to auto-recentre and return the result
15809               
15810 4AEE 020E  20        li   rx,>ff*256                 ; LDX #255          ; We have an overflow, so set X to the maximum possible
     4AF0 FF00     
15811                                                                          ; value of 255
15812               
15813               RE2:
15814 4AF2 1511  14        jgt  RE3+2                      ; BPL RE3+2         ; If X has bit 7 clear (i.e. the result < 128), then
15815                                                                          ; jump to RE3+2 in routine REDU2 to do an auto-recentre,
15816                                                                          ; if configured, because the result is on the left side
15817                                                                          ; of the centre point of 128
15818               
15819                                                                          ; Jumps to RE2+2 end up here
15820               
15821 4AF4 D360  30        movb @T,ra                      ; LDA T             ; Restore the original argument A from T into A
     4AF6 00D1     
15822               
15823 4AF8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4AFA FE34     
15824               
15825               * ******************************************************************************
15826               *
15827               * Name: REDU2
15828               * Type: Subroutine
15829               * Category: Dashboard
15830               * Summary: Reduce the value of the pitch or roll dashboard indicator
15831               *
15832               * ------------------------------------------------------------------------------
15833               *
15834               * Reduce X by A, where X is either the current rate of pitch or the current
15835               * rate of roll.
15836               *
15837               * The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
15838               * This is the amount by which the pitch or roll is currently changing, so 1
15839               * means it is decreasing at the maximum rate, 128 means it is not changing,
15840               * and 255 means it is increasing at the maximum rate. These values correspond
15841               * to the line on the DC or RL indicators on the dashboard, with 1 meaning full
15842               * left, 128 meaning the middle, and 255 meaning full right.
15843               *
15844               * If reducing X would bring it below 1, then X is set to 1.
15845               *
15846               * If keyboard auto-recentre is configured and the result is greater than 128, we
15847               * reduce X down to the mid-point, 128. This is the equivalent of having a roll
15848               * or pitch in the right half of the indicator, when decreasing the roll or pitch
15849               * should jump us straight to the mid-point.
15850               *
15851               * ------------------------------------------------------------------------------
15852               *
15853               * Other entry points:
15854               *
15855               * RE3+2               Auto-recentre the value in X, if keyboard auto-recentre
15856               * is configured
15857               *
15858               * ******************************************************************************
15859               
15860               REDU2:
15861 4AFC D80D  30        movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later
     4AFE 00D1     
15862               
15863 4B00 D34E  18        movb rx,ra                      ; TXA               ; Copy argument X into A
15864               
15865                      .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
     **** ****     > SEC
0001 4B02 0A18  18        sla  rmone,1
                   < elite.a99
15866                                                                          ; C flag affecting the result
15867               
15868                      .sbc @T,ra                      ; SBC T             ; Set X = A = argument X - argument A
     **** ****     > SBC
0001 4B04 1801  14        joc  !
0002 4B06 7347  18        sb   rone,ra
0003               !:
0004 4B08 7360  30        sb   @T,ra
     4B0A 00D1     
                   < elite.a99
15869 4B0C D38D  18        movb ra,rx                      ; TAX
15870               
15871 4B0E 1802  14        joc  RE3                        ; BCS RE3           ; If the C flag is set, then we didn't underflow, so
15872                                                                          ; jump to RE3 to auto-recentre and return the result
15873               
15874 4B10 020E  20        li   rx,>01*256                 ; LDX #1            ; We have an underflow, so set X to the minimum possible
     4B12 0100     
15875                                                                          ; value, 1
15876               
15877               RE3:
15878 4B14 15EF  14        jgt  RE2+2                      ; BPL RE2+2         ; If X has bit 7 clear (i.e. the result < 128), then
15879                                                                          ; jump to RE2+2 above to return the result as is,
15880                                                                          ; because the result is on the left side of the centre
15881                                                                          ; point of 128, so we don't need to auto-centre
15882               
15883                                                                          ; Jumps to RE3+2 end up here
15884               
15885                                                                          ; If we get here, then we need to apply auto-recentre,
15886                                                                          ; if it is configured
15887               
15888 4B16 D360  30        movb @DJD,ra                    ; LDA DJD           ; If keyboard auto-recentre is disabled, then
     4B18 0F4B     
15889 4B1A 16EC  14        jne  RE2+2                      ; BNE RE2+2         ; jump to RE2+2 to restore A and return
15890               
15891 4B1C 020E  20        li   rx,>80*256                 ; LDX #128          ; If we get here then keyboard auto-recentre is enabled,
     4B1E 8000     
15892 4B20 11E9  14        jlt  RE2+2                      ; BMI RE2+2         ; so set X to 128 (the middle of our range) and jump to
15893                                                                          ; RE2+2 to restore A and return from the subroutine
15894                                                                          ; (this BMI is effectively a JMP as bit 7 of X is always
15895                                                                          ; set)
15896               
15897               * ******************************************************************************
15898               *
15899               * Name: ARCTAN
15900               * Type: Subroutine
15901               * Category: Maths (Geometry)
15902               * Summary: Calculate A = arctan(P / Q)
15903               * Deep dive: The sine, cosine and arctan tables
15904               *
15905               * ------------------------------------------------------------------------------
15906               *
15907               * Calculate the following:
15908               *
15909               * A = arctan(P / Q)
15910               *
15911               * In other words, this finds the angle in the right-angled triangle where the
15912               * opposite side to angle A is length P and the adjacent side to angle A has
15913               * length Q, so:
15914               *
15915               * tan(A) = P / Q
15916               *
15917               * The result in A is an integer representing the angle in radians. The routine
15918               * returns values in the range 0 to 128, which covers 0 to 180 degrees (or 0 to
15919               * PI radians).
15920               *
15921               * ******************************************************************************
15922               
15923               ARCTAN:
15924 4B22 D360  30        movb @P,ra                      ; LDA P             ; Set T1 = P EOR Q, which will have the sign of P * Q
     4B24 001B     
15925                      .eor @Q                         ; EOR Q             ;
     **** ****     > EOR
0001 4B26 D020  30        movb @Q,rtmp
     4B28 0090     
0002 4B2A 2B40  18        xor  rtmp,ra
                   < elite.a99
15926               * AND #%10000000         \ The AND is commented out in the original source
15927 4B2C D80D  30        movb ra,@T1                     ; STA T1
     4B2E 0006     
15928               
15929 4B30 D360  30        movb @Q,ra                      ; LDA Q             ; If Q = 0, jump to AR2 to return a right angle
     4B32 0090     
15930 4B34 132B  14        jeq  AR2                        ; BEQ AR2
15931               
15932                      .asla                           ; ASL A             ; Set Q = |Q| * 2 (this is a quick way of clearing the
     **** ****     > ASLA
0001 4B36 024D  22        andi ra,>ff00
     4B38 FF00     
0002 4B3A 0A1D  18        sla  ra,1
                   < elite.a99
15933 4B3C D80D  30        movb ra,@Q                      ; STA Q             ; sign bit, and we don't need to shift right again as we
     4B3E 0090     
15934                                                                          ; only ever use this value in the division with |P| * 2,
15935                                                                          ; which we set next)
15936               
15937 4B40 D360  30        movb @P,ra                      ; LDA P             ; Set A = |P| * 2
     4B42 001B     
15938                      .asla                           ; ASL A
     **** ****     > ASLA
0001 4B44 024D  22        andi ra,>ff00
     4B46 FF00     
0002 4B48 0A1D  18        sla  ra,1
                   < elite.a99
15939               
15940 4B4A 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
     4B4C 0090     
15941 4B4E 180A  14        joc  AR1                        ; BCS AR1           ; and Q around, so we can still use the lookup table
15942               
15943 4B50 0200  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     4B52 4BA8     
15944 4B54 06A0  32        bl   @jsr                       ;
     4B56 FE28     
15945                                                                          ;
15946                                                                          ; A = arctan(A / Q)
15947                                                                          ; = arctan(|P / Q|)
15948               
15949                      .sec                            ; SEC               ; Set the C flag so the SBC instruction in AR3 will be
     **** ****     > SEC
0001 4B58 0A18  18        sla  rmone,1
                   < elite.a99
15950                                                                          ; correct, should we jump there
15951               
15952               AR4:
15953 4B5A D3A0  30        movb @T1,rx                     ; LDX T1            ; If T1 is negative, i.e. P and Q have different signs,
     4B5C 0006     
15954 4B5E 111A  14        jlt  AR3                        ; BMI AR3           ; jump down to AR3 to return arctan(-|P / Q|)
15955               
15956 4B60 0460  28        b    @rts                       ; RTS               ; Otherwise P and Q have the same sign, so our result is
     4B62 FE34     
15957                                                                          ; correct and we can return from the subroutine
15958               
15959               AR1:
15960                                                                          ; We want to calculate arctan(t) where |t| > 1, so we
15961                                                                          ; can use the calculation described in the documentation
15962                                                                          ; for the ACT table, i.e. 64 - arctan(1 / t)
15963 4B64 D3A0  30        movb @Q,rx                      ; LDX Q             ; Swap the values in Q and P, using the fact that we
     4B66 0090     
15964 4B68 D80D  30        movb ra,@Q                      ; STA Q             ; called AR1 with A = P
     4B6A 0090     
15965 4B6C D80E  30        movb rx,@P                      ; STX P             ;
     4B6E 001B     
15966 4B70 D34E  18        movb rx,ra                      ; TXA               ; This also sets A = P (which now contains the original
15967                                                                          ; argument |Q|)
15968               
15969 4B72 0200  20        li   rtmp,ARS1                  ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
     4B74 4BA8     
15970 4B76 06A0  32        bl   @jsr                       ;
     4B78 FE28     
15971                                                                          ;
15972                                                                          ; A = arctan(A / Q)
15973                                                                          ; = arctan(|Q / P|)
15974                                                                          ; = arctan(1 / |P / Q|)
15975               
15976 4B7A D80D  30        movb ra,@T                      ; STA T             ; Set T = 64 - T
     4B7C 00D1     
15977 4B7E 020D  20        li   ra,>40*256                 ; LDA #64
     4B80 4000     
15978                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 4B82 1801  14        joc  !
0002 4B84 7347  18        sb   rone,ra
0003               !:
0004 4B86 7360  30        sb   @T,ra
     4B88 00D1     
                   < elite.a99
15979               
15980 4B8A 18E7  14        joc  AR4                        ; BCS AR4           ; Jump to AR4 to continue the calculation (this BCS is
15981                                                                          ; effectively a JMP as the subtraction will never
15982                                                                          ; underflow, as ARS1 returns values in the range 0-31)
15983               
15984               AR2:
15985                                                                          ; If we get here then Q = 0, so tan(A) = infinity and
15986                                                                          ; A is a right angle, or 0.25 of a circle. We allocate
15987                                                                          ; 255 to a full circle, so we should return 63 for a
15988                                                                          ; right angle
15989 4B8C 020D  20        li   ra,>3f*256                 ; LDA #63           ; Set A to 63, to represent a right angle
     4B8E 3F00     
15990               
15991 4B90 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4B92 FE34     
15992               
15993               AR3:
15994                                                                          ; A contains arctan(|P / Q|) but P and Q have different
15995                                                                          ; signs, so we need to return arctan(-|P / Q|), using
15996                                                                          ; the calculation described in the documentation for the
15997                                                                          ; ACT table, i.e. 128 - A
15998 4B94 D80D  30        movb ra,@T                      ; STA T             ; Set A = 128 - A
     4B96 00D1     
15999 4B98 020D  20        li   ra,>80*256                 ; LDA #128          ;
     4B9A 8000     
16000               * SEC                    \ The SEC instruction is commented out in the original
16001                      .sbc @T,ra                      ; SBC T             ; source, and isn't required as we did a SEC before
     **** ****     > SBC
0001 4B9C 1801  14        joc  !
0002 4B9E 7347  18        sb   rone,ra
0003               !:
0004 4BA0 7360  30        sb   @T,ra
     4BA2 00D1     
                   < elite.a99
16002                                                                          ; calling AR3
16003               
16004 4BA4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4BA6 FE34     
16005               
16006               ARS1:
16007                                                                          ; This routine fetches arctan(A / Q) from the ACT table,
16008                                                                          ; so A will be set to an integer in the range 0 to 31
16009                                                                          ; that represents an angle from 0 to 45 degrees (or 0 to
16010                                                                          ; PI / 4 radians)
16011 4BA8 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     4BAA DB2C     
16012 4BAC 06A0  32        bl   @jsr                       ;
     4BAE FE28     
16013                                                                          ;
16014                                                                          ; R = 256 * A / Q
16015               
16016 4BB0 D360  30        movb @R,ra                      ; LDA R             ; Set X = R / 8
     4BB2 0091     
16017 4BB4 091D  18        srl  ra,1                       ; LSR A             ; = 32 * A / Q
16018 4BB6 091D  18        srl  ra,1                       ; LSR A             ;
16019 4BB8 091D  18        srl  ra,1                       ; LSR A             ; so X has the value t * 32 where t = A / Q, which is
16020 4BBA D38D  18        movb ra,rx                      ; TAX               ; what we need to look up values in the ACT table
16021               
16022 4BBC 06CE  14        swpb rx                         ;
16023 4BBE D36E  34        movb @ACT(rx),ra                ; LDA ACT,X         ; Fetch ACT+X from the ACT table into A, so now:
     4BC0 4BC8     
16024 4BC2 06CE  14        swpb rx                         ;
16025                                                                          ;
16026                                                                          ; A = value in ACT + X
16027                                                                          ; = value in ACT + (32 * A / Q)
16028                                                                          ; = arctan(A / Q)
16029               
16030 4BC4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4BC6 FE34     
16031               
16032               * ******************************************************************************
16033               *
16034               * Name: ACT
16035               * Type: Variable
16036               * Category: Maths (Geometry)
16037               * Summary: Arctan table
16038               * Deep dive: The sine, cosine and arctan tables
16039               *
16040               * ------------------------------------------------------------------------------
16041               *
16042               * This table contains lookup values for arctangent calculations involving angles
16043               * in the range 0 to 45 degrees (or 0 to PI / 4 radians).
16044               *
16045               * To calculate the value of theta in the following:
16046               *
16047               * theta = arctan(t)
16048               *
16049               * where 0 <= t < 1, we look up the value in:
16050               *
16051               * ACT + (t * 32)
16052               *
16053               * The result will be an integer representing the angle in radians, where 256
16054               * represents a full circle of 360 degrees (2 * PI radians). The result of the
16055               * lookup will therefore be an integer in the range 0 to 31, as this represents
16056               * 0 to 45 degrees (0 to PI / 4 radians).
16057               *
16058               * The table does not support values of t >= 1 or t < 0 directly, so if we need
16059               * to calculate the arctangent for an angle greater than 45 degrees, we can apply
16060               * the following calculation to the result from the table:
16061               *
16062               * * For t > 1, arctan(t) = 64 - arctan(1 / t)
16063               *
16064               * For negative values of t where -1 < t < 0, we can apply the following
16065               * calculation to the result from the table:
16066               *
16067               * * For t < 0, arctan(-t) = 128 - arctan(t)
16068               *
16069               * Finally, if t < -1, we can do the first calculation to get arctan(|t|), and
16070               * the second to get arctan(-|t|).
16071               *
16072               * ******************************************************************************
16073               
16074               ACT:
16075                      ; FOR I%, 0, 31
16076               
16077                      ; EQUB INT((128 / PI) * ATN(I% / 32) + 0.5) ;
16078               
16079                      ; NEXT
16080               
16081 4BC8 12              byte >12
16082 4BC9   13            byte >13
16083 4BCA 14              byte >14
16084 4BCB   15            byte >15
16085 4BCC 16              byte >16
16086 4BCD   17            byte >17
16087 4BCE 18              byte >18
16088 4BCF   19            byte >19
16089 4BD0 1A              byte >1a
16090 4BD1   1B            byte >1b
16091 4BD2 1B              byte >1b
16092 4BD3   1C            byte >1c
16093 4BD4 1D              byte >1d
16094 4BD5   1D            byte >1d
16095 4BD6 1E              byte >1e
16096 4BD7   1F            byte >1f
16097 4BD8 20              byte >20
16098 4BD9   20            byte >20
16099 4BDA 21              byte >21
16100 4BDB   21            byte >21
16101 4BDC 22              byte >22
16102 4BDD   22            byte >22
16103 4BDE 23              byte >23
16104 4BDF   24            byte >24
16105 4BE0 24              byte >24
16106 4BE1   24            byte >24
16107 4BE2 25              byte >25
16108 4BE3   25            byte >25
16109 4BE4 26              byte >26
16110 4BE5   26            byte >26
16111 4BE6 27              byte >27
16112 4BE7   27            byte >27
16113               
16114               * ******************************************************************************
16115               *
16116               * Name: WARP
16117               * Type: Subroutine
16118               * Category: Flight
16119               * Summary: Perform an in-system jump
16120               *
16121               * ------------------------------------------------------------------------------
16122               *
16123               * This is called when we press "J" during flight. The following checks are
16124               * performed:
16125               *
16126               * * Make sure we don't have any ships or space stations in the vicinity
16127               *
16128               * * Make sure we are not in witchspace
16129               *
16130               * * If we are facing the planet, make sure we aren't too close
16131               *
16132               * * If we are facing the sun, make sure we aren't too close
16133               *
16134               * If the above checks are passed, then we perform an in-system jump by moving
16135               * the sun and planet in the opposite direction to travel, so we appear to jump
16136               * in space. This means that any asteroids, cargo canisters or escape pods get
16137               * dragged along for the ride.
16138               *
16139               * ******************************************************************************
16140               
16141               WARP:
16152               
16153 4BE8 D360  30        movb @MANY+AST,ra               ; LDA MANY+AST      ; Set X to the total number of asteroids, escape pods
     4BEA 0D57     
16154                      .clc                            ; CLC               ; and cargo canisters in the vicinity
     **** ****     > CLC
0001 4BEC 0A16  18        sla  rzero,1
                   < elite.a99
16155                      .adc @MANY+ESC,ra               ; ADC MANY+ESC      ;
     **** ****     > ADC
0001 4BEE 1701  14        jnc  !
0002 4BF0 B347  18        ab   rone,ra
0003               !:
0004 4BF2 B360  30        ab   @MANY+ESC,ra
     4BF4 0D5A     
                   < elite.a99
16156                      .adc @MANY+OIL,ra               ; ADC MANY+OIL      ; This code saves one byte of memory over the code in
     **** ****     > ADC
0001 4BF6 1701  14        jnc  !
0002 4BF8 B347  18        ab   rone,ra
0003               !:
0004 4BFA B360  30        ab   @MANY+OIL,ra
     4BFC 0D58     
                   < elite.a99
16157 4BFE D38D  18        movb ra,rx                      ; TAX               ; the source disc version. The second CLC is not needed
16158                                                                          ; as there is no way that adding the number of asteroids
16159                                                                          ; and the number of escape pods will cause a carry
16160               
16162               
16163 4C00 06CE  14        swpb rx                         ;
16164 4C02 D36E  34        movb @FRIN+2(rx),ra             ; LDA FRIN+2,X      ; If the slot at FRIN+2+X is non-zero, then we have
     4C04 0D42     
16165 4C06 06CE  14        swpb rx                         ;
16166                                                                          ; something else in the vicinity besides asteroids,
16167                                                                          ; escape pods and cargo canisters, so to check whether
16168                                                                          ; we can jump, we first grab the slot contents into A
16169               
16170 4C08 F360  30        socb @SSPR,ra                   ; ORA SSPR          ; If there is a space station nearby, then SSPR will
     4C0A 0D55     
16171                                                                          ; be non-zero, so OR'ing with SSPR will produce a
16172                                                                          ; non-zero result if either A or SSPR are non-zero
16173               
16174 4C0C F360  30        socb @MJ,ra                     ; ORA MJ            ; If we are in witchspace, then MJ will be non-zero, so
     4C0E 0D5C     
16175                                                                          ; OR'ing with MJ will produce a non-zero result if
16176                                                                          ; either A or SSPR or MJ are non-zero
16177               
16178 4C10 163A  14        jne  WA1                        ; BNE WA1           ; A is non-zero if we have either a ship or a space
16179                                                                          ; station in the vicinity, or we are in witchspace, in
16180                                                                          ; which case jump to WA1 to make a low beep to show that
16181                                                                          ; we can't do an in-system jump
16182               
16183 4C12 D3E0  30        movb @K.+8,ry                   ; LDY K%+8          ; Otherwise we can do an in-system jump, so now we fetch
     4C14 0908     
16184                                                                          ; the byte at K%+8, which contains the z_sign for the
16185                                                                          ; first ship slot, i.e. the distance of the planet
16186               
16187 4C16 1107  14        jlt  WA3                        ; BMI WA3           ; If the planet's z_sign is negative, then the planet
16188                                                                          ; is behind us, so jump to WA3 to skip the following
16189               
16190 4C18 D3CD  18        movb ra,ry                      ; TAY               ; Set A = Y = 0 (as we didn't BNE above) so the call
16191                                                                          ; to MAS2 measures the distance to the planet
16192               
16193 4C1A 0200  20        li   rtmp,MAS2                  ; JSR MAS2          ; Call MAS2 to set A to the largest distance to the
     4C1C 17D6     
16194 4C1E 06A0  32        bl   @jsr                       ;
     4C20 FE28     
16195                                                                          ; planet in any of the three axes (we could also call
16196                                                                          ; routine m to do the same thing, as A = 0)
16197               
16205               
16206 4C22 091D  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
16207 4C24 1330  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
16208                                                                          ; too close to jump in that direction
16209                                                                          ;
16210                                                                          ; These instructions between them save one byte of
16211                                                                          ; memory over the CMP-based code in the source disc
16212                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
16213                                                                          ; takes up two bytes (though the code does exactly the
16214                                                                          ; same thing)
16215               
16217               
16218               WA3:
16219 4C26 D3E0  30        movb @K.+NI.+8,ry               ; LDY K%+NI%+8      ; Fetch the z_sign (byte #8) of the second ship in the
     4C28 092C     
16220                                                                          ; ship data workspace at K%, which is reserved for the
16221                                                                          ; sun or the space station (in this case it's the
16222                                                                          ; former, as we already confirmed there isn't a space
16223                                                                          ; station in the vicinity)
16224               
16225 4C2A 1108  14        jlt  WA2                        ; BMI WA2           ; If the sun's z_sign is negative, then the sun is
16226                                                                          ; behind us, so jump to WA2 to skip the following
16227               
16228 4C2C 020F  20        li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to point to the offset of the ship data block
     4C2E 2400     
16229                                                                          ; for the sun, which is NI% (as each block is NI% bytes
16230                                                                          ; long, and the sun is the second block)
16231               
16232 4C30 0200  20        li   rtmp,m_                    ; JSR m             ; Call m to set A to the largest distance to the sun
     4C32 17D2     
16233 4C34 06A0  32        bl   @jsr                       ;
     4C36 FE28     
16234                                                                          ; in any of the three axes
16235               
16243               
16244 4C38 091D  18        srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
16245 4C3A 1325  14        jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
16246                                                                          ; too close to jump in that direction
16247                                                                          ;
16248                                                                          ; These instructions between them save one byte of
16249                                                                          ; memory over the CMP-based code in the source disc
16250                                                                          ; version, as LSR A is a one-byte opcode, while CMP #2
16251                                                                          ; takes up two bytes (though the code does exactly the
16252                                                                          ; same thing)
16253               
16255               
16256               WA2:
16257                                                                          ; If we get here, then we can do an in-system jump, as
16258                                                                          ; we don't have any ships or space stations in the
16259                                                                          ; vicinity, we are not in witchspace, and if we are
16260                                                                          ; facing the planet or the sun, we aren't too close to
16261                                                                          ; jump towards it
16262                                                                          ;
16263                                                                          ; We do an in-system jump by moving the sun and planet,
16264                                                                          ; rather than moving our own local bubble (this is why
16265                                                                          ; in-system jumps drag asteroids, cargo canisters and
16266                                                                          ; escape pods along for the ride). Specifically, we move
16267                                                                          ; them in the z-axis by a fixed amount in the opposite
16268                                                                          ; direction to travel, thus performing a jump towards
16269                                                                          ; our destination
16270 4C3C 020D  20        li   ra,>81*256                 ; LDA #&81          ; Set R = R = P = &81
     4C3E 8100     
16271 4C40 D80D  30        movb ra,@S                      ; STA S
     4C42 0092     
16272 4C44 D80D  30        movb ra,@R                      ; STA R
     4C46 0091     
16273 4C48 D80D  30        movb ra,@P                      ; STA P
     4C4A 001B     
16274               
16275 4C4C D360  30        movb @K.+8,ra                   ; LDA K%+8          ; Set A = z_sign for the planet
     4C4E 0908     
16276               
16277 4C50 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     4C52 4862     
16278 4C54 06A0  32        bl   @jsr                       ;
     4C56 FE28     
16279                                                                          ; = (z_sign &81) + &8181
16280                                                                          ; = (z_sign &81) - &0181
16281                                                                          ;
16282                                                                          ; This moves the planet against the direction of travel
16283                                                                          ; by reducing z_sign by 1, as the above maths is:
16284                                                                          ;
16285                                                                          ; z_sign 00000000
16286                                                                          ; +   00000000 10000001
16287                                                                          ; -   00000001 10000001
16288                                                                          ;
16289                                                                          ; or:
16290                                                                          ;
16291                                                                          ; z_sign 00000000
16292                                                                          ; +   00000000 00000000
16293                                                                          ; -   00000001 00000000
16294                                                                          ;
16295                                                                          ; i.e. the high byte is z_sign - 1, making sure the sign
16296                                                                          ; is preserved
16297               
16298 4C58 D80D  30        movb ra,@K.+8                   ; STA K%+8          ; Set the planet's z_sign to the high byte of the result
     4C5A 0908     
16299               
16300 4C5C D360  30        movb @K.+NI.+8,ra               ; LDA K%+NI%+8      ; Set A = z_sign for the sun
     4C5E 092C     
16301               
16302 4C60 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     4C62 4862     
16303 4C64 06A0  32        bl   @jsr                       ;
     4C66 FE28     
16304                                                                          ; = (z_sign &81) + &8181
16305                                                                          ; = (z_sign &81) - &0181
16306                                                                          ;
16307                                                                          ; which moves the sun against the direction of travel
16308                                                                          ; by reducing z_sign by 1
16309               
16310 4C68 D80D  30        movb ra,@K.+NI.+8               ; STA K%+NI%+8      ; Set the planet's z_sign to the high byte of the result
     4C6A 092C     
16311               
16312 4C6C 020D  20        li   ra,>01*256                 ; LDA #1            ; Temporarily set the view type to a non-zero value, so
     4C6E 0100     
16313 4C70 D80D  30        movb ra,@QQ11                   ; STA QQ11          ; the call to LOOK1 below clears the screen before
     4C72 0096     
16314                                                                          ; switching to the space view
16315               
16316 4C74 D80D  30        movb ra,@MCNT                   ; STA MCNT          ; Set the main loop counter to 1, so the next iteration
     4C76 0099     
16317                                                                          ; through the main loop will potentially spawn ships
16318                                                                          ; (see part 2 of the main game loop at me3)
16319               
16320 4C78 091D  18        srl  ra,1                       ; LSR A             ; Set EV, the extra vessels spawning counter, to 0
16321 4C7A D80D  30        movb ra,@EV                     ; STA EV            ; (the LSR produces a 0 as A was previously 1)
     4C7C 0D63     
16322               
16323 4C7E D3A0  30        movb @VIEW,rx                   ; LDX VIEW          ; Set X to the current view (front, rear, left or right)
     4C80 0D5F     
16324 4C82 0460  28        b    @LOOK1                     ; JMP LOOK1         ; and jump to LOOK1 to initialise that view, returning
     4C84 4E90     
16325                                                                          ; from the subroutine using a tail call
16326               
16327               WA1:
16328 4C86 020D  20        li   ra,>28*256                 ; LDA #40           ; If we get here then we can't do an in-system jump, so
     4C88 2800     
16329 4C8A 0460  28        b    @NOISE                     ; JMP NOISE         ; call the NOISE routine with A = 40 to make a long, low
     4C8C D340     
16330                                                                          ; beep and return from the subroutine using a tail call
16331               
16332               * ******************************************************************************
16333               *
16334               * Name: LASLI
16335               * Type: Subroutine
16336               * Category: Drawing lines
16337               * Summary: Draw the laser lines for when we fire our lasers
16338               *
16339               * ------------------------------------------------------------------------------
16340               *
16341               * Draw the laser lines, aiming them to slightly different place each time so
16342               * they appear to flicker and dance. Also heat up the laser temperature and drain
16343               * some energy.
16344               *
16345               * ------------------------------------------------------------------------------
16346               *
16347               * Other entry points:
16348               *
16349               * LASLI2              Just draw the current laser lines without moving the
16350               * centre point, draining energy or heating up. This has
16351               * the effect of removing the lines from the screen
16352               *
16353               * LASLI-1             Contains an RTS
16354               *
16355               * ******************************************************************************
16356               
16357               LASLI:
16358 4C8E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     4C90 C7D0     
16359 4C92 06A0  32        bl   @jsr                       ;
     4C94 FE28     
16360               
16361 4C96 024D  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     4C98 0700     
16362               
16363                      .adi ((Y-4)*256)                ; ADC #Y-4          ; Set LASY to four pixels above the centre of the
     **** ****     > ADI
0001 4C9A 1701  14        jnc  !
0002 4C9C B347  18        ab   rone,ra
0003               !:
0004 4C9E 022D  22        ai   ra,((Y-4)*256)
     4CA0 5C00     
                   < elite.a99
16364 4CA2 D80D  30        movb ra,@LASY                   ; STA LASY          ; screen (#Y), plus our random number, so the laser
     4CA4 0F15     
16365                                                                          ; dances above and below the centre point
16366               
16367 4CA6 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     4CA8 C7D0     
16368 4CAA 06A0  32        bl   @jsr                       ;
     4CAC FE28     
16369               
16370 4CAE 024D  22        andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7
     4CB0 0700     
16371               
16372                      .adi ((X-4)*256)                ; ADC #X-4          ; Set LASX to four pixels left of the centre of the
     **** ****     > ADI
0001 4CB2 1701  14        jnc  !
0002 4CB4 B347  18        ab   rone,ra
0003               !:
0004 4CB6 022D  22        ai   ra,((X-4)*256)
     4CB8 7C00     
                   < elite.a99
16373 4CBA D80D  30        movb ra,@LASX                   ; STA LASX          ; screen (#X), plus our random number, so the laser
     4CBC 0F14     
16374                                                                          ; dances to the left and right of the centre point
16375               
16376 4CBE D360  30        movb @GNTMP,ra                  ; LDA GNTMP         ; Add 8 to the laser temperature in GNTMP
     4CC0 0D61     
16377                      .adi (>08*256)                  ; ADC #8
     **** ****     > ADI
0001 4CC2 1701  14        jnc  !
0002 4CC4 B347  18        ab   rone,ra
0003               !:
0004 4CC6 022D  22        ai   ra,(>08*256)
     4CC8 0800     
                   < elite.a99
16378 4CCA D80D  30        movb ra,@GNTMP                  ; STA GNTMP
     4CCC 0D61     
16379               
16380 4CCE 0200  20        li   rtmp,DENGY                 ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1
     4CD0 B306     
16381 4CD2 06A0  32        bl   @jsr                       ;
     4CD4 FE28     
16382               
16383               LASLI2:
16384 4CD6 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
     4CD8 0096     
16385 4CDA 1632  14        jne  PU1-1                      ; BNE PU1-1         ; then jump to MA9 to return from the main flight loop
16386                                                                          ; (as PU1-1 is an RTS)
16387               
16388 4CDC 020D  20        li   ra,>20*256                 ; LDA #32           ; Set A = 32 and Y = 224 for the first set of laser
     4CDE 2000     
16389 4CE0 020F  20        li   ry,>e0*256                 ; LDY #224          ; lines (the wider pair of lines)
     4CE2 E000     
16390               
16391 4CE4 0200  20        li   rtmp,las_                  ; JSR las           ; Call las below to draw the first set of laser lines
     4CE6 4CF4     
16392 4CE8 06A0  32        bl   @jsr                       ;
     4CEA FE28     
16393               
16394 4CEC 020D  20        li   ra,>30*256                 ; LDA #48           ; Fall through into las with A = 48 and Y = 208 to draw
     4CEE 3000     
16395 4CF0 020F  20        li   ry,>d0*256                 ; LDY #208          ; a second set of lines (the narrower pair)
     4CF2 D000     
16396               
16397                                                                          ; The following routine draws two laser lines, one from
16398                                                                          ; the centre point down to point A on the bottom row,
16399                                                                          ; and the other from the centre point down to point Y
16400                                                                          ; on the bottom row. We therefore get lines from the
16401                                                                          ; centre point to points 32, 48, 208 and 224 along the
16402                                                                          ; bottom row, giving us the triangular laser effect
16403                                                                          ; we're after
16404               
16405               las_:
16406 4CF4 D80D  30        movb ra,@X2                     ; STA X2            ; Set X2 = A
     4CF6 0033     
16407               
16408 4CF8 D360  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     4CFA 0F14     
16409 4CFC D80D  30        movb ra,@X1                     ; STA X1
     4CFE 0031     
16410 4D00 D360  30        movb @LASY,ra                   ; LDA LASY
     4D02 0F15     
16411 4D04 D80D  30        movb ra,@Y1                     ; STA Y1
     4D06 0032     
16412               
16413 4D08 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4D0A BF00     
16414 4D0C D80D  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     4D0E 0034     
16415                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16416                                                                          ; pixel row of the space view
16417               
16418 4D10 0200  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     4D12 23BE     
16419 4D14 06A0  32        bl   @jsr                       ;
     4D16 FE28     
16420                                                                          ; the centre point to (A, 191)
16421               
16422 4D18 D360  30        movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
     4D1A 0F14     
16423 4D1C D80D  30        movb ra,@X1                     ; STA X1
     4D1E 0031     
16424 4D20 D360  30        movb @LASY,ra                   ; LDA LASY
     4D22 0F15     
16425 4D24 D80D  30        movb ra,@Y1                     ; STA Y1
     4D26 0032     
16426               
16427 4D28 D80F  30        movb ry,@X2                     ; STY X2            ; Set X2 = Y
     4D2A 0033     
16428               
16429 4D2C 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
     4D2E BF00     
16430 4D30 D80D  30        movb ra,@Y2                     ; STA Y2            ; pixel row of the space view (as before)
     4D32 0034     
16431               
16432 4D34 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
     4D36 23BE     
16433                                                                          ; the centre point to (Y, 191), and return from
16434                                                                          ; the subroutine using a tail call
16435               
16436               * ******************************************************************************
16437               *
16438               * Name: PLUT
16439               * Type: Subroutine
16440               * Category: Flight
16441               * Summary: Flip the coordinate axes for the four different views
16442               * Deep dive: Flipping axes between space views
16443               *
16444               * ------------------------------------------------------------------------------
16445               *
16446               * This routine flips the relevant geometric axes in INWK depending on which
16447               * view we are looking through (front, rear, left, right).
16448               *
16449               * ------------------------------------------------------------------------------
16450               *
16451               * Other entry points:
16452               *
16453               * PU1-1               Contains an RTS
16454               *
16455               * ******************************************************************************
16456               
16457               PLUT:
16458 4D38 D3A0  30        movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
     4D3A 0D5F     
16459                                                                          ;
16460                                                                          ; 0 = front
16461                                                                          ; 1 = rear
16462                                                                          ; 2 = left
16463                                                                          ; 3 = right
16464               
16465 4D3C 1602  14        jne  PU1                        ; BNE PU1           ; If the current view is the front view, return from the
16466 4D3E 0460  28        b    @rts                       ; RTS               ; subroutine, as the geometry in INWK is already correct
     4D40 FE34     
16467               
16468               PU1:
16469 4D42 7387  18        sb   rone,rx                    ; DEX               ; Decrement the view, so now:
16470                                                                          ;
16471                                                                          ; 0 = rear
16472                                                                          ; 1 = left
16473                                                                          ; 2 = right
16474               
16475 4D44 163A  14        jne  PU2                        ; BNE PU2           ; If the current view is left or right, jump to PU2,
16476                                                                          ; otherwise this is the rear view, so continue on
16477               
16478 4D46 D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Flip the sign of x_sign
     4D48 0055     
16479                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4D4A 0200  20        li   rtmp,(>80*256)
     4D4C 8000     
0002 4D4E 2B40  18        xor  rtmp,ra
                   < elite.a99
16480 4D50 D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     4D52 0055     
16481               
16482 4D54 D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Flip the sign of z_sign
     4D56 005B     
16483                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4D58 0200  20        li   rtmp,(>80*256)
     4D5A 8000     
0002 4D5C 2B40  18        xor  rtmp,ra
                   < elite.a99
16484 4D5E D80D  30        movb ra,@INWK+8                 ; STA INWK+8
     4D60 005B     
16485               
16486 4D62 D360  30        movb @INWK+10,ra                ; LDA INWK+10       ; Flip the sign of nosev_x_hi
     4D64 005D     
16487                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4D66 0200  20        li   rtmp,(>80*256)
     4D68 8000     
0002 4D6A 2B40  18        xor  rtmp,ra
                   < elite.a99
16488 4D6C D80D  30        movb ra,@INWK+10                ; STA INWK+10
     4D6E 005D     
16489               
16490 4D70 D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; Flip the sign of nosev_z_hi
     4D72 0061     
16491                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4D74 0200  20        li   rtmp,(>80*256)
     4D76 8000     
0002 4D78 2B40  18        xor  rtmp,ra
                   < elite.a99
16492 4D7A D80D  30        movb ra,@INWK+14                ; STA INWK+14
     4D7C 0061     
16493               
16494 4D7E D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Flip the sign of roofv_x_hi
     4D80 0063     
16495                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4D82 0200  20        li   rtmp,(>80*256)
     4D84 8000     
0002 4D86 2B40  18        xor  rtmp,ra
                   < elite.a99
16496 4D88 D80D  30        movb ra,@INWK+16                ; STA INWK+16
     4D8A 0063     
16497               
16498 4D8C D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Flip the sign of roofv_z_hi
     4D8E 0067     
16499                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4D90 0200  20        li   rtmp,(>80*256)
     4D92 8000     
0002 4D94 2B40  18        xor  rtmp,ra
                   < elite.a99
16500 4D96 D80D  30        movb ra,@INWK+20                ; STA INWK+20
     4D98 0067     
16501               
16502 4D9A D360  30        movb @INWK+22,ra                ; LDA INWK+22       ; Flip the sign of sidev_x_hi
     4D9C 0069     
16503                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4D9E 0200  20        li   rtmp,(>80*256)
     4DA0 8000     
0002 4DA2 2B40  18        xor  rtmp,ra
                   < elite.a99
16504 4DA4 D80D  30        movb ra,@INWK+22                ; STA INWK+22
     4DA6 0069     
16505               
16506 4DA8 D360  30        movb @INWK+26,ra                ; LDA INWK+26       ; Flip the sign of roofv_z_hi
     4DAA 006D     
16507                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 4DAC 0200  20        li   rtmp,(>80*256)
     4DAE 8000     
0002 4DB0 2B40  18        xor  rtmp,ra
                   < elite.a99
16508 4DB2 D80D  30        movb ra,@INWK+26                ; STA INWK+26
     4DB4 006D     
16509               
16510 4DB6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4DB8 FE34     
16511               
16512               PU2:
16513                                                                          ; We enter this with X set to the view, as follows:
16514                                                                          ;
16515                                                                          ; 1 = left
16516                                                                          ; 2 = right
16517 4DBA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set RAT2 = 0 (left view) or -1 (right view)
     4DBC 0000     
16518 4DBE 028E  22        ci   rx,>02*256                 ; CPX #2
     4DC0 0200     
16519 4DC2 06A0  32        bl   @rora                      ; ROR A
     4DC4 FE62     
16520 4DC6 D80D  30        movb ra,@RAT2                   ; STA RAT2
     4DC8 00AB     
16521               
16522                      .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT = -1 (left view) or 0 (right view)
     **** ****     > EOI
0001 4DCA 0200  20        li   rtmp,(>80*256)
     4DCC 8000     
0002 4DCE 2B40  18        xor  rtmp,ra
                   < elite.a99
16523 4DD0 D80D  30        movb ra,@RAT                    ; STA RAT
     4DD2 00AA     
16524               
16525 4DD4 D360  30        movb @INWK,ra                   ; LDA INWK          ; Swap x_lo and z_lo
     4DD6 0053     
16526 4DD8 D3A0  30        movb @INWK+6,rx                 ; LDX INWK+6
     4DDA 0059     
16527 4DDC D80D  30        movb ra,@INWK+6                 ; STA INWK+6
     4DDE 0059     
16528 4DE0 D80E  30        movb rx,@INWK                   ; STX INWK
     4DE2 0053     
16529               
16530 4DE4 D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Swap x_hi and z_hi
     4DE6 0054     
16531 4DE8 D3A0  30        movb @INWK+7,rx                 ; LDX INWK+7
     4DEA 005A     
16532 4DEC D80D  30        movb ra,@INWK+7                 ; STA INWK+7
     4DEE 005A     
16533 4DF0 D80E  30        movb rx,@INWK+1                 ; STX INWK+1
     4DF2 0054     
16534               
16535 4DF4 D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Swap x_sign and z_sign
     4DF6 0055     
16536                      .eor @RAT                       ; EOR RAT           ; If left view, flip sign of new z_sign
     **** ****     > EOR
0001 4DF8 D020  30        movb @RAT,rtmp
     4DFA 00AA     
0002 4DFC 2B40  18        xor  rtmp,ra
                   < elite.a99
16537 4DFE D38D  18        movb ra,rx                      ; TAX               ; If right view, flip sign of new x_sign
16538 4E00 D360  30        movb @INWK+8,ra                 ; LDA INWK+8
     4E02 005B     
16539                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4E04 D020  30        movb @RAT2,rtmp
     4E06 00AB     
0002 4E08 2B40  18        xor  rtmp,ra
                   < elite.a99
16540 4E0A D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     4E0C 0055     
16541 4E0E D80E  30        movb rx,@INWK+8                 ; STX INWK+8
     4E10 005B     
16542               
16543 4E12 020F  20        li   ry,>09*256                 ; LDY #9            ; Swap nosev_x_lo and nosev_z_lo
     4E14 0900     
16544 4E16 0200  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap nosev_x_hi and nosev_z_hi
     4E18 4E2E     
16545 4E1A 06A0  32        bl   @jsr                       ;
     4E1C FE28     
16546                                                                          ; If left view, flip sign of new nosev_z_hi
16547                                                                          ; If right view, flip sign of new nosev_x_hi
16548               
16549 4E1E 020F  20        li   ry,>0f*256                 ; LDY #15           ; Swap roofv_x_lo and roofv_z_lo
     4E20 0F00     
16550 4E22 0200  20        li   rtmp,PUS1                  ; JSR PUS1          ; Swap roofv_x_hi and roofv_z_hi
     4E24 4E2E     
16551 4E26 06A0  32        bl   @jsr                       ;
     4E28 FE28     
16552                                                                          ; If left view, flip sign of new roofv_z_hi
16553                                                                          ; If right view, flip sign of new roofv_x_hi
16554               
16555 4E2A 020F  20        li   ry,>15*256                 ; LDY #21           ; Swap sidev_x_lo and sidev_z_lo
     4E2C 1500     
16556                                                                          ; Swap sidev_x_hi and sidev_z_hi
16557                                                                          ; If left view, flip sign of new sidev_z_hi
16558                                                                          ; If right view, flip sign of new sidev_x_hi
16559               
16560               PUS1:
16561 4E2E 06CF  14        swpb ry                         ;
16562 4E30 D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Swap the low x and z bytes for the vector in Y:
     4E32 0053     
16563 4E34 06CF  14        swpb ry                         ;
16564 4E36 06CF  14        swpb ry                         ;
16565 4E38 D3AF  34        movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ;
     4E3A 0057     
16566 4E3C 06CF  14        swpb ry                         ;
16567 4E3E 06CF  14        swpb ry                         ;
16568 4E40 DBCD  38        movb ra,@INWK+4(ry)             ; STA INWK+4,Y      ; * For Y =  9 swap nosev_x_lo and nosev_z_lo
     4E42 0057     
16569 4E44 06CF  14        swpb ry                         ;
16570 4E46 DBCE  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; * For Y = 15 swap roofv_x_lo and roofv_z_lo
     4E48 0053     
16571                                                                          ; * For Y = 21 swap sidev_x_lo and sidev_z_lo
16572               
16573 4E4A 06CF  14        swpb ry                         ;
16574 4E4C D36F  34        movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Swap the high x and z bytes for the offset in Y:
     4E4E 0054     
16575 4E50 06CF  14        swpb ry                         ;
16576                      .eor @RAT                       ; EOR RAT           ;
     **** ****     > EOR
0001 4E52 D020  30        movb @RAT,rtmp
     4E54 00AA     
0002 4E56 2B40  18        xor  rtmp,ra
                   < elite.a99
16577 4E58 D38D  18        movb ra,rx                      ; TAX               ; * If left view, flip sign of new z-coordinate
16578 4E5A 06CF  14        swpb ry                         ;
16579 4E5C D36F  34        movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; * If right view, flip sign of new x-coordinate
     4E5E 0058     
16580 4E60 06CF  14        swpb ry                         ;
16581                      .eor @RAT2                      ; EOR RAT2
     **** ****     > EOR
0001 4E62 D020  30        movb @RAT2,rtmp
     4E64 00AB     
0002 4E66 2B40  18        xor  rtmp,ra
                   < elite.a99
16582 4E68 06CF  14        swpb ry                         ;
16583 4E6A DBCD  38        movb ra,@INWK+1(ry)             ; STA INWK+1,Y
     4E6C 0054     
16584 4E6E 06CF  14        swpb ry                         ;
16585 4E70 DBCE  38        movb rx,@INWK+5(ry)             ; STX INWK+5,Y
     4E72 0058     
16586               
16587                                                                          ; Fall through into LOOK1 to return from the subroutine
16588               
16589               * ******************************************************************************
16590               *
16591               * Name: LOOK1
16592               * Type: Subroutine
16593               * Category: Flight
16594               * Summary: Initialise the space view
16595               *
16596               * ------------------------------------------------------------------------------
16597               *
16598               * Initialise the space view, with the direction of view given in X. This clears
16599               * the upper screen and draws the laser crosshairs, if the view in X has lasers
16600               * fitted. It also wipes all the ships from the scanner, so we can recalculate
16601               * ship positions for the new view (they get put back in the main flight loop).
16602               *
16603               * ------------------------------------------------------------------------------
16604               *
16605               * Arguments:
16606               *
16607               * X                   The space view to set:
16608               *
16609               * * 0 = front
16610               * * 1 = rear
16611               * * 2 = left
16612               * * 3 = right
16613               *
16614               * ------------------------------------------------------------------------------
16615               *
16616               * Other entry points:
16617               *
16618               * LO2                 Contains an RTS
16619               *
16620               * ******************************************************************************
16621               
16622               LO2:
16623 4E74 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4E76 FE34     
16624               
16625               LQ:
16626 4E78 D80E  30        movb rx,@VIEW                   ; STX VIEW          ; Set the current space view to X
     4E7A 0D5F     
16627               
16628 4E7C 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4E7E 4EFA     
16629 4E80 06A0  32        bl   @jsr                       ;
     4E82 FE28     
16630                                                                          ; and set the current view type in QQ11 to 0 (space
16631                                                                          ; view)
16632               
16633 4E84 0200  20        li   rtmp,SIGHT                 ; JSR SIGHT         ; Draw the laser crosshairs
     4E86 4EBC     
16634 4E88 06A0  32        bl   @jsr                       ;
     4E8A FE28     
16635               
16636 4E8C 0460  28        b    @NWSTARS                   ; JMP NWSTARS       ; Set up a new stardust field and return from the
     4E8E B1E6     
16637                                                                          ; subroutine using a tail call
16638               
16639               LOOK1:
16640 4E90 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, the type number of a space view
     4E92 0000     
16641               
16642 4E94 D3E0  30        movb @QQ11,ry                   ; LDY QQ11          ; If the current view is not a space view, jump up to LQ
     4E96 0096     
16643 4E98 16EF  14        jne  LQ                         ; BNE LQ            ; to set up a new space view
16644               
16645 4E9A 93A0  30        cb   @VIEW,rx                   ; CPX VIEW          ; If the current view is already of type X, jump to LO2
     4E9C 0D5F     
16646 4E9E 13EA  14        jeq  LO2                        ; BEQ LO2           ; to return from the subroutine (as LO2 contains an RTS)
16647               
16648 4EA0 D80E  30        movb rx,@VIEW                   ; STX VIEW          ; Change the current space view to X
     4EA2 0D5F     
16649               
16650 4EA4 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     4EA6 4EFA     
16651 4EA8 06A0  32        bl   @jsr                       ;
     4EAA FE28     
16652                                                                          ; and set the current view type in QQ11 to 0 (space
16653                                                                          ; view)
16654               
16655 4EAC 0200  20        li   rtmp,FLIP                  ; JSR FLIP          ; Swap the x- and y-coordinates of all the stardust
     4EAE 2B48     
16656 4EB0 06A0  32        bl   @jsr                       ;
     4EB2 FE28     
16657                                                                          ; particles and redraw the stardust field
16658               
16659 4EB4 0200  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all the ships from the scanner and mark them all
     4EB6 B23C     
16660 4EB8 06A0  32        bl   @jsr                       ;
     4EBA FE28     
16661                                                                          ; as not being shown on-screen
16662               
16663                                                                          ; And fall through into SIGHT to draw the laser
16664                                                                          ; crosshairs
16665               
16666               * ******************************************************************************
16667               *
16668               * Name: SIGHT
16669               * Type: Subroutine
16670               * Category: Flight
16671               * Summary: Draw the laser crosshairs
16672               *
16673               * ******************************************************************************
16674               
16675               SIGHT:
16676 4EBC D3E0  30        movb @VIEW,ry                   ; LDY VIEW          ; Fetch the laser power for our new view
     4EBE 0D5F     
16677 4EC0 06CF  14        swpb ry                         ;
16678 4EC2 D36F  34        movb @LASER(ry),ra              ; LDA LASER,Y
     4EC4 0310     
16679 4EC6 06CF  14        swpb ry                         ;
16680               
16681 4EC8 13D5  14        jeq  LO2                        ; BEQ LO2           ; If it is zero (i.e. there is no laser fitted to this
16682                                                                          ; view), jump to LO2 to return from the subroutine (as
16683                                                                          ; LO2 contains an RTS)
16684               
16685 4ECA 020D  20        li   ra,>80*256                 ; LDA #128          ; Set QQ19 to the x-coordinate of the centre of the
     4ECC 8000     
16686 4ECE D80D  30        movb ra,@QQ19                   ; STA QQ19          ; screen
     4ED0 007F     
16687               
16688 4ED2 020D  20        li   ra,(Y-24)*256              ; LDA #Y-24         ; Set QQ19+1 to the y-coordinate of the centre of the
     4ED4 4800     
16689 4ED6 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; screen, minus 24 (because TT15 will add 24 to the
     4ED8 0080     
16690                                                                          ; coordinate when it draws the crosshairs)
16691               
16692 4EDA 020D  20        li   ra,>14*256                 ; LDA #20           ; Set QQ19+2 to size 20 for the crosshairs size
     4EDC 1400     
16693 4EDE D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4EE0 0081     
16694               
16695 4EE2 0200  20        li   rtmp,TT15                  ; JSR TT15          ; Call TT15 to draw crosshairs of size 20 just to the
     4EE4 56FE     
16696 4EE6 06A0  32        bl   @jsr                       ;
     4EE8 FE28     
16697                                                                          ; left of the middle of the screen
16698               
16699 4EEA 020D  20        li   ra,>0a*256                 ; LDA #10           ; Set QQ19+2 to size 10 for the crosshairs size
     4EEC 0A00     
16700 4EEE D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     4EF0 0081     
16701               
16702 4EF2 0460  28        b    @TT15                      ; JMP TT15          ; Call TT15 to draw crosshairs of size 10 at the same
     4EF4 56FE     
16703                                                                          ; location, which will remove the centre part from the
16704                                                                          ; laser crosshairs, leaving a gap in the middle, and
16705                                                                          ; return from the subroutine using a tail call
16706               
16707               * ******************************************************************************
16708               *
16709               * Name: TT66
16710               * Type: Subroutine
16711               * Category: Drawing the screen
16712               * Summary: Clear the screen and set the current view type
16713               *
16714               * ------------------------------------------------------------------------------
16715               *
16716               * Clear the top part of the screen, draw a white border, and set the current
16717               * view type in QQ11 to A.
16718               *
16719               * ------------------------------------------------------------------------------
16720               *
16721               * Arguments:
16722               *
16723               * A                   The type of the new current view (see QQ11 for a list of
16724               * view types)
16725               *
16726               * ------------------------------------------------------------------------------
16727               *
16728               * Other entry points:
16729               *
16730               * TT66-2              Call TT66 with A = 1
16731               *
16732               * ******************************************************************************
16733               
16734 4EF6 020D  20        li   ra,>01*256                 ; LDA #1            ; Set the view type to 1 when this is called via the
     4EF8 0100     
16735                                                                          ; TT66-2 entry point
16736               
16737               TT66:
16738 4EFA D80D  30        movb ra,@QQ11                   ; STA QQ11          ; Set the current view type in QQ11 to A
     4EFC 0096     
16739               
16740                                                                          ; Fall through into TTX66 to clear the screen and draw a
16741                                                                          ; white border
16742               
16743               * ******************************************************************************
16744               *
16745               * Name: TTX66
16746               * Type: Subroutine
16747               * Category: Drawing the screen
16748               * Summary: Clear the top part of the screen and draw a white border
16749               *
16750               * ------------------------------------------------------------------------------
16751               *
16752               * Clear the top part of the screen (the space view) and draw a white border
16753               * along the top and sides.
16754               *
16755               * ------------------------------------------------------------------------------
16756               *
16757               * Other entry points:
16758               *
16759               * BOX                 Just draw the border and (if this is a space view) the
16760               * view name. This can be used to remove the border and
16761               * view name, as it is drawn using EOR logic
16762               *
16763               * ******************************************************************************
16764               
16765               TTX66:
16766 4EFE 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     4F00 8000     
16767 4F02 D80D  30        movb ra,@QQ17                   ; STA QQ17
     4F04 007E     
16768               
16775               
16776                      .asla                           ; ASL A             ; Set LAS2 to 0, as 128 << 1 = %10000000 << 1 = 0. This
     **** ****     > ASLA
0001 4F06 024D  22        andi ra,>ff00
     4F08 FF00     
0002 4F0A 0A1D  18        sla  ra,1
                   < elite.a99
16777 4F0C D80D  30        movb ra,@LAS2                   ; STA LAS2          ; stops any laser pulsing
     4F0E 0D5D     
16778               
16780               
16781 4F10 D80D  30        movb ra,@DLY                    ; STA DLY           ; Set the delay in DLY to 0, to indicate that we are
     4F12 0D64     
16782                                                                          ; no longer showing an in-flight message, so any new
16783                                                                          ; in-flight messages will be shown instantly
16784               
16785 4F14 D80D  30        movb ra,@de_                    ; STA de            ; Clear de, the flag that appends " DESTROYED" to the
     4F16 0D65     
16786                                                                          ; end of the next text token, so that it doesn't
16787               
16788 4F18 020E  20        li   rx,>60*256                 ; LDX #&60          ; Set X to the screen memory page for the top row of the
     4F1A 6000     
16789                                                                          ; screen (as screen memory starts at &6000)
16790               
16791               BOL1:
16792 4F1C 0200  20        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X, which clears
     4F1E CF96     
16793 4F20 06A0  32        bl   @jsr                       ;
     4F22 FE28     
16794                                                                          ; that character row on the screen
16795               
16796 4F24 B387  18        ab   rone,rx                    ; INX               ; Increment X to point to the next page, i.e. the next
16797                                                                          ; character row
16798               
16799 4F26 028E  22        ci   rx,>78*256                 ; CPX #&78          ; Loop back to BOL1 until we have cleared page &7700,
     4F28 7800     
16800 4F2A 16F8  14        jne  BOL1                       ; BNE BOL1          ; the last character row in the space view part of the
16801                                                                          ; screen (the top part)
16802               
16803 4F2C D3A0  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Fetch into X the number that's shown on-screen during
     4F2E 002F     
16804                                                                          ; the hyperspace countdown
16805               
16806 4F30 1304  14        jeq  BOX                        ; BEQ BOX           ; If the counter is zero then we are not counting down
16807                                                                          ; to hyperspace, so jump to BOX to skip the next
16808                                                                          ; instruction
16809               
16810 4F32 0200  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     4F34 A292     
16811 4F36 06A0  32        bl   @jsr                       ;
     4F38 FE28     
16812                                                                          ; i.e. print the hyperspace countdown in the top-left
16813                                                                          ; corner
16814               
16815               BOX:
16816 4F3A 020F  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     4F3C 0100     
16817 4F3E D80F  30        movb ry,@YC                     ; STY YC
     4F40 002D     
16818               
16819 4F42 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to tt66 to skip
     4F44 0096     
16820 4F46 1616  14        jne  tt66_                      ; BNE tt66          ; displaying the view name
16821               
16822 4F48 020F  20        li   ry,>0b*256                 ; LDY #11           ; Move the text cursor to row 11
     4F4A 0B00     
16823 4F4C D80F  30        movb ry,@XC                     ; STY XC
     4F4E 002C     
16824               
16825 4F50 D360  30        movb @VIEW,ra                   ; LDA VIEW          ; Load the current view into A:
     4F52 0D5F     
16826                                                                          ;
16827                                                                          ; 0 = front
16828                                                                          ; 1 = rear
16829                                                                          ; 2 = left
16830                                                                          ; 3 = right
16831               
16832 4F54 026D  22        ori  ra,>60*256                 ; ORA #&60          ; OR with &60 so we get a value of &60 to &63 (96 to 99)
     4F56 6000     
16833               
16834 4F58 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print recursive token 96 to 99, which will be in the
     4F5A ACA0     
16835 4F5C 06A0  32        bl   @jsr                       ;
     4F5E FE28     
16836                                                                          ; range "FRONT" to "RIGHT"
16837               
16838 4F60 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     4F62 A3D0     
16839 4F64 06A0  32        bl   @jsr                       ;
     4F66 FE28     
16840               
16841 4F68 020D  20        li   ra,>af*256                 ; LDA #175          ; Print recursive token 15 ("VIEW ")
     4F6A AF00     
16842 4F6C 0200  20        li   rtmp,TT27                  ; JSR TT27
     4F6E ACA0     
16843 4F70 06A0  32        bl   @jsr                       ;
     4F72 FE28     
16844               
16845               tt66_:
16846 4F74 020E  20        li   rx,>00*256                 ; LDX #0            ; Set (X1, Y1) to (0, 0)
     4F76 0000     
16847 4F78 D80E  30        movb rx,@X1                     ; STX X1
     4F7A 0031     
16848 4F7C D80E  30        movb rx,@Y1                     ; STX Y1
     4F7E 0032     
16849               
16850 4F80 D80E  30        movb rx,@QQ17                   ; STX QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     4F82 007E     
16851               
16852 4F84 7387  18        sb   rone,rx                    ; DEX               ; Set X2 = 255
16853 4F86 D80E  30        movb rx,@X2                     ; STX X2
     4F88 0033     
16854               
16855 4F8A 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1), so
     4F8C 277A     
16856 4F8E 06A0  32        bl   @jsr                       ;
     4F90 FE28     
16857                                                                          ; that's (0, 0) to (255, 0), along the very top of the
16858                                                                          ; screen
16859               
16860 4F92 020D  20        li   ra,>02*256                 ; LDA #2            ; Set X1 = X2 = 2
     4F94 0200     
16861 4F96 D80D  30        movb ra,@X1                     ; STA X1
     4F98 0031     
16862 4F9A D80D  30        movb ra,@X2                     ; STA X2
     4F9C 0033     
16863               
16864 4F9E 0200  20        li   rtmp,BOS2                  ; JSR BOS2          ; Call BOS2 below, which will call BOS1 twice, and then
     4FA0 4FA6     
16865 4FA2 06A0  32        bl   @jsr                       ;
     4FA4 FE28     
16866                                                                          ; fall through into BOS2 again, so we effectively do
16867                                                                          ; BOS1 four times, decrementing X1 and X2 each time
16868                                                                          ; before calling LOIN, so this whole loop-within-a-loop
16869                                                                          ; mind-bender ends up drawing these four lines:
16870                                                                          ;
16871                                                                          ; (1, 0)   to (1, 191)
16872                                                                          ; (0, 0)   to (0, 191)
16873                                                                          ; (255, 0) to (255, 191)
16874                                                                          ; (254, 0) to (254, 191)
16875                                                                          ;
16876                                                                          ; So that's a 2-pixel wide vertical border along the
16877                                                                          ; left edge of the upper part of the screen, and a
16878                                                                          ; 2-pixel wide vertical border along the right edge
16879               
16880               BOS2:
16881 4FA6 0200  20        li   rtmp,BOS1                  ; JSR BOS1          ; Call BOS1 below and then fall through into it, which
     4FA8 4FAE     
16882 4FAA 06A0  32        bl   @jsr                       ;
     4FAC FE28     
16883                                                                          ; ends up running BOS1 twice. This is all part of the
16884                                                                          ; loop-the-loop border-drawing mind-bender explained
16885                                                                          ; above
16886               
16887               BOS1:
16888 4FAE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set Y1 = 0
     4FB0 0000     
16889 4FB2 D80D  30        movb ra,@Y1                     ; STA Y1
     4FB4 0032     
16890               
16891 4FB6 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
     4FB8 BF00     
16892 4FBA D80D  30        movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
     4FBC 0034     
16893                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
16894                                                                          ; pixel row of the space view
16895               
16896 4FBE 7347  18        sb   rone,ra                    ; DEC X1            ; Decrement X1 and X2
16897 4FC0 7347  18        sb   rone,ra                    ; DEC X2
16898               
16899 4FC2 0460  28        b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), and return from
     4FC4 23BE     
16900                                                                          ; the subroutine using a tail call
16901               
16902               * ******************************************************************************
16903               *
16904               * Name: DELAY
16905               * Type: Subroutine
16906               * Category: Utility routines
16907               * Summary: Wait for a specified time, in 1/50s of a second
16908               *
16909               * ------------------------------------------------------------------------------
16910               *
16911               * Wait for the number of vertical syncs given in Y, so this effectively waits
16912               * for Y/50 of a second (as the vertical sync occurs 50 times a second).
16913               *
16914               * ------------------------------------------------------------------------------
16915               *
16916               * Arguments:
16917               *
16918               * Y                   The number of vertical sync events to wait for
16919               *
16920               * ------------------------------------------------------------------------------
16921               *
16922               * Other entry points:
16923               *
16924               * DEL8                Wait for 8/50 of a second (0.16 seconds)
16925               *
16926               * DELAY-5             Wait for 2/50 of a second (0.04 seconds)
16927               *
16928               * ******************************************************************************
16929               
16930 4FC6 020F  20        li   ry,>02*256                 ; LDY #2            ; Set Y to 2 vertical syncs
     4FC8 0200     
16931               
16932 4FCA 2C              byte >2c                                            ; Skip the next instruction by turning it into
16933                                                                          ; &2C &A0 &08, or BIT &08A0, which does nothing apart
16934                                                                          ; from affect the flags
16935               
16936               DEL8:
16937 4FCC 020F  20        li   ry,>08*256                 ; LDY #8            ; Set Y to 8 vertical syncs and fall through into DELAY
     4FCE 0800     
16938                                                                          ; to wait for this long
16939               
16940               DELAY:
16941 4FD0 0200  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     4FD2 51C2     
16942 4FD4 06A0  32        bl   @jsr                       ;
     4FD6 FE28     
16943                                                                          ; screen gets drawn
16944               
16945 4FD8 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter in Y
16946               
16947 4FDA 16FA  14        jne  DELAY                      ; BNE DELAY         ; If Y isn't yet at zero, jump back to DELAY to wait
16948                                                                          ; for another vertical sync
16949               
16950 4FDC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     4FDE FE34     
16951               
16952               * ******************************************************************************
16953               *
16954               * Name: hm
16955               * Type: Subroutine
16956               * Category: Charts
16957               * Summary: Select the closest system and redraw the chart crosshairs
16958               *
16959               * ------------------------------------------------------------------------------
16960               *
16961               * Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
16962               * system, redraw the crosshairs on the chart accordingly (if they are being
16963               * shown), and, if this is not a space view, clear the bottom three text rows of
16964               * the screen.
16965               *
16966               * ******************************************************************************
16967               
16968               hm_:
16969 4FE0 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4FE2 5C7A     
16970 4FE4 06A0  32        bl   @jsr                       ;
     4FE6 FE28     
16971                                                                          ; which will erase the crosshairs currently there
16972               
16973 4FE8 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     4FEA A000     
16974 4FEC 06A0  32        bl   @jsr                       ;
     4FEE FE28     
16975                                                                          ; (QQ9, QQ10)
16976               
16977 4FF0 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     4FF2 5C7A     
16978 4FF4 06A0  32        bl   @jsr                       ;
     4FF6 FE28     
16979                                                                          ; which will draw the crosshairs at our current home
16980                                                                          ; system
16981               
16982 4FF8 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, return from the subroutine
     4FFA 0096     
16983 4FFC 132C  14        jeq  SC5                        ; BEQ SC5           ; (as SC5 contains an RTS)
16984               
16985                                                                          ; Otherwise fall through into CLYNS to clear space at
16986                                                                          ; the bottom of the screen
16987               
16988               * ******************************************************************************
16989               *
16990               * Name: CLYNS
16991               * Type: Subroutine
16992               * Category: Drawing the screen
16993               * Summary: Clear the bottom three text rows of the mode 4 screen
16994               *
16995               * ------------------------------------------------------------------------------
16996               *
16997               * This routine clears some space at the bottom of the screen and moves the text
16998               * cursor to column 1, row 21.
16999               *
17000               * Specifically, it zeroes the following screen locations:
17001               *
17002               * &7507 to &75F0
17003               * &7607 to &76F0
17004               * &7707 to &77F0
17005               *
17006               * which clears the three bottom text rows of the mode 4 screen (rows 21 to 23),
17007               * clearing each row from text column 1 to 30 (so it doesn't overwrite the box
17008               * border in columns 0 and 32, or the last usable column in column 31).
17009               *
17010               * ------------------------------------------------------------------------------
17011               *
17012               * Returns:
17013               *
17014               * A                   A is set to 0
17015               *
17016               * Y                   Y is set to 0
17017               *
17018               * ******************************************************************************
17019               
17020               CLYNS:
17021 4FFE 020D  20        li   ra,>14*256                 ; LDA #20           ; Move the text cursor to row 20, near the bottom of
     5000 1400     
17022 5002 D80D  30        movb ra,@YC                     ; STA YC            ; the screen
     5004 002D     
17023               
17024 5006 020D  20        li   ra,>75*256                 ; LDA #&75          ; Set the two-byte value in SC to &7507
     5008 7500     
17025 500A D80D  30        movb ra,@SC+1                   ; STA SC+1
     500C 0008     
17026 500E 020D  20        li   ra,>07*256                 ; LDA #7
     5010 0700     
17027 5012 D80D  30        movb ra,@SC                     ; STA SC
     5014 0007     
17028               
17029 5016 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline, which will move the text cursor down
     5018 52CE     
17030 501A 06A0  32        bl   @jsr                       ;
     501C FE28     
17031                                                                          ; a line (to row 21) and back to column 1
17032               
17033 501E 020D  20        li   ra,>00*256                 ; LDA #0            ; Call LYN to clear the pixels from &7507 to &75F0
     5020 0000     
17034 5022 0200  20        li   rtmp,LYN                   ; JSR LYN
     5024 503C     
17035 5026 06A0  32        bl   @jsr                       ;
     5028 FE28     
17036               
17037 502A B347  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7607
17038               
17039 502C 0200  20        li   rtmp,LYN                   ; JSR LYN           ; Call LYN to clear the pixels from &7607 to &76F0
     502E 503C     
17040 5030 06A0  32        bl   @jsr                       ;
     5032 FE28     
17041               
17042 5034 B347  18        ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7707
17043               
17044 5036 B3C7  18        ab   rone,ry                    ; INY               ; Move the text cursor to column 1 (as LYN sets Y to 0)
17045 5038 D80F  30        movb ry,@XC                     ; STY XC
     503A 002C     
17046               
17047                                                                          ; Fall through into LYN to clear the pixels from &7707
17048                                                                          ; to &77F0
17049               
17050               * ******************************************************************************
17051               *
17052               * Name: LYN
17053               * Type: Subroutine
17054               * Category: Drawing the screen
17055               * Summary: Clear most of a row of pixels
17056               *
17057               * ------------------------------------------------------------------------------
17058               *
17059               * Set pixels 0-233 to the value in A, starting at the pixel pointed to by SC.
17060               *
17061               * ------------------------------------------------------------------------------
17062               *
17063               * Arguments:
17064               *
17065               * A                   The value to store in pixels 1-233 (the only value that
17066               * is actually used is A = 0, which clears those pixels)
17067               *
17068               * ------------------------------------------------------------------------------
17069               *
17070               * Returns:
17071               *
17072               * Y                   Y is set to 0
17073               *
17074               * ------------------------------------------------------------------------------
17075               *
17076               * Other entry points:
17077               *
17078               * SC5                 Contains an RTS
17079               *
17080               * ******************************************************************************
17081               
17082               LYN:
17083 503C 020F  20        li   ry,>e9*256                 ; LDY #233          ; Set up a counter in Y to count down from pixel 233
     503E E900     
17084               
17085               EE2:
17086                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store A in the Y-th byte after the address pointed to
     **** ****     > ST_IND_Y_IDX
0001 5040 D820  42        movb @SC,@rtmplb
     5042 0007     
     5044 8301     
0002 5046 D020  30        movb @SC+1,rtmp
     5048 0008     
0003 504A 06CF  14        swpb ry
0004 504C A00F  18        a    ry,rtmp
0005 504E 06CF  14        swpb ry
0006 5050 D40D  30        movb RA,*rtmp
                   < elite.a99
17087                                                                          ; by SC
17088               
17089 5052 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y
17090               
17091 5054 16F5  14        jne  EE2                        ; BNE EE2           ; Loop back until Y is zero
17092               
17093               SC5:
17094 5056 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5058 FE34     
17095               
17096               * ******************************************************************************
17097               *
17098               * Name: SCAN
17099               * Type: Subroutine
17100               * Category: Dashboard
17101               * Summary: Display the current ship on the scanner
17102               * Deep dive: The 3D scanner
17103               *
17104               * ------------------------------------------------------------------------------
17105               *
17106               * This is used both to display a ship on the scanner, and to erase it again.
17107               *
17108               * ------------------------------------------------------------------------------
17109               *
17110               * Arguments:
17111               *
17112               * INWK                The ship's data block
17113               *
17114               * ******************************************************************************
17115               
17116               SCAN:
17117 505A D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's scanner flag from byte #31
     505C 0072     
17118               
17119 505E 024D  22        andi ra,>10*256                 ; AND #%00010000    ; If bit 4 is clear then the ship should not be shown
     5060 1000     
17120 5062 13F9  14        jeq  SC5                        ; BEQ SC5           ; on the scanner, so return from the subroutine (as SC5
17121                                                                          ; contains an RTS)
17122               
17123 5064 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship's type from TYPE into A
     5066 009B     
17124               
17125 5068 11F6  14        jlt  SC5                        ; BMI SC5           ; If this is the planet or the sun, then the type will
17126                                                                          ; have bit 7 set and we don't want to display it on the
17127                                                                          ; scanner, so return from the subroutine (as SC5
17128                                                                          ; contains an RTS)
17129               
17130 506A 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to the default scanner colour of green/cyan
     506C FF00     
17131                                                                          ; (a 4-pixel mode 5 byte in colour 3)
17132               
17133               * CMP #TGL               \ These instructions are commented out in the original
17134               * BEQ SC49               \ source. Along with the block just below, they would
17135                                                                          ; set X to colour 1 (red) for asteroids, cargo canisters
17136                                                                          ; and escape pods, rather than green/cyan. Presumably
17137                                                                          ; they decided it didn't work that well against the red
17138                                                                          ; ellipse and took this code out for release
17139               
17140 506E 028D  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If this is not a missile, skip the following
     5070 0900     
17141 5072 1602  14        jne  B47                        ; BNE B47           ; instruction
17142               
17143 5074 020E  20        li   rx,>f0*256                 ; LDX #&F0          ; This is a missile, so set X to colour 2 (yellow/white)
     5076 F000     
17144               
17145               B47:
17146               * CMP #AST               \ These instructions are commented out in the original
17147               * BCC P%+4               \ source. See above for an explanation of what they do
17148               * LDX #&0F
17149               * .SC49
17150 5078 D80E  30        movb rx,@COL                    ; STX COL           ; Store X, the colour of this ship on the scanner, in
     507A 00A2     
17151                                                                          ; COL
17152               
17153 507C D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; If any of x_hi, y_hi and z_hi have a 1 in bit 6 or 7,
     507E 0054     
17154 5080 F360  30        socb @INWK+4,ra                 ; ORA INWK+4        ; then the ship is too far away to be shown on the
     5082 0057     
17155 5084 F360  30        socb @INWK+7,ra                 ; ORA INWK+7        ; scanner, so return from the subroutine (as SC5
     5086 005A     
17156 5088 024D  22        andi ra,>c0*256                 ; AND #%11000000    ; contains an RTS)
     508A C000     
17157 508C 16E4  14        jne  SC5                        ; BNE SC5
17158               
17159                                                                          ; If we get here, we know x_hi, y_hi and z_hi are all
17160                                                                          ; 63 (%00111111) or less
17161               
17162                                                                          ; Now, we convert the x_hi coordinate of the ship into
17163                                                                          ; the screen x-coordinate of the dot on the scanner,
17164                                                                          ; using the following (see the deep dive on "The 3D
17165                                                                          ; scanner" for an explanation):
17166                                                                          ;
17167                                                                          ; X1 = 123 + (x_sign x_hi)
17168               
17169 508E D360  30        movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi
     5090 0054     
17170               
17171                      .clc                            ; CLC               ; Clear the C flag so we can do addition below
     **** ****     > CLC
0001 5092 0A16  18        sla  rzero,1
                   < elite.a99
17172               
17173 5094 D3A0  30        movb @INWK+2,rx                 ; LDX INWK+2        ; Set X = x_sign
     5096 0055     
17174               
17175 5098 1507  14        jgt  SC2                        ; BPL SC2           ; If x_sign is positive, skip the following
17176               
17177                      .eoi (>ff*256)                  ; EOR #%11111111    ; x_sign is negative, so flip the bits in A and add 1
     **** ****     > EOI
0001 509A 0200  20        li   rtmp,(>FF*256)
     509C FF00     
0002 509E 2B40  18        xor  rtmp,ra
                   < elite.a99
17178                      .adi (>01*256)                  ; ADC #1            ; to make it a negative number (bit 7 will now be set
     **** ****     > ADI
0001 50A0 1701  14        jnc  !
0002 50A2 B347  18        ab   rone,ra
0003               !:
0004 50A4 022D  22        ai   ra,(>01*256)
     50A6 0100     
                   < elite.a99
17179                                                                          ; as we confirmed above that bits 6 and 7 are clear). So
17180                                                                          ; this gives A the sign of x_sign and gives it a value
17181                                                                          ; range of -63 (%11000001) to 0
17182               
17183               SC2:
17184                      .adi (>7b*256)                  ; ADC #123          ; Set X1 = 123 + (x_sign x_hi)
     **** ****     > ADI
0001 50A8 1701  14        jnc  !
0002 50AA B347  18        ab   rone,ra
0003               !:
0004 50AC 022D  22        ai   ra,(>7B*256)
     50AE 7B00     
                   < elite.a99
17185 50B0 D80D  30        movb ra,@X1                     ; STA X1
     50B2 0031     
17186               
17187                                                                          ; Next, we convert the z_hi coordinate of the ship into
17188                                                                          ; the y-coordinate of the base of the ship's stick,
17189                                                                          ; like this (see the deep dive on "The 3D scanner" for
17190                                                                          ; an explanation):
17191                                                                          ;
17192                                                                          ; SC = 220 - (z_sign z_hi) / 4
17193                                                                          ;
17194                                                                          ; though the following code actually does it like this:
17195                                                                          ;
17196                                                                          ; SC = 255 - (35 + z_hi / 4)
17197               
17198 50B4 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi / 4
     50B6 005A     
17199 50B8 091D  18        srl  ra,1                       ; LSR A             ;
17200 50BA 091D  18        srl  ra,1                       ; LSR A             ; So A is in the range 0-15
17201               
17202                      .clc                            ; CLC               ; Clear the C flag for the addition below
     **** ****     > CLC
0001 50BC 0A16  18        sla  rzero,1
                   < elite.a99
17203               
17204 50BE D3A0  30        movb @INWK+8,rx                 ; LDX INWK+8        ; Set X = z_sign
     50C0 005B     
17205               
17206 50C2 1504  14        jgt  SC3                        ; BPL SC3           ; If z_sign is positive, skip the following
17207               
17208                      .eoi (>ff*256)                  ; EOR #%11111111    ; z_sign is negative, so flip the bits in A and set the
     **** ****     > EOI
0001 50C4 0200  20        li   rtmp,(>FF*256)
     50C6 FF00     
0002 50C8 2B40  18        xor  rtmp,ra
                   < elite.a99
17209                      .sec                            ; SEC               ; C flag. As above, this makes A negative, this time
     **** ****     > SEC
0001 50CA 0A18  18        sla  rmone,1
                   < elite.a99
17210                                                                          ; with a range of -16 (%11110000) to -1 (%11111111). And
17211                                                                          ; as we are about to do an ADC, the SEC effectively adds
17212                                                                          ; another 1 to that value, giving a range of -15 to 0
17213               
17214               SC3:
17215                      .adi (>23*256)                  ; ADC #35           ; Set A = 35 + A to give a number in the range 20 to 50
     **** ****     > ADI
0001 50CC 1701  14        jnc  !
0002 50CE B347  18        ab   rone,ra
0003               !:
0004 50D0 022D  22        ai   ra,(>23*256)
     50D2 2300     
                   < elite.a99
17216               
17217                      .eoi (>ff*256)                  ; EOR #%11111111    ; Flip all the bits and store in SC, so SC is in the
     **** ****     > EOI
0001 50D4 0200  20        li   rtmp,(>FF*256)
     50D6 FF00     
0002 50D8 2B40  18        xor  rtmp,ra
                   < elite.a99
17218 50DA D80D  30        movb ra,@SC                     ; STA SC            ; range 205 to 235, with a higher z_hi giving a lower SC
     50DC 0007     
17219               
17220                                                                          ; Now for the stick height, which we calculate using the
17221                                                                          ; following (see the deep dive on "The 3D scanner" for
17222                                                                          ; an explanation):
17223                                                                          ;
17224                                                                          ; A = - (y_sign y_hi) / 2
17225               
17226 50DE D360  30        movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi / 2
     50E0 0057     
17227 50E2 091D  18        srl  ra,1                       ; LSR A
17228               
17229                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 50E4 0A16  18        sla  rzero,1
                   < elite.a99
17230               
17231 50E6 D3A0  30        movb @INWK+5,rx                 ; LDX INWK+5        ; Set X = y_sign
     50E8 0058     
17232               
17233 50EA 1104  14        jlt  SCD6                       ; BMI SCD6          ; If y_sign is negative, skip the following, as we
17234                                                                          ; already have a positive value in A
17235               
17236                      .eoi (>ff*256)                  ; EOR #%11111111    ; y_sign is positive, so flip the bits in A and set the
     **** ****     > EOI
0001 50EC 0200  20        li   rtmp,(>FF*256)
     50EE FF00     
0002 50F0 2B40  18        xor  rtmp,ra
                   < elite.a99
17237                      .sec                            ; SEC               ; C flag. This makes A negative, and as we are about to
     **** ****     > SEC
0001 50F2 0A18  18        sla  rmone,1
                   < elite.a99
17238                                                                          ; do an ADC below, the SEC effectively adds another 1 to
17239                                                                          ; that value to implement two's complement negation, so
17240                                                                          ; we don't need to add another 1 here
17241               
17242               SCD6:
17243                                                                          ; We now have all the information we need to draw this
17244                                                                          ; ship on the scanner, namely:
17245                                                                          ;
17246                                                                          ; X1 = the screen x-coordinate of the ship's dot
17247                                                                          ;
17248                                                                          ; SC = the screen y-coordinate of the base of the
17249                                                                          ; stick
17250                                                                          ;
17251                                                                          ; A = the screen height of the ship's stick, with the
17252                                                                          ; correct sign for adding to the base of the stick
17253                                                                          ; to get the dot's y-coordinate
17254                                                                          ;
17255                                                                          ; First, though, we have to make sure the dot is inside
17256                                                                          ; the dashboard, by moving it if necessary
17257                      .adc @SC,ra                     ; ADC SC            ; Set A = SC + A, so A now contains the y-coordinate of
     **** ****     > ADC
0001 50F4 1701  14        jnc  !
0002 50F6 B347  18        ab   rone,ra
0003               !:
0004 50F8 B360  30        ab   @SC,ra
     50FA 0007     
                   < elite.a99
17258                                                                          ; the end of the stick, plus the length of the stick, to
17259                                                                          ; give us the screen y-coordinate of the dot
17260               
17261 50FC 1508  14        jgt  ld246_                     ; BPL ld246         ; If the result has bit 0 clear, then the result has
17262                                                                          ; overflowed and is bigger than 256, so jump to ld246 to
17263                                                                          ; set A to the maximum allowed value of 246 (this
17264                                                                          ; instruction isn't required as we test both the maximum
17265                                                                          ; and minimum below, but it might save a few cycles)
17266               
17267 50FE 028D  22        ci   ra,>c2*256                 ; CMP #194          ; If A >= 194, skip the following instruction, as 194 is
     5100 C200     
17268 5102 1802  14        joc  B48                        ; BCS B48           ; the minimum allowed value of A
17269               
17270 5104 020D  20        li   ra,>c2*256                 ; LDA #194          ; A < 194, so set A to 194, the minimum allowed value
     5106 C200     
17271                                                                          ; for the y-coordinate of our ship's dot
17272               
17273               B48:
17274 5108 028D  22        ci   ra,>f7*256                 ; CMP #247          ; If A < 247, skip the following instruction, as 246 is
     510A F700     
17275 510C 1700  14        jnc  B49                        ; BCC B49           ; the maximum allowed value of A
17276               
17277               ld246_:
17278                      equ  $
17279               B49:
17280 510E 020D  20        li   ra,>f6*256                 ; LDA #246          ; A >= 247, so set A to 246, the maximum allowed value
     5110 F600     
17281                                                                          ; for the y-coordinate of our ship's dot
17282               
17283 5112 D80D  30        movb ra,@Y1                     ; STA Y1            ; Store A in Y1, as it now contains the screen
     5114 0032     
17284                                                                          ; y-coordinate for the ship's dot, clipped so that it
17285                                                                          ; fits within the dashboard
17286               
17287                      .sec                            ; SEC               ; Set A = A - SC to get the stick length, by reversing
     **** ****     > SEC
0001 5116 0A18  18        sla  rmone,1
                   < elite.a99
17288                      .sbc @SC,ra                     ; SBC SC            ; the ADC SC we did above. This clears the C flag if the
     **** ****     > SBC
0001 5118 1801  14        joc  !
0002 511A 7347  18        sb   rone,ra
0003               !:
0004 511C 7360  30        sb   @SC,ra
     511E 0007     
                   < elite.a99
17289                                                                          ; result is negative (i.e. the stick length is negative)
17290                                                                          ; and sets it if the result is positive (i.e. the stick
17291                                                                          ; length is negative)
17292               
17293                                                                          ; So now we have the following:
17294                                                                          ;
17295                                                                          ; X1 = the screen x-coordinate of the ship's dot,
17296                                                                          ; clipped to fit into the dashboard
17297                                                                          ;
17298                                                                          ; Y1 = the screen y-coordinate of the ship's dot,
17299                                                                          ; clipped to fit into the dashboard
17300                                                                          ;
17301                                                                          ; SC = the screen y-coordinate of the base of the
17302                                                                          ; stick
17303                                                                          ;
17304                                                                          ; A = the screen height of the ship's stick, with the
17305                                                                          ; correct sign for adding to the base of the stick
17306                                                                          ; to get the dot's y-coordinate
17307                                                                          ;
17308                                                                          ; C = 0 if A is negative, 1 if A is positive
17309                                                                          ;
17310                                                                          ; and we can get on with drawing the dot and stick
17311               
17312                      .php                            ; PHP               ; Store the flags (specifically the C flag) from the
     **** ****     > PHP
0001 5120 02C0  12        stst rtmp
0002 5122 D680  30        movb rtmp,*rsp
0003 5124 060A  14        dec  rsp
                   < elite.a99
17313                                                                          ; above subtraction
17314               
17315               * BCS SC48               \ These instructions are commented out in the original
17316               * EOR #&FF               \ source. They would negate A if the C flag were set,
17317               * ADC #1                 \ which would reverse the direction of all the sticks,
17318                                                                          ; so you could turn your joystick around. Perhaps one of
17319                                                                          ; the authors' test sticks was easier to use upside
17320                                                                          ; down? Who knows...
17321               
17322               SC48:
17323                      .pha                            ; PHA               ; Store the stick height in A on the stack
     **** ****     > PHA
0001 5126 D68D  30        movb ra,*rsp
0002 5128 060A  14        dec  rsp
                   < elite.a99
17324               
17325 512A 0200  20        li   rtmp,CPIX4                 ; JSR CPIX4         ; Draw a double-height dot at (X1, Y1). This also leaves
     512C B40A     
17326 512E 06A0  32        bl   @jsr                       ;
     5130 FE28     
17327                                                                          ; the following variables set up for the dot's top-right
17328                                                                          ; pixel, the last pixel to be drawn (as the dot gets
17329                                                                          ; drawn from the bottom up):
17330                                                                          ;
17331                                                                          ; SC(1 0) = screen address of the pixel's character
17332                                                                          ; block
17333                                                                          ;
17334                                                                          ; Y = number of the character row containing the pixel
17335                                                                          ;
17336                                                                          ; X = the pixel's number (0-3) in that row
17337                                                                          ;
17338                                                                          ; We can use there as the starting point for drawing the
17339                                                                          ; stick, if there is one
17340               
17341 5132 06CE  14        swpb rx                         ;
17342 5134 D36E  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Load the same mode 5 1-pixel byte that we just used
     5136 23BA     
17343 5138 06CE  14        swpb rx                         ;
17344                      .and @COL                       ; AND COL           ; for the top-right pixel, and mask it with the same
     **** ****     > AND
0001 513A D020  30        movb @COL,rtmp
     513C 00A2     
0002 513E 0540  14        inv  rtmp
0003 5140 5340  18        szcb rtmp,ra
                   < elite.a99
17345 5142 D80D  30        movb ra,@X1                     ; STA X1            ; colour, storing the result in X1, so we can use it as
     5144 0031     
17346                                                                          ; the character row byte for the stick
17347               
17348                      .pla                            ; PLA               ; Restore the stick height from the stack into A
     **** ****     > PLA
0001 5146 058A  14        inc  rsp
0002 5148 D35A  26        movb *rsp,ra
                   < elite.a99
17349               
17350                      .plp                            ; PLP               ; Restore the flags from above, so the C flag once again
     **** ****     > PLP
0001 514A 058A  14        inc  rsp
0002 514C D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
17351                                                                          ; reflects the sign of the stick height
17352               
17353 514E D38D  18        movb ra,rx                      ; TAX               ; Copy the stick height into X
17354               
17355 5150 1316  14        jeq  RTS1                       ; BEQ RTS1          ; If the stick height is zero, then there is no stick to
17356                                                                          ; draw, so return from the subroutine (as RTS contains
17357                                                                          ; an RTS)
17358               
17359 5152 1717  14        jnc  RTS3                       ; BCC RTS3          ; If the C flag is clear then the stick height in A is
17360                                                                          ; negative, so jump down to RTS+1
17361               
17362               VLL1:
17363                                                                          ; If we get here then the stick length is positive (so
17364                                                                          ; the dot is below the ellipse and the stick is above
17365                                                                          ; the dot, and we need to draw the stick upwards from
17366                                                                          ; the dot)
17367 5154 73C7  18        sb   rone,ry                    ; DEY               ; We want to draw the stick upwards, so decrement the
17368                                                                          ; pixel row in Y
17369               
17370 5156 1503  14        jgt  VL1                        ; BPL VL1           ; If Y is still positive then it correctly points at the
17371                                                                          ; line above, so jump to VL1 to skip the following
17372               
17373 5158 020F  20        li   ry,>07*256                 ; LDY #7            ; We just decremented Y up through the top of the
     515A 0700     
17374                                                                          ; character block, so we need to move it to the last row
17375                                                                          ; in the character above, so set Y to 7, the number of
17376                                                                          ; the last row
17377               
17378 515C 7347  18        sb   rone,ra                    ; DEC SC+1          ; Decrement the high byte of the screen address to move
17379                                                                          ; to the character block above
17380               
17381               VL1:
17382 515E D360  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     5160 0031     
17383                                                                          ; we stored in X1 above, and which has the same pixel
17384                                                                          ; pattern as the bottom-right pixel of the dot (so the
17385                                                                          ; stick comes out of the right side of the dot)
17386               
17387                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 5162 D020  30        movb @SC,rtmp
     5164 0007     
0002 5166 2B40  18        xor  rtmp,ra
                   < elite.a99
17388                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 5168 D820  42        movb @SC,@rtmplb
     516A 0007     
     516C 8301     
0002 516E D020  30        movb @SC+1,rtmp
     5170 0008     
0003 5172 06CF  14        swpb ry
0004 5174 A00F  18        a    ry,rtmp
0005 5176 06CF  14        swpb ry
0006 5178 D40D  30        movb RA,*rtmp
                   < elite.a99
17389               
17390 517A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the (positive) stick height in X
17391               
17392 517C 16EB  14        jne  VLL1                       ; BNE VLL1          ; If we still have more stick to draw, jump up to VLL1
17393                                                                          ; to draw the next pixel
17394               
17395               RTS1:
17396 517E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5180 FE34     
17397               
17398                                                                          ; If we get here then the stick length is negative (so
17399                                                                          ; the dot is above the ellipse and the stick is below
17400                                                                          ; the dot, and we need to draw the stick downwards from
17401                                                                          ; the dot)
17402               
17403               RTS3:
17404 5182 B3C7  18        ab   rone,ry                    ; INY               ; We want to draw the stick downwards, so we first
17405                                                                          ; increment the row counter so that it's pointing to the
17406                                                                          ; bottom-right pixel in the dot (as opposed to the top-
17407                                                                          ; right pixel that the call to CPIX4 finished on)
17408               
17409 5184 028F  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     5186 0800     
17410 5188 1603  14        jne  VLL2                       ; BNE VLL2          ; correctly points at the next line down, so jump to
17411                                                                          ; VLL2 to skip the following
17412               
17413 518A 020F  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     518C 0000     
17414                                                                          ; character block, so we need to move it to the first
17415                                                                          ; row in the character below, so set Y to 0, the number
17416                                                                          ; of the first row
17417               
17418 518E B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17419                                                                          ; to the character block above
17420               
17421               VLL2:
17422 5190 B3C7  18        ab   rone,ry                    ; INY               ; We want to draw the stick itself, heading downwards,
17423                                                                          ; so increment the pixel row in Y
17424               
17425 5192 028F  22        ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
     5194 0800     
17426 5196 1603  14        jne  VL2                        ; BNE VL2           ; correctly points at the next line down, so jump to
17427                                                                          ; VL2 to skip the following
17428               
17429 5198 020F  20        li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
     519A 0000     
17430                                                                          ; character block, so we need to move it to the first
17431                                                                          ; row in the character below, so set Y to 0, the number
17432                                                                          ; of the first row
17433               
17434 519C B347  18        ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
17435                                                                          ; to the character block above
17436               
17437               VL2:
17438 519E D360  30        movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
     51A0 0031     
17439                                                                          ; we stored in X1 above, and which has the same pixel
17440                                                                          ; pattern as the bottom-right pixel of the dot (so the
17441                                                                          ; stick comes out of the right side of the dot)
17442               
17443                      .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
     **** ****     > EOR
0001 51A2 D020  30        movb @SC,rtmp
     51A4 0007     
0002 51A6 2B40  18        xor  rtmp,ra
                   < elite.a99
17444                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic
     **** ****     > ST_IND_Y_IDX
0001 51A8 D820  42        movb @SC,@rtmplb
     51AA 0007     
     51AC 8301     
0002 51AE D020  30        movb @SC+1,rtmp
     51B0 0008     
0003 51B2 06CF  14        swpb ry
0004 51B4 A00F  18        a    ry,rtmp
0005 51B6 06CF  14        swpb ry
0006 51B8 D40D  30        movb RA,*rtmp
                   < elite.a99
17445               
17446 51BA B387  18        ab   rone,rx                    ; INX               ; Increment the (negative) stick height in X
17447               
17448 51BC 16E9  14        jne  VLL2                       ; BNE VLL2          ; If we still have more stick to draw, jump up to VLL2
17449                                                                          ; to draw the next pixel
17450               
17451 51BE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     51C0 FE34     
17452               
17453               * ******************************************************************************
17454               *
17455               * Name: WSCAN
17456               * Type: Subroutine
17457               * Category: Drawing the screen
17458               * Summary: Wait for the vertical sync
17459               *
17460               * ------------------------------------------------------------------------------
17461               *
17462               * Wait for vertical sync to occur on the video system - in other words, wait
17463               * for the screen to start its refresh cycle, which it does 50 times a second
17464               * (50Hz).
17465               *
17466               * ******************************************************************************
17467               
17468               WSCAN:
17469 51C2 020D  20        li   ra,>00*256                 ; LDA #0            ; Set DL to 0
     51C4 0000     
17470 51C6 D80D  30        movb ra,@DL                     ; STA DL
     51C8 009A     
17471               
17472               B50:
17473 51CA D360  30        movb @DL,ra                     ; LDA DL            ; Loop round these two instructions until DL is no
     51CC 009A     
17474 51CE 13FD  14        jeq  B50                        ; BEQ B50           ; longer 0 (DL gets set to 30 in the LINSCN routine,
17475                                                                          ; which is run when vertical sync has occurred on the
17476                                                                          ; video system, so DL will change to a non-zero value
17477                                                                          ; at the start of each screen refresh)
17478               
17479 51D0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     51D2 FE34     
17480               
17481               * ******************************************************************************
17482               *
17483               * Save ELTC.bin
17484               *
17485               * ******************************************************************************
17486               
17487                      ; PRINT "ELITE C"
17488                      ; PRINT "Assembled at ", ~CODE_C%
17489                      ; PRINT "Ends at ", ~P%
17490                      ; PRINT "Code size is ", ~(P% - CODE_C%)
17491                      ; PRINT "Execute at ", ~LOAD%
17492                      ; PRINT "Reload at ", ~LOAD_C%
17493               
17494                      ; PRINT "S.ELTC ", ~CODE_C%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_C%
17495                      ; SAVE "3-assembled-output/ELTC.bin", CODE_C%, P%, LOAD%
17496               
17497               * ******************************************************************************
17498               *
17499               * ELITE D FILE
17500               *
17501               * Produces the binary file ELTD.bin that gets loaded by elite-bcfs.asm.
17502               *
17503               * ******************************************************************************
17504               
17505               CODE_D.:
17506                      equ $
17507               
17508               LOAD_D.:
17509                      equ LOAD. + $ - CODE.
17510               
17511               * ******************************************************************************
17512               *
17513               * Name: tnpr
17514               * Type: Subroutine
17515               * Category: Market
17516               * Summary: Work out if we have space for a specific amount of cargo
17517               *
17518               * ------------------------------------------------------------------------------
17519               *
17520               * Given a market item and an amount, work out whether there is room in the
17521               * cargo hold for this item.
17522               *
17523               * For standard tonne canisters, the limit is given by the type of cargo hold we
17524               * have, with a standard cargo hold having a capacity of 20t and an extended
17525               * cargo bay being 35t.
17526               *
17527               * For items measured in kg (gold, platinum), g (gem-stones) and alien items,
17528               * the individual limit on each of these is 200 units.
17529               *
17530               * ------------------------------------------------------------------------------
17531               *
17532               * Arguments:
17533               *
17534               * A                   The number of units of this market item
17535               *
17536               * QQ29                The type of market item (see QQ23 for a list of market
17537               * item numbers)
17538               *
17539               * ------------------------------------------------------------------------------
17540               *
17541               * Returns:
17542               *
17543               * A                   A is preserved
17544               *
17545               * C flag              Returns the result:
17546               *
17547               * * Set if there is no room for this item
17548               *
17549               * * Clear if there is room for this item
17550               *
17551               * ******************************************************************************
17552               
17553               tnpr_:
17554                      .pha                            ; PHA               ; Store A on the stack
     **** ****     > PHA
0001 51D4 D68D  30        movb ra,*rsp
0002 51D6 060A  14        dec  rsp
                   < elite.a99
17555               
17556 51D8 020E  20        li   rx,>0c*256                 ; LDX #12           ; If QQ29 > 12 then jump to kg below, as this cargo
     51DA 0C00     
17557 51DC 93A0  30        cb   @QQ29,rx                   ; CPX QQ29          ; type is gold, platinum, gem-stones or alien items,
     51DE 0F1B     
17558 51E0 170E  14        jnc  kg_                        ; BCC kg            ; and they have different cargo limits to the standard
17559                                                                          ; tonne canisters
17560               
17561               Tml:
17562                                                                          ; Here we count the tonne canisters we have in the hold
17563                                                                          ; and add to A to see if we have enough room for A more
17564                                                                          ; tonnes of cargo, using X as the loop counter, starting
17565                                                                          ; with X = 12
17566 51E2 06CE  14        swpb rx                         ;
17567                      .adc @QQ20(rx),ra               ; ADC QQ20,X        ; Set A = A + the number of tonnes we have in the hold
     **** ****     > ADC
0001 51E4 1701  14        jnc  !
0002 51E6 B347  18        ab   rone,ra
0003               !:
0004 51E8 B36E  34        ab   @QQ20(RX),ra
     51EA 0317     
                   < elite.a99
17568 51EC 06CE  14        swpb rx                         ;
17569                                                                          ; of market item number X. Note that the first time we
17570                                                                          ; go round this loop, the C flag is set (as we didn't
17571                                                                          ; branch with the BCC above, so the effect of this loop
17572                                                                          ; is to count the number of tonne canisters in the hold,
17573                                                                          ; and add 1
17574               
17575 51EE 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
17576               
17577 51F0 15F8  14        jgt  Tml                        ; BPL Tml           ; Loop back to add in the next market item in the hold,
17578                                                                          ; until we have added up all market items from 12
17579                                                                          ; (minerals) down to 0 (food)
17580               
17581 51F2 9360  30        cb   @CRGO,ra                   ; CMP CRGO          ; If A < CRGO then the C flag will be clear (we have
     51F4 0316     
17582                                                                          ; room in the hold)
17583                                                                          ;
17584                                                                          ; If A >= CRGO then the C flag will be set (we do not
17585                                                                          ; have room in the hold)
17586                                                                          ;
17587                                                                          ; This works because A contains the number of canisters
17588                                                                          ; plus 1, while CRGO contains our cargo capacity plus 2,
17589                                                                          ; so if we actually have "a" canisters and a capacity
17590                                                                          ; of "c", then:
17591                                                                          ;
17592                                                                          ; A < CRGO means: a+1 <  c+2
17593                                                                          ; a   <  c+1
17594                                                                          ; a   <= c
17595                                                                          ;
17596                                                                          ; So this is why the value in CRGO is 2 higher than the
17597                                                                          ; actual cargo bay size, i.e. it's 22 for the standard
17598                                                                          ; 20-tonne bay, and 37 for the large 35-tonne bay
17599               
17600                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 51F6 058A  14        inc  rsp
0002 51F8 D35A  26        movb *rsp,ra
                   < elite.a99
17601               
17602 51FA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     51FC FE34     
17603               
17604               kg_:
17605                                                                          ; Here we count the number of items of this type that
17606                                                                          ; we already have in the hold, and add to A to see if
17607                                                                          ; we have enough room for A more units
17608 51FE D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set Y to the item number we want to add
     5200 0F1B     
17609               
17610 5202 06CF  14        swpb ry                         ;
17611                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Set A = A + the number of units of this item that we
     **** ****     > ADC
0001 5204 1701  14        jnc  !
0002 5206 B347  18        ab   rone,ra
0003               !:
0004 5208 B36F  34        ab   @QQ20(RY),ra
     520A 0317     
                   < elite.a99
17612 520C 06CF  14        swpb ry                         ;
17613                                                                          ; already have in the hold
17614               
17615 520E 028D  22        ci   ra,>c8*256                 ; CMP #200          ; Is the result greater than 200 (the limit on
     5210 C800     
17616                                                                          ; individual stocks of gold, platinum, gem-stones and
17617                                                                          ; alien items)?
17618                                                                          ;
17619                                                                          ; If so, this sets the C flag (no room)
17620                                                                          ;
17621                                                                          ; Otherwise it is clear (we have room)
17622               
17623                      .pla                            ; PLA               ; Restore A from the stack
     **** ****     > PLA
0001 5212 058A  14        inc  rsp
0002 5214 D35A  26        movb *rsp,ra
                   < elite.a99
17624               
17625 5216 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5218 FE34     
17626               
17627               * ******************************************************************************
17628               *
17629               * Name: TT20
17630               * Type: Subroutine
17631               * Category: Universe
17632               * Summary: Twist the selected system's seeds four times
17633               * Deep dive: Twisting the system seeds
17634               * Galaxy and system seeds
17635               *
17636               * ------------------------------------------------------------------------------
17637               *
17638               * Twist the three 16-bit seeds in QQ15 (selected system) four times, to
17639               * generate the next system.
17640               *
17641               * ******************************************************************************
17642               
17643               TT20:
17644 521A 0200  20        li   rtmp,B51                   ; JSR B51           ; This line calls the line below as a subroutine, which
     521C 5222     
17645 521E 06A0  32        bl   @jsr                       ;
     5220 FE28     
17646                                                                          ; does two twists before returning here, and then we
17647                                                                          ; fall through to the line below for another two
17648                                                                          ; twists, so the net effect of these two consecutive
17649                                                                          ; JSR calls is four twists, not counting the ones
17650                                                                          ; inside your head as you try to follow this process
17651               
17652               B51:
17653 5222 0200  20        li   rtmp,TT54                  ; JSR TT54          ; This line calls TT54 as a subroutine to do a twist,
     5224 522A     
17654 5226 06A0  32        bl   @jsr                       ;
     5228 FE28     
17655                                                                          ; and then falls through into TT54 to do another twist
17656                                                                          ; before returning from the subroutine
17657               
17658               * ******************************************************************************
17659               *
17660               * Name: TT54
17661               * Type: Subroutine
17662               * Category: Universe
17663               * Summary: Twist the selected system's seeds
17664               * Deep dive: Twisting the system seeds
17665               * Galaxy and system seeds
17666               *
17667               * ------------------------------------------------------------------------------
17668               *
17669               * This routine twists the three 16-bit seeds in QQ15 once.
17670               *
17671               * If we start with seeds s0, s1 and s2 and we want to work out their new values
17672               * after we perform a twist (let's call the new values s0, s1 and s2), then:
17673               *
17674               * s0 = s1
17675               * s1 = s2
17676               * s2 = s0 + s1 + s2
17677               *
17678               * So given an existing set of seeds in s0, s1 and s2, we can get the new values
17679               * s0, s1 and s2 simply by doing the above sums. And if we want to do the
17680               * above in-place without creating three new s variables, then we can do the
17681               * following:
17682               *
17683               * tmp = s0 + s1
17684               * s0 = s1
17685               * s1 = s2
17686               * s2 = tmp + s1
17687               *
17688               * So this is what we do in this routine, where each seed is a 16-bit number.
17689               *
17690               * ******************************************************************************
17691               
17692               TT54:
17693 522A D360  30        movb @QQ15,ra                   ; LDA QQ15          ; X = tmp_lo = s0_lo + s1_lo
     522C 0078     
17694                      .clc                            ; CLC
     **** ****     > CLC
0001 522E 0A16  18        sla  rzero,1
                   < elite.a99
17695                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 5230 1701  14        jnc  !
0002 5232 B347  18        ab   rone,ra
0003               !:
0004 5234 B360  30        ab   @QQ15+2,ra
     5236 007A     
                   < elite.a99
17696 5238 D38D  18        movb ra,rx                      ; TAX
17697               
17698 523A D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Y = tmp_hi = s1_hi + s1_hi + C
     523C 0079     
17699                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 523E 1701  14        jnc  !
0002 5240 B347  18        ab   rone,ra
0003               !:
0004 5242 B360  30        ab   @QQ15+3,ra
     5244 007B     
                   < elite.a99
17700 5246 D3CD  18        movb ra,ry                      ; TAY
17701               
17702 5248 D360  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; s0_lo = s1_lo
     524A 007A     
17703 524C D80D  30        movb ra,@QQ15                   ; STA QQ15
     524E 0078     
17704               
17705 5250 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; s0_hi = s1_hi
     5252 007B     
17706 5254 D80D  30        movb ra,@QQ15+1                 ; STA QQ15+1
     5256 0079     
17707               
17708 5258 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; s1_hi = s2_hi
     525A 007D     
17709 525C D80D  30        movb ra,@QQ15+3                 ; STA QQ15+3
     525E 007B     
17710               
17711 5260 D360  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; s1_lo = s2_lo
     5262 007C     
17712 5264 D80D  30        movb ra,@QQ15+2                 ; STA QQ15+2
     5266 007A     
17713               
17714                      .clc                            ; CLC               ; s2_lo = X + s1_lo
     **** ****     > CLC
0001 5268 0A16  18        sla  rzero,1
                   < elite.a99
17715 526A D34E  18        movb rx,ra                      ; TXA
17716                      .adc @QQ15+2,ra                 ; ADC QQ15+2
     **** ****     > ADC
0001 526C 1701  14        jnc  !
0002 526E B347  18        ab   rone,ra
0003               !:
0004 5270 B360  30        ab   @QQ15+2,ra
     5272 007A     
                   < elite.a99
17717 5274 D80D  30        movb ra,@QQ15+4                 ; STA QQ15+4
     5276 007C     
17718               
17719 5278 D34F  18        movb ry,ra                      ; TYA               ; s2_hi = Y + s1_hi + C
17720                      .adc @QQ15+3,ra                 ; ADC QQ15+3
     **** ****     > ADC
0001 527A 1701  14        jnc  !
0002 527C B347  18        ab   rone,ra
0003               !:
0004 527E B360  30        ab   @QQ15+3,ra
     5280 007B     
                   < elite.a99
17721 5282 D80D  30        movb ra,@QQ15+5                 ; STA QQ15+5
     5284 007D     
17722               
17723 5286 0460  28        b    @rts                       ; RTS               ; The twist is complete so return from the subroutine
     5288 FE34     
17724               
17725               * ******************************************************************************
17726               *
17727               * Name: TT146
17728               * Type: Subroutine
17729               * Category: Universe
17730               * Summary: Print the distance to the selected system in light years
17731               *
17732               * ------------------------------------------------------------------------------
17733               *
17734               * If it is non-zero, print the distance to the selected system in light years.
17735               * If it is zero, just move the text cursor down a line.
17736               *
17737               * Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
17738               * then a colon, then the distance to one decimal place, then token 35 ("LIGHT
17739               * YEARS"). If the distance is zero, move the cursor down one line.
17740               *
17741               * ******************************************************************************
17742               
17743               TT146:
17744 528A D360  30        movb @QQ8,ra                    ; LDA QQ8           ; Take the two bytes of the 16-bit value in QQ8 and
     528C 0F2F     
17745 528E F360  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; OR them together to check whether there are any
     5290 0F30     
17746 5292 1603  14        jne  TT63                       ; BNE TT63          ; non-zero bits, and if so, jump to TT63 to print the
17747                                                                          ; distance
17748               
17749 5294 B347  18        ab   rone,ra                    ; INC YC            ; The distance is zero, so we just move the text cursor
17750 5296 0460  28        b    @rts                       ; RTS               ; in YC down by one line and return from the subroutine
     5298 FE34     
17751               
17752               TT63:
17753 529A 020D  20        li   ra,>bf*256                 ; LDA #191          ; Print recursive token 31 ("DISTANCE") followed by
     529C BF00     
17754 529E 0200  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     52A0 AC94     
17755 52A2 06A0  32        bl   @jsr                       ;
     52A4 FE28     
17756               
17757 52A6 D3A0  30        movb @QQ8,rx                    ; LDX QQ8           ; Load (Y X) from QQ8, which contains the 16-bit
     52A8 0F2F     
17758 52AA D3E0  30        movb @QQ8+1,ry                  ; LDY QQ8+1         ; distance we want to show
     52AC 0F30     
17759               
17760                      .sec                            ; SEC               ; Set the C flag so that the call to pr5 will include a
     **** ****     > SEC
0001 52AE 0A18  18        sla  rmone,1
                   < elite.a99
17761                                                                          ; decimal point, and display the value as (Y X) / 10
17762               
17763 52B0 0200  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, including a decimal point
     52B2 A2A2     
17764 52B4 06A0  32        bl   @jsr                       ;
     52B6 FE28     
17765               
17766 52B8 020D  20        li   ra,>c3*256                 ; LDA #195          ; Set A to the recursive token 35 (" LIGHT YEARS") and
     52BA C300     
17767                                                                          ; fall through into TT60 to print the token followed
17768                                                                          ; by a paragraph break
17769               
17770               * ******************************************************************************
17771               *
17772               * Name: TT60
17773               * Type: Subroutine
17774               * Category: Text
17775               * Summary: Print a text token and a paragraph break
17776               *
17777               * ------------------------------------------------------------------------------
17778               *
17779               * Print a text token (i.e. a character, control code, two-letter token or
17780               * recursive token). Then print a paragraph break (a blank line between
17781               * paragraphs) by moving the cursor down a line, setting Sentence Case, and then
17782               * printing a newline.
17783               *
17784               * ------------------------------------------------------------------------------
17785               *
17786               * Arguments:
17787               *
17788               * A                   The text token to be printed
17789               *
17790               * ******************************************************************************
17791               
17792               TT60:
17793 52BC 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TTX69
     52BE ACA0     
17794 52C0 06A0  32        bl   @jsr                       ;
     52C2 FE28     
17795                                                                          ; to print the paragraph break
17796               
17797               * ******************************************************************************
17798               *
17799               * Name: TTX69
17800               * Type: Subroutine
17801               * Category: Text
17802               * Summary: Print a paragraph break
17803               *
17804               * ------------------------------------------------------------------------------
17805               *
17806               * Print a paragraph break (a blank line between paragraphs) by moving the cursor
17807               * down a line, setting Sentence Case, and then printing a newline.
17808               *
17809               * ******************************************************************************
17810               
17811               TTX69:
17812 52C4 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a line
17813               
17814                                                                          ; Fall through into TT69 to set Sentence Case and print
17815                                                                          ; a newline
17816               
17817               * ******************************************************************************
17818               *
17819               * Name: TT69
17820               * Type: Subroutine
17821               * Category: Text
17822               * Summary: Set Sentence Case and print a newline
17823               *
17824               * ******************************************************************************
17825               
17826               TT69:
17827 52C6 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     52C8 8000     
17828 52CA D80D  30        movb ra,@QQ17                   ; STA QQ17
     52CC 007E     
17829               
17830                                                                          ; Fall through into TT67 to print a newline
17831               
17832               * ******************************************************************************
17833               *
17834               * Name: TT67
17835               * Type: Subroutine
17836               * Category: Text
17837               * Summary: Print a newline
17838               *
17839               * ******************************************************************************
17840               
17841               TT67:
17842 52CE 020D  20        li   ra,>0d*256                 ; LDA #13           ; Load a newline character into A
     52D0 0D00     
17843               
17844 52D2 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     52D4 ACA0     
17845                                                                          ; subroutine using a tail call
17846               
17847               * ******************************************************************************
17848               *
17849               * Name: TT70
17850               * Type: Subroutine
17851               * Category: Universe
17852               * Summary: Display "MAINLY " and jump to TT72
17853               *
17854               * ------------------------------------------------------------------------------
17855               *
17856               * This subroutine is called by TT25 when displaying a system's economy.
17857               *
17858               * ******************************************************************************
17859               
17860               TT70:
17861 52D6 020D  20        li   ra,>ad*256                 ; LDA #173          ; Print recursive token 13 ("MAINLY ")
     52D8 AD00     
17862 52DA 0200  20        li   rtmp,TT27                  ; JSR TT27
     52DC ACA0     
17863 52DE 06A0  32        bl   @jsr                       ;
     52E0 FE28     
17864               
17865 52E2 0460  28        b    @TT72                      ; JMP TT72          ; Jump to TT72 to continue printing system data as part
     52E4 536A     
17866                                                                          ; of routine TT25
17867               
17868               * ******************************************************************************
17869               *
17870               * Name: spc
17871               * Type: Subroutine
17872               * Category: Text
17873               * Summary: Print a text token followed by a space
17874               *
17875               * ------------------------------------------------------------------------------
17876               *
17877               * Print a text token (i.e. a character, control code, two-letter token or
17878               * recursive token) followed by a space.
17879               *
17880               * ------------------------------------------------------------------------------
17881               *
17882               * Arguments:
17883               *
17884               * A                   The text token to be printed
17885               *
17886               * ******************************************************************************
17887               
17888               spc_:
17889 52E6 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     52E8 ACA0     
17890 52EA 06A0  32        bl   @jsr                       ;
     52EC FE28     
17891               
17892 52EE 0460  28        b    @TT162                     ; JMP TT162         ; Print a space and return from the subroutine using a
     52F0 A3D0     
17893                                                                          ; tail call
17894               
17895               * ******************************************************************************
17896               *
17897               * Name: TT25
17898               * Type: Subroutine
17899               * Category: Universe
17900               * Summary: Show the Data on System screen (red key f6)
17901               * Deep dive: Generating system data
17902               * Galaxy and system seeds
17903               *
17904               * ------------------------------------------------------------------------------
17905               *
17906               * Other entry points:
17907               *
17908               * TT72                Used by TT70 to re-enter the routine after displaying
17909               * "MAINLY" for the economy type
17910               *
17911               * ******************************************************************************
17912               
17913               TT25:
17914 52F2 0200  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     52F4 4EF8     
17915 52F6 06A0  32        bl   @jsr                       ;
     52F8 FE28     
17916                                                                          ; and set the current view type in QQ11 to 1
17917               
17918 52FA 020D  20        li   ra,>09*256                 ; LDA #9            ; Move the text cursor to column 9
     52FC 0900     
17919 52FE D80D  30        movb ra,@XC                     ; STA XC
     5300 002C     
17920               
17921 5302 020D  20        li   ra,>a3*256                 ; LDA #163          ; Print recursive token 3 as a title in capitals at
     5304 A300     
17922 5306 0200  20        li   rtmp,TT27                  ; JSR TT27          ; the top ("DATA ON {selected system name}")
     5308 ACA0     
17923 530A 06A0  32        bl   @jsr                       ;
     530C FE28     
17924               
17925 530E 0200  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line underneath the title
     5310 2746     
17926 5312 06A0  32        bl   @jsr                       ;
     5314 FE28     
17927               
17928 5316 0200  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     5318 52C4     
17929 531A 06A0  32        bl   @jsr                       ;
     531C FE28     
17930               
17931 531E B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one more line
17932               
17933 5320 0200  20        li   rtmp,TT146                 ; JSR TT146         ; If the distance to this system is non-zero, print
     5322 528A     
17934 5324 06A0  32        bl   @jsr                       ;
     5326 FE28     
17935                                                                          ; "DISTANCE", then the distance, "LIGHT YEARS" and a
17936                                                                          ; paragraph break, otherwise just move the cursor down
17937                                                                          ; a line
17938               
17939 5328 020D  20        li   ra,>c2*256                 ; LDA #194          ; Print recursive token 34 ("ECONOMY") followed by
     532A C200     
17940 532C 0200  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     532E AC94     
17941 5330 06A0  32        bl   @jsr                       ;
     5332 FE28     
17942               
17943 5334 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; The system economy is determined by the value in QQ3,
     5336 0F28     
17944                                                                          ; so fetch it into A. First we work out the system's
17945                                                                          ; prosperity as follows:
17946                                                                          ;
17947                                                                          ; QQ3 = 0 or 5 = %000 or %101 = Rich
17948                                                                          ; QQ3 = 1 or 6 = %001 or %110 = Average
17949                                                                          ; QQ3 = 2 or 7 = %010 or %111 = Poor
17950                                                                          ; QQ3 = 3 or 4 = %011 or %100 = Mainly
17951               
17952                      .clc                            ; CLC               ; If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
     **** ****     > CLC
0001 5338 0A16  18        sla  rzero,1
                   < elite.a99
17953                      .adi (>01*256)                  ; ADC #1            ; (3 or 4), then call TT70, which prints "MAINLY " and
     **** ****     > ADI
0001 533A 1701  14        jnc  !
0002 533C B347  18        ab   rone,ra
0003               !:
0004 533E 022D  22        ai   ra,(>01*256)
     5340 0100     
                   < elite.a99
17954 5342 091D  18        srl  ra,1                       ; LSR A             ; jumps down to TT72 to print the type of economy
17955 5344 028D  22        ci   ra,>02*256                 ; CMP #%00000010
     5346 0200     
17956 5348 13C6  14        jeq  TT70                       ; BEQ TT70
17957               
17958 534A D360  30        movb @QQ3,ra                    ; LDA QQ3           ; If (QQ3 + 1) >> 1 < %10, i.e. if QQ3 = %000, %001 or
     534C 0F28     
17959 534E 1705  14        jnc  TT71                       ; BCC TT71          ; %010 (0, 1 or 2), then jump to TT71 with A set to the
17960                                                                          ; original value of QQ3
17961               
17962                      .sbi (>05*256)                  ; SBC #5            ; Here QQ3 = %101, %110 or %111 (5, 6 or 7), so subtract
     **** ****     > SBI
0001 5350 1801  14        joc  !
0002 5352 7347  18        sb   rone,ra
0003               !:
0004 5354 022D  22        ai   ra,-(>05*256)
     5356 FB00     
                   < elite.a99
17963                      .clc                            ; CLC               ; 5 to bring it down to 0, 1 or 2 (the C flag is already
     **** ****     > CLC
0001 5358 0A16  18        sla  rzero,1
                   < elite.a99
17964                                                                          ; set so the SBC will be correct)
17965               
17966               TT71:
17967                      .adi (>aa*256)                  ; ADC #170          ; A is now 0, 1 or 2, so print recursive token 10 + A.
     **** ****     > ADI
0001 535A 1701  14        jnc  !
0002 535C B347  18        ab   rone,ra
0003               !:
0004 535E 022D  22        ai   ra,(>AA*256)
     5360 AA00     
                   < elite.a99
17968 5362 0200  20        li   rtmp,TT27                  ; JSR TT27          ; This means that:
     5364 ACA0     
17969 5366 06A0  32        bl   @jsr                       ;
     5368 FE28     
17970                                                                          ;
17971                                                                          ; QQ3 = 0 or 5 prints token 10 ("RICH ")
17972                                                                          ; QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
17973                                                                          ; QQ3 = 2 or 7 prints token 12 ("POOR ")
17974               
17975               TT72:
17976 536A D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the type of economy, which is
     536C 0F28     
17977 536E 091D  18        srl  ra,1                       ; LSR A             ; determined by bit 2 of QQ3, as follows:
17978 5370 091D  18        srl  ra,1                       ; LSR A             ;
17979                                                                          ; QQ3 bit 2 = 0 = Industrial
17980                                                                          ; QQ3 bit 2 = 1 = Agricultural
17981                                                                          ;
17982                                                                          ; So we fetch QQ3 into A and set A = bit 2 of QQ3 using
17983                                                                          ; two right shifts (which will work as QQ3 is only a
17984                                                                          ; 3-bit number)
17985               
17986                      .clc                            ; CLC               ; Print recursive token 8 + A, followed by a paragraph
     **** ****     > CLC
0001 5372 0A16  18        sla  rzero,1
                   < elite.a99
17987                      .adi (>a8*256)                  ; ADC #168          ; break and Sentence Case, so:
     **** ****     > ADI
0001 5374 1701  14        jnc  !
0002 5376 B347  18        ab   rone,ra
0003               !:
0004 5378 022D  22        ai   ra,(>A8*256)
     537A A800     
                   < elite.a99
17988 537C 0200  20        li   rtmp,TT60                  ; JSR TT60          ;
     537E 52BC     
17989 5380 06A0  32        bl   @jsr                       ;
     5382 FE28     
17990                                                                          ; QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
17991                                                                          ; QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")
17992               
17993 5384 020D  20        li   ra,>a2*256                 ; LDA #162          ; Print recursive token 2 ("GOVERNMENT") followed by
     5386 A200     
17994 5388 0200  20        li   rtmp,TT68                  ; JSR TT68          ; a colon
     538A AC94     
17995 538C 06A0  32        bl   @jsr                       ;
     538E FE28     
17996               
17997 5390 D360  30        movb @QQ4,ra                    ; LDA QQ4           ; The system's government is determined by the value in
     5392 0F29     
17998                                                                          ; QQ4, so fetch it into A
17999               
18000                      .clc                            ; CLC               ; Print recursive token 17 + A, followed by a paragraph
     **** ****     > CLC
0001 5394 0A16  18        sla  rzero,1
                   < elite.a99
18001                      .adi (>b1*256)                  ; ADC #177          ; break and Sentence Case, so:
     **** ****     > ADI
0001 5396 1701  14        jnc  !
0002 5398 B347  18        ab   rone,ra
0003               !:
0004 539A 022D  22        ai   ra,(>B1*256)
     539C B100     
                   < elite.a99
18002 539E 0200  20        li   rtmp,TT60                  ; JSR TT60          ;
     53A0 52BC     
18003 53A2 06A0  32        bl   @jsr                       ;
     53A4 FE28     
18004                                                                          ; QQ4 = 0 prints token 17 ("ANARCHY")
18005                                                                          ; QQ4 = 1 prints token 18 ("FEUDAL")
18006                                                                          ; QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
18007                                                                          ; QQ4 = 3 prints token 20 ("DICTATORSHIP")
18008                                                                          ; QQ4 = 4 prints token 21 ("COMMUNIST")
18009                                                                          ; QQ4 = 5 prints token 22 ("CONFEDERACY")
18010                                                                          ; QQ4 = 6 prints token 23 ("DEMOCRACY")
18011                                                                          ; QQ4 = 7 prints token 24 ("CORPORATE STATE")
18012               
18013 53A6 020D  20        li   ra,>c4*256                 ; LDA #196          ; Print recursive token 36 ("TECH.LEVEL") followed by a
     53A8 C400     
18014 53AA 0200  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     53AC AC94     
18015 53AE 06A0  32        bl   @jsr                       ;
     53B0 FE28     
18016               
18017 53B2 D3A0  30        movb @QQ5,rx                    ; LDX QQ5           ; Fetch the tech level from QQ5 and increment it, as it
     53B4 0F2A     
18018 53B6 B387  18        ab   rone,rx                    ; INX               ; is stored in the range 0-14 but the displayed range
18019                                                                          ; should be 1-15
18020               
18021                      .clc                            ; CLC               ; Call pr2 to print the technology level as a 3-digit
     **** ****     > CLC
0001 53B8 0A16  18        sla  rzero,1
                   < elite.a99
18022 53BA 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; number without a decimal point (by clearing the C
     53BC 322C     
18023 53BE 06A0  32        bl   @jsr                       ;
     53C0 FE28     
18024                                                                          ; flag)
18025               
18026 53C2 0200  20        li   rtmp,TTX69                 ; JSR TTX69         ; Print a paragraph break and set Sentence Case
     53C4 52C4     
18027 53C6 06A0  32        bl   @jsr                       ;
     53C8 FE28     
18028               
18029 53CA 020D  20        li   ra,>c0*256                 ; LDA #192          ; Print recursive token 32 ("POPULATION") followed by a
     53CC C000     
18030 53CE 0200  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     53D0 AC94     
18031 53D2 06A0  32        bl   @jsr                       ;
     53D4 FE28     
18032               
18033                      .sec                            ; SEC               ; Call pr2 to print the population as a 3-digit number
     **** ****     > SEC
0001 53D6 0A18  18        sla  rmone,1
                   < elite.a99
18034 53D8 D3A0  30        movb @QQ6,rx                    ; LDX QQ6           ; with a decimal point (by setting the C flag), so the
     53DA 0F2B     
18035 53DC 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; number printed will be population / 10
     53DE 322C     
18036 53E0 06A0  32        bl   @jsr                       ;
     53E2 FE28     
18037               
18038 53E4 020D  20        li   ra,>c6*256                 ; LDA #198          ; Print recursive token 38 (" BILLION"), followed by a
     53E6 C600     
18039 53E8 0200  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     53EA 52BC     
18040 53EC 06A0  32        bl   @jsr                       ;
     53EE FE28     
18041               
18042 53F0 020D  20        li   ra,('(')*256               ; LDA #'('          ; Print an opening bracket
     53F2 2800     
18043 53F4 0200  20        li   rtmp,TT27                  ; JSR TT27
     53F6 ACA0     
18044 53F8 06A0  32        bl   @jsr                       ;
     53FA FE28     
18045               
18046 53FC D360  30        movb @QQ15+4,ra                 ; LDA QQ15+4        ; Now to calculate the species, so first check bit 7 of
     53FE 007C     
18047 5400 1108  14        jlt  TT75                       ; BMI TT75          ; s2_lo, and if it is set, jump to TT75 as this is an
18048                                                                          ; alien species
18049               
18050 5402 020D  20        li   ra,>bc*256                 ; LDA #188          ; Bit 7 of s2_lo is clear, so print recursive token 28
     5404 BC00     
18051 5406 0200  20        li   rtmp,TT27                  ; JSR TT27          ; ("HUMAN COLONIAL")
     5408 ACA0     
18052 540A 06A0  32        bl   @jsr                       ;
     540C FE28     
18053               
18054 540E 0460  28        b    @TT76                      ; JMP TT76          ; Jump to TT76 to print "S)" and a paragraph break, so
     5410 54A6     
18055                                                                          ; the whole species string is "(HUMAN COLONIALS)"
18056               
18057               TT75:
18058 5412 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; This is an alien species, and we start with the first
     5414 007D     
18059 5416 091D  18        srl  ra,1                       ; LSR A             ; adjective, so fetch bits 2-7 of s2_hi into A and push
18060 5418 091D  18        srl  ra,1                       ; LSR A             ; onto the stack so we can use this later
18061                      .pha                            ; PHA
     **** ****     > PHA
0001 541A D68D  30        movb ra,*rsp
0002 541C 060A  14        dec  rsp
                   < elite.a99
18062               
18063 541E 024D  22        andi ra,>07*256                 ; AND #%00000111    ; Set A = bits 0-2 of A (so that's bits 2-4 of s2_hi)
     5420 0700     
18064               
18065 5422 028D  22        ci   ra,>03*256                 ; CMP #3            ; If A >= 3, jump to TT205 to skip the first adjective,
     5424 0300     
18066 5426 1808  14        joc  TT205                      ; BCS TT205
18067               
18068                      .adi (>e3*256)                  ; ADC #227          ; Otherwise A = 0, 1 or 2, so print recursive token
     **** ****     > ADI
0001 5428 1701  14        jnc  !
0002 542A B347  18        ab   rone,ra
0003               !:
0004 542C 022D  22        ai   ra,(>E3*256)
     542E E300     
                   < elite.a99
18069 5430 0200  20        li   rtmp,spc_                  ; JSR spc           ; 67 + A, followed by a space, so:
     5432 52E6     
18070 5434 06A0  32        bl   @jsr                       ;
     5436 FE28     
18071                                                                          ;
18072                                                                          ; A = 0 prints token 67 ("LARGE") and a space
18073                                                                          ; A = 1 prints token 68 ("FIERCE") and a space
18074                                                                          ; A = 2 prints token 69 ("SMALL") and a space
18075               
18076               TT205:
18077                      .pla                            ; PLA               ; Now for the second adjective, so restore A to bits
     **** ****     > PLA
0001 5438 058A  14        inc  rsp
0002 543A D35A  26        movb *rsp,ra
                   < elite.a99
18078 543C 091D  18        srl  ra,1                       ; LSR A             ; 2-7 of s2_hi, and throw away bits 2-4 to leave
18079 543E 091D  18        srl  ra,1                       ; LSR A             ; A = bits 5-7 of s2_hi
18080 5440 091D  18        srl  ra,1                       ; LSR A
18081               
18082 5442 028D  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT206 to skip the second adjective
     5444 0600     
18083 5446 1808  14        joc  TT206                      ; BCS TT206
18084               
18085                      .adi (>e6*256)                  ; ADC #230          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5448 1701  14        jnc  !
0002 544A B347  18        ab   rone,ra
0003               !:
0004 544C 022D  22        ai   ra,(>E6*256)
     544E E600     
                   < elite.a99
18086 5450 0200  20        li   rtmp,spc_                  ; JSR spc           ; 70 + A, followed by a space, so:
     5452 52E6     
18087 5454 06A0  32        bl   @jsr                       ;
     5456 FE28     
18088                                                                          ;
18089                                                                          ; A = 0 prints token 70 ("GREEN") and a space
18090                                                                          ; A = 1 prints token 71 ("RED") and a space
18091                                                                          ; A = 2 prints token 72 ("YELLOW") and a space
18092                                                                          ; A = 3 prints token 73 ("BLUE") and a space
18093                                                                          ; A = 4 prints token 74 ("BLACK") and a space
18094                                                                          ; A = 5 prints token 75 ("HARMLESS") and a space
18095               
18096               TT206:
18097 5458 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Now for the third adjective, so EOR the high bytes of
     545A 007B     
18098                      .eor @QQ15+1                    ; EOR QQ15+1        ; s0 and s1 and extract bits 0-2 of the result:
     **** ****     > EOR
0001 545C D020  30        movb @QQ15+1,rtmp
     545E 0079     
0002 5460 2B40  18        xor  rtmp,ra
                   < elite.a99
18099 5462 024D  22        andi ra,>07*256                 ; AND #%00000111    ;
     5464 0700     
18100 5466 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; A = (s0_hi EOR s1_hi) AND %111
     5468 007F     
18101                                                                          ;
18102                                                                          ; storing the result in QQ19 so we can use it later
18103               
18104 546A 028D  22        ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT207 to skip the third adjective
     546C 0600     
18105 546E 1808  14        joc  TT207                      ; BCS TT207
18106               
18107                      .adi (>ec*256)                  ; ADC #236          ; Otherwise A = 0 to 5, so print recursive token
     **** ****     > ADI
0001 5470 1701  14        jnc  !
0002 5472 B347  18        ab   rone,ra
0003               !:
0004 5474 022D  22        ai   ra,(>EC*256)
     5476 EC00     
                   < elite.a99
18108 5478 0200  20        li   rtmp,spc_                  ; JSR spc           ; 76 + A, followed by a space, so:
     547A 52E6     
18109 547C 06A0  32        bl   @jsr                       ;
     547E FE28     
18110                                                                          ;
18111                                                                          ; A = 0 prints token 76 ("SLIMY") and a space
18112                                                                          ; A = 1 prints token 77 ("BUG-EYED") and a space
18113                                                                          ; A = 2 prints token 78 ("HORNED") and a space
18114                                                                          ; A = 3 prints token 79 ("BONY") and a space
18115                                                                          ; A = 4 prints token 80 ("FAT") and a space
18116                                                                          ; A = 5 prints token 81 ("FURRY") and a space
18117               
18118               TT207:
18119 5480 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Now for the actual species, so take bits 0-1 of
     5482 007D     
18120 5484 024D  22        andi ra,>03*256                 ; AND #%00000011    ; s2_hi, add this to the value of A that we used for
     5486 0300     
18121                      .clc                            ; CLC               ; the third adjective, and take bits 0-2 of the result
     **** ****     > CLC
0001 5488 0A16  18        sla  rzero,1
                   < elite.a99
18122                      .adc @QQ19,ra                   ; ADC QQ19
     **** ****     > ADC
0001 548A 1701  14        jnc  !
0002 548C B347  18        ab   rone,ra
0003               !:
0004 548E B360  30        ab   @QQ19,ra
     5490 007F     
                   < elite.a99
18123 5492 024D  22        andi ra,>07*256                 ; AND #%00000111
     5494 0700     
18124               
18125                      .adi (>f2*256)                  ; ADC #242          ; A = 0 to 7, so print recursive token 82 + A, so:
     **** ****     > ADI
0001 5496 1701  14        jnc  !
0002 5498 B347  18        ab   rone,ra
0003               !:
0004 549A 022D  22        ai   ra,(>F2*256)
     549C F200     
                   < elite.a99
18126 549E 0200  20        li   rtmp,TT27                  ; JSR TT27          ;
     54A0 ACA0     
18127 54A2 06A0  32        bl   @jsr                       ;
     54A4 FE28     
18128                                                                          ; A = 0 prints token 82 ("RODENT")
18129                                                                          ; A = 1 prints token 83 ("FROG")
18130                                                                          ; A = 2 prints token 84 ("LIZARD")
18131                                                                          ; A = 3 prints token 85 ("LOBSTER")
18132                                                                          ; A = 4 prints token 86 ("BIRD")
18133                                                                          ; A = 5 prints token 87 ("HUMANOID")
18134                                                                          ; A = 6 prints token 88 ("FELINE")
18135                                                                          ; A = 7 prints token 89 ("INSECT")
18136               
18137               TT76:
18138 54A6 020D  20        li   ra,('S')*256               ; LDA #'S'          ; Print an "S" to pluralise the species
     54A8 5300     
18139 54AA 0200  20        li   rtmp,TT27                  ; JSR TT27
     54AC ACA0     
18140 54AE 06A0  32        bl   @jsr                       ;
     54B0 FE28     
18141               
18142 54B2 020D  20        li   ra,(')')*256               ; LDA #')'          ; And finally, print a closing bracket, followed by a
     54B4 2900     
18143 54B6 0200  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case, to end the species
     54B8 52BC     
18144 54BA 06A0  32        bl   @jsr                       ;
     54BC FE28     
18145                                                                          ; section
18146               
18147 54BE 020D  20        li   ra,>c1*256                 ; LDA #193          ; Print recursive token 33 ("GROSS PRODUCTIVITY"),
     54C0 C100     
18148 54C2 0200  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     54C4 AC94     
18149 54C6 06A0  32        bl   @jsr                       ;
     54C8 FE28     
18150               
18151 54CA D3A0  30        movb @QQ7,rx                    ; LDX QQ7           ; Fetch the 16-bit productivity value from QQ7 into
     54CC 0F2D     
18152 54CE D3E0  30        movb @QQ7+1,ry                  ; LDY QQ7+1         ; (Y X)
     54D0 0F2E     
18153               
18154 54D2 0200  20        li   rtmp,pr6_                  ; JSR pr6           ; Print (Y X) to 5 digits with no decimal point
     54D4 A2A0     
18155 54D6 06A0  32        bl   @jsr                       ;
     54D8 FE28     
18156               
18157 54DA 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     54DC A3D0     
18158 54DE 06A0  32        bl   @jsr                       ;
     54E0 FE28     
18159               
18160 54E2 020D  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     54E4 0000     
18161 54E6 D80D  30        movb ra,@QQ17                   ; STA QQ17
     54E8 007E     
18162               
18163 54EA 020D  20        li   ra,('M')*256               ; LDA #'M'          ; Print "M"
     54EC 4D00     
18164 54EE 0200  20        li   rtmp,TT27                  ; JSR TT27
     54F0 ACA0     
18165 54F2 06A0  32        bl   @jsr                       ;
     54F4 FE28     
18166               
18167 54F6 020D  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR"), followed by a
     54F8 E200     
18168 54FA 0200  20        li   rtmp,TT60                  ; JSR TT60          ; paragraph break and Sentence Case
     54FC 52BC     
18169 54FE 06A0  32        bl   @jsr                       ;
     5500 FE28     
18170               
18171 5502 020D  20        li   ra,>fa*256                 ; LDA #250          ; Print recursive token 90 ("AVERAGE RADIUS"), followed
     5504 FA00     
18172 5506 0200  20        li   rtmp,TT68                  ; JSR TT68          ; by a colon
     5508 AC94     
18173 550A 06A0  32        bl   @jsr                       ;
     550C FE28     
18174               
18175                                                                          ; The average radius is calculated like this:
18176                                                                          ;
18177                                                                          ; ((s2_hi AND %1111) + 11) * 256 + s1_hi
18178                                                                          ;
18179                                                                          ; or, in terms of memory locations:
18180                                                                          ;
18181                                                                          ; ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
18182                                                                          ;
18183                                                                          ; Because the multiplication is by 256, this is the
18184                                                                          ; same as saying a 16-bit number, with high byte:
18185                                                                          ;
18186                                                                          ; (QQ15+5 AND %1111) + 11
18187                                                                          ;
18188                                                                          ; and low byte:
18189                                                                          ;
18190                                                                          ; QQ15+3
18191                                                                          ;
18192                                                                          ; so we can set this up in (Y X) and call the pr5
18193                                                                          ; routine to print it out
18194               
18195 550E D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Set A = QQ15+5
     5510 007D     
18196 5512 D3A0  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Set X = QQ15+3
     5514 007B     
18197               
18198 5516 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Set Y = (A AND %1111) + 11
     5518 0F00     
18199                      .clc                            ; CLC
     **** ****     > CLC
0001 551A 0A16  18        sla  rzero,1
                   < elite.a99
18200                      .adi (>0b*256)                  ; ADC #11
     **** ****     > ADI
0001 551C 1701  14        jnc  !
0002 551E B347  18        ab   rone,ra
0003               !:
0004 5520 022D  22        ai   ra,(>0B*256)
     5522 0B00     
                   < elite.a99
18201 5524 D3CD  18        movb ra,ry                      ; TAY
18202               
18203 5526 0200  20        li   rtmp,pr5_                  ; JSR pr5           ; Print (Y X) to 5 digits, not including a decimal
     5528 A2A2     
18204 552A 06A0  32        bl   @jsr                       ;
     552C FE28     
18205                                                                          ; point, as the C flag will be clear (as the maximum
18206                                                                          ; radius will always fit into 16 bits)
18207               
18208 552E 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     5530 A3D0     
18209 5532 06A0  32        bl   @jsr                       ;
     5534 FE28     
18210               
18211 5536 020D  20        li   ra,('k')*256               ; LDA #'k'          ; Print "km", returning from the subroutine using a
     5538 6B00     
18212 553A 0200  20        li   rtmp,TT26                  ; JSR TT26          ; tail call
     553C 341A     
18213 553E 06A0  32        bl   @jsr                       ;
     5540 FE28     
18214 5542 020D  20        li   ra,('m')*256               ; LDA #'m'
     5544 6D00     
18215 5546 0460  28        b    @TT26                      ; JMP TT26
     5548 341A     
18216               
18217               * ******************************************************************************
18218               *
18219               * Name: TT24
18220               * Type: Subroutine
18221               * Category: Universe
18222               * Summary: Calculate system data from the system seeds
18223               * Deep dive: Generating system data
18224               * Galaxy and system seeds
18225               *
18226               * ------------------------------------------------------------------------------
18227               *
18228               * Calculate system data from the seeds in QQ15 and store them in the relevant
18229               * locations. Specifically, this routine calculates the following from the three
18230               * 16-bit seeds in QQ15 (using only s0_hi, s1_hi and s1_lo):
18231               *
18232               * QQ3 = economy (0-7)
18233               * QQ4 = government (0-7)
18234               * QQ5 = technology level (0-14)
18235               * QQ6 = population * 10 (1-71)
18236               * QQ7 = productivity (96-62480)
18237               *
18238               * The ranges of the various values are shown in brackets. Note that the radius
18239               * and type of inhabitant are calculated on-the-fly in the TT25 routine when
18240               * the system data gets displayed, so they aren't calculated here.
18241               *
18242               * ******************************************************************************
18243               
18244               TT24:
18245 554A D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi and extract bits 0-2 to determine the
     554C 0079     
18246 554E 024D  22        andi ra,>07*256                 ; AND #%00000111    ; system's economy, and store in QQ3
     5550 0700     
18247 5552 D80D  30        movb ra,@QQ3                    ; STA QQ3
     5554 0F28     
18248               
18249 5556 D360  30        movb @QQ15+2,ra                 ; LDA QQ15+2        ; Fetch s1_lo and extract bits 3-5 to determine the
     5558 007A     
18250 555A 091D  18        srl  ra,1                       ; LSR A             ; system's government, and store in QQ4
18251 555C 091D  18        srl  ra,1                       ; LSR A
18252 555E 091D  18        srl  ra,1                       ; LSR A
18253 5560 024D  22        andi ra,>07*256                 ; AND #%00000111
     5562 0700     
18254 5564 D80D  30        movb ra,@QQ4                    ; STA QQ4
     5566 0F29     
18255               
18256 5568 091D  18        srl  ra,1                       ; LSR A             ; If government isn't anarchy or feudal, skip to TT77,
18257 556A 1606  14        jne  TT77                       ; BNE TT77          ; as we need to fix the economy of anarchy and feudal
18258                                                                          ; systems so they can't be rich
18259               
18260 556C D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Set bit 1 of the economy in QQ3 to fix the economy
     556E 0F28     
18261 5570 026D  22        ori  ra,>02*256                 ; ORA #%00000010    ; for anarchy and feudal governments
     5572 0200     
18262 5574 D80D  30        movb ra,@QQ3                    ; STA QQ3
     5576 0F28     
18263               
18264               TT77:
18265 5578 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the tech level, which we do like this:
     557A 0F28     
18266                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 557C 0200  20        li   rtmp,(>07*256)
     557E 0700     
0002 5580 2B40  18        xor  rtmp,ra
                   < elite.a99
18267                      .clc                            ; CLC               ; flipped_economy + (s1_hi AND %11) + (government / 2)
     **** ****     > CLC
0001 5582 0A16  18        sla  rzero,1
                   < elite.a99
18268 5584 D80D  30        movb ra,@QQ5                    ; STA QQ5           ;
     5586 0F2A     
18269                                                                          ; or, in terms of memory locations:
18270                                                                          ;
18271                                                                          ; QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
18272                                                                          ;
18273                                                                          ; We start by setting QQ5 = QQ3 EOR %111
18274               
18275 5588 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; We then take the first 2 bits of s1_hi (QQ15+3) and
     558A 007B     
18276 558C 024D  22        andi ra,>03*256                 ; AND #%00000011    ; add it into QQ5
     558E 0300     
18277                      .adc @QQ5,ra                    ; ADC QQ5
     **** ****     > ADC
0001 5590 1701  14        jnc  !
0002 5592 B347  18        ab   rone,ra
0003               !:
0004 5594 B360  30        ab   @QQ5,ra
     5596 0F2A     
                   < elite.a99
18278 5598 D80D  30        movb ra,@QQ5                    ; STA QQ5
     559A 0F2A     
18279               
18280 559C D360  30        movb @QQ4,ra                    ; LDA QQ4           ; And finally we add QQ4 / 2 and store the result in
     559E 0F29     
18281 55A0 091D  18        srl  ra,1                       ; LSR A             ; QQ5, using LSR then ADC to divide by 2, which rounds
18282                      .adc @QQ5,ra                    ; ADC QQ5           ; up the result for odd-numbered government types
     **** ****     > ADC
0001 55A2 1701  14        jnc  !
0002 55A4 B347  18        ab   rone,ra
0003               !:
0004 55A6 B360  30        ab   @QQ5,ra
     55A8 0F2A     
                   < elite.a99
18283 55AA D80D  30        movb ra,@QQ5                    ; STA QQ5
     55AC 0F2A     
18284               
18285                      .asla                           ; ASL A             ; Now to work out the population, like so:
     **** ****     > ASLA
0001 55AE 024D  22        andi ra,>ff00
     55B0 FF00     
0002 55B2 0A1D  18        sla  ra,1
                   < elite.a99
18286                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 55B4 024D  22        andi ra,>ff00
     55B6 FF00     
0002 55B8 0A1D  18        sla  ra,1
                   < elite.a99
18287                      .adc @QQ3,ra                    ; ADC QQ3           ; (tech level * 4) + economy + government + 1
     **** ****     > ADC
0001 55BA 1701  14        jnc  !
0002 55BC B347  18        ab   rone,ra
0003               !:
0004 55BE B360  30        ab   @QQ3,ra
     55C0 0F28     
                   < elite.a99
18288                      .adc @QQ4,ra                    ; ADC QQ4           ;
     **** ****     > ADC
0001 55C2 1701  14        jnc  !
0002 55C4 B347  18        ab   rone,ra
0003               !:
0004 55C6 B360  30        ab   @QQ4,ra
     55C8 0F29     
                   < elite.a99
18289                      .adi (>01*256)                  ; ADC #1            ; or, in terms of memory locations:
     **** ****     > ADI
0001 55CA 1701  14        jnc  !
0002 55CC B347  18        ab   rone,ra
0003               !:
0004 55CE 022D  22        ai   ra,(>01*256)
     55D0 0100     
                   < elite.a99
18290 55D2 D80D  30        movb ra,@QQ6                    ; STA QQ6           ;
     55D4 0F2B     
18291                                                                          ; QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1
18292               
18293 55D6 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Finally, we work out productivity, like this:
     55D8 0F28     
18294                      .eoi (>07*256)                  ; EOR #%00000111    ;
     **** ****     > EOI
0001 55DA 0200  20        li   rtmp,(>07*256)
     55DC 0700     
0002 55DE 2B40  18        xor  rtmp,ra
                   < elite.a99
18295                      .adi (>03*256)                  ; ADC #3            ; (flipped_economy + 3) * (government + 4)
     **** ****     > ADI
0001 55E0 1701  14        jnc  !
0002 55E2 B347  18        ab   rone,ra
0003               !:
0004 55E4 022D  22        ai   ra,(>03*256)
     55E6 0300     
                   < elite.a99
18296 55E8 D80D  30        movb ra,@P                      ; STA P             ; * population
     55EA 001B     
18297 55EC D360  30        movb @QQ4,ra                    ; LDA QQ4           ; * 8
     55EE 0F29     
18298                      .adi (>04*256)                  ; ADC #4            ;
     **** ****     > ADI
0001 55F0 1701  14        jnc  !
0002 55F2 B347  18        ab   rone,ra
0003               !:
0004 55F4 022D  22        ai   ra,(>04*256)
     55F6 0400     
                   < elite.a99
18299 55F8 D80D  30        movb ra,@Q                      ; STA Q             ; or, in terms of memory locations:
     55FA 0090     
18300 55FC 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ;
     55FE 4676     
18301 5600 06A0  32        bl   @jsr                       ;
     5602 FE28     
18302                                                                          ; QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
18303                                                                          ;
18304                                                                          ; We do the first step by setting P to the first
18305                                                                          ; expression in brackets and Q to the second, and
18306                                                                          ; calling MULTU, so now (A P) = P * Q. The highest this
18307                                                                          ; can be is 10 * 11 (as the maximum values of economy
18308                                                                          ; and government are 7), so the high byte of the result
18309                                                                          ; will always be 0, so we actually have:
18310                                                                          ;
18311                                                                          ; P = P * Q
18312                                                                          ; = (flipped_economy + 3) * (government + 4)
18313               
18314 5604 D360  30        movb @QQ6,ra                    ; LDA QQ6           ; We now take the result in P and multiply by the
     5606 0F2B     
18315 5608 D80D  30        movb ra,@Q                      ; STA Q             ; population to get the productivity, by setting Q to
     560A 0090     
18316 560C 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ; the population from QQ6 and calling MULTU again, so
     560E 4676     
18317 5610 06A0  32        bl   @jsr                       ;
     5612 FE28     
18318                                                                          ; now we have:
18319                                                                          ;
18320                                                                          ; (A P) = P * population
18321               
18322                      .asl @P                         ; ASL P             ; Next we multiply the result by 8, as a 16-bit number,
     **** ****     > ASL
0001 5614 D020  30        movb @P,rtmp
     5616 001B     
0002 5618 0240  22        andi rtmp,>ff00
     561A FF00     
0003 561C 0A10  18        sla  rtmp,1
0004 561E D800  30        movb rtmp,@P
     5620 001B     
                   < elite.a99
18323 5622 06A0  32        bl   @rola                      ; ROL A             ; so we shift both bytes to the left three times, using
     5624 FE3E     
18324                      .asl @P                         ; ASL P             ; the C flag to carry bits from bit 7 of the low byte
     **** ****     > ASL
0001 5626 D020  30        movb @P,rtmp
     5628 001B     
0002 562A 0240  22        andi rtmp,>ff00
     562C FF00     
0003 562E 0A10  18        sla  rtmp,1
0004 5630 D800  30        movb rtmp,@P
     5632 001B     
                   < elite.a99
18325 5634 06A0  32        bl   @rola                      ; ROL A             ; into bit 0 of the high byte
     5636 FE3E     
18326                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 5638 D020  30        movb @P,rtmp
     563A 001B     
0002 563C 0240  22        andi rtmp,>ff00
     563E FF00     
0003 5640 0A10  18        sla  rtmp,1
0004 5642 D800  30        movb rtmp,@P
     5644 001B     
                   < elite.a99
18327 5646 06A0  32        bl   @rola                      ; ROL A
     5648 FE3E     
18328               
18329 564A D80D  30        movb ra,@QQ7+1                  ; STA QQ7+1         ; Finally, we store the productivity in two bytes, with
     564C 0F2E     
18330 564E D360  30        movb @P,ra                      ; LDA P             ; the low byte in QQ7 and the high byte in QQ7+1
     5650 001B     
18331 5652 D80D  30        movb ra,@QQ7                    ; STA QQ7
     5654 0F2D     
18332               
18333 5656 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5658 FE34     
18334               
18335               * ******************************************************************************
18336               *
18337               * Name: TT22
18338               * Type: Subroutine
18339               * Category: Charts
18340               * Summary: Show the Long-range Chart (red key f4)
18341               *
18342               * ******************************************************************************
18343               
18344               TT22:
18345 565A 020D  20        li   ra,>40*256                 ; LDA #64           ; Clear the top part of the screen, draw a white border,
     565C 4000     
18346 565E 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Long-
     5660 4EFA     
18347 5662 06A0  32        bl   @jsr                       ;
     5664 FE28     
18348                                                                          ; range Chart)
18349               
18350 5666 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     5668 0700     
18351 566A D80D  30        movb ra,@XC                     ; STA XC
     566C 002C     
18352               
18353 566E 0200  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5670 5EC2     
18354 5672 06A0  32        bl   @jsr                       ;
     5674 FE28     
18355                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
18356               
18357 5676 020D  20        li   ra,>c7*256                 ; LDA #199          ; Print recursive token 39 ("GALACTIC CHART{galaxy
     5678 C700     
18358 567A 0200  20        li   rtmp,TT27                  ; JSR TT27          ; number right-aligned to width 3}")
     567C ACA0     
18359 567E 06A0  32        bl   @jsr                       ;
     5680 FE28     
18360               
18361 5682 0200  20        li   rtmp,NLIN                  ; JSR NLIN          ; Draw a horizontal line at pixel row 23 to box in the
     5684 2746     
18362 5686 06A0  32        bl   @jsr                       ;
     5688 FE28     
18363                                                                          ; title and act as the top frame of the chart, and move
18364                                                                          ; the text cursor down one line
18365               
18366 568A 020D  20        li   ra,>98*256                 ; LDA #152          ; Draw a screen-wide horizontal line at pixel row 152
     568C 9800     
18367 568E 0200  20        li   rtmp,NLIN2                 ; JSR NLIN2         ; for the bottom edge of the chart, so the chart itself
     5690 274C     
18368 5692 06A0  32        bl   @jsr                       ;
     5694 FE28     
18369                                                                          ; is 128 pixels high, starting on row 24 and ending on
18370                                                                          ; row 151
18371               
18372 5696 0200  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     5698 57E2     
18373 569A 06A0  32        bl   @jsr                       ;
     569C FE28     
18374                                                                          ; current system's galactic coordinates
18375               
18376 569E 020E  20        li   rx,>00*256                 ; LDX #0            ; We're now going to plot each of the galaxy's systems,
     56A0 0000     
18377                                                                          ; so set up a counter in X for each system, starting at
18378                                                                          ; 0 and looping through to 255
18379               
18380               TT83:
18381 56A2 D80E  30        movb rx,@XSAV                   ; STX XSAV          ; Store the counter in XSAV
     56A4 0093     
18382               
18383 56A6 D3A0  30        movb @QQ15+3,rx                 ; LDX QQ15+3        ; Fetch the s1_hi seed into X, which gives us the
     56A8 007B     
18384                                                                          ; galactic x-coordinate of this system
18385               
18386 56AA D3E0  30        movb @QQ15+4,ry                 ; LDY QQ15+4        ; Fetch the s2_lo seed and set bits 4 and 6, storing the
     56AC 007C     
18387 56AE D34F  18        movb ry,ra                      ; TYA               ; result in ZZ to give a random number between 80 and
18388 56B0 026D  22        ori  ra,>50*256                 ; ORA #%01010000    ; (but which will always be the same for this system).
     56B2 5000     
18389 56B4 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; We use this value to determine the size of the point
     56B6 0097     
18390                                                                          ; for this system on the chart by passing it as the
18391                                                                          ; distance argument to the PIXEL routine below
18392               
18393 56B8 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch the s0_hi seed into A, which gives us the
     56BA 0079     
18394                                                                          ; galactic y-coordinate of this system
18395               
18396 56BC 091D  18        srl  ra,1                       ; LSR A             ; We halve the y-coordinate because the galaxy in
18397                                                                          ; in Elite is rectangular rather than square, and is
18398                                                                          ; twice as wide (x-axis) as it is high (y-axis), so the
18399                                                                          ; chart is 256 pixels wide and 128 high
18400               
18401                      .clc                            ; CLC               ; Add 24 to the halved y-coordinate and store in XX15+1
     **** ****     > CLC
0001 56BE 0A16  18        sla  rzero,1
                   < elite.a99
18402                      .adi (>18*256)                  ; ADC #24           ; (as the top of the chart is on pixel row 24, just
     **** ****     > ADI
0001 56C0 1701  14        jnc  !
0002 56C2 B347  18        ab   rone,ra
0003               !:
0004 56C4 022D  22        ai   ra,(>18*256)
     56C6 1800     
                   < elite.a99
18403 56C8 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; below the line we drew on row 23 above)
     56CA 0032     
18404               
18405 56CC 0200  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Call PIXEL to draw a point at (X, A), with the size of
     56CE 2974     
18406 56D0 06A0  32        bl   @jsr                       ;
     56D2 FE28     
18407                                                                          ; the point dependent on the distance specified in ZZ
18408                                                                          ; (so a high value of ZZ will produce a 1-pixel point,
18409                                                                          ; a medium value will produce a 2-pixel dash, and a
18410                                                                          ; small value will produce a 4-pixel square)
18411               
18412 56D4 0200  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     56D6 521A     
18413 56D8 06A0  32        bl   @jsr                       ;
     56DA FE28     
18414                                                                          ; to twist the three 16-bit seeds in QQ15
18415               
18416 56DC D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the loop counter from XSAV
     56DE 0093     
18417               
18418 56E0 B387  18        ab   rone,rx                    ; INX               ; Increment the counter
18419               
18420 56E2 16DF  14        jne  TT83                       ; BNE TT83          ; If X > 0 then we haven't done all 256 systems yet, so
18421                                                                          ; loop back up to TT83
18422               
18423 56E4 D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Set QQ19 to the selected system's x-coordinate
     56E6 0F31     
18424 56E8 D80D  30        movb ra,@QQ19                   ; STA QQ19
     56EA 007F     
18425               
18426 56EC D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set QQ19+1 to the selected system's y-coordinate,
     56EE 0F32     
18427 56F0 091D  18        srl  ra,1                       ; LSR A             ; halved to fit it into the chart
18428 56F2 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1
     56F4 0080     
18429               
18430 56F6 020D  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to size 4 for the crosshairs size
     56F8 0400     
18431 56FA D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     56FC 0081     
18432               
18433                                                                          ; Fall through into TT15 to draw crosshairs of size 4 at
18434                                                                          ; the selected system's coordinates
18435               
18436               * ******************************************************************************
18437               *
18438               * Name: TT15
18439               * Type: Subroutine
18440               * Category: Drawing lines
18441               * Summary: Draw a set of crosshairs
18442               *
18443               * ------------------------------------------------------------------------------
18444               *
18445               * For all views except the Short-range Chart, the centre is drawn 24 pixels to
18446               * the right of the y-coordinate given.
18447               *
18448               * ------------------------------------------------------------------------------
18449               *
18450               * Arguments:
18451               *
18452               * QQ19                The pixel x-coordinate of the centre of the crosshairs
18453               *
18454               * QQ19+1              The pixel y-coordinate of the centre of the crosshairs
18455               *
18456               * QQ19+2              The size of the crosshairs
18457               *
18458               * ******************************************************************************
18459               
18460               TT15:
18461 56FE 020D  20        li   ra,>18*256                 ; LDA #24           ; Set A to 24, which we will use as the minimum
     5700 1800     
18462                                                                          ; screen indent for the crosshairs (i.e. the minimum
18463                                                                          ; distance from the top-left corner of the screen)
18464               
18465 5702 D3A0  30        movb @QQ11,rx                   ; LDX QQ11          ; If the current view is not the Short-range Chart,
     5704 0096     
18466 5706 1502  14        jgt  B52                        ; BPL B52           ; which is the only view with bit 7 set, then skip the
18467                                                                          ; following instruction
18468               
18469 5708 020D  20        li   ra,>00*256                 ; LDA #0            ; This is the Short-range Chart, so set A to 0, so the
     570A 0000     
18470                                                                          ; crosshairs can go right up against the screen edges
18471               
18472               B52:
18473 570C D80D  30        movb ra,@QQ19+5                 ; STA QQ19+5        ; Set QQ19+5 to A, which now contains the correct indent
     570E 0084     
18474                                                                          ; for this view
18475               
18476 5710 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate - crosshairs size
     5712 007F     
18477                      .sec                            ; SEC               ; to get the x-coordinate of the left edge of the
     **** ****     > SEC
0001 5714 0A18  18        sla  rmone,1
                   < elite.a99
18478                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 5716 1801  14        joc  !
0002 5718 7347  18        sb   rone,ra
0003               !:
0004 571A 7360  30        sb   @QQ19+2,ra
     571C 0081     
                   < elite.a99
18479               
18480 571E 1802  14        joc  TT84                       ; BCS TT84          ; If the above subtraction didn't underflow, then A is
18481                                                                          ; positive, so skip the next instruction
18482               
18483 5720 020D  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     5722 0000     
18484                                                                          ; crosshairs don't spill out of the left of the screen
18485               
18486               TT84:
18487                                                                          ; In the following, the authors have used XX15 for
18488                                                                          ; temporary storage. XX15 shares location with X1, Y1,
18489                                                                          ; X2 and Y2, so in the following, you can consider
18490                                                                          ; the variables like this:
18491                                                                          ;
18492                                                                          ; XX15   is the same as X1
18493                                                                          ; XX15+1 is the same as Y1
18494                                                                          ; XX15+2 is the same as X2
18495                                                                          ; XX15+3 is the same as Y2
18496                                                                          ;
18497                                                                          ; Presumably this routine was written at a different
18498                                                                          ; time to the line-drawing routine, before the two
18499                                                                          ; workspaces were merged to save space
18500 5724 D80D  30        movb ra,@XX15                   ; STA XX15          ; Set XX15 (X1) = A (the x-coordinate of the left edge
     5726 0031     
18501                                                                          ; of the crosshairs)
18502               
18503 5728 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate + crosshairs size
     572A 007F     
18504                      .clc                            ; CLC               ; to get the x-coordinate of the right edge of the
     **** ****     > CLC
0001 572C 0A16  18        sla  rzero,1
                   < elite.a99
18505                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; crosshairs
     **** ****     > ADC
0001 572E 1701  14        jnc  !
0002 5730 B347  18        ab   rone,ra
0003               !:
0004 5732 B360  30        ab   @QQ19+2,ra
     5734 0081     
                   < elite.a99
18506               
18507 5736 1702  14        jnc  B53                        ; BCC B53           ; If the above addition didn't overflow, then A is
18508                                                                          ; correct, so skip the next instruction
18509               
18510 5738 020D  20        li   ra,>ff*256                 ; LDA #255          ; The addition overflowed, so set A to 255 so the
     573A FF00     
18511                                                                          ; crosshairs don't spill out of the right of the screen
18512                                                                          ; (as 255 is the x-coordinate of the rightmost pixel
18513                                                                          ; on-screen)
18514               
18515               B53:
18516 573C D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = A (the x-coordinate of the right
     573E 0033     
18517                                                                          ; edge of the crosshairs)
18518               
18519 5740 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set XX15+1 (Y1) = crosshairs y-coordinate + indent
     5742 0080     
18520                      .clc                            ; CLC               ; to get the y-coordinate of the centre of the
     **** ****     > CLC
0001 5744 0A16  18        sla  rzero,1
                   < elite.a99
18521                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; crosshairs
     **** ****     > ADC
0001 5746 1701  14        jnc  !
0002 5748 B347  18        ab   rone,ra
0003               !:
0004 574A B360  30        ab   @QQ19+5,ra
     574C 0084     
                   < elite.a99
18522 574E D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     5750 0032     
18523               
18524 5752 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1),
     5754 277A     
18525 5756 06A0  32        bl   @jsr                       ;
     5758 FE28     
18526                                                                          ; which will draw from the left edge of the crosshairs
18527                                                                          ; to the right edge, through the centre of the
18528                                                                          ; crosshairs
18529               
18530 575A D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate - crosshairs size
     575C 0080     
18531                      .sec                            ; SEC               ; to get the y-coordinate of the top edge of the
     **** ****     > SEC
0001 575E 0A18  18        sla  rmone,1
                   < elite.a99
18532                      .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs
     **** ****     > SBC
0001 5760 1801  14        joc  !
0002 5762 7347  18        sb   rone,ra
0003               !:
0004 5764 7360  30        sb   @QQ19+2,ra
     5766 0081     
                   < elite.a99
18533               
18534 5768 1802  14        joc  TT86                       ; BCS TT86          ; If the above subtraction didn't underflow, then A is
18535                                                                          ; correct, so skip the next instruction
18536               
18537 576A 020D  20        li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
     576C 0000     
18538                                                                          ; crosshairs don't spill out of the top of the screen
18539               
18540               TT86:
18541                      .clc                            ; CLC               ; Set XX15+1 (Y1) = A + indent to get the y-coordinate
     **** ****     > CLC
0001 576E 0A16  18        sla  rzero,1
                   < elite.a99
18542                      .adc @QQ19+5,ra                 ; ADC QQ19+5        ; of the top edge of the indented crosshairs
     **** ****     > ADC
0001 5770 1701  14        jnc  !
0002 5772 B347  18        ab   rone,ra
0003               !:
0004 5774 B360  30        ab   @QQ19+5,ra
     5776 0084     
                   < elite.a99
18543 5778 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     577A 0032     
18544               
18545 577C D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate + crosshairs size
     577E 0080     
18546                      .clc                            ; CLC               ; + indent to get the y-coordinate of the bottom edge
     **** ****     > CLC
0001 5780 0A16  18        sla  rzero,1
                   < elite.a99
18547                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; of the indented crosshairs
     **** ****     > ADC
0001 5782 1701  14        jnc  !
0002 5784 B347  18        ab   rone,ra
0003               !:
0004 5786 B360  30        ab   @QQ19+2,ra
     5788 0081     
                   < elite.a99
18548                      .adc @QQ19+5,ra                 ; ADC QQ19+5
     **** ****     > ADC
0001 578A 1701  14        jnc  !
0002 578C B347  18        ab   rone,ra
0003               !:
0004 578E B360  30        ab   @QQ19+5,ra
     5790 0084     
                   < elite.a99
18549               
18550 5792 028D  22        ci   ra,>98*256                 ; CMP #152          ; If A < 152 then skip the following, as the crosshairs
     5794 9800     
18551 5796 1705  14        jnc  TT87                       ; BCC TT87          ; won't spill out of the bottom of the screen
18552               
18553 5798 D3A0  30        movb @QQ11,rx                   ; LDX QQ11          ; A >= 152, so we need to check whether this will fit in
     579A 0096     
18554                                                                          ; this view, so fetch the view type
18555               
18556 579C 1102  14        jlt  TT87                       ; BMI TT87          ; If this is the Short-range Chart then the y-coordinate
18557                                                                          ; is fine, so skip to TT87
18558               
18559 579E 020D  20        li   ra,>97*256                 ; LDA #151          ; Otherwise this is the Long-range Chart, so we need to
     57A0 9700     
18560                                                                          ; clip the crosshairs at a maximum y-coordinate of 151
18561               
18562               TT87:
18563 57A2 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; Set XX15+3 (Y2) = A (the y-coordinate of the bottom
     57A4 0034     
18564                                                                          ; edge of the crosshairs)
18565               
18566 57A6 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set XX15 (X1) = the x-coordinate of the centre of the
     57A8 007F     
18567 57AA D80D  30        movb ra,@XX15                   ; STA XX15          ; crosshairs
     57AC 0031     
18568               
18569 57AE D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = the x-coordinate of the centre of
     57B0 0033     
18570                                                                          ; the crosshairs
18571               
18572 57B2 0460  28        b    @LL30                      ; JMP LL30          ; Draw a vertical line (X1, Y1) to (X2, Y2), which will
     57B4 23BE     
18573                                                                          ; draw from the top edge of the crosshairs to the bottom
18574                                                                          ; edge, through the centre of the crosshairs, returning
18575                                                                          ; from the subroutine using a tail call
18576               
18577               * ******************************************************************************
18578               *
18579               * Name: TT14
18580               * Type: Subroutine
18581               * Category: Drawing circles
18582               * Summary: Draw a circle with crosshairs on a chart
18583               *
18584               * ------------------------------------------------------------------------------
18585               *
18586               * Draw a circle with crosshairs at the current system's galactic coordinates.
18587               *
18588               * ******************************************************************************
18589               
18590               TT126:
18591 57B6 020D  20        li   ra,>68*256                 ; LDA #104          ; Set QQ19 = 104, for the x-coordinate of the centre of
     57B8 6800     
18592 57BA D80D  30        movb ra,@QQ19                   ; STA QQ19          ; the fixed circle on the Short-range Chart
     57BC 007F     
18593               
18594 57BE 020D  20        li   ra,>5a*256                 ; LDA #90           ; Set QQ19+1 = 90, for the y-coordinate of the centre of
     57C0 5A00     
18595 57C2 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; the fixed circle on the Short-range Chart
     57C4 0080     
18596               
18597 57C6 020D  20        li   ra,>10*256                 ; LDA #16           ; Set QQ19+2 = 16, the size of the crosshairs on the
     57C8 1000     
18598 57CA D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Short-range Chart
     57CC 0081     
18599               
18600 57CE 0200  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, at the
     57D0 56FE     
18601 57D2 06A0  32        bl   @jsr                       ;
     57D4 FE28     
18602                                                                          ; exact coordinates as this is the Short-range Chart
18603               
18604 57D6 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14, so this can act as
     57D8 030D     
18605 57DA D80D  30        movb ra,@K                      ; STA K             ; the circle's radius (70 being a full tank)
     57DC 003D     
18606               
18607 57DE 0460  28        b    @TT128                     ; JMP TT128         ; Jump to TT128 to draw a circle with the centre at the
     57E0 5828     
18608                                                                          ; same coordinates as the crosshairs, (QQ19, QQ19+1),
18609                                                                          ; and radius K that reflects the current fuel levels,
18610                                                                          ; returning from the subroutine using a tail call
18611               
18612               TT14:
18613 57E2 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is the Short-range Chart, which
     57E4 0096     
18614 57E6 11E7  14        jlt  TT126                      ; BMI TT126         ; is the only view with bit 7 set, then jump up to TT126
18615                                                                          ; to draw the crosshairs and circle for that view
18616               
18617                                                                          ; Otherwise this is the Long-range Chart, so we draw the
18618                                                                          ; crosshairs and circle for that view instead
18619               
18620 57E8 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14 divided by 4, so
     57EA 030D     
18621 57EC 091D  18        srl  ra,1                       ; LSR A             ; this can act as the circle's radius (70 being a full
18622 57EE 091D  18        srl  ra,1                       ; LSR A             ; tank, which divides down to a radius of 17)
18623 57F0 D80D  30        movb ra,@K                      ; STA K
     57F2 003D     
18624               
18625 57F4 D360  30        movb @QQ0,ra                    ; LDA QQ0           ; Set QQ19 to the x-coordinate of the current system,
     57F6 0301     
18626 57F8 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; which will be the centre of the circle and crosshairs
     57FA 007F     
18627                                                                          ; we draw
18628               
18629 57FC D360  30        movb @QQ1,ra                    ; LDA QQ1           ; Set QQ19+1 to the y-coordinate of the current system,
     57FE 0302     
18630 5800 091D  18        srl  ra,1                       ; LSR A             ; halved because the galactic chart is half as high as
18631 5802 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; it is wide, which will again be the centre of the
     5804 0080     
18632                                                                          ; circle and crosshairs we draw
18633               
18634 5806 020D  20        li   ra,>07*256                 ; LDA #7            ; Set QQ19+2 = 7, the size of the crosshairs on the
     5808 0700     
18635 580A D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Long-range Chart
     580C 0081     
18636               
18637 580E 0200  20        li   rtmp,TT15                  ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, which will
     5810 56FE     
18638 5812 06A0  32        bl   @jsr                       ;
     5814 FE28     
18639                                                                          ; be drawn 24 pixels to the right of QQ19+1
18640               
18641 5816 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Add 24 to the y-coordinate of the crosshairs in QQ19+1
     5818 0080     
18642                      .clc                            ; CLC               ; so that the centre of the circle matches the centre
     **** ****     > CLC
0001 581A 0A16  18        sla  rzero,1
                   < elite.a99
18643                      .adi (>18*256)                  ; ADC #24           ; of the crosshairs
     **** ****     > ADI
0001 581C 1701  14        jnc  !
0002 581E B347  18        ab   rone,ra
0003               !:
0004 5820 022D  22        ai   ra,(>18*256)
     5822 1800     
                   < elite.a99
18644 5824 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1
     5826 0080     
18645               
18646                                                                          ; Fall through into TT128 to draw a circle with the
18647                                                                          ; centre at the same coordinates as the crosshairs,
18648                                                                          ; (QQ19, QQ19+1), and radius K that reflects the
18649                                                                          ; current fuel levels
18650               
18651               * ******************************************************************************
18652               *
18653               * Name: TT128
18654               * Type: Subroutine
18655               * Category: Drawing circles
18656               * Summary: Draw a circle on a chart
18657               * Deep dive: Drawing circles
18658               *
18659               * ------------------------------------------------------------------------------
18660               *
18661               * Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
18662               *
18663               * ------------------------------------------------------------------------------
18664               *
18665               * Arguments:
18666               *
18667               * QQ19                The x-coordinate of the centre of the circle
18668               *
18669               * QQ19+1              The y-coordinate of the centre of the circle
18670               *
18671               * K                   The radius of the circle
18672               *
18673               * ******************************************************************************
18674               
18675               TT128:
18676 5828 D360  30        movb @QQ19,ra                   ; LDA QQ19          ; Set K3 = the x-coordinate of the centre
     582A 007F     
18677 582C D80D  30        movb ra,@K3                     ; STA K3
     582E 00D2     
18678               
18679 5830 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set K4 = the y-coordinate of the centre
     5832 0080     
18680 5834 D80D  30        movb ra,@K4                     ; STA K4
     5836 00E0     
18681               
18682 5838 020E  20        li   rx,>00*256                 ; LDX #0            ; Set the high bytes of K3(1 0) and K4(1 0) to 0
     583A 0000     
18683 583C D80E  30        movb rx,@K4+1                   ; STX K4+1
     583E 00E1     
18684 5840 D80E  30        movb rx,@K3+1                   ; STX K3+1
     5842 00D3     
18685               
18686               * STX LSX                \ This instruction is commented out in the original
18687                                                                          ; source
18688               
18689 5844 B387  18        ab   rone,rx                    ; INX               ; Set LSP = 1 to reset the ball line heap
18690 5846 D80E  30        movb rx,@LSP                    ; STX LSP
     5848 0077     
18691               
18692 584A 020E  20        li   rx,>02*256                 ; LDX #2            ; Set STP = 2, the step size for the circle
     584C 0200     
18693 584E D80E  30        movb rx,@STP                    ; STX STP
     5850 00A6     
18694               
18695 5852 0200  20        li   rtmp,CIRCLE2               ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
     5854 BEE8     
18696 5856 06A0  32        bl   @jsr                       ;
     5858 FE28     
18697                                                                          ; (K3(1 0), K4(1 0)) and radius K
18698               
18699               * LDA #&FF               \ These instructions are commented out in the original
18700               * STA LSX                \ source
18701               
18702 585A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     585C FE34     
18703               
18704               * ******************************************************************************
18705               *
18706               * Name: TT219
18707               * Type: Subroutine
18708               * Category: Market
18709               * Summary: Show the Buy Cargo screen (red key f1)
18710               *
18711               * ------------------------------------------------------------------------------
18712               *
18713               * Other entry points:
18714               *
18715               * BAY2                Jump into the main loop at FRCE, setting the key
18716               * "pressed" to red key f9 (so we show the Inventory
18717               * screen)
18718               *
18719               * ******************************************************************************
18720               
18721               TT219:
18722               * LDA #2                 \ This instruction is commented out in the original
18723                                                                          ; source. Perhaps this view originally had a QQ11 value
18724                                                                          ; of 2, but it turned out not to need its own unique ID,
18725                                                                          ; so the authors found they could just use a view value
18726                                                                          ; of 1 and save an instruction at the same time?
18727 585E 0200  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     5860 4EF8     
18728 5862 06A0  32        bl   @jsr                       ;
     5864 FE28     
18729                                                                          ; and set the current view type in QQ11 to 1
18730               
18731 5866 0200  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     5868 A3FA     
18732 586A 06A0  32        bl   @jsr                       ;
     586C FE28     
18733               
18734 586E 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     5870 8000     
18735 5872 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     5874 007E     
18736               
18737               * JSR FLKB               \ This instruction is commented out in the original
18738                                                                          ; source. It calls a routine to flush the keyboard
18739                                                                          ; buffer (FLKB) that isn't present in the cassette
18740                                                                          ; version but is in other versions
18741               
18742 5876 020D  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     5878 0000     
18743 587A D80D  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     587C 0F1B     
18744                                                                          ; current item and start it at 0
18745               
18746               TT220:
18747 587E 0200  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     5880 A2BE     
18748 5882 06A0  32        bl   @jsr                       ;
     5884 FE28     
18749                                                                          ; availability of the current item, and set QQ24 to the
18750                                                                          ; item's price / 4, QQ25 to the quantity available and
18751                                                                          ; QQ19+1 to byte #1 from the market prices table for
18752                                                                          ; this item
18753               
18754 5886 D360  30        movb @QQ25,ra                   ; LDA QQ25          ; If there are some of the current item available, jump
     5888 0F19     
18755 588A 1611  14        jne  TT224                      ; BNE TT224         ; to TT224 below to see if we want to buy any
18756               
18757 588C 0460  28        b    @TT222                     ; JMP TT222         ; Otherwise there are none available, so jump down to
     588E 5994     
18758                                                                          ; TT222 to skip this item
18759               
18760               TQ4:
18761 5890 020F  20        li   ry,>b0*256                 ; LDY #176          ; Set Y to the recursive token 16 ("QUANTITY")
     5892 B000     
18762               
18763               Tc:
18764 5894 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     5896 A3D0     
18765 5898 06A0  32        bl   @jsr                       ;
     589A FE28     
18766               
18767 589C D34F  18        movb ry,ra                      ; TYA               ; Print the recursive token in Y followed by a question
18768 589E 0200  20        li   rtmp,prq_                  ; JSR prq           ; mark
     58A0 A2AE     
18769 58A2 06A0  32        bl   @jsr                       ;
     58A4 FE28     
18770               
18771               TTX224:
18772 58A6 0200  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     58A8 AA70     
18773 58AA 06A0  32        bl   @jsr                       ;
     58AC FE28     
18774                                                                          ; second
18775               
18776               TT224:
18777 58AE 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     58B0 4FFE     
18778 58B2 06A0  32        bl   @jsr                       ;
     58B4 FE28     
18779                                                                          ; and move the text cursor to column 1 on row 21, i.e.
18780                                                                          ; the start of the top row of the three bottom rows
18781               
18782 58B6 020D  20        li   ra,>cc*256                 ; LDA #204          ; Print recursive token 44 ("QUANTITY OF ")
     58B8 CC00     
18783 58BA 0200  20        li   rtmp,TT27                  ; JSR TT27
     58BC ACA0     
18784 58BE 06A0  32        bl   @jsr                       ;
     58C0 FE28     
18785               
18786 58C2 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; Print recursive token 48 + QQ29, which will be in the
     58C4 0F1B     
18787                      .clc                            ; CLC               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     **** ****     > CLC
0001 58C6 0A16  18        sla  rzero,1
                   < elite.a99
18788                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 58C8 1701  14        jnc  !
0002 58CA B347  18        ab   rone,ra
0003               !:
0004 58CC 022D  22        ai   ra,(>D0*256)
     58CE D000     
                   < elite.a99
18789 58D0 0200  20        li   rtmp,TT27                  ; JSR TT27
     58D2 ACA0     
18790 58D4 06A0  32        bl   @jsr                       ;
     58D6 FE28     
18791               
18792 58D8 020D  20        li   ra,('/')*256               ; LDA #'/'          ; Print "/"
     58DA 2F00     
18793 58DC 0200  20        li   rtmp,TT27                  ; JSR TT27
     58DE ACA0     
18794 58E0 06A0  32        bl   @jsr                       ;
     58E2 FE28     
18795               
18796 58E4 0200  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the current item
     58E6 A3B8     
18797 58E8 06A0  32        bl   @jsr                       ;
     58EA FE28     
18798                                                                          ; (as the call to TT151 above set QQ19+1 with the
18799                                                                          ; appropriate value)
18800               
18801 58EC 020D  20        li   ra,('?')*256               ; LDA #'?'          ; Print "?"
     58EE 3F00     
18802 58F0 0200  20        li   rtmp,TT27                  ; JSR TT27
     58F2 ACA0     
18803 58F4 06A0  32        bl   @jsr                       ;
     58F6 FE28     
18804               
18805 58F8 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     58FA 52CE     
18806 58FC 06A0  32        bl   @jsr                       ;
     58FE FE28     
18807               
18808 5900 020E  20        li   rx,>00*256                 ; LDX #0            ; These instructions have no effect, as they are
     5902 0000     
18809 5904 D80E  30        movb rx,@R                      ; STX R             ; repeated at the start of gnum, which we call next.
     5906 0091     
18810 5908 020E  20        li   rx,>0c*256                 ; LDX #12           ; Perhaps they were left behind when code was moved from
     590A 0C00     
18811 590C D80E  30        movb rx,@T1                     ; STX T1            ; here into gnum, and weren't deleted?
     590E 0006     
18812               
18813               * .TT223                 \ This label is commented out in the original source,
18814                                                                          ; and is a duplicate of a label in gnum, so this could
18815                                                                          ; also be a remnant if the code in gnum was originally
18816                                                                          ; here, but got moved into the gnum subroutine
18817               
18818 5910 0200  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     5912 59C6     
18819 5914 06A0  32        bl   @jsr                       ;
     5916 FE28     
18820                                                                          ; will be the quantity of this item we want to purchase,
18821                                                                          ; returning the number entered in A and R
18822               
18823 5918 18BB  14        joc  TQ4                        ; BCS TQ4           ; If gnum set the C flag, the number entered is greater
18824                                                                          ; than the quantity available, so jump up to TQ4 to
18825                                                                          ; display a "Quantity?" error, beep, clear the number
18826                                                                          ; and try again
18827               
18828 591A D80D  30        movb ra,@P                      ; STA P             ; Otherwise we have a valid purchase quantity entered,
     591C 001B     
18829                                                                          ; so store the amount we want to purchase in P
18830               
18831 591E 0200  20        li   rtmp,tnpr_                 ; JSR tnpr          ; Call tnpr to work out whether there is room in the
     5920 51D4     
18832 5922 06A0  32        bl   @jsr                       ;
     5924 FE28     
18833                                                                          ; cargo hold for this item
18834               
18835 5926 020F  20        li   ry,>ce*256                 ; LDY #206          ; Set Y to recursive token 46 (" CARGO{sentence case}")
     5928 CE00     
18836                                                                          ; to pass to the Tc routine if we call it
18837               
18838 592A 18B4  14        joc  Tc                         ; BCS Tc            ; If the C flag is set, then there is no room in the
18839                                                                          ; cargo hold, jump up to Tc to print a "Cargo?" error,
18840                                                                          ; beep, clear the number and try again
18841               
18842 592C D360  30        movb @QQ24,ra                   ; LDA QQ24          ; There is room in the cargo hold, so now to check
     592E 0F18     
18843 5930 D80D  30        movb ra,@Q                      ; STA Q             ; whether we have enough cash, so fetch the item's
     5932 0090     
18844                                                                          ; price / 4, which was returned in QQ24 by the call
18845                                                                          ; to TT151 above and store it in Q
18846               
18847 5934 0200  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate:
     5936 A77A     
18848 5938 06A0  32        bl   @jsr                       ;
     593A FE28     
18849                                                                          ;
18850                                                                          ; (Y X) = P * Q * 4
18851                                                                          ;
18852                                                                          ; which will be the total price of this transaction
18853                                                                          ; (as P contains the purchase quantity and Q contains
18854                                                                          ; the item's price / 4)
18855               
18856 593C 0200  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot in CASH
     593E A6EA     
18857 5940 06A0  32        bl   @jsr                       ;
     5942 FE28     
18858               
18859 5944 020F  20        li   ry,>c5*256                 ; LDY #197          ; If the C flag is clear, we didn't have enough cash,
     5946 C500     
18860 5948 17A5  14        jnc  Tc                         ; BCC Tc            ; so set Y to the recursive token 37 ("CASH") and jump
18861                                                                          ; up to Tc to print a "Cash?" error, beep, clear the
18862                                                                          ; number and try again
18863               
18864 594A D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the current market item number from QQ29 into Y
     594C 0F1B     
18865               
18866 594E D360  30        movb @R,ra                      ; LDA R             ; Set A to the number of items we just purchased (this
     5950 0091     
18867                                                                          ; was set by gnum above)
18868               
18869                      .pha                            ; PHA               ; Store the quantity just purchased on the stack
     **** ****     > PHA
0001 5952 D68D  30        movb ra,*rsp
0002 5954 060A  14        dec  rsp
                   < elite.a99
18870               
18871                      .clc                            ; CLC               ; Add the number purchased to the Y-th byte of QQ20,
     **** ****     > CLC
0001 5956 0A16  18        sla  rzero,1
                   < elite.a99
18872 5958 06CF  14        swpb ry                         ;
18873                      .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; which contains the number of items of this type in
     **** ****     > ADC
0001 595A 1701  14        jnc  !
0002 595C B347  18        ab   rone,ra
0003               !:
0004 595E B36F  34        ab   @QQ20(RY),ra
     5960 0317     
                   < elite.a99
18874 5962 06CF  14        swpb ry                         ;
18875 5964 06CF  14        swpb ry                         ;
18876 5966 DBCD  38        movb ra,@QQ20(ry)               ; STA QQ20,Y        ; our hold (so this transfers the bought items into our
     5968 0317     
18877 596A 06CF  14        swpb ry                         ;
18878                                                                          ; cargo hold)
18879               
18880 596C 06CF  14        swpb ry                         ;
18881 596E D36F  34        movb @AVL(ry),ra                ; LDA AVL,Y         ; Subtract the number of items from the Y-th byte of
     5970 0335     
18882 5972 06CF  14        swpb ry                         ;
18883                      .sec                            ; SEC               ; AVL, which contains the number of items of this type
     **** ****     > SEC
0001 5974 0A18  18        sla  rmone,1
                   < elite.a99
18884                      .sbc @R,ra                      ; SBC R             ; that are available on the market
     **** ****     > SBC
0001 5976 1801  14        joc  !
0002 5978 7347  18        sb   rone,ra
0003               !:
0004 597A 7360  30        sb   @R,ra
     597C 0091     
                   < elite.a99
18885 597E 06CF  14        swpb ry                         ;
18886 5980 DBCD  38        movb ra,@AVL(ry)                ; STA AVL,Y
     5982 0335     
18887 5984 06CF  14        swpb ry                         ;
18888               
18889                      .pla                            ; PLA               ; Restore the quantity just purchased
     **** ****     > PLA
0001 5986 058A  14        inc  rsp
0002 5988 D35A  26        movb *rsp,ra
                   < elite.a99
18890               
18891 598A 1304  14        jeq  TT222                      ; BEQ TT222         ; If we didn't buy anything, jump to TT222 to skip the
18892                                                                          ; following instruction
18893               
18894 598C 0200  20        li   rtmp,dn_                   ; JSR dn            ; Call dn to print the amount of cash left in the cash
     598E AA5C     
18895 5990 06A0  32        bl   @jsr                       ;
     5992 FE28     
18896                                                                          ; pot, then make a short, high beep to confirm the
18897                                                                          ; purchase, and delay for 1 second
18898               
18899               TT222:
18900 5994 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; Move the text cursor to row QQ29 + 5 (where QQ29 is
     5996 0F1B     
18901                      .clc                            ; CLC               ; the item number, starting from 0)
     **** ****     > CLC
0001 5998 0A16  18        sla  rzero,1
                   < elite.a99
18902                      .adi (>05*256)                  ; ADC #5
     **** ****     > ADI
0001 599A 1701  14        jnc  !
0002 599C B347  18        ab   rone,ra
0003               !:
0004 599E 022D  22        ai   ra,(>05*256)
     59A0 0500     
                   < elite.a99
18903 59A2 D80D  30        movb ra,@YC                     ; STA YC
     59A4 002D     
18904               
18905 59A6 020D  20        li   ra,>00*256                 ; LDA #0            ; Move the text cursor to column 0
     59A8 0000     
18906 59AA D80D  30        movb ra,@XC                     ; STA XC
     59AC 002C     
18907               
18908 59AE B347  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
18909               
18910 59B0 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to BAY2 as we have done the
     59B2 0F1B     
18911 59B4 028D  22        ci   ra,>11*256                 ; CMP #17           ; last item
     59B6 1100     
18912 59B8 1802  14        joc  BAY2                       ; BCS BAY2
18913               
18914 59BA 0460  28        b    @TT220                     ; JMP TT220         ; Otherwise loop back to TT220 to print the next market
     59BC 587E     
18915                                                                          ; item
18916               
18917               BAY2:
18918 59BE 020D  20        li   ra,(f9_)*256               ; LDA #f9           ; Jump into the main loop at FRCE, setting the key
     59C0 7700     
18919 59C2 0460  28        b    @FRCE                      ; JMP FRCE          ; "pressed" to red key f9 (so we show the Inventory
     59C4 CA0C     
18920                                                                          ; screen)
18921               
18922               * ******************************************************************************
18923               *
18924               * Name: gnum
18925               * Type: Subroutine
18926               * Category: Market
18927               * Summary: Get a number from the keyboard
18928               *
18929               * ------------------------------------------------------------------------------
18930               *
18931               * Get a number from the keyboard, up to the maximum number in QQ25, for the
18932               * buying and selling of cargo and equipment.
18933               *
18934               * Pressing a key with an ASCII code less than ASCII "0" will return a 0 in A (so
18935               * that includes pressing Space or Return), while pressing a key with an ASCII
18936               * code greater than ASCII "9" will jump to the Inventory screen (so that
18937               * includes all letters and most punctuation).
18938               *
18939               * ------------------------------------------------------------------------------
18940               *
18941               * Arguments:
18942               *
18943               * QQ25                The maximum number allowed
18944               *
18945               * ------------------------------------------------------------------------------
18946               *
18947               * Returns:
18948               *
18949               * A                   The number entered
18950               *
18951               * R                   Also contains the number entered
18952               *
18953               * C flag              Set if the number is too large (> QQ25), clear otherwise
18954               *
18955               * ******************************************************************************
18956               
18957               gnum_:
18958 59C6 020E  20        li   rx,>00*256                 ; LDX #0            ; We will build the number entered in R, so initialise
     59C8 0000     
18959 59CA D80E  30        movb rx,@R                      ; STX R             ; it with 0
     59CC 0091     
18960               
18961 59CE 020E  20        li   rx,>0c*256                 ; LDX #12           ; We will check for up to 12 key presses, so set a
     59D0 0C00     
18962 59D2 D80E  30        movb rx,@T1                     ; STX T1            ; counter in T1
     59D4 0006     
18963               
18964               TT223:
18965 59D6 0200  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     59D8 D5B4     
18966 59DA 06A0  32        bl   @jsr                       ;
     59DC FE28     
18967                                                                          ; the key's ASCII code in A (and X)
18968               
18969 59DE D80D  30        movb ra,@Q                      ; STA Q             ; Store the key pressed in Q
     59E0 0090     
18970               
18971                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 59E2 0A18  18        sla  rmone,1
                   < elite.a99
18972                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 59E4 1801  14        joc  !
0002 59E6 7347  18        sb   rone,ra
0003               !:
0004 59E8 022D  22        ai   ra,-(('0')*256)
     59EA D000     
                   < elite.a99
18973               
18974 59EC 172B  14        jnc  OUT                        ; BCC OUT           ; If A < 0, jump to OUT to load the current number and
18975                                                                          ; return from the subroutine, as the key pressed was
18976                                                                          ; RETURN (or some other ncharacter with a value less
18977                                                                          ; than ASCII "0")
18978               
18979 59EE 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to BAY2 to display the Inventory
     59F0 0A00     
18980 59F2 18E5  14        joc  BAY2                       ; BCS BAY2          ; screen, as the key pressed was a letter or other
18981                                                                          ; non-digit and is greater than ASCII "9"
18982               
18983 59F4 D80D  30        movb ra,@S                      ; STA S             ; Store the numeric value of the key pressed in S
     59F6 0092     
18984               
18985 59F8 D360  30        movb @R,ra                      ; LDA R             ; Fetch the result so far into A
     59FA 0091     
18986               
18987 59FC 028D  22        ci   ra,>1a*256                 ; CMP #26           ; If A >= 26, where A is the number entered so far, then
     59FE 1A00     
18988 5A00 1821  14        joc  OUT                        ; BCS OUT           ; adding a further digit will make it bigger than 256,
18989                                                                          ; so jump to OUT to return from the subroutine with the
18990                                                                          ; result in R (i.e. ignore the last key press)
18991               
18992                      .asla                           ; ASL A             ; Set A = (A * 2) + (A * 8) = A * 10
     **** ****     > ASLA
0001 5A02 024D  22        andi ra,>ff00
     5A04 FF00     
0002 5A06 0A1D  18        sla  ra,1
                   < elite.a99
18993 5A08 D80D  30        movb ra,@T                      ; STA T
     5A0A 00D1     
18994                      .asla                           ; ASL A
     **** ****     > ASLA
0001 5A0C 024D  22        andi ra,>ff00
     5A0E FF00     
0002 5A10 0A1D  18        sla  ra,1
                   < elite.a99
18995                      .asla                           ; ASL A
     **** ****     > ASLA
0001 5A12 024D  22        andi ra,>ff00
     5A14 FF00     
0002 5A16 0A1D  18        sla  ra,1
                   < elite.a99
18996                      .adc @T,ra                      ; ADC T
     **** ****     > ADC
0001 5A18 1701  14        jnc  !
0002 5A1A B347  18        ab   rone,ra
0003               !:
0004 5A1C B360  30        ab   @T,ra
     5A1E 00D1     
                   < elite.a99
18997               
18998                      .adc @S,ra                      ; ADC S             ; Add the pressed digit to A and store in R, so R now
     **** ****     > ADC
0001 5A20 1701  14        jnc  !
0002 5A22 B347  18        ab   rone,ra
0003               !:
0004 5A24 B360  30        ab   @S,ra
     5A26 0092     
                   < elite.a99
18999 5A28 D80D  30        movb ra,@R                      ; STA R             ; contains its previous value with the new key press
     5A2A 0091     
19000                                                                          ; tacked onto the end
19001               
19002 5A2C 9360  30        cb   @QQ25,ra                   ; CMP QQ25          ; If the result in R = the maximum allowed in QQ25, jump
     5A2E 0F19     
19003 5A30 1301  14        jeq  TT226                      ; BEQ TT226         ; to TT226 to print the key press and keep looping (the
19004                                                                          ; BEQ is needed because the BCS below would jump to OUT
19005                                                                          ; if R >= QQ25, which we don't want)
19006               
19007 5A32 1808  14        joc  OUT                        ; BCS OUT           ; If the result in R > QQ25, jump to OUT to return from
19008                                                                          ; the subroutine with the result in R
19009               
19010               TT226:
19011 5A34 D360  30        movb @Q,ra                      ; LDA Q             ; Print the character in Q (i.e. the key that was
     5A36 0090     
19012 5A38 0200  20        li   rtmp,TT26                  ; JSR TT26          ; pressed, as we stored the ASCII value in Q earlier)
     5A3A 341A     
19013 5A3C 06A0  32        bl   @jsr                       ;
     5A3E FE28     
19014               
19015 5A40 7347  18        sb   rone,ra                    ; DEC T1            ; Decrement the loop counter
19016               
19017 5A42 16C9  14        jne  TT223                      ; BNE TT223         ; Loop back to TT223 until we have checked for 12 digits
19018               
19019               OUT:
19020 5A44 D360  30        movb @R,ra                      ; LDA R             ; Set A to the result we have been building in R
     5A46 0091     
19021               
19022 5A48 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5A4A FE34     
19023               
19024               * ******************************************************************************
19025               *
19026               * Name: TT208
19027               * Type: Subroutine
19028               * Category: Market
19029               * Summary: Show the Sell Cargo screen (red key f2)
19030               *
19031               * ******************************************************************************
19032               
19033               TT208:
19034 5A4C 020D  20        li   ra,>04*256                 ; LDA #4            ; Clear the top part of the screen, draw a white border,
     5A4E 0400     
19035 5A50 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 4 (Sell
     5A52 4EFA     
19036 5A54 06A0  32        bl   @jsr                       ;
     5A56 FE28     
19037                                                                          ; Cargo screen)
19038               
19039 5A58 020D  20        li   ra,>04*256                 ; LDA #4            ; Move the text cursor to row 4, column 4
     5A5A 0400     
19040 5A5C D80D  30        movb ra,@YC                     ; STA YC
     5A5E 002D     
19041 5A60 D80D  30        movb ra,@XC                     ; STA XC
     5A62 002C     
19042               
19043               * JSR FLKB               \ This instruction is commented out in the original
19044                                                                          ; source. It calls a routine to flush the keyboard
19045                                                                          ; buffer (FLKB) that isn't present in the cassette
19046                                                                          ; version but is in other versions
19047               
19048 5A64 020D  20        li   ra,>cd*256                 ; LDA #205          ; Print recursive token 45 ("SELL")
     5A66 CD00     
19049 5A68 0200  20        li   rtmp,TT27                  ; JSR TT27
     5A6A ACA0     
19050 5A6C 06A0  32        bl   @jsr                       ;
     5A6E FE28     
19051               
19052 5A70 020D  20        li   ra,>ce*256                 ; LDA #206          ; Print recursive token 46 (" CARGO{sentence case}")
     5A72 CE00     
19053 5A74 0200  20        li   rtmp,TT68                  ; JSR TT68          ; followed by a colon
     5A76 AC94     
19054 5A78 06A0  32        bl   @jsr                       ;
     5A7A FE28     
19055               
19056                                                                          ; Fall through into TT210 to show the Inventory screen
19057                                                                          ; with the option to sell
19058               
19059               * ******************************************************************************
19060               *
19061               * Name: TT210
19062               * Type: Subroutine
19063               * Category: Market
19064               * Summary: Show a list of current cargo in our hold, optionally to sell
19065               *
19066               * ------------------------------------------------------------------------------
19067               *
19068               * Show a list of current cargo in our hold, either with the ability to sell (the
19069               * Sell Cargo screen) or without (the Inventory screen), depending on the current
19070               * view.
19071               *
19072               * ------------------------------------------------------------------------------
19073               *
19074               * Arguments:
19075               *
19076               * QQ11                The current view:
19077               *
19078               * * 4 = Sell Cargo
19079               *
19080               * * 8 = Inventory
19081               *
19082               * ******************************************************************************
19083               
19084               TT210:
19085 5A7C 020F  20        li   ry,>00*256                 ; LDY #0            ; We're going to loop through all the available market
     5A7E 0000     
19086                                                                          ; items and check whether we have any in the hold (and,
19087                                                                          ; if we are in the Sell Cargo screen, whether we want
19088                                                                          ; to sell any items), so we set up a counter in Y to
19089                                                                          ; denote the current item and start it at 0
19090               
19091               TT211:
19092 5A80 D80F  30        movb ry,@QQ29                   ; STY QQ29          ; Store the current item number in QQ29
     5A82 0F1B     
19093               
19094 5A84 06CF  14        swpb ry                         ;
19095 5A86 D3AF  34        movb @QQ20(ry),rx               ; LDX QQ20,Y        ; Fetch into X the amount of the current item that we
     5A88 0317     
19096 5A8A 06CF  14        swpb ry                         ;
19097 5A8C 1364  14        jeq  TT212                      ; BEQ TT212         ; have in our cargo hold, which is stored in QQ20+Y,
19098                                                                          ; and if there are no items of this type in the hold,
19099                                                                          ; jump down to TT212 to skip to the next item
19100               
19101 5A8E D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y * 4, so this will act as an index into the
19102                      .asla                           ; ASL A             ; market prices table at QQ23 for this item (as there
     **** ****     > ASLA
0001 5A90 024D  22        andi ra,>ff00
     5A92 FF00     
0002 5A94 0A1D  18        sla  ra,1
                   < elite.a99
19103                      .asla                           ; ASL A             ; are four bytes per item in the table)
     **** ****     > ASLA
0001 5A96 024D  22        andi ra,>ff00
     5A98 FF00     
0002 5A9A 0A1D  18        sla  ra,1
                   < elite.a99
19104 5A9C D3CD  18        movb ra,ry                      ; TAY
19105               
19106 5A9E 06CF  14        swpb ry                         ;
19107 5AA0 D36F  34        movb @QQ23+1(ry),ra             ; LDA QQ23+1,Y      ; Fetch byte #1 from the market prices table for the
     5AA2 D6EF     
19108 5AA4 06CF  14        swpb ry                         ;
19109 5AA6 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; current item and store it in QQ19+1, for use by the
     5AA8 0080     
19110                                                                          ; call to TT152 below
19111               
19112 5AAA D34E  18        movb rx,ra                      ; TXA               ; Store the amount of item in the hold (in X) on the
19113                      .pha                            ; PHA               ; stack
     **** ****     > PHA
0001 5AAC D68D  30        movb ra,*rsp
0002 5AAE 060A  14        dec  rsp
                   < elite.a99
19114               
19115 5AB0 0200  20        li   rtmp,TT69                  ; JSR TT69          ; Call TT69 to set Sentence Case and print a newline
     5AB2 52C6     
19116 5AB4 06A0  32        bl   @jsr                       ;
     5AB6 FE28     
19117               
19118                      .clc                            ; CLC               ; Print recursive token 48 + QQ29, which will be in the
     **** ****     > CLC
0001 5AB8 0A16  18        sla  rzero,1
                   < elite.a99
19119 5ABA D360  30        movb @QQ29,ra                   ; LDA QQ29          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     5ABC 0F1B     
19120                      .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
     **** ****     > ADI
0001 5ABE 1701  14        jnc  !
0002 5AC0 B347  18        ab   rone,ra
0003               !:
0004 5AC2 022D  22        ai   ra,(>D0*256)
     5AC4 D000     
                   < elite.a99
19121 5AC6 0200  20        li   rtmp,TT27                  ; JSR TT27
     5AC8 ACA0     
19122 5ACA 06A0  32        bl   @jsr                       ;
     5ACC FE28     
19123               
19124 5ACE 020D  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the item's
     5AD0 0E00     
19125 5AD2 D80D  30        movb ra,@XC                     ; STA XC            ; quantity
     5AD4 002C     
19126               
19127                      .pla                            ; PLA               ; Restore the amount of item in the hold into X
     **** ****     > PLA
0001 5AD6 058A  14        inc  rsp
0002 5AD8 D35A  26        movb *rsp,ra
                   < elite.a99
19128 5ADA D38D  18        movb ra,rx                      ; TAX
19129               
19130                      .clc                            ; CLC               ; Print the 8-bit number in X to 3 digits, without a
     **** ****     > CLC
0001 5ADC 0A16  18        sla  rzero,1
                   < elite.a99
19131 5ADE 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; decimal point
     5AE0 322C     
19132 5AE2 06A0  32        bl   @jsr                       ;
     5AE4 FE28     
19133               
19134 5AE6 0200  20        li   rtmp,TT152                 ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the market item
     5AE8 A3B8     
19135 5AEA 06A0  32        bl   @jsr                       ;
     5AEC FE28     
19136                                                                          ; whose byte #1 from the market prices table is in
19137                                                                          ; QQ19+1 (which we set up above)
19138               
19139 5AEE D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     5AF0 0096     
19140 5AF2 028D  22        ci   ra,>04*256                 ; CMP #4            ; screen), jump to TT212 to skip the option to sell
     5AF4 0400     
19141 5AF6 162F  14        jne  TT212                      ; BNE TT212         ; items
19142               
19143 5AF8 020D  20        li   ra,>cd*256                 ; LDA #205          ; Set A to recursive token 45 ("SELL")
     5AFA CD00     
19144               
19145 5AFC 0200  20        li   rtmp,TT214                 ; JSR TT214         ; Call TT214 to print "Sell(Y/N)?" and return the
     5AFE 5BCA     
19146 5B00 06A0  32        bl   @jsr                       ;
     5B02 FE28     
19147                                                                          ; response in the C flag
19148               
19149 5B04 1728  14        jnc  TT212                      ; BCC TT212         ; If the response was "no", jump to TT212 to move on to
19150                                                                          ; the next item
19151               
19152 5B06 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; We are selling this item, so fetch the item number
     5B08 0F1B     
19153                                                                          ; from QQ29
19154               
19155 5B0A 020E  20        li   rx,>ff*256                 ; LDX #255          ; Set QQ17 = 255 to disable printing
     5B0C FF00     
19156 5B0E D80E  30        movb rx,@QQ17                   ; STX QQ17
     5B10 007E     
19157               
19158 5B12 0200  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to set QQ24 to the item's price / 4 (the
     5B14 A2BE     
19159 5B16 06A0  32        bl   @jsr                       ;
     5B18 FE28     
19160                                                                          ; routine doesn't print the item details, as we just
19161                                                                          ; disabled printing)
19162               
19163 5B1A D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Set P to the amount of this item we have in our cargo
     5B1C 0F1B     
19164 5B1E 06CF  14        swpb ry                         ;
19165 5B20 D36F  34        movb @QQ20(ry),ra               ; LDA QQ20,Y        ; hold (which is the amount to sell)
     5B22 0317     
19166 5B24 06CF  14        swpb ry                         ;
19167 5B26 D80D  30        movb ra,@P                      ; STA P
     5B28 001B     
19168               
19169 5B2A D360  30        movb @QQ24,ra                   ; LDA QQ24          ; Set Q to the item's price / 4
     5B2C 0F18     
19170 5B2E D80D  30        movb ra,@Q                      ; STA Q
     5B30 0090     
19171               
19172 5B32 0200  20        li   rtmp,GCASH                 ; JSR GCASH         ; Call GCASH to calculate
     5B34 A77A     
19173 5B36 06A0  32        bl   @jsr                       ;
     5B38 FE28     
19174                                                                          ;
19175                                                                          ; (Y X) = P * Q * 4
19176                                                                          ;
19177                                                                          ; which will be the total price we make from this sale
19178                                                                          ; (as P contains the quantity we're selling and Q
19179                                                                          ; contains the item's price / 4)
19180               
19181 5B3A 0200  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH
     5B3C A736     
19182 5B3E 06A0  32        bl   @jsr                       ;
     5B40 FE28     
19183               
19184 5B42 020D  20        li   ra,>00*256                 ; LDA #0            ; We've made the sale, so set the amount
     5B44 0000     
19185 5B46 D3E0  30        movb @QQ29,ry                   ; LDY QQ29
     5B48 0F1B     
19186 5B4A 06CF  14        swpb ry                         ;
19187 5B4C DBCD  38        movb ra,@QQ20(ry)               ; STA QQ20,Y
     5B4E 0317     
19188 5B50 06CF  14        swpb ry                         ;
19189               
19190 5B52 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0, which enables printing again
     5B54 007E     
19191               
19192               TT212:
19193 5B56 D3E0  30        movb @QQ29,ry                   ; LDY QQ29          ; Fetch the item number from QQ29 into Y, and increment
     5B58 0F1B     
19194 5B5A B3C7  18        ab   rone,ry                    ; INY               ; Y to point to the next item
19195               
19196 5B5C 028F  22        ci   ry,>11*256                 ; CPY #17           ; If Y >= 17 then skip the next instruction as we have
     5B5E 1100     
19197 5B60 1802  14        joc  B54                        ; BCS B54           ; done the last item
19198               
19199 5B62 0460  28        b    @TT211                     ; JMP TT211         ; Otherwise loop back to TT211 to print the next item
     5B64 5A80     
19200                                                                          ; in the hold
19201               
19202               B54:
19203 5B66 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
     5B68 0096     
19204 5B6A 028D  22        ci   ra,>04*256                 ; CMP #4            ; screen), skip the next two instructions and just
     5B6C 0400     
19205 5B6E 1606  14        jne  B55                        ; BNE B55           ; return from the subroutine
19206               
19207 5B70 0200  20        li   rtmp,dn2_                  ; JSR dn2           ; This is the Sell Cargo screen, so call dn2 to make a
     5B72 AA70     
19208 5B74 06A0  32        bl   @jsr                       ;
     5B76 FE28     
19209                                                                          ; short, high beep and delay for 1 second
19210               
19211 5B78 0460  28        b    @BAY2                      ; JMP BAY2          ; And then jump to BAY2 to display the Inventory
     5B7A 59BE     
19212                                                                          ; screen, as we have finished selling cargo
19213               
19214               B55:
19215 5B7C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5B7E FE34     
19216               
19217               * ******************************************************************************
19218               *
19219               * Name: TT213
19220               * Type: Subroutine
19221               * Category: Market
19222               * Summary: Show the Inventory screen (red key f9)
19223               *
19224               * ******************************************************************************
19225               
19226               TT213:
19227 5B80 020D  20        li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
     5B82 0800     
19228 5B84 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 8 (Inventory
     5B86 4EFA     
19229 5B88 06A0  32        bl   @jsr                       ;
     5B8A FE28     
19230                                                                          ; screen)
19231               
19232 5B8C 020D  20        li   ra,>0b*256                 ; LDA #11           ; Move the text cursor to column 11 to print the screen
     5B8E 0B00     
19233 5B90 D80D  30        movb ra,@XC                     ; STA XC            ; title
     5B92 002C     
19234               
19235 5B94 020D  20        li   ra,>a4*256                 ; LDA #164          ; Print recursive token 4 ("INVENTORY{crlf}") followed
     5B96 A400     
19236 5B98 0200  20        li   rtmp,TT60                  ; JSR TT60          ; by a paragraph break and Sentence Case
     5B9A 52BC     
19237 5B9C 06A0  32        bl   @jsr                       ;
     5B9E FE28     
19238               
19239 5BA0 0200  20        li   rtmp,NLIN4                 ; JSR NLIN4         ; Draw a horizontal line at pixel row 19 to box in the
     5BA2 2740     
19240 5BA4 06A0  32        bl   @jsr                       ;
     5BA6 FE28     
19241                                                                          ; title. The authors could have used a call to NLIN3
19242                                                                          ; instead and saved the above call to TT60, but you
19243                                                                          ; just can't optimise everything
19244               
19245 5BA8 0200  20        li   rtmp,fwl_                  ; JSR fwl           ; Call fwl to print the fuel and cash levels on two
     5BAA AC2E     
19246 5BAC 06A0  32        bl   @jsr                       ;
     5BAE FE28     
19247                                                                          ; separate lines
19248               
19249 5BB0 D360  30        movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
     5BB2 0316     
19250 5BB4 028D  22        ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
     5BB6 1A00     
19251 5BB8 1706  14        jnc  B56                        ; BCC B56           ; instructions
19252               
19253 5BBA 020D  20        li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
     5BBC 6B00     
19254 5BBE 0200  20        li   rtmp,TT27                  ; JSR TT27          ; token 107 ("LARGE CARGO{sentence case} BAY")
     5BC0 ACA0     
19255 5BC2 06A0  32        bl   @jsr                       ;
     5BC4 FE28     
19256               
19257               B56:
19258 5BC6 0460  28        b    @TT210                     ; JMP TT210         ; Jump to TT210 to print the contents of our cargo bay
     5BC8 5A7C     
19259                                                                          ; and return from the subroutine using a tail call
19260               
19261               * ******************************************************************************
19262               *
19263               * Name: TT214
19264               * Type: Subroutine
19265               * Category: Keyboard
19266               * Summary: Ask a question with a "Y/N?" prompt and return the response
19267               *
19268               * ------------------------------------------------------------------------------
19269               *
19270               * Arguments:
19271               *
19272               * A                   The text token to print before the "Y/N?" prompt
19273               *
19274               * ------------------------------------------------------------------------------
19275               *
19276               * Returns:
19277               *
19278               * C flag              Set if the response was "yes", clear otherwise
19279               *
19280               * ******************************************************************************
19281               
19282               TT214:
19283                      .pha                            ; PHA               ; Print a space, using the stack to preserve the value
     **** ****     > PHA
0001 5BCA D68D  30        movb ra,*rsp
0002 5BCC 060A  14        dec  rsp
                   < elite.a99
19284 5BCE 0200  20        li   rtmp,TT162                 ; JSR TT162         ; of A
     5BD0 A3D0     
19285 5BD2 06A0  32        bl   @jsr                       ;
     5BD4 FE28     
19286                      .pla                            ; PLA
     **** ****     > PLA
0001 5BD6 058A  14        inc  rsp
0002 5BD8 D35A  26        movb *rsp,ra
                   < elite.a99
19287               
19288               TT221:
19289 5BDA 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     5BDC ACA0     
19290 5BDE 06A0  32        bl   @jsr                       ;
     5BE0 FE28     
19291               
19292 5BE2 020D  20        li   ra,>e1*256                 ; LDA #225          ; Print recursive token 65 ("(Y/N)?")
     5BE4 E100     
19293 5BE6 0200  20        li   rtmp,TT27                  ; JSR TT27
     5BE8 ACA0     
19294 5BEA 06A0  32        bl   @jsr                       ;
     5BEC FE28     
19295               
19296 5BEE 0200  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     5BF0 D5B4     
19297 5BF2 06A0  32        bl   @jsr                       ;
     5BF4 FE28     
19298                                                                          ; the key's ASCII code in A and X
19299               
19300 5BF6 026D  22        ori  ra,>20*256                 ; ORA #%00100000    ; Set bit 5 in the value of the key pressed, which
     5BF8 2000     
19301                                                                          ; converts it to lower case
19302               
19303 5BFA 028D  22        ci   ra,('y')*256               ; CMP #'y'          ; If "y" was pressed, jump to TT218
     5BFC 7900     
19304 5BFE 1304  14        jeq  TT218                      ; BEQ TT218
19305               
19306 5C00 020D  20        li   ra,('n')*256               ; LDA #'n'          ; Otherwise jump to TT26 to print "n" and return from
     5C02 6E00     
19307 5C04 0460  28        b    @TT26                      ; JMP TT26          ; the subroutine using a tail call (so all other
     5C06 341A     
19308                                                                          ; responses apart from "y" indicate a no)
19309               
19310               TT218:
19311 5C08 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character in A, i.e. print "y"
     5C0A 341A     
19312 5C0C 06A0  32        bl   @jsr                       ;
     5C0E FE28     
19313               
19314                      .sec                            ; SEC               ; Set the C flag to indicate a "yes" response
     **** ****     > SEC
0001 5C10 0A18  18        sla  rmone,1
                   < elite.a99
19315               
19316 5C12 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5C14 FE34     
19317               
19318               * ******************************************************************************
19319               *
19320               * Name: TT16
19321               * Type: Subroutine
19322               * Category: Charts
19323               * Summary: Move the crosshairs on a chart
19324               *
19325               * ------------------------------------------------------------------------------
19326               *
19327               * Move the chart crosshairs by the amount in X and Y.
19328               *
19329               * ------------------------------------------------------------------------------
19330               *
19331               * Arguments:
19332               *
19333               * X                   The amount to move the crosshairs in the x-axis
19334               *
19335               * Y                   The amount to move the crosshairs in the y-axis
19336               *
19337               * ******************************************************************************
19338               
19339               TT16:
19340 5C16 D34E  18        movb rx,ra                      ; TXA               ; Push the change in X onto the stack (let's call this
19341                      .pha                            ; PHA               ; the x-delta)
     **** ****     > PHA
0001 5C18 D68D  30        movb ra,*rsp
0002 5C1A 060A  14        dec  rsp
                   < elite.a99
19342               
19343 5C1C 73C7  18        sb   rone,ry                    ; DEY               ; Negate the change in Y and push it onto the stack
19344 5C1E D34F  18        movb ry,ra                      ; TYA               ; (let's call this the y-delta)
19345                      .eoi (>ff*256)                  ; EOR #&FF
     **** ****     > EOI
0001 5C20 0200  20        li   rtmp,(>FF*256)
     5C22 FF00     
0002 5C24 2B40  18        xor  rtmp,ra
                   < elite.a99
19346                      .pha                            ; PHA
     **** ****     > PHA
0001 5C26 D68D  30        movb ra,*rsp
0002 5C28 060A  14        dec  rsp
                   < elite.a99
19347               
19348 5C2A 0200  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     5C2C 51C2     
19349 5C2E 06A0  32        bl   @jsr                       ;
     5C30 FE28     
19350                                                                          ; screen gets drawn and we can move the crosshairs with
19351                                                                          ; no screen flicker
19352               
19353 5C32 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     5C34 5C7A     
19354 5C36 06A0  32        bl   @jsr                       ;
     5C38 FE28     
19355                                                                          ; which will erase the crosshairs currently there
19356               
19357                      .pla                            ; PLA               ; Store the y-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 5C3A 058A  14        inc  rsp
0002 5C3C D35A  26        movb *rsp,ra
                   < elite.a99
19358 5C3E D80D  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; y-coordinate of the crosshairs from QQ10 into A, ready
     5C40 0082     
19359 5C42 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; for the call to TT123
     5C44 0F32     
19360               
19361 5C46 0200  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5C48 5CA0     
19362 5C4A 06A0  32        bl   @jsr                       ;
     5C4C FE28     
19363                                                                          ; y-coordinate by the y-delta, putting the new value in
19364                                                                          ; QQ19+4
19365               
19366 5C4E D360  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated y-coordinate in QQ10 (the current
     5C50 0083     
19367 5C52 D80D  30        movb ra,@QQ10                   ; STA QQ10          ; y-coordinate of the crosshairs)
     5C54 0F32     
19368               
19369 5C56 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; This instruction has no effect, as QQ19+1 is
     5C58 0080     
19370                                                                          ; overwritten below, both in TT103 and TT105
19371               
19372                      .pla                            ; PLA               ; Store the x-delta in QQ19+3 and fetch the current
     **** ****     > PLA
0001 5C5A 058A  14        inc  rsp
0002 5C5C D35A  26        movb *rsp,ra
                   < elite.a99
19373 5C5E D80D  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; x-coordinate of the crosshairs from QQ10 into A, ready
     5C60 0082     
19374 5C62 D360  30        movb @QQ9,ra                    ; LDA QQ9           ; for the call to TT123
     5C64 0F31     
19375               
19376 5C66 0200  20        li   rtmp,TT123                 ; JSR TT123         ; Call TT123 to move the selected system's galactic
     5C68 5CA0     
19377 5C6A 06A0  32        bl   @jsr                       ;
     5C6C FE28     
19378                                                                          ; x-coordinate by the x-delta, putting the new value in
19379                                                                          ; QQ19+4
19380               
19381 5C6E D360  30        movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated x-coordinate in QQ9 (the current
     5C70 0083     
19382 5C72 D80D  30        movb ra,@QQ9                    ; STA QQ9           ; x-coordinate of the crosshairs)
     5C74 0F31     
19383               
19384 5C76 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; This instruction has no effect, as QQ19 is overwritten
     5C78 007F     
19385                                                                          ; below, both in TT103 and TT105
19386               
19387                                                                          ; Now we've updated the coordinates of the crosshairs,
19388                                                                          ; fall through into TT103 to redraw them at their new
19389                                                                          ; location
19390               
19391               * ******************************************************************************
19392               *
19393               * Name: TT103
19394               * Type: Subroutine
19395               * Category: Charts
19396               * Summary: Draw a small set of crosshairs on a chart
19397               *
19398               * ------------------------------------------------------------------------------
19399               *
19400               * Draw a small set of crosshairs on a galactic chart at the coordinates in
19401               * (QQ9, QQ10).
19402               *
19403               * ******************************************************************************
19404               
19405               TT103:
19406 5C7A D360  30        movb @QQ11,ra                   ; LDA QQ11          ; Fetch the current view type into A
     5C7C 0096     
19407               
19408 5C7E 1320  14        jeq  TT180                      ; BEQ TT180         ; If this is a space view, return from the subroutine
19409                                                                          ; (as TT180 contains an RTS), as there are no moveable
19410                                                                          ; crosshairs in space
19411               
19412 5C80 1121  14        jlt  TT105                      ; BMI TT105         ; If this is the Short-range Chart screen, jump to TT105
19413               
19414 5C82 D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Store the crosshairs x-coordinate in QQ19
     5C84 0F31     
19415 5C86 D80D  30        movb ra,@QQ19                   ; STA QQ19
     5C88 007F     
19416               
19417 5C8A D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Halve the crosshairs y-coordinate and store it in QQ19
     5C8C 0F32     
19418 5C8E 091D  18        srl  ra,1                       ; LSR A             ; (we halve it because the Long-range Chart is half as
19419 5C90 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; high as it is wide)
     5C92 0080     
19420               
19421 5C94 020D  20        li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to 4 denote crosshairs of size 4
     5C96 0400     
19422 5C98 D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5C9A 0081     
19423               
19424 5C9C 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 4 at the
     5C9E 56FE     
19425                                                                          ; crosshairs coordinates, returning from the subroutine
19426                                                                          ; using a tail call
19427               
19428               * ******************************************************************************
19429               *
19430               * Name: TT123
19431               * Type: Subroutine
19432               * Category: Charts
19433               * Summary: Move galactic coordinates by a signed delta
19434               *
19435               * ------------------------------------------------------------------------------
19436               *
19437               * Move an 8-bit galactic coordinate by a certain distance in either direction
19438               * (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
19439               * overflow. The coordinate is in a single axis, so it's either an x-coordinate
19440               * or a y-coordinate.
19441               *
19442               * ------------------------------------------------------------------------------
19443               *
19444               * Arguments:
19445               *
19446               * A                   The galactic coordinate to update
19447               *
19448               * QQ19+3              The delta (can be positive or negative)
19449               *
19450               * ------------------------------------------------------------------------------
19451               *
19452               * Returns:
19453               *
19454               * QQ19+4              The updated coordinate after moving by the delta (this
19455               * will be the same as A if moving by the delta overflows)
19456               *
19457               * ------------------------------------------------------------------------------
19458               *
19459               * Other entry points:
19460               *
19461               * TT180               Contains an RTS
19462               *
19463               * ******************************************************************************
19464               
19465               TT123:
19466 5CA0 D80D  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the original coordinate in temporary storage at
     5CA2 0083     
19467                                                                          ; QQ19+4
19468               
19469                      .clc                            ; CLC               ; Set A = A + QQ19+3, so A now contains the original
     **** ****     > CLC
0001 5CA4 0A16  18        sla  rzero,1
                   < elite.a99
19470                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ; coordinate, moved by the delta
     **** ****     > ADC
0001 5CA6 1701  14        jnc  !
0002 5CA8 B347  18        ab   rone,ra
0003               !:
0004 5CAA B360  30        ab   @QQ19+3,ra
     5CAC 0082     
                   < elite.a99
19471               
19472 5CAE D3A0  30        movb @QQ19+3,rx                 ; LDX QQ19+3        ; If the delta is negative, jump to TT124
     5CB0 0082     
19473 5CB2 1103  14        jlt  TT124                      ; BMI TT124
19474               
19475 5CB4 1703  14        jnc  TT125                      ; BCC TT125         ; If the C flag is clear, then the above addition didn't
19476                                                                          ; overflow, so jump to TT125 to return the updated value
19477               
19478 5CB6 0460  28        b    @rts                       ; RTS               ; Otherwise the C flag is set and the above addition
     5CB8 FE34     
19479                                                                          ; overflowed, so do not update the return value
19480               
19481               TT124:
19482 5CBA 1702  14        jnc  TT180                      ; BCC TT180         ; If the C flag is clear, then because the delta is
19483                                                                          ; negative, this indicates the addition (which is
19484                                                                          ; effectively a subtraction) underflowed, so jump to
19485                                                                          ; TT180 to return from the subroutine without updating
19486                                                                          ; the return value
19487               
19488               TT125:
19489 5CBC D80D  30        movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the updated coordinate in QQ19+4
     5CBE 0083     
19490               
19491               TT180:
19492 5CC0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5CC2 FE34     
19493               
19494               * ******************************************************************************
19495               *
19496               * Name: TT105
19497               * Type: Subroutine
19498               * Category: Charts
19499               * Summary: Draw crosshairs on the Short-range Chart, with clipping
19500               *
19501               * ------------------------------------------------------------------------------
19502               *
19503               * Check whether the crosshairs are close enough to the current system to appear
19504               * on the Short-range Chart, and if so, draw them.
19505               *
19506               * ******************************************************************************
19507               
19508               TT105:
19509 5CC4 D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Set A = QQ9 - QQ0, the horizontal distance between the
     5CC6 0F31     
19510                      .sec                            ; SEC               ; crosshairs (QQ9) and the current system (QQ0)
     **** ****     > SEC
0001 5CC8 0A18  18        sla  rmone,1
                   < elite.a99
19511                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 5CCA 1801  14        joc  !
0002 5CCC 7347  18        sb   rone,ra
0003               !:
0004 5CCE 7360  30        sb   @QQ0,ra
     5CD0 0301     
                   < elite.a99
19512               
19513 5CD2 028D  22        ci   ra,>26*256                 ; CMP #38           ; If the horizontal distance in A < 38, then the
     5CD4 2600     
19514 5CD6 1703  14        jnc  TT179                      ; BCC TT179         ; crosshairs are close enough to the current system to
19515                                                                          ; appear in the Short-range Chart, so jump to TT179 to
19516                                                                          ; check the vertical distance
19517               
19518 5CD8 028D  22        ci   ra,>e6*256                 ; CMP #230          ; If the horizontal distance in A < -26, then the
     5CDA E600     
19519 5CDC 17F1  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19520                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19521                                                                          ; return from the subroutine (as TT180 contains an RTS)
19522               
19523               TT179:
19524                      .asla                           ; ASL A             ; Set QQ19 = 104 + A * 4
     **** ****     > ASLA
0001 5CDE 024D  22        andi ra,>ff00
     5CE0 FF00     
0002 5CE2 0A1D  18        sla  ra,1
                   < elite.a99
19525                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 5CE4 024D  22        andi ra,>ff00
     5CE6 FF00     
0002 5CE8 0A1D  18        sla  ra,1
                   < elite.a99
19526                      .clc                            ; CLC               ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > CLC
0001 5CEA 0A16  18        sla  rzero,1
                   < elite.a99
19527                      .adi (>68*256)                  ; ADC #104          ; so this sets QQ19 to the screen pixel x-coordinate
     **** ****     > ADI
0001 5CEC 1701  14        jnc  !
0002 5CEE B347  18        ab   rone,ra
0003               !:
0004 5CF0 022D  22        ai   ra,(>68*256)
     5CF2 6800     
                   < elite.a99
19528 5CF4 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; of the crosshairs
     5CF6 007F     
19529               
19530 5CF8 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     5CFA 0F32     
19531                      .sec                            ; SEC               ; crosshairs (QQ10) and the current system (QQ1)
     **** ****     > SEC
0001 5CFC 0A18  18        sla  rmone,1
                   < elite.a99
19532                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 5CFE 1801  14        joc  !
0002 5D00 7347  18        sb   rone,ra
0003               !:
0004 5D02 7360  30        sb   @QQ1,ra
     5D04 0302     
                   < elite.a99
19533               
19534 5D06 028D  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is < 38, then the
     5D08 2600     
19535 5D0A 1703  14        jnc  B57                        ; BCC B57           ; crosshairs are close enough to the current system to
19536                                                                          ; appear in the Short-range Chart, so skip the next two
19537                                                                          ; instructions
19538               
19539 5D0C 028D  22        ci   ra,>dc*256                 ; CMP #220          ; If the horizontal distance in A is < -36, then the
     5D0E DC00     
19540 5D10 17D7  14        jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
19541                                                                          ; appear in the Short-range Chart, so jump to TT180 to
19542                                                                          ; return from the subroutine (as TT180 contains an RTS)
19543               
19544               B57:
19545                      .asla                           ; ASL A             ; Set QQ19+1 = 90 + A * 2
     **** ****     > ASLA
0001 5D12 024D  22        andi ra,>ff00
     5D14 FF00     
0002 5D16 0A1D  18        sla  ra,1
                   < elite.a99
19546                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 5D18 0A16  18        sla  rzero,1
                   < elite.a99
19547                      .adi (>5a*256)                  ; ADC #90           ; 90 is the y-coordinate of the centre of the chart,
     **** ****     > ADI
0001 5D1A 1701  14        jnc  !
0002 5D1C B347  18        ab   rone,ra
0003               !:
0004 5D1E 022D  22        ai   ra,(>5A*256)
     5D20 5A00     
                   < elite.a99
19548 5D22 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; so this sets QQ19+1 to the screen pixel x-coordinate
     5D24 0080     
19549                                                                          ; of the crosshairs
19550               
19551 5D26 020D  20        li   ra,>08*256                 ; LDA #8            ; Set QQ19+2 to 8 denote crosshairs of size 8
     5D28 0800     
19552 5D2A D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2
     5D2C 0081     
19553               
19554 5D2E 0460  28        b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 8 at the
     5D30 56FE     
19555                                                                          ; crosshairs coordinates, returning from the subroutine
19556                                                                          ; using a tail call
19557               
19558               * ******************************************************************************
19559               *
19560               * Name: TT23
19561               * Type: Subroutine
19562               * Category: Charts
19563               * Summary: Show the Short-range Chart (red key f5)
19564               *
19565               * ******************************************************************************
19566               
19567               TT23:
19568 5D32 020D  20        li   ra,>80*256                 ; LDA #128          ; Clear the top part of the screen, draw a white border,
     5D34 8000     
19569 5D36 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 128 (Short-
     5D38 4EFA     
19570 5D3A 06A0  32        bl   @jsr                       ;
     5D3C FE28     
19571                                                                          ; range Chart)
19572               
19573 5D3E 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
     5D40 0700     
19574 5D42 D80D  30        movb ra,@XC                     ; STA XC
     5D44 002C     
19575               
19576 5D46 020D  20        li   ra,>be*256                 ; LDA #190          ; Print recursive token 30 ("SHORT RANGE CHART") and
     5D48 BE00     
19577 5D4A 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; draw a horizontal line at pixel row 19 to box in the
     5D4C 2738     
19578 5D4E 06A0  32        bl   @jsr                       ;
     5D50 FE28     
19579                                                                          ; title
19580               
19581 5D52 0200  20        li   rtmp,TT14                  ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
     5D54 57E2     
19582 5D56 06A0  32        bl   @jsr                       ;
     5D58 FE28     
19583                                                                          ; current system's galactic coordinates
19584               
19585 5D5A 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     5D5C 5C7A     
19586 5D5E 06A0  32        bl   @jsr                       ;
     5D60 FE28     
19587                                                                          ; i.e. at the selected system
19588               
19589 5D62 0200  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     5D64 5EC2     
19590 5D66 06A0  32        bl   @jsr                       ;
     5D68 FE28     
19591                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19592               
19593 5D6A 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0, which we'll use below to zero out the INWK
     5D6C 0000     
19594                                                                          ; workspace
19595               
19596 5D6E D80D  30        movb ra,@XX20                   ; STA XX20          ; We're about to start working our way through each of
     5D70 00A8     
19597                                                                          ; the galaxy's systems, so set up a counter in XX20 for
19598                                                                          ; each system, starting at 0 and looping through to 255
19599               
19600 5D72 020E  20        li   rx,>18*256                 ; LDX #24           ; First, though, we need to zero out the 25 bytes at
     5D74 1800     
19601                                                                          ; INWK so we can use them to work out which systems have
19602                                                                          ; room for a label, so set a counter in X for 25 bytes
19603               
19604               EE3:
19605 5D76 06CE  14        swpb rx                         ;
19606 5D78 DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X        ; Set the X-th byte of INWK to zero
     5D7A 0053     
19607 5D7C 06CE  14        swpb rx                         ;
19608               
19609 5D7E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19610               
19611 5D80 15FA  14        jgt  EE3                        ; BPL EE3           ; Loop back to EE3 for the next byte until we've zeroed
19612                                                                          ; all 25 bytes
19613               
19614                                                                          ; We now loop through every single system in the galaxy
19615                                                                          ; and check the distance from the current system whose
19616                                                                          ; coordinates are in (QQ0, QQ1). We get the galactic
19617                                                                          ; coordinates of each system from the system's seeds,
19618                                                                          ; like this:
19619                                                                          ;
19620                                                                          ; x = s1_hi (which is stored in QQ15+3)
19621                                                                          ; y = s0_hi (which is stored in QQ15+1)
19622                                                                          ;
19623                                                                          ; so the following loops through each system in the
19624                                                                          ; galaxy in turn and calculates the distance between
19625                                                                          ; (QQ0, QQ1) and (s1_hi, s0_hi) to find the closest one
19626               
19627               TT182:
19628 5D82 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     5D84 007B     
19629                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 5D86 0A18  18        sla  rmone,1
                   < elite.a99
19630                      .sbc @QQ0,ra                    ; SBC QQ0
     **** ****     > SBC
0001 5D88 1801  14        joc  !
0002 5D8A 7347  18        sb   rone,ra
0003               !:
0004 5D8C 7360  30        sb   @QQ0,ra
     5D8E 0301     
                   < elite.a99
19631               
19632 5D90 1807  14        joc  TT184                      ; BCS TT184         ; If a borrow didn't occur, i.e. s1_hi >= QQ0, then the
19633                                                                          ; result is positive, so jump to TT184 and skip the
19634                                                                          ; following two instructions
19635               
19636                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5D92 0200  20        li   rtmp,(>FF*256)
     5D94 FF00     
0002 5D96 2B40  18        xor  rtmp,ra
                   < elite.a99
19637                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ0|)
     **** ****     > ADI
0001 5D98 1701  14        jnc  !
0002 5D9A B347  18        ab   rone,ra
0003               !:
0004 5D9C 022D  22        ai   ra,(>01*256)
     5D9E 0100     
                   < elite.a99
19638               
19639               TT184:
19640 5DA0 028D  22        ci   ra,>14*256                 ; CMP #20           ; If the horizontal distance in A is >= 20, then this
     5DA2 1400     
19641 5DA4 1702  14        jnc  TT184A                     ; BCC TT184A        ; system is too far away from the current system to
19642 5DA6 0460  28        b    @TT187                     ; JMP TT187         ; appear in the Short-range Chart, so jump to TT187 to
     5DA8 5EB0     
19643                                                                          ; move on to the next system
19644               TT184A:
19645 5DAA D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     5DAC 0079     
19646                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
     **** ****     > SEC
0001 5DAE 0A18  18        sla  rmone,1
                   < elite.a99
19647                      .sbc @QQ1,ra                    ; SBC QQ1
     **** ****     > SBC
0001 5DB0 1801  14        joc  !
0002 5DB2 7347  18        sb   rone,ra
0003               !:
0004 5DB4 7360  30        sb   @QQ1,ra
     5DB6 0302     
                   < elite.a99
19648               
19649 5DB8 1807  14        joc  TT186                      ; BCS TT186         ; If a borrow didn't occur, i.e. s0_hi >= QQ1, then the
19650                                                                          ; result is positive, so jump to TT186 and skip the
19651                                                                          ; following two instructions
19652               
19653                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 5DBA 0200  20        li   rtmp,(>FF*256)
     5DBC FF00     
0002 5DBE 2B40  18        xor  rtmp,ra
                   < elite.a99
19654                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ1|)
     **** ****     > ADI
0001 5DC0 1701  14        jnc  !
0002 5DC2 B347  18        ab   rone,ra
0003               !:
0004 5DC4 022D  22        ai   ra,(>01*256)
     5DC6 0100     
                   < elite.a99
19655               
19656               TT186:
19657 5DC8 028D  22        ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is >= 38, then this
     5DCA 2600     
19658 5DCC 1871  14        joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
19659                                                                          ; appear in the Short-range Chart, so jump to TT187 to
19660                                                                          ; move on to the next system
19661               
19662                                                                          ; This system should be shown on the Short-range Chart,
19663                                                                          ; so now we need to work out where the label should go,
19664                                                                          ; and set up the various variables we need to draw the
19665                                                                          ; system's filled circle on the chart
19666               
19667 5DCE D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
     5DD0 007B     
19668                      .sec                            ; SEC               ; this system and the current system, where |A| < 20.
     **** ****     > SEC
0001 5DD2 0A18  18        sla  rmone,1
                   < elite.a99
19669                      .sbc @QQ0,ra                    ; SBC QQ0           ; Let's call this the x-delta, as it's the horizontal
     **** ****     > SBC
0001 5DD4 1801  14        joc  !
0002 5DD6 7347  18        sb   rone,ra
0003               !:
0004 5DD8 7360  30        sb   @QQ0,ra
     5DDA 0301     
                   < elite.a99
19670                                                                          ; difference between the current system at the centre of
19671                                                                          ; the chart, and this system (and this time we keep the
19672                                                                          ; sign of A, so it can be negative if it's to the left
19673                                                                          ; of the chart's centre, or positive if it's to the
19674                                                                          ; right)
19675               
19676                      .asla                           ; ASL A             ; Set XX12 = 104 + x-delta * 4
     **** ****     > ASLA
0001 5DDC 024D  22        andi ra,>ff00
     5DDE FF00     
0002 5DE0 0A1D  18        sla  ra,1
                   < elite.a99
19677                      .asla                           ; ASL A             ;
     **** ****     > ASLA
0001 5DE2 024D  22        andi ra,>ff00
     5DE4 FF00     
0002 5DE6 0A1D  18        sla  ra,1
                   < elite.a99
19678                      .adi (>68*256)                  ; ADC #104          ; 104 is the x-coordinate of the centre of the chart,
     **** ****     > ADI
0001 5DE8 1701  14        jnc  !
0002 5DEA B347  18        ab   rone,ra
0003               !:
0004 5DEC 022D  22        ai   ra,(>68*256)
     5DEE 6800     
                   < elite.a99
19679 5DF0 D80D  30        movb ra,@XX12                   ; STA XX12          ; so this sets XX12 to the centre 104 +/- 76, the pixel
     5DF2 0037     
19680                                                                          ; x-coordinate of this system
19681               
19682 5DF4 091D  18        srl  ra,1                       ; LSR A             ; Move the text cursor to column x-delta / 2 + 1
19683 5DF6 091D  18        srl  ra,1                       ; LSR A             ; which will be in the range 1-10
19684 5DF8 091D  18        srl  ra,1                       ; LSR A
19685 5DFA D80D  30        movb ra,@XC                     ; STA XC
     5DFC 002C     
19686 5DFE B347  18        ab   rone,ra                    ; INC XC
19687               
19688 5E00 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
     5E02 0079     
19689                      .sec                            ; SEC               ; this system and the current system, where |A| < 38.
     **** ****     > SEC
0001 5E04 0A18  18        sla  rmone,1
                   < elite.a99
19690                      .sbc @QQ1,ra                    ; SBC QQ1           ; Let's call this the y-delta, as it's the vertical
     **** ****     > SBC
0001 5E06 1801  14        joc  !
0002 5E08 7347  18        sb   rone,ra
0003               !:
0004 5E0A 7360  30        sb   @QQ1,ra
     5E0C 0302     
                   < elite.a99
19691                                                                          ; difference between the current system at the centre of
19692                                                                          ; the chart, and this system (and this time we keep the
19693                                                                          ; sign of A, so it can be negative if it's above the
19694                                                                          ; chart's centre, or positive if it's below)
19695               
19696                      .asla                           ; ASL A             ; Set K4 = 90 + y-delta * 2
     **** ****     > ASLA
0001 5E0E 024D  22        andi ra,>ff00
     5E10 FF00     
0002 5E12 0A1D  18        sla  ra,1
                   < elite.a99
19697                      .adi (>5a*256)                  ; ADC #90           ;
     **** ****     > ADI
0001 5E14 1701  14        jnc  !
0002 5E16 B347  18        ab   rone,ra
0003               !:
0004 5E18 022D  22        ai   ra,(>5A*256)
     5E1A 5A00     
                   < elite.a99
19698 5E1C D80D  30        movb ra,@K4                     ; STA K4            ; 90 is the y-coordinate of the centre of the chart,
     5E1E 00E0     
19699                                                                          ; so this sets K4 to the centre 90 +/- 74, the pixel
19700                                                                          ; y-coordinate of this system
19701               
19702 5E20 091D  18        srl  ra,1                       ; LSR A             ; Set Y = K4 / 8, so Y contains the number of the text
19703 5E22 091D  18        srl  ra,1                       ; LSR A             ; row that contains this system
19704 5E24 091D  18        srl  ra,1                       ; LSR A
19705 5E26 D3CD  18        movb ra,ry                      ; TAY
19706               
19707                                                                          ; Now to see if there is room for this system's label.
19708                                                                          ; Ideally we would print the system name on the same
19709                                                                          ; text row as the system, but we only want to print one
19710                                                                          ; label per row, to prevent overlap, so now we check
19711                                                                          ; this system's row, and if that's already occupied,
19712                                                                          ; the row above, and if that's already occupied, the
19713                                                                          ; row below... and if that's already occupied, we give
19714                                                                          ; up and don't print a label for this system
19715               
19716 5E28 06CF  14        swpb ry                         ;
19717 5E2A D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; If the value in INWK+Y is 0 (i.e. the text row
     5E2C 0053     
19718 5E2E 06CF  14        swpb ry                         ;
19719 5E30 130D  14        jeq  EE4                        ; BEQ EE4           ; containing this system does not already have another
19720                                                                          ; system's label on it), jump to EE4 to store this
19721                                                                          ; system's label on this row
19722               
19723 5E32 B3C7  18        ab   rone,ry                    ; INY               ; If the value in INWK+Y+1 is 0 (i.e. the text row below
19724 5E34 06CF  14        swpb ry                         ;
19725 5E36 D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; the one containing this system does not already have
     5E38 0053     
19726 5E3A 06CF  14        swpb ry                         ;
19727 5E3C 1307  14        jeq  EE4                        ; BEQ EE4           ; another system's label on it), jump to EE4 to store
19728                                                                          ; this system's label on this row
19729               
19730 5E3E 73C7  18        sb   rone,ry                    ; DEY               ; If the value in INWK+Y-1 is 0 (i.e. the text row above
19731 5E40 73C7  18        sb   rone,ry                    ; DEY               ; the one containing this system does not already have
19732 5E42 06CF  14        swpb ry                         ;
19733 5E44 D3AF  34        movb @INWK(ry),rx               ; LDX INWK,Y        ; another system's label on it), fall through into to
     5E46 0053     
19734 5E48 06CF  14        swpb ry                         ;
19735 5E4A 1610  14        jne  ee1_                       ; BNE ee1           ; EE4 to store this system's label on this row,
19736                                                                          ; otherwise jump to ee1 to skip printing a label for
19737                                                                          ; this system (as there simply isn't room)
19738               
19739               EE4:
19740 5E4C D80F  30        movb ry,@YC                     ; STY YC            ; Now to print the label, so move the text cursor to row
     5E4E 002D     
19741                                                                          ; Y (which contains the row where we can print this
19742                                                                          ; system's label)
19743               
19744 5E50 028F  22        ci   ry,>03*256                 ; CPY #3            ; If Y < 3, then the system would clash with the chart
     5E52 0300     
19745 5E54 172D  14        jnc  TT187                      ; BCC TT187         ; title, so jump to TT187 to skip showing the system
19746               
19747 5E56 7387  18        sb   rone,rx                    ; DEX               ; We entered the EE4 routine with X = 0, so this stores
19748 5E58 DBCE  38        movb rx,@INWK(ry)               ; STX INWK,Y        ; &FF in INWK+Y, to denote that this row is now occupied
     5E5A 0053     
19749                                                                          ; so we don't try to print another system's label on
19750                                                                          ; this row
19751               
19752 5E5C 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
     5E5E 8000     
19753 5E60 D80D  30        movb ra,@QQ17                   ; STA QQ17
     5E62 007E     
19754               
19755 5E64 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     5E66 AB54     
19756 5E68 06A0  32        bl   @jsr                       ;
     5E6A FE28     
19757                                                                          ; in QQ15 (which now contains the seeds for the current
19758                                                                          ; system)
19759               
19760               ee1_:
19761 5E6C 020D  20        li   ra,>00*256                 ; LDA #0            ; Now to plot the star, so set the high bytes of K, K3
     5E6E 0000     
19762 5E70 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; and K4 to 0
     5E72 00D3     
19763 5E74 D80D  30        movb ra,@K4+1                   ; STA K4+1
     5E76 00E1     
19764 5E78 D80D  30        movb ra,@K+1                    ; STA K+1
     5E7A 003E     
19765               
19766 5E7C D360  30        movb @XX12,ra                   ; LDA XX12          ; Set the low byte of K3 to XX12, the pixel x-coordinate
     5E7E 0037     
19767 5E80 D80D  30        movb ra,@K3                     ; STA K3            ; of this system
     5E82 00D2     
19768               
19769 5E84 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi for this system from QQ15+5, extract bit 0
     5E86 007D     
19770 5E88 024D  22        andi ra,>01*256                 ; AND #1            ; and add 2 to get the size of the star, which we store
     5E8A 0100     
19771                      .adi (>02*256)                  ; ADC #2            ; in K. This will be either 2, 3 or 4, depending on the
     **** ****     > ADI
0001 5E8C 1701  14        jnc  !
0002 5E8E B347  18        ab   rone,ra
0003               !:
0004 5E90 022D  22        ai   ra,(>02*256)
     5E92 0200     
                   < elite.a99
19772 5E94 D80D  30        movb ra,@K                      ; STA K             ; value of bit 0, and whether the C flag is set (which
     5E96 003D     
19773                                                                          ; will vary depending on what happens in the above call
19774                                                                          ; to cpl). Incidentally, the planet's average radius
19775                                                                          ; also uses s2_hi, bits 0-3 to be precise, but that
19776                                                                          ; doesn't mean the two sizes affect each other
19777               
19778                                                                          ; We now have the following:
19779                                                                          ;
19780                                                                          ; K(1 0)  = radius of star (2, 3 or 4)
19781                                                                          ;
19782                                                                          ; K3(1 0) = pixel x-coordinate of system
19783                                                                          ;
19784                                                                          ; K4(1 0) = pixel y-coordinate of system
19785                                                                          ;
19786                                                                          ; which we can now pass to the SUN routine to draw a
19787                                                                          ; small "sun" on the Short-range Chart for this system
19788               
19789 5E98 0200  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5E9A B2C6     
19790 5E9C 06A0  32        bl   @jsr                       ;
     5E9E FE28     
19791               
19792 5EA0 0200  20        li   rtmp,SUN                   ; JSR SUN           ; Call SUN to plot a sun with radius K at pixel
     5EA2 BC68     
19793 5EA4 06A0  32        bl   @jsr                       ;
     5EA6 FE28     
19794                                                                          ; coordinate (K3, K4)
19795               
19796 5EA8 0200  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block
     5EAA B2C6     
19797 5EAC 06A0  32        bl   @jsr                       ;
     5EAE FE28     
19798               
19799               TT187:
19800 5EB0 0200  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     5EB2 521A     
19801 5EB4 06A0  32        bl   @jsr                       ;
     5EB6 FE28     
19802                                                                          ; to twist the three 16-bit seeds in QQ15
19803               
19804 5EB8 B347  18        ab   rone,ra                    ; INC XX20          ; Increment the counter
19805               
19806 5EBA 0460  28        b    @rts                       ; RTS               ; If X = 0 then we have done all 256 systems, so return
     5EBC FE34     
19807                                                                          ; from the subroutine (as TT111-1 contains an RTS)
19808               
19809 5EBE 0460  28        b    @TT182                     ; JMP TT182         ; Otherwise jump back up to TT182 to process the next
     5EC0 5D82     
19810                                                                          ; system
19811               
19812               * ******************************************************************************
19813               *
19814               * Name: TT81
19815               * Type: Subroutine
19816               * Category: Universe
19817               * Summary: Set the selected system's seeds to those of system 0
19818               *
19819               * ------------------------------------------------------------------------------
19820               *
19821               * Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
19822               * seeds for the selected system (QQ15) - in other words, set the selected
19823               * system's seeds to those of system 0.
19824               *
19825               * ******************************************************************************
19826               
19827               TT81:
19828 5EC2 020E  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X to copy six bytes (for three
     5EC4 0500     
19829                                                                          ; 16-bit numbers)
19830               
19831 5EC6 06CE  14        swpb rx                         ;
19832 5EC8 D36E  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Copy the X-th byte in QQ21 to the X-th byte in QQ15
     5ECA 0303     
19833 5ECC 06CE  14        swpb rx                         ;
19834 5ECE 06CE  14        swpb rx                         ;
19835 5ED0 DB8D  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     5ED2 0078     
19836 5ED4 06CE  14        swpb rx                         ;
19837               
19838 5ED6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19839               
19840 5ED8 15F5  14        jgt  TT81+2                     ; BPL TT81+2        ; Loop back up to the LDA instruction if we still have
19841                                                                          ; more bytes to copy
19842               
19843 5EDA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     5EDC FE34     
19844               
19845               * ******************************************************************************
19846               *
19847               * Name: TT111
19848               * Type: Subroutine
19849               * Category: Universe
19850               * Summary: Set the current system to the nearest system to a point
19851               *
19852               * ------------------------------------------------------------------------------
19853               *
19854               * Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
19855               * to this point in the galaxy, and set this as the currently selected system.
19856               *
19857               * ------------------------------------------------------------------------------
19858               *
19859               * Arguments:
19860               *
19861               * QQ9                 The x-coordinate near which we want to find a system
19862               *
19863               * QQ10                The y-coordinate near which we want to find a system
19864               *
19865               * ------------------------------------------------------------------------------
19866               *
19867               * Returns:
19868               *
19869               * QQ8(1 0)            The distance from the current system to the nearest
19870               * system to the original coordinates
19871               *
19872               * QQ9                 The x-coordinate of the nearest system to the original
19873               * coordinates
19874               *
19875               * QQ10                The y-coordinate of the nearest system to the original
19876               * coordinates
19877               *
19878               * QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
19879               * original coordinates
19880               *
19881               * ------------------------------------------------------------------------------
19882               *
19883               * Other entry points:
19884               *
19885               * TT111-1             Contains an RTS
19886               *
19887               * ******************************************************************************
19888               
19889                      aorg CODE_UPPER.                                    ; TI-99/4A upper RAM code
19890               
19891               TT111:
19892 A000 0200  20        li   rtmp,TT81                  ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
     A002 5EC2     
19893 A004 06A0  32        bl   @jsr                       ;
     A006 FE28     
19894                                                                          ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)
19895               
19896                                                                          ; We now loop through every single system in the galaxy
19897                                                                          ; and check the distance from (QQ9, QQ10). We get the
19898                                                                          ; galactic coordinates of each system from the system's
19899                                                                          ; seeds, like this:
19900                                                                          ;
19901                                                                          ; x = s1_hi (which is stored in QQ15+3)
19902                                                                          ; y = s0_hi (which is stored in QQ15+1)
19903                                                                          ;
19904                                                                          ; so the following loops through each system in the
19905                                                                          ; galaxy in turn and calculates the distance between
19906                                                                          ; (QQ9, QQ10) and (s1_hi, s0_hi) to find the closest one
19907               
19908 A008 020F  20        li   ry,>7f*256                 ; LDY #127          ; Set Y = T = 127 to hold the shortest distance we've
     A00A 7F00     
19909 A00C D80F  30        movb ry,@T                      ; STY T             ; found so far, which we initially set to half the
     A00E 00D1     
19910                                                                          ; distance across the galaxy, or 127, as our coordinate
19911                                                                          ; system ranges from (0,0) to (255, 255)
19912               
19913 A010 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = U = 0 to act as a counter for each system in
     A012 0000     
19914 A014 D80D  30        movb ra,@U                      ; STA U             ; the current galaxy, which we start at system 0 and
     A016 008F     
19915                                                                          ; loop through to 255, the last system
19916               
19917               TT130:
19918 A018 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ9, the horizontal distance between
     A01A 007B     
19919                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 A01C 0A18  18        sla  rmone,1
                   < elite.a99
19920                      .sbc @QQ9,ra                    ; SBC QQ9
     **** ****     > SBC
0001 A01E 1801  14        joc  !
0002 A020 7347  18        sb   rone,ra
0003               !:
0004 A022 7360  30        sb   @QQ9,ra
     A024 0F31     
                   < elite.a99
19921               
19922 A026 1807  14        joc  TT132                      ; BCS TT132         ; If a borrow didn't occur, i.e. s1_hi >= QQ9, then the
19923                                                                          ; result is positive, so jump to TT132 and skip the
19924                                                                          ; following two instructions
19925               
19926                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 A028 0200  20        li   rtmp,(>FF*256)
     A02A FF00     
0002 A02C 2B40  18        xor  rtmp,ra
                   < elite.a99
19927                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ9|)
     **** ****     > ADI
0001 A02E 1701  14        jnc  !
0002 A030 B347  18        ab   rone,ra
0003               !:
0004 A032 022D  22        ai   ra,(>01*256)
     A034 0100     
                   < elite.a99
19928               
19929               TT132:
19930 A036 091D  18        srl  ra,1                       ; LSR A             ; Set S = A / 2
19931 A038 D80D  30        movb ra,@S                      ; STA S             ; = |s1_hi - QQ9| / 2
     A03A 0092     
19932               
19933 A03C D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ10, the vertical distance between
     A03E 0079     
19934                      .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
     **** ****     > SEC
0001 A040 0A18  18        sla  rmone,1
                   < elite.a99
19935                      .sbc @QQ10,ra                   ; SBC QQ10
     **** ****     > SBC
0001 A042 1801  14        joc  !
0002 A044 7347  18        sb   rone,ra
0003               !:
0004 A046 7360  30        sb   @QQ10,ra
     A048 0F32     
                   < elite.a99
19936               
19937 A04A 1807  14        joc  TT134                      ; BCS TT134         ; If a borrow didn't occur, i.e. s0_hi >= QQ10, then the
19938                                                                          ; result is positive, so jump to TT134 and skip the
19939                                                                          ; following two instructions
19940               
19941                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 A04C 0200  20        li   rtmp,(>FF*256)
     A04E FF00     
0002 A050 2B40  18        xor  rtmp,ra
                   < elite.a99
19942                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ10|)
     **** ****     > ADI
0001 A052 1701  14        jnc  !
0002 A054 B347  18        ab   rone,ra
0003               !:
0004 A056 022D  22        ai   ra,(>01*256)
     A058 0100     
                   < elite.a99
19943               
19944               TT134:
19945 A05A 091D  18        srl  ra,1                       ; LSR A             ; Set A = S + A / 2
19946                      .clc                            ; CLC               ; = |s1_hi - QQ9| / 2 + |s0_hi - QQ10| / 2
     **** ****     > CLC
0001 A05C 0A16  18        sla  rzero,1
                   < elite.a99
19947                      .adc @S,ra                      ; ADC S             ;
     **** ****     > ADC
0001 A05E 1701  14        jnc  !
0002 A060 B347  18        ab   rone,ra
0003               !:
0004 A062 B360  30        ab   @S,ra
     A064 0092     
                   < elite.a99
19948                                                                          ; So A now contains the sum of the horizontal and
19949                                                                          ; vertical distances, both divided by 2 so the result
19950                                                                          ; fits into one byte, and although this doesn't contain
19951                                                                          ; the actual distance between the systems, it's a good
19952                                                                          ; enough approximation to use for comparing distances
19953               
19954 A066 9360  30        cb   @T,ra                      ; CMP T             ; If A >= T, then this system's distance is bigger than
     A068 00D1     
19955 A06A 180E  14        joc  TT135                      ; BCS TT135         ; our "minimum distance so far" stored in T, so it's no
19956                                                                          ; closer than the systems we have already found, so
19957                                                                          ; skip to TT135 to move on to the next system
19958               
19959 A06C D80D  30        movb ra,@T                      ; STA T             ; This system is the closest to (QQ9, QQ10) so far, so
     A06E 00D1     
19960                                                                          ; update T with the new "distance" approximation
19961               
19962 A070 020E  20        li   rx,>05*256                 ; LDX #5            ; As this system is the closest we have found yet, we
     A072 0500     
19963                                                                          ; want to store the system's seeds in case it ends up
19964                                                                          ; being the closest of all, so we set up a counter in X
19965                                                                          ; to copy six bytes (for three 16-bit numbers)
19966               
19967               TT136:
19968 A074 06CE  14        swpb rx                         ;
19969 A076 D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ19,
     A078 0078     
19970 A07A 06CE  14        swpb rx                         ;
19971 A07C 06CE  14        swpb rx                         ;
19972 A07E DB8D  38        movb ra,@QQ19(rx)               ; STA QQ19,X        ; where QQ15 contains the seeds for the system we just
     A080 007F     
19973 A082 06CE  14        swpb rx                         ;
19974                                                                          ; found to be the closest so far, and QQ19 is temporary
19975                                                                          ; storage
19976               
19977 A084 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
19978               
19979 A086 15F6  14        jgt  TT136                      ; BPL TT136         ; Loop back to TT136 if we still have more bytes to
19980                                                                          ; copy
19981               
19982               TT135:
19983 A088 0200  20        li   rtmp,TT20                  ; JSR TT20          ; We want to move on to the next system, so call TT20
     A08A 521A     
19984 A08C 06A0  32        bl   @jsr                       ;
     A08E FE28     
19985                                                                          ; to twist the three 16-bit seeds in QQ15
19986               
19987 A090 B347  18        ab   rone,ra                    ; INC U             ; Increment the system counter in U
19988               
19989 A092 16C2  14        jne  TT130                      ; BNE TT130         ; If U > 0 then we haven't done all 256 systems yet, so
19990                                                                          ; loop back up to TT130
19991               
19992                                                                          ; We have now finished checking all the systems in the
19993                                                                          ; galaxy, and the seeds for the closest system are in
19994                                                                          ; QQ19, so now we want to copy these seeds to QQ15,
19995                                                                          ; to set the selected system to this closest system
19996               
19997 A094 020E  20        li   rx,>05*256                 ; LDX #5            ; So we set up a counter in X to copy six bytes (for
     A096 0500     
19998                                                                          ; three 16-bit numbers)
19999               
20000               TT137:
20001 A098 06CE  14        swpb rx                         ;
20002 A09A D36E  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy the X-th byte in QQ19 to the X-th byte in QQ15
     A09C 007F     
20003 A09E 06CE  14        swpb rx                         ;
20004 A0A0 06CE  14        swpb rx                         ;
20005 A0A2 DB8D  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     A0A4 0078     
20006 A0A6 06CE  14        swpb rx                         ;
20007               
20008 A0A8 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
20009               
20010 A0AA 15F6  14        jgt  TT137                      ; BPL TT137         ; Loop back to TT137 if we still have more bytes to
20011                                                                          ; copy
20012               
20013 A0AC D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; The y-coordinate of the system described by the seeds
     A0AE 0079     
20014 A0B0 D80D  30        movb ra,@QQ10                   ; STA QQ10          ; in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
     A0B2 0F32     
20015                                                                          ; as this is where we store the selected system's
20016                                                                          ; y-coordinate
20017               
20018 A0B4 D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; The x-coordinate of the system described by the seeds
     A0B6 007B     
20019 A0B8 D80D  30        movb ra,@QQ9                    ; STA QQ9           ; in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
     A0BA 0F31     
20020                                                                          ; as this is where we store the selected system's
20021                                                                          ; x-coordinate
20022               
20023                                                                          ; We have now found the closest system to (QQ9, QQ10)
20024                                                                          ; and have set it as the selected system, so now we
20025                                                                          ; need to work out the distance between the selected
20026                                                                          ; system and the current system
20027               
20028                      .sec                            ; SEC               ; Set A = QQ9 - QQ0, the horizontal distance between
     **** ****     > SEC
0001 A0BC 0A18  18        sla  rmone,1
                   < elite.a99
20029                      .sbc @QQ0,ra                    ; SBC QQ0           ; the selected system's x-coordinate (QQ9) and the
     **** ****     > SBC
0001 A0BE 1801  14        joc  !
0002 A0C0 7347  18        sb   rone,ra
0003               !:
0004 A0C2 7360  30        sb   @QQ0,ra
     A0C4 0301     
                   < elite.a99
20030                                                                          ; current system's x-coordinate (QQ0)
20031               
20032 A0C6 1807  14        joc  TT139                      ; BCS TT139         ; If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
20033                                                                          ; result is positive, so jump to TT139 and skip the
20034                                                                          ; following two instructions
20035               
20036                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 A0C8 0200  20        li   rtmp,(>FF*256)
     A0CA FF00     
0002 A0CC 2B40  18        xor  rtmp,ra
                   < elite.a99
20037                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ9 - QQ0|)
     **** ****     > ADI
0001 A0CE 1701  14        jnc  !
0002 A0D0 B347  18        ab   rone,ra
0003               !:
0004 A0D2 022D  22        ai   ra,(>01*256)
     A0D4 0100     
                   < elite.a99
20038               
20039                                                                          ; A now contains the difference between the two
20040                                                                          ; systems' x-coordinates, with the sign removed. We
20041                                                                          ; will refer to this as the x-delta ("delta" means
20042                                                                          ; change or difference in maths)
20043               
20044               TT139:
20045 A0D6 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     A0D8 464E     
20046 A0DA 06A0  32        bl   @jsr                       ;
     A0DC FE28     
20047                                                                          ; = |QQ9 - QQ0| ^ 2
20048                                                                          ; = x_delta ^ 2
20049               
20050 A0DE D80D  30        movb ra,@K+1                    ; STA K+1           ; Store (A P) in K(1 0)
     A0E0 003E     
20051 A0E2 D360  30        movb @P,ra                      ; LDA P
     A0E4 001B     
20052 A0E6 D80D  30        movb ra,@K                      ; STA K
     A0E8 003D     
20053               
20054 A0EA D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
     A0EC 0F32     
20055                      .sec                            ; SEC               ; selected system's y-coordinate (QQ10) and the current
     **** ****     > SEC
0001 A0EE 0A18  18        sla  rmone,1
                   < elite.a99
20056                      .sbc @QQ1,ra                    ; SBC QQ1           ; system's y-coordinate (QQ1)
     **** ****     > SBC
0001 A0F0 1801  14        joc  !
0002 A0F2 7347  18        sb   rone,ra
0003               !:
0004 A0F4 7360  30        sb   @QQ1,ra
     A0F6 0302     
                   < elite.a99
20057               
20058 A0F8 1807  14        joc  TT141                      ; BCS TT141         ; If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
20059                                                                          ; result is positive, so jump to TT141 and skip the
20060                                                                          ; following two instructions
20061               
20062                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
     **** ****     > EOI
0001 A0FA 0200  20        li   rtmp,(>FF*256)
     A0FC FF00     
0002 A0FE 2B40  18        xor  rtmp,ra
                   < elite.a99
20063                      .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ10 - QQ1|)
     **** ****     > ADI
0001 A100 1701  14        jnc  !
0002 A102 B347  18        ab   rone,ra
0003               !:
0004 A104 022D  22        ai   ra,(>01*256)
     A106 0100     
                   < elite.a99
20064               
20065               TT141:
20066 A108 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
20067               
20068                                                                          ; A now contains the difference between the two
20069                                                                          ; systems' y-coordinates, with the sign removed, and
20070                                                                          ; halved. We halve the value because the galaxy in
20071                                                                          ; in Elite is rectangular rather than square, and is
20072                                                                          ; twice as wide (x-axis) as it is high (y-axis), so to
20073                                                                          ; get a distance that matches the shape of the
20074                                                                          ; long-range galaxy chart, we need to halve the
20075                                                                          ; distance between the vertical y-coordinates. We will
20076                                                                          ; refer to this as the y-delta
20077               
20078 A10A 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; Set (A P) = A * A
     A10C 464E     
20079 A10E 06A0  32        bl   @jsr                       ;
     A110 FE28     
20080                                                                          ; = (|QQ10 - QQ1| / 2) ^ 2
20081                                                                          ; = y_delta ^ 2
20082               
20083                                                                          ; By this point we have the following results:
20084                                                                          ;
20085                                                                          ; K(1 0) = x_delta ^ 2
20086                                                                          ; (A P) = y_delta ^ 2
20087                                                                          ;
20088                                                                          ; so to find the distance between the two points, we
20089                                                                          ; can use Pythagoras - so first we need to add the two
20090                                                                          ; results together, and then take the square root
20091               
20092                      .pha                            ; PHA               ; Store the high byte of the y-axis value on the stack,
     **** ****     > PHA
0001 A112 D68D  30        movb ra,*rsp
0002 A114 060A  14        dec  rsp
                   < elite.a99
20093                                                                          ; so we can use A for another purpose
20094               
20095 A116 D360  30        movb @P,ra                      ; LDA P             ; Set Q = P + K, which adds the low bytes of the two
     A118 001B     
20096                      .clc                            ; CLC               ; calculated values
     **** ****     > CLC
0001 A11A 0A16  18        sla  rzero,1
                   < elite.a99
20097                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 A11C 1701  14        jnc  !
0002 A11E B347  18        ab   rone,ra
0003               !:
0004 A120 B360  30        ab   @K,ra
     A122 003D     
                   < elite.a99
20098 A124 D80D  30        movb ra,@Q                      ; STA Q
     A126 0090     
20099               
20100                      .pla                            ; PLA               ; Restore the high byte of the y-axis value from the
     **** ****     > PLA
0001 A128 058A  14        inc  rsp
0002 A12A D35A  26        movb *rsp,ra
                   < elite.a99
20101                                                                          ; stack into A again
20102               
20103                      .adc @K+1,ra                    ; ADC K+1           ; Set R = A + K+1, which adds the high bytes of the two
     **** ****     > ADC
0001 A12C 1701  14        jnc  !
0002 A12E B347  18        ab   rone,ra
0003               !:
0004 A130 B360  30        ab   @K+1,ra
     A132 003E     
                   < elite.a99
20104 A134 D80D  30        movb ra,@R                      ; STA R             ; calculated values, so we now have:
     A136 0091     
20105                                                                          ;
20106                                                                          ; (R Q) = K(1 0) + (A P)
20107                                                                          ; = (x_delta ^ 2) + (y_delta ^ 2)
20108               
20109 A138 0200  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q), so Q now contains the distance
     A13A DA9E     
20110 A13C 06A0  32        bl   @jsr                       ;
     A13E FE28     
20111                                                                          ; between the two systems, in terms of coordinates
20112               
20113                                                                          ; We now store the distance to the selected system * 4
20114                                                                          ; in the two-byte location QQ8, by taking (0 Q) and
20115                                                                          ; shifting it left twice, storing it in QQ8(1 0)
20116               
20117 A140 D360  30        movb @Q,ra                      ; LDA Q             ; First we shift the low byte left by setting
     A142 0090     
20118                      .asla                           ; ASL A             ; A = Q * 2, with bit 7 of A going into the C flag
     **** ****     > ASLA
0001 A144 024D  22        andi ra,>ff00
     A146 FF00     
0002 A148 0A1D  18        sla  ra,1
                   < elite.a99
20119               
20120 A14A 020E  20        li   rx,>00*256                 ; LDX #0            ; Now we set the high byte in QQ8+1 to 0 and rotate
     A14C 0000     
20121 A14E D80E  30        movb rx,@QQ8+1                  ; STX QQ8+1         ; the C flag into bit 0 of QQ8+1
     A150 0F30     
20122 A152 0204  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     A154 0F30     
20123 A156 06A0  32        bl   @rol                       ;
     A158 FE4E     
20124               
20125                      .asla                           ; ASL A             ; And then we repeat the shift left of (QQ8+1 A)
     **** ****     > ASLA
0001 A15A 024D  22        andi ra,>ff00
     A15C FF00     
0002 A15E 0A1D  18        sla  ra,1
                   < elite.a99
20126 A160 0204  20        li   rarg1,QQ8+1                ; ROL QQ8+1
     A162 0F30     
20127 A164 06A0  32        bl   @rol                       ;
     A166 FE4E     
20128               
20129 A168 D80D  30        movb ra,@QQ8                    ; STA QQ8           ; And store A in the low byte, QQ8, so QQ8(1 0) now
     A16A 0F2F     
20130                                                                          ; contains Q * 4. Given that the width of the galaxy is
20131                                                                          ; 256 in coordinate terms, the width of the galaxy
20132                                                                          ; would be 1024 in the units we store in QQ8
20133               
20134 A16C 0460  28        b    @TT24                      ; JMP TT24          ; Call TT24 to calculate system data from the seeds in
     A16E 554A     
20135                                                                          ; QQ15 and store them in the relevant locations, so our
20136                                                                          ; new selected system is fully set up, and return from
20137                                                                          ; the subroutine using a tail call
20138               
20139               * ******************************************************************************
20140               *
20141               * Name: hy6
20142               * Type: Subroutine
20143               * Category: Flight
20144               * Summary: Print a message to say there is no hyperspacing allowed inside the
20145               * station
20146               *
20147               * ------------------------------------------------------------------------------
20148               *
20149               * Print "Docked" at the bottom of the screen to indicate we can't hyperspace
20150               * when docked.
20151               *
20152               * ******************************************************************************
20153               
20154               hy6_:
20155 A170 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     A172 4FFE     
20156 A174 06A0  32        bl   @jsr                       ;
     A176 FE28     
20157                                                                          ; and move the text cursor to column 1 on row 21, i.e.
20158                                                                          ; the start of the top row of the three bottom rows
20159               
20160 A178 020D  20        li   ra,>0f*256                 ; LDA #15           ; Move the text cursor to column 15 (the middle of the
     A17A 0F00     
20161 A17C D80D  30        movb ra,@XC                     ; STA XC            ; screen), setting A to 15 at the same time for the
     A17E 002C     
20162                                                                          ; following call to TT27
20163               
20164 A180 0460  28        b    @TT27                      ; JMP TT27          ; Print recursive token 129 ("{sentence case}DOCKED")
     A182 ACA0     
20165                                                                          ; and return from the subroutine using a tail call
20166               
20167               * ******************************************************************************
20168               *
20169               * Name: hyp
20170               * Type: Subroutine
20171               * Category: Flight
20172               * Summary: Start the hyperspace process
20173               *
20174               * ------------------------------------------------------------------------------
20175               *
20176               * Called when "H" or CTRL-H is pressed during flight. Checks the following:
20177               *
20178               * * We are in space
20179               *
20180               * * We are not already in a hyperspace countdown
20181               *
20182               * If CTRL is being held down, we jump to Ghy to engage the galactic hyperdrive,
20183               * otherwise we check that:
20184               *
20185               * * The selected system is not the current system
20186               *
20187               * * We have enough fuel to make the jump
20188               *
20189               * and if all the pre-jump checks are passed, we print the destination on-screen
20190               * and start the countdown.
20191               *
20192               * ******************************************************************************
20193               
20194               hyp_:
20195 A184 D360  30        movb @QQ12,ra                   ; LDA QQ12          ; If we are docked (QQ12 = &FF) then jump to hy6 to
     A186 009F     
20196 A188 16F3  14        jne  hy6_                       ; BNE hy6           ; print an error message and return from the subroutine
20197                                                                          ; using a tail call (as we can't hyperspace when docked)
20198               
20199 A18A D360  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; Fetch QQ22+1, which contains the number that's shown
     A18C 002F     
20200                                                                          ; on-screen during hyperspace countdown
20201               
20202 A18E 165D  14        jne  zZ_+1                      ; BNE zZ_+1         ; If it is non-zero, return from the subroutine (as zZ+1
20203                                                                          ; contains an RTS), as there is already a countdown in
20204                                                                          ; progress
20205               
20206 A190 0200  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed
     A192 D3C4     
20207 A194 06A0  32        bl   @jsr                       ;
     A196 FE28     
20208               
20209 A198 1136  14        jlt  Ghy                        ; BMI Ghy           ; If it is, then the galactic hyperdrive has been
20210                                                                          ; activated, so jump to Ghy to process it
20211               
20212 A19A 0200  20        li   rtmp,hm_                   ; JSR hm            ; This is a chart view, so call hm to redraw the chart
     A19C 4FE0     
20213 A19E 06A0  32        bl   @jsr                       ;
     A1A0 FE28     
20214                                                                          ; crosshairs
20215               
20216 A1A2 D360  30        movb @QQ8,ra                    ; LDA QQ8           ; If both bytes of the distance to the selected system
     A1A4 0F2F     
20217 A1A6 F360  30        socb @QQ8+1,ra                  ; ORA QQ8+1         ; in QQ8 are zero, return from the subroutine (as zZ+1
     A1A8 0F30     
20218 A1AA 134F  14        jeq  zZ_+1                      ; BEQ zZ_+1         ; contains an RTS), as the selected system is the
20219                                                                          ; current system
20220               
20221 A1AC 020D  20        li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7, row 23 (in the
     A1AE 0700     
20222 A1B0 D80D  30        movb ra,@XC                     ; STA XC            ; middle of the bottom text row)
     A1B2 002C     
20223 A1B4 020D  20        li   ra,>17*256                 ; LDA #23
     A1B6 1700     
20224 A1B8 D80D  30        movb ra,@YC                     ; STA YC
     A1BA 002D     
20225               
20226 A1BC 020D  20        li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
     A1BE 0000     
20227 A1C0 D80D  30        movb ra,@QQ17                   ; STA QQ17
     A1C2 007E     
20228               
20229 A1C4 020D  20        li   ra,>bd*256                 ; LDA #189          ; Print recursive token 29 ("HYPERSPACE ")
     A1C6 BD00     
20230 A1C8 0200  20        li   rtmp,TT27                  ; JSR TT27
     A1CA ACA0     
20231 A1CC 06A0  32        bl   @jsr                       ;
     A1CE FE28     
20232               
20233 A1D0 D360  30        movb @QQ8+1,ra                  ; LDA QQ8+1         ; If the high byte of the distance to the selected
     A1D2 0F30     
20234 A1D4 166A  14        jne  TT147                      ; BNE TT147         ; system in QQ8 is > 0, then it is definitely too far to
20235                                                                          ; jump (as our maximum range is 7.0 light years, or a
20236                                                                          ; value of 70 in QQ8(1 0)), so jump to TT147 to print
20237                                                                          ; "RANGE?" and return from the subroutine using a tail
20238                                                                          ; call
20239               
20240 A1D6 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Fetch our current fuel level from Q114 into A
     A1D8 030D     
20241               
20242 A1DA 9360  30        cb   @QQ8,ra                    ; CMP QQ8           ; If our fuel reserves are less than the distance to the
     A1DC 0F2F     
20243 A1DE 1765  14        jnc  TT147                      ; BCC TT147         ; selected system, then we don't have enough fuel for
20244                                                                          ; this jump, so jump to TT147 to print "RANGE?" and
20245                                                                          ; return from the subroutine using a tail call
20246               
20247 A1E0 020D  20        li   ra,('-')*256               ; LDA #'-'          ; Print a hyphen
     A1E2 2D00     
20248 A1E4 0200  20        li   rtmp,TT27                  ; JSR TT27
     A1E6 ACA0     
20249 A1E8 06A0  32        bl   @jsr                       ;
     A1EA FE28     
20250               
20251 A1EC 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print the name of the selected system
     A1EE AB54     
20252 A1F0 06A0  32        bl   @jsr                       ;
     A1F2 FE28     
20253               
20254                                                                          ; Fall through into wW to start the hyperspace countdown
20255               
20256               * ******************************************************************************
20257               *
20258               * Name: wW
20259               * Type: Subroutine
20260               * Category: Flight
20261               * Summary: Start a hyperspace countdown
20262               *
20263               * ------------------------------------------------------------------------------
20264               *
20265               * Start the hyperspace countdown (for both inter-system hyperspace and the
20266               * galactic hyperdrive).
20267               *
20268               * ******************************************************************************
20269               
20270               wW:
20271 A1F4 020D  20        li   ra,>0f*256                 ; LDA #15           ; The hyperspace countdown starts from 15, so set A to
     A1F6 0F00     
20272                                                                          ; 15 so we can set the two hyperspace counters
20273               
20274 A1F8 D80D  30        movb ra,@QQ22+1                 ; STA QQ22+1        ; Set the number in QQ22+1 to A, which is the number
     A1FA 002F     
20275                                                                          ; that's shown on-screen during the hyperspace countdown
20276               
20277 A1FC D80D  30        movb ra,@QQ22                   ; STA QQ22          ; Set the number in QQ22 to 15, which is the internal
     A1FE 002E     
20278                                                                          ; counter that counts down by 1 each iteration of the
20279                                                                          ; main game loop, and each time it reaches zero, the
20280                                                                          ; on-screen counter gets decremented, and QQ22 gets set
20281                                                                          ; to 5, so setting QQ22 to 15 here makes the first tick
20282                                                                          ; of the hyperspace counter longer than subsequent ticks
20283               
20284 A200 D38D  18        movb ra,rx                      ; TAX               ; Print the 8-bit number in X (i.e. 15) at text location
20285 A202 0460  28        b    @ee3_                      ; JMP ee3           ; (0, 1), padded to 5 digits, so it appears in the top
     A204 A292     
20286                                                                          ; left corner of the screen, and return from the
20287                                                                          ; subroutine using a tail call
20288               
20289               * .hy5                   \ This instruction and the hy5 label are commented out
20290               * RTS                    \ in the original - they can actually be found at the
20291                                                                          ; end of the jmp routine below, so perhaps this is where
20292                                                                          ; they were originally, but the authors realised they
20293                                                                          ; could save a byte by using a tail call instead of an
20294                                                                          ; RTS?
20295               
20296               * ******************************************************************************
20297               *
20298               * Name: Ghy
20299               * Type: Subroutine
20300               * Category: Flight
20301               * Summary: Perform a galactic hyperspace jump
20302               * Deep dive: Twisting the system seeds
20303               * Galaxy and system seeds
20304               *
20305               * ------------------------------------------------------------------------------
20306               *
20307               * Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
20308               * being pressed.
20309               *
20310               * This routine also updates the galaxy seeds to point to the next galaxy. Using
20311               * a galactic hyperdrive rotates each seed byte to the left, rolling each byte
20312               * left within itself like this:
20313               *
20314               * 01234567 -> 12345670
20315               *
20316               * to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
20317               * roll round to those of the first galaxy again.
20318               *
20319               * We always arrive in a new galaxy at galactic coordinates (96, 96), and then
20320               * find the nearest system and set that as our location.
20321               *
20322               * ------------------------------------------------------------------------------
20323               *
20324               * Other entry points:
20325               *
20326               * zZ+1                Contains an RTS
20327               *
20328               * ******************************************************************************
20329               
20330               Ghy:
20359               
20360 A206 D3A0  30        movb @GHYP,rx                   ; LDX GHYP          ; Fetch GHYP, which tells us whether we own a galactic
     A208 032D     
20361 A20A 1341  14        jeq  hy5_                       ; BEQ hy5           ; hyperdrive, and if it is zero, which means we don't,
20362                                                                          ; return from the subroutine (as hy5 contains an RTS)
20363               
20364 A20C B387  18        ab   rone,rx                    ; INX               ; We own a galactic hyperdrive, so X is &FF, so this
20365                                                                          ; instruction sets X = 0
20366               
20373               
20374 A20E D80E  30        movb rx,@GHYP                   ; STX GHYP          ; The galactic hyperdrive is a one-use item, so set GHYP
     A210 032D     
20375                                                                          ; to 0 so we no longer have one fitted
20376               
20377 A212 D80E  30        movb rx,@FIST                   ; STX FIST          ; Changing galaxy also clears our criminal record, so
     A214 0334     
20378                                                                          ; set our legal status in FIST to 0 ("clean")
20379               
20380 A216 0200  20        li   rtmp,wW                    ; JSR wW            ; Call wW to start the hyperspace countdown
     A218 A1F4     
20381 A21A 06A0  32        bl   @jsr                       ;
     A21C FE28     
20382               
20383 A21E 020E  20        li   rx,>05*256                 ; LDX #5            ; To move galaxy, we rotate the galaxy's seeds left, so
     A220 0500     
20384                                                                          ; set a counter in X for the 6 seed bytes
20385               
20386 A222 B347  18        ab   rone,ra                    ; INC GCNT          ; Increment the current galaxy number in GCNT
20387               
20388 A224 D360  30        movb @GCNT,ra                   ; LDA GCNT          ; Set GCNT = GCNT mod 8, so we jump from galaxy 7 back
     A226 030F     
20389 A228 024D  22        andi ra,>07*256                 ; AND #7            ; to galaxy 0 (shown in-game as going from galaxy 8 back
     A22A 0700     
20390 A22C D80D  30        movb ra,@GCNT                   ; STA GCNT          ; to the starting point in galaxy 1)
     A22E 030F     
20391               
20392               G1:
20393 A230 06CE  14        swpb rx                         ;
20394 A232 D36E  34        movb @QQ21(rx),ra               ; LDA QQ21,X        ; Load the X-th seed byte into A
     A234 0303     
20395 A236 06CE  14        swpb rx                         ;
20396               
20397                      .asla                           ; ASL A             ; Set the C flag to bit 7 of the seed
     **** ****     > ASLA
0001 A238 024D  22        andi ra,>ff00
     A23A FF00     
0002 A23C 0A1D  18        sla  ra,1
                   < elite.a99
20398               
20399 A23E 0204  20        li   rarg1,QQ21                 ; ROL QQ21,X        ; Rotate the seed in memory, which will add bit 7 back
     A240 0303     
20400 A242 06A0  32        bl   @rol                       ;
     A244 FE4E     
20401                                                                          ; in as bit 0, so this rolls the seed around on itself
20402               
20403 A246 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
20404               
20405 A248 15F3  14        jgt  G1                         ; BPL G1            ; Loop back for the next seed byte, until we have
20406                                                                          ; rotated them all
20407               
20408               * JSR DORND              \ This instruction is commented out in the original
20409                                                                          ; source, and would set A and X to random numbers, so
20410                                                                          ; perhaps the original plan was to arrive in each new
20411                                                                          ; galaxy in a random place?
20412               
20413               zZ_:
20414 A24A 020D  20        li   ra,>60*256                 ; LDA #96           ; Set (QQ9, QQ10) to (96, 96), which is where we always
     A24C 6000     
20415 A24E D80D  30        movb ra,@QQ9                    ; STA QQ9           ; arrive in a new galaxy (the selected system will be
     A250 0F31     
20416 A252 D80D  30        movb ra,@QQ10                   ; STA QQ10          ; set to the nearest actual system later on)
     A254 0F32     
20417               
20418 A256 0200  20        li   rtmp,TT110                 ; JSR TT110         ; Call TT110 to show the front space view
     A258 A682     
20419 A25A 06A0  32        bl   @jsr                       ;
     A25C FE28     
20420               
20422               
20423 A25E 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Call TT111 to set the current system to the nearest
     A260 A000     
20424 A262 06A0  32        bl   @jsr                       ;
     A264 FE28     
20425                                                                          ; system to (QQ9, QQ10), and put the seeds of the
20426                                                                          ; nearest system into QQ15 to QQ15+5
20427                                                                          ;
20428                                                                          ; This call fixes a bug in the early cassette versions,
20429                                                                          ; where the galactic hyperdrive will take us to
20430                                                                          ; coordinates (96, 96) in the new galaxy, even if there
20431                                                                          ; isn't actually a system there, so if we jump when we
20432                                                                          ; are low on fuel, it is possible to get stuck in the
20433                                                                          ; middle of nowhere when changing galaxy
20434                                                                          ;
20435                                                                          ; This call sets the current system correctly, so we
20436                                                                          ; always arrive at the nearest system to (96, 96)
20437               
20439               
20441               
20442 A266 020E  20        li   rx,>00*256                 ; LDX #0            ; Set the distance to the selected system in QQ8(1 0)
     A268 0000     
20443 A26A D80E  30        movb rx,@QQ8                    ; STX QQ8           ; to 0
     A26C 0F2F     
20444 A26E D80E  30        movb rx,@QQ8+1                  ; STX QQ8+1
     A270 0F30     
20445               
20447               
20448 A272 020D  20        li   ra,>74*256                 ; LDA #116          ; Print recursive token 116 ("GALACTIC HYPERSPACE")
     A274 7400     
20449 A276 0200  20        li   rtmp,MESS                  ; JSR MESS          ; as an in-flight message
     A278 D616     
20450 A27A 06A0  32        bl   @jsr                       ;
     A27C FE28     
20451               
20452                                                                          ; Fall through into jmp to set the system to the
20453                                                                          ; current system and return from the subroutine there
20454               
20455               * ******************************************************************************
20456               *
20457               * Name: jmp
20458               * Type: Subroutine
20459               * Category: Universe
20460               * Summary: Set the current system to the selected system
20461               *
20462               * ------------------------------------------------------------------------------
20463               *
20464               * Returns:
20465               *
20466               * (QQ0, QQ1)          The galactic coordinates of the new system
20467               *
20468               * ------------------------------------------------------------------------------
20469               *
20470               * Other entry points:
20471               *
20472               * hy5                 Contains an RTS
20473               *
20474               * ******************************************************************************
20475               
20476               jmp_:
20477 A27E D360  30        movb @QQ9,ra                    ; LDA QQ9           ; Set the current system's galactic x-coordinate to the
     A280 0F31     
20478 A282 D80D  30        movb ra,@QQ0                    ; STA QQ0           ; x-coordinate of the selected system
     A284 0301     
20479               
20480 A286 D360  30        movb @QQ10,ra                   ; LDA QQ10          ; Set the current system's galactic y-coordinate to the
     A288 0F32     
20481 A28A D80D  30        movb ra,@QQ1                    ; STA QQ1           ; y-coordinate of the selected system
     A28C 0302     
20482               
20483               hy5_:
20484 A28E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A290 FE34     
20485               
20486               * ******************************************************************************
20487               *
20488               * Name: ee3
20489               * Type: Subroutine
20490               * Category: Flight
20491               * Summary: Print the hyperspace countdown in the top-left of the screen
20492               *
20493               * ------------------------------------------------------------------------------
20494               *
20495               * Print the 8-bit number in X at text location (0, 1). Print the number to
20496               * 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
20497               * numbers < 10000 are right-aligned), with no decimal point.
20498               *
20499               * ------------------------------------------------------------------------------
20500               *
20501               * Arguments:
20502               *
20503               * X                   The number to print
20504               *
20505               * ******************************************************************************
20506               
20507               ee3_:
20508 A292 020F  20        li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
     A294 0100     
20509 A296 D80F  30        movb ry,@YC                     ; STY YC
     A298 002D     
20510               
20511 A29A 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0 for the high byte in pr6
20512               
20513 A29C D80F  30        movb ry,@XC                     ; STY XC            ; Move the text cursor to column 0
     A29E 002C     
20514               
20515                                                                          ; Fall through into pr6 to print X to 5 digits, as the
20516                                                                          ; high byte in Y is 0
20517               
20518               * ******************************************************************************
20519               *
20520               * Name: pr6
20521               * Type: Subroutine
20522               * Category: Text
20523               * Summary: Print 16-bit number, left-padded to 5 digits, no point
20524               *
20525               * ------------------------------------------------------------------------------
20526               *
20527               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20528               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
20529               * with no decimal point.
20530               *
20531               * ------------------------------------------------------------------------------
20532               *
20533               * Arguments:
20534               *
20535               * X                   The low byte of the number to print
20536               *
20537               * Y                   The high byte of the number to print
20538               *
20539               * ******************************************************************************
20540               
20541               pr6_:
20542                      .clc                            ; CLC               ; Do not display a decimal point when printing
     **** ****     > CLC
0001 A2A0 0A16  18        sla  rzero,1
                   < elite.a99
20543               
20544                                                                          ; Fall through into pr5 to print X to 5 digits
20545               
20546               * ******************************************************************************
20547               *
20548               * Name: pr5
20549               * Type: Subroutine
20550               * Category: Text
20551               * Summary: Print a 16-bit number, left-padded to 5 digits, and optional point
20552               *
20553               * ------------------------------------------------------------------------------
20554               *
20555               * Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
20556               * numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
20557               * Optionally include a decimal point.
20558               *
20559               * ------------------------------------------------------------------------------
20560               *
20561               * Arguments:
20562               *
20563               * X                   The low byte of the number to print
20564               *
20565               * Y                   The high byte of the number to print
20566               *
20567               * C flag              If set, include a decimal point
20568               *
20569               * ******************************************************************************
20570               
20571               pr5_:
20572 A2A2 020D  20        li   ra,>05*256                 ; LDA #5            ; Set the number of digits to print to 5
     A2A4 0500     
20573               
20574 A2A6 0460  28        b    @TT11                      ; JMP TT11          ; Call TT11 to print (Y X) to 5 digits and return from
     A2A8 3234     
20575                                                                          ; the subroutine using a tail call
20576               
20577               * ******************************************************************************
20578               *
20579               * Name: TT147
20580               * Type: Subroutine
20581               * Category: Flight
20582               * Summary: Print an error when a system is out of hyperspace range
20583               *
20584               * ------------------------------------------------------------------------------
20585               *
20586               * Print "RANGE?" for when the hyperspace distance is too far
20587               *
20588               * ******************************************************************************
20589               
20590               TT147:
20591 A2AA 020D  20        li   ra,>ca*256                 ; LDA #202          ; Load A with token 42 ("RANGE") and fall through into
     A2AC CA00     
20592                                                                          ; prq to print it, followed by a question mark
20593               
20594               * ******************************************************************************
20595               *
20596               * Name: prq
20597               * Type: Subroutine
20598               * Category: Text
20599               * Summary: Print a text token followed by a question mark
20600               *
20601               * ------------------------------------------------------------------------------
20602               *
20603               * Arguments:
20604               *
20605               * A                   The text token to be printed
20606               *
20607               * ------------------------------------------------------------------------------
20608               *
20609               * Other entry points:
20610               *
20611               * prq+3               Print a question mark
20612               *
20613               * ******************************************************************************
20614               
20615               prq_:
20616 A2AE 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     A2B0 ACA0     
20617 A2B2 06A0  32        bl   @jsr                       ;
     A2B4 FE28     
20618               
20619 A2B6 020D  20        li   ra,('?')*256               ; LDA #'?'          ; Print a question mark and return from the
     A2B8 3F00     
20620 A2BA 0460  28        b    @TT27                      ; JMP TT27          ; subroutine using a tail call
     A2BC ACA0     
20621               
20622               * ******************************************************************************
20623               *
20624               * Name: TT151
20625               * Type: Subroutine
20626               * Category: Market
20627               * Summary: Print the name, price and availability of a market item
20628               * Deep dive: Market item prices and availability
20629               * Galaxy and system seeds
20630               *
20631               * ------------------------------------------------------------------------------
20632               *
20633               * Arguments:
20634               *
20635               * A                   The number of the market item to print, 0-16 (see QQ23
20636               * for details of item numbers)
20637               *
20638               * ------------------------------------------------------------------------------
20639               *
20640               * Returns:
20641               *
20642               * QQ19+1              Byte #1 from the market prices table for this item
20643               *
20644               * QQ24                The item's price / 4
20645               *
20646               * QQ25                The item's availability
20647               *
20648               * ******************************************************************************
20649               
20650               TT151:
20651                      .pha                            ; PHA               ; Store the item number on the stack and in QQ19+4
     **** ****     > PHA
0001 A2BE D68D  30        movb ra,*rsp
0002 A2C0 060A  14        dec  rsp
                   < elite.a99
20652 A2C2 D80D  30        movb ra,@QQ19+4                 ; STA QQ19+4
     A2C4 0083     
20653               
20654                      .asla                           ; ASL A             ; Store the item number * 4 in QQ19, so this will act as
     **** ****     > ASLA
0001 A2C6 024D  22        andi ra,>ff00
     A2C8 FF00     
0002 A2CA 0A1D  18        sla  ra,1
                   < elite.a99
20655                      .asla                           ; ASL A             ; an index into the market prices table at QQ23 for this
     **** ****     > ASLA
0001 A2CC 024D  22        andi ra,>ff00
     A2CE FF00     
0002 A2D0 0A1D  18        sla  ra,1
                   < elite.a99
20656 A2D2 D80D  30        movb ra,@QQ19                   ; STA QQ19          ; item (as there are four bytes per item in the table)
     A2D4 007F     
20657               
20658 A2D6 020D  20        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1, for the item's name
     A2D8 0100     
20659 A2DA D80D  30        movb ra,@XC                     ; STA XC
     A2DC 002C     
20660               
20661                      .pla                            ; PLA               ; Restore the item number
     **** ****     > PLA
0001 A2DE 058A  14        inc  rsp
0002 A2E0 D35A  26        movb *rsp,ra
                   < elite.a99
20662               
20663                      .adi (>d0*256)                  ; ADC #208          ; Print recursive token 48 + A, which will be in the
     **** ****     > ADI
0001 A2E2 1701  14        jnc  !
0002 A2E4 B347  18        ab   rone,ra
0003               !:
0004 A2E6 022D  22        ai   ra,(>D0*256)
     A2E8 D000     
                   < elite.a99
20664 A2EA 0200  20        li   rtmp,TT27                  ; JSR TT27          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
     A2EC ACA0     
20665 A2EE 06A0  32        bl   @jsr                       ;
     A2F0 FE28     
20666                                                                          ; prints the item's name
20667               
20668 A2F2 020D  20        li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the price
     A2F4 0E00     
20669 A2F6 D80D  30        movb ra,@XC                     ; STA XC
     A2F8 002C     
20670               
20671 A2FA D3A0  30        movb @QQ19,rx                   ; LDX QQ19          ; Fetch byte #1 from the market prices table (units and
     A2FC 007F     
20672 A2FE 06CE  14        swpb rx                         ;
20673 A300 D36E  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; economic_factor) for this item and store in QQ19+1
     A302 D6EF     
20674 A304 06CE  14        swpb rx                         ;
20675 A306 D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1
     A308 0080     
20676               
20677 A30A D360  30        movb @QQ26,ra                   ; LDA QQ26          ; Fetch the random number for this system visit and
     A30C 0346     
20678 A30E 06CE  14        swpb rx                         ;
20679                      .and @QQ23+3(rx)                ; AND QQ23+3,X      ; AND with byte #3 from the market prices table (mask)
     **** ****     > AND
0001 A310 D02E  34        movb @QQ23+3(RX),rtmp
     A312 D6F1     
0002 A314 0540  14        inv  rtmp
0003 A316 5340  18        szcb rtmp,ra
                   < elite.a99
20680 A318 06CE  14        swpb rx                         ;
20681                                                                          ; to give:
20682                                                                          ;
20683                                                                          ; A = random AND mask
20684               
20685                      .clc                            ; CLC               ; Add byte #0 from the market prices table (base_price),
     **** ****     > CLC
0001 A31A 0A16  18        sla  rzero,1
                   < elite.a99
20686 A31C 06CE  14        swpb rx                         ;
20687                      .adc @QQ23(rx),ra               ; ADC QQ23,X        ; so we now have:
     **** ****     > ADC
0001 A31E 1701  14        jnc  !
0002 A320 B347  18        ab   rone,ra
0003               !:
0004 A322 B36E  34        ab   @QQ23(RX),ra
     A324 D6EE     
                   < elite.a99
20688 A326 06CE  14        swpb rx                         ;
20689 A328 D80D  30        movb ra,@QQ24                   ; STA QQ24          ;
     A32A 0F18     
20690                                                                          ; A = base_price + (random AND mask)
20691               
20692 A32C 0200  20        li   rtmp,TT152                 ; JSR TT152         ; Call TT152 to print the item's unit ("t", "kg" or
     A32E A3B8     
20693 A330 06A0  32        bl   @jsr                       ;
     A332 FE28     
20694                                                                          ; "g"), padded to a width of two characters
20695               
20696 A334 0200  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     A336 A462     
20697 A338 06A0  32        bl   @jsr                       ;
     A33A FE28     
20698                                                                          ; (and set the availability of alien items to 0)
20699               
20700 A33C D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     A33E 0080     
20701 A340 1108  14        jlt  TT155                      ; BMI TT155         ; TT155 if it is negative (i.e. if the economic_factor
20702                                                                          ; is negative)
20703               
20704 A342 D360  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 + QQ19+3
     A344 0F18     
20705                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 A346 1701  14        jnc  !
0002 A348 B347  18        ab   rone,ra
0003               !:
0004 A34A B360  30        ab   @QQ19+3,ra
     A34C 0082     
                   < elite.a99
20706                                                                          ; = base_price + (random AND mask)
20707                                                                          ; + (economy * |economic_factor|)
20708                                                                          ;
20709                                                                          ; which is the result we want, as the economic_factor
20710                                                                          ; is positive
20711               
20712 A34E 0460  28        b    @TT156                     ; JMP TT156         ; Jump to TT156 to multiply the result by 4
     A350 A360     
20713               
20714               TT155:
20715 A352 D360  30        movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 - QQ19+3
     A354 0F18     
20716                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 A356 0A18  18        sla  rmone,1
                   < elite.a99
20717                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ; = base_price + (random AND mask)
     **** ****     > SBC
0001 A358 1801  14        joc  !
0002 A35A 7347  18        sb   rone,ra
0003               !:
0004 A35C 7360  30        sb   @QQ19+3,ra
     A35E 0082     
                   < elite.a99
20718                                                                          ; - (economy * |economic_factor|)
20719                                                                          ;
20720                                                                          ; which is the result we want, as economic_factor
20721                                                                          ; is negative
20722               
20723               TT156:
20724 A360 D80D  30        movb ra,@QQ24                   ; STA QQ24          ; Store the result in QQ24 and P
     A362 0F18     
20725 A364 D80D  30        movb ra,@P                      ; STA P
     A366 001B     
20726               
20727 A368 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
     A36A 0000     
20728 A36C 0200  20        li   rtmp,GC2                   ; JSR GC2           ; which is the same as (Y X) = P * 4 because A = 0
     A36E A782     
20729 A370 06A0  32        bl   @jsr                       ;
     A372 FE28     
20730               
20731                      .sec                            ; SEC               ; We now have our final price, * 10, so we can call pr5
     **** ****     > SEC
0001 A374 0A18  18        sla  rmone,1
                   < elite.a99
20732 A376 0200  20        li   rtmp,pr5_                  ; JSR pr5           ; to print (Y X) to 5 digits, including a decimal
     A378 A2A2     
20733 A37A 06A0  32        bl   @jsr                       ;
     A37C FE28     
20734                                                                          ; point, as the C flag is set
20735               
20736 A37E D3E0  30        movb @QQ19+4,ry                 ; LDY QQ19+4        ; We now move on to availability, so fetch the market
     A380 0083     
20737                                                                          ; item number that we stored in QQ19+4 at the start
20738               
20739 A382 020D  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 so we can print the availability to 5
     A384 0500     
20740                                                                          ; digits (right-padded with spaces)
20741               
20742 A386 06CF  14        swpb ry                         ;
20743 A388 D3AF  34        movb @AVL(ry),rx                ; LDX AVL,Y         ; Set X to the item's availability, which is given in
     A38A 0335     
20744 A38C 06CF  14        swpb ry                         ;
20745                                                                          ; the AVL table
20746               
20747 A38E D80E  30        movb rx,@QQ25                   ; STX QQ25          ; Store the availability in QQ25
     A390 0F19     
20748               
20749                      .clc                            ; CLC               ; Clear the C flag
     **** ****     > CLC
0001 A392 0A16  18        sla  rzero,1
                   < elite.a99
20750               
20751 A394 1306  14        jeq  TT172                      ; BEQ TT172         ; If none are available, jump to TT172 to print a tab
20752                                                                          ; and a "-"
20753               
20754 A396 0200  20        li   rtmp,pr2_+2                ; JSR pr2+2         ; Otherwise print the 8-bit number in X to 5 digits,
     A398 322E     
20755 A39A 06A0  32        bl   @jsr                       ;
     A39C FE28     
20756                                                                          ; right-aligned with spaces. This works because we set
20757                                                                          ; A to 5 above, and we jump into the pr2 routine just
20758                                                                          ; after the first instruction, which would normally
20759                                                                          ; set the number of digits to 3
20760               
20761 A39E 0460  28        b    @TT152                     ; JMP TT152         ; Print the unit ("t", "kg" or "g") for the market item,
     A3A0 A3B8     
20762                                                                          ; with a following space if required to make it two
20763                                                                          ; characters long, and return from the subroutine using
20764                                                                          ; a tail call
20765               
20766               TT172:
20767 A3A2 D360  30        movb @XC,ra                     ; LDA XC            ; Move the text cursor in XC to the right by 4 columns,
     A3A4 002C     
20768                      .adi (>04*256)                  ; ADC #4            ; so the cursor is where the last digit would be if we
     **** ****     > ADI
0001 A3A6 1701  14        jnc  !
0002 A3A8 B347  18        ab   rone,ra
0003               !:
0004 A3AA 022D  22        ai   ra,(>04*256)
     A3AC 0400     
                   < elite.a99
20769 A3AE D80D  30        movb ra,@XC                     ; STA XC            ; were printing a 5-digit availability number
     A3B0 002C     
20770               
20771 A3B2 020D  20        li   ra,('-')*256               ; LDA #'-'          ; Print a "-" character by jumping to TT162+2, which
     A3B4 2D00     
20772 A3B6 160D  14        jne  TT162+2                    ; BNE TT162+2       ; contains JMP TT27 (this BNE is effectively a JMP as A
20773                                                                          ; will never be zero), and return from the subroutine
20774                                                                          ; using a tail call
20775               
20776               * ******************************************************************************
20777               *
20778               * Name: TT152
20779               * Type: Subroutine
20780               * Category: Market
20781               * Summary: Print the unit ("t", "kg" or "g") for a market item
20782               *
20783               * ------------------------------------------------------------------------------
20784               *
20785               * Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
20786               * market prices table is in QQ19+1, right-padded with spaces to a width of two
20787               * characters (so that's "t ", "kg" or "g ").
20788               *
20789               * ******************************************************************************
20790               
20791               TT152:
20792 A3B8 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the economic_factor from QQ19+1
     A3BA 0080     
20793               
20794 A3BC 024D  22        andi ra,>60*256                 ; AND #96           ; If bits 5 and 6 are both clear, jump to TT160 to
     A3BE 6000     
20795 A3C0 130B  14        jeq  TT160                      ; BEQ TT160         ; print "t" for tonne, followed by a space, and return
20796                                                                          ; from the subroutine using a tail call
20797               
20798 A3C2 028D  22        ci   ra,>20*256                 ; CMP #32           ; If bit 5 is set, jump to TT161 to print "kg" for
     A3C4 2000     
20799 A3C6 130F  14        jeq  TT161                      ; BEQ TT161         ; kilograms, and return from the subroutine using a tail
20800                                                                          ; call
20801               
20802 A3C8 0200  20        li   rtmp,TT16a                 ; JSR TT16a         ; Otherwise call TT16a to print "g" for grams, and fall
     A3CA A3F2     
20803 A3CC 06A0  32        bl   @jsr                       ;
     A3CE FE28     
20804                                                                          ; through into TT162 to print a space and return from
20805                                                                          ; the subroutine
20806               
20807               * ******************************************************************************
20808               *
20809               * Name: TT162
20810               * Type: Subroutine
20811               * Category: Text
20812               * Summary: Print a space
20813               *
20814               * ------------------------------------------------------------------------------
20815               *
20816               * Other entry points:
20817               *
20818               * TT162+2             Jump to TT27 to print the text token in A
20819               *
20820               * ******************************************************************************
20821               
20822               TT162:
20823 A3D0 020D  20        li   ra,(' ')*256               ; LDA #' '          ; Load a space character into A
     A3D2 2000     
20824               
20825 A3D4 0460  28        b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
     A3D6 ACA0     
20826                                                                          ; subroutine using a tail call
20827               
20828               * ******************************************************************************
20829               *
20830               * Name: TT160
20831               * Type: Subroutine
20832               * Category: Market
20833               * Summary: Print "t" (for tonne) and a space
20834               *
20835               * ******************************************************************************
20836               
20837               TT160:
20838 A3D8 020D  20        li   ra,('t')*256               ; LDA #'t'          ; Load a "t" character into A
     A3DA 7400     
20839               
20840 A3DC 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     A3DE 341A     
20841 A3E0 06A0  32        bl   @jsr                       ;
     A3E2 FE28     
20842                                                                          ; change the character case
20843               
20844 A3E4 17F5  14        jnc  TT162                      ; BCC TT162         ; Jump to TT162 to print a space and return from the
20845                                                                          ; subroutine using a tail call (this BCC is effectively
20846                                                                          ; a JMP as the C flag is cleared by TT26)
20847               
20848               * ******************************************************************************
20849               *
20850               * Name: TT161
20851               * Type: Subroutine
20852               * Category: Market
20853               * Summary: Print "kg" (for kilograms)
20854               *
20855               * ******************************************************************************
20856               
20857               TT161:
20858 A3E6 020D  20        li   ra,('k')*256               ; LDA #'k'          ; Load a "k" character into A
     A3E8 6B00     
20859               
20860 A3EA 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character, using TT216 so that it doesn't
     A3EC 341A     
20861 A3EE 06A0  32        bl   @jsr                       ;
     A3F0 FE28     
20862                                                                          ; change the character case, and fall through into
20863                                                                          ; TT16a to print a "g" character
20864               
20865               * ******************************************************************************
20866               *
20867               * Name: TT16a
20868               * Type: Subroutine
20869               * Category: Market
20870               * Summary: Print "g" (for grams)
20871               *
20872               * ******************************************************************************
20873               
20874               TT16a:
20875 A3F2 020D  20        li   ra,('g')*256               ; LDA #'g'          ; Load a "g" character into A
     A3F4 6700     
20876               
20877 A3F6 0460  28        b    @TT26                      ; JMP TT26          ; Print the character, using TT216 so that it doesn't
     A3F8 341A     
20878                                                                          ; change the character case, and return from the
20879                                                                          ; subroutine using a tail call
20880               
20881               * ******************************************************************************
20882               *
20883               * Name: TT163
20884               * Type: Subroutine
20885               * Category: Market
20886               * Summary: Print the headers for the table of market prices
20887               *
20888               * ------------------------------------------------------------------------------
20889               *
20890               * Print the column headers for the prices table in the Buy Cargo and Market
20891               * Price screens.
20892               *
20893               * ******************************************************************************
20894               
20895               TT163:
20896 A3FA 020D  20        li   ra,>11*256                 ; LDA #17           ; Move the text cursor in XC to column 17
     A3FC 1100     
20897 A3FE D80D  30        movb ra,@XC                     ; STA XC
     A400 002C     
20898               
20899 A402 020D  20        li   ra,>ff*256                 ; LDA #255          ; Print recursive token 95 token ("UNIT  QUANTITY
     A404 FF00     
20900 A406 16E5  14        jne  TT162+2                    ; BNE TT162+2       ; {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
20901                                                                          ; jumping to TT162+2, which contains JMP TT27 (this BNE
20902                                                                          ; is effectively a JMP as A will never be zero), and
20903                                                                          ; return from the subroutine using a tail call
20904               
20905               * ******************************************************************************
20906               *
20907               * Name: TT167
20908               * Type: Subroutine
20909               * Category: Market
20910               * Summary: Show the Market Price screen (red key f7)
20911               *
20912               * ******************************************************************************
20913               
20914               TT167:
20915 A408 020D  20        li   ra,>10*256                 ; LDA #16           ; Clear the top part of the screen, draw a white border,
     A40A 1000     
20916 A40C 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 16 (Market
     A40E 4EFA     
20917 A410 06A0  32        bl   @jsr                       ;
     A412 FE28     
20918                                                                          ; Price screen)
20919               
20920 A414 020D  20        li   ra,>05*256                 ; LDA #5            ; Move the text cursor to column 5
     A416 0500     
20921 A418 D80D  30        movb ra,@XC                     ; STA XC
     A41A 002C     
20922               
20923 A41C 020D  20        li   ra,>a7*256                 ; LDA #167          ; Print recursive token 7 ("{current system name} MARKET
     A41E A700     
20924 A420 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; PRICES") and draw a horizontal line at pixel row 19
     A422 2738     
20925 A424 06A0  32        bl   @jsr                       ;
     A426 FE28     
20926                                                                          ; to box in the title
20927               
20928 A428 020D  20        li   ra,>03*256                 ; LDA #3            ; Move the text cursor to row 3
     A42A 0300     
20929 A42C D80D  30        movb ra,@YC                     ; STA YC
     A42E 002D     
20930               
20931 A430 0200  20        li   rtmp,TT163                 ; JSR TT163         ; Print the column headers for the prices table
     A432 A3FA     
20932 A434 06A0  32        bl   @jsr                       ;
     A436 FE28     
20933               
20934 A438 020D  20        li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
     A43A 0000     
20935 A43C D80D  30        movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
     A43E 0F1B     
20936                                                                          ; current item and start it at 0
20937               
20938               TT168:
20939 A440 020E  20        li   rx,>80*256                 ; LDX #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     A442 8000     
20940 A444 D80E  30        movb rx,@QQ17                   ; STX QQ17          ; next letter in capitals
     A446 007E     
20941               
20942 A448 0200  20        li   rtmp,TT151                 ; JSR TT151         ; Call TT151 to print the item name, market price and
     A44A A2BE     
20943 A44C 06A0  32        bl   @jsr                       ;
     A44E FE28     
20944                                                                          ; availability of the current item, and set QQ24 to the
20945                                                                          ; item's price / 4, QQ25 to the quantity available and
20946                                                                          ; QQ19+1 to byte #1 from the market prices table for
20947                                                                          ; this item
20948               
20949 A450 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one row
20950               
20951 A452 B347  18        ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item
20952               
20953 A454 D360  30        movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to TT168 as we have done the
     A456 0F1B     
20954 A458 028D  22        ci   ra,>11*256                 ; CMP #17           ; last item
     A45A 1100     
20955 A45C 17F1  14        jnc  TT168                      ; BCC TT168
20956               
20957 A45E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A460 FE34     
20958               
20959               * ******************************************************************************
20960               *
20961               * Name: var
20962               * Type: Subroutine
20963               * Category: Market
20964               * Summary: Calculate QQ19+3 = economy * |economic_factor|
20965               *
20966               * ------------------------------------------------------------------------------
20967               *
20968               * Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
20969               * table for an item. Also sets the availability of alien items to 0.
20970               *
20971               * This routine forms part of the calculations for market item prices (TT151)
20972               * and availability (GVL).
20973               *
20974               * ------------------------------------------------------------------------------
20975               *
20976               * Arguments:
20977               *
20978               * QQ19+1              Byte #1 of the market prices table for this market item
20979               * (which contains the economic_factor in bits 0-5, and the
20980               * sign of the economic_factor in bit 7)
20981               *
20982               * ******************************************************************************
20983               
20984               var_:
20985 A462 D360  30        movb @QQ19+1,ra                 ; LDA QQ19+1        ; Extract bits 0-5 from QQ19+1 into A, to get the
     A464 0080     
20986 A466 024D  22        andi ra,>1f*256                 ; AND #31           ; economic_factor without its sign, in other words:
     A468 1F00     
20987                                                                          ;
20988                                                                          ; A = |economic_factor|
20989               
20990 A46A D3E0  30        movb @QQ28,ry                   ; LDY QQ28          ; Set Y to the economy byte of the current system
     A46C 0F1A     
20991               
20992 A46E D80D  30        movb ra,@QQ19+2                 ; STA QQ19+2        ; Store A in QQ19+2
     A470 0081     
20993               
20994                      .clc                            ; CLC               ; Clear the C flag so we can do additions below
     **** ****     > CLC
0001 A472 0A16  18        sla  rzero,1
                   < elite.a99
20995               
20996 A474 020D  20        li   ra,>00*256                 ; LDA #0            ; Set AVL+16 (availability of alien items) to 0,
     A476 0000     
20997 A478 D80D  30        movb ra,@AVL+16                 ; STA AVL+16        ; setting A to 0 in the process
     A47A 0345     
20998               
20999               TT153:
21000                                                                          ; We now do the multiplication by doing a series of
21001                                                                          ; additions in a loop, building the result in A. Each
21002                                                                          ; loop adds QQ19+2 (|economic_factor|) to A, and it
21003                                                                          ; loops the number of times given by the economy byte;
21004                                                                          ; in other words, because A starts at 0, this sets:
21005                                                                          ;
21006                                                                          ; A = economy * |economic_factor|
21007 A47C 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the economy in Y, exiting the loop when it
21008 A47E 1106  14        jlt  TT154                      ; BMI TT154         ; becomes negative
21009               
21010                      .adc @QQ19+2,ra                 ; ADC QQ19+2        ; Add QQ19+2 to A
     **** ****     > ADC
0001 A480 1701  14        jnc  !
0002 A482 B347  18        ab   rone,ra
0003               !:
0004 A484 B360  30        ab   @QQ19+2,ra
     A486 0081     
                   < elite.a99
21011               
21012 A488 0460  28        b    @TT153                     ; JMP TT153         ; Loop back to TT153 to do another addition
     A48A A47C     
21013               
21014               TT154:
21015 A48C D80D  30        movb ra,@QQ19+3                 ; STA QQ19+3        ; Store the result in QQ19+3
     A48E 0082     
21016               
21017 A490 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A492 FE34     
21018               
21019               * ******************************************************************************
21020               *
21021               * Name: hyp1
21022               * Type: Subroutine
21023               * Category: Universe
21024               * Summary: Process a jump to the system closest to (QQ9, QQ10)
21025               *
21026               * ------------------------------------------------------------------------------
21027               *
21028               * Do a hyperspace jump to the system closest to galactic coordinates
21029               * (QQ9, QQ10), and set up the current system's state to those of the new system.
21030               *
21031               * ------------------------------------------------------------------------------
21032               *
21033               * Returns:
21034               *
21035               * (QQ0, QQ1)          The galactic coordinates of the new system
21036               *
21037               * QQ2 to QQ2+6        The seeds of the new system
21038               *
21039               * EV                  Set to 0
21040               *
21041               * QQ28                The new system's economy
21042               *
21043               * tek                 The new system's tech level
21044               *
21045               * gov                 The new system's government
21046               *
21047               * ------------------------------------------------------------------------------
21048               *
21049               * Other entry points:
21050               *
21051               * hyp1+3              Jump straight to the system at (QQ9, QQ10) without
21052               * first calculating which system is closest. We do this
21053               * if we already know that (QQ9, QQ10) points to a system
21054               *
21055               * ******************************************************************************
21056               
21057               hyp1_:
21058 A494 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     A496 A000     
21059 A498 06A0  32        bl   @jsr                       ;
     A49A FE28     
21060                                                                          ; (QQ9, QQ10)
21061               
21062 A49C 0200  20        li   rtmp,jmp_                  ; JSR jmp           ; Set the current system to the selected system
     A49E A27E     
21063 A4A0 06A0  32        bl   @jsr                       ;
     A4A2 FE28     
21064               
21065 A4A4 020E  20        li   rx,>05*256                 ; LDX #5            ; We now want to copy the seeds for the selected system
     A4A6 0500     
21066                                                                          ; in QQ15 into QQ2, where we store the seeds for the
21067                                                                          ; current system, so set up a counter in X for copying
21068                                                                          ; 6 bytes (for three 16-bit seeds)
21069               
21070               TT112:
21071 A4A8 06CE  14        swpb rx                         ;
21072 A4AA D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ2, to
     A4AC 0078     
21073 A4AE 06CE  14        swpb rx                         ;
21074 A4B0 06CE  14        swpb rx                         ;
21075 A4B2 DB8D  38        movb ra,@QQ2(rx)                ; STA QQ2,X         ; update the selected system to the new one. Note that
     A4B4 0F22     
21076 A4B6 06CE  14        swpb rx                         ;
21077                                                                          ; this approach has a minor bug associated with it: if
21078                                                                          ; your hyperspace counter hits 0 just as you're docking,
21079                                                                          ; then you will magically appear in the station in your
21080                                                                          ; hyperspace destination, without having to go to the
21081                                                                          ; effort of actually flying there. This bug was fixed in
21082                                                                          ; later versions by saving the destination seeds in a
21083                                                                          ; separate location called safehouse, and using those
21084                                                                          ; instead... but that isn't the case in this version
21085               
21086 A4B8 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
21087               
21088 A4BA 15F6  14        jgt  TT112                      ; BPL TT112         ; Loop back to TT112 if we still have more bytes to
21089                                                                          ; copy
21090               
21091 A4BC B387  18        ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X = &FF)
21092               
21093 A4BE D80E  30        movb rx,@EV                     ; STX EV            ; Set EV, the extra vessels spawning counter, to 0, as
     A4C0 0D63     
21094                                                                          ; we are entering a new system with no extra vessels
21095                                                                          ; spawned
21096               
21097 A4C2 D360  30        movb @QQ3,ra                    ; LDA QQ3           ; Set the current system's economy in QQ28 to the
     A4C4 0F28     
21098 A4C6 D80D  30        movb ra,@QQ28                   ; STA QQ28          ; selected system's economy from QQ3
     A4C8 0F1A     
21099               
21100 A4CA D360  30        movb @QQ5,ra                    ; LDA QQ5           ; Set the current system's tech level in tek to the
     A4CC 0F2A     
21101 A4CE D80D  30        movb ra,@tek_                   ; STA tek           ; selected system's economy from QQ5
     A4D0 0F1D     
21102               
21103 A4D2 D360  30        movb @QQ4,ra                    ; LDA QQ4           ; Set the current system's government in gov to the
     A4D4 0F29     
21104 A4D6 D80D  30        movb ra,@gov_                   ; STA gov           ; selected system's government from QQ4
     A4D8 0F1C     
21105               
21106 A4DA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A4DC FE34     
21107               
21108               * ******************************************************************************
21109               *
21110               * Name: GVL
21111               * Type: Subroutine
21112               * Category: Universe
21113               * Summary: Calculate the availability of market items
21114               * Deep dive: Market item prices and availability
21115               * Galaxy and system seeds
21116               *
21117               * ------------------------------------------------------------------------------
21118               *
21119               * Calculate the availability for each market item and store it in AVL. This is
21120               * called on arrival in a new system.
21121               *
21122               * ------------------------------------------------------------------------------
21123               *
21124               * Other entry points:
21125               *
21126               * hyR                 Contains an RTS
21127               *
21128               * ******************************************************************************
21129               
21130               GVL:
21131 A4DE 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     A4E0 C7D0     
21132 A4E2 06A0  32        bl   @jsr                       ;
     A4E4 FE28     
21133               
21134 A4E6 D80D  30        movb ra,@QQ26                   ; STA QQ26          ; Set QQ26 to the random byte that's used in the market
     A4E8 0346     
21135                                                                          ; calculations
21136               
21137 A4EA 020E  20        li   rx,>00*256                 ; LDX #0            ; We are now going to loop through the market item
     A4EC 0000     
21138 A4EE D80E  30        movb rx,@XX4                    ; STX XX4           ; availability table in AVL, so set a counter in XX4
     A4F0 00A7     
21139                                                                          ; (and X) for the market item number, starting with 0
21140               
21141               hy9_:
21142 A4F2 06CE  14        swpb rx                         ;
21143 A4F4 D36E  34        movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; Fetch byte #1 from the market prices table (units and
     A4F6 D6EF     
21144 A4F8 06CE  14        swpb rx                         ;
21145 A4FA D80D  30        movb ra,@QQ19+1                 ; STA QQ19+1        ; economic_factor) for item number X and store it in
     A4FC 0080     
21146                                                                          ; QQ19+1
21147               
21148 A4FE 0200  20        li   rtmp,var_                  ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
     A500 A462     
21149 A502 06A0  32        bl   @jsr                       ;
     A504 FE28     
21150                                                                          ; (and set the availability of alien items to 0)
21151               
21152 A506 06CE  14        swpb rx                         ;
21153 A508 D36E  34        movb @QQ23+3(rx),ra             ; LDA QQ23+3,X      ; Fetch byte #3 from the market prices table (mask) and
     A50A D6F1     
21154 A50C 06CE  14        swpb rx                         ;
21155                      .and @QQ26                      ; AND QQ26          ; AND with the random number for this system visit
     **** ****     > AND
0001 A50E D020  30        movb @QQ26,rtmp
     A510 0346     
0002 A512 0540  14        inv  rtmp
0003 A514 5340  18        szcb rtmp,ra
                   < elite.a99
21156                                                                          ; to give:
21157                                                                          ;
21158                                                                          ; A = random AND mask
21159               
21160                      .clc                            ; CLC               ; Add byte #2 from the market prices table
     **** ****     > CLC
0001 A516 0A16  18        sla  rzero,1
                   < elite.a99
21161 A518 06CE  14        swpb rx                         ;
21162                      .adc @QQ23+2(rx),ra             ; ADC QQ23+2,X      ; (base_quantity) so we now have:
     **** ****     > ADC
0001 A51A 1701  14        jnc  !
0002 A51C B347  18        ab   rone,ra
0003               !:
0004 A51E B36E  34        ab   @QQ23+2(RX),ra
     A520 D6F0     
                   < elite.a99
21163 A522 06CE  14        swpb rx                         ;
21164                                                                          ;
21165                                                                          ; A = base_quantity + (random AND mask)
21166               
21167 A524 D3E0  30        movb @QQ19+1,ry                 ; LDY QQ19+1        ; Fetch the byte #1 that we stored above and jump to
     A526 0080     
21168 A528 1107  14        jlt  TT157                      ; BMI TT157         ; TT157 if it is negative (i.e. if the economic_factor
21169                                                                          ; is negative)
21170               
21171                      .sec                            ; SEC               ; Set A = A - QQ19+3
     **** ****     > SEC
0001 A52A 0A18  18        sla  rmone,1
                   < elite.a99
21172                      .sbc @QQ19+3,ra                 ; SBC QQ19+3        ;
     **** ****     > SBC
0001 A52C 1801  14        joc  !
0002 A52E 7347  18        sb   rone,ra
0003               !:
0004 A530 7360  30        sb   @QQ19+3,ra
     A532 0082     
                   < elite.a99
21173                                                                          ; = base_quantity + (random AND mask)
21174                                                                          ; - (economy * |economic_factor|)
21175                                                                          ;
21176                                                                          ; which is the result we want, as the economic_factor
21177                                                                          ; is positive
21178               
21179 A534 0460  28        b    @TT158                     ; JMP TT158         ; Jump to TT158 to skip TT157
     A536 A542     
21180               
21181               TT157:
21182                      .clc                            ; CLC               ; Set A = A + QQ19+3
     **** ****     > CLC
0001 A538 0A16  18        sla  rzero,1
                   < elite.a99
21183                      .adc @QQ19+3,ra                 ; ADC QQ19+3        ;
     **** ****     > ADC
0001 A53A 1701  14        jnc  !
0002 A53C B347  18        ab   rone,ra
0003               !:
0004 A53E B360  30        ab   @QQ19+3,ra
     A540 0082     
                   < elite.a99
21184                                                                          ; = base_quantity + (random AND mask)
21185                                                                          ; + (economy * |economic_factor|)
21186                                                                          ;
21187                                                                          ; which is the result we want, as the economic_factor
21188                                                                          ; is negative
21189               
21190               TT158:
21191 A542 1502  14        jgt  TT159                      ; BPL TT159         ; If A < 0, then set A = 0, so we don't have negative
21192 A544 020D  20        li   ra,>00*256                 ; LDA #0            ; availability
     A546 0000     
21193               
21194               TT159:
21195 A548 D3E0  30        movb @XX4,ry                    ; LDY XX4           ; Fetch the counter (the market item number) into Y
     A54A 00A7     
21196               
21197 A54C 024D  22        andi ra,>3f*256                 ; AND #%00111111    ; Take bits 0-5 of A, i.e. A mod 64, and store this as
     A54E 3F00     
21198 A550 06CF  14        swpb ry                         ;
21199 A552 DBCD  38        movb ra,@AVL(ry)                ; STA AVL,Y         ; this item's availability in the Y=th byte of AVL, so
     A554 0335     
21200 A556 06CF  14        swpb ry                         ;
21201                                                                          ; each item has a maximum availability of 63t
21202               
21203 A558 B3C7  18        ab   rone,ry                    ; INY               ; Increment the counter into XX44, Y and A
21204 A55A D34F  18        movb ry,ra                      ; TYA
21205 A55C D80D  30        movb ra,@XX4                    ; STA XX4
     A55E 00A7     
21206               
21207                      .asla                           ; ASL A             ; Set X = counter * 4, so that X points to the next
     **** ****     > ASLA
0001 A560 024D  22        andi ra,>ff00
     A562 FF00     
0002 A564 0A1D  18        sla  ra,1
                   < elite.a99
21208                      .asla                           ; ASL A             ; item's entry in the four-byte market prices table,
     **** ****     > ASLA
0001 A566 024D  22        andi ra,>ff00
     A568 FF00     
0002 A56A 0A1D  18        sla  ra,1
                   < elite.a99
21209 A56C D38D  18        movb ra,rx                      ; TAX               ; ready for the next loop
21210               
21211 A56E 028D  22        ci   ra,>3f*256                 ; CMP #63           ; If A < 63, jump back up to hy9 to set the availability
     A570 3F00     
21212 A572 17BF  14        jnc  hy9_                       ; BCC hy9           ; for the next market item
21213               
21214               hyR:
21215 A574 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A576 FE34     
21216               
21217               * ******************************************************************************
21218               *
21219               * Name: GTHG
21220               * Type: Subroutine
21221               * Category: Universe
21222               * Summary: Spawn a Thargoid ship and a Thargon companion
21223               * Deep dive: Fixing ship positions
21224               *
21225               * ******************************************************************************
21226               
21227               GTHG:
21228 A578 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK
     A57A C786     
21229 A57C 06A0  32        bl   @jsr                       ;
     A57E FE28     
21230                                                                          ;
21231                                                                          ; Note that because Ze uses the value of X returned by
21232                                                                          ; DORND, and X contains the value of A returned by the
21233                                                                          ; previous call to DORND, this does not set the new ship
21234                                                                          ; to a totally random location. See the deep dive on
21235                                                                          ; "Fixing ship positions" for details
21236               
21237 A580 020D  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set the AI flag in byte #32 so that the ship has AI,
     A582 FF00     
21238 A584 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; is extremely and aggressively hostile, and has E.C.M.
     A586 0073     
21239               
21240 A588 020D  20        li   ra,(THG)*256               ; LDA #THG          ; Call NWSHP to add a new Thargoid ship to our local
     A58A 0600     
21241 A58C 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; bubble of universe
     A58E B5DA     
21242 A590 06A0  32        bl   @jsr                       ;
     A592 FE28     
21243               
21244 A594 020D  20        li   ra,(TGL)*256               ; LDA #TGL          ; Call NWSHP to add a new Thargon ship to our local
     A596 0C00     
21245 A598 0460  28        b    @NWSHP                     ; JMP NWSHP         ; bubble of universe, and return from the subroutine
     A59A B5DA     
21246                                                                          ; using a tail call
21247               
21248               * ******************************************************************************
21249               *
21250               * Name: MJP
21251               * Type: Subroutine
21252               * Category: Flight
21253               * Summary: Process a mis-jump into witchspace
21254               *
21255               * ------------------------------------------------------------------------------
21256               *
21257               * Process a mis-jump into witchspace (which happens very rarely). Witchspace has
21258               * a strange, almost dust-free aspect to it, and it is populated by hostile
21259               * Thargoids. Using our escape pod will be fatal, and our position on the
21260               * galactic chart is in-between systems. It is a scary place...
21261               *
21262               * There is a 0.78% chance that this routine is called from TT18 instead of doing
21263               * a normal hyperspace, or we can manually trigger a mis-jump by holding down
21264               * CTRL after first enabling the "author display" configuration option ("X") when
21265               * paused.
21266               *
21267               * ------------------------------------------------------------------------------
21268               *
21269               * Other entry points:
21270               *
21271               * ptg                 Called when the user manually forces a mis-jump
21272               *
21273               * ******************************************************************************
21274               
21275               ptg_:
21276                      .lsr @COK                       ; LSR COK           ; Set bit 0 of the competition flags in COK, so that the
     **** ****     > LSR
0001 A59C D020  30        movb @COK,rtmp
     A59E 030E     
0002 A5A0 0910  18        srl  rtmp,1
0003 A5A2 D800  30        movb rtmp,@COK
     A5A4 030E     
                   < elite.a99
21277                      .sec                            ; SEC               ; competition code will include the fact that we have
     **** ****     > SEC
0001 A5A6 0A18  18        sla  rmone,1
                   < elite.a99
21278 A5A8 0204  20        li   rarg1,COK                  ; ROL COK           ; manually forced a mis-jump into witchspace
     A5AA 030E     
21279 A5AC 06A0  32        bl   @rol                       ;
     A5AE FE4E     
21280               
21281               MJP:
21282               * LDA #1                 \ This instruction is commented out in the original
21283                                                                          ; source - it is not required as a call to TT66-2 sets
21284                                                                          ; A to 1 for us. This is presumably an example of the
21285                                                                          ; authors saving a couple of bytes by calling TT66-2
21286                                                                          ; instead of TT66, while leaving the original LDA
21287                                                                          ; instruction in place
21288 A5B0 0200  20        li   rtmp,TT66-2                ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
     A5B2 4EF8     
21289 A5B4 06A0  32        bl   @jsr                       ;
     A5B6 FE28     
21290                                                                          ; and set the current view type in QQ11 to 1
21291               
21292 A5B8 0200  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     A5BA 419C     
21293 A5BC 06A0  32        bl   @jsr                       ;
     A5BE FE28     
21294                                                                          ; hyperspace sound for a second time (as we already
21295                                                                          ; called LL164 in TT18)
21296               
21297 A5C0 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces, as
     A5C2 C682     
21298 A5C4 06A0  32        bl   @jsr                       ;
     A5C6 FE28     
21299                                                                          ; well as setting Y to &FF
21300               
21301 A5C8 D80F  30        movb ry,@MJ                     ; STY MJ            ; Set the mis-jump flag in MJ to &FF, to indicate that
     A5CA 0D5C     
21302                                                                          ; we are now in witchspace
21303               
21304               MJP1:
21305 A5CC 0200  20        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     A5CE A578     
21306 A5D0 06A0  32        bl   @jsr                       ;
     A5D2 FE28     
21307                                                                          ; companion
21308               
21309 A5D4 020D  20        li   ra,>03*256                 ; LDA #3            ; Fetch the number of Thargoid ships from MANY+THG, and
     A5D6 0300     
21310 A5D8 9360  30        cb   @MANY+THG,ra               ; CMP MANY+THG      ; if it is less than or equal to 3, loop back to MJP1 to
     A5DA 0D53     
21311 A5DC 18F7  14        joc  MJP1                       ; BCS MJP1          ; spawn another one, until we have four Thargoids
21312               
21313 A5DE D80D  30        movb ra,@NOSTM                  ; STA NOSTM         ; Set NOSTM (the maximum number of stardust particles)
     A5E0 0F33     
21314                                                                          ; to 3, so there are fewer bits of stardust in
21315                                                                          ; witchspace (normal space has a maximum of 18)
21316               
21317 A5E2 020E  20        li   rx,>00*256                 ; LDX #0            ; Initialise the front space view
     A5E4 0000     
21318 A5E6 0200  20        li   rtmp,LOOK1                 ; JSR LOOK1
     A5E8 4E90     
21319 A5EA 06A0  32        bl   @jsr                       ;
     A5EC FE28     
21320               
21321 A5EE D360  30        movb @QQ1,ra                    ; LDA QQ1           ; Fetch the current system's galactic y-coordinate in
     A5F0 0302     
21322                      .eoi (>1f*256)                  ; EOR #%00011111    ; QQ1 and flip bits 0-5, so we end up somewhere in the
     **** ****     > EOI
0001 A5F2 0200  20        li   rtmp,(>1F*256)
     A5F4 1F00     
0002 A5F6 2B40  18        xor  rtmp,ra
                   < elite.a99
21323 A5F8 D80D  30        movb ra,@QQ1                    ; STA QQ1           ; vicinity of our original destination, but above or
     A5FA 0302     
21324                                                                          ; below it in the galactic chart
21325               ptg1_:
21326 A5FC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A5FE FE34     
21327               
21328               * ******************************************************************************
21329               *
21330               * Name: TT18
21331               * Type: Subroutine
21332               * Category: Flight
21333               * Summary: Try to initiate a jump into hyperspace
21334               *
21335               * ------------------------------------------------------------------------------
21336               *
21337               * Try to go through hyperspace. Called from TT102 in the main loop when the
21338               * hyperspace countdown has finished.
21339               *
21340               * ******************************************************************************
21341               
21342               TT18:
21343 A600 D360  30        movb @QQ14,ra                   ; LDA QQ14          ; Subtract the distance to the selected system (in QQ8)
     A602 030D     
21344                      .sec                            ; SEC               ; from the amount of fuel in our tank (in QQ14) into A
     **** ****     > SEC
0001 A604 0A18  18        sla  rmone,1
                   < elite.a99
21345                      .sbc @QQ8,ra                    ; SBC QQ8
     **** ****     > SBC
0001 A606 1801  14        joc  !
0002 A608 7347  18        sb   rone,ra
0003               !:
0004 A60A 7360  30        sb   @QQ8,ra
     A60C 0F2F     
                   < elite.a99
21346               
21347 A60E D80D  30        movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel amount in QQ14
     A610 030D     
21348               
21349 A612 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, jump to ee5
     A614 0096     
21350 A616 1608  14        jne  ee5_                       ; BNE ee5           ; to skip the following
21351               
21352 A618 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     A61A 4EFA     
21353 A61C 06A0  32        bl   @jsr                       ;
     A61E FE28     
21354                                                                          ; and set the current view type in QQ11 to 0 (space
21355                                                                          ; view)
21356               
21357 A620 0200  20        li   rtmp,LL164                 ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
     A622 419C     
21358 A624 06A0  32        bl   @jsr                       ;
     A626 FE28     
21359                                                                          ; hyperspace sound
21360               
21361               ee5_:
21362 A628 0200  20        li   rtmp,CTRL                  ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed,
     A62A D3C4     
21363 A62C 06A0  32        bl   @jsr                       ;
     A62E FE28     
21364                                                                          ; returning a negative value in A if it is
21365               
21366                      .and @PATG                      ; AND PATG          ; If the game is configured to show the author's names
     **** ****     > AND
0001 A630 D020  30        movb @PATG,rtmp
     A632 0F4C     
0002 A634 0540  14        inv  rtmp
0003 A636 5340  18        szcb rtmp,ra
                   < elite.a99
21367                                                                          ; on the start-up screen, then PATG will contain &FF,
21368                                                                          ; otherwise it will be 0
21369               
21370 A638 11B1  14        jlt  ptg_                       ; BMI ptg           ; By now, A will be negative if we are holding down CTRL
21371                                                                          ; and author names are configured, which is what we have
21372                                                                          ; to do in order to trigger a manual mis-jump, so jump
21373                                                                          ; to ptg to do a mis-jump (ptg not only mis-jumps, but
21374                                                                          ; updates the competition flags, so Acornsoft could tell
21375                                                                          ; from the competition code whether this feature had
21376                                                                          ; been used)
21377               
21378 A63A 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     A63C C7D0     
21379 A63E 06A0  32        bl   @jsr                       ;
     A640 FE28     
21380               
21381 A642 028D  22        ci   ra,>fd*256                 ; CMP #253          ; If A >= 253 (0.78% chance) then jump to MJP to trigger
     A644 FD00     
21382 A646 18B4  14        joc  MJP                        ; BCS MJP           ; a mis-jump into witchspace
21383               
21384               * JSR TT111              \ This instruction is commented out in the original
21385                                                                          ; source. It finds the closest system to coordinates
21386                                                                          ; (QQ9, QQ10), but we don't need to do this as the
21387                                                                          ; crosshairs will already be on a system by this point
21388               
21389 A648 0200  20        li   rtmp,hyp1_+3               ; JSR hyp1+3        ; Jump straight to the system at (QQ9, QQ10) without
     A64A A497     
21390 A64C 06A0  32        bl   @jsr                       ;
     A64E FE28     
21391                                                                          ; first calculating which system is closest
21392               
21393 A650 0200  20        li   rtmp,GVL                   ; JSR GVL           ; Calculate the availability for each market item in the
     A652 A4DE     
21394 A654 06A0  32        bl   @jsr                       ;
     A656 FE28     
21395                                                                          ; new system
21396               
21397 A658 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     A65A C682     
21398 A65C 06A0  32        bl   @jsr                       ;
     A65E FE28     
21399               
21400 A660 0200  20        li   rtmp,SOLAR                 ; JSR SOLAR         ; Halve our legal status, update the missile indicators,
     A662 B172     
21401 A664 06A0  32        bl   @jsr                       ;
     A666 FE28     
21402                                                                          ; and set up data blocks and slots for the planet and
21403                                                                          ; sun
21404               
21405 A668 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view in QQ11 is not a space view (0) or
     A66A 0096     
21406 A66C 024D  22        andi ra,>3f*256                 ; AND #%00111111    ; one of the charts (64 or 128), return from the
     A66E 3F00     
21407 A670 16C5  14        jne  ptg1_                      ; BNE ptg1          ; subroutine (as hyR contains an RTS)
21408               
21409 A672 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; Otherwise clear the screen and draw a white border
     A674 4EFE     
21410 A676 06A0  32        bl   @jsr                       ;
     A678 FE28     
21411               
21412 A67A D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is one of the charts, jump to
     A67C 0096     
21413 A67E 1630  14        jne  TT114                      ; BNE TT114         ; TT114 (from which we jump to the correct routine to
21414                                                                          ; display the chart)
21415               
21416 A680 B347  18        ab   rone,ra                    ; INC QQ11          ; This is a space view, so increment QQ11 to 1
21417               
21418                                                                          ; Fall through into TT110 to show the front space view
21419               
21420               * ******************************************************************************
21421               *
21422               * Name: TT110
21423               * Type: Subroutine
21424               * Category: Flight
21425               * Summary: Launch from a station or show the front space view
21426               *
21427               * ------------------------------------------------------------------------------
21428               *
21429               * Launch the ship (if we are docked), or show the front space view (if we are
21430               * already in space).
21431               *
21432               * Called when red key f0 is pressed while docked (launch), after we arrive in a
21433               * new galaxy, or after a hyperspace if the current view is a space view.
21434               *
21435               * ******************************************************************************
21436               
21437               TT110:
21438 A682 D3A0  30        movb @QQ12,rx                   ; LDX QQ12          ; If we are not docked (QQ12 = 0) then jump to NLUNCH
     A684 009F     
21439 A686 1326  14        jeq  NLUNCH                     ; BEQ NLUNCH        ; to skip the launch tunnel and setup process
21440               
21441 A688 0200  20        li   rtmp,LAUN                  ; JSR LAUN          ; Show the space station launch tunnel
     A68A 41C2     
21442 A68C 06A0  32        bl   @jsr                       ;
     A68E FE28     
21443               
21444 A690 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     A692 C682     
21445 A694 06A0  32        bl   @jsr                       ;
     A696 FE28     
21446               
21447 A698 0200  20        li   rtmp,TT111                 ; JSR TT111         ; Select the system closest to galactic coordinates
     A69A A000     
21448 A69C 06A0  32        bl   @jsr                       ;
     A69E FE28     
21449                                                                          ; (QQ9, QQ10)
21450               
21451 A6A0 B347  18        ab   rone,ra                    ; INC INWK+8        ; Increment z_sign ready for the call to SOS, so the
21452                                                                          ; planet appears at a z_sign of 1 in front of us when
21453                                                                          ; we launch
21454               
21455 A6A2 0200  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     A6A4 B14E     
21456 A6A6 06A0  32        bl   @jsr                       ;
     A6A8 FE28     
21457                                                                          ; to FRIN, where it will get put in the first slot as
21458                                                                          ; it's the first one to be added to our local bubble of
21459                                                                          ; universe following the call to RES2 above
21460               
21461 A6AA 020D  20        li   ra,>80*256                 ; LDA #128          ; For the space station, set z_sign to &80, so it's
     A6AC 8000     
21462 A6AE D80D  30        movb ra,@INWK+8                 ; STA INWK+8        ; behind us (&80 is negative)
     A6B0 005B     
21463               
21464 A6B2 B347  18        ab   rone,ra                    ; INC INWK+7        ; And increment z_hi, so it's only just behind us
21465               
21466 A6B4 0200  20        li   rtmp,NWSPS                 ; JSR NWSPS         ; Add a new space station to our local bubble of
     A6B6 B58A     
21467 A6B8 06A0  32        bl   @jsr                       ;
     A6BA FE28     
21468                                                                          ; universe
21469               
21470 A6BC 020D  20        li   ra,>0c*256                 ; LDA #12           ; Set our launch speed in DELTA to 12
     A6BE 0C00     
21471 A6C0 D80D  30        movb ra,@DELTA                  ; STA DELTA
     A6C2 008C     
21472               
21473 A6C4 0200  20        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     A6C6 CB8A     
21474 A6C8 06A0  32        bl   @jsr                       ;
     A6CA FE28     
21475                                                                          ; are carrying in our hold (A is up to 40 for a
21476                                                                          ; standard hold crammed with contraband, up to 70 for
21477                                                                          ; an extended cargo hold full of narcotics and slaves)
21478               
21479 A6CC F360  30        socb @FIST,ra                   ; ORA FIST          ; OR the value in A with our legal status in FIST to
     A6CE 0334     
21480                                                                          ; get a new value that is at least as high as both
21481                                                                          ; values, to reflect the fact that launching with a
21482                                                                          ; hold full of contraband can only make matters worse
21483               
21484 A6D0 D80D  30        movb ra,@FIST                   ; STA FIST          ; Update our legal status with the new value
     A6D2 0334     
21485               
21486               NLUNCH:
21487 A6D4 020E  20        li   rx,>00*256                 ; LDX #0            ; Set QQ12 to 0 to indicate we are not docked
     A6D6 0000     
21488 A6D8 D80E  30        movb rx,@QQ12                   ; STX QQ12
     A6DA 009F     
21489               
21490 A6DC 0460  28        b    @LOOK1                     ; JMP LOOK1         ; Jump to LOOK1 to switch to the front view (X = 0),
     A6DE 4E90     
21491                                                                          ; returning from the subroutine using a tail call
21492               
21493               * ******************************************************************************
21494               *
21495               * Name: TT114
21496               * Type: Subroutine
21497               * Category: Charts
21498               * Summary: Display either the Long-range or Short-range Chart
21499               *
21500               * ------------------------------------------------------------------------------
21501               *
21502               * Display either the Long-range or Short-range Chart, depending on the current
21503               * view setting. Called from TT18 once we know the current view is one of the
21504               * charts.
21505               *
21506               * ------------------------------------------------------------------------------
21507               *
21508               * Arguments:
21509               *
21510               * A                   The current view, loaded from QQ11
21511               *
21512               * ******************************************************************************
21513               
21514               TT114:
21515 A6E0 1102  14        jlt  TT115                      ; BMI TT115         ; If bit 7 of the current view is set (i.e. the view is
21516                                                                          ; the Short-range Chart, 128), skip to TT115 below to
21517                                                                          ; jump to TT23 to display the chart
21518               
21519 A6E2 0460  28        b    @TT22                      ; JMP TT22          ; Otherwise the current view is the Long-range Chart, so
     A6E4 565A     
21520                                                                          ; jump to TT22 to display it
21521               
21522               TT115:
21523 A6E6 0460  28        b    @TT23                      ; JMP TT23          ; Jump to TT23 to display the Short-range Chart
     A6E8 5D32     
21524               
21525               * ******************************************************************************
21526               *
21527               * Name: LCASH
21528               * Type: Subroutine
21529               * Category: Maths (Arithmetic)
21530               * Summary: Subtract an amount of cash from the cash pot
21531               *
21532               * ------------------------------------------------------------------------------
21533               *
21534               * Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
21535               * cash in the pot. As CASH is a four-byte number, this calculates:
21536               *
21537               * CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
21538               *
21539               * ------------------------------------------------------------------------------
21540               *
21541               * Returns:
21542               *
21543               * C flag              If set, there was enough cash to do the subtraction
21544               *
21545               * If clear, there was not enough cash to do the
21546               * subtraction
21547               *
21548               * ******************************************************************************
21549               
21550               LCASH:
21551 A6EA D80E  30        movb rx,@T1                     ; STX T1            ; Subtract the least significant bytes:
     A6EC 0006     
21552 A6EE D360  30        movb @CASH+3,ra                 ; LDA CASH+3        ;
     A6F0 030C     
21553                      .sec                            ; SEC               ; CASH+3 = CASH+3 - X
     **** ****     > SEC
0001 A6F2 0A18  18        sla  rmone,1
                   < elite.a99
21554                      .sbc @T1,ra                     ; SBC T1
     **** ****     > SBC
0001 A6F4 1801  14        joc  !
0002 A6F6 7347  18        sb   rone,ra
0003               !:
0004 A6F8 7360  30        sb   @T1,ra
     A6FA 0006     
                   < elite.a99
21555 A6FC D80D  30        movb ra,@CASH+3                 ; STA CASH+3
     A6FE 030C     
21556               
21557 A700 D80F  30        movb ry,@T1                     ; STY T1            ; Then the second most significant bytes:
     A702 0006     
21558 A704 D360  30        movb @CASH+2,ra                 ; LDA CASH+2        ;
     A706 030B     
21559                      .sbc @T1,ra                     ; SBC T1            ; CASH+2 = CASH+2 - Y
     **** ****     > SBC
0001 A708 1801  14        joc  !
0002 A70A 7347  18        sb   rone,ra
0003               !:
0004 A70C 7360  30        sb   @T1,ra
     A70E 0006     
                   < elite.a99
21560 A710 D80D  30        movb ra,@CASH+2                 ; STA CASH+2
     A712 030B     
21561               
21562 A714 D360  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     A716 030A     
21563                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A718 1801  14        joc  !
0002 A71A 7347  18        sb   rone,ra
0003               !:
0004 A71C 022D  22        ai   ra,-(>00*256)
     A71E 0000     
                   < elite.a99
21564 A720 D80D  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 - 0
     A722 030A     
21565               
21566 A724 D360  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     A726 0309     
21567                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 A728 1801  14        joc  !
0002 A72A 7347  18        sb   rone,ra
0003               !:
0004 A72C 022D  22        ai   ra,-(>00*256)
     A72E 0000     
                   < elite.a99
21568 A730 D80D  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH - 0
     A732 0309     
21569               
21570 A734 1820  14        joc  TT113                      ; BCS TT113         ; If the C flag is set then the subtraction didn't
21571                                                                          ; underflow, so the value in CASH is correct and we can
21572                                                                          ; jump to TT113 to return from the subroutine with the
21573                                                                          ; C flag set to indicate success (as TT113 contains an
21574                                                                          ; RTS)
21575               
21576                                                                          ; Otherwise we didn't have enough cash in CASH to
21577                                                                          ; subtract (Y X) from it, so fall through into
21578                                                                          ; MCASH to reverse the sum and restore the original
21579                                                                          ; value in CASH, and returning with the C flag clear
21580               
21581               * ******************************************************************************
21582               *
21583               * Name: MCASH
21584               * Type: Subroutine
21585               * Category: Maths (Arithmetic)
21586               * Summary: Add an amount of cash to the cash pot
21587               *
21588               * ------------------------------------------------------------------------------
21589               *
21590               * Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
21591               * calculates:
21592               *
21593               * CASH(0 1 2 3) = CASH(0 1 2 3) + (Y X)
21594               *
21595               * ------------------------------------------------------------------------------
21596               *
21597               * Other entry points:
21598               *
21599               * TT113               Contains an RTS
21600               *
21601               * ******************************************************************************
21602               
21603               MCASH:
21604 A736 D34E  18        movb rx,ra                      ; TXA               ; Add the least significant bytes:
21605                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 A738 0A16  18        sla  rzero,1
                   < elite.a99
21606                      .adc @CASH+3,ra                 ; ADC CASH+3        ; CASH+3 = CASH+3 + X
     **** ****     > ADC
0001 A73A 1701  14        jnc  !
0002 A73C B347  18        ab   rone,ra
0003               !:
0004 A73E B360  30        ab   @CASH+3,ra
     A740 030C     
                   < elite.a99
21607 A742 D80D  30        movb ra,@CASH+3                 ; STA CASH+3
     A744 030C     
21608               
21609 A746 D34F  18        movb ry,ra                      ; TYA               ; Then the second most significant bytes:
21610                      .adc @CASH+2,ra                 ; ADC CASH+2        ;
     **** ****     > ADC
0001 A748 1701  14        jnc  !
0002 A74A B347  18        ab   rone,ra
0003               !:
0004 A74C B360  30        ab   @CASH+2,ra
     A74E 030B     
                   < elite.a99
21611 A750 D80D  30        movb ra,@CASH+2                 ; STA CASH+2        ; CASH+2 = CASH+2 + Y
     A752 030B     
21612               
21613 A754 D360  30        movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
     A756 030A     
21614                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 A758 1701  14        jnc  !
0002 A75A B347  18        ab   rone,ra
0003               !:
0004 A75C 022D  22        ai   ra,(>00*256)
     A75E 0000     
                   < elite.a99
21615 A760 D80D  30        movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 + 0
     A762 030A     
21616               
21617 A764 D360  30        movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
     A766 0309     
21618                      .adi (>00*256)                  ; ADC #0            ;
     **** ****     > ADI
0001 A768 1701  14        jnc  !
0002 A76A B347  18        ab   rone,ra
0003               !:
0004 A76C 022D  22        ai   ra,(>00*256)
     A76E 0000     
                   < elite.a99
21619 A770 D80D  30        movb ra,@CASH                   ; STA CASH          ; CASH = CASH + 0
     A772 0309     
21620               
21621                      .clc                            ; CLC               ; Clear the C flag, so if the above was done following
     **** ****     > CLC
0001 A774 0A16  18        sla  rzero,1
                   < elite.a99
21622                                                                          ; a failed LCASH call, the C flag correctly indicates
21623                                                                          ; failure
21624               
21625               TT113:
21626 A776 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A778 FE34     
21627               
21628               * ******************************************************************************
21629               *
21630               * Name: GCASH
21631               * Type: Subroutine
21632               * Category: Maths (Arithmetic)
21633               * Summary: Calculate (Y X) = P * Q * 4
21634               *
21635               * ------------------------------------------------------------------------------
21636               *
21637               * Calculate the following multiplication of unsigned 8-bit numbers:
21638               *
21639               * (Y X) = P * Q * 4
21640               *
21641               * ******************************************************************************
21642               
21643               GCASH:
21644 A77A 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate (A P) = P * Q
     A77C 4676     
21645 A77E 06A0  32        bl   @jsr                       ;
     A780 FE28     
21646               
21647               * ******************************************************************************
21648               *
21649               * Name: GC2
21650               * Type: Subroutine
21651               * Category: Maths (Arithmetic)
21652               * Summary: Calculate (Y X) = (A P) * 4
21653               *
21654               * ------------------------------------------------------------------------------
21655               *
21656               * Calculate the following multiplication of unsigned 16-bit numbers:
21657               *
21658               * (Y X) = (A P) * 4
21659               *
21660               * ******************************************************************************
21661               
21662               GC2:
21663                      .asl @P                         ; ASL P             ; Set (A P) = (A P) * 4
     **** ****     > ASL
0001 A782 D020  30        movb @P,rtmp
     A784 001B     
0002 A786 0240  22        andi rtmp,>ff00
     A788 FF00     
0003 A78A 0A10  18        sla  rtmp,1
0004 A78C D800  30        movb rtmp,@P
     A78E 001B     
                   < elite.a99
21664 A790 06A0  32        bl   @rola                      ; ROL A
     A792 FE3E     
21665                      .asl @P                         ; ASL P
     **** ****     > ASL
0001 A794 D020  30        movb @P,rtmp
     A796 001B     
0002 A798 0240  22        andi rtmp,>ff00
     A79A FF00     
0003 A79C 0A10  18        sla  rtmp,1
0004 A79E D800  30        movb rtmp,@P
     A7A0 001B     
                   < elite.a99
21666 A7A2 06A0  32        bl   @rola                      ; ROL A
     A7A4 FE3E     
21667               
21668 A7A6 D3CD  18        movb ra,ry                      ; TAY               ; Set (Y X) = (A P)
21669 A7A8 D3A0  30        movb @P,rx                      ; LDX P
     A7AA 001B     
21670               
21671 A7AC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     A7AE FE34     
21672               
21673               * ******************************************************************************
21674               *
21675               * Name: EQSHP
21676               * Type: Subroutine
21677               * Category: Equipment
21678               * Summary: Show the Equip Ship screen (red key f3)
21679               *
21680               * ------------------------------------------------------------------------------
21681               *
21682               * Other entry points:
21683               *
21684               * err                 Beep, pause and go to the docking bay (i.e. show the
21685               * Status Mode screen)
21686               *
21687               * pres                Given an item number A with the item name in recursive
21688               * token Y, show an error to say that the item is already
21689               * present, refund the cost of the item, and then beep and
21690               * exit to the docking bay (i.e. show the Status Mode
21691               * screen)
21692               *
21693               * ******************************************************************************
21694               
21695               bay_:
21696 A7B0 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
     A7B2 CDBC     
21697                                                                          ; screen)
21698               
21699               EQSHP:
21700 A7B4 0200  20        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     A7B6 3522     
21701 A7B8 06A0  32        bl   @jsr                       ;
     A7BA FE28     
21702               
21703 A7BC 020D  20        li   ra,>20*256                 ; LDA #32           ; Clear the top part of the screen, draw a white border,
     A7BE 2000     
21704 A7C0 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 32 (Equip
     A7C2 4EFA     
21705 A7C4 06A0  32        bl   @jsr                       ;
     A7C6 FE28     
21706                                                                          ; Ship screen)
21707               
21708 A7C8 020D  20        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12
     A7CA 0C00     
21709 A7CC D80D  30        movb ra,@XC                     ; STA XC
     A7CE 002C     
21710               
21711 A7D0 020D  20        li   ra,>cf*256                 ; LDA #207          ; Print recursive token 47 ("EQUIP") followed by a space
     A7D2 CF00     
21712 A7D4 0200  20        li   rtmp,spc_                  ; JSR spc
     A7D6 52E6     
21713 A7D8 06A0  32        bl   @jsr                       ;
     A7DA FE28     
21714               
21715 A7DC 020D  20        li   ra,>b9*256                 ; LDA #185          ; Print recursive token 25 ("SHIP") and draw a
     A7DE B900     
21716 A7E0 0200  20        li   rtmp,NLIN3                 ; JSR NLIN3         ; horizontal line at pixel row 19 to box in the title
     A7E2 2738     
21717 A7E4 06A0  32        bl   @jsr                       ;
     A7E6 FE28     
21718               
21719 A7E8 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     A7EA 8000     
21720 A7EC D80D  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     A7EE 007E     
21721               
21722 A7F0 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21723               
21724 A7F2 D360  30        movb @tek_,ra                   ; LDA tek           ; Fetch the tech level of the current system from tek
     A7F4 0F1D     
21725                      .clc                            ; CLC               ; and add 3 (the tech level is stored as 0-14, so A is
     **** ****     > CLC
0001 A7F6 0A16  18        sla  rzero,1
                   < elite.a99
21726                      .adi (>03*256)                  ; ADC #3            ; now set to between 3 and 17)
     **** ****     > ADI
0001 A7F8 1701  14        jnc  !
0002 A7FA B347  18        ab   rone,ra
0003               !:
0004 A7FC 022D  22        ai   ra,(>03*256)
     A7FE 0300     
                   < elite.a99
21727               
21728 A800 028D  22        ci   ra,>0c*256                 ; CMP #12           ; If A >= 12 then set A = 12, so A is now set to between
     A802 0C00     
21729 A804 1702  14        jnc  B58                        ; BCC B58           ; 3 and 12
21730 A806 020D  20        li   ra,>0c*256                 ; LDA #12
     A808 0C00     
21731               
21732               B58:
21733 A80A D80D  30        movb ra,@Q                      ; STA Q             ; Set QQ25 = A (so QQ25 is in the range 3-12 and
     A80C 0090     
21734 A80E D80D  30        movb ra,@QQ25                   ; STA QQ25          ; represents number of the most advanced item available
     A810 0F19     
21735 A812 B347  18        ab   rone,ra                    ; INC Q             ; in this system, which we can pass to gnum below when
21736                                                                          ; asking which item we want to buy)
21737                                                                          ;
21738                                                                          ; Set Q = A + 1 (so Q is in the range 4-13 and contains
21739                                                                          ; QQ25 + 1, i.e. the highest item number on sale + 1)
21740               
21741 A814 020D  20        li   ra,>46*256                 ; LDA #70           ; Set A = 70 - QQ14, where QQ14 contains the current
     A816 4600     
21742                      .sec                            ; SEC               ; fuel in light years * 10, so this leaves the amount
     **** ****     > SEC
0001 A818 0A18  18        sla  rmone,1
                   < elite.a99
21743                      .sbc @QQ14,ra                   ; SBC QQ14          ; of fuel we need to fill 'er up (in light years * 10)
     **** ****     > SBC
0001 A81A 1801  14        joc  !
0002 A81C 7347  18        sb   rone,ra
0003               !:
0004 A81E 7360  30        sb   @QQ14,ra
     A820 030D     
                   < elite.a99
21744               
21745                      .asla                           ; ASL A             ; The price of fuel is always 2 Cr per light year, so we
     **** ****     > ASLA
0001 A822 024D  22        andi ra,>ff00
     A824 FF00     
0002 A826 0A1D  18        sla  ra,1
                   < elite.a99
21746 A828 D80D  38        movb ra,@PRXS                   ; STA PRXS          ; double A and store it in PRXS, as the first price in
     A82A 3060     
21747                                                                          ; the price list (which is reserved for fuel), and
21748                                                                          ; because the table contains prices as price * 10, it's
21749                                                                          ; in the right format (so tank containing 7.0 light
21750                                                                          ; years of fuel would be 14.0 Cr, or a PRXS value of
21751                                                                          ; 140)
21752               
21753 A82C 020E  20        li   rx,>01*256                 ; LDX #1            ; We are now going to work our way through the equipment
     A82E 0100     
21754                                                                          ; price list at PRXS, printing out the equipment that is
21755                                                                          ; available at this station, so set a counter in X,
21756                                                                          ; starting at 1, to hold the number of the current item
21757                                                                          ; plus 1 (so the item number in X loops through 1-13)
21758               
21759               EQL1:
21760 A830 D80E  30        movb rx,@XX13                   ; STX XX13          ; Store the current item number + 1 in XX13
     A832 0098     
21761               
21762 A834 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Print a newline
     A836 52CE     
21763 A838 06A0  32        bl   @jsr                       ;
     A83A FE28     
21764               
21765 A83C D3A0  30        movb @XX13,rx                   ; LDX XX13          ; Print the current item number + 1 to 3 digits, left-
     A83E 0098     
21766                      .clc                            ; CLC               ; padding with spaces, and with no decimal point, so the
     **** ****     > CLC
0001 A840 0A16  18        sla  rzero,1
                   < elite.a99
21767 A842 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; items are numbered from 1
     A844 322C     
21768 A846 06A0  32        bl   @jsr                       ;
     A848 FE28     
21769               
21770 A84A 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     A84C A3D0     
21771 A84E 06A0  32        bl   @jsr                       ;
     A850 FE28     
21772               
21773 A852 D360  30        movb @XX13,ra                   ; LDA XX13          ; Print recursive token 104 + XX13, which will be in the
     A854 0098     
21774                      .clc                            ; CLC               ; range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
     **** ****     > CLC
0001 A856 0A16  18        sla  rzero,1
                   < elite.a99
21775                      .adi (>68*256)                  ; ADC #104          ; so this prints the current item's name
     **** ****     > ADI
0001 A858 1701  14        jnc  !
0002 A85A B347  18        ab   rone,ra
0003               !:
0004 A85C 022D  22        ai   ra,(>68*256)
     A85E 6800     
                   < elite.a99
21776 A860 0200  20        li   rtmp,TT27                  ; JSR TT27
     A862 ACA0     
21777 A864 06A0  32        bl   @jsr                       ;
     A866 FE28     
21778               
21779 A868 D360  30        movb @XX13,ra                   ; LDA XX13          ; Call prx-3 to set (Y X) to the price of the item with
     A86A 0098     
21780 A86C 0200  20        li   rtmp,prx_-3                ; JSR prx-3         ; number XX13 - 1 (as XX13 contains the item number + 1)
     A86E AAA9     
21781 A870 06A0  32        bl   @jsr                       ;
     A872 FE28     
21782               
21783                      .sec                            ; SEC               ; Set the C flag so we will print a decimal point when
     **** ****     > SEC
0001 A874 0A18  18        sla  rmone,1
                   < elite.a99
21784                                                                          ; we print the price
21785               
21786 A876 020D  20        li   ra,>19*256                 ; LDA #25           ; Move the text cursor to column 25
     A878 1900     
21787 A87A D80D  30        movb ra,@XC                     ; STA XC
     A87C 002C     
21788               
21789 A87E 020D  20        li   ra,>06*256                 ; LDA #6            ; Print the number in (Y X) to 6 digits, left-padding
     A880 0600     
21790 A882 0200  20        li   rtmp,TT11                  ; JSR TT11          ; with spaces and including a decimal point, which will
     A884 3234     
21791 A886 06A0  32        bl   @jsr                       ;
     A888 FE28     
21792                                                                          ; be the correct price for this item as (Y X) contains
21793                                                                          ; the price * 10, so the trailing zero will go after the
21794                                                                          ; decimal point (i.e. 5250 will be printed as 525.0)
21795               
21796 A88A D3A0  30        movb @XX13,rx                   ; LDX XX13          ; Increment the current item number in XX13
     A88C 0098     
21797 A88E B387  18        ab   rone,rx                    ; INX
21798               
21799 A890 93A0  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, loop back up to print the next item on the
     A892 0090     
21800 A894 17CD  14        jnc  EQL1                       ; BCC EQL1          ; list of equipment available at this station
21801               
21802 A896 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     A898 4FFE     
21803 A89A 06A0  32        bl   @jsr                       ;
     A89C FE28     
21804                                                                          ; and move the text cursor to column 1 on row 21, i.e.
21805                                                                          ; the start of the top row of the three bottom rows
21806               
21807 A89E 020D  20        li   ra,>7f*256                 ; LDA #127          ; Print recursive token 127 ("ITEM") followed by a
     A8A0 7F00     
21808 A8A2 0200  20        li   rtmp,prq_                  ; JSR prq           ; question mark
     A8A4 A2AE     
21809 A8A6 06A0  32        bl   @jsr                       ;
     A8A8 FE28     
21810               
21811 A8AA 0200  20        li   rtmp,gnum_                 ; JSR gnum          ; Call gnum to get a number from the keyboard, which
     A8AC 59C6     
21812 A8AE 06A0  32        bl   @jsr                       ;
     A8B0 FE28     
21813                                                                          ; will be the number of the item we want to purchase,
21814                                                                          ; returning the number entered in A and R, and setting
21815                                                                          ; the C flag if the number is bigger than the highest
21816                                                                          ; item number in QQ25
21817               
21818 A8B2 1602  14        jne  FIX004                     ; BNE FIX004        ; If no number was entered, jump up to bay to go to the
21819                                                                          ; docking bay (i.e. show the Status Mode screen)
21820 A8B4 0460  28        b    @bay_                      ; JMP bay
     A8B6 A7B0     
21821               FIX004:
21822 A8B8 1702  14        jnc  FIX005                     ; BCC FIX005        ; If the number entered was too big, jump up to bay to
21823                                                                          ; go to the docking bay (i.e. show the Status Mode
21824                                                                          ; screen)
21825 A8BA 0460  28        b    @bay_                      ; JMP bay
     A8BC A7B0     
21826               FIX005:
21827                      .sbi (>00*256)                  ; SBC #0            ; Set A to the number entered - 1 (because the C flag is
     **** ****     > SBI
0001 A8BE 1801  14        joc  !
0002 A8C0 7347  18        sb   rone,ra
0003               !:
0004 A8C2 022D  22        ai   ra,-(>00*256)
     A8C4 0000     
                   < elite.a99
21828                                                                          ; clear), which will be the actual item number we want
21829                                                                          ; to buy
21830               
21831 A8C6 020E  20        li   rx,>02*256                 ; LDX #2            ; Move the text cursor to column 2
     A8C8 0200     
21832 A8CA D80E  30        movb rx,@XC                     ; STX XC
     A8CC 002C     
21833               
21834 A8CE B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down one line
21835               
21836                      .pha                            ; PHA               ; While preserving the value in A, call eq to subtract
     **** ****     > PHA
0001 A8D0 D68D  30        movb ra,*rsp
0002 A8D2 060A  14        dec  rsp
                   < elite.a99
21837 A8D4 0200  20        li   rtmp,eq_                   ; JSR eq            ; the price of the item we want to buy (which is in A)
     A8D6 AA80     
21838 A8D8 06A0  32        bl   @jsr                       ;
     A8DA FE28     
21839                      .pla                            ; PLA               ; from our cash pot, but only if we have enough cash in
     **** ****     > PLA
0001 A8DC 058A  14        inc  rsp
0002 A8DE D35A  26        movb *rsp,ra
                   < elite.a99
21840                                                                          ; the pot. If we don't have enough cash, exit to the
21841                                                                          ; docking bay (i.e. show the Status Mode screen)
21842               
21843 A8E0 1606  14        jne  et0_                       ; BNE et0           ; If A is not 0 (i.e. the item we've just bought is not
21844                                                                          ; fuel), skip to et0
21845               
21846 A8E2 D80D  30        movb ra,@MCNT                   ; STA MCNT          ; We just bought fuel, so we zero the main loop counter
     A8E4 0099     
21847               
21848 A8E6 020E  20        li   rx,>46*256                 ; LDX #70           ; Set the current fuel level * 10 in QQ14 to 70, or 7.0
     A8E8 4600     
21849 A8EA D80E  30        movb rx,@QQ14                   ; STX QQ14          ; light years (a full tank)
     A8EC 030D     
21850               
21851               et0_:
21852 A8EE 028D  22        ci   ra,>01*256                 ; CMP #1            ; If A is not 1 (i.e. the item we've just bought is not
     A8F0 0100     
21853 A8F2 160E  14        jne  et1_                       ; BNE et1           ; a missile), skip to et1
21854               
21855 A8F4 D3A0  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Fetch the current number of missiles from NOMSL into X
     A8F6 0333     
21856               
21857 A8F8 B387  18        ab   rone,rx                    ; INX               ; Increment X to the new number of missiles
21858               
21859 A8FA 020F  20        li   ry,>75*256                 ; LDY #117          ; Set Y to recursive token 117 ("ALL")
     A8FC 7500     
21860               
21861 A8FE 028E  22        ci   rx,>05*256                 ; CPX #5            ; If buying this missile would give us 5 missiles, this
     A900 0500     
21862 A902 185E  14        joc  pres_                      ; BCS pres          ; is more than the maximum of 4 missiles that we can
21863                                                                          ; fit, so jump to pres to show the error "All Present",
21864                                                                          ; beep and exit to the docking bay (i.e. show the Status
21865                                                                          ; Mode screen)
21866               
21867 A904 D80E  30        movb rx,@NOMSL                  ; STX NOMSL         ; Otherwise update the number of missiles in NOMSL
     A906 0333     
21868               
21869 A908 0200  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     A90A C73C     
21870 A90C 06A0  32        bl   @jsr                       ;
     A90E FE28     
21871                                                                          ; them are targeted
21872               
21873               et1_:
21874 A910 020F  20        li   ry,>6b*256                 ; LDY #107          ; Set Y to recursive token 107 ("LARGE CARGO{sentence
     A912 6B00     
21875                                                                          ; case} BAY")
21876               
21877 A914 028D  22        ci   ra,>02*256                 ; CMP #2            ; If A is not 2 (i.e. the item we've just bought is not
     A916 0200     
21878 A918 1607  14        jne  et2_                       ; BNE et2           ; a large cargo bay), skip to et2
21879               
21880 A91A 020E  20        li   rx,>25*256                 ; LDX #37           ; If our current cargo capacity in CRGO is 37, then we
     A91C 2500     
21881 A91E 93A0  30        cb   @CRGO,rx                   ; CPX CRGO          ; already have a large cargo bay fitted, so jump to pres
     A920 0316     
21882 A922 134E  14        jeq  pres_                      ; BEQ pres          ; to show the error "Large Cargo Bay Present", beep and
21883                                                                          ; exit to the docking bay (i.e. show the Status Mode
21884                                                                          ; screen)
21885               
21886 A924 D80E  30        movb rx,@CRGO                   ; STX CRGO          ; Otherwise we just scored ourselves a large cargo bay,
     A926 0316     
21887                                                                          ; so update our current cargo capacity in CRGO to 37
21888               
21889               et2_:
21890 A928 028D  22        ci   ra,>03*256                 ; CMP #3            ; If A is not 3 (i.e. the item we've just bought is not
     A92A 0300     
21891 A92C 1605  14        jne  et3_                       ; BNE et3           ; an E.C.M. system), skip to et3
21892               
21893 A92E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 108 ("E.C.M.SYSTEM")
21894               
21895 A930 D3A0  30        movb @ECM,rx                    ; LDX ECM           ; If we already have an E.C.M. fitted (i.e. ECM is
     A932 0328     
21896 A934 1645  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "E.C.M.
21897                                                                          ; System Present", beep and exit to the docking bay
21898                                                                          ; (i.e. show the Status Mode screen)
21899               
21900 A936 7347  18        sb   rone,ra                    ; DEC ECM           ; Otherwise we just took delivery of a brand new E.C.M.
21901                                                                          ; system, so set ECM to &FF (as ECM was 0 before the DEC
21902                                                                          ; instruction)
21903               
21904               et3_:
21905 A938 028D  22        ci   ra,>04*256                 ; CMP #4            ; If A is not 4 (i.e. the item we've just bought is not
     A93A 0400     
21906 A93C 1616  14        jne  et4_                       ; BNE et4           ; an extra pulse laser), skip to et4
21907               
21908 A93E 0200  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     A940 AACA     
21909 A942 06A0  32        bl   @jsr                       ;
     A944 FE28     
21910                                                                          ; prompt, and ask for a view number, which is returned
21911                                                                          ; in X (which now contains 0-3)
21912               
21913 A946 020D  20        li   ra,>04*256                 ; LDA #4            ; This instruction doesn't appear to do anything, as we
     A948 0400     
21914                                                                          ; either don't need it (if we already have this laser)
21915                                                                          ; or we set A to 4 below (if we buy it)
21916               
21917 A94A 06CE  14        swpb rx                         ;
21918 A94C D3AE  34        movb @LASER(rx),rx              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     A94E 0310     
21919 A950 06CE  14        swpb rx                         ;
21920 A952 1303  14        jeq  ed4_                       ; BEQ ed4           ; LASER+X, which contains the laser power for view X, is
21921                                                                          ; zero), jump to ed4 to buy a pulse laser
21922               
21923               ed7_:
21924 A954 020F  20        li   ry,>bb*256                 ; LDY #187          ; Otherwise we already have a laser mounted in this
     A956 BB00     
21925 A958 1633  14        jne  pres_                      ; BNE pres          ; view, so jump to pres with Y set to token 27
21926                                                                          ; (" LASER") to show the error "Laser Present", beep
21927                                                                          ; and exit to the docking bay (i.e. show the Status
21928                                                                          ; Mode screen)
21929               
21930               ed4_:
21931 A95A 020D  20        li   ra,(POW)*256               ; LDA #POW          ; We just bought a pulse laser for view X, so we need
     A95C 0F00     
21932 A95E 06CE  14        swpb rx                         ;
21933 A960 DB8D  38        movb ra,@LASER(rx)              ; STA LASER,X       ; to fit it by storing the laser power for a pulse laser
     A962 0310     
21934 A964 06CE  14        swpb rx                         ;
21935                                                                          ; (given in POW) in LASER+X
21936               
21937 A966 020D  20        li   ra,>04*256                 ; LDA #4            ; Set A to 4 as we just overwrote the original value,
     A968 0400     
21938                                                                          ; and we still need it set correctly so we can continue
21939                                                                          ; through the conditional statements for all the other
21940                                                                          ; equipment
21941               
21942               et4_:
21943 A96A 028D  22        ci   ra,>05*256                 ; CMP #5            ; If A is not 5 (i.e. the item we've just bought is not
     A96C 0500     
21944 A96E 1620  14        jne  et5_                       ; BNE et5           ; an extra beam laser), skip to et5
21945               
21946 A970 0200  20        li   rtmp,qv_                   ; JSR qv            ; Print a menu listing the four views, with a "View ?"
     A972 AACA     
21947 A974 06A0  32        bl   @jsr                       ;
     A976 FE28     
21948                                                                          ; prompt, and ask for a view number, which is returned
21949                                                                          ; in X (which now contains 0-3)
21950               
21951 A978 D80E  30        movb rx,@T1                     ; STX T1            ; Store the view in T1 so we can retrieve it below
     A97A 0006     
21952               
21953 A97C 020D  20        li   ra,>05*256                 ; LDA #5            ; Set A to 5 as the call to qv will have overwritten
     A97E 0500     
21954                                                                          ; the original value, and we still need it set
21955                                                                          ; correctly so we can continue through the conditional
21956                                                                          ; statements for all the other equipment
21957               
21958 A980 06CE  14        swpb rx                         ;
21959 A982 D3AE  34        movb @LASER(rx),rx              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
     A984 0310     
21960 A986 06CE  14        swpb rx                         ;
21961 A988 130B  14        jeq  ed5_                       ; BEQ ed5           ; LASER+X, which contains the laser power for view X,
21962                                                                          ; is zero), jump to ed5 to buy a beam laser
21963               
21964               * BPL P%+4               \ This instruction is commented out in the original
21965                                                                          ; source, though it would have no effect (it would
21966                                                                          ; simply skip the BMI if A is positive, which is what
21967                                                                          ; BMI does anyway)
21968               
21969 A98A 11E4  14        jlt  ed7_                       ; BMI ed7           ; If there is a beam laser already mounted in the chosen
21970                                                                          ; view (i.e. LASER+X has bit 7 set, which indicates a
21971                                                                          ; beam laser rather than a pulse laser), skip back to
21972                                                                          ; ed7 to print a "Laser Present" error, beep and exit
21973                                                                          ; to the docking bay (i.e. show the Status Mode screen)
21974               
21975 A98C 020D  20        li   ra,>04*256                 ; LDA #4            ; If we get here then we already have a pulse laser in
     A98E 0400     
21976 A990 0200  20        li   rtmp,prx_                  ; JSR prx           ; the selected view, so we call prx to set (Y X) to the
     A992 AAAC     
21977 A994 06A0  32        bl   @jsr                       ;
     A996 FE28     
21978                                                                          ; price of equipment item number 4 (extra pulse laser)
21979                                                                          ; so we can give a refund of the pulse laser
21980               
21981 A998 0200  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, so we refund
     A99A A736     
21982 A99C 06A0  32        bl   @jsr                       ;
     A99E FE28     
21983                                                                          ; the price of the pulse laser we are exchanging for a
21984                                                                          ; new beam laser
21985               
21986               ed5_:
21987 A9A0 020D  20        li   ra,(POW+128)*256           ; LDA #POW+128      ; We just bought a beam laser for view X, so we need
     A9A2 8F00     
21988 A9A4 D3A0  30        movb @T1,rx                     ; LDX T1            ; to fit it by storing the laser power for a beam laser
     A9A6 0006     
21989 A9A8 06CE  14        swpb rx                         ;
21990 A9AA DB8D  38        movb ra,@LASER(rx)              ; STA LASER,X       ; (given in POW+128) in LASER+X, using the view number
     A9AC 0310     
21991 A9AE 06CE  14        swpb rx                         ;
21992                                                                          ; we stored in T1 earlier, as the call to prx will have
21993                                                                          ; overwritten the original value in X
21994               
21995               et5_:
21996 A9B0 020F  20        li   ry,>6f*256                 ; LDY #111          ; Set Y to recursive token 107 ("FUEL SCOOPS")
     A9B2 6F00     
21997               
21998 A9B4 028D  22        ci   ra,>06*256                 ; CMP #6            ; If A is not 6 (i.e. the item we've just bought is not
     A9B6 0600     
21999 A9B8 1620  14        jne  et6_                       ; BNE et6           ; a fuel scoop), skip to et6
22000               
22001 A9BA D3A0  30        movb @BST,rx                    ; LDX BST           ; If we already have fuel scoops fitted (i.e. BST is
     A9BC 0329     
22002 A9BE 131C  14        jeq  ed9_                       ; BEQ ed9           ; zero), jump to ed9, otherwise fall through into pres
22003                                                                          ; to show the error "Fuel Scoops Present", beep and
22004                                                                          ; exit to the docking bay (i.e. show the Status Mode
22005                                                                          ; screen)
22006               
22007               pres_:
22008                                                                          ; If we get here we need to show an error to say that
22009                                                                          ; the item whose name is in recursive token Y is already
22010                                                                          ; present, and then process a refund for the cost of
22011                                                                          ; item number A
22012 A9C0 D80F  30        movb ry,@K                      ; STY K             ; Store the item's name in K
     A9C2 003D     
22013               
22014 A9C4 0200  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     A9C6 AAAC     
22015 A9C8 06A0  32        bl   @jsr                       ;
     A9CA FE28     
22016                                                                          ; number A
22017               
22018 A9CC 0200  20        li   rtmp,MCASH                 ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, as the station
     A9CE A736     
22019 A9D0 06A0  32        bl   @jsr                       ;
     A9D2 FE28     
22020                                                                          ; already took the money for this item in the JSR eq
22021                                                                          ; instruction above, but we can't fit the item, so need
22022                                                                          ; our money back
22023               
22024 A9D4 D360  30        movb @K,ra                      ; LDA K             ; Print the recursive token in K (the item's name)
     A9D6 003D     
22025 A9D8 0200  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     A9DA 52E6     
22026 A9DC 06A0  32        bl   @jsr                       ;
     A9DE FE28     
22027               
22028 A9E0 020D  20        li   ra,>1f*256                 ; LDA #31           ; Print recursive token 145 ("PRESENT")
     A9E2 1F00     
22029 A9E4 0200  20        li   rtmp,TT27                  ; JSR TT27
     A9E6 ACA0     
22030 A9E8 06A0  32        bl   @jsr                       ;
     A9EA FE28     
22031               
22032               err_:
22033 A9EC 0200  20        li   rtmp,dn2_                  ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
     A9EE AA70     
22034 A9F0 06A0  32        bl   @jsr                       ;
     A9F2 FE28     
22035                                                                          ; second
22036               
22037 A9F4 0460  28        b    @BAY                       ; JMP BAY           ; Jump to BAY to go to the docking bay (i.e. show the
     A9F6 CDBC     
22038                                                                          ; Status Mode screen)
22039               
22040               ed9_:
22041 A9F8 7347  18        sb   rone,ra                    ; DEC BST           ; We just bought a shiny new fuel scoop, so set BST to
22042                                                                          ; &FF (as BST was 0 before the jump to ed9 above)
22043               
22044               et6_:
22045 A9FA B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 112 ("E.C.M.SYSTEM")
22046               
22047 A9FC 028D  22        ci   ra,>07*256                 ; CMP #7            ; If A is not 7 (i.e. the item we've just bought is not
     A9FE 0700     
22048 AA00 1604  14        jne  et7_                       ; BNE et7           ; an escape pod), skip to et7
22049               
22050 AA02 D3A0  30        movb @ESCP,rx                   ; LDX ESCP          ; If we already have an escape pod fitted (i.e. ESCP is
     AA04 032E     
22051 AA06 16DC  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Escape Pod
22052                                                                          ; Present", beep and exit to the docking bay (i.e. show
22053                                                                          ; the Status Mode screen)
22054               
22055 AA08 7347  18        sb   rone,ra                    ; DEC ESCP          ; Otherwise we just bought an escape pod, so set ESCP
22056                                                                          ; to &FF (as ESCP was 0 before the DEC instruction)
22057               
22058               et7_:
22059 AA0A B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 113 ("ENERGY BOMB")
22060               
22061 AA0C 028D  22        ci   ra,>08*256                 ; CMP #8            ; If A is not 8 (i.e. the item we've just bought is not
     AA0E 0800     
22062 AA10 1607  14        jne  et8_                       ; BNE et8           ; an energy bomb), skip to et8
22063               
22064 AA12 D3A0  30        movb @BOMB,rx                   ; LDX BOMB          ; If we already have an energy bomb fitted (i.e. BOMB
     AA14 032A     
22065 AA16 16D4  14        jne  pres_                      ; BNE pres          ; is non-zero), jump to pres to show the error "Energy
22066                                                                          ; Bomb Present", beep and exit to the docking bay (i.e.
22067                                                                          ; show the Status Mode screen)
22068               
22069 AA18 020E  20        li   rx,>7f*256                 ; LDX #&7F          ; Otherwise we just bought an energy bomb, so set BOMB
     AA1A 7F00     
22070 AA1C D80E  30        movb rx,@BOMB                   ; STX BOMB          ; to &7F
     AA1E 032A     
22071               
22072               et8_:
22073 AA20 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 114 ("ENERGY UNIT")
22074               
22075 AA22 028D  22        ci   ra,>09*256                 ; CMP #9            ; If A is not 9 (i.e. the item we've just bought is not
     AA24 0900     
22076 AA26 1604  14        jne  etA                        ; BNE etA           ; an energy unit), skip to etA
22077               
22078 AA28 D3A0  30        movb @ENGY,rx                   ; LDX ENGY          ; If we already have an energy unit fitted (i.e. ENGY is
     AA2A 032B     
22079 AA2C 16C9  14        jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Energy Unit
22080                                                                          ; Present", beep and exit to the docking bay (i.e. show
22081                                                                          ; the Status Mode screen)
22082               
22083 AA2E B347  18        ab   rone,ra                    ; INC ENGY          ; Otherwise we just picked up an energy unit, so set
22084                                                                          ; ENGY to 1 (as ENGY was 0 before the INC instruction)
22085               
22086               etA:
22087 AA30 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 115 ("DOCKING
22088                                                                          ; COMPUTERS")
22089               
22090 AA32 028D  22        ci   ra,>0a*256                 ; CMP #10           ; If A is not 10 (i.e. the item we've just bought is not
     AA34 0A00     
22091 AA36 1604  14        jne  etB                        ; BNE etB           ; a docking computer), skip to etB
22092               
22093 AA38 D3A0  30        movb @DKCMP,rx                  ; LDX DKCMP         ; If we already have a docking computer fitted (i.e.
     AA3A 032C     
22094 AA3C 16C1  14        jne  pres_                      ; BNE pres          ; DKCMP is non-zero), jump to pres to show the error
22095                                                                          ; "Docking Computer Present", beep and exit to the
22096                                                                          ; docking bay (i.e. show the Status Mode screen)
22097               
22098 AA3E 7347  18        sb   rone,ra                    ; DEC DKCMP         ; Otherwise we just got hold of a docking computer, so
22099                                                                          ; set DKCMP to &FF (as DKCMP was 0 before the DEC
22100                                                                          ; instruction)
22101               
22102               etB:
22103 AA40 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to recursive token 116 ("GALACTIC
22104                                                                          ; HYPERSPACE ")
22105               
22106 AA42 028D  22        ci   ra,>0b*256                 ; CMP #11           ; If A is not 11 (i.e. the item we've just bought is not
     AA44 0B00     
22107 AA46 1604  14        jne  et9_                       ; BNE et9           ; a galactic hyperdrive), skip to et9
22108               
22109 AA48 D3A0  30        movb @GHYP,rx                   ; LDX GHYP          ; If we already have a galactic hyperdrive fitted (i.e.
     AA4A 032D     
22110 AA4C 16B9  14        jne  pres_                      ; BNE pres          ; GHYP is non-zero), jump to pres to show the error
22111                                                                          ; "Galactic Hyperspace Present", beep and exit to the
22112                                                                          ; docking bay (i.e. show the Status Mode screen)
22113               
22114 AA4E 7347  18        sb   rone,ra                    ; DEC GHYP          ; Otherwise we just splashed out on a galactic
22115                                                                          ; hyperdrive, so set GHYP to &FF (as GHYP was 0 before
22116                                                                          ; the DEC instruction)
22117               
22118               et9_:
22119 AA50 0200  20        li   rtmp,dn_                   ; JSR dn            ; We are done buying equipment, so print the amount of
     AA52 AA5C     
22120 AA54 06A0  32        bl   @jsr                       ;
     AA56 FE28     
22121                                                                          ; cash left in the cash pot, then make a short, high
22122                                                                          ; beep to confirm the purchase, and delay for 1 second
22123               
22124 AA58 0460  28        b    @EQSHP                     ; JMP EQSHP         ; Jump back up to EQSHP to show the Equip Ship screen
     AA5A A7B4     
22125                                                                          ; again and see if we can't track down another bargain
22126               
22127               * ******************************************************************************
22128               *
22129               * Name: dn
22130               * Type: Subroutine
22131               * Category: Market
22132               * Summary: Print the amount of money we have left in the cash pot, then make
22133               * a short, high beep and delay for 1 second
22134               *
22135               * ******************************************************************************
22136               
22137               dn_:
22138 AA5C 0200  20        li   rtmp,TT162                 ; JSR TT162         ; Print a space
     AA5E A3D0     
22139 AA60 06A0  32        bl   @jsr                       ;
     AA62 FE28     
22140               
22141 AA64 020D  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:{cash} CR{crlf}")
     AA66 7700     
22142 AA68 0200  20        li   rtmp,spc_                  ; JSR spc           ; followed by a space
     AA6A 52E6     
22143 AA6C 06A0  32        bl   @jsr                       ;
     AA6E FE28     
22144               
22145                                                                          ; Fall through into dn2 to make a beep and delay for
22146                                                                          ; 1 second before returning from the subroutine
22147               
22148               * ******************************************************************************
22149               *
22150               * Name: dn2
22151               * Type: Subroutine
22152               * Category: Text
22153               * Summary: Make a short, high beep and delay for 1 second
22154               *
22155               * ******************************************************************************
22156               
22157               dn2_:
22158 AA70 0200  20        li   rtmp,BEEP                  ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep
     AA72 D33C     
22159 AA74 06A0  32        bl   @jsr                       ;
     AA76 FE28     
22160               
22161 AA78 020F  20        li   ry,>32*256                 ; LDY #50           ; Delay for 50 vertical syncs (50/50 = 1 second) and
     AA7A 3200     
22162 AA7C 0460  28        b    @DELAY                     ; JMP DELAY         ; return from the subroutine using a tail call
     AA7E 4FD0     
22163               
22164               * ******************************************************************************
22165               *
22166               * Name: eq
22167               * Type: Subroutine
22168               * Category: Equipment
22169               * Summary: Subtract the price of equipment from the cash pot
22170               *
22171               * ------------------------------------------------------------------------------
22172               *
22173               * If we have enough cash, subtract the price of a specified piece of equipment
22174               * from our cash pot and return from the subroutine. If we don't have enough
22175               * cash, exit to the docking bay (i.e. show the Status Mode screen).
22176               *
22177               * ------------------------------------------------------------------------------
22178               *
22179               * Arguments:
22180               *
22181               * A                   The item number of the piece of equipment (0-11) as
22182               * shown in the table at PRXS
22183               *
22184               * ******************************************************************************
22185               
22186               eq_:
22187 AA80 0200  20        li   rtmp,prx_                  ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
     AA82 AAAC     
22188 AA84 06A0  32        bl   @jsr                       ;
     AA86 FE28     
22189                                                                          ; number A
22190               
22191 AA88 0200  20        li   rtmp,LCASH                 ; JSR LCASH         ; Subtract (Y X) cash from the cash pot, but only if
     AA8A A6EA     
22192 AA8C 06A0  32        bl   @jsr                       ;
     AA8E FE28     
22193                                                                          ; we have enough cash
22194               
22195 AA90 181A  14        joc  c_                         ; BCS c             ; If the C flag is set then we did have enough cash for
22196                                                                          ; the transaction, so jump to c to return from the
22197                                                                          ; subroutine (as c contains an RTS)
22198               
22199 AA92 020D  20        li   ra,>c5*256                 ; LDA #197          ; Otherwise we don't have enough cash to buy this piece
     AA94 C500     
22200 AA96 0200  20        li   rtmp,prq_                  ; JSR prq           ; of equipment, so print recursive token 37 ("CASH")
     AA98 A2AE     
22201 AA9A 06A0  32        bl   @jsr                       ;
     AA9C FE28     
22202                                                                          ; followed by a question mark
22203               
22204 AA9E 0460  28        b    @err_                      ; JMP err           ; Jump to err to beep, pause and go to the docking bay
     AAA0 A9EC     
22205                                                                          ; (i.e. show the Status Mode screen)
22206               
22207               * ******************************************************************************
22208               *
22209               * Name: prx
22210               * Type: Subroutine
22211               * Category: Equipment
22212               * Summary: Return the price of a piece of equipment
22213               *
22214               * ------------------------------------------------------------------------------
22215               *
22216               * This routine returns the price of equipment as listed in the table at PRXS.
22217               *
22218               * ------------------------------------------------------------------------------
22219               *
22220               * Arguments:
22221               *
22222               * A                   The item number of the piece of equipment (0-11) as
22223               * shown in the table at PRXS
22224               *
22225               * ------------------------------------------------------------------------------
22226               *
22227               * Returns:
22228               *
22229               * (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
22230               *
22231               * ------------------------------------------------------------------------------
22232               *
22233               * Other entry points:
22234               *
22235               * prx-3               Return the price of the item with number A - 1
22236               *
22237               * c                   Contains an RTS
22238               *
22239               * ******************************************************************************
22240               
22241                      .sec                            ; SEC               ; Decrement A (for when this routine is called via
     **** ****     > SEC
0001 AAA2 0A18  18        sla  rmone,1
                   < elite.a99
22242                      .sbi (>01*256)                  ; SBC #1            ; prx-3)
     **** ****     > SBI
0001 AAA4 1801  14        joc  !
0002 AAA6 7347  18        sb   rone,ra
0003               !:
0004 AAA8 022D  22        ai   ra,-(>01*256)
     AAAA FF00     
                   < elite.a99
22243               
22244               prx_:
22245                      .asla                           ; ASL A             ; Set Y = A * 2, so it can act as an index into the
     **** ****     > ASLA
0001 AAAC 024D  22        andi ra,>ff00
     AAAE FF00     
0002 AAB0 0A1D  18        sla  ra,1
                   < elite.a99
22246 AAB2 D3CD  18        movb ra,ry                      ; TAY               ; PRXS table, which has two bytes per entry
22247               
22248 AAB4 06CF  14        swpb ry                         ;
22249 AAB6 D3AF  34        movb @PRXS(ry),rx               ; LDX PRXS,Y        ; Fetch the low byte of the price into X
     AAB8 3060     
22250 AABA 06CF  14        swpb ry                         ;
22251               
22252 AABC 06CF  14        swpb ry                         ;
22253 AABE D36F  34        movb @PRXS+1(ry),ra             ; LDA PRXS+1,Y      ; Fetch the high byte of the price into A and transfer
     AAC0 3061     
22254 AAC2 06CF  14        swpb ry                         ;
22255 AAC4 D3CD  18        movb ra,ry                      ; TAY               ; it to X, so the price is now in (Y X)
22256               
22257               c_:
22258 AAC6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AAC8 FE34     
22259               
22260               * ******************************************************************************
22261               *
22262               * Name: qv
22263               * Type: Subroutine
22264               * Category: Equipment
22265               * Summary: Print a menu of the four space views, for buying lasers
22266               *
22267               * ------------------------------------------------------------------------------
22268               *
22269               * Print a menu in the bottom-middle of the screen, at row 16, column 12, that
22270               * lists the four available space views, like this:
22271               *
22272               * 0 Front
22273               * 1 Rear
22274               * 2 Left
22275               * 3 Right
22276               *
22277               * Also print a "View ?" prompt and ask for a view number. The menu is shown
22278               * when we choose to buy a new laser in the Equip Ship screen.
22279               *
22280               * ------------------------------------------------------------------------------
22281               *
22282               * Returns:
22283               *
22284               * X                   The chosen view number (0-3)
22285               *
22286               * ******************************************************************************
22287               
22288               qv_:
22289 AACA 020F  20        li   ry,>10*256                 ; LDY #16           ; Move the text cursor to row 16, and at the same time
     AACC 1000     
22290 AACE D80F  30        movb ry,@YC                     ; STY YC            ; set Y to a counter going from 16 to 19 in the loop
     AAD0 002D     
22291                                                                          ; below
22292               
22293               qv1_:
22294 AAD2 020E  20        li   rx,>0c*256                 ; LDX #12           ; Move the text cursor to column 12
     AAD4 0C00     
22295 AAD6 D80E  30        movb rx,@XC                     ; STX XC
     AAD8 002C     
22296               
22297 AADA D34F  18        movb ry,ra                      ; TYA               ; Transfer the counter value from Y to A
22298               
22299                      .clc                            ; CLC               ; Print ASCII character "0" - 16 + A, so as A goes from
     **** ****     > CLC
0001 AADC 0A16  18        sla  rzero,1
                   < elite.a99
22300                      .adi (('0'-16)*256)             ; ADC #'0'-16       ; 16 to 19, this prints "0" through "3" followed by a
     **** ****     > ADI
0001 AADE 1701  14        jnc  !
0002 AAE0 B347  18        ab   rone,ra
0003               !:
0004 AAE2 022D  22        ai   ra,(('0'-16)*256)
     AAE4 2000     
                   < elite.a99
22301 AAE6 0200  20        li   rtmp,spc_                  ; JSR spc           ; space
     AAE8 52E6     
22302 AAEA 06A0  32        bl   @jsr                       ;
     AAEC FE28     
22303               
22304 AAEE D360  30        movb @YC,ra                     ; LDA YC            ; Print recursive text token 80 + YC, so as YC goes from
     AAF0 002D     
22305                      .clc                            ; CLC               ; 16 to 19, this prints "FRONT", "REAR", "LEFT" and
     **** ****     > CLC
0001 AAF2 0A16  18        sla  rzero,1
                   < elite.a99
22306                      .adi (>50*256)                  ; ADC #80           ; "RIGHT"
     **** ****     > ADI
0001 AAF4 1701  14        jnc  !
0002 AAF6 B347  18        ab   rone,ra
0003               !:
0004 AAF8 022D  22        ai   ra,(>50*256)
     AAFA 5000     
                   < elite.a99
22307 AAFC 0200  20        li   rtmp,TT27                  ; JSR TT27
     AAFE ACA0     
22308 AB00 06A0  32        bl   @jsr                       ;
     AB02 FE28     
22309               
22310 AB04 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row, and increment the
22311                                                                          ; counter in YC at the same time
22312               
22313 AB06 D3E0  30        movb @YC,ry                     ; LDY YC            ; Update Y with the incremented counter in YC
     AB08 002D     
22314               
22315 AB0A 028F  22        ci   ry,>14*256                 ; CPY #20           ; If Y < 20 then loop back up to qv1 to print the next
     AB0C 1400     
22316 AB0E 17E1  14        jnc  qv1_                       ; BCC qv1           ; view in the menu
22317               
22318               qv3_:
22319 AB10 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     AB12 4FFE     
22320 AB14 06A0  32        bl   @jsr                       ;
     AB16 FE28     
22321                                                                          ; and move the text cursor to column 1 on row 21, i.e.
22322                                                                          ; the start of the top row of the three bottom rows
22323               
22324               qv2_:
22325 AB18 020D  20        li   ra,>af*256                 ; LDA #175          ; Print recursive text token 15 ("VIEW ") followed by
     AB1A AF00     
22326 AB1C 0200  20        li   rtmp,prq_                  ; JSR prq           ; a question mark
     AB1E A2AE     
22327 AB20 06A0  32        bl   @jsr                       ;
     AB22 FE28     
22328               
22329 AB24 0200  20        li   rtmp,TT217                 ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
     AB26 D5B4     
22330 AB28 06A0  32        bl   @jsr                       ;
     AB2A FE28     
22331                                                                          ; the key's ASCII code in A (and X)
22332               
22333                      .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
     **** ****     > SEC
0001 AB2C 0A18  18        sla  rmone,1
                   < elite.a99
22334                      .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)
     **** ****     > SBI
0001 AB2E 1801  14        joc  !
0002 AB30 7347  18        sb   rone,ra
0003               !:
0004 AB32 022D  22        ai   ra,-(('0')*256)
     AB34 D000     
                   < elite.a99
22335               
22336 AB36 028D  22        ci   ra,>04*256                 ; CMP #4            ; If the number entered in A >= 4, then it is not a
     AB38 0400     
22337 AB3A 18EA  14        joc  qv3_                       ; BCS qv3           ; valid view number, so jump back to qv3 to try again
22338               
22339 AB3C D38D  18        movb ra,rx                      ; TAX               ; We have a valid view number, so transfer it to X
22340               
22341 AB3E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AB40 FE34     
22342               
22343               * ******************************************************************************
22344               *
22345               * Save ELTD.bin
22346               *
22347               * ******************************************************************************
22348               
22349                      ; PRINT "ELITE D"
22350                      ; PRINT "Assembled at ", ~CODE_D%
22351                      ; PRINT "Ends at ", ~P%
22352                      ; PRINT "Code size is ", ~(P% - CODE_D%)
22353                      ; PRINT "Execute at ", ~LOAD%
22354                      ; PRINT "Reload at ", ~LOAD_D%
22355               
22356                      ; PRINT "S.ELTD ", ~CODE_D%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_D%
22357                      ; SAVE "3-assembled-output/ELTD.bin", CODE_D%, P%, LOAD%
22358               
22359               * ******************************************************************************
22360               *
22361               * ELITE E FILE
22362               *
22363               * Produces the binary file ELTE.bin that gets loaded by elite-bcfs.asm.
22364               *
22365               * ******************************************************************************
22366               
22367               CODE_E.:
22368                      equ $
22369               
22370               LOAD_E.:
22371                      equ LOAD. + $ - CODE.
22372               
22373               * ******************************************************************************
22374               *
22375               * Name: Authors' names
22376               * Type: Variable
22377               * Category: Copy protection
22378               * Summary: The authors' names and a copyright notice, buried in the code
22379               *
22380               * ------------------------------------------------------------------------------
22381               *
22382               * This copyright notice is not used anywhere and it is obfuscated by EOR'ing
22383               * each character with 164, but presumably the authors wanted their names buried
22384               * in the code somewhere. Though they do also have recursive token 94, which
22385               * reads "BY D.BRABEN & I.BELL" and can be displayed on the title screen using
22386               * the "X" configuration option, so this isn't the only author name easter egg
22387               * in the game. It contains the following text:
22388               *
22389               * (C)Bell/Braben1984
22390               *
22391               * ******************************************************************************
22392               
22393 AB42 8C              byte '(' ^ 164
22394 AB43   E7            byte 'C' ^ 164
22395 AB44 8D              byte ')' ^ 164
22396 AB45   E6            byte 'B' ^ 164
22397 AB46 C1              byte 'e' ^ 164
22398 AB47   C8            byte 'l' ^ 164
22399 AB48 C8              byte 'l' ^ 164
22400 AB49   8B            byte '/' ^ 164
22401 AB4A E6              byte 'B' ^ 164
22402 AB4B   D6            byte 'r' ^ 164
22403 AB4C C5              byte 'a' ^ 164
22404 AB4D   C6            byte 'b' ^ 164
22405 AB4E C1              byte 'e' ^ 164
22406 AB4F   CA            byte 'n' ^ 164
22407 AB50 95              byte '1' ^ 164
22408 AB51   9D            byte '9' ^ 164
22409 AB52 9C              byte '8' ^ 164
22410 AB53   90            byte '4' ^ 164
22411               
22412               * ******************************************************************************
22413               *
22414               * Name: cpl
22415               * Type: Subroutine
22416               * Category: Universe
22417               * Summary: Print the selected system name
22418               * Deep dive: Generating system names
22419               * Galaxy and system seeds
22420               *
22421               * ------------------------------------------------------------------------------
22422               *
22423               * Print control code 3 (the selected system name, i.e. the one in the crosshairs
22424               * in the Short-range Chart).
22425               *
22426               * ******************************************************************************
22427               
22428               cpl_:
22429 AB54 020E  20        li   rx,>05*256                 ; LDX #5            ; First we need to back up the seeds in QQ15, so set up
     AB56 0500     
22430                                                                          ; a counter in X to cover three 16-bit seeds (i.e.
22431                                                                          ; 6 bytes)
22432               
22433               TT53:
22434 AB58 06CE  14        swpb rx                         ;
22435 AB5A D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy byte X from QQ15 to QQ19
     AB5C 0078     
22436 AB5E 06CE  14        swpb rx                         ;
22437 AB60 06CE  14        swpb rx                         ;
22438 AB62 DB8D  38        movb ra,@QQ19(rx)               ; STA QQ19,X
     AB64 007F     
22439 AB66 06CE  14        swpb rx                         ;
22440               
22441 AB68 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22442               
22443 AB6A 15F6  14        jgt  TT53                       ; BPL TT53          ; Loop back for the next byte to back up
22444               
22445 AB6C 020F  20        li   ry,>03*256                 ; LDY #3            ; Step 1: Now that the seeds are backed up, we can
     AB6E 0300     
22446                                                                          ; start the name-generation process. We will either
22447                                                                          ; need to loop three or four times, so for now set
22448                                                                          ; up a counter in Y to loop four times
22449               
22450                      .bit @QQ15                      ; BIT QQ15          ; Check bit 6 of s0_lo, which is stored in QQ15
     **** ****     > BIT
0001 AB70 D020  30        movb @QQ15,rtmp
     AB72 0078     
0002 AB74 0540  14        inv  rtmp
0003 AB76 D047  18        movb rone,rtmp2
0004 AB78 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22451               
22452                      .bvs B59                        ; BVS B59           ; If bit 6 is set then skip over the next instruction
     **** ****     > BVS
0001 AB7A 1801  14        joc  !
0002 AB7C 1001  14        jmp  B59
0003               !:
                   < elite.a99
22453               
22454 AB7E 73C7  18        sb   rone,ry                    ; DEY               ; Bit 6 is clear, so we only want to loop three times,
22455                                                                          ; so decrement the loop counter in Y
22456               
22457               B59:
22458 AB80 D80F  30        movb ry,@T                      ; STY T             ; Store the loop counter in T
     AB82 00D1     
22459               
22460               TT55:
22461 AB84 D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Step 2: Load s2_hi, which is stored in QQ15+5, and
     AB86 007D     
22462 AB88 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; extract bits 0-4 by AND'ing with %11111
     AB8A 1F00     
22463               
22464 AB8C 1306  14        jeq  B60                        ; BEQ B60           ; If all those bits are zero, then skip the following
22465                                                                          ; two instructions to go to step 3
22466               
22467 AB8E 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; We now have a number in the range 1-31, which we can
     AB90 8000     
22468                                                                          ; easily convert into a two-letter token, but first we
22469                                                                          ; need to add 128 (or set bit 7) to get a range of
22470                                                                          ; 129-159
22471               
22472 AB92 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the two-letter token in A
     AB94 ACA0     
22473 AB96 06A0  32        bl   @jsr                       ;
     AB98 FE28     
22474               
22475               B60:
22476 AB9A 0200  20        li   rtmp,TT54                  ; JSR TT54          ; Step 3: twist the seeds in QQ15
     AB9C 522A     
22477 AB9E 06A0  32        bl   @jsr                       ;
     ABA0 FE28     
22478               
22479 ABA2 7347  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
22480               
22481 ABA4 15EF  14        jgt  TT55                       ; BPL TT55          ; Loop back for the next two letters
22482               
22483 ABA6 020E  20        li   rx,>05*256                 ; LDX #5            ; We have printed the system name, so we can now
     ABA8 0500     
22484                                                                          ; restore the seeds we backed up earlier. Set up a
22485                                                                          ; counter in X to cover three 16-bit seeds (i.e. 6
22486                                                                          ; bytes)
22487               
22488               TT56:
22489 ABAA 06CE  14        swpb rx                         ;
22490 ABAC D36E  34        movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy byte X from QQ19 to QQ15
     ABAE 007F     
22491 ABB0 06CE  14        swpb rx                         ;
22492 ABB2 06CE  14        swpb rx                         ;
22493 ABB4 DB8D  38        movb ra,@QQ15(rx)               ; STA QQ15,X
     ABB6 0078     
22494 ABB8 06CE  14        swpb rx                         ;
22495               
22496 ABBA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22497               
22498 ABBC 15F6  14        jgt  TT56                       ; BPL TT56          ; Loop back for the next byte to restore
22499               
22500 ABBE 0460  28        b    @rts                       ; RTS               ; Once all the seeds are restored, return from the
     ABC0 FE34     
22501                                                                          ; subroutine
22502               
22503               * ******************************************************************************
22504               *
22505               * Name: cmn
22506               * Type: Subroutine
22507               * Category: Status
22508               * Summary: Print the commander's name
22509               *
22510               * ------------------------------------------------------------------------------
22511               *
22512               * Print control code 4 (the commander's name).
22513               *
22514               * ------------------------------------------------------------------------------
22515               *
22516               * Other entry points:
22517               *
22518               * cmn-1               Contains an RTS
22519               *
22520               * ******************************************************************************
22521               
22522               cmn_:
22523 ABC2 020F  20        li   ry,>00*256                 ; LDY #0            ; Set up a counter in Y, starting from 0
     ABC4 0000     
22524               
22525               QUL4:
22526 ABC6 06CF  14        swpb ry                         ;
22527 ABC8 D36F  34        movb @NA.(ry),ra                ; LDA NA%,Y         ; The commander's name is stored at NA%, so load the
     ABCA 2338     
22528 ABCC 06CF  14        swpb ry                         ;
22529                                                                          ; Y-th character from NA%
22530               
22531 ABCE 028D  22        ci   ra,>0d*256                 ; CMP #13           ; If we have reached the end of the name, return from
     ABD0 0D00     
22532 ABD2 1307  14        jeq  ypl_-1                     ; BEQ ypl-1         ; the subroutine (ypl-1 points to the RTS below)
22533               
22534 ABD4 0200  20        li   rtmp,TT26                  ; JSR TT26          ; Print the character we just loaded
     ABD6 341A     
22535 ABD8 06A0  32        bl   @jsr                       ;
     ABDA FE28     
22536               
22537 ABDC B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter
22538               
22539 ABDE 16F3  14        jne  QUL4                       ; BNE QUL4          ; Loop back for the next character
22540               
22541 ABE0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ABE2 FE34     
22542               
22543               * ******************************************************************************
22544               *
22545               * Name: ypl
22546               * Type: Subroutine
22547               * Category: Universe
22548               * Summary: Print the current system name
22549               *
22550               * ------------------------------------------------------------------------------
22551               *
22552               * Print control code 2 (the current system name).
22553               *
22554               * ------------------------------------------------------------------------------
22555               *
22556               * Other entry points:
22557               *
22558               * ypl-1               Contains an RTS
22559               *
22560               * ******************************************************************************
22561               
22562               ypl_:
22563 ABE4 D360  30        movb @MJ,ra                     ; LDA MJ            ; Check the mis-jump flag at MJ, and if it is non-zero
     ABE6 0D5C     
22564 ABE8 16EB  14        jne  cmn_-1                     ; BNE cmn-1         ; then we are in witchspace, and witchspace doesn't have
22565                                                                          ; a system name, so return from the subroutine (cmn-1
22566                                                                          ; contains an RTS)
22567               
22568 ABEA 0200  20        li   rtmp,TT62                  ; JSR TT62          ; Call TT62 below to swap the three 16-bit seeds in
     ABEC ABFA     
22569 ABEE 06A0  32        bl   @jsr                       ;
     ABF0 FE28     
22570                                                                          ; QQ2 and QQ15 (before the swap, QQ2 contains the seeds
22571                                                                          ; for the current system, while QQ15 contains the seeds
22572                                                                          ; for the selected system)
22573               
22574 ABF2 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Call cpl to print out the system name for the seeds
     ABF4 AB54     
22575 ABF6 06A0  32        bl   @jsr                       ;
     ABF8 FE28     
22576                                                                          ; in QQ15 (which now contains the seeds for the current
22577                                                                          ; system)
22578               
22579                                                                          ; Now we fall through into the TT62 subroutine, which
22580                                                                          ; will swap QQ2 and QQ15 once again, so everything goes
22581                                                                          ; back into the right place, and the RTS at the end of
22582                                                                          ; TT62 will return from the subroutine
22583               
22584               TT62:
22585 ABFA 020E  20        li   rx,>05*256                 ; LDX #5            ; Set up a counter in X for the three 16-bit seeds we
     ABFC 0500     
22586                                                                          ; want to swap (i.e. 6 bytes)
22587               
22588               TT78:
22589 ABFE 06CE  14        swpb rx                         ;
22590 AC00 D36E  34        movb @QQ15(rx),ra               ; LDA QQ15,X        ; Swap byte X between QQ2 and QQ15
     AC02 0078     
22591 AC04 06CE  14        swpb rx                         ;
22592 AC06 06CE  14        swpb rx                         ;
22593 AC08 D3AE  34        movb @QQ2(rx),rx                ; LDY QQ2,X
     AC0A 0F22     
22594 AC0C 06CE  14        swpb rx                         ;
22595 AC0E 06CE  14        swpb rx                         ;
22596 AC10 DB8D  38        movb ra,@QQ2(rx)                ; STA QQ2,X
     AC12 0F22     
22597 AC14 06CE  14        swpb rx                         ;
22598 AC16 DB8F  38        movb ry,@QQ15(rx)               ; STY QQ15,X
     AC18 0078     
22599               
22600 AC1A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22601               
22602 AC1C 15F0  14        jgt  TT78                       ; BPL TT78          ; Loop back for the next byte to swap
22603               
22604 AC1E 0460  28        b    @rts                       ; RTS               ; Once all bytes are swapped, return from the
     AC20 FE34     
22605                                                                          ; subroutine
22606               
22607               * ******************************************************************************
22608               *
22609               * Name: tal
22610               * Type: Subroutine
22611               * Category: Universe
22612               * Summary: Print the current galaxy number
22613               *
22614               * ------------------------------------------------------------------------------
22615               *
22616               * Print control code 1 (the current galaxy number, right-aligned to width 3).
22617               *
22618               * ******************************************************************************
22619               
22620               tal_:
22621                      .clc                            ; CLC               ; We don't want to print the galaxy number with a
     **** ****     > CLC
0001 AC22 0A16  18        sla  rzero,1
                   < elite.a99
22622                                                                          ; decimal point, so clear the C flag for pr2 to take as
22623                                                                          ; an argument
22624               
22625 AC24 D3A0  30        movb @GCNT,rx                   ; LDX GCNT          ; Load the current galaxy number from GCNT into X
     AC26 030F     
22626               
22627 AC28 B387  18        ab   rone,rx                    ; INX               ; Add 1 to the galaxy number, as the galaxy numbers
22628                                                                          ; are 0-7 internally, but we want to display them as
22629                                                                          ; galaxy 1 through 8
22630               
22631 AC2A 0460  28        b    @pr2_                      ; JMP pr2           ; Jump to pr2, which prints the number in X to a width
     AC2C 322C     
22632                                                                          ; of 3 figures, left-padding with spaces to a width of
22633                                                                          ; 3, and return from the subroutine using a tail call
22634               
22635               * ******************************************************************************
22636               *
22637               * Name: fwl
22638               * Type: Subroutine
22639               * Category: Status
22640               * Summary: Print fuel and cash levels
22641               *
22642               * ------------------------------------------------------------------------------
22643               *
22644               * Print control code 5 ("FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:",
22645               * control code 0).
22646               *
22647               * ******************************************************************************
22648               
22649               fwl_:
22650 AC2E 020D  20        li   ra,>69*256                 ; LDA #105          ; Print recursive token 105 ("FUEL") followed by a
     AC30 6900     
22651 AC32 0200  20        li   rtmp,TT68                  ; JSR TT68          ; colon
     AC34 AC94     
22652 AC36 06A0  32        bl   @jsr                       ;
     AC38 FE28     
22653               
22654 AC3A D3A0  30        movb @QQ14,rx                   ; LDX QQ14          ; Load the current fuel level from QQ14
     AC3C 030D     
22655               
22656                      .sec                            ; SEC               ; We want to print the fuel level with a decimal point,
     **** ****     > SEC
0001 AC3E 0A18  18        sla  rmone,1
                   < elite.a99
22657                                                                          ; so set the C flag for pr2 to take as an argument
22658               
22659 AC40 0200  20        li   rtmp,pr2_                  ; JSR pr2           ; Call pr2, which prints the number in X to a width of
     AC42 322C     
22660 AC44 06A0  32        bl   @jsr                       ;
     AC46 FE28     
22661                                                                          ; 3 figures (i.e. in the format x.x, which will always
22662                                                                          ; be exactly 3 characters as the maximum fuel is 7.0)
22663               
22664 AC48 020D  20        li   ra,>c3*256                 ; LDA #195          ; Print recursive token 35 ("LIGHT YEARS") followed by
     AC4A C300     
22665 AC4C 0200  20        li   rtmp,plf_                  ; JSR plf           ; a newline
     AC4E AC88     
22666 AC50 06A0  32        bl   @jsr                       ;
     AC52 FE28     
22667               
22668               PCASH:
22669 AC54 020D  20        li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:" then control code
     AC56 7700     
22670 AC58 1623  14        jne  TT27                       ; BNE TT27          ; 0, which prints cash levels, then " CR" and newline)
22671               
22672               * ******************************************************************************
22673               *
22674               * Name: csh
22675               * Type: Subroutine
22676               * Category: Status
22677               * Summary: Print the current amount of cash
22678               *
22679               * ------------------------------------------------------------------------------
22680               *
22681               * Print control code 0 (the current amount of cash, right-aligned to width 9,
22682               * followed by " CR" and a newline).
22683               *
22684               * ******************************************************************************
22685               
22686               csh_:
22687 AC5A 020E  20        li   rx,>03*256                 ; LDX #3            ; We are going to use the BPRNT routine to print out
     AC5C 0300     
22688                                                                          ; the current amount of cash, which is stored as a
22689                                                                          ; 32-bit number at location CASH. BPRNT prints out
22690                                                                          ; the 32-bit number stored in K, so before we call
22691                                                                          ; BPRNT, we need to copy the four bytes from CASH into
22692                                                                          ; K, so first we set up a counter in X for the 4 bytes
22693               
22694               pc1_:
22695 AC5E 06CE  14        swpb rx                         ;
22696 AC60 D36E  34        movb @CASH(rx),ra               ; LDA CASH,X        ; Copy byte X from CASH to K
     AC62 0309     
22697 AC64 06CE  14        swpb rx                         ;
22698 AC66 06CE  14        swpb rx                         ;
22699 AC68 DB8D  38        movb ra,@K(rx)                  ; STA K,X
     AC6A 003D     
22700 AC6C 06CE  14        swpb rx                         ;
22701               
22702 AC6E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
22703               
22704 AC70 15F6  14        jgt  pc1_                       ; BPL pc1           ; Loop back for the next byte to copy
22705               
22706 AC72 020D  20        li   ra,>09*256                 ; LDA #9            ; We want to print the cash amount using up to 9 digits
     AC74 0900     
22707 AC76 D80D  30        movb ra,@U                      ; STA U             ; (including the decimal point), so store this in U
     AC78 008F     
22708                                                                          ; for BRPNT to take as an argument
22709               
22710                      .sec                            ; SEC               ; We want to print the cash amount with a decimal point,
     **** ****     > SEC
0001 AC7A 0A18  18        sla  rmone,1
                   < elite.a99
22711                                                                          ; so set the C flag for BRPNT to take as an argument
22712               
22713 AC7C 0200  20        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the amount of cash to 9 digits with a decimal
     AC7E 324C     
22714 AC80 06A0  32        bl   @jsr                       ;
     AC82 FE28     
22715                                                                          ; point
22716               
22717 AC84 020D  20        li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR") followed by a
     AC86 E200     
22718                                                                          ; newline by falling through into plf
22719               
22720               * ******************************************************************************
22721               *
22722               * Name: plf
22723               * Type: Subroutine
22724               * Category: Text
22725               * Summary: Print a text token followed by a newline
22726               *
22727               * ------------------------------------------------------------------------------
22728               *
22729               * Arguments:
22730               *
22731               * A                   The text token to be printed
22732               *
22733               * ******************************************************************************
22734               
22735               plf_:
22736 AC88 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A
     AC8A ACA0     
22737 AC8C 06A0  32        bl   @jsr                       ;
     AC8E FE28     
22738               
22739 AC90 0460  28        b    @TT67                      ; JMP TT67          ; Jump to TT67 to print a newline and return from the
     AC92 52CE     
22740                                                                          ; subroutine using a tail call
22741               
22742               * ******************************************************************************
22743               *
22744               * Name: TT68
22745               * Type: Subroutine
22746               * Category: Text
22747               * Summary: Print a text token followed by a colon
22748               *
22749               * ------------------------------------------------------------------------------
22750               *
22751               * Arguments:
22752               *
22753               * A                   The text token to be printed
22754               *
22755               * ******************************************************************************
22756               
22757               TT68:
22758 AC94 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A and fall through into TT73
     AC96 ACA0     
22759 AC98 06A0  32        bl   @jsr                       ;
     AC9A FE28     
22760                                                                          ; to print a colon
22761               
22762               * ******************************************************************************
22763               *
22764               * Name: TT73
22765               * Type: Subroutine
22766               * Category: Text
22767               * Summary: Print a colon
22768               *
22769               * ******************************************************************************
22770               
22771               TT73:
22772 AC9C 020D  20        li   ra,(':')*256               ; LDA #':'          ; Set A to ASCII ":" and fall through into TT27 to
     AC9E 3A00     
22773                                                                          ; actually print the colon
22774               
22775               * ******************************************************************************
22776               *
22777               * Name: TT27
22778               * Type: Subroutine
22779               * Category: Text
22780               * Summary: Print a text token
22781               * Deep dive: Printing text tokens
22782               *
22783               * ------------------------------------------------------------------------------
22784               *
22785               * Print a text token (i.e. a character, control code, two-letter token or
22786               * recursive token).
22787               *
22788               * ------------------------------------------------------------------------------
22789               *
22790               * Arguments:
22791               *
22792               * A                   The text token to be printed
22793               *
22794               * ******************************************************************************
22795               
22796               TT27:
22797 ACA0 D38D  18        movb ra,rx                      ; TAX               ; Copy the token number from A to X. We can then keep
22798                                                                          ; decrementing X and testing it against zero, while
22799                                                                          ; keeping the original token number intact in A; this
22800                                                                          ; effectively implements a switch statement on the
22801                                                                          ; value of the token
22802               
22803 ACA2 13DB  14        jeq  csh_                       ; BEQ csh           ; If token = 0, this is control code 0 (current amount
22804                                                                          ; of cash and newline), so jump to csh to print the
22805                                                                          ; amount of cash and return from the subroutine using
22806                                                                          ; a tail call
22807               
22808 ACA4 116E  14        jlt  TT43                       ; BMI TT43          ; If token > 127, this is either a two-letter token
22809                                                                          ; (128-159) or a recursive token (160-255), so jump
22810                                                                          ; to TT43 to process tokens
22811               
22812 ACA6 7387  18        sb   rone,rx                    ; DEX               ; If token = 1, this is control code 1 (current galaxy
22813 ACA8 13BC  14        jeq  tal_                       ; BEQ tal           ; number), so jump to tal to print the galaxy number and
22814                                                                          ; return from the subroutine using a tail call
22815               
22816 ACAA 7387  18        sb   rone,rx                    ; DEX               ; If token = 2, this is control code 2 (current system
22817 ACAC 139B  14        jeq  ypl_                       ; BEQ ypl           ; name), so jump to ypl to print the current system name
22818                                                                          ; and return from the subroutine using a tail call
22819               
22820 ACAE 7387  18        sb   rone,rx                    ; DEX               ; If token > 3, skip the following instruction
22821 ACB0 1602  14        jne  B61                        ; BNE B61
22822               
22823 ACB2 0460  28        b    @cpl_                      ; JMP cpl           ; This token is control code 3 (selected system name)
     ACB4 AB54     
22824                                                                          ; so jump to cpl to print the selected system name
22825                                                                          ; and return from the subroutine using a tail call
22826               
22827               B61:
22828 ACB6 7387  18        sb   rone,rx                    ; DEX               ; If token = 4, this is control code 4 (commander
22829 ACB8 1384  14        jeq  cmn_                       ; BEQ cmn           ; name), so jump to cmm to print the commander name
22830                                                                          ; and return from the subroutine using a tail call
22831               
22832 ACBA 7387  18        sb   rone,rx                    ; DEX               ; If token = 5, this is control code 5 (fuel, newline,
22833 ACBC 13B8  14        jeq  fwl_                       ; BEQ fwl           ; cash, newline), so jump to fwl to print the fuel level
22834                                                                          ; and return from the subroutine using a tail call
22835               
22836 ACBE 7387  18        sb   rone,rx                    ; DEX               ; If token > 6, skip the following three instructions
22837 ACC0 1606  14        jne  B62                        ; BNE B62
22838               
22839 ACC2 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; This token is control code 6 (switch to Sentence
     ACC4 8000     
22840 ACC6 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; Case), so set bit 7 of QQ17 to switch to Sentence Case
     ACC8 007E     
22841 ACCA 0460  28        b    @rts                       ; RTS               ; and return from the subroutine as we are done
     ACCC FE34     
22842               
22843               B62:
22844 ACCE 7387  18        sb   rone,rx                    ; DEX               ; If token > 8, skip the following two instructions
22845 ACD0 7387  18        sb   rone,rx                    ; DEX
22846 ACD2 1604  14        jne  B63                        ; BNE B63
22847               
22848 ACD4 D80E  30        movb rx,@QQ17                   ; STX QQ17          ; This token is control code 8 (switch to ALL CAPS), so
     ACD6 007E     
22849 ACD8 0460  28        b    @rts                       ; RTS               ; set QQ17 to 0 to switch to ALL CAPS and return from
     ACDA FE34     
22850                                                                          ; the subroutine as we are done
22851               
22852               B63:
22853 ACDC 7387  18        sb   rone,rx                    ; DEX               ; If token = 9, this is control code 9 (tab to column
22854 ACDE 1339  14        jeq  crlf_                      ; BEQ crlf          ; 21 and print a colon), so jump to crlf
22855               
22856 ACE0 028D  22        ci   ra,>60*256                 ; CMP #96           ; By this point, token is either 7, or in 10-127.
     ACE2 6000     
22857 ACE4 186E  14        joc  ex_                        ; BCS ex            ; Check token number in A and if token >= 96, then the
22858                                                                          ; token is in 96-127, which is a recursive token, so
22859                                                                          ; jump to ex, which prints recursive tokens in this
22860                                                                          ; range (i.e. where the recursive token number is
22861                                                                          ; correct and doesn't need correcting)
22862               
22863 ACE6 028D  22        ci   ra,>0e*256                 ; CMP #14           ; If token < 14, skip the following two instructions
     ACE8 0E00     
22864 ACEA 1703  14        jnc  B64                        ; BCC B64
22865               
22866 ACEC 028D  22        ci   ra,>20*256                 ; CMP #32           ; If token < 32, then this means token is in 14-31, so
     ACEE 2000     
22867 ACF0 172B  14        jnc  qw_                        ; BCC qw            ; this is a recursive token that needs 114 adding to it
22868                                                                          ; to get the recursive token number, so jump to qw
22869                                                                          ; which will do this
22870               
22871                                                                          ; By this point, token is either 7 (beep) or in 10-13
22872                                                                          ; (line feeds and carriage returns), or in 32-95
22873                                                                          ; (ASCII letters, numbers and punctuation)
22874               
22875               B64:
22876 ACF2 D3A0  30        movb @QQ17,rx                   ; LDX QQ17          ; Fetch QQ17, which controls letter case, into X
     ACF4 007E     
22877               
22878 ACF6 1343  14        jeq  TT74                       ; BEQ TT74          ; If QQ17 = 0, then ALL CAPS is set, so jump to TT74
22879                                                                          ; to print this character as is (i.e. as a capital)
22880               
22881 ACF8 1113  14        jlt  TT41                       ; BMI TT41          ; If QQ17 has bit 7 set, then we are using Sentence
22882                                                                          ; Case, so jump to TT41, which will print the
22883                                                                          ; character in upper or lower case, depending on
22884                                                                          ; whether this is the first letter in a word
22885               
22886                      .bit @QQ17                      ; BIT QQ17          ; If we get here, QQ17 is not 0 and bit 7 is clear, so
     **** ****     > BIT
0001 ACFA D020  30        movb @QQ17,rtmp
     ACFC 007E     
0002 ACFE 0540  14        inv  rtmp
0003 AD00 D047  18        movb rone,rtmp2
0004 AD02 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22887                      .bvs TT46                       ; BVS TT46          ; either it is bit 6 that is set, or some other flag in
     **** ****     > BVS
0001 AD04 1801  14        joc  !
0002 AD06 1032  14        jmp  TT46
0003               !:
                   < elite.a99
22888                                                                          ; QQ17 is set (bits 0-5). So check whether bit 6 is set.
22889                                                                          ; If it is, then ALL CAPS has been set (as bit 7 is
22890                                                                          ; clear) but bit 6 is still indicating that the next
22891                                                                          ; character should be printed in lower case, so we need
22892                                                                          ; to fix this. We do this with a jump to TT46, which
22893                                                                          ; will print this character in upper case and clear bit
22894                                                                          ; 6, so the flags are consistent with ALL CAPS going
22895                                                                          ; forward
22896               
22897                                                                          ; If we get here, some other flag is set in QQ17 (one
22898                                                                          ; of bits 0-5 is set), which shouldn't happen in this
22899                                                                          ; version of Elite. If this were the case, then we
22900                                                                          ; would fall through into TT42 to print in lower case,
22901                                                                          ; which is how printing all words in lower case could
22902                                                                          ; be supported (by setting QQ17 to 1, say)
22903               
22904               * ******************************************************************************
22905               *
22906               * Name: TT42
22907               * Type: Subroutine
22908               * Category: Text
22909               * Summary: Print a letter in lower case
22910               *
22911               * ------------------------------------------------------------------------------
22912               *
22913               * Arguments:
22914               *
22915               * A                   The character to be printed. Can be one of the
22916               * following:
22917               *
22918               * * 7 (beep)
22919               *
22920               * * 10-13 (line feeds and carriage returns)
22921               *
22922               * * 32-95 (ASCII capital letters, numbers and
22923               * punctuation)
22924               *
22925               * ------------------------------------------------------------------------------
22926               *
22927               * Other entry points:
22928               *
22929               * TT44                Jumps to TT26 to print the character in A (used to
22930               * enable us to use a branch instruction to jump to TT26)
22931               *
22932               * ******************************************************************************
22933               
22934               TT42:
22935 AD08 028D  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     AD0A 4100     
22936 AD0C 1707  14        jnc  TT44                       ; BCC TT44          ; to TT26 (via TT44) to print the character as is, as
22937                                                                          ; we don't care about the character's case
22938               
22939 AD0E 028D  22        ci   ra,('Z'+1)*256             ; CMP #'Z'+1        ; If A >= (ASCII "Z" + 1), then this is also
     AD10 5B00     
22940 AD12 1804  14        joc  TT44                       ; BCS TT44          ; punctuation, so jump to TT26 (via TT44) to print the
22941                                                                          ; character as is, as we don't care about the
22942                                                                          ; character's case
22943               
22944                      .adi (>20*256)                  ; ADC #32           ; Add 32 to the character, to convert it from upper to
     **** ****     > ADI
0001 AD14 1701  14        jnc  !
0002 AD16 B347  18        ab   rone,ra
0003               !:
0004 AD18 022D  22        ai   ra,(>20*256)
     AD1A 2000     
                   < elite.a99
22945                                                                          ; lower case
22946               
22947               TT44:
22948 AD1C 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     AD1E 341A     
22949               
22950               * ******************************************************************************
22951               *
22952               * Name: TT41
22953               * Type: Subroutine
22954               * Category: Text
22955               * Summary: Print a letter according to Sentence Case
22956               *
22957               * ------------------------------------------------------------------------------
22958               *
22959               * The rules for printing in Sentence Case are as follows:
22960               *
22961               * * If QQ17 bit 6 is set, print lower case (via TT45)
22962               *
22963               * * If QQ17 bit 6 is clear, then:
22964               *
22965               * * If character is punctuation, just print it
22966               *
22967               * * If character is a letter, set QQ17 bit 6 and print letter as a capital
22968               *
22969               * ------------------------------------------------------------------------------
22970               *
22971               * Arguments:
22972               *
22973               * A                   The character to be printed. Can be one of the
22974               * following:
22975               *
22976               * * 7 (beep)
22977               *
22978               * * 10-13 (line feeds and carriage returns)
22979               *
22980               * * 32-95 (ASCII capital letters, numbers and
22981               * punctuation)
22982               *
22983               * X                   Contains the current value of QQ17
22984               *
22985               * QQ17                Bit 7 is set
22986               *
22987               * ******************************************************************************
22988               
22989               TT41:
22990                                                                          ; If we get here, then QQ17 has bit 7 set, so we are in
22991                                                                          ; Sentence Case
22992                      .bit @QQ17                      ; BIT QQ17          ; If QQ17 also has bit 6 set, jump to TT45 to print
     **** ****     > BIT
0001 AD20 D020  30        movb @QQ17,rtmp
     AD22 007E     
0002 AD24 0540  14        inv  rtmp
0003 AD26 D047  18        movb rone,rtmp2
0004 AD28 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
22993                      .bvs TT45                       ; BVS TT45          ; this character in lower case
     **** ****     > BVS
0001 AD2A 1801  14        joc  !
0002 AD2C 1017  14        jmp  TT45
0003               !:
                   < elite.a99
22994               
22995                                                                          ; If we get here, then QQ17 has bit 6 clear and bit 7
22996                                                                          ; set, so we are in Sentence Case and we need to print
22997                                                                          ; the next letter in upper case
22998               
22999 AD2E 028D  22        ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
     AD30 4100     
23000 AD32 1725  14        jnc  TT74                       ; BCC TT74          ; to TT26 (via TT44) to print the character as is, as
23001                                                                          ; we don't care about the character's case
23002               
23003                      .pha                            ; PHA               ; Otherwise this is a letter, so store the token number
     **** ****     > PHA
0001 AD34 D68D  30        movb ra,*rsp
0002 AD36 060A  14        dec  rsp
                   < elite.a99
23004               
23005 AD38 D34E  18        movb rx,ra                      ; TXA               ; Set bit 6 in QQ17 (X contains the current QQ17)
23006 AD3A 026D  22        ori  ra,>40*256                 ; ORA #%1000000     ; so the next letter after this one is printed in lower
     AD3C 4000     
23007 AD3E D80D  30        movb ra,@QQ17                   ; STA QQ17          ; case
     AD40 007E     
23008               
23009                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 AD42 058A  14        inc  rsp
0002 AD44 D35A  26        movb *rsp,ra
                   < elite.a99
23010               
23011 AD46 16EA  14        jne  TT44                       ; BNE TT44          ; Jump to TT26 (via TT44) to print the character in A
23012                                                                          ; (this BNE is effectively a JMP as A will never be
23013                                                                          ; zero)
23014               
23015               * ******************************************************************************
23016               *
23017               * Name: qw
23018               * Type: Subroutine
23019               * Category: Text
23020               * Summary: Print a recursive token in the range 128-145
23021               *
23022               * ------------------------------------------------------------------------------
23023               *
23024               * Print a recursive token where the token number is in 128-145 (so the value
23025               * passed to TT27 is in the range 14-31).
23026               *
23027               * ------------------------------------------------------------------------------
23028               *
23029               * Arguments:
23030               *
23031               * A                   A value from 128-145, which refers to a recursive token
23032               * in the range 14-31
23033               *
23034               * ******************************************************************************
23035               
23036               qw_:
23037                      .adi (>72*256)                  ; ADC #114          ; This is a recursive token in the range 0-95, so add
     **** ****     > ADI
0001 AD48 1701  14        jnc  !
0002 AD4A B347  18        ab   rone,ra
0003               !:
0004 AD4C 022D  22        ai   ra,(>72*256)
     AD4E 7200     
                   < elite.a99
23038 AD50 1638  14        jne  ex_                        ; BNE ex            ; 114 to the argument to get the token number 128-145
23039                                                                          ; and jump to ex to print it
23040               
23041               * ******************************************************************************
23042               *
23043               * Name: crlf
23044               * Type: Subroutine
23045               * Category: Text
23046               * Summary: Tab to column 21 and print a colon
23047               *
23048               * ------------------------------------------------------------------------------
23049               *
23050               * Print control code 9 (tab to column 21 and print a colon). The subroutine
23051               * name is pretty misleading, as it doesn't have anything to do with carriage
23052               * returns or line feeds.
23053               *
23054               * ******************************************************************************
23055               
23056               crlf_:
23057 AD52 020D  20        li   ra,>15*256                 ; LDA #21           ; Set the X-column in XC to 21
     AD54 1500     
23058 AD56 D80D  30        movb ra,@XC                     ; STA XC
     AD58 002C     
23059               
23060 AD5A 16A0  14        jne  TT73                       ; BNE TT73          ; Jump to TT73, which prints a colon (this BNE is
23061                                                                          ; effectively a JMP as A will never be zero)
23062               
23063               * ******************************************************************************
23064               *
23065               * Name: TT45
23066               * Type: Subroutine
23067               * Category: Text
23068               * Summary: Print a letter in lower case
23069               *
23070               * ------------------------------------------------------------------------------
23071               *
23072               * This routine prints a letter in lower case. Specifically:
23073               *
23074               * * If QQ17 = 255, abort printing this character as printing is disabled
23075               *
23076               * * If this is a letter then print in lower case
23077               *
23078               * * Otherwise this is punctuation, so clear bit 6 in QQ17 and print
23079               *
23080               * ------------------------------------------------------------------------------
23081               *
23082               * Arguments:
23083               *
23084               * A                   The character to be printed. Can be one of the
23085               * following:
23086               *
23087               * * 7 (beep)
23088               *
23089               * * 10-13 (line feeds and carriage returns)
23090               *
23091               * * 32-95 (ASCII capital letters, numbers and
23092               * punctuation)
23093               *
23094               * X                   Contains the current value of QQ17
23095               *
23096               * QQ17                Bits 6 and 7 are set
23097               *
23098               * ******************************************************************************
23099               
23100               TT45:
23101                                                                          ; If we get here, then QQ17 has bit 6 and 7 set, so we
23102                                                                          ; are in Sentence Case and we need to print the next
23103                                                                          ; letter in lower case
23104 AD5C 028E  22        ci   rx,>ff*256                 ; CPX #255          ; If QQ17 = 255 then printing is disabled, so return
     AD5E FF00     
23105 AD60 1602  14        jne  FIX006                     ; BNE FIX006        ; from the subroutine (as TT48 contains an RTS)
23106 AD62 0460  28        b    @TT48                      ; JMP TT48
     AD64 AE58     
23107               
23108               FIX006:
23109 AD66 028D  22        ci   ra,('A')*256               ; CMP #'A'          ; If A >= ASCII "A", then jump to TT42, which will
     AD68 4100     
23110 AD6A 18CE  14        joc  TT42                       ; BCS TT42          ; print the letter in lowercase
23111               
23112                                                                          ; Otherwise this is not a letter, it's punctuation, so
23113                                                                          ; this is effectively a word break. We therefore fall
23114                                                                          ; through to TT46 to print the character and set QQ17
23115                                                                          ; to ensure the next word starts with a capital letter
23116               
23117               * ******************************************************************************
23118               *
23119               * Name: TT46
23120               * Type: Subroutine
23121               * Category: Text
23122               * Summary: Print a character and switch to capitals
23123               *
23124               * ------------------------------------------------------------------------------
23125               *
23126               * Print a character and clear bit 6 in QQ17, so that the next letter that gets
23127               * printed after this will start with a capital letter.
23128               *
23129               * ------------------------------------------------------------------------------
23130               *
23131               * Arguments:
23132               *
23133               * A                   The character to be printed. Can be one of the
23134               * following:
23135               *
23136               * * 7 (beep)
23137               *
23138               * * 10-13 (line feeds and carriage returns)
23139               *
23140               * * 32-95 (ASCII capital letters, numbers and
23141               * punctuation)
23142               *
23143               * X                   Contains the current value of QQ17
23144               *
23145               * QQ17                Bits 6 and 7 are set
23146               *
23147               * ******************************************************************************
23148               
23149               TT46:
23150                      .pha                            ; PHA               ; Store the token number
     **** ****     > PHA
0001 AD6C D68D  30        movb ra,*rsp
0002 AD6E 060A  14        dec  rsp
                   < elite.a99
23151               
23152 AD70 D34E  18        movb rx,ra                      ; TXA               ; Clear bit 6 in QQ17 (X contains the current QQ17) so
23153 AD72 024D  22        andi ra,>bf*256                 ; AND #%10111111    ; the next letter after this one is printed in upper
     AD74 BF00     
23154 AD76 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; case
     AD78 007E     
23155               
23156                      .pla                            ; PLA               ; Restore the token number into A
     **** ****     > PLA
0001 AD7A 058A  14        inc  rsp
0002 AD7C D35A  26        movb *rsp,ra
                   < elite.a99
23157               
23158                                                                          ; Now fall through into TT74 to print the character
23159               
23160               * ******************************************************************************
23161               *
23162               * Name: TT74
23163               * Type: Subroutine
23164               * Category: Text
23165               * Summary: Print a character
23166               *
23167               * ------------------------------------------------------------------------------
23168               *
23169               * Arguments:
23170               *
23171               * A                   The character to be printed
23172               *
23173               * ******************************************************************************
23174               
23175               TT74:
23176 AD7E 0460  28        b    @TT26                      ; JMP TT26          ; Print the character in A
     AD80 341A     
23177               
23178               * ******************************************************************************
23179               *
23180               * Name: TT43
23181               * Type: Subroutine
23182               * Category: Text
23183               * Summary: Print a two-letter token or recursive token 0-95
23184               *
23185               * ------------------------------------------------------------------------------
23186               *
23187               * Print a two-letter token, or a recursive token where the token number is in
23188               * 0-95 (so the value passed to TT27 is in the range 160-255).
23189               *
23190               * ------------------------------------------------------------------------------
23191               *
23192               * Arguments:
23193               *
23194               * A                   One of the following:
23195               *
23196               * * 128-159 (two-letter token)
23197               *
23198               * * 160-255 (the argument to TT27 that refers to a
23199               * recursive token in the range 0-95)
23200               *
23201               * ******************************************************************************
23202               
23203               TT43:
23204 AD82 028D  22        ci   ra,>a0*256                 ; CMP #160          ; If token >= 160, then this is a recursive token, so
     AD84 A000     
23205 AD86 1819  14        joc  TT47                       ; BCS TT47          ; jump to TT47 below to process it
23206               
23207 AD88 024D  22        andi ra,>7f*256                 ; AND #127          ; This is a two-letter token with number 128-159. The
     AD8A 7F00     
23208                      .asla                           ; ASL A             ; set of two-letter tokens is stored in a lookup table
     **** ****     > ASLA
0001 AD8C 024D  22        andi ra,>ff00
     AD8E FF00     
0002 AD90 0A1D  18        sla  ra,1
                   < elite.a99
23209                                                                          ; at QQ16, with each token taking up two bytes, so to
23210                                                                          ; convert this into the token's position in the table,
23211                                                                          ; we subtract 128 (or just clear bit 7) and multiply
23212                                                                          ; by 2 (or shift left)
23213               
23214 AD92 D3CD  18        movb ra,ry                      ; TAY               ; Transfer the token's position into Y so we can look
23215                                                                          ; up the token using absolute indexed mode
23216               
23217 AD94 06CF  14        swpb ry                         ;
23218 AD96 D36F  34        movb @QQ16(ry),ra               ; LDA QQ16,Y        ; Get the first letter of the token and print it
     AD98 D6AE     
23219 AD9A 06CF  14        swpb ry                         ;
23220 AD9C 0200  20        li   rtmp,TT27                  ; JSR TT27
     AD9E ACA0     
23221 ADA0 06A0  32        bl   @jsr                       ;
     ADA2 FE28     
23222               
23223 ADA4 06CF  14        swpb ry                         ;
23224 ADA6 D36F  34        movb @QQ16+1(ry),ra             ; LDA QQ16+1,Y      ; Get the second letter of the token
     ADA8 D6AF     
23225 ADAA 06CF  14        swpb ry                         ;
23226               
23227 ADAC 028D  22        ci   ra,('?')*256               ; CMP #'?'          ; If the second letter of the token is a question mark
     ADAE 3F00     
23228 ADB0 1602  14        jne  FIX007                     ; BNE FIX007        ; then this is a one-letter token, so just return from
23229                                                                          ; the subroutine without printing (as TT48 contains an
23230                                                                          ; RTS)
23231 ADB2 0460  28        b    @TT48                      ; JMP TT48
     ADB4 AE58     
23232               FIX007:
23233 ADB6 0460  28        b    @TT27                      ; JMP TT27          ; Print the second letter and return from the
     ADB8 ACA0     
23234                                                                          ; subroutine
23235               
23236               TT47:
23237                      .sbi (>a0*256)                  ; SBC #160          ; This is a recursive token in the range 160-255, so
     **** ****     > SBI
0001 ADBA 1801  14        joc  !
0002 ADBC 7347  18        sb   rone,ra
0003               !:
0004 ADBE 022D  22        ai   ra,-(>A0*256)
     ADC0 6000     
                   < elite.a99
23238                                                                          ; subtract 160 from the argument to get the token
23239                                                                          ; number 0-95 and fall through into ex to print it
23240               
23241               * ******************************************************************************
23242               *
23243               * Name: ex
23244               * Type: Subroutine
23245               * Category: Text
23246               * Summary: Print a recursive token
23247               * Deep dive: Printing text tokens
23248               *
23249               * ------------------------------------------------------------------------------
23250               *
23251               * This routine works its way through the recursive text tokens that are stored
23252               * in tokenised form in the table at QQ18, and when it finds token number A,
23253               * it prints it. Tokens are null-terminated in memory and fill three pages,
23254               * but there is no lookup table as that would consume too much memory, so the
23255               * only way to find the correct token is to start at the beginning and look
23256               * through the table byte by byte, counting tokens as we go until we are in the
23257               * right place. This approach might not be terribly speed efficient, but it is
23258               * certainly memory-efficient.
23259               *
23260               * ------------------------------------------------------------------------------
23261               *
23262               * Arguments:
23263               *
23264               * A                   The recursive token to be printed, in the range 0-148
23265               *
23266               * ------------------------------------------------------------------------------
23267               *
23268               * Other entry points:
23269               *
23270               * TT48                Contains an RTS
23271               *
23272               * ******************************************************************************
23273               
23274               ex_:
23275 ADC2 D38D  18        movb ra,rx                      ; TAX               ; Copy the token number into X
23276               
23277 ADC4 020D  20        li   ra,((QQ18)%256)*256        ; LDA #LO(QQ18)     ; Set V(1 0) to point to the recursive token table at
     ADC6 0000     
23278 ADC8 D80D  30        movb ra,@V                      ; STA V             ; location QQ18
     ADCA 0022     
23279 ADCC 020D  20        li   ra,((QQ18)/256)*256        ; LDA #HI(QQ18)
     ADCE 0400     
23280 ADD0 D80D  30        movb ra,@V+1                    ; STA V+1
     ADD2 0023     
23281               
23282 ADD4 020F  20        li   ry,>00*256                 ; LDY #0            ; Set a counter Y to point to the character offset
     ADD6 0000     
23283                                                                          ; as we scan through the table
23284               
23285 ADD8 D34E  18        movb rx,ra                      ; TXA               ; Copy the token number back into A, so both A and X
23286                                                                          ; now contain the token number we want to print
23287               
23288 ADDA 1313  14        jeq  TT50                       ; BEQ TT50          ; If the token number we want is 0, then we have
23289                                                                          ; already found the token we are looking for, so jump
23290                                                                          ; to TT50, otherwise start working our way through the
23291                                                                          ; null-terminated token table until we find the X-th
23292                                                                          ; token
23293               
23294               TT51:
23295                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch the Y-th character from the token table page
     **** ****     > LD_IND_Y_IDX
0001 ADDC D820  42        movb @V,@rtmplb
     ADDE 0022     
     ADE0 8301     
0002 ADE2 D020  30        movb @V+1,rtmp
     ADE4 0023     
0003 ADE6 06CF  14        swpb ry
0004 ADE8 A00F  18        a    ry,rtmp
0005 ADEA 06CF  14        swpb ry
0006 ADEC D350  26        movb *rtmp,RA
                   < elite.a99
23296                                                                          ; we are currently scanning
23297               
23298 ADEE 1304  14        jeq  TT49                       ; BEQ TT49          ; If the character is null, we've reached the end of
23299                                                                          ; this token, so jump to TT49
23300               
23301 ADF0 B3C7  18        ab   rone,ry                    ; INY               ; Increment character pointer and loop back around for
23302 ADF2 16F4  14        jne  TT51                       ; BNE TT51          ; the next character in this token, assuming Y hasn't
23303                                                                          ; yet wrapped around to 0
23304               
23305 ADF4 B347  18        ab   rone,ra                    ; INC V+1           ; If it has wrapped round to 0, we have just crossed
23306 ADF6 16F2  14        jne  TT51                       ; BNE TT51          ; into a new page, so increment V+1 so that V points
23307                                                                          ; to the start of the new page
23308               
23309               TT49:
23310 ADF8 B3C7  18        ab   rone,ry                    ; INY               ; Increment the character pointer
23311               
23312 ADFA 1601  14        jne  TT59                       ; BNE TT59          ; If Y hasn't just wrapped around to 0, skip the next
23313                                                                          ; instruction
23314               
23315 ADFC B347  18        ab   rone,ra                    ; INC V+1           ; We have just crossed into a new page, so increment
23316                                                                          ; V+1 so that V points to the start of the new page
23317               
23318               TT59:
23319 ADFE 7387  18        sb   rone,rx                    ; DEX               ; We have just reached a new token, so decrement the
23320                                                                          ; token number we are looking for
23321               
23322 AE00 16ED  14        jne  TT51                       ; BNE TT51          ; Assuming we haven't yet reached the token number in
23323                                                                          ; X, look back up to keep fetching characters
23324               
23325               TT50:
23326                                                                          ; We have now reached the correct token in the token
23327                                                                          ; table, with Y pointing to the start of the token as
23328                                                                          ; an offset within the page pointed to by V, so let's
23329                                                                          ; print the recursive token. Because recursive tokens
23330                                                                          ; can contain other recursive tokens, we need to store
23331                                                                          ; our current state on the stack, so we can retrieve
23332                                                                          ; it after printing each character in this token
23333 AE02 D34F  18        movb ry,ra                      ; TYA               ; Store the offset in Y on the stack
23334                      .pha                            ; PHA
     **** ****     > PHA
0001 AE04 D68D  30        movb ra,*rsp
0002 AE06 060A  14        dec  rsp
                   < elite.a99
23335               
23336 AE08 D360  30        movb @V+1,ra                    ; LDA V+1           ; Store the high byte of V (the page containing the
     AE0A 0023     
23337                      .pha                            ; PHA               ; token we have found) on the stack, so the stack now
     **** ****     > PHA
0001 AE0C D68D  30        movb ra,*rsp
0002 AE0E 060A  14        dec  rsp
                   < elite.a99
23338                                                                          ; contains the address of the start of this token
23339               
23340                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the character at offset Y in the token table,
     **** ****     > LD_IND_Y_IDX
0001 AE10 D820  42        movb @V,@rtmplb
     AE12 0022     
     AE14 8301     
0002 AE16 D020  30        movb @V+1,rtmp
     AE18 0023     
0003 AE1A 06CF  14        swpb ry
0004 AE1C A00F  18        a    ry,rtmp
0005 AE1E 06CF  14        swpb ry
0006 AE20 D350  26        movb *rtmp,RA
                   < elite.a99
23341                                                                          ; which is the next character of this token that we
23342                                                                          ; want to print
23343               
23344                      .eoi ((RE)*256)                 ; EOR #RE           ; Tokens are stored in memory having been EOR'd with the
     **** ****     > EOI
0001 AE22 0200  20        li   rtmp,((RE)*256)
     AE24 2300     
0002 AE26 2B40  18        xor  rtmp,ra
                   < elite.a99
23345                                                                          ; value of RE - which is 35 for all versions of Elite
23346                                                                          ; except for NES, where RE is 62 - so we repeat the
23347                                                                          ; EOR to get the actual character to print
23348               
23349 AE28 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Print the text token in A, which could be a letter,
     AE2A ACA0     
23350 AE2C 06A0  32        bl   @jsr                       ;
     AE2E FE28     
23351                                                                          ; number, control code, two-letter token or another
23352                                                                          ; recursive token
23353               
23354                      .pla                            ; PLA               ; Restore the high byte of V (the page containing the
     **** ****     > PLA
0001 AE30 058A  14        inc  rsp
0002 AE32 D35A  26        movb *rsp,ra
                   < elite.a99
23355 AE34 D80D  30        movb ra,@V+1                    ; STA V+1           ; token we have found) into V+1
     AE36 0023     
23356               
23357                      .pla                            ; PLA               ; Restore the offset into Y
     **** ****     > PLA
0001 AE38 058A  14        inc  rsp
0002 AE3A D35A  26        movb *rsp,ra
                   < elite.a99
23358 AE3C D3CD  18        movb ra,ry                      ; TAY
23359               
23360 AE3E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next character in the
23361                                                                          ; token we are printing
23362               
23363 AE40 1601  14        jne  B65                        ; BNE B65           ; If Y is zero then we have just crossed into a new
23364 AE42 B347  18        ab   rone,ra                    ; INC V+1           ; page, so increment V+1 so that V points to the start
23365                                                                          ; of the new page
23366               
23367               B65:
23368                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the next character we want to print into A
     **** ****     > LD_IND_Y_IDX
0001 AE44 D820  42        movb @V,@rtmplb
     AE46 0022     
     AE48 8301     
0002 AE4A D020  30        movb @V+1,rtmp
     AE4C 0023     
0003 AE4E 06CF  14        swpb ry
0004 AE50 A00F  18        a    ry,rtmp
0005 AE52 06CF  14        swpb ry
0006 AE54 D350  26        movb *rtmp,RA
                   < elite.a99
23369               
23370 AE56 16D5  14        jne  TT50                       ; BNE TT50          ; If this is not the null character at the end of the
23371                                                                          ; token, jump back up to TT50 to print the next
23372                                                                          ; character, otherwise we are done printing
23373               
23374               TT48:
23375 AE58 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AE5A FE34     
23376               
23377               * ******************************************************************************
23378               *
23379               * Name: DOEXP
23380               * Type: Subroutine
23381               * Category: Drawing ships
23382               * Summary: Draw an exploding ship
23383               * Deep dive: Drawing explosion clouds
23384               * Generating random numbers
23385               *
23386               * ******************************************************************************
23387               
23388               EX2:
23389 AE5C D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bits 5 and 7 of the ship's byte #31 to denote that
     AE5E 0072     
23390 AE60 026D  22        ori  ra,>a0*256                 ; ORA #%10100000    ; the ship is exploding and has been killed
     AE62 A000     
23391 AE64 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     AE66 0072     
23392               
23393 AE68 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     AE6A FE34     
23394               
23395               DOEXP:
23396 AE6C D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; If bit 6 of the ship's byte #31 is clear, then the
     AE6E 0072     
23397 AE70 024D  22        andi ra,>40*256                 ; AND #%01000000    ; ship is not already exploding so there is no existing
     AE72 4000     
23398 AE74 1304  14        jeq  B66                        ; BEQ B66           ; explosion cloud to remove, so skip the following
23399                                                                          ; instruction
23400               
23401 AE76 0200  20        li   rtmp,PTCLS                 ; JSR PTCLS         ; Call PTCLS to remove the existing cloud by drawing it
     AE78 AFB4     
23402 AE7A 06A0  32        bl   @jsr                       ;
     AE7C FE28     
23403                                                                          ; again
23404               
23405               B66:
23406 AE7E D360  30        movb @INWK+6,ra                 ; LDA INWK+6        ; Set T = z_lo
     AE80 0059     
23407 AE82 D80D  30        movb ra,@T                      ; STA T
     AE84 00D1     
23408               
23409 AE86 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi, so (A T) = z
     AE88 005A     
23410               
23411 AE8A 028D  22        ci   ra,>20*256                 ; CMP #32           ; If z_hi < 32, skip the next two instructions
     AE8C 2000     
23412 AE8E 1703  14        jnc  B67                        ; BCC B67
23413               
23414 AE90 020D  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and jump to yy (this BNE is effectively a
     AE92 FE00     
23415 AE94 1615  14        jne  yy_                        ; BNE yy            ; JMP, as A is never zero)
23416               
23417               B67:
23418                      .asl @T                         ; ASL T             ; Shift (A T) left twice
     **** ****     > ASL
0001 AE96 D020  30        movb @T,rtmp
     AE98 00D1     
0002 AE9A 0240  22        andi rtmp,>ff00
     AE9C FF00     
0003 AE9E 0A10  18        sla  rtmp,1
0004 AEA0 D800  30        movb rtmp,@T
     AEA2 00D1     
                   < elite.a99
23419 AEA4 06A0  32        bl   @rola                      ; ROL A
     AEA6 FE3E     
23420                      .asl @T                         ; ASL T
     **** ****     > ASL
0001 AEA8 D020  30        movb @T,rtmp
     AEAA 00D1     
0002 AEAC 0240  22        andi rtmp,>ff00
     AEAE FF00     
0003 AEB0 0A10  18        sla  rtmp,1
0004 AEB2 D800  30        movb rtmp,@T
     AEB4 00D1     
                   < elite.a99
23421 AEB6 06A0  32        bl   @rola                      ; ROL A
     AEB8 FE3E     
23422               
23423                      .sec                            ; SEC               ; And then shift A left once more, inserting a 1 into
     **** ****     > SEC
0001 AEBA 0A18  18        sla  rmone,1
                   < elite.a99
23424 AEBC 06A0  32        bl   @rola                      ; ROL A             ; bit 0
     AEBE FE3E     
23425               
23426                                                                          ; Overall, the above multiplies A by 8 and makes sure it
23427                                                                          ; is at least 1, to leave a one-byte distance in A. We
23428                                                                          ; can use this as the distance for our cloud, to ensure
23429                                                                          ; that the explosion cloud is visible even for ships
23430                                                                          ; that blow up a long way away
23431               
23432               yy_:
23433 AEC0 D80D  30        movb ra,@Q                      ; STA Q             ; Store the distance to the explosion in Q
     AEC2 0090     
23434               
23435 AEC4 020F  20        li   ry,>01*256                 ; LDY #1            ; Fetch byte #1 of the ship line heap, which contains
     AEC6 0100     
23436                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud counter
     **** ****     > LD_IND_Y_IDX
0001 AEC8 D820  42        movb @XX19,@rtmplb
     AECA 0074     
     AECC 8301     
0002 AECE D020  30        movb @XX19+1,rtmp
     AED0 0075     
0003 AED2 06CF  14        swpb ry
0004 AED4 A00F  18        a    ry,rtmp
0005 AED6 06CF  14        swpb ry
0006 AED8 D350  26        movb *rtmp,RA
                   < elite.a99
23437               
23438                      .adi (>04*256)                  ; ADC #4            ; Add 4 to the cloud counter, so it ticks onwards every
     **** ****     > ADI
0001 AEDA 1701  14        jnc  !
0002 AEDC B347  18        ab   rone,ra
0003               !:
0004 AEDE 022D  22        ai   ra,(>04*256)
     AEE0 0400     
                   < elite.a99
23439                                                                          ; we redraw it
23440               
23441 AEE2 18BC  14        joc  EX2                        ; BCS EX2           ; If the addition overflowed, jump up to EX2 to update
23442                                                                          ; the explosion flags and return from the subroutine
23443               
23444                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the updated cloud counter in byte #1 of the ship
     **** ****     > ST_IND_Y_IDX
0001 AEE4 D820  42        movb @XX19,@rtmplb
     AEE6 0074     
     AEE8 8301     
0002 AEEA D020  30        movb @XX19+1,rtmp
     AEEC 0075     
0003 AEEE 06CF  14        swpb ry
0004 AEF0 A00F  18        a    ry,rtmp
0005 AEF2 06CF  14        swpb ry
0006 AEF4 D40D  30        movb RA,*rtmp
                   < elite.a99
23445                                                                          ; line heap
23446               
23447 AEF6 0200  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     AEF8 495C     
23448 AEFA 06A0  32        bl   @jsr                       ;
     AEFC FE28     
23449                                                                          ;
23450                                                                          ; (P R) = 256 * A / Q
23451                                                                          ; = 256 * cloud counter / distance
23452                                                                          ;
23453                                                                          ; We are going to use this as our cloud size, so the
23454                                                                          ; further away the cloud, the smaller it is, and as the
23455                                                                          ; cloud counter ticks onward, the cloud expands
23456               
23457 AEFE D360  30        movb @P,ra                      ; LDA P             ; Set A = P, so we now have:
     AF00 001B     
23458                                                                          ;
23459                                                                          ; (A R) = 256 * cloud counter / distance
23460               
23461 AF02 028D  22        ci   ra,>1c*256                 ; CMP #&1C          ; If A < 28, skip the next two instructions
     AF04 1C00     
23462 AF06 1703  14        jnc  B68                        ; BCC B68
23463               
23464 AF08 020D  20        li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and skip the following (this BNE is
     AF0A FE00     
23465 AF0C 161B  14        jne  LABEL_1                    ; BNE LABEL_1       ; effectively a JMP as A is never zero)
23466               
23467               B68:
23468                      .asl @R                         ; ASL R             ; Shift (A R) left three times to multiply by 8
     **** ****     > ASL
0001 AF0E D020  30        movb @R,rtmp
     AF10 0091     
0002 AF12 0240  22        andi rtmp,>ff00
     AF14 FF00     
0003 AF16 0A10  18        sla  rtmp,1
0004 AF18 D800  30        movb rtmp,@R
     AF1A 0091     
                   < elite.a99
23469 AF1C 06A0  32        bl   @rola                      ; ROL A
     AF1E FE3E     
23470                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 AF20 D020  30        movb @R,rtmp
     AF22 0091     
0002 AF24 0240  22        andi rtmp,>ff00
     AF26 FF00     
0003 AF28 0A10  18        sla  rtmp,1
0004 AF2A D800  30        movb rtmp,@R
     AF2C 0091     
                   < elite.a99
23471 AF2E 06A0  32        bl   @rola                      ; ROL A
     AF30 FE3E     
23472                      .asl @R                         ; ASL R
     **** ****     > ASL
0001 AF32 D020  30        movb @R,rtmp
     AF34 0091     
0002 AF36 0240  22        andi rtmp,>ff00
     AF38 FF00     
0003 AF3A 0A10  18        sla  rtmp,1
0004 AF3C D800  30        movb rtmp,@R
     AF3E 0091     
                   < elite.a99
23473 AF40 06A0  32        bl   @rola                      ; ROL A
     AF42 FE3E     
23474               
23475                                                                          ; Overall, the above multiplies (A R) by 8 to leave a
23476                                                                          ; one-byte cloud size in A, given by the following:
23477                                                                          ;
23478                                                                          ; A = 8 * cloud counter / distance
23479               
23480               LABEL_1:
23481 AF44 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to 0
23482               
23483                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the cloud size in byte #0 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 AF46 D820  42        movb @XX19,@rtmplb
     AF48 0074     
     AF4A 8301     
0002 AF4C D020  30        movb @XX19+1,rtmp
     AF4E 0075     
0003 AF50 06CF  14        swpb ry
0004 AF52 A00F  18        a    ry,rtmp
0005 AF54 06CF  14        swpb ry
0006 AF56 D40D  30        movb RA,*rtmp
                   < elite.a99
23484               
23485 AF58 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 6 of the ship's byte #31 to denote that the
     AF5A 0072     
23486 AF5C 024D  22        andi ra,>bf*256                 ; AND #%10111111    ; explosion has not yet been drawn
     AF5E BF00     
23487 AF60 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     AF62 0072     
23488               
23489 AF64 024D  22        andi ra,>08*256                 ; AND #%00001000    ; If bit 3 of the ship's byte #31 is clear, then nothing
     AF66 0800     
23490 AF68 1602  14        jne  FIX008                     ; BNE FIX008        ; is being drawn on-screen for this ship anyway, so
23491 AF6A 0460  28        b    @TT48                      ; JMP TT48          ; return from the subroutine (as TT48 contains an RTS)
     AF6C AE58     
23492               
23493               FIX008:
23494 AF6E 020F  20        li   ry,>02*256                 ; LDY #2            ; Otherwise it's time to draw an explosion cloud, so
     AF70 0200     
23495                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; fetch byte #2 of the ship line heap into Y, which we
     **** ****     > LD_IND_Y_IDX
0001 AF72 D820  42        movb @XX19,@rtmplb
     AF74 0074     
     AF76 8301     
0002 AF78 D020  30        movb @XX19+1,rtmp
     AF7A 0075     
0003 AF7C 06CF  14        swpb ry
0004 AF7E A00F  18        a    ry,rtmp
0005 AF80 06CF  14        swpb ry
0006 AF82 D350  26        movb *rtmp,RA
                   < elite.a99
23496 AF84 D3CD  18        movb ra,ry                      ; TAY               ; set to the explosion count for this ship (i.e. the
23497                                                                          ; number of vertices used as origins for explosion
23498                                                                          ; clouds)
23499                                                                          ;
23500                                                                          ; The explosion count is stored as 4 * n + 6, where n is
23501                                                                          ; the number of vertices, so the following loop copies
23502                                                                          ; the coordinates of the first n vertices from the heap
23503                                                                          ; at XX3, which is where we stored all the visible
23504                                                                          ; vertex coordinates in part 8 of the LL9 routine, and
23505                                                                          ; sticks them in the ship line heap pointed to by XX19,
23506                                                                          ; starting at byte #7 (so it leaves the first 6 bytes of
23507                                                                          ; the ship line heap alone)
23508               
23509               EXL1:
23510 AF86 06CF  14        swpb ry                         ;
23511 AF88 D36F  34        movb @XX3-7(ry),ra              ; LDA XX3-7,Y       ; Copy byte Y-7 from the XX3 heap, into the Y-th byte of
     AF8A 00F9     
23512 AF8C 06CF  14        swpb ry                         ;
23513                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 AF8E D820  42        movb @XX19,@rtmplb
     AF90 0074     
     AF92 8301     
0002 AF94 D020  30        movb @XX19+1,rtmp
     AF96 0075     
0003 AF98 06CF  14        swpb ry
0004 AF9A A00F  18        a    ry,rtmp
0005 AF9C 06CF  14        swpb ry
0006 AF9E D40D  30        movb RA,*rtmp
                   < elite.a99
23514               
23515 AFA0 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
23516               
23517 AFA2 028F  22        ci   ry,>06*256                 ; CPY #6            ; Keep copying vertex coordinates into the ship line
     AFA4 0600     
23518 AFA6 16EF  14        jne  EXL1                       ; BNE EXL1          ; heap until Y = 6 (which will copy n vertices, where n
23519                                                                          ; is the number of vertices we should be exploding)
23520               
23521 AFA8 D360  30        movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 of the ship's byte #31 to denote that the
     AFAA 0072     
23522 AFAC 026D  22        ori  ra,>40*256                 ; ORA #%01000000    ; explosion has been drawn (as it's about to be)
     AFAE 4000     
23523 AFB0 D80D  30        movb ra,@INWK+31                ; STA INWK+31
     AFB2 0072     
23524               
23525               PTCLS:
23526                                                                          ; This part of the routine actually draws the explosion
23527                                                                          ; cloud
23528 AFB4 020F  20        li   ry,>00*256                 ; LDY #0            ; Fetch byte #0 of the ship line heap, which contains
     AFB6 0000     
23529                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud size we stored above, and store it in Q
     **** ****     > LD_IND_Y_IDX
0001 AFB8 D820  42        movb @XX19,@rtmplb
     AFBA 0074     
     AFBC 8301     
0002 AFBE D020  30        movb @XX19+1,rtmp
     AFC0 0075     
0003 AFC2 06CF  14        swpb ry
0004 AFC4 A00F  18        a    ry,rtmp
0005 AFC6 06CF  14        swpb ry
0006 AFC8 D350  26        movb *rtmp,RA
                   < elite.a99
23530 AFCA D80D  30        movb ra,@Q                      ; STA Q
     AFCC 0090     
23531               
23532 AFCE B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #1
23533               
23534                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #1 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 AFD0 D820  42        movb @XX19,@rtmplb
     AFD2 0074     
     AFD4 8301     
0002 AFD6 D020  30        movb @XX19+1,rtmp
     AFD8 0075     
0003 AFDA 06CF  14        swpb ry
0004 AFDC A00F  18        a    ry,rtmp
0005 AFDE 06CF  14        swpb ry
0006 AFE0 D350  26        movb *rtmp,RA
                   < elite.a99
23535                                                                          ; the cloud counter. We are now going to process this
23536                                                                          ; into the number of particles in each vertex's cloud
23537               
23538 AFE2 1503  14        jgt  B69                        ; BPL B69           ; If the cloud counter < 128, then we are in the first
23539                                                                          ; half of the cloud's existence, so skip the next
23540                                                                          ; instruction
23541               
23542                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the value of A so that in the second half of the
     **** ****     > EOI
0001 AFE4 0200  20        li   rtmp,(>FF*256)
     AFE6 FF00     
0002 AFE8 2B40  18        xor  rtmp,ra
                   < elite.a99
23543                                                                          ; cloud's existence, A counts down instead of up
23544               
23545               B69:
23546 AFEA 091D  18        srl  ra,1                       ; LSR A             ; Divide A by 8 so that is has a maximum value of 15
23547 AFEC 091D  18        srl  ra,1                       ; LSR A
23548 AFEE 091D  18        srl  ra,1                       ; LSR A
23549               
23550 AFF0 026D  22        ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1 and store it in U, to
     AFF2 0100     
23551 AFF4 D80D  30        movb ra,@U                      ; STA U             ; give us the number of particles in the explosion for
     AFF6 008F     
23552                                                                          ; each vertex
23553               
23554 AFF8 B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #2
23555               
23556                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #2 of the ship line heap, which contains
     **** ****     > LD_IND_Y_IDX
0001 AFFA D820  42        movb @XX19,@rtmplb
     AFFC 0074     
     AFFE 8301     
0002 B000 D020  30        movb @XX19+1,rtmp
     B002 0075     
0003 B004 06CF  14        swpb ry
0004 B006 A00F  18        a    ry,rtmp
0005 B008 06CF  14        swpb ry
0006 B00A D350  26        movb *rtmp,RA
                   < elite.a99
23557 B00C D80D  30        movb ra,@TGT                    ; STA TGT           ; the explosion count for this ship (i.e. the number of
     B00E 00A0     
23558                                                                          ; vertices used as origins for explosion clouds) and
23559                                                                          ; store it in TGT
23560               
23561 B010 D360  30        movb @RAND+1,ra                 ; LDA RAND+1        ; Fetch the current random number seed in RAND+1 and
     B012 0001     
23562                      .pha                            ; PHA               ; store it on the stack, so we can re-randomise the
     **** ****     > PHA
0001 B014 D68D  30        movb ra,*rsp
0002 B016 060A  14        dec  rsp
                   < elite.a99
23563                                                                          ; seeds when we are done
23564               
23565 B018 020F  20        li   ry,>06*256                 ; LDY #6            ; Set Y = 6 to point to the byte before the first vertex
     B01A 0600     
23566                                                                          ; coordinate we stored on the ship line heap above (we
23567                                                                          ; increment it below so it points to the first vertex)
23568               
23569               EXL5:
23570 B01C 020E  20        li   rx,>03*256                 ; LDX #3            ; We are about to fetch a pair of coordinates from the
     B01E 0300     
23571                                                                          ; ship line heap, so set a counter in X for 4 bytes
23572               
23573               EXL3:
23574 B020 B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next byte
23575                                                                          ; from the coordinate we are copying
23576               
23577                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Copy the Y-th byte from the ship line heap to the X-th
     **** ****     > LD_IND_Y_IDX
0001 B022 D820  42        movb @XX19,@rtmplb
     B024 0074     
     B026 8301     
0002 B028 D020  30        movb @XX19+1,rtmp
     B02A 0075     
0003 B02C 06CF  14        swpb ry
0004 B02E A00F  18        a    ry,rtmp
0005 B030 06CF  14        swpb ry
0006 B032 D350  26        movb *rtmp,RA
                   < elite.a99
23578 B034 06CE  14        swpb rx                         ;
23579 B036 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X          ; byte of K3
     B038 00D2     
23580 B03A 06CE  14        swpb rx                         ;
23581               
23582 B03C 7387  18        sb   rone,rx                    ; DEX               ; Decrement the X index
23583               
23584 B03E 15F0  14        jgt  EXL3                       ; BPL EXL3          ; Loop back to EXL3 until we have copied all four bytes
23585               
23586                                                                          ; The above loop copies the vertex coordinates from the
23587                                                                          ; ship line heap to K3, reversing them as we go, so it
23588                                                                          ; sets the following:
23589                                                                          ;
23590                                                                          ; K3+3 = x_lo
23591                                                                          ; K3+2 = x_hi
23592                                                                          ; K3+1 = y_lo
23593                                                                          ; K3+0 = y_hi
23594               
23595 B040 D80F  30        movb ry,@CNT                    ; STY CNT           ; Set CNT to the index that points to the next vertex on
     B042 00A4     
23596                                                                          ; the ship line heap
23597               
23598 B044 020F  20        li   ry,>02*256                 ; LDY #2            ; Set Y = 2, which we will use to point to bytes #3 to
     B046 0200     
23599                                                                          ; #6, after incrementing it
23600               
23601                                                                          ; This next loop copies bytes #3 to #6 from the ship
23602                                                                          ; line heap into the four random number seeds in RAND to
23603                                                                          ; RAND+3, EOR'ing them with the vertex index so they are
23604                                                                          ; different for every vertex. This enables us to
23605                                                                          ; generate random numbers for drawing each vertex that
23606                                                                          ; are random but repeatable, which we need when we
23607                                                                          ; redraw the cloud to remove it
23608                                                                          ;
23609                                                                          ; Note that we haven't actually set the values of bytes
23610                                                                          ; #3 to #6 in the ship line heap, so we have no idea
23611                                                                          ; what they are, we just use what's already there. But
23612                                                                          ; the fact that those bytes are stored for this ship
23613                                                                          ; means we can repeat the random generation of the
23614                                                                          ; cloud, which is the important bit
23615               
23616               EXL2:
23617 B048 B3C7  18        ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next
23618                                                                          ; random number seed to copy
23619               
23620                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y-th byte from the ship line heap
     **** ****     > LD_IND_Y_IDX
0001 B04A D820  42        movb @XX19,@rtmplb
     B04C 0074     
     B04E 8301     
0002 B050 D020  30        movb @XX19+1,rtmp
     B052 0075     
0003 B054 06CF  14        swpb ry
0004 B056 A00F  18        a    ry,rtmp
0005 B058 06CF  14        swpb ry
0006 B05A D350  26        movb *rtmp,RA
                   < elite.a99
23621               
23622                      .eor @CNT                       ; EOR CNT           ; EOR with the vertex index, so the seeds are different
     **** ****     > EOR
0001 B05C D020  30        movb @CNT,rtmp
     B05E 00A4     
0002 B060 2B40  18        xor  rtmp,ra
                   < elite.a99
23623                                                                          ; for each vertex
23624               
23625 B062 06CF  14        swpb ry                         ;
23626 B064 DBCD  38        movb ra,@>FFFD(ry)              ; STA &FFFD,Y       ; Y is going from 3 to 6, so this stores the four bytes
     B066 FFFD     
23627 B068 06CF  14        swpb ry                         ;
23628                                                                          ; in memory locations &00, &01, &02 and &03, which are
23629                                                                          ; the memory locations of RAND through RAND+3
23630               
23631 B06A 028F  22        ci   ry,>06*256                 ; CPY #6            ; Loop back to EXL2 until Y = 6, which means we have
     B06C 0600     
23632 B06E 16EC  14        jne  EXL2                       ; BNE EXL2          ; copied four bytes
23633               
23634 B070 D3E0  30        movb @U,ry                      ; LDY U             ; Set Y to the number of particles in the explosion for
     B072 008F     
23635                                                                          ; each vertex, which we stored in U above. We will now
23636                                                                          ; use this as a loop counter to iterate through all the
23637                                                                          ; particles in the explosion
23638               
23639               EXL4:
23640 B074 0200  20        li   rtmp,DORND2                ; JSR DORND2        ; Set ZZ to a random number, making sure the C flag
     B076 C7CE     
23641 B078 06A0  32        bl   @jsr                       ;
     B07A FE28     
23642 B07C D80D  30        movb ra,@ZZ                     ; STA ZZ            ; doesn't affect the outcome
     B07E 0097     
23643               
23644 B080 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Set (A R) = (y_hi y_lo)
     B082 00D3     
23645 B084 D80D  30        movb ra,@R                      ; STA R             ; = y
     B086 0091     
23646 B088 D360  30        movb @K3,ra                     ; LDA K3
     B08A 00D2     
23647               
23648 B08C 0200  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     B08E B0F0     
23649 B090 06A0  32        bl   @jsr                       ;
     B092 FE28     
23650                                                                          ; = y +/- random * cloud size
23651               
23652 B094 1627  14        jne  EX11                       ; BNE EX11          ; If A is non-zero, the particle is off-screen as the
23653                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23654                                                                          ; the next particle
23655               
23656 B096 028E  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If X > the y-coordinate of the bottom of the screen,
     B098 BF00     
23657 B09A 1824  14        joc  EX11                       ; BCS EX11          ; the particle is off the bottom of the screen, so jump
23658                                                                          ; to EX11 to do the next particle
23659               
23660                                                                          ; Otherwise X contains a random y-coordinate within the
23661                                                                          ; cloud
23662               
23663 B09C D80E  30        movb rx,@Y1                     ; STX Y1            ; Set Y1 = our random y-coordinate within the cloud
     B09E 0032     
23664               
23665 B0A0 D360  30        movb @K3+3,ra                   ; LDA K3+3          ; Set (A R) = (x_hi x_lo)
     B0A2 00D5     
23666 B0A4 D80D  30        movb ra,@R                      ; STA R
     B0A6 0091     
23667 B0A8 D360  30        movb @K3+2,ra                   ; LDA K3+2
     B0AA 00D4     
23668               
23669 B0AC 0200  20        li   rtmp,EXS1                  ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
     B0AE B0F0     
23670 B0B0 06A0  32        bl   @jsr                       ;
     B0B2 FE28     
23671                                                                          ; = x +/- random * cloud size
23672               
23673 B0B4 1606  14        jne  EX4                        ; BNE EX4           ; If A is non-zero, the particle is off-screen as the
23674                                                                          ; coordinate is bigger than 255), so jump to EX11 to do
23675                                                                          ; the next particle
23676               
23677                                                                          ; Otherwise X contains a random x-coordinate within the
23678                                                                          ; cloud
23679               
23680 B0B6 D360  30        movb @Y1,ra                     ; LDA Y1            ; Set A = our random y-coordinate within the cloud
     B0B8 0032     
23681               
23682 B0BA 0200  20        li   rtmp,PIXEL                 ; JSR PIXEL         ; Draw a point at screen coordinate (X, A) with the
     B0BC 2974     
23683 B0BE 06A0  32        bl   @jsr                       ;
     B0C0 FE28     
23684                                                                          ; point size determined by the distance in ZZ
23685               
23686               EX4:
23687 B0C2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter for the next particle
23688               
23689 B0C4 15D7  14        jgt  EXL4                       ; BPL EXL4          ; Loop back to EXL4 until we have done all the particles
23690                                                                          ; in the cloud
23691               
23692 B0C6 D3E0  30        movb @CNT,ry                    ; LDY CNT           ; Set Y to the index that points to the next vertex on
     B0C8 00A4     
23693                                                                          ; the ship line heap
23694               
23695 B0CA 93E0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y < TGT, which we set to the explosion count for
     B0CC 00A0     
23696 B0CE 17A6  14        jnc  EXL5                       ; BCC EXL5          ; this ship (i.e. the number of vertices used as origins
23697                                                                          ; for explosion clouds), loop back to EXL5 to do a cloud
23698                                                                          ; for the next vertex
23699               
23700                      .pla                            ; PLA               ; Restore the current random number seed to RAND+1 that
     **** ****     > PLA
0001 B0D0 058A  14        inc  rsp
0002 B0D2 D35A  26        movb *rsp,ra
                   < elite.a99
23701 B0D4 D80D  30        movb ra,@RAND+1                 ; STA RAND+1        ; we stored at the start of the routine
     B0D6 0001     
23702               
23703 B0D8 D360  30        movb @K.+6,ra                   ; LDA K%+6          ; Store the z_lo coordinate for the planet (which will
     B0DA 0906     
23704 B0DC D80D  30        movb ra,@RAND+3                 ; STA RAND+3        ; be pretty random) in the RAND+3 seed
     B0DE 0003     
23705               
23706 B0E0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B0E2 FE34     
23707               
23708               EX11:
23709 B0E4 0200  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     B0E6 C7CE     
23710 B0E8 06A0  32        bl   @jsr                       ;
     B0EA FE28     
23711                                                                          ; doesn't affect the outcome
23712               
23713 B0EC 0460  28        b    @EX4                       ; JMP EX4           ; We just skipped a particle, so jump up to EX4 to do
     B0EE B0C2     
23714                                                                          ; the next one
23715               
23716               EXS1:
23717                                                                          ; This routine calculates the following:
23718                                                                          ;
23719                                                                          ; (A X) = (A R) +/- random * cloud size
23720                                                                          ;
23721                                                                          ; returning with the flags set for the high byte in A
23722 B0F0 D80D  30        movb ra,@S                      ; STA S             ; Store A in S so we can use it later
     B0F2 0092     
23723               
23724 B0F4 0200  20        li   rtmp,DORND2                ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
     B0F6 C7CE     
23725 B0F8 06A0  32        bl   @jsr                       ;
     B0FA FE28     
23726                                                                          ; doesn't affect the outcome
23727               
23728 B0FC 06A0  32        bl   @rola                      ; ROL A             ; Set A = A * 2
     B0FE FE3E     
23729               
23730 B100 1811  14        joc  EX5                        ; BCS EX5           ; If bit 7 of A was set (50% chance), jump to EX5
23731               
23732 B102 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set A = A * Q / 256
     B104 46D4     
23733 B106 06A0  32        bl   @jsr                       ;
     B108 FE28     
23734                                                                          ; = random << 1 * projected cloud size / 256
23735               
23736                      .adc @R,ra                      ; ADC R             ; Set (A X) = (S R) + A
     **** ****     > ADC
0001 B10A 1701  14        jnc  !
0002 B10C B347  18        ab   rone,ra
0003               !:
0004 B10E B360  30        ab   @R,ra
     B110 0091     
                   < elite.a99
23737 B112 D38D  18        movb ra,rx                      ; TAX               ; = (S R) + random * projected cloud size
23738                                                                          ;
23739                                                                          ; where S contains the argument A, starting with the low
23740                                                                          ; bytes
23741               
23742 B114 D360  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     B116 0092     
23743                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 B118 1701  14        jnc  !
0002 B11A B347  18        ab   rone,ra
0003               !:
0004 B11C 022D  22        ai   ra,(>00*256)
     B11E 0000     
                   < elite.a99
23744               
23745 B120 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B122 FE34     
23746               
23747               EX5:
23748 B124 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     B126 46D4     
23749 B128 06A0  32        bl   @jsr                       ;
     B12A FE28     
23750 B12C D80D  30        movb ra,@T                      ; STA T             ; = random << 1 * projected cloud size / 256
     B12E 00D1     
23751               
23752 B130 D360  30        movb @R,ra                      ; LDA R             ; Set (A X) = (S R) - T
     B132 0091     
23753                      .sbc @T,ra                      ; SBC T             ;
     **** ****     > SBC
0001 B134 1801  14        joc  !
0002 B136 7347  18        sb   rone,ra
0003               !:
0004 B138 7360  30        sb   @T,ra
     B13A 00D1     
                   < elite.a99
23754 B13C D38D  18        movb ra,rx                      ; TAX               ; where S contains the argument A, starting with the low
23755                                                                          ; bytes
23756               
23757 B13E D360  30        movb @S,ra                      ; LDA S             ; And then the high bytes
     B140 0092     
23758                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 B142 1801  14        joc  !
0002 B144 7347  18        sb   rone,ra
0003               !:
0004 B146 022D  22        ai   ra,-(>00*256)
     B148 0000     
                   < elite.a99
23759               
23760 B14A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B14C FE34     
23761               
23762               * ******************************************************************************
23763               *
23764               * Name: SOS1
23765               * Type: Subroutine
23766               * Category: Universe
23767               * Summary: Update the missile indicators, set up the planet data block
23768               *
23769               * ------------------------------------------------------------------------------
23770               *
23771               * Update the missile indicators, and set up a data block for the planet, but
23772               * only setting the pitch and roll counters to 127 (no damping).
23773               *
23774               * ******************************************************************************
23775               
23776               SOS1:
23777 B14E 0200  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     B150 C73C     
23778 B152 06A0  32        bl   @jsr                       ;
     B154 FE28     
23779                                                                          ; them are targeted
23780               
23781 B156 020D  20        li   ra,>7f*256                 ; LDA #127          ; Set the pitch and roll counters to 127, so that's a
     B158 7F00     
23782 B15A D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; clockwise roll and a diving pitch with no damping, so
     B15C 0070     
23783 B15E D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; the planet's rotation doesn't slow down
     B160 0071     
23784               
23785 B162 D360  30        movb @tek_,ra                   ; LDA tek           ; Set A = 128 or 130 depending on bit 1 of the system's
     B164 0F1D     
23786 B166 024D  22        andi ra,>02*256                 ; AND #%00000010    ; tech level in tek
     B168 0200     
23787 B16A 026D  22        ori  ra,>80*256                 ; ORA #%10000000
     B16C 8000     
23788               
23789 B16E 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Add a new planet to our local bubble of universe,
     B170 B5DA     
23790                                                                          ; with the planet type defined by A (128 is a planet
23791                                                                          ; with an equator and meridian, 130 is a planet with
23792                                                                          ; a crater)
23793               
23794               * ******************************************************************************
23795               *
23796               * Name: SOLAR
23797               * Type: Subroutine
23798               * Category: Universe
23799               * Summary: Set up various aspects of arriving in a new system
23800               *
23801               * ------------------------------------------------------------------------------
23802               *
23803               * Halve our legal status, update the missile indicators, and set up data blocks
23804               * and slots for the planet and sun.
23805               *
23806               * ******************************************************************************
23807               
23808               SOLAR:
23809                      .lsr @FIST                      ; LSR FIST          ; Halve our legal status in FIST, making us less bad,
     **** ****     > LSR
0001 B172 D020  30        movb @FIST,rtmp
     B174 0334     
0002 B176 0910  18        srl  rtmp,1
0003 B178 D800  30        movb rtmp,@FIST
     B17A 0334     
                   < elite.a99
23810                                                                          ; and moving bit 0 into the C flag (so every time we
23811                                                                          ; arrive in a new system, our legal status improves a
23812                                                                          ; bit)
23813               
23814 B17C 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace, which
     B17E C710     
23815 B180 06A0  32        bl   @jsr                       ;
     B182 FE28     
23816                                                                          ; doesn't affect the C flag
23817               
23818 B184 D360  30        movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi
     B186 0079     
23819               
23820 B188 024D  22        andi ra,>07*256                 ; AND #%00000111    ; Extract bits 0-2 (which also happen to determine the
     B18A 0700     
23821                                                                          ; economy), which will be between 0 and 7
23822               
23823                      .adi (>06*256)                  ; ADC #6            ; Add 6 + C, and divide by 2, to get a result between 3
     **** ****     > ADI
0001 B18C 1701  14        jnc  !
0002 B18E B347  18        ab   rone,ra
0003               !:
0004 B190 022D  22        ai   ra,(>06*256)
     B192 0600     
                   < elite.a99
23824 B194 091D  18        srl  ra,1                       ; LSR A             ; and 7, at the same time shifting bit 0 of the result
23825                                                                          ; of the addition into the C flag
23826               
23827 B196 D80D  30        movb ra,@INWK+8                 ; STA INWK+8        ; Store the result in z_sign in byte #6
     B198 005B     
23828               
23829 B19A 06A0  32        bl   @rora                      ; ROR A             ; Halve A, rotating in the C flag, which was previously
     B19C FE62     
23830 B19E D80D  30        movb ra,@INWK+2                 ; STA INWK+2        ; bit 0 of s0_hi + 6 + C, so when this is stored in both
     B1A0 0055     
23831 B1A2 D80D  30        movb ra,@INWK+5                 ; STA INWK+5        ; x_sign and y_sign, it moves the planet to the upper
     B1A4 0058     
23832                                                                          ; right or lower left
23833               
23834 B1A6 0200  20        li   rtmp,SOS1                  ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
     B1A8 B14E     
23835 B1AA 06A0  32        bl   @jsr                       ;
     B1AC FE28     
23836                                                                          ; to FRIN, where it will get put in the first slot as
23837                                                                          ; it's the first one to be added to our local bubble of
23838                                                                          ; this new system's universe
23839               
23840 B1AE D360  30        movb @QQ15+3,ra                 ; LDA QQ15+3        ; Fetch s1_hi, extract bits 0-2, set bits 0 and 7 and
     B1B0 007B     
23841 B1B2 024D  22        andi ra,>07*256                 ; AND #%00000111    ; store in z_sign, so the sun is behind us at a distance
     B1B4 0700     
23842 B1B6 026D  22        ori  ra,>81*256                 ; ORA #%10000001    ; of 1 to 7
     B1B8 8100     
23843 B1BA D80D  30        movb ra,@INWK+8                 ; STA INWK+8
     B1BC 005B     
23844               
23845 B1BE D360  30        movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi, extract bits 0-1 and store in x_sign and
     B1C0 007D     
23846 B1C2 024D  22        andi ra,>03*256                 ; AND #%00000011    ; y_sign, so the sun is either dead centre in our rear
     B1C4 0300     
23847 B1C6 D80D  30        movb ra,@INWK+2                 ; STA INWK+2        ; laser crosshairs, or off to the top left by a distance
     B1C8 0055     
23848 B1CA D80D  30        movb ra,@INWK+1                 ; STA INWK+1        ; of 1 or 2 when we look out the back
     B1CC 0054     
23849               
23850 B1CE 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the pitch and roll counters to 0 (no rotation)
     B1D0 0000     
23851 B1D2 D80D  30        movb ra,@INWK+29                ; STA INWK+29
     B1D4 0070     
23852 B1D6 D80D  30        movb ra,@INWK+30                ; STA INWK+30
     B1D8 0071     
23853               
23854 B1DA 020D  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     B1DC 8100     
23855               
23856 B1DE 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Call NWSHP to set up the sun's data block and add it
     B1E0 B5DA     
23857 B1E2 06A0  32        bl   @jsr                       ;
     B1E4 FE28     
23858                                                                          ; to FRIN, where it will get put in the second slot as
23859                                                                          ; it's the second one to be added to our local bubble
23860                                                                          ; of this new system's universe
23861               
23862               * ******************************************************************************
23863               *
23864               * Name: NWSTARS
23865               * Type: Subroutine
23866               * Category: Stardust
23867               * Summary: Initialise the stardust field
23868               *
23869               * ------------------------------------------------------------------------------
23870               *
23871               * This routine is called when the space view is initialised in routine LOOK1.
23872               *
23873               * ******************************************************************************
23874               
23875               NWSTARS:
23876 B1E6 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to WPSHPS to skip
     B1E8 0096     
23877               * ORA MJ                 \ the initialisation of the SX, SY and SZ tables. The OR
23878 B1EA 1628  14        jne  WPSHPS                     ; BNE WPSHPS        ; instruction is commented out in the original source,
23879                                                                          ; but it would have the effect of also skipping the
23880                                                                          ; initialisation if we had mis-jumped into witchspace
23881               
23882               * ******************************************************************************
23883               *
23884               * Name: nWq
23885               * Type: Subroutine
23886               * Category: Stardust
23887               * Summary: Create a random cloud of stardust
23888               *
23889               * ------------------------------------------------------------------------------
23890               *
23891               * Create a random cloud of stardust containing the correct number of dust
23892               * particles, i.e. NOSTM of them, which is 3 in witchspace and 18 (#NOST) in
23893               * normal space. Also clears the scanner and initialises the LSO block.
23894               *
23895               * This is called by the DEATH routine when it displays our untimely demise.
23896               *
23897               * ******************************************************************************
23898               
23899               nWq:
23900 B1EC D3E0  30        movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
     B1EE 0F33     
23901                                                                          ; we can use it as a counter through all the stardust
23902               
23903               SAL4:
23904 B1F0 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     B1F2 C7D0     
23905 B1F4 06A0  32        bl   @jsr                       ;
     B1F6 FE28     
23906               
23907 B1F8 026D  22        ori  ra,>08*256                 ; ORA #8            ; Set A so that it's at least 8
     B1FA 0800     
23908               
23909 B1FC 06CF  14        swpb ry                         ;
23910 B1FE DBCD  38        movb ra,@SZ(ry)                 ; STA SZ,Y          ; Store A in the Y-th particle's z_hi coordinate at
     B200 0EE8     
23911 B202 06CF  14        swpb ry                         ;
23912                                                                          ; SZ+Y, so the particle appears in front of us
23913               
23914 B204 D80D  30        movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the particle's z_hi coordinate
     B206 0097     
23915               
23916 B208 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     B20A C7D0     
23917 B20C 06A0  32        bl   @jsr                       ;
     B20E FE28     
23918               
23919 B210 06CF  14        swpb ry                         ;
23920 B212 DBCD  38        movb ra,@SX(ry)                 ; STA SX,Y          ; Store A in the Y-th particle's x_hi coordinate at
     B214 034C     
23921 B216 06CF  14        swpb ry                         ;
23922                                                                          ; SX+Y, so the particle appears in front of us
23923               
23924 B218 D80D  30        movb ra,@X1                     ; STA X1            ; Set X1 to the particle's x_hi coordinate
     B21A 0031     
23925               
23926 B21C 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     B21E C7D0     
23927 B220 06A0  32        bl   @jsr                       ;
     B222 FE28     
23928               
23929 B224 06CF  14        swpb ry                         ;
23930 B226 DBCD  38        movb ra,@SY(ry)                 ; STA SY,Y          ; Store A in the Y-th particle's y_hi coordinate at
     B228 0EC2     
23931 B22A 06CF  14        swpb ry                         ;
23932                                                                          ; SY+Y, so the particle appears in front of us
23933               
23934 B22C D80D  30        movb ra,@Y1                     ; STA Y1            ; Set Y1 to the particle's y_hi coordinate
     B22E 0032     
23935               
23936 B230 0200  20        li   rtmp,PIXEL2                ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ
     B232 2924     
23937 B234 06A0  32        bl   @jsr                       ;
     B236 FE28     
23938               
23939 B238 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
23940                                                                          ; stardust
23941               
23942 B23A 16DA  14        jne  SAL4                       ; BNE SAL4          ; Loop back to SAL4 until we have randomised all the
23943                                                                          ; stardust particles
23944               
23945                                                                          ; Fall through into WPSHPS to clear the scanner and
23946                                                                          ; reset the LSO block
23947               
23948               * ******************************************************************************
23949               *
23950               * Name: WPSHPS
23951               * Type: Subroutine
23952               * Category: Dashboard
23953               * Summary: Clear the scanner, reset the ball line and sun line heaps
23954               *
23955               * ------------------------------------------------------------------------------
23956               *
23957               * Remove all ships from the scanner, reset the sun line heap at LSO, and reset
23958               * the ball line heap at LSX2 and LSY2.
23959               *
23960               * ******************************************************************************
23961               
23962               WPSHPS:
23963 B23C 020E  20        li   rx,>00*256                 ; LDX #0            ; Set up a counter in X to work our way through all the
     B23E 0000     
23964                                                                          ; ship slots in FRIN
23965               
23966               WSL1:
23967 B240 06CE  14        swpb rx                         ;
23968 B242 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type in slot X
     B244 0D40     
23969 B246 06CE  14        swpb rx                         ;
23970               
23971 B248 1338  14        jeq  WS2                        ; BEQ WS2           ; If the slot contains 0 then it is empty and we have
23972                                                                          ; checked all the slots (as they are always shuffled
23973                                                                          ; down in the main loop to close up and gaps), so jump
23974                                                                          ; to WS2 as we are done
23975               
23976 B24A 1135  14        jlt  WS1                        ; BMI WS1           ; If the slot contains a ship type with bit 7 set, then
23977                                                                          ; it contains the planet or the sun, so jump down to WS1
23978                                                                          ; to skip this slot, as the planet and sun don't appear
23979                                                                          ; on the scanner
23980               
23981 B24C D80D  30        movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE
     B24E 009B     
23982               
23983 B250 0200  20        li   rtmp,GINF                  ; JSR GINF          ; Call GINF to get the address of the data block for
     B252 B564     
23984 B254 06A0  32        bl   @jsr                       ;
     B256 FE28     
23985                                                                          ; ship slot X and store it in INF
23986               
23987 B258 020F  20        li   ry,>1f*256                 ; LDY #31           ; We now want to copy the first 32 bytes from the ship's
     B25A 1F00     
23988                                                                          ; data block into INWK, so set a counter in Y
23989               
23990               WSL2:
23991                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte from the data block pointed to by
     **** ****     > LD_IND_Y_IDX
0001 B25C D820  42        movb @INF,@rtmplb
     B25E 0020     
     B260 8301     
0002 B262 D020  30        movb @INF+1,rtmp
     B264 0021     
0003 B266 06CF  14        swpb ry
0004 B268 A00F  18        a    ry,rtmp
0005 B26A 06CF  14        swpb ry
0006 B26C D350  26        movb *rtmp,RA
                   < elite.a99
23992 B26E 06CF  14        swpb ry                         ;
23993 B270 DBCD  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; INF into the Y-th byte of INWK workspace
     B272 0053     
23994 B274 06CF  14        swpb ry                         ;
23995               
23996 B276 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter to point at the next byte
23997               
23998 B278 15F1  14        jgt  WSL2                       ; BPL WSL2          ; Loop back to WSL2 until we have copied all 32 bytes
23999               
24000 B27A D80E  30        movb rx,@XSAV                   ; STX XSAV          ; Store the ship slot number in XSAV while we call SCAN
     B27C 0093     
24001               
24002 B27E 0200  20        li   rtmp,SCAN                  ; JSR SCAN          ; Call SCAN to plot this ship on the scanner, which will
     B280 505A     
24003 B282 06A0  32        bl   @jsr                       ;
     B284 FE28     
24004                                                                          ; remove it as it's plotted with EOR logic
24005               
24006 B286 D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the ship slot number from XSAV into X
     B288 0093     
24007               
24008 B28A 020F  20        li   ry,>1f*256                 ; LDY #31           ; Clear bits 3, 4 and 6 in the ship's byte #31, which
     B28C 1F00     
24009                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; stops drawing the ship on-screen (bit 3), hides it
     **** ****     > LD_IND_Y_IDX
0001 B28E D820  42        movb @INF,@rtmplb
     B290 0020     
     B292 8301     
0002 B294 D020  30        movb @INF+1,rtmp
     B296 0021     
0003 B298 06CF  14        swpb ry
0004 B29A A00F  18        a    ry,rtmp
0005 B29C 06CF  14        swpb ry
0006 B29E D350  26        movb *rtmp,RA
                   < elite.a99
24010 B2A0 024D  22        andi ra,>a7*256                 ; AND #%10100111    ; from the scanner (bit 4) and stops any lasers firing
     B2A2 A700     
24011                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; (bit 6)
     **** ****     > ST_IND_Y_IDX
0001 B2A4 D820  42        movb @INF,@rtmplb
     B2A6 0020     
     B2A8 8301     
0002 B2AA D020  30        movb @INF+1,rtmp
     B2AC 0021     
0003 B2AE 06CF  14        swpb ry
0004 B2B0 A00F  18        a    ry,rtmp
0005 B2B2 06CF  14        swpb ry
0006 B2B4 D40D  30        movb RA,*rtmp
                   < elite.a99
24012               
24013               WS1:
24014 B2B6 B387  18        ab   rone,rx                    ; INX               ; Increment X to point to the next ship slot
24015               
24016 B2B8 16C3  14        jne  WSL1                       ; BNE WSL1          ; Loop back up to process the next slot (this BNE is
24017                                                                          ; effectively a JMP as X will never be zero)
24018               
24019               WS2:
24020 B2BA 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set LSX2 = LSY2 = &FF to clear the ball line heap
     B2BC FF00     
24021 B2BE D80E  30        movb rx,@LSX2                   ; STX LSX2
     B2C0 0E26     
24022 B2C2 D80E  30        movb rx,@LSY2                   ; STX LSY2
     B2C4 0E74     
24023               
24024                                                                          ; Fall through into FLFLLS to reset the LSO block
24025               
24026               * ******************************************************************************
24027               *
24028               * Name: FLFLLS
24029               * Type: Subroutine
24030               * Category: Drawing suns
24031               * Summary: Reset the sun line heap
24032               *
24033               * ------------------------------------------------------------------------------
24034               *
24035               * Reset the sun line heap at LSO by zero-filling it and setting the first byte
24036               * to &FF.
24037               *
24038               * ------------------------------------------------------------------------------
24039               *
24040               * Returns:
24041               *
24042               * A                   A is set to 0
24043               *
24044               * ******************************************************************************
24045               
24046               FLFLLS:
24047 B2C6 020F  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     B2C8 BF00     
24048                                                                          ; view, so this sets Y as a counter for the number of
24049                                                                          ; lines in the space view (i.e. 191), which is also the
24050                                                                          ; number of lines in the LSO block
24051               
24052 B2CA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the LSO block
     B2CC 0000     
24053               
24054               SAL6:
24055 B2CE 06CF  14        swpb ry                         ;
24056 B2D0 DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Set the Y-th byte of the LSO block to 0
     B2D2 0D66     
24057 B2D4 06CF  14        swpb ry                         ;
24058               
24059 B2D6 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
24060               
24061 B2D8 16FA  14        jne  SAL6                       ; BNE SAL6          ; Loop back until we have filled all the way to LSO+1
24062               
24063 B2DA 73C7  18        sb   rone,ry                    ; DEY               ; Decrement Y to value of &FF (as we exit the above loop
24064                                                                          ; with Y = 0)
24065               
24066 B2DC D80F  30        movb ry,@LSX                    ; STY LSX           ; Set the first byte of the LSO block, which has its own
     B2DE 0D66     
24067                                                                          ; label LSX, to &FF, to indicate that the sun line heap
24068                                                                          ; is empty
24069               
24070 B2E0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B2E2 FE34     
24071               
24072               * ******************************************************************************
24073               *
24074               * Name: DET1
24075               * Type: Subroutine
24076               * Category: Drawing the screen
24077               * Summary: Show or hide the dashboard (for when we die)
24078               *
24079               * ------------------------------------------------------------------------------
24080               *
24081               * This routine sets the screen to show the number of text rows given in X.
24082               *
24083               * It is used when we are killed, as reducing the number of rows from the usual
24084               * 31 to 24 has the effect of hiding the dashboard, leaving a monochrome image
24085               * of ship debris and explosion clouds. Increasing the rows back up to 31 makes
24086               * the dashboard reappear, as the dashboard's screen memory doesn't get touched
24087               * by this process.
24088               *
24089               * ------------------------------------------------------------------------------
24090               *
24091               * Arguments:
24092               *
24093               * X                   The number of text rows to display on the screen (24
24094               * will hide the dashboard, 31 will make it reappear)
24095               *
24096               * ------------------------------------------------------------------------------
24097               *
24098               * Returns:
24099               *
24100               * A                   A is set to 6
24101               *
24102               * ******************************************************************************
24103               
24104               DET1:
24105 B2E4 020D  20        li   ra,>06*256                 ; LDA #6            ; Set A to 6 so we can update 6845 register R6 below
     B2E6 0600     
24106               
24107 B2E8 0300  22        limi 0                          ; SEI               ; Disable interrupts so we can update the 6845
     B2EA 0000     
24108               
24109 B2EC D80D  38        movb ra,@VIA+>00                ; STA VIA+&00       ; Set 6845 register R6 to the value in X. Register R6
     B2EE FE00     
24110 B2F0 D80E  38        movb rx,@VIA+>01                ; STX VIA+&01       ; is the "vertical displayed" register, which sets the
     B2F2 FE01     
24111                                                                          ; number of rows shown on the screen
24112               
24113 B2F4 0300  22        limi 2                          ; CLI               ; Re-enable interrupts
     B2F6 0002     
24114               
24115 B2F8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B2FA FE34     
24116               
24117               * ******************************************************************************
24118               *
24119               * Name: SHD
24120               * Type: Subroutine
24121               * Category: Flight
24122               * Summary: Charge a shield and drain some energy from the energy banks
24123               *
24124               * ------------------------------------------------------------------------------
24125               *
24126               * Charge up a shield, and if it needs charging, drain some energy from the
24127               * energy banks.
24128               *
24129               * ------------------------------------------------------------------------------
24130               *
24131               * Arguments:
24132               *
24133               * X                   The value of the shield to recharge
24134               *
24135               * ******************************************************************************
24136               
24137 B2FC 7387  18        sb   rone,rx                    ; DEX               ; Increment the shield value so that it doesn't go past
24138                                                                          ; a maximum of 255
24139               
24140 B2FE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B300 FE34     
24141               
24142               SHD:
24143 B302 B387  18        ab   rone,rx                    ; INX               ; Increment the shield value
24144               
24145 B304 13FD  14        jeq  SHD-2                      ; BEQ SHD-2         ; If the shield value is 0 then this means it was 255
24146                                                                          ; before, which is the maximum value, so jump to SHD-2
24147                                                                          ; to bring it back down to 258 and return
24148               
24149                                                                          ; Otherwise fall through into DENGY to drain our energy
24150                                                                          ; to pay for all this shield charging
24151               
24152               * ******************************************************************************
24153               *
24154               * Name: DENGY
24155               * Type: Subroutine
24156               * Category: Flight
24157               * Summary: Drain some energy from the energy banks
24158               *
24159               * ------------------------------------------------------------------------------
24160               *
24161               * Returns:
24162               *
24163               * Z flag              Set if we have no energy left, clear otherwise
24164               *
24165               * ******************************************************************************
24166               
24167               DENGY:
24168 B306 7347  18        sb   rone,ra                    ; DEC ENERGY        ; Decrement the energy banks in ENERGY
24169               
24170                      .php                            ; PHP               ; Save the flags on the stack
     **** ****     > PHP
0001 B308 02C0  12        stst rtmp
0002 B30A D680  30        movb rtmp,*rsp
0003 B30C 060A  14        dec  rsp
                   < elite.a99
24171               
24172 B30E 1601  14        jne  B70                        ; BNE B70           ; If the energy levels are not yet zero, skip the
24173                                                                          ; following instruction
24174               
24175 B310 B347  18        ab   rone,ra                    ; INC ENERGY        ; The minimum allowed energy level is 1, and we just
24176                                                                          ; reached 0, so increment ENERGY back to 1
24177               
24178               B70:
24179                      .plp                            ; PLP               ; Restore the flags from the stack, so we return with
     **** ****     > PLP
0001 B312 058A  14        inc  rsp
0002 B314 D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
24180                                                                          ; the Z flag from the DEC instruction above
24181               
24182 B316 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B318 FE34     
24183               
24184               * ******************************************************************************
24185               *
24186               * Name: COMPAS
24187               * Type: Subroutine
24188               * Category: Dashboard
24189               * Summary: Update the compass
24190               *
24191               * ******************************************************************************
24192               
24193               COMPAS:
24194 B31A 0200  20        li   rtmp,DOT                   ; JSR DOT           ; Call DOT to redraw (i.e. remove) the current compass
     B31C B3EC     
24195 B31E 06A0  32        bl   @jsr                       ;
     B320 FE28     
24196                                                                          ; dot
24197               
24198 B322 D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
     B324 0D55     
24199 B326 1638  14        jne  SP1                        ; BNE SP1           ; SP1 to draw the space station on the compass
24200               
24201 B328 0200  20        li   rtmp,SPS1                  ; JSR SPS1          ; Otherwise we need to draw the planet on the compass,
     B32A D10A     
24202 B32C 06A0  32        bl   @jsr                       ;
     B32E FE28     
24203                                                                          ; so first call SPS1 to calculate the vector to the
24204                                                                          ; planet and store it in XX15
24205               
24206 B330 0460  28        b    @SP2                       ; JMP SP2           ; Jump to SP2 to draw XX15 on the compass, returning
     B332 B3A0     
24207                                                                          ; from the subroutine using a tail call
24208               
24209               * ******************************************************************************
24210               *
24211               * Name: SPS2
24212               * Type: Subroutine
24213               * Category: Maths (Arithmetic)
24214               * Summary: Calculate (Y X) = A / 10
24215               *
24216               * ------------------------------------------------------------------------------
24217               *
24218               * Calculate the following, where A is a sign-magnitude 8-bit integer and the
24219               * result is a signed 16-bit integer:
24220               *
24221               * (Y X) = A / 10
24222               *
24223               * ------------------------------------------------------------------------------
24224               *
24225               * Returns:
24226               *
24227               * C flag              The C flag is cleared
24228               *
24229               * ******************************************************************************
24230               
24231               SPS2:
24232                      .asla                           ; ASL A             ; Set X = |A| * 2, and set the C flag to the sign bit of
     **** ****     > ASLA
0001 B334 024D  22        andi ra,>ff00
     B336 FF00     
0002 B338 0A1D  18        sla  ra,1
                   < elite.a99
24233 B33A D38D  18        movb ra,rx                      ; TAX               ; A
24234               
24235 B33C 020D  20        li   ra,>00*256                 ; LDA #0            ; Set Y to have the sign bit from A in bit 7, with the
     B33E 0000     
24236 B340 06A0  32        bl   @rora                      ; ROR A             ; rest of its bits zeroed, so Y now contains the sign of
     B342 FE62     
24237 B344 D3CD  18        movb ra,ry                      ; TAY               ; the original argument
24238               
24239 B346 020D  20        li   ra,>14*256                 ; LDA #20           ; Set Q = 20
     B348 1400     
24240 B34A D80D  30        movb ra,@Q                      ; STA Q
     B34C 0090     
24241               
24242 B34E D34E  18        movb rx,ra                      ; TXA               ; Copy X into A, so A now contains the argument A * 2
24243               
24244 B350 0200  20        li   rtmp,DVID4                 ; JSR DVID4         ; Calculate the following:
     B352 495C     
24245 B354 06A0  32        bl   @jsr                       ;
     B356 FE28     
24246                                                                          ;
24247                                                                          ; P = A / Q
24248                                                                          ; = |argument A| * 2 / 20
24249                                                                          ; = |argument A| / 10
24250               
24251 B358 D3A0  30        movb @P,rx                      ; LDX P             ; Set X to the result
     B35A 001B     
24252               
24253 B35C D34F  18        movb ry,ra                      ; TYA               ; If the sign of the original argument A is negative,
24254 B35E 1104  14        jlt  LL163                      ; BMI LL163         ; jump to LL163 to flip the sign of the result
24255               
24256 B360 020F  20        li   ry,>00*256                 ; LDY #0            ; Set the high byte of the result to 0, as the result is
     B362 0000     
24257                                                                          ; positive
24258               
24259 B364 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B366 FE34     
24260               
24261               LL163:
24262 B368 020F  20        li   ry,>ff*256                 ; LDY #&FF          ; The result is negative, so set the high byte to &FF
     B36A FF00     
24263               
24264 B36C D34E  18        movb rx,ra                      ; TXA               ; Flip the low byte and add 1 to get the negated low
24265                      .eoi (>ff*256)                  ; EOR #&FF          ; byte, using two's complement
     **** ****     > EOI
0001 B36E 0200  20        li   rtmp,(>FF*256)
     B370 FF00     
0002 B372 2B40  18        xor  rtmp,ra
                   < elite.a99
24266 B374 D38D  18        movb ra,rx                      ; TAX
24267 B376 B387  18        ab   rone,rx                    ; INX
24268               
24269 B378 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B37A FE34     
24270               
24271               * ******************************************************************************
24272               *
24273               * Name: SPS4
24274               * Type: Subroutine
24275               * Category: Maths (Geometry)
24276               * Summary: Calculate the vector to the space station
24277               *
24278               * ------------------------------------------------------------------------------
24279               *
24280               * Calculate the vector between our ship and the space station and store it in
24281               * XX15.
24282               *
24283               * ******************************************************************************
24284               
24285               SPS4:
24286 B37C 020E  20        li   rx,>08*256                 ; LDX #8            ; First we need to copy the space station's coordinates
     B37E 0800     
24287                                                                          ; into K3, so set a counter to copy the first 9 bytes
24288                                                                          ; (the 3-byte x, y and z coordinates) from the station's
24289                                                                          ; data block at K% + NI% into K3
24290               
24291               SPL1:
24292 B380 06CE  14        swpb rx                         ;
24293 B382 D36E  34        movb @K.+NI.(rx),ra             ; LDA K%+NI%,X      ; Copy the X-th byte from the station's data block at
     B384 0924     
24294 B386 06CE  14        swpb rx                         ;
24295 B388 06CE  14        swpb rx                         ;
24296 B38A DB8D  38        movb ra,@K3(rx)                 ; STA K3,X          ; K% + NI% to the X-th byte of K3
     B38C 00D2     
24297 B38E 06CE  14        swpb rx                         ;
24298               
24299 B390 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
24300               
24301 B392 15F6  14        jgt  SPL1                       ; BPL SPL1          ; Loop back to SPL1 until we have copied all 9 bytes
24302               
24303 B394 0460  28        b    @TAS2                      ; JMP TAS2          ; Call TAS2 to build XX15 from K3, returning from the
     B396 D12E     
24304                                                                          ; subroutine using a tail call
24305               
24306               * ******************************************************************************
24307               *
24308               * Name: SP1
24309               * Type: Subroutine
24310               * Category: Dashboard
24311               * Summary: Draw the space station on the compass
24312               *
24313               * ******************************************************************************
24314               
24315               SP1:
24316 B398 0200  20        li   rtmp,SPS4                  ; JSR SPS4          ; Call SPS4 to calculate the vector to the space station
     B39A B37C     
24317 B39C 06A0  32        bl   @jsr                       ;
     B39E FE28     
24318                                                                          ; and store it in XX15
24319               
24320                                                                          ; Fall through into SP2 to draw XX15 on the compass
24321               
24322               * ******************************************************************************
24323               *
24324               * Name: SP2
24325               * Type: Subroutine
24326               * Category: Dashboard
24327               * Summary: Draw a dot on the compass, given the planet/station vector
24328               *
24329               * ------------------------------------------------------------------------------
24330               *
24331               * Draw a dot on the compass to represent the planet or station, whose normalised
24332               * vector is in XX15.
24333               *
24334               * XX15 to XX15+2      The normalised vector to the planet or space station,
24335               * stored as x in XX15, y in XX15+1 and z in XX15+2
24336               *
24337               * ******************************************************************************
24338               
24339               SP2:
24340 B3A0 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A to the x-coordinate of the planet or station to
     B3A2 0031     
24341                                                                          ; show on the compass, which will be in the range -96 to
24342                                                                          ; +96 as the vector has been normalised
24343               
24344 B3A4 0200  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     B3A6 B334     
24345 B3A8 06A0  32        bl   @jsr                       ;
     B3AA FE28     
24346                                                                          ; is the x-offset from the centre of the compass of the
24347                                                                          ; dot we want to draw. Returns with the C flag clear
24348               
24349 B3AC D34E  18        movb rx,ra                      ; TXA               ; Set COMX = 195 + X, as 186 is the pixel x-coordinate
24350                      .adi (>c3*256)                  ; ADC #195          ; of the leftmost dot possible on the compass, and X can
     **** ****     > ADI
0001 B3AE 1701  14        jnc  !
0002 B3B0 B347  18        ab   rone,ra
0003               !:
0004 B3B2 022D  22        ai   ra,(>C3*256)
     B3B4 C300     
                   < elite.a99
24351 B3B6 D80D  30        movb ra,@COMX                   ; STA COMX          ; be -9, which would be 195 - 9 = 186. This also means
     B3B8 0F16     
24352                                                                          ; that the highest value for COMX is 195 + 9 = 204,
24353                                                                          ; which is the pixel x-coordinate of the rightmost dot
24354                                                                          ; in the compass... but the compass dot is actually two
24355                                                                          ; pixels wide, so the compass dot can overlap the right
24356                                                                          ; edge of the compass, but not the left edge
24357               
24358 B3BA D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A to the y-coordinate of the planet or station to
     B3BC 0032     
24359                                                                          ; show on the compass, which will be in the range -96 to
24360                                                                          ; +96 as the vector has been normalised
24361               
24362 B3BE 0200  20        li   rtmp,SPS2                  ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
     B3C0 B334     
24363 B3C2 06A0  32        bl   @jsr                       ;
     B3C4 FE28     
24364                                                                          ; is the x-offset from the centre of the compass of the
24365                                                                          ; dot we want to draw. Returns with the C flag clear
24366               
24367 B3C6 D80E  30        movb rx,@T                      ; STX T             ; Set COMY = 204 - X, as 203 is the pixel y-coordinate
     B3C8 00D1     
24368 B3CA 020D  20        li   ra,>cc*256                 ; LDA #204          ; of the centre of the compass, the C flag is clear,
     B3CC CC00     
24369                      .sbc @T,ra                      ; SBC T             ; and the y-axis needs to be flipped around (because
     **** ****     > SBC
0001 B3CE 1801  14        joc  !
0002 B3D0 7347  18        sb   rone,ra
0003               !:
0004 B3D2 7360  30        sb   @T,ra
     B3D4 00D1     
                   < elite.a99
24370 B3D6 D80D  30        movb ra,@COMY                   ; STA COMY          ; when the planet or station is above us, and the
     B3D8 0F17     
24371                                                                          ; vector is therefore positive, we want to show the dot
24372                                                                          ; higher up on the compass, which has a smaller pixel
24373                                                                          ; y-coordinate). So this calculation does this:
24374                                                                          ;
24375                                                                          ; COMY = 204 - X - (1 - 0) = 203 - X
24376               
24377 B3DA 020D  20        li   ra,>f0*256                 ; LDA #&F0          ; Set A to a 4-pixel mode 5 byte row in colour 2
     B3DC F000     
24378                                                                          ; (yellow/white), the colour for when the planet or
24379                                                                          ; station in the compass is in front of us
24380               
24381 B3DE D3A0  30        movb @XX15+2,rx                 ; LDX XX15+2        ; If the z-coordinate of the XX15 vector is positive,
     B3E0 0033     
24382 B3E2 1502  14        jgt  B71                        ; BPL B71           ; skip the following instruction
24383               
24384 B3E4 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; The z-coordinate of XX15 is negative, so the planet or
     B3E6 FF00     
24385                                                                          ; station is behind us and the compass dot should be in
24386                                                                          ; green/cyan, so set A to a 4-pixel mode 5 byte row in
24387                                                                          ; colour 3
24388               
24389               B71:
24390 B3E8 D80D  30        movb ra,@COMC                   ; STA COMC          ; Store the compass colour in COMC
     B3EA 0F48     
24391               
24392                                                                          ; Fall through into DOT to draw the dot on the compass
24393               
24394               * ******************************************************************************
24395               *
24396               * Name: DOT
24397               * Type: Subroutine
24398               * Category: Dashboard
24399               * Summary: Draw a dash on the compass
24400               *
24401               * ------------------------------------------------------------------------------
24402               *
24403               * Arguments:
24404               *
24405               * COMX                The screen pixel x-coordinate of the dash
24406               *
24407               * COMY                The screen pixel y-coordinate of the dash
24408               *
24409               * COMC                The colour and thickness of the dash:
24410               *
24411               * * &F0 = a double-height dash in yellow/white, for when
24412               * the object in the compass is in front of us
24413               *
24414               * * &FF = a single-height dash in green/cyan, for when
24415               * the object in the compass is behind us
24416               *
24417               * ******************************************************************************
24418               
24419               DOT:
24420 B3EC D360  30        movb @COMY,ra                   ; LDA COMY          ; Set Y1 = COMY, the y-coordinate of the dash
     B3EE 0F17     
24421 B3F0 D80D  30        movb ra,@Y1                     ; STA Y1
     B3F2 0032     
24422               
24423 B3F4 D360  30        movb @COMX,ra                   ; LDA COMX          ; Set X1 = COMX, the x-coordinate of the dash
     B3F6 0F16     
24424 B3F8 D80D  30        movb ra,@X1                     ; STA X1
     B3FA 0031     
24425               
24426 B3FC D360  30        movb @COMC,ra                   ; LDA COMC          ; Set COL = COMC, the mode 5 colour byte for the dash
     B3FE 0F48     
24427 B400 D80D  30        movb ra,@COL                    ; STA COL
     B402 00A2     
24428               
24429 B404 028D  22        ci   ra,>f0*256                 ; CMP #&F0          ; If COL is &F0 then the planet/station is in front of
     B406 F000     
24430 B408 1605  14        jne  CPIX2                      ; BNE CPIX2         ; us and we want to draw a double-height dash, so if it
24431                                                                          ; isn't &F0 jump to CPIX2 to draw a single-height dash
24432               
24433                                                                          ; Otherwise fall through into CPIX4 to draw a double-
24434                                                                          ; height dash
24435               
24436               * ******************************************************************************
24437               *
24438               * Name: CPIX4
24439               * Type: Subroutine
24440               * Category: Drawing pixels
24441               * Summary: Draw a double-height dot on the dashboard
24442               *
24443               * ------------------------------------------------------------------------------
24444               *
24445               * Draw a double-height mode 5 dot (2 pixels high, 2 pixels wide).
24446               *
24447               * ------------------------------------------------------------------------------
24448               *
24449               * Arguments:
24450               *
24451               * X1                  The screen pixel x-coordinate of the bottom-left corner
24452               * of the dot
24453               *
24454               * Y1                  The screen pixel y-coordinate of the bottom-left corner
24455               * of the dot
24456               *
24457               * COL                 The colour of the dot as a mode 5 character row byte
24458               *
24459               * ******************************************************************************
24460               
24461               CPIX4:
24462 B40A 0200  20        li   rtmp,CPIX2                 ; JSR CPIX2         ; Call CPIX2 to draw a single-height dash at (X1, Y1)
     B40C B414     
24463 B40E 06A0  32        bl   @jsr                       ;
     B410 FE28     
24464               
24465 B412 7347  18        sb   rone,ra                    ; DEC Y1            ; Decrement Y1
24466               
24467                                                                          ; Fall through into CPIX2 to draw a second single-height
24468                                                                          ; dash on the pixel row above the first one, to create a
24469                                                                          ; double-height dot
24470               
24471               * ******************************************************************************
24472               *
24473               * Name: CPIX2
24474               * Type: Subroutine
24475               * Category: Drawing pixels
24476               * Summary: Draw a single-height dash on the dashboard
24477               * Deep dive: Drawing colour pixels in mode 5
24478               *
24479               * ------------------------------------------------------------------------------
24480               *
24481               * Draw a single-height mode 5 dash (1 pixel high, 2 pixels wide).
24482               *
24483               * ------------------------------------------------------------------------------
24484               *
24485               * Arguments:
24486               *
24487               * X1                  The screen pixel x-coordinate of the dash
24488               *
24489               * Y1                  The screen pixel y-coordinate of the dash
24490               *
24491               * COL                 The colour of the dash as a mode 5 character row byte
24492               *
24493               * ******************************************************************************
24494               
24495               CPIX2:
24496 B414 D360  30        movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate into A
     B416 0032     
24497               
24498               * .CPIX                  \ This label is commented out in the original source. It
24499                                                                          ; would provide a new entry point with A specifying the
24500                                                                          ; y-coordinate instead of Y1, but it isn't used anywhere
24501               
24502 B418 D3CD  18        movb ra,ry                      ; TAY               ; Store the y-coordinate in Y
24503               
24504 B41A 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 8, so A now contains the character row we
24505 B41C 091D  18        srl  ra,1                       ; LSR A             ; need to draw in (as each character row contains 8
24506 B41E 091D  18        srl  ra,1                       ; LSR A             ; pixel rows)
24507               
24508 B420 026D  22        ori  ra,>60*256                 ; ORA #&60          ; Each character row in Elite's screen mode takes up one
     B422 6000     
24509                                                                          ; page in memory (256 bytes), so we now OR with &60 to
24510                                                                          ; get the page containing the dash (see the comments in
24511                                                                          ; routine TT26 for more discussion about calculating
24512                                                                          ; screen memory addresses)
24513               
24514 B424 D80D  30        movb ra,@SCH                    ; STA SCH           ; Store the screen page in the high byte of SC(1 0)
     B426 0008     
24515               
24516 B428 D360  30        movb @X1,ra                     ; LDA X1            ; Each character block contains 8 pixel rows, so to get
     B42A 0031     
24517 B42C 024D  22        andi ra,>f8*256                 ; AND #%11111000    ; the address of the first byte in the character block
     B42E F800     
24518                                                                          ; that we need to draw into, as an offset from the start
24519                                                                          ; of the row, we clear bits 0-2
24520               
24521 B430 D80D  30        movb ra,@SC                     ; STA SC            ; Store the address of the character block in the low
     B432 0007     
24522                                                                          ; byte of SC(1 0), so now SC(1 0) points to the
24523                                                                          ; character block we need to draw into
24524               
24525 B434 D34F  18        movb ry,ra                      ; TYA               ; Set Y to just bits 0-2 of the y-coordinate, which will
24526 B436 024D  22        andi ra,>07*256                 ; AND #%00000111    ; be the number of the pixel row we need to draw into
     B438 0700     
24527 B43A D3CD  18        movb ra,ry                      ; TAY               ; within the character block
24528               
24529 B43C D360  30        movb @X1,ra                     ; LDA X1            ; Copy bits 0-1 of X1 to bits 1-2 of X, and clear the C
     B43E 0031     
24530 B440 024D  22        andi ra,>06*256                 ; AND #%00000110    ; flag in the process (using the LSR). X will now be
     B442 0600     
24531 B444 091D  18        srl  ra,1                       ; LSR A             ; a value between 0 and 3, and will be the pixel number
24532 B446 D38D  18        movb ra,rx                      ; TAX               ; in the character row for the left pixel in the dash.
24533                                                                          ; This is because each character row is one byte that
24534                                                                          ; contains 4 pixels, but covers 8 screen coordinates, so
24535                                                                          ; this effectively does the division by 2 that we need
24536               
24537 B448 06CE  14        swpb rx                         ;
24538 B44A D36E  34        movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; Fetch a mode 5 1-pixel byte with the pixel position
     B44C 23B9     
24539 B44E 06CE  14        swpb rx                         ;
24540                      .and @COL                       ; AND COL           ; at X, and AND with the colour byte so that pixel takes
     **** ****     > AND
0001 B450 D020  30        movb @COL,rtmp
     B452 00A2     
0002 B454 0540  14        inv  rtmp
0003 B456 5340  18        szcb rtmp,ra
                   < elite.a99
24541                                                                          ; on the colour we want to draw (i.e. A is acting as a
24542                                                                          ; mask on the colour byte)
24543               
24544                      .eor @SC                        ; EOR (SC),Y        ; Draw the pixel on-screen using EOR logic, so we can
     **** ****     > EOR
0001 B458 D020  30        movb @SC,rtmp
     B45A 0007     
0002 B45C 2B40  18        xor  rtmp,ra
                   < elite.a99
24545                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; remove it later without ruining the background that's
     **** ****     > ST_IND_Y_IDX
0001 B45E D820  42        movb @SC,@rtmplb
     B460 0007     
     B462 8301     
0002 B464 D020  30        movb @SC+1,rtmp
     B466 0008     
0003 B468 06CF  14        swpb ry
0004 B46A A00F  18        a    ry,rtmp
0005 B46C 06CF  14        swpb ry
0006 B46E D40D  30        movb RA,*rtmp
                   < elite.a99
24546                                                                          ; already on-screen
24547               
24548 B470 06CE  14        swpb rx                         ;
24549 B472 D36E  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Fetch a mode 5 1-pixel byte with the pixel position
     B474 23BA     
24550 B476 06CE  14        swpb rx                         ;
24551                                                                          ; at X+1, so we can draw the right pixel of the dash
24552               
24553 B478 150C  14        jgt  CP1                        ; BPL CP1           ; The CTWOS table has an extra row at the end of it that
24554                                                                          ; repeats the first value, %10001000, so if we have not
24555                                                                          ; fetched that value, then the right pixel of the dash
24556                                                                          ; is in the same character block as the left pixel, so
24557                                                                          ; jump to CP1 to draw it
24558               
24559 B47A D360  30        movb @SC,ra                     ; LDA SC            ; Otherwise the left pixel we drew was at the last
     B47C 0007     
24560                      .adi (>08*256)                  ; ADC #8            ; position of four in this character block, so we add
     **** ****     > ADI
0001 B47E 1701  14        jnc  !
0002 B480 B347  18        ab   rone,ra
0003               !:
0004 B482 022D  22        ai   ra,(>08*256)
     B484 0800     
                   < elite.a99
24561 B486 D80D  30        movb ra,@SC                     ; STA SC            ; 8 to the screen address to move onto the next block
     B488 0007     
24562                                                                          ; along (as there are 8 bytes in a character block).
24563                                                                          ; The C flag was cleared above, so this ADC is correct
24564               
24565 B48A 06CE  14        swpb rx                         ;
24566 B48C D36E  34        movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Re-fetch the mode 5 1-pixel byte, as we just overwrote
     B48E 23BA     
24567 B490 06CE  14        swpb rx                         ;
24568                                                                          ; A (the byte will still be the fifth byte from the
24569                                                                          ; table, which is correct as we want to draw the
24570                                                                          ; leftmost pixel in the next character along as the
24571                                                                          ; dash's right pixel)
24572               
24573               CP1:
24574                      .and @COL                       ; AND COL           ; Apply the colour mask to the pixel byte, as above
     **** ****     > AND
0001 B492 D020  30        movb @COL,rtmp
     B494 00A2     
0002 B496 0540  14        inv  rtmp
0003 B498 5340  18        szcb rtmp,ra
                   < elite.a99
24575               
24576                      .eor @SC                        ; EOR (SC),Y        ; Draw the dash's right pixel according to the mask in
     **** ****     > EOR
0001 B49A D020  30        movb @SC,rtmp
     B49C 0007     
0002 B49E 2B40  18        xor  rtmp,ra
                   < elite.a99
24577                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; A, with the colour in COL, using EOR logic, just as
     **** ****     > ST_IND_Y_IDX
0001 B4A0 D820  42        movb @SC,@rtmplb
     B4A2 0007     
     B4A4 8301     
0002 B4A6 D020  30        movb @SC+1,rtmp
     B4A8 0008     
0003 B4AA 06CF  14        swpb ry
0004 B4AC A00F  18        a    ry,rtmp
0005 B4AE 06CF  14        swpb ry
0006 B4B0 D40D  30        movb RA,*rtmp
                   < elite.a99
24578                                                                          ; above
24579               
24580 B4B2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B4B4 FE34     
24581               
24582               * ******************************************************************************
24583               *
24584               * Name: OOPS
24585               * Type: Subroutine
24586               * Category: Flight
24587               * Summary: Take some damage
24588               *
24589               * ------------------------------------------------------------------------------
24590               *
24591               * We just took some damage, so reduce the shields if we have any, or reduce the
24592               * energy levels and potentially take some damage to the cargo if we don't.
24593               *
24594               * ------------------------------------------------------------------------------
24595               *
24596               * Arguments:
24597               *
24598               * A                   The amount of damage to take
24599               *
24600               * INF                 The address of the ship block for the ship that attacked
24601               * us, or the ship that we just ran into
24602               *
24603               * ******************************************************************************
24604               
24605               OOPS:
24606 B4B6 D80D  30        movb ra,@T                      ; STA T             ; Store the amount of damage in T
     B4B8 00D1     
24607               
24608 B4BA 020F  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 (z_sign) for the ship attacking us, and
     B4BC 0800     
24609 B4BE 020E  20        li   rx,>00*256                 ; LDX #0            ; set X = 0
     B4C0 0000     
24610                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y
     **** ****     > LD_IND_Y_IDX
0001 B4C2 D820  42        movb @INF,@rtmplb
     B4C4 0020     
     B4C6 8301     
0002 B4C8 D020  30        movb @INF+1,rtmp
     B4CA 0021     
0003 B4CC 06CF  14        swpb ry
0004 B4CE A00F  18        a    ry,rtmp
0005 B4D0 06CF  14        swpb ry
0006 B4D2 D350  26        movb *rtmp,RA
                   < elite.a99
24611               
24612 B4D4 110E  14        jlt  OO1                        ; BMI OO1           ; If A is negative, then we got hit in the rear, so jump
24613                                                                          ; to OO1 to process damage to the aft shield
24614               
24615 B4D6 D360  30        movb @FSH,ra                    ; LDA FSH           ; Otherwise the forward shield was damaged, so fetch the
     B4D8 0F11     
24616                      .sbc @T,ra                      ; SBC T             ; shield strength from FSH and subtract the damage in T
     **** ****     > SBC
0001 B4DA 1801  14        joc  !
0002 B4DC 7347  18        sb   rone,ra
0003               !:
0004 B4DE 7360  30        sb   @T,ra
     B4E0 00D1     
                   < elite.a99
24617               
24618 B4E2 1704  14        jnc  OO2                        ; BCC OO2           ; If the C flag is clear then this amount of damage was
24619                                                                          ; too much for the shields, so jump to OO2 to set the
24620                                                                          ; shield level to 0 and start taking damage directly
24621                                                                          ; from the energy banks
24622               
24623 B4E4 D80D  30        movb ra,@FSH                    ; STA FSH           ; Store the new value of the forward shield in FSH
     B4E6 0F11     
24624               
24625 B4E8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B4EA FE34     
24626               
24627               OO2:
24628               * LDX #0                 \ This instruction is commented out in the original
24629                                                                          ; source, and isn't required as X is set to 0 above
24630 B4EC D80E  30        movb rx,@FSH                    ; STX FSH           ; Set the forward shield to 0
     B4EE 0F11     
24631               
24632 B4F0 170D  14        jnc  OO3                        ; BCC OO3           ; Jump to OO3 to start taking damage directly from the
24633                                                                          ; energy banks (this BCC is effectively a JMP as the C
24634                                                                          ; flag is clear, as we jumped to OO2 with a BCC)
24635               
24636               OO1:
24637 B4F2 D360  30        movb @ASH,ra                    ; LDA ASH           ; The aft shield was damaged, so fetch the shield
     B4F4 0F12     
24638                      .sbc @T,ra                      ; SBC T             ; strength from ASH and subtract the damage in T
     **** ****     > SBC
0001 B4F6 1801  14        joc  !
0002 B4F8 7347  18        sb   rone,ra
0003               !:
0004 B4FA 7360  30        sb   @T,ra
     B4FC 00D1     
                   < elite.a99
24639               
24640 B4FE 1704  14        jnc  OO5                        ; BCC OO5           ; If the C flag is clear then this amount of damage was
24641                                                                          ; too much for the shields, so jump to OO5 to set the
24642                                                                          ; shield level to 0 and start taking damage directly
24643                                                                          ; from the energy banks
24644               
24645 B500 D80D  30        movb ra,@ASH                    ; STA ASH           ; Store the new value of the aft shield in ASH
     B502 0F12     
24646               
24647 B504 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B506 FE34     
24648               
24649               OO5:
24650               * LDX #0                 \ This instruction is commented out in the original
24651                                                                          ; source, and isn't required as X is set to 0 above
24652 B508 D80E  30        movb rx,@ASH                    ; STX ASH           ; Set the aft shield to 0
     B50A 0F12     
24653               
24654               OO3:
24655                      .adc @ENERGY,ra                 ; ADC ENERGY        ; A is negative and contains the amount by which the
     **** ****     > ADC
0001 B50C 1701  14        jnc  !
0002 B50E B347  18        ab   rone,ra
0003               !:
0004 B510 B360  30        ab   @ENERGY,ra
     B512 0F13     
                   < elite.a99
24656 B514 D80D  30        movb ra,@ENERGY                 ; STA ENERGY        ; damage overwhelmed the shields, so this drains the
     B516 0F13     
24657                                                                          ; energy banks by that amount (and because the energy
24658                                                                          ; banks are shown over four indicators rather than one,
24659                                                                          ; but with the same value range of 0-255, energy will
24660                                                                          ; appear to drain away four times faster than the
24661                                                                          ; shields did)
24662               
24663 B518 1301  14        jeq  B72                        ; BEQ B72           ; If we have just run out of energy, skip the next
24664                                                                          ; instruction to jump straight to our death
24665               
24666 B51A 1802  14        joc  B73                        ; BCS B73           ; If the C flag is set, then subtracting the damage from
24667                                                                          ; the energy banks didn't underflow, so we had enough
24668                                                                          ; energy to survive, and we can skip the next
24669                                                                          ; instruction to make a sound and take some damage
24670               
24671               B72:
24672 B51C 0460  28        b    @DEATH                     ; JMP DEATH         ; Otherwise our energy levels are either 0 or negative,
     B51E CBD2     
24673                                                                          ; and in either case that means we jump to our DEATH,
24674                                                                          ; returning from the subroutine using a tail call
24675               
24676               B73:
24677 B520 0200  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; We didn't die, so call EXNO3 to make the sound of a
     B522 D2BE     
24678 B524 06A0  32        bl   @jsr                       ;
     B526 FE28     
24679                                                                          ; collision
24680               
24681 B528 0460  28        b    @OUCH                      ; JMP OUCH          ; And jump to OUCH to take damage and return from the
     B52A D658     
24682                                                                          ; subroutine using a tail call
24683               
24684               * ******************************************************************************
24685               *
24686               * Name: SPS3
24687               * Type: Subroutine
24688               * Category: Maths (Geometry)
24689               * Summary: Copy a space coordinate from the K% block into K3
24690               *
24691               * ------------------------------------------------------------------------------
24692               *
24693               * Copy one of the planet's coordinates into the corresponding location in the
24694               * temporary variable K3. The high byte and absolute value of the sign byte are
24695               * copied into the first two K3 bytes, and the sign of the sign byte is copied
24696               * into the highest K3 byte.
24697               *
24698               * The comments below are written for copying the planet's x-coordinate into
24699               * K3(2 1 0).
24700               *
24701               * ------------------------------------------------------------------------------
24702               *
24703               * Arguments:
24704               *
24705               * X                   Determines which coordinate to copy, and to where:
24706               *
24707               * * X = 0 copies (x_sign, x_hi) into K3(2 1 0)
24708               *
24709               * * X = 3 copies (y_sign, y_hi) into K3(5 4 3)
24710               *
24711               * * X = 6 copies (z_sign, z_hi) into K3(8 7 6)
24712               *
24713               * ******************************************************************************
24714               
24715               SPS3:
24716 B52C 06CE  14        swpb rx                         ;
24717 B52E D36E  34        movb @K.+1(rx),ra               ; LDA K%+1,X        ; Copy x_hi into K3+X
     B530 0901     
24718 B532 06CE  14        swpb rx                         ;
24719 B534 06CE  14        swpb rx                         ;
24720 B536 DB8D  38        movb ra,@K3(rx)                 ; STA K3,X
     B538 00D2     
24721 B53A 06CE  14        swpb rx                         ;
24722               
24723 B53C 06CE  14        swpb rx                         ;
24724 B53E D36E  34        movb @K.+2(rx),ra               ; LDA K%+2,X        ; Set A = Y = x_sign
     B540 0902     
24725 B542 06CE  14        swpb rx                         ;
24726 B544 D3CD  18        movb ra,ry                      ; TAY
24727               
24728 B546 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Set K3+1 = |x_sign|
     B548 7F00     
24729 B54A 06CE  14        swpb rx                         ;
24730 B54C DB8D  38        movb ra,@K3+1(rx)               ; STA K3+1,X
     B54E 00D3     
24731 B550 06CE  14        swpb rx                         ;
24732               
24733 B552 D34F  18        movb ry,ra                      ; TYA               ; Set K3+2 = the sign of x_sign
24734 B554 024D  22        andi ra,>80*256                 ; AND #%10000000
     B556 8000     
24735 B558 06CE  14        swpb rx                         ;
24736 B55A DB8D  38        movb ra,@K3+2(rx)               ; STA K3+2,X
     B55C 00D4     
24737 B55E 06CE  14        swpb rx                         ;
24738               
24739 B560 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B562 FE34     
24740               
24741               * ******************************************************************************
24742               *
24743               * Name: GINF
24744               * Type: Subroutine
24745               * Category: Universe
24746               * Summary: Fetch the address of a ship's data block into INF
24747               *
24748               * ------------------------------------------------------------------------------
24749               *
24750               * Get the address of the data block for ship slot X and store it in INF. This
24751               * address is fetched from the UNIV table, which stores the addresses of the 13
24752               * ship data blocks in workspace K%.
24753               *
24754               * ------------------------------------------------------------------------------
24755               *
24756               * Arguments:
24757               *
24758               * X                   The ship slot number for which we want the data block
24759               * address
24760               *
24761               * ******************************************************************************
24762               
24763               GINF:
24764 B564 D34E  18        movb rx,ra                      ; TXA               ; Set Y = X * 2
24765                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B566 024D  22        andi ra,>ff00
     B568 FF00     
0002 B56A 0A1D  18        sla  ra,1
                   < elite.a99
24766 B56C D3CD  18        movb ra,ry                      ; TAY
24767               
24768 B56E 06CF  14        swpb ry                         ;
24769 B570 D36F  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Get the high byte of the address of the X-th ship
     B572 238F     
24770 B574 06CF  14        swpb ry                         ;
24771 B576 D80D  30        movb ra,@INF                    ; STA INF           ; from UNIV and store it in INF
     B578 0020     
24772               
24773 B57A 06CF  14        swpb ry                         ;
24774 B57C D36F  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y      ; Get the low byte of the address of the X-th ship
     B57E 2390     
24775 B580 06CF  14        swpb ry                         ;
24776 B582 D80D  30        movb ra,@INF+1                  ; STA INF+1         ; from UNIV and store it in INF
     B584 0021     
24777               
24778 B586 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B588 FE34     
24779               
24780               * ******************************************************************************
24781               *
24782               * Name: NWSPS
24783               * Type: Subroutine
24784               * Category: Universe
24785               * Summary: Add a new space station to our local bubble of universe
24786               *
24787               * ******************************************************************************
24788               
24789               NWSPS:
24790 B58A 0200  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     B58C B76E     
24791 B58E 06A0  32        bl   @jsr                       ;
     B590 FE28     
24792               
24793 B592 020E  20        li   rx,>01*256                 ; LDX #%00000001    ; Set the AI flag in byte #32 to %00000001 (friendly, no
     B594 0100     
24794 B596 D80E  30        movb rx,@INWK+32                ; STX INWK+32       ; AI, has an E.C.M.)
     B598 0073     
24795               
24796 B59A 7387  18        sb   rone,rx                    ; DEX               ; Set pitch counter to 0 (no pitch, roll only)
24797 B59C D80E  30        movb rx,@INWK+30                ; STX INWK+30
     B59E 0071     
24798               
24799               * STX INWK+31            \ This instruction is commented out in the original
24800                                                                          ; source. It would set the exploding state and missile
24801                                                                          ; count to 0
24802               
24803 B5A0 D80E  30        movb rx,@FRIN+1                 ; STX FRIN+1        ; Set the second slot in the FRIN table to 0, so when we
     B5A2 0D41     
24804                                                                          ; fall through into NWSHP below, the new station that
24805                                                                          ; gets created will go into slot FRIN+1, as this will be
24806                                                                          ; the first empty slot that the routine finds
24807               
24808 B5A4 7387  18        sb   rone,rx                    ; DEX               ; Set the roll counter to 255 (maximum anti-clockwise
24809 B5A6 D80E  30        movb rx,@INWK+29                ; STX INWK+29       ; roll with no damping)
     B5A8 0070     
24810               
24811 B5AA 020E  20        li   rx,>0a*256                 ; LDX #10           ; Call NwS1 to flip the sign of nosev_x_hi (byte #10)
     B5AC 0A00     
24812 B5AE 0200  20        li   rtmp,NwS1                  ; JSR NwS1
     B5B0 B710     
24813 B5B2 06A0  32        bl   @jsr                       ;
     B5B4 FE28     
24814               
24815 B5B6 0200  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_y_hi (byte #12)
     B5B8 B710     
24816 B5BA 06A0  32        bl   @jsr                       ;
     B5BC FE28     
24817               
24818 B5BE 0200  20        li   rtmp,NwS1                  ; JSR NwS1          ; And again to flip the sign of nosev_z_hi (byte #14)
     B5C0 B710     
24819 B5C2 06A0  32        bl   @jsr                       ;
     B5C4 FE28     
24820               
24821 B5C6 020D  20        li   ra,((LSO)%256)*256         ; LDA #LO(LSO)      ; Set bytes #33 and #34 to point to LSO for the ship
     B5C8 6600     
24822 B5CA D80D  30        movb ra,@INWK+33                ; STA INWK+33       ; line heap for the space station
     B5CC 0074     
24823 B5CE 020D  20        li   ra,((LSO)/256)*256         ; LDA #HI(LSO)
     B5D0 0D00     
24824 B5D2 D80D  30        movb ra,@INWK+34                ; STA INWK+34
     B5D4 0075     
24825               
24826 B5D6 020D  20        li   ra,(SST)*256               ; LDA #SST          ; Set A to the space station type, and fall through
     B5D8 0800     
24827                                                                          ; into NWSHP to finish adding the space station to the
24828                                                                          ; universe
24829               
24830               * ******************************************************************************
24831               *
24832               * Name: NWSHP
24833               * Type: Subroutine
24834               * Category: Universe
24835               * Summary: Add a new ship to our local bubble of universe
24836               *
24837               * ------------------------------------------------------------------------------
24838               *
24839               * This creates a new block of ship data in the K% workspace, allocates a new
24840               * block in the ship line heap at WP, adds the new ship's type into the first
24841               * empty slot in FRIN, and adds a pointer to the ship data into UNIV. If there
24842               * isn't enough free memory for the new ship, it isn't added.
24843               *
24844               * ------------------------------------------------------------------------------
24845               *
24846               * Arguments:
24847               *
24848               * A                   The type of the ship to add (see variable XX21 for a
24849               * list of ship types)
24850               *
24851               * ------------------------------------------------------------------------------
24852               *
24853               * Returns:
24854               *
24855               * C flag              Set if the ship was successfully added, clear if it
24856               * wasn't (as there wasn't enough free memory)
24857               *
24858               * INF                 Points to the new ship's data block in K%
24859               *
24860               * ******************************************************************************
24861               
24862               NWSHP:
24863 B5DA D80D  30        movb ra,@T                      ; STA T             ; Store the ship type in location T
     B5DC 00D1     
24864               
24865 B5DE 020E  20        li   rx,>00*256                 ; LDX #0            ; Before we can add a new ship, we need to check
     B5E0 0000     
24866                                                                          ; whether we have an empty slot we can put it in. To do
24867                                                                          ; this, we need to loop through all the slots to look
24868                                                                          ; for an empty one, so set a counter in X that starts
24869                                                                          ; from the first slot at 0. When ships are killed, then
24870                                                                          ; the slots are shuffled down by the KILLSHP routine, so
24871                                                                          ; the first empty slot will always come after the last
24872                                                                          ; filled slot. This allows us to tack the new ship's
24873                                                                          ; data block and ship line heap onto the end of the
24874                                                                          ; existing ship data and heap, as shown in the memory
24875                                                                          ; map below
24876               
24877               NWL1:
24878 B5E2 06CE  14        swpb rx                         ;
24879 B5E4 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Load the ship type for the X-th slot
     B5E6 0D40     
24880 B5E8 06CE  14        swpb rx                         ;
24881               
24882 B5EA 1307  14        jeq  NW1                        ; BEQ NW1           ; If it is zero, then this slot is empty and we can use
24883                                                                          ; it for our new ship, so jump down to NW1
24884               
24885 B5EC B387  18        ab   rone,rx                    ; INX               ; Otherwise increment X to point to the next slot
24886               
24887 B5EE 028E  22        ci   rx,(NOSH)*256              ; CPX #NOSH         ; If we haven't reached the last slot yet, loop back up
     B5F0 0C00     
24888 B5F2 17F7  14        jnc  NWL1                       ; BCC NWL1          ; to NWL1 to check the next slot (note that this means
24889                                                                          ; only slots from 0 to #NOSH - 1 are populated by this
24890                                                                          ; routine, but there is one more slot reserved in FRIN,
24891                                                                          ; which is used to identify the end of the slot list
24892                                                                          ; when shuffling the slots down in the KILLSHP routine)
24893               
24894               NW3:
24895                      .clc                            ; CLC               ; Otherwise we don't have an empty slot, so we can't
     **** ****     > CLC
0001 B5F4 0A16  18        sla  rzero,1
                   < elite.a99
24896 B5F6 0460  28        b    @rts                       ; RTS               ; add a new ship, so clear the C flag to indicate that
     B5F8 FE34     
24897                                                                          ; we have not managed to create the new ship, and return
24898                                                                          ; from the subroutine
24899               
24900               NW1:
24901                                                                          ; If we get here, then we have found an empty slot at
24902                                                                          ; index X, so we can go ahead and create our new ship.
24903                                                                          ; We do that by creating a ship data block at INWK and,
24904                                                                          ; when we are done, copying the block from INWK into
24905                                                                          ; the K% workspace (specifically, to INF)
24906 B5FA 0200  20        li   rtmp,GINF                  ; JSR GINF          ; Get the address of the data block for ship slot X
     B5FC B564     
24907 B5FE 06A0  32        bl   @jsr                       ;
     B600 FE28     
24908                                                                          ; (which is in workspace K%) and store it in INF
24909               
24910 B602 D360  30        movb @T,ra                      ; LDA T             ; If the type of ship that we want to create is
     B604 00D1     
24911 B606 1169  14        jlt  NW2                        ; BMI NW2           ; negative, then this indicates a planet or sun, so
24912                                                                          ; jump down to NW2, as the next section sets up a ship
24913                                                                          ; data block, which doesn't apply to planets and suns,
24914                                                                          ; as they don't have things like shields, missiles,
24915                                                                          ; vertices and edges
24916               
24917                                                                          ; This is a ship, so first we need to set up various
24918                                                                          ; pointers to the ship blueprint we will need. The
24919                                                                          ; blueprints for each ship type in Elite are stored
24920                                                                          ; in a table at location XX21, so refer to the comments
24921                                                                          ; on that variable for more details on the data we're
24922                                                                          ; about to access
24923               
24924                      .asla                           ; ASL A             ; Set Y = ship type * 2
     **** ****     > ASLA
0001 B608 024D  22        andi ra,>ff00
     B60A FF00     
0002 B60C 0A1D  18        sla  ra,1
                   < elite.a99
24925 B60E D3CD  18        movb ra,ry                      ; TAY
24926               
24927 B610 06CF  14        swpb ry                         ;
24928 B612 D36F  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
     B614 F14C     
24929 B616 06CF  14        swpb ry                         ;
24930 B618 D80D  30        movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
     B61A 001E     
24931                                                                          ; so this fetches the low byte of this particular ship
24932                                                                          ; type's blueprint and stores it in XX0
24933               
24934 B61C 06CF  14        swpb ry                         ;
24935 B61E D36F  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
     B620 F14D     
24936 B622 06CF  14        swpb ry                         ;
24937 B624 D80D  30        movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1, so XX0(1 0) now
     B626 001F     
24938                                                                          ; contains the address of this ship's blueprint
24939               
24940 B628 028F  22        ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship type is a space station (SST), then jump
     B62A 1000     
24941 B62C 1338  14        jeq  NW6                        ; BEQ NW6           ; to NW6, skipping the heap space steps below, as the
24942                                                                          ; space station has its own line heap at LSO (which it
24943                                                                          ; shares with the sun)
24944               
24945                                                                          ; We now want to allocate space for a heap that we can
24946                                                                          ; use to store the lines we draw for our new ship (so it
24947                                                                          ; can easily be erased from the screen again). SLSP
24948                                                                          ; points to the start of the current heap space, and we
24949                                                                          ; can extend it downwards with the heap for our new ship
24950                                                                          ; (as the heap space always ends just before the WP
24951                                                                          ; workspace)
24952               
24953 B62E 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch ship blueprint byte #5, which contains the
     B630 0500     
24954                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; maximum heap size required for plotting the new ship,
     **** ****     > LD_IND_Y_IDX
0001 B632 D820  42        movb @XX0,@rtmplb
     B634 001E     
     B636 8301     
0002 B638 D020  30        movb @XX0+1,rtmp
     B63A 001F     
0003 B63C 06CF  14        swpb ry
0004 B63E A00F  18        a    ry,rtmp
0005 B640 06CF  14        swpb ry
0006 B642 D350  26        movb *rtmp,RA
                   < elite.a99
24955 B644 D80D  30        movb ra,@T1                     ; STA T1            ; and store it in T1
     B646 0006     
24956               
24957 B648 D360  30        movb @SLSP,ra                   ; LDA SLSP          ; Take the 16-bit address in SLSP and subtract T1,
     B64A 0F1E     
24958                      .sec                            ; SEC               ; storing the 16-bit result in INWK(34 33), so this now
     **** ****     > SEC
0001 B64C 0A18  18        sla  rmone,1
                   < elite.a99
24959                      .sbc @T1,ra                     ; SBC T1            ; points to the start of the line heap for our new ship
     **** ****     > SBC
0001 B64E 1801  14        joc  !
0002 B650 7347  18        sb   rone,ra
0003               !:
0004 B652 7360  30        sb   @T1,ra
     B654 0006     
                   < elite.a99
24960 B656 D80D  30        movb ra,@INWK+33                ; STA INWK+33
     B658 0074     
24961 B65A D360  30        movb @SLSP+1,ra                 ; LDA SLSP+1
     B65C 0F1F     
24962                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 B65E 1801  14        joc  !
0002 B660 7347  18        sb   rone,ra
0003               !:
0004 B662 022D  22        ai   ra,-(>00*256)
     B664 0000     
                   < elite.a99
24963 B666 D80D  30        movb ra,@INWK+34                ; STA INWK+34
     B668 0075     
24964               
24965                                                                          ; We now need to check that there is enough free space
24966                                                                          ; for both this new line heap and the new data block
24967                                                                          ; for our ship. In memory, this is the layout of the
24968                                                                          ; ship data blocks and ship line heaps:
24969                                                                          ;
24970                                                                          ; +-----------------------------------+   &0F34
24971                                                                          ; |                                   |
24972                                                                          ; | WP workspace                      |
24973                                                                          ; |                                   |
24974                                                                          ; +-----------------------------------+   &0D40 = WP
24975                                                                          ; |                                   |
24976                                                                          ; | Current ship line heap            |
24977                                                                          ; |                                   |
24978                                                                          ; +-----------------------------------+   SLSP
24979                                                                          ; |                                   |
24980                                                                          ; | Proposed heap for new ship        |
24981                                                                          ; |                                   |
24982                                                                          ; +-----------------------------------+   INWK(34 33)
24983                                                                          ; |                                   |
24984                                                                          ; .                                   .
24985                                                                          ; .                                   .
24986                                                                          ; .                                   .
24987                                                                          ; .                                   .
24988                                                                          ; .                                   .
24989                                                                          ; |                                   |
24990                                                                          ; +-----------------------------------+   INF + NI%
24991                                                                          ; |                                   |
24992                                                                          ; | Proposed data block for new ship  |
24993                                                                          ; |                                   |
24994                                                                          ; +-----------------------------------+   INF
24995                                                                          ; |                                   |
24996                                                                          ; | Existing ship data blocks         |
24997                                                                          ; |                                   |
24998                                                                          ; +-----------------------------------+   &0900 = K%
24999                                                                          ;
25000                                                                          ; So, to work out if we have enough space, we have to
25001                                                                          ; make sure there is room between the end of our new
25002                                                                          ; ship data block at INF + NI%, and the start of the
25003                                                                          ; proposed heap for our new ship at the address we
25004                                                                          ; stored in INWK(34 33). Or, to put it another way, we
25005                                                                          ; and to make sure that:
25006                                                                          ;
25007                                                                          ; INWK(34 33) > INF + NI%
25008                                                                          ;
25009                                                                          ; which is the same as saying:
25010                                                                          ;
25011                                                                          ; INWK+33 - INF > NI%
25012                                                                          ;
25013                                                                          ; because INWK is in zero page, so INWK+34 = 0
25014               
25015 B66A D360  30        movb @INWK+33,ra                ; LDA INWK+33       ; Calculate INWK+33 - INF, again using 16-bit
     B66C 0074     
25016               * SEC                    \ arithmetic, and put the result in (A Y), so the high
25017                      .sbc @INF,ra                    ; SBC INF           ; byte is in A and the low byte in Y. The SEC
     **** ****     > SBC
0001 B66E 1801  14        joc  !
0002 B670 7347  18        sb   rone,ra
0003               !:
0004 B672 7360  30        sb   @INF,ra
     B674 0020     
                   < elite.a99
25018 B676 D3CD  18        movb ra,ry                      ; TAY               ; instruction is commented out in the original source;
25019 B678 D360  30        movb @INWK+34,ra                ; LDA INWK+34       ; as the previous subtraction will never underflow, it
     B67A 0075     
25020                      .sbc @INF+1,ra                  ; SBC INF+1         ; is superfluous
     **** ****     > SBC
0001 B67C 1801  14        joc  !
0002 B67E 7347  18        sb   rone,ra
0003               !:
0004 B680 7360  30        sb   @INF+1,ra
     B682 0021     
                   < elite.a99
25021               
25022 B684 17B7  14        jnc  NW3+1                      ; BCC NW3+1         ; If we have an underflow from the subtraction, then
25023                                                                          ; INF > INWK+33 and we definitely don't have enough
25024                                                                          ; room for this ship, so jump to NW3+1, which returns
25025                                                                          ; from the subroutine (with the C flag already cleared)
25026               
25027 B686 1603  14        jne  NW4                        ; BNE NW4           ; If the subtraction of the high bytes in A is not
25028                                                                          ; zero, and we don't have underflow, then we definitely
25029                                                                          ; have enough space, so jump to NW4 to continue setting
25030                                                                          ; up the new ship
25031               
25032 B688 028F  22        ci   ry,(NI.)*256               ; CPY #NI%          ; Otherwise the high bytes are the same in our
     B68A 2400     
25033 B68C 17B3  14        jnc  NW3+1                      ; BCC NW3+1         ; subtraction, so now we compare the low byte of the
25034                                                                          ; result (which is in Y) with NI%. This is the same as
25035                                                                          ; doing INWK+33 - INF > NI% (see above). If this isn't
25036                                                                          ; true, the C flag will be clear and we don't have
25037                                                                          ; enough space, so we jump to NW3+1, which returns
25038                                                                          ; from the subroutine (with the C flag already cleared)
25039               
25040               NW4:
25041 B68E D360  30        movb @INWK+33,ra                ; LDA INWK+33       ; If we get here then we do have enough space for our
     B690 0074     
25042 B692 D80D  30        movb ra,@SLSP                   ; STA SLSP          ; new ship, so store the new bottom of the ship line
     B694 0F1E     
25043 B696 D360  30        movb @INWK+34,ra                ; LDA INWK+34       ; heap (i.e. INWK+33) in SLSP, doing both the high and
     B698 0075     
25044 B69A D80D  30        movb ra,@SLSP+1                 ; STA SLSP+1        ; low bytes
     B69C 0F1F     
25045               
25046               NW6:
25047 B69E 020F  20        li   ry,>0e*256                 ; LDY #14           ; Fetch ship blueprint byte #14, which contains the
     B6A0 0E00     
25048                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; ship's energy, and store it in byte #35
     **** ****     > LD_IND_Y_IDX
0001 B6A2 D820  42        movb @XX0,@rtmplb
     B6A4 001E     
     B6A6 8301     
0002 B6A8 D020  30        movb @XX0+1,rtmp
     B6AA 001F     
0003 B6AC 06CF  14        swpb ry
0004 B6AE A00F  18        a    ry,rtmp
0005 B6B0 06CF  14        swpb ry
0006 B6B2 D350  26        movb *rtmp,RA
                   < elite.a99
25049 B6B4 D80D  30        movb ra,@INWK+35                ; STA INWK+35
     B6B6 0076     
25050               
25051 B6B8 020F  20        li   ry,>13*256                 ; LDY #19           ; Fetch ship blueprint byte #19, which contains the
     B6BA 1300     
25052                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of missiles and laser power, and AND with %111
     **** ****     > LD_IND_Y_IDX
0001 B6BC D820  42        movb @XX0,@rtmplb
     B6BE 001E     
     B6C0 8301     
0002 B6C2 D020  30        movb @XX0+1,rtmp
     B6C4 001F     
0003 B6C6 06CF  14        swpb ry
0004 B6C8 A00F  18        a    ry,rtmp
0005 B6CA 06CF  14        swpb ry
0006 B6CC D350  26        movb *rtmp,RA
                   < elite.a99
25053 B6CE 024D  22        andi ra,>07*256                 ; AND #%00000111    ; to extract the number of missiles before storing in
     B6D0 0700     
25054 B6D2 D80D  30        movb ra,@INWK+31                ; STA INWK+31       ; byte #31
     B6D4 0072     
25055               
25056 B6D6 D360  30        movb @T,ra                      ; LDA T             ; Restore the ship type we stored above
     B6D8 00D1     
25057               
25058               NW2:
25059 B6DA 06CE  14        swpb rx                         ;
25060 B6DC DB8D  38        movb ra,@FRIN(rx)               ; STA FRIN,X        ; Store the ship type in the X-th byte of FRIN, so the
     B6DE 0D40     
25061 B6E0 06CE  14        swpb rx                         ;
25062                                                                          ; this slot is now shown as occupied in the index table
25063               
25064 B6E2 D38D  18        movb ra,rx                      ; TAX               ; Copy the ship type into X
25065               
25066 B6E4 1101  14        jlt  B74                        ; BMI B74           ; If the ship type is negative (planet or sun), then
25067                                                                          ; skip the following instruction
25068               
25069 B6E6 B347  18        ab   rone,ra                    ; INC MANY,X        ; Increment the total number of ships of type X
25070               
25071               B74:
25072 B6E8 020F  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; The final step is to copy the new ship's data block
     B6EA 2300     
25073                                                                          ; from INWK to INF, so set up a counter for NI% bytes
25074                                                                          ; in Y
25075               
25076               NWL3:
25077 B6EC 06CF  14        swpb ry                         ;
25078 B6EE D36F  34        movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store in the Y-th byte
     B6F0 0053     
25079 B6F2 06CF  14        swpb ry                         ;
25080                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; of the workspace pointed to by INF
     **** ****     > ST_IND_Y_IDX
0001 B6F4 D820  42        movb @INF,@rtmplb
     B6F6 0020     
     B6F8 8301     
0002 B6FA D020  30        movb @INF+1,rtmp
     B6FC 0021     
0003 B6FE 06CF  14        swpb ry
0004 B700 A00F  18        a    ry,rtmp
0005 B702 06CF  14        swpb ry
0006 B704 D40D  30        movb RA,*rtmp
                   < elite.a99
25081               
25082 B706 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
25083               
25084 B708 15F1  14        jgt  NWL3                       ; BPL NWL3          ; Loop back for the next byte until we have copied them
25085                                                                          ; all over
25086               
25087                      .sec                            ; SEC               ; We have successfully created our new ship, so set the
     **** ****     > SEC
0001 B70A 0A18  18        sla  rmone,1
                   < elite.a99
25088                                                                          ; C flag to indicate success
25089               
25090 B70C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B70E FE34     
25091               
25092               * ******************************************************************************
25093               *
25094               * Name: NwS1
25095               * Type: Subroutine
25096               * Category: Universe
25097               * Summary: Flip the sign and double an INWK byte
25098               *
25099               * ------------------------------------------------------------------------------
25100               *
25101               * Flip the sign of the INWK byte at offset X, and increment X by 2. This is
25102               * used by the space station creation routine at NWSPS.
25103               *
25104               * ------------------------------------------------------------------------------
25105               *
25106               * Arguments:
25107               *
25108               * X                   The offset of the INWK byte to be flipped
25109               *
25110               * ------------------------------------------------------------------------------
25111               *
25112               * Returns:
25113               *
25114               * X                   X is incremented by 2
25115               *
25116               * ******************************************************************************
25117               
25118               NwS1:
25119 B710 06CE  14        swpb rx                         ;
25120 B712 D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Load the X-th byte of INWK into A and flip bit 7,
     B714 0053     
25121 B716 06CE  14        swpb rx                         ;
25122                      .eoi (>80*256)                  ; EOR #%10000000    ; storing the result back in the X-th byte of INWK
     **** ****     > EOI
0001 B718 0200  20        li   rtmp,(>80*256)
     B71A 8000     
0002 B71C 2B40  18        xor  rtmp,ra
                   < elite.a99
25123 B71E 06CE  14        swpb rx                         ;
25124 B720 DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X
     B722 0053     
25125 B724 06CE  14        swpb rx                         ;
25126               
25127 B726 B387  18        ab   rone,rx                    ; INX               ; Add 2 to X
25128 B728 B387  18        ab   rone,rx                    ; INX
25129               
25130 B72A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B72C FE34     
25131               
25132               * ******************************************************************************
25133               *
25134               * Name: ABORT
25135               * Type: Subroutine
25136               * Category: Dashboard
25137               * Summary: Disarm missiles and update the dashboard indicators
25138               *
25139               * ------------------------------------------------------------------------------
25140               *
25141               * Arguments:
25142               *
25143               * Y                   The new status of the leftmost missile indicator
25144               *
25145               * ******************************************************************************
25146               
25147               ABORT:
25148 B72E 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set X to &FF, which is the value of MSTG when we have
     B730 FF00     
25149                                                                          ; no target lock for our missile
25150               
25151                                                                          ; Fall through into ABORT2 to set the missile lock to
25152                                                                          ; the value in X, which effectively disarms the missile
25153               
25154               * ******************************************************************************
25155               *
25156               * Name: ABORT2
25157               * Type: Subroutine
25158               * Category: Dashboard
25159               * Summary: Set/unset the lock target for a missile and update the dashboard
25160               *
25161               * ------------------------------------------------------------------------------
25162               *
25163               * Set the lock target for the leftmost missile and update the dashboard.
25164               *
25165               * ------------------------------------------------------------------------------
25166               *
25167               * Arguments:
25168               *
25169               * X                   The slot number of the ship to lock our missile onto, or
25170               * &FF to remove missile lock
25171               *
25172               * Y                   The new colour of the missile indicator:
25173               *
25174               * * &00 = black (no missile)
25175               *
25176               * * &0E = red (armed and locked)
25177               *
25178               * * &E0 = yellow/white (armed)
25179               *
25180               * * &EE = green/cyan (disarmed)
25181               *
25182               * ******************************************************************************
25183               
25184               ABORT2:
25185 B732 D80E  30        movb rx,@MSTG                   ; STX MSTG          ; Store the target of our missile lock in MSTG
     B734 0052     
25186               
25187 B736 D3A0  30        movb @NOMSL,rx                  ; LDX NOMSL         ; Call MSBAR to update the leftmost indicator in the
     B738 0333     
25188 B73A 0200  20        li   rtmp,MSBAR                 ; JSR MSBAR         ; dashboard's missile bar, which returns with Y = 0
     B73C B79A     
25189 B73E 06A0  32        bl   @jsr                       ;
     B740 FE28     
25190               
25191 B742 D80F  30        movb ry,@MSAR                   ; STY MSAR          ; Set MSAR = 0 to indicate that the leftmost missile
     B744 0D5E     
25192                                                                          ; is no longer seeking a target lock
25193               
25194 B746 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B748 FE34     
25195               
25196               * ******************************************************************************
25197               *
25198               * Name: ECBLB2
25199               * Type: Subroutine
25200               * Category: Dashboard
25201               * Summary: Start up the E.C.M. (light up the indicator, start the countdown
25202               * and make the E.C.M. sound)
25203               *
25204               * ******************************************************************************
25205               
25206               ECBLB2:
25207 B74A 020D  20        li   ra,>20*256                 ; LDA #32           ; Set the E.C.M. countdown timer in ECMA to 32
     B74C 2000     
25208 B74E D80D  30        movb ra,@ECMA                   ; STA ECMA
     B750 0030     
25209               
25210                      .asla                           ; ASL A             ; Call the NOISE routine with A = 64 to make the sound
     **** ****     > ASLA
0001 B752 024D  22        andi ra,>ff00
     B754 FF00     
0002 B756 0A1D  18        sla  ra,1
                   < elite.a99
25211 B758 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; of the E.C.M. being switched on
     B75A D340     
25212 B75C 06A0  32        bl   @jsr                       ;
     B75E FE28     
25213               
25214                                                                          ; Fall through into ECBLB to light up the E.C.M. bulb
25215               
25216               * ******************************************************************************
25217               *
25218               * Name: ECBLB
25219               * Type: Subroutine
25220               * Category: Dashboard
25221               * Summary: Light up the E.C.M. indicator bulb ("E") on the dashboard
25222               *
25223               * ******************************************************************************
25224               
25225               ECBLB:
25226 B760 020D  20        li   ra,(7*8)*256               ; LDA #7*8          ; The E.C.M. bulb is in character block number 7
     B762 3800     
25227                                                                          ; with each character taking 8 bytes, so this sets the
25228                                                                          ; low byte of the screen address of the character block
25229                                                                          ; we want to draw to
25230               
25231 B764 020E  20        li   rx,((ECBT)%256)*256        ; LDX #LO(ECBT)     ; Set (Y X) to point to the character definition in
     B766 7200     
25232 B768 020F  20        li   ry,((ECBT)/256)*256        ; LDY #HI(ECBT)     ; ECBT. The LDY has no effect, as we overwrite Y with
     B76A B800     
25233                                                                          ; the jump to BULB-2, which writes the high byte of SPBT
25234                                                                          ; into Y. This works as long as ECBT and SPBT are in
25235                                                                          ; the same page of memory, so perhaps the BNE below got
25236                                                                          ; changed from BULB to BULB-2 so they could remove the
25237                                                                          ; LDY, but for some reason it didn't get culled? Who
25238                                                                          ; knows...
25239               
25240 B76C 1605  14        jne  BULB-2                     ; BNE BULB-2        ; Jump down to BULB-2 (this BNE is effectively a JMP as
25241                                                                          ; A will never be zero)
25242               
25243               * ******************************************************************************
25244               *
25245               * Name: SPBLB
25246               * Type: Subroutine
25247               * Category: Dashboard
25248               * Summary: Light up the space station indicator ("S") on the dashboard
25249               *
25250               * ******************************************************************************
25251               
25252               SPBLB:
25253 B76E 020D  20        li   ra,(24*8)*256              ; LDA #24*8         ; The space station bulb is in character block number 24
     B770 C000     
25254                                                                          ; with each character taking 8 bytes, so this sets the
25255                                                                          ; low byte of the screen address of the character block
25256                                                                          ; we want to draw to
25257               
25258 B772 020E  20        li   rx,((SPBT)%256)*256        ; LDX #LO(SPBT)     ; Set (Y X) to point to the character definition in SPBT
     B774 6F00     
25259 B776 020F  20        li   ry,((SPBT)/256)*256        ; LDY #HI(SPBT)
     B778 B800     
25260               
25261                                                                          ; Fall through into BULB to draw the space station bulb
25262               
25263               * ******************************************************************************
25264               *
25265               * Name: BULB
25266               * Type: Subroutine
25267               * Category: Dashboard
25268               * Summary: Draw an indicator bulb on the dashboard
25269               *
25270               * ------------------------------------------------------------------------------
25271               *
25272               * Arguments:
25273               *
25274               * A                   The y-coordinate of the bulb as a low-byte screen
25275               * address offset within screen page &7D (as both bulbs
25276               * are on this character row in the dashboard)
25277               *
25278               * (Y X)               The address of the character definition of the bulb to
25279               * be drawn (i.e. ECBT for the E.C.M. bulb, or SPBT for the
25280               * space station bulb)
25281               *
25282               * ------------------------------------------------------------------------------
25283               *
25284               * Other entry points:
25285               *
25286               * BULB-2              Set the Y screen address
25287               *
25288               * ******************************************************************************
25289               
25290               BULB:
25291 B77A D80D  30        movb ra,@SC                     ; STA SC            ; Store the low byte of the screen address in SC
     B77C 0007     
25292               
25293 B77E D80E  30        movb rx,@P+1                    ; STX P+1           ; Set P(2 1) = (Y X)
     B780 001C     
25294 B782 D80F  30        movb ry,@P+2                    ; STY P+2
     B784 001D     
25295               
25296 B786 020D  20        li   ra,>7d*256                 ; LDA #&7D          ; Set A to the high byte of the screen address, which is
     B788 7D00     
25297                                                                          ; &7D as the bulbs are both in the character row from
25298                                                                          ; &7D00 to &7DFF
25299               
25300 B78A 0460  28        b    @RREN                      ; JMP RREN          ; Call RREN to print the character definition pointed to
     B78C 34CE     
25301                                                                          ; by P(2 1) at the screen address pointed to by (A SC),
25302                                                                          ; returning from the subroutine using a tail call
25303               
25304               * ******************************************************************************
25305               *
25306               * Name: ECBT
25307               * Type: Variable
25308               * Category: Dashboard
25309               * Summary: The character bitmap for the E.C.M. indicator bulb
25310               *
25311               * ------------------------------------------------------------------------------
25312               *
25313               * The character bitmap for the E.C.M. indicator's "E" bulb that gets displayed
25314               * on the dashboard.
25315               *
25316               * The E.C.M. indicator uses the first 5 rows of the space station's "S" bulb
25317               * below, as the bottom 5 rows of the "E" match the top 5 rows of the "S".
25318               *
25319               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
25320               *
25321               * ******************************************************************************
25322               
25323               ECBT:
25324 B78E E0              byte >e0                                            ; x x x .
25325 B78F   E0            byte >e0                                            ; x x x .
25326 B790 80              byte >80                                            ; x . . .
25327                                                                          ; x x x .
25328                                                                          ; x x x .
25329                                                                          ; x . . .
25330                                                                          ; x x x .
25331                                                                          ; x x x .
25332               
25333               * ******************************************************************************
25334               *
25335               * Name: SPBT
25336               * Type: Variable
25337               * Category: Dashboard
25338               * Summary: The bitmap definition for the space station indicator bulb
25339               *
25340               * ------------------------------------------------------------------------------
25341               *
25342               * The bitmap definition for the space station indicator's "S" bulb that gets
25343               * displayed on the dashboard.
25344               *
25345               * Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
25346               *
25347               * ******************************************************************************
25348               
25349               SPBT:
25350 B791   E0            byte >e0                                            ; x x x .
25351 B792 E0              byte >e0                                            ; x x x .
25352 B793   80            byte >80                                            ; x . . .
25353 B794 E0              byte >e0                                            ; x x x .
25354 B795   E0            byte >e0                                            ; x x x .
25355 B796 20              byte >20                                            ; . . x .
25356 B797   E0            byte >e0                                            ; x x x .
25357 B798 E0              byte >e0                                            ; x x x .
25358               
25359               * ******************************************************************************
25360               *
25361               * Name: MSBAR
25362               * Type: Subroutine
25363               * Category: Dashboard
25364               * Summary: Draw a specific indicator in the dashboard's missile bar
25365               *
25366               * ------------------------------------------------------------------------------
25367               *
25368               * Each indicator is a rectangle that's 3 pixels wide and 5 pixels high. If the
25369               * indicator is set to black, this effectively removes a missile.
25370               *
25371               * ------------------------------------------------------------------------------
25372               *
25373               * Arguments:
25374               *
25375               * X                   The number of the missile indicator to update (counting
25376               * from right to left, so indicator NOMSL is the leftmost
25377               * indicator)
25378               *
25379               * Y                   The colour of the missile indicator:
25380               *
25381               * * &00 = black (no missile)
25382               *
25383               * * &0E = red (armed and locked)
25384               *
25385               * * &E0 = yellow/white (armed)
25386               *
25387               * * &EE = green/cyan (disarmed)
25388               *
25389               * ------------------------------------------------------------------------------
25390               *
25391               * Returns:
25392               *
25393               * X                   X is preserved
25394               *
25395               * Y                   Y is set to 0
25396               *
25397               * ******************************************************************************
25398               
25399               MSBAR:
25400 B79A D34E  18        movb rx,ra                      ; TXA               ; Set T = X * 8
25401                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B79C 024D  22        andi ra,>ff00
     B79E FF00     
0002 B7A0 0A1D  18        sla  ra,1
                   < elite.a99
25402                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B7A2 024D  22        andi ra,>ff00
     B7A4 FF00     
0002 B7A6 0A1D  18        sla  ra,1
                   < elite.a99
25403                      .asla                           ; ASL A
     **** ****     > ASLA
0001 B7A8 024D  22        andi ra,>ff00
     B7AA FF00     
0002 B7AC 0A1D  18        sla  ra,1
                   < elite.a99
25404 B7AE D80D  30        movb ra,@T                      ; STA T
     B7B0 00D1     
25405               
25406 B7B2 020D  20        li   ra,>31*256                 ; LDA #49           ; Set SC = 49 - T
     B7B4 3100     
25407                      .sbc @T,ra                      ; SBC T             ; = 48 + 1 - (X * 8)
     **** ****     > SBC
0001 B7B6 1801  14        joc  !
0002 B7B8 7347  18        sb   rone,ra
0003               !:
0004 B7BA 7360  30        sb   @T,ra
     B7BC 00D1     
                   < elite.a99
25408 B7BE D80D  30        movb ra,@SC                     ; STA SC
     B7C0 0007     
25409               
25410                                                                          ; So the low byte of SC(1 0) contains the row address
25411                                                                          ; for the rightmost missile indicator, made up as
25412                                                                          ; follows:
25413                                                                          ;
25414                                                                          ; * 48 (character block 7, as byte #7 * 8 = 48), the
25415                                                                          ; character block of the rightmost missile
25416                                                                          ;
25417                                                                          ; * 1 (so we start drawing on the second row of the
25418                                                                          ; character block)
25419                                                                          ;
25420                                                                          ; * Move left one character (8 bytes) for each count
25421                                                                          ; of X, so when X = 0 we are drawing the rightmost
25422                                                                          ; missile, for X = 1 we hop to the left by one
25423                                                                          ; character, and so on
25424               
25425 B7C2 020D  20        li   ra,>7e*256                 ; LDA #&7E          ; Set the high byte of SC(1 0) to &7E, the character row
     B7C4 7E00     
25426 B7C6 D80D  30        movb ra,@SCH                    ; STA SCH           ; that contains the missile indicators (i.e. the bottom
     B7C8 0008     
25427                                                                          ; row of the screen)
25428               
25429 B7CA D34F  18        movb ry,ra                      ; TYA               ; Set A to the correct colour, which is a 3-pixel wide
25430                                                                          ; mode 5 character row in the correct colour (for
25431                                                                          ; example, a green block has Y = &EE, or %11101110, so
25432                                                                          ; the missile blocks are 3 pixels wide, with the
25433                                                                          ; fourth pixel on the character row being empty)
25434               
25435 B7CC 020F  20        li   ry,>05*256                 ; LDY #5            ; We now want to draw this line five times, so set a
     B7CE 0500     
25436                                                                          ; counter in Y
25437               
25438               MBL1:
25439                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the 3-pixel row, and as we do not use EOR logic,
     **** ****     > ST_IND_Y_IDX
0001 B7D0 D820  42        movb @SC,@rtmplb
     B7D2 0007     
     B7D4 8301     
0002 B7D6 D020  30        movb @SC+1,rtmp
     B7D8 0008     
0003 B7DA 06CF  14        swpb ry
0004 B7DC A00F  18        a    ry,rtmp
0005 B7DE 06CF  14        swpb ry
0006 B7E0 D40D  30        movb RA,*rtmp
                   < elite.a99
25440                                                                          ; this will overwrite anything that is already there
25441                                                                          ; (so drawing a black missile will delete what's there)
25442               
25443 B7E2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter for the next row
25444               
25445 B7E4 16F5  14        jne  MBL1                       ; BNE MBL1          ; Loop back to MBL1 if have more rows to draw
25446               
25447 B7E6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B7E8 FE34     
25448               
25449               * ******************************************************************************
25450               *
25451               * Name: PROJ
25452               * Type: Subroutine
25453               * Category: Maths (Geometry)
25454               * Summary: Project the current ship or planet onto the screen
25455               * Deep dive: Extended screen coordinates
25456               *
25457               * ------------------------------------------------------------------------------
25458               *
25459               * Project the current ship's location or the planet onto the screen, either
25460               * returning the screen coordinates of the projection (if it's on-screen), or
25461               * returning an error via the C flag.
25462               *
25463               * In this context, "on-screen" means that the point is projected into the
25464               * following range:
25465               *
25466               * centre of screen - 1024 < x < centre of screen + 1024
25467               * centre of screen - 1024 < y < centre of screen + 1024
25468               *
25469               * This is to cater for ships (and, more likely, planets and suns) whose centres
25470               * are off-screen but whose edges may still be visible.
25471               *
25472               * The projection calculation is:
25473               *
25474               * K3(1 0) = #X + x / z
25475               * K4(1 0) = #Y + y / z
25476               *
25477               * where #X and #Y are the pixel x-coordinate and y-coordinate of the centre of
25478               * the screen.
25479               *
25480               * ------------------------------------------------------------------------------
25481               *
25482               * Arguments:
25483               *
25484               * INWK                The ship data block for the ship to project on-screen
25485               *
25486               * ------------------------------------------------------------------------------
25487               *
25488               * Returns:
25489               *
25490               * K3(1 0)             The x-coordinate of the ship's projection on-screen
25491               *
25492               * K4(1 0)             The y-coordinate of the ship's projection on-screen
25493               *
25494               * C flag              Set if the ship's projection doesn't fit on the screen,
25495               * clear if it does project onto the screen
25496               *
25497               * A                   Contains K4+1, the high byte of the y-coordinate
25498               *
25499               * ******************************************************************************
25500               
25501               PROJ:
25502 B7EA D360  30        movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
     B7EC 0053     
25503 B7EE D80D  30        movb ra,@P                      ; STA P             ; = x
     B7F0 001B     
25504 B7F2 D360  30        movb @INWK+1,ra                 ; LDA INWK+1
     B7F4 0054     
25505 B7F6 D80D  30        movb ra,@P+1                    ; STA P+1
     B7F8 001C     
25506               
25507 B7FA D360  30        movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign
     B7FC 0055     
25508               
25509 B7FE 0200  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     B800 C214     
25510 B802 06A0  32        bl   @jsr                       ;
     B804 FE28     
25511                                                                          ;
25512                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
25513                                                                          ; = (x_sign x_hi x_lo) / (z_sign z_hi z_lo)
25514                                                                          ; = x / z
25515               
25516 B806 1832  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
25517                                                                          ; the coordinate doesn't fit on the screen, so return
25518                                                                          ; from the subroutine with the C flag set (as PL2-1
25519                                                                          ; contains an RTS)
25520               
25521 B808 D360  30        movb @K,ra                      ; LDA K             ; Set K3(1 0) = (X K) + #X
     B80A 003D     
25522                      .adi ((X)*256)                  ; ADC #X            ; = #X + x / z
     **** ****     > ADI
0001 B80C 1701  14        jnc  !
0002 B80E B347  18        ab   rone,ra
0003               !:
0004 B810 022D  22        ai   ra,((X)*256)
     B812 8000     
                   < elite.a99
25523 B814 D80D  30        movb ra,@K3                     ; STA K3            ;
     B816 00D2     
25524                                                                          ; first doing the low bytes
25525               
25526 B818 D34E  18        movb rx,ra                      ; TXA               ; And then the high bytes. #X is the x-coordinate of
25527                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 B81A 1701  14        jnc  !
0002 B81C B347  18        ab   rone,ra
0003               !:
0004 B81E 022D  22        ai   ra,(>00*256)
     B820 0000     
                   < elite.a99
25528 B822 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; space x-coordinate into a screen x-coordinate
     B824 00D3     
25529               
25530 B826 D360  30        movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
     B828 0056     
25531 B82A D80D  30        movb ra,@P                      ; STA P
     B82C 001B     
25532 B82E D360  30        movb @INWK+4,ra                 ; LDA INWK+4
     B830 0057     
25533 B832 D80D  30        movb ra,@P+1                    ; STA P+1
     B834 001C     
25534               
25535 B836 D360  30        movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = -y_sign
     B838 0058     
25536                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B83A 0200  20        li   rtmp,(>80*256)
     B83C 8000     
0002 B83E 2B40  18        xor  rtmp,ra
                   < elite.a99
25537               
25538 B840 0200  20        li   rtmp,PLS6                  ; JSR PLS6          ; Call PLS6 to calculate:
     B842 C214     
25539 B844 06A0  32        bl   @jsr                       ;
     B846 FE28     
25540                                                                          ;
25541                                                                          ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
25542                                                                          ; = -(y_sign y_hi y_lo) / (z_sign z_hi z_lo)
25543                                                                          ; = -y / z
25544               
25545 B848 1811  14        joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
25546                                                                          ; the coordinate doesn't fit on the screen, so return
25547                                                                          ; from the subroutine with the C flag set (as PL2-1
25548                                                                          ; contains an RTS)
25549               
25550 B84A D360  30        movb @K,ra                      ; LDA K             ; Set K4(1 0) = (X K) + #Y
     B84C 003D     
25551                      .adi ((Y)*256)                  ; ADC #Y            ; = #Y - y / z
     **** ****     > ADI
0001 B84E 1701  14        jnc  !
0002 B850 B347  18        ab   rone,ra
0003               !:
0004 B852 022D  22        ai   ra,((Y)*256)
     B854 6000     
                   < elite.a99
25552 B856 D80D  30        movb ra,@K4                     ; STA K4            ;
     B858 00E0     
25553                                                                          ; first doing the low bytes
25554               
25555 B85A D34E  18        movb rx,ra                      ; TXA               ; And then the high bytes. #Y is the y-coordinate of
25556                      .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
     **** ****     > ADI
0001 B85C 1701  14        jnc  !
0002 B85E B347  18        ab   rone,ra
0003               !:
0004 B860 022D  22        ai   ra,(>00*256)
     B862 0000     
                   < elite.a99
25557 B864 D80D  30        movb ra,@K4+1                   ; STA K4+1          ; space x-coordinate into a screen y-coordinate
     B866 00E1     
25558               
25559                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 B868 0A16  18        sla  rzero,1
                   < elite.a99
25560               
25561 B86A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     B86C FE34     
25562               
25563               * ******************************************************************************
25564               *
25565               * Name: PL2
25566               * Type: Subroutine
25567               * Category: Drawing planets
25568               * Summary: Remove the planet or sun from the screen
25569               *
25570               * ------------------------------------------------------------------------------
25571               *
25572               * Other entry points:
25573               *
25574               * PL2-1               Contains an RTS
25575               *
25576               * ******************************************************************************
25577               
25578               PL2:
25579 B86E D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Shift bit 0 of the planet/sun's type into the C flag
     B870 009B     
25580 B872 091D  18        srl  ra,1                       ; LSR A
25581               
25582 B874 1802  14        joc  B75                        ; BCS B75           ; If the planet/sun's type has bit 0 clear, then it's
25583                                                                          ; either 128 or 130, which is a planet; meanwhile, the
25584                                                                          ; sun has type 129, which has bit 0 set. So if this is
25585                                                                          ; the sun, skip the following instruction
25586               
25587 B876 0460  28        b    @WPLS2                     ; JMP WPLS2         ; This is the planet, so jump to WPLS2 to remove it from
     B878 BFC6     
25588                                                                          ; screen, returning from the subroutine using a tail
25589                                                                          ; call
25590               
25591               B75:
25592 B87A 0460  28        b    @WPLS                      ; JMP WPLS          ; This is the sun, so jump to WPLS to remove it from
     B87C C048     
25593                                                                          ; screen, returning from the subroutine using a tail
25594                                                                          ; call
25595               
25596               * ******************************************************************************
25597               *
25598               * Name: PLANET
25599               * Type: Subroutine
25600               * Category: Drawing planets
25601               * Summary: Draw the planet or sun
25602               *
25603               * ------------------------------------------------------------------------------
25604               *
25605               * Arguments:
25606               *
25607               * INWK                The planet or sun's ship data block
25608               *
25609               * ******************************************************************************
25610               
25611               PLANET:
25612 B87E D360  30        movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign (the highest byte in the planet/sun's
     B880 005B     
25613                                                                          ; coordinates)
25614               
25615 B882 11F5  14        jlt  PL2                        ; BMI PL2           ; If A is negative then the planet/sun is behind us, so
25616                                                                          ; jump to PL2 to remove it from the screen, returning
25617                                                                          ; from the subroutine using a tail call
25618               
25619 B884 028D  22        ci   ra,>30*256                 ; CMP #48           ; If A >= 48 then the planet/sun is too far away to be
     B886 3000     
25620 B888 18F2  14        joc  PL2                        ; BCS PL2           ; seen, so jump to PL2 to remove it from the screen,
25621                                                                          ; returning from the subroutine using a tail call
25622               
25623 B88A F360  30        socb @INWK+7,ra                 ; ORA INWK+7        ; Set A to 0 if both z_sign and z_hi are 0
     B88C 005A     
25624               
25625 B88E 13EF  14        jeq  PL2                        ; BEQ PL2           ; If both z_sign and z_hi are 0, then the planet/sun is
25626                                                                          ; too close to be shown, so jump to PL2 to remove it
25627                                                                          ; from the screen, returning from the subroutine using a
25628                                                                          ; tail call
25629               
25630 B890 0200  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the planet/sun onto the screen, returning the
     B892 B7EA     
25631 B894 06A0  32        bl   @jsr                       ;
     B896 FE28     
25632                                                                          ; centre's coordinates in K3(1 0) and K4(1 0)
25633               
25634 B898 18EA  14        joc  PL2                        ; BCS PL2           ; If the C flag is set by PROJ then the planet/sun is
25635                                                                          ; not visible on-screen, so jump to PL2 to remove it
25636                                                                          ; from the screen, returning from the subroutine using
25637                                                                          ; a tail call
25638               
25639 B89A 020D  20        li   ra,>60*256                 ; LDA #96           ; Set (A P+1 P) = (0 96 0) = 24576
     B89C 6000     
25640 B89E D80D  30        movb ra,@P+1                    ; STA P+1           ;
     B8A0 001C     
25641 B8A2 020D  20        li   ra,>00*256                 ; LDA #0            ; This represents the planet/sun's radius at a distance
     B8A4 0000     
25642 B8A6 D80D  30        movb ra,@P                      ; STA P             ; of z = 1
     B8A8 001B     
25643               
25644 B8AA 0200  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     B8AC 4994     
25645 B8AE 06A0  32        bl   @jsr                       ;
     B8B0 FE28     
25646                                                                          ;
25647                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
25648                                                                          ; = (0 96 0) / z
25649                                                                          ; = 24576 / z
25650                                                                          ;
25651                                                                          ; so K now contains the planet/sun's radius, reduced by
25652                                                                          ; the actual distance to the planet/sun. We know that
25653                                                                          ; K+3 and K+2 will be 0, as the number we are dividing,
25654                                                                          ; (0 96 0), fits into the two bottom bytes, so the
25655                                                                          ; result is actually in K(1 0)
25656               
25657 B8B2 D360  30        movb @K+1,ra                    ; LDA K+1           ; If the high byte of the reduced radius is zero, jump
     B8B4 003E     
25658 B8B6 1304  14        jeq  PL82                       ; BEQ PL82          ; to PL82, as K contains the radius on its own
25659               
25660 B8B8 020D  20        li   ra,>f8*256                 ; LDA #248          ; Otherwise set K = 248, to round up the radius in
     B8BA F800     
25661 B8BC D80D  30        movb ra,@K                      ; STA K             ; K(1 0) to the nearest integer (if we consider the low
     B8BE 003D     
25662                                                                          ; byte to be the fractional part)
25663               
25664               PL82:
25665 B8C0 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet/sun's type has bit 0 clear, then it's
     B8C2 009B     
25666 B8C4 091D  18        srl  ra,1                       ; LSR A             ; either 128 or 130, which is a planet (the sun has type
25667 B8C6 1702  14        jnc  PL9                        ; BCC PL9           ; 129, which has bit 0 set). So jump to PL9 to draw the
25668                                                                          ; planet with radius K, returning from the subroutine
25669                                                                          ; using a tail call
25670               
25671 B8C8 0460  28        b    @SUN                       ; JMP SUN           ; Otherwise jump to SUN to draw the sun with radius K,
     B8CA BC68     
25672                                                                          ; returning from the subroutine using a tail call
25673               
25674               * ******************************************************************************
25675               *
25676               * Name: PL9 (Part 1 of 3)
25677               * Type: Subroutine
25678               * Category: Drawing planets
25679               * Summary: Draw the planet, with either an equator and meridian, or a crater
25680               *
25681               * ------------------------------------------------------------------------------
25682               *
25683               * Draw the planet with radius K at pixel coordinate (K3, K4), and with either an
25684               * equator and meridian, or a crater.
25685               *
25686               * ------------------------------------------------------------------------------
25687               *
25688               * Arguments:
25689               *
25690               * K(1 0)              The planet's radius
25691               *
25692               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25693               *
25694               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25695               *
25696               * INWK                The planet's ship data block
25697               *
25698               * ******************************************************************************
25699               
25700               PL9:
25701 B8CC 0200  20        li   rtmp,WPLS2                 ; JSR WPLS2         ; Call WPLS2 to remove the planet from the screen
     B8CE BFC6     
25702 B8D0 06A0  32        bl   @jsr                       ;
     B8D2 FE28     
25703               
25704 B8D4 0200  20        li   rtmp,CIRCLE                ; JSR CIRCLE        ; Call CIRCLE to draw the planet's new circle
     B8D6 BEBA     
25705 B8D8 06A0  32        bl   @jsr                       ;
     B8DA FE28     
25706               
25707 B8DC 1803  14        joc  PL20                       ; BCS PL20          ; If the call to CIRCLE returned with the C flag set,
25708                                                                          ; then the circle does not fit on-screen, so jump to
25709                                                                          ; PL20 to return from the subroutine
25710               
25711 B8DE D360  30        movb @K+1,ra                    ; LDA K+1           ; If K+1 is zero, jump to PL25 as K(1 0) < 256, so the
     B8E0 003E     
25712 B8E2 1302  14        jeq  PL25                       ; BEQ PL25          ; planet fits on the screen and we can draw meridians or
25713                                                                          ; craters
25714               
25715               PL20:
25716 B8E4 0460  28        b    @rts                       ; RTS               ; The planet doesn't fit on-screen, so return from the
     B8E6 FE34     
25717                                                                          ; subroutine
25718               
25719               PL25:
25720 B8E8 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the planet type is 128 then it has an equator and
     B8EA 009B     
25721 B8EC 028D  22        ci   ra,>80*256                 ; CMP #128          ; a meridian, so this jumps to PL26 if this is not a
     B8EE 8000     
25722 B8F0 1643  14        jne  PL26                       ; BNE PL26          ; planet with an equator - in other words, if it is a
25723                                                                          ; planet with a crater
25724               
25725                                                                          ; Otherwise this is a planet with an equator and
25726                                                                          ; meridian, so fall through into the following to draw
25727                                                                          ; them
25728               
25729               * ******************************************************************************
25730               *
25731               * Name: PL9 (Part 2 of 3)
25732               * Type: Subroutine
25733               * Category: Drawing planets
25734               * Summary: Draw the planet's equator and meridian
25735               * Deep dive: Drawing meridians and equators
25736               *
25737               * ------------------------------------------------------------------------------
25738               *
25739               * Draw the planet's equator and meridian.
25740               *
25741               * ------------------------------------------------------------------------------
25742               *
25743               * Arguments:
25744               *
25745               * K(1 0)              The planet's radius
25746               *
25747               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25748               *
25749               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25750               *
25751               * INWK                The planet's ship data block
25752               *
25753               * ******************************************************************************
25754               
25755 B8F2 D360  30        movb @K,ra                      ; LDA K             ; If the planet's radius is less than 6, the planet is
     B8F4 003D     
25756 B8F6 028D  22        ci   ra,>06*256                 ; CMP #6            ; too small to show a meridian, so jump to PL20 to
     B8F8 0600     
25757 B8FA 17F4  14        jnc  PL20                       ; BCC PL20          ; return from the subroutine
25758               
25759 B8FC D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     B8FE 0061     
25760                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B900 0200  20        li   rtmp,(>80*256)
     B902 8000     
0002 B904 2B40  18        xor  rtmp,ra
                   < elite.a99
25761 B906 D80D  30        movb ra,@P                      ; STA P
     B908 001B     
25762               
25763 B90A D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     B90C 0067     
25764               
25765 B90E 0200  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     B910 C1CC     
25766 B912 06A0  32        bl   @jsr                       ;
     B914 FE28     
25767                                                                          ;
25768                                                                          ; CNT2 = arctan(P / A) / 4
25769                                                                          ; = arctan(-nosev_z_hi / roofv_z_hi) / 4
25770                                                                          ;
25771                                                                          ; and do the following if nosev_z_hi >= 0:
25772                                                                          ;
25773                                                                          ; CNT2 = CNT2 + PI
25774               
25775 B916 020E  20        li   rx,>09*256                 ; LDX #9            ; Set X to 9 so the call to PLS1 divides nosev_x
     B918 0900     
25776               
25777 B91A 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B91C BA3C     
25778 B91E 06A0  32        bl   @jsr                       ;
     B920 FE28     
25779 B922 D80D  30        movb ra,@K2                     ; STA K2            ;
     B924 00AC     
25780 B926 D80F  30        movb ry,@XX16                   ; STY XX16          ; (XX16 K2) = nosev_x / z
     B928 0009     
25781                                                                          ;
25782                                                                          ; and increment X to point to nosev_y for the next call
25783               
25784 B92A 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B92C BA3C     
25785 B92E 06A0  32        bl   @jsr                       ;
     B930 FE28     
25786 B932 D80D  30        movb ra,@K2+1                   ; STA K2+1          ;
     B934 00AD     
25787 B936 D80F  30        movb ry,@XX16+1                 ; STY XX16+1        ; (XX16+1 K2+1) = nosev_y / z
     B938 000A     
25788               
25789 B93A 020E  20        li   rx,>0f*256                 ; LDX #15           ; Set X to 15 so the call to PLS5 divides roofv_x
     B93C 0F00     
25790               
25791 B93E 0200  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     B940 C1F0     
25792 B942 06A0  32        bl   @jsr                       ;
     B944 FE28     
25793                                                                          ;
25794                                                                          ; (XX16+2 K2+2) = roofv_x / z
25795                                                                          ;
25796                                                                          ; (XX16+3 K2+3) = roofv_y / z
25797               
25798 B946 0200  20        li   rtmp,PLS2                  ; JSR PLS2          ; Call PLS2 to draw the first meridian
     B948 BA86     
25799 B94A 06A0  32        bl   @jsr                       ;
     B94C FE28     
25800               
25801 B94E D360  30        movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
     B950 0061     
25802                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 B952 0200  20        li   rtmp,(>80*256)
     B954 8000     
0002 B956 2B40  18        xor  rtmp,ra
                   < elite.a99
25803 B958 D80D  30        movb ra,@P                      ; STA P
     B95A 001B     
25804               
25805 B95C D360  30        movb @INWK+26,ra                ; LDA INWK+26       ; Set A = sidev_z_hi, so the second meridian will be at
     B95E 006D     
25806                                                                          ; 90 degrees to the first
25807               
25808 B960 0200  20        li   rtmp,PLS4                  ; JSR PLS4          ; Call PLS4 to calculate the following:
     B962 C1CC     
25809 B964 06A0  32        bl   @jsr                       ;
     B966 FE28     
25810                                                                          ;
25811                                                                          ; CNT2 = arctan(P / A) / 4
25812                                                                          ; = arctan(-nosev_z_hi / sidev_z_hi) / 4
25813                                                                          ;
25814                                                                          ; and do the following if nosev_z_hi >= 0:
25815                                                                          ;
25816                                                                          ; CNT2 = CNT2 + PI
25817               
25818 B968 020E  20        li   rx,>15*256                 ; LDX #21           ; Set X to 21 so the call to PLS5 divides sidev_x
     B96A 1500     
25819               
25820 B96C 0200  20        li   rtmp,PLS5                  ; JSR PLS5          ; Call PLS5 to calculate the following:
     B96E C1F0     
25821 B970 06A0  32        bl   @jsr                       ;
     B972 FE28     
25822                                                                          ;
25823                                                                          ; (XX16+2 K2+2) = sidev_x / z
25824                                                                          ;
25825                                                                          ; (XX16+3 K2+3) = sidev_y / z
25826               
25827 B974 0460  28        b    @PLS2                      ; JMP PLS2          ; Jump to PLS2 to draw the second meridian, returning
     B976 BA86     
25828                                                                          ; from the subroutine using a tail call
25829               
25830               * ******************************************************************************
25831               *
25832               * Name: PL9 (Part 3 of 3)
25833               * Type: Subroutine
25834               * Category: Drawing planets
25835               * Summary: Draw the planet's crater
25836               * Deep dive: Drawing craters
25837               *
25838               * ------------------------------------------------------------------------------
25839               *
25840               * Draw the planet's crater.
25841               *
25842               * ------------------------------------------------------------------------------
25843               *
25844               * Arguments:
25845               *
25846               * K(1 0)              The planet's radius
25847               *
25848               * K3(1 0)             Pixel x-coordinate of the centre of the planet
25849               *
25850               * K4(1 0)             Pixel y-coordinate of the centre of the planet
25851               *
25852               * INWK                The planet's ship data block
25853               *
25854               * ******************************************************************************
25855               
25856               PL26:
25857 B978 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi
     B97A 0067     
25858               
25859 B97C 11B3  14        jlt  PL20                       ; BMI PL20          ; If A is negative, the crater is on the far side of the
25860                                                                          ; planet, so return from the subroutine (as PL2
25861                                                                          ; contains an RTS)
25862               
25863 B97E 020E  20        li   rx,>0f*256                 ; LDX #15           ; Set X = 15, so the following call to PLS3 operates on
     B980 0F00     
25864                                                                          ; roofv
25865               
25866 B982 0200  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     B984 C180     
25867 B986 06A0  32        bl   @jsr                       ;
     B988 FE28     
25868                                                                          ;
25869                                                                          ; (Y A P) = 222 * roofv_x / z
25870                                                                          ;
25871                                                                          ; to give the x-coordinate of the crater offset and
25872                                                                          ; increment X to point to roofv_y for the next call
25873               
25874                      .clc                            ; CLC               ; Calculate:
     **** ****     > CLC
0001 B98A 0A16  18        sla  rzero,1
                   < elite.a99
25875                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 B98C 1701  14        jnc  !
0002 B98E B347  18        ab   rone,ra
0003               !:
0004 B990 B360  30        ab   @K3,ra
     B992 00D2     
                   < elite.a99
25876 B994 D80D  30        movb ra,@K3                     ; STA K3            ; K3(1 0) = (Y A) + K3(1 0)
     B996 00D2     
25877                                                                          ; = 222 * roofv_x / z + x-coordinate of planet
25878                                                                          ; centre
25879                                                                          ;
25880                                                                          ; starting with the high bytes
25881               
25882 B998 D34F  18        movb ry,ra                      ; TYA               ; And then doing the low bytes, so now K3(1 0) contains
25883                      .adc @K3+1,ra                   ; ADC K3+1          ; the x-coordinate of the crater offset plus the planet
     **** ****     > ADC
0001 B99A 1701  14        jnc  !
0002 B99C B347  18        ab   rone,ra
0003               !:
0004 B99E B360  30        ab   @K3+1,ra
     B9A0 00D3     
                   < elite.a99
25884 B9A2 D80D  30        movb ra,@K3+1                   ; STA K3+1          ; centre to give the x-coordinate of the crater's centre
     B9A4 00D3     
25885               
25886 B9A6 0200  20        li   rtmp,PLS3                  ; JSR PLS3          ; Call PLS3 to calculate:
     B9A8 C180     
25887 B9AA 06A0  32        bl   @jsr                       ;
     B9AC FE28     
25888                                                                          ;
25889                                                                          ; (Y A P) = 222 * roofv_y / z
25890                                                                          ;
25891                                                                          ; to give the y-coordinate of the crater offset
25892               
25893 B9AE D80D  30        movb ra,@P                      ; STA P             ; Calculate:
     B9B0 001B     
25894 B9B2 D360  30        movb @K4,ra                     ; LDA K4            ;
     B9B4 00E0     
25895                      .sec                            ; SEC               ; K4(1 0) = K4(1 0) - (Y A)
     **** ****     > SEC
0001 B9B6 0A18  18        sla  rmone,1
                   < elite.a99
25896                      .sbc @P,ra                      ; SBC P             ; = 222 * roofv_y / z - y-coordinate of planet
     **** ****     > SBC
0001 B9B8 1801  14        joc  !
0002 B9BA 7347  18        sb   rone,ra
0003               !:
0004 B9BC 7360  30        sb   @P,ra
     B9BE 001B     
                   < elite.a99
25897 B9C0 D80D  30        movb ra,@K4                     ; STA K4            ; centre
     B9C2 00E0     
25898                                                                          ;
25899                                                                          ; starting with the low bytes
25900               
25901 B9C4 D80F  30        movb ry,@P                      ; STY P             ; And then doing the low bytes, so now K4(1 0) contains
     B9C6 001B     
25902 B9C8 D360  30        movb @K4+1,ra                   ; LDA K4+1          ; the y-coordinate of the crater offset plus the planet
     B9CA 00E1     
25903                      .sbc @P,ra                      ; SBC P             ; centre to give the y-coordinate of the crater's centre
     **** ****     > SBC
0001 B9CC 1801  14        joc  !
0002 B9CE 7347  18        sb   rone,ra
0003               !:
0004 B9D0 7360  30        sb   @P,ra
     B9D2 001B     
                   < elite.a99
25904 B9D4 D80D  30        movb ra,@K4+1                   ; STA K4+1
     B9D6 00E1     
25905               
25906 B9D8 020E  20        li   rx,>09*256                 ; LDX #9            ; Set X = 9, so the following call to PLS1 operates on
     B9DA 0900     
25907                                                                          ; nosev
25908               
25909 B9DC 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B9DE BA3C     
25910 B9E0 06A0  32        bl   @jsr                       ;
     B9E2 FE28     
25911                                                                          ;
25912                                                                          ; (Y A) = nosev_x / z
25913                                                                          ;
25914                                                                          ; and increment X to point to nosev_y for the next call
25915               
25916 B9E4 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16 K2) = (Y A) / 2
25917 B9E6 D80D  30        movb ra,@K2                     ; STA K2
     B9E8 00AC     
25918 B9EA D80F  30        movb ry,@XX16                   ; STY XX16
     B9EC 0009     
25919               
25920 B9EE 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     B9F0 BA3C     
25921 B9F2 06A0  32        bl   @jsr                       ;
     B9F4 FE28     
25922                                                                          ;
25923                                                                          ; (Y A) = nosev_y / z
25924                                                                          ;
25925                                                                          ; and increment X to point to nosev_z for the next call
25926               
25927 B9F6 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16+1 K2+1) = (Y A) / 2
25928 B9F8 D80D  30        movb ra,@K2+1                   ; STA K2+1
     B9FA 00AD     
25929 B9FC D80F  30        movb ry,@XX16+1                 ; STY XX16+1
     B9FE 000A     
25930               
25931 BA00 020E  20        li   rx,>15*256                 ; LDX #21           ; Set X = 21, so the following call to PLS1 operates on
     BA02 1500     
25932                                                                          ; sidev
25933               
25934 BA04 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BA06 BA3C     
25935 BA08 06A0  32        bl   @jsr                       ;
     BA0A FE28     
25936                                                                          ;
25937                                                                          ; (Y A) = sidev_x / z
25938                                                                          ;
25939                                                                          ; and increment X to point to sidev_y for the next call
25940               
25941 BA0C 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16+2 K2+2) = (Y A) / 2
25942 BA0E D80D  30        movb ra,@K2+2                   ; STA K2+2
     BA10 00AE     
25943 BA12 D80F  30        movb ry,@XX16+2                 ; STY XX16+2
     BA14 000B     
25944               
25945 BA16 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     BA18 BA3C     
25946 BA1A 06A0  32        bl   @jsr                       ;
     BA1C FE28     
25947                                                                          ;
25948                                                                          ; (Y A) = sidev_y / z
25949                                                                          ;
25950                                                                          ; and increment X to point to sidev_z for the next call
25951               
25952 BA1E 091D  18        srl  ra,1                       ; LSR A             ; Set (XX16+3 K2+3) = (Y A) / 2
25953 BA20 D80D  30        movb ra,@K2+3                   ; STA K2+3
     BA22 00AF     
25954 BA24 D80F  30        movb ry,@XX16+3                 ; STY XX16+3
     BA26 000C     
25955               
25956 BA28 020D  20        li   ra,>40*256                 ; LDA #64           ; Set TGT = 64, so we draw a full ellipse in the call to
     BA2A 4000     
25957 BA2C D80D  30        movb ra,@TGT                    ; STA TGT           ; PLS22 below
     BA2E 00A0     
25958               
25959 BA30 020D  20        li   ra,>00*256                 ; LDA #0            ; Set CNT2 = 0 as we are drawing a full ellipse, so we
     BA32 0000     
25960 BA34 D80D  30        movb ra,@CNT2                   ; STA CNT2          ; don't need to apply an offset
     BA36 00A5     
25961               
25962 BA38 0460  28        b    @PLS22                     ; JMP PLS22         ; Jump to PLS22 to draw the crater, returning from the
     BA3A BA8E     
25963                                                                          ; subroutine using a tail call
25964               
25965               * ******************************************************************************
25966               *
25967               * Name: PLS1
25968               * Type: Subroutine
25969               * Category: Drawing planets
25970               * Summary: Calculate (Y A) = nosev_x / z
25971               *
25972               * ------------------------------------------------------------------------------
25973               *
25974               * Calculate the following division of a specified value from one of the
25975               * orientation vectors (in this example, nosev_x):
25976               *
25977               * (Y A) = nosev_x / z
25978               *
25979               * where z is the z-coordinate of the planet from INWK. The result is an 8-bit
25980               * magnitude in A, with maximum value 254, and just a sign bit (bit 7) in Y.
25981               *
25982               * ------------------------------------------------------------------------------
25983               *
25984               * Arguments:
25985               *
25986               * X                   Determines which of the INWK orientation vectors to
25987               * divide:
25988               *
25989               * * X = 9, 11, 13: divides nosev_x, nosev_y, nosev_z
25990               *
25991               * * X = 15, 17, 19: divides roofv_x, roofv_y, roofv_z
25992               *
25993               * * X = 21, 23, 25: divides sidev_x, sidev_y, sidev_z
25994               *
25995               * INWK                The planet's ship data block
25996               *
25997               * ------------------------------------------------------------------------------
25998               *
25999               * Returns:
26000               *
26001               * A                   The result as an 8-bit magnitude with maximum value 254
26002               *
26003               * Y                   The sign of the result in bit 7
26004               *
26005               * K+3                 Also the sign of the result in bit 7
26006               *
26007               * X                   X gets incremented by 2 so it points to the next
26008               * coordinate in this orientation vector (so consecutive
26009               * calls to the routine will start with x, then move onto y
26010               * and then z)
26011               *
26012               * ******************************************************************************
26013               
26014               PLS1:
26015 BA3C 06CE  14        swpb rx                         ;
26016 BA3E D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = nosev_x_lo
     BA40 0053     
26017 BA42 06CE  14        swpb rx                         ;
26018 BA44 D80D  30        movb ra,@P                      ; STA P
     BA46 001B     
26019               
26020 BA48 06CE  14        swpb rx                         ;
26021 BA4A D36E  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set P+1 = |nosev_x_hi|
     BA4C 0054     
26022 BA4E 06CE  14        swpb rx                         ;
26023 BA50 024D  22        andi ra,>7f*256                 ; AND #%01111111
     BA52 7F00     
26024 BA54 D80D  30        movb ra,@P+1                    ; STA P+1
     BA56 001C     
26025               
26026 BA58 06CE  14        swpb rx                         ;
26027 BA5A D36E  34        movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set A = sign bit of nosev_x_lo
     BA5C 0054     
26028 BA5E 06CE  14        swpb rx                         ;
26029 BA60 024D  22        andi ra,>80*256                 ; AND #%10000000
     BA62 8000     
26030               
26031 BA64 0200  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     BA66 4994     
26032 BA68 06A0  32        bl   @jsr                       ;
     BA6A FE28     
26033                                                                          ;
26034                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
26035               
26036 BA6C D360  30        movb @K,ra                      ; LDA K             ; Fetch the lowest byte of the result into A
     BA6E 003D     
26037               
26038 BA70 D3E0  30        movb @K+1,ry                    ; LDY K+1           ; Fetch the second byte of the result into Y
     BA72 003E     
26039               
26040 BA74 1302  14        jeq  B76                        ; BEQ B76           ; If the second byte is 0, skip the next instruction
26041               
26042 BA76 020D  20        li   ra,>fe*256                 ; LDA #254          ; The second byte is non-zero, so the result won't fit
     BA78 FE00     
26043                                                                          ; into one byte, so set A = 254 as our maximum one-byte
26044                                                                          ; value to return
26045               
26046               B76:
26047 BA7A D3E0  30        movb @K+3,ry                    ; LDY K+3           ; Fetch the sign of the result from K+3 into Y
     BA7C 0040     
26048               
26049 BA7E B387  18        ab   rone,rx                    ; INX               ; Add 2 to X so the index points to the next coordinate
26050 BA80 B387  18        ab   rone,rx                    ; INX               ; in this orientation vector (so consecutive calls to
26051                                                                          ; the routine will start with x, then move onto y and z)
26052               
26053 BA82 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BA84 FE34     
26054               
26055               * ******************************************************************************
26056               *
26057               * Name: PLS2
26058               * Type: Subroutine
26059               * Category: Drawing planets
26060               * Summary: Draw a half-ellipse
26061               * Deep dive: Drawing ellipses
26062               * Drawing meridians and equators
26063               *
26064               * ------------------------------------------------------------------------------
26065               *
26066               * Draw a half-ellipse, used for the planet's equator and meridian.
26067               *
26068               * ******************************************************************************
26069               
26070               PLS2:
26071 BA86 020D  20        li   ra,>1f*256                 ; LDA #31           ; Set TGT = 31, so we only draw half an ellipse
     BA88 1F00     
26072 BA8A D80D  30        movb ra,@TGT                    ; STA TGT
     BA8C 00A0     
26073               
26074                                                                          ; Fall through into PLS22 to draw the half-ellipse
26075               
26076               * ******************************************************************************
26077               *
26078               * Name: PLS22
26079               * Type: Subroutine
26080               * Category: Drawing planets
26081               * Summary: Draw an ellipse or half-ellipse
26082               * Deep dive: Drawing ellipses
26083               * Drawing meridians and equators
26084               * Drawing craters
26085               *
26086               * ------------------------------------------------------------------------------
26087               *
26088               * Draw an ellipse or half-ellipse, to be used for the planet's equator and
26089               * meridian (in which case we draw half an ellipse), or crater (in which case we
26090               * draw a full ellipse).
26091               *
26092               * The ellipse is defined by a centre point, plus two conjugate radius vectors,
26093               * u and v, where:
26094               *
26095               * u = [ u_x ]       v = [ v_x ]
26096               * [ u_y ]           [ v_y ]
26097               *
26098               * The individual components of these 2D vectors (i.e. u_x, u_y etc.) are 16-bit
26099               * sign-magnitude numbers, where the high bytes contain only the sign bit (in
26100               * bit 7), with bits 0 to 6 being clear. This means that as we store u_x as
26101               * (XX16 K2), for example, we know that |u_x| = K2.
26102               *
26103               * This routine calls BLINE to draw each line segment in the ellipse, passing the
26104               * coordinates as follows:
26105               *
26106               * K6(1 0) = K3(1 0) + u_x * cos(CNT2) + v_x * sin(CNT2)
26107               *
26108               * K6(3 2) = K4(1 0) - u_y * cos(CNT2) - v_y * sin(CNT2)
26109               *
26110               * The y-coordinates are negated because BLINE expects pixel coordinates but the
26111               * u and v vectors are extracted from the orientation vector. The y-axis runs
26112               * in the opposite direction in 3D space to that on the screen, so we need to
26113               * negate the 3D space coordinates before we can combine them with the ellipse's
26114               * centre coordinates.
26115               *
26116               * ------------------------------------------------------------------------------
26117               *
26118               * Arguments:
26119               *
26120               * K(1 0)              The planet's radius
26121               *
26122               * K3(1 0)             The pixel x-coordinate of the centre of the ellipse
26123               *
26124               * K4(1 0)             The pixel y-coordinate of the centre of the ellipse
26125               *
26126               * (XX16 K2)           The x-component of u (i.e. u_x), where XX16 contains
26127               * just the sign of the sign-magnitude number
26128               *
26129               * (XX16+1 K2+1)       The y-component of u (i.e. u_y), where XX16+1 contains
26130               * just the sign of the sign-magnitude number
26131               *
26132               * (XX16+2 K2+2)       The x-component of v (i.e. v_x), where XX16+2 contains
26133               * just the sign of the sign-magnitude number
26134               *
26135               * (XX16+3 K2+3)       The y-component of v (i.e. v_y), where XX16+3 contains
26136               * just the sign of the sign-magnitude number
26137               *
26138               * TGT                 The number of segments to draw:
26139               *
26140               * * 32 for a half ellipse (a meridian)
26141               *
26142               * * 64 for a full ellipse (a crater)
26143               *
26144               * CNT2                The starting segment for drawing the half-ellipse
26145               *
26146               * ******************************************************************************
26147               
26148               PLS22:
26149 BA8E 020E  20        li   rx,>00*256                 ; LDX #0            ; Set CNT = 0
     BA90 0000     
26150 BA92 D80E  30        movb rx,@CNT                    ; STX CNT
     BA94 00A4     
26151               
26152 BA96 7387  18        sb   rone,rx                    ; DEX               ; Set FLAG = &FF to start a new line in the ball line
26153 BA98 D80E  30        movb rx,@FLAG                   ; STX FLAG          ; heap when calling BLIN below, so the crater or
     BA9A 00A3     
26154                                                                          ; meridian is separate from any previous ellipses
26155               
26156               PLL4:
26157 BA9C D360  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = CNT2 mod 32
     BA9E 00A5     
26158 BAA0 024D  22        andi ra,>1f*256                 ; AND #31           ;
     BAA2 1F00     
26159 BAA4 D38D  18        movb ra,rx                      ; TAX               ; So X is the starting segment, reduced to the range 0
26160                                                                          ; to 32, so as there are 64 segments in the circle, this
26161                                                                          ; reduces the starting angle to 0 to 180 degrees, so we
26162                                                                          ; can use X as an index into the sine table (which only
26163                                                                          ; contains values for segments 0 to 31)
26164                                                                          ;
26165                                                                          ; Also, because CNT2 mod 32 is in the range 0 to 180
26166                                                                          ; degrees, we know that sin(CNT2 mod 32) is always
26167                                                                          ; positive, or to put it another way:
26168                                                                          ;
26169                                                                          ; sin(CNT2 mod 32) = |sin(CNT2)|
26170               
26171 BAA6 06CE  14        swpb rx                         ;
26172 BAA8 D36E  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     BAAA 44A6     
26173 BAAC 06CE  14        swpb rx                         ;
26174 BAAE D80D  30        movb ra,@Q                      ; STA Q             ; = sin(CNT2 mod 32)
     BAB0 0090     
26175                                                                          ; = |sin(CNT2)|
26176               
26177 BAB2 D360  30        movb @K2+2,ra                   ; LDA K2+2          ; Set A = K2+2
     BAB4 00AE     
26178                                                                          ; = |v_x|
26179               
26180 BAB6 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set R = A * Q / 256
     BAB8 46D4     
26181 BABA 06A0  32        bl   @jsr                       ;
     BABC FE28     
26182 BABE D80D  30        movb ra,@R                      ; STA R             ; = |v_x| * |sin(CNT2)|
     BAC0 0091     
26183               
26184 BAC2 D360  30        movb @K2+3,ra                   ; LDA K2+3          ; Set A = K2+3
     BAC4 00AF     
26185                                                                          ; = |v_y|
26186               
26187 BAC6 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K = A * Q / 256
     BAC8 46D4     
26188 BACA 06A0  32        bl   @jsr                       ;
     BACC FE28     
26189 BACE D80D  30        movb ra,@K                      ; STA K             ; = |v_y| * |sin(CNT2)|
     BAD0 003D     
26190               
26191 BAD2 D3A0  30        movb @CNT2,rx                   ; LDX CNT2          ; If CNT2 >= 33 then this sets the C flag, otherwise
     BAD4 00A5     
26192 BAD6 028E  22        ci   rx,>21*256                 ; CPX #33           ; it's clear, so this means that:
     BAD8 2100     
26193                                                                          ;
26194                                                                          ; * C is clear if the segment starts in the first half
26195                                                                          ; of the circle, 0 to 180 degrees
26196                                                                          ;
26197                                                                          ; * C is set if the segment starts in the second half
26198                                                                          ; of the circle, 180 to 360 degrees
26199                                                                          ;
26200                                                                          ; In other words, the C flag contains the sign bit for
26201                                                                          ; sin(CNT2), which is positive for 0 to 180 degrees
26202                                                                          ; and negative for 180 to 360 degrees
26203               
26204 BADA 020D  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+5, so
     BADC 0000     
26205 BADE 06A0  32        bl   @rora                      ; ROR A             ; XX16+5 has the correct sign for sin(CNT2)
     BAE0 FE62     
26206 BAE2 D80D  30        movb ra,@XX16+5                 ; STA XX16+5        ;
     BAE4 000E     
26207                                                                          ; Because we set the following above:
26208                                                                          ;
26209                                                                          ; K = |v_y| * |sin(CNT2)|
26210                                                                          ; R = |v_x| * |sin(CNT2)|
26211                                                                          ;
26212                                                                          ; we can add XX16+5 as the high byte to give us the
26213                                                                          ; following:
26214                                                                          ;
26215                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
26216                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
26217               
26218 BAE6 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; Set X = (CNT2 + 16) mod 32
     BAE8 00A5     
26219                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 BAEA 0A16  18        sla  rzero,1
                   < elite.a99
26220                      .adi (>10*256)                  ; ADC #16           ; So we can use X as a lookup index into the SNE table
     **** ****     > ADI
0001 BAEC 1701  14        jnc  !
0002 BAEE B347  18        ab   rone,ra
0003               !:
0004 BAF0 022D  22        ai   ra,(>10*256)
     BAF2 1000     
                   < elite.a99
26221 BAF4 024D  22        andi ra,>1f*256                 ; AND #31           ; to get the cosine (as there are 16 segments in a
     BAF6 1F00     
26222 BAF8 D38D  18        movb ra,rx                      ; TAX               ; quarter-circle)
26223                                                                          ;
26224                                                                          ; Also, because the sine table only contains positive
26225                                                                          ; values, we know that sin((CNT2 + 16) mod 32) will
26226                                                                          ; always be positive, or to put it another way:
26227                                                                          ;
26228                                                                          ; sin((CNT2 + 16) mod 32) = |cos(CNT2)|
26229               
26230 BAFA 06CE  14        swpb rx                         ;
26231 BAFC D36E  34        movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
     BAFE 44A6     
26232 BB00 06CE  14        swpb rx                         ;
26233 BB02 D80D  30        movb ra,@Q                      ; STA Q             ; = sin((CNT2 + 16) mod 32)
     BB04 0090     
26234                                                                          ; = |cos(CNT2)|
26235               
26236 BB06 D360  30        movb @K2+1,ra                   ; LDA K2+1          ; Set A = K2+1
     BB08 00AD     
26237                                                                          ; = |u_y|
26238               
26239 BB0A 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set K+2 = A * Q / 256
     BB0C 46D4     
26240 BB0E 06A0  32        bl   @jsr                       ;
     BB10 FE28     
26241 BB12 D80D  30        movb ra,@K+2                    ; STA K+2           ; = |u_y| * |cos(CNT2)|
     BB14 003F     
26242               
26243 BB16 D360  30        movb @K2,ra                     ; LDA K2            ; Set A = K2
     BB18 00AC     
26244                                                                          ; = |u_x|
26245               
26246 BB1A 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set P = A * Q / 256
     BB1C 46D4     
26247 BB1E 06A0  32        bl   @jsr                       ;
     BB20 FE28     
26248 BB22 D80D  30        movb ra,@P                      ; STA P             ; = |u_x| * |cos(CNT2)|
     BB24 001B     
26249                                                                          ;
26250                                                                          ; The call to FMLTU also sets the C flag, so in the
26251                                                                          ; following, ADC #15 adds 16 rather than 15
26252               
26253 BB26 D360  30        movb @CNT2,ra                   ; LDA CNT2          ; If (CNT2 + 16) mod 64 >= 33 then this sets the C flag,
     BB28 00A5     
26254                      .adi (>0f*256)                  ; ADC #15           ; otherwise it's clear, so this means that:
     **** ****     > ADI
0001 BB2A 1701  14        jnc  !
0002 BB2C B347  18        ab   rone,ra
0003               !:
0004 BB2E 022D  22        ai   ra,(>0F*256)
     BB30 0F00     
                   < elite.a99
26255 BB32 024D  22        andi ra,>3f*256                 ; AND #63           ;
     BB34 3F00     
26256 BB36 028D  22        ci   ra,>21*256                 ; CMP #33           ; * C is clear if the segment starts in the first or
     BB38 2100     
26257                                                                          ; last quarter of the circle, 0 to 90 degrees or 270
26258                                                                          ; to 360 degrees
26259                                                                          ;
26260                                                                          ; * C is set if the segment starts in the second or
26261                                                                          ; third quarter of the circle, 90 to 270 degrees
26262                                                                          ;
26263                                                                          ; In other words, the C flag contains the sign bit for
26264                                                                          ; cos(CNT2), which is positive for 0 to 90 degrees or
26265                                                                          ; 270 to 360 degrees, and negative for 90 to 270 degrees
26266               
26267 BB3A 020D  20        li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+4, so:
     BB3C 0000     
26268 BB3E 06A0  32        bl   @rora                      ; ROR A             ; XX16+4 has the correct sign for cos(CNT2)
     BB40 FE62     
26269 BB42 D80D  30        movb ra,@XX16+4                 ; STA XX16+4        ;
     BB44 000D     
26270                                                                          ; Because we set the following above:
26271                                                                          ;
26272                                                                          ; K+2 = |u_y| * |cos(CNT2)|
26273                                                                          ; P   = |u_x| * |cos(CNT2)|
26274                                                                          ;
26275                                                                          ; we can add XX16+4 as the high byte to give us the
26276                                                                          ; following:
26277                                                                          ;
26278                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
26279                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
26280               
26281 BB46 D360  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+2 * XX16+5
     BB48 000E     
26282                      .eor @XX16+2                    ; EOR XX16+2        ; = the sign of v_x * XX16+5
     **** ****     > EOR
0001 BB4A D020  30        movb @XX16+2,rtmp
     BB4C 000B     
0002 BB4E 2B40  18        xor  rtmp,ra
                   < elite.a99
26283 BB50 D80D  30        movb ra,@S                      ; STA S             ;
     BB52 0092     
26284                                                                          ; So because we set this above:
26285                                                                          ;
26286                                                                          ; (XX16+5 R) = |v_x| * sin(CNT2)
26287                                                                          ;
26288                                                                          ; we now have this:
26289                                                                          ;
26290                                                                          ; (S R) = v_x * sin(CNT2)
26291               
26292 BB54 D360  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16 * XX16+4
     BB56 000D     
26293                      .eor @XX16                      ; EOR XX16          ; = the sign of u_x * XX16+4
     **** ****     > EOR
0001 BB58 D020  30        movb @XX16,rtmp
     BB5A 0009     
0002 BB5C 2B40  18        xor  rtmp,ra
                   < elite.a99
26294                                                                          ;
26295                                                                          ; So because we set this above:
26296                                                                          ;
26297                                                                          ; (XX16+4 P)   = |u_x| * cos(CNT2)
26298                                                                          ;
26299                                                                          ; we now have this:
26300                                                                          ;
26301                                                                          ; (A P) = u_x * cos(CNT2)
26302               
26303 BB5E 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     BB60 4862     
26304 BB62 06A0  32        bl   @jsr                       ;
     BB64 FE28     
26305                                                                          ; = u_x * cos(CNT2) + v_x * sin(CNT2)
26306               
26307 BB66 D80D  30        movb ra,@T                      ; STA T             ; Store the high byte in T, so the result is now:
     BB68 00D1     
26308                                                                          ;
26309                                                                          ; (T X) = u_x * cos(CNT2) + v_x * sin(CNT2)
26310               
26311 BB6A 1515  14        jgt  PL42                       ; BPL PL42          ; If the result is positive, jump down to PL42
26312               
26313 BB6C D34E  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
26314                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 BB6E 0200  20        li   rtmp,(>FF*256)
     BB70 FF00     
0002 BB72 2B40  18        xor  rtmp,ra
                   < elite.a99
26315                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 BB74 0A16  18        sla  rzero,1
                   < elite.a99
26316                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 BB76 1701  14        jnc  !
0002 BB78 B347  18        ab   rone,ra
0003               !:
0004 BB7A 022D  22        ai   ra,(>01*256)
     BB7C 0100     
                   < elite.a99
26317 BB7E D38D  18        movb ra,rx                      ; TAX
26318               
26319 BB80 D360  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     BB82 00D1     
26320                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 BB84 0200  20        li   rtmp,(>7F*256)
     BB86 7F00     
0002 BB88 2B40  18        xor  rtmp,ra
                   < elite.a99
26321                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BB8A 1701  14        jnc  !
0002 BB8C B347  18        ab   rone,ra
0003               !:
0004 BB8E 022D  22        ai   ra,(>00*256)
     BB90 0000     
                   < elite.a99
26322 BB92 D80D  30        movb ra,@T                      ; STA T
     BB94 00D1     
26323               
26324               PL42:
26325 BB96 D34E  18        movb rx,ra                      ; TXA               ; Set K6(1 0) = K3(1 0) + (T X)
26326                      .adc @K3,ra                     ; ADC K3            ;
     **** ****     > ADC
0001 BB98 1701  14        jnc  !
0002 BB9A B347  18        ab   rone,ra
0003               !:
0004 BB9C B360  30        ab   @K3,ra
     BB9E 00D2     
                   < elite.a99
26327 BBA0 D80D  30        movb ra,@K6                     ; STA K6            ; starting with the low bytes
     BBA2 0082     
26328               
26329 BBA4 D360  30        movb @T,ra                      ; LDA T             ; And then doing the high bytes, so we now get:
     BBA6 00D1     
26330                      .adc @K3+1,ra                   ; ADC K3+1          ;
     **** ****     > ADC
0001 BBA8 1701  14        jnc  !
0002 BBAA B347  18        ab   rone,ra
0003               !:
0004 BBAC B360  30        ab   @K3+1,ra
     BBAE 00D3     
                   < elite.a99
26331 BBB0 D80D  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K3(1 0) + (T X)
     BBB2 0083     
26332                                                                          ; = K3(1 0) + u_x * cos(CNT2)
26333                                                                          ; + v_x * sin(CNT2)
26334                                                                          ;
26335                                                                          ; K3(1 0) is the x-coordinate of the centre of the
26336                                                                          ; ellipse, so we now have the correct x-coordinate for
26337                                                                          ; our ellipse segment that we can pass to BLINE below
26338               
26339 BBB4 D360  30        movb @K,ra                      ; LDA K             ; Set R = K = |v_y| * sin(CNT2)
     BBB6 003D     
26340 BBB8 D80D  30        movb ra,@R                      ; STA R
     BBBA 0091     
26341               
26342 BBBC D360  30        movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+3 * XX16+5
     BBBE 000E     
26343                      .eor @XX16+3                    ; EOR XX16+3        ; = the sign of v_y * XX16+5
     **** ****     > EOR
0001 BBC0 D020  30        movb @XX16+3,rtmp
     BBC2 000C     
0002 BBC4 2B40  18        xor  rtmp,ra
                   < elite.a99
26344 BBC6 D80D  30        movb ra,@S                      ; STA S             ;
     BBC8 0092     
26345                                                                          ; So because we set this above:
26346                                                                          ;
26347                                                                          ; (XX16+5 K) = |v_y| * sin(CNT2)
26348                                                                          ;
26349                                                                          ; and we just set R = K, we now have this:
26350                                                                          ;
26351                                                                          ; (S R) = v_y * sin(CNT2)
26352               
26353 BBCA D360  30        movb @K+2,ra                    ; LDA K+2           ; Set P = K+2 = |u_y| * cos(CNT2)
     BBCC 003F     
26354 BBCE D80D  30        movb ra,@P                      ; STA P
     BBD0 001B     
26355               
26356 BBD2 D360  30        movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16+1 * XX16+4
     BBD4 000D     
26357                      .eor @XX16+1                    ; EOR XX16+1        ; = the sign of u_y * XX16+4
     **** ****     > EOR
0001 BBD6 D020  30        movb @XX16+1,rtmp
     BBD8 000A     
0002 BBDA 2B40  18        xor  rtmp,ra
                   < elite.a99
26358                                                                          ;
26359                                                                          ; So because we set this above:
26360                                                                          ;
26361                                                                          ; (XX16+4 K+2) = |u_y| * cos(CNT2)
26362                                                                          ;
26363                                                                          ; and we just set P = K+2, we now have this:
26364                                                                          ;
26365                                                                          ; (A P) = u_y * cos(CNT2)
26366               
26367 BBDC 0200  20        li   rtmp,ADD                   ; JSR ADD           ; Set (A X) = (A P) + (S R)
     BBDE 4862     
26368 BBE0 06A0  32        bl   @jsr                       ;
     BBE2 FE28     
26369                                                                          ; =  u_y * cos(CNT2) + v_y * sin(CNT2)
26370               
26371                      .eoi (>80*256)                  ; EOR #%10000000    ; Store the negated high byte in T, so the result is
     **** ****     > EOI
0001 BBE4 0200  20        li   rtmp,(>80*256)
     BBE6 8000     
0002 BBE8 2B40  18        xor  rtmp,ra
                   < elite.a99
26372 BBEA D80D  30        movb ra,@T                      ; STA T             ; now:
     BBEC 00D1     
26373                                                                          ;
26374                                                                          ; (T X) = - u_y * cos(CNT2) - v_y * sin(CNT2)
26375                                                                          ;
26376                                                                          ; This negation is necessary because BLINE expects us
26377                                                                          ; to pass pixel coordinates, where y-coordinates get
26378                                                                          ; larger as we go down the screen; u_y and v_y, on the
26379                                                                          ; other hand, are extracted from the orientation
26380                                                                          ; vectors, where y-coordinates get larger as we go up
26381                                                                          ; in space, so to rectify this we need to negate the
26382                                                                          ; result in (T X) before we can add it to the
26383                                                                          ; y-coordinate of the ellipse's centre in BLINE
26384               
26385 BBEE 1515  14        jgt  PL43                       ; BPL PL43          ; If the result is positive, jump down to PL43
26386               
26387 BBF0 D34E  18        movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
26388                      .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
     **** ****     > EOI
0001 BBF2 0200  20        li   rtmp,(>FF*256)
     BBF4 FF00     
0002 BBF6 2B40  18        xor  rtmp,ra
                   < elite.a99
26389                      .clc                            ; CLC               ; byte in X
     **** ****     > CLC
0001 BBF8 0A16  18        sla  rzero,1
                   < elite.a99
26390                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 BBFA 1701  14        jnc  !
0002 BBFC B347  18        ab   rone,ra
0003               !:
0004 BBFE 022D  22        ai   ra,(>01*256)
     BC00 0100     
                   < elite.a99
26391 BC02 D38D  18        movb ra,rx                      ; TAX
26392               
26393 BC04 D360  30        movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
     BC06 00D1     
26394                      .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
     **** ****     > EOI
0001 BC08 0200  20        li   rtmp,(>7F*256)
     BC0A 7F00     
0002 BC0C 2B40  18        xor  rtmp,ra
                   < elite.a99
26395                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BC0E 1701  14        jnc  !
0002 BC10 B347  18        ab   rone,ra
0003               !:
0004 BC12 022D  22        ai   ra,(>00*256)
     BC14 0000     
                   < elite.a99
26396 BC16 D80D  30        movb ra,@T                      ; STA T
     BC18 00D1     
26397               
26398               PL43:
26399                                                                          ; We now call BLINE to draw the ellipse line segment
26400                                                                          ;
26401                                                                          ; The first few instructions of BLINE do the following:
26402                                                                          ;
26403                                                                          ; K6(3 2) = K4(1 0) + (T X)
26404                                                                          ;
26405                                                                          ; which gives:
26406                                                                          ;
26407                                                                          ; K6(3 2) = K4(1 0) - u_y * cos(CNT2)
26408                                                                          ; - v_y * sin(CNT2)
26409                                                                          ;
26410                                                                          ; K4(1 0) is the pixel y-coordinate of the centre of the
26411                                                                          ; ellipse, so this gives us the correct y-coordinate for
26412                                                                          ; our ellipse segment (we already calculated the
26413                                                                          ; x-coordinate in K3(1 0) above)
26414 BC1A 0200  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also returns
     BC1C 2A06     
26415 BC1E 06A0  32        bl   @jsr                       ;
     BC20 FE28     
26416                                                                          ; the updated value of CNT in A
26417               
26418 BC22 9360  30        cb   @TGT,ra                    ; CMP TGT           ; If CNT > TGT then jump to PL40 to stop drawing the
     BC24 00A0     
26419 BC26 1301  14        jeq  B77                        ; BEQ B77           ; ellipse (which is how we draw half-ellipses)
26420 BC28 180D  14        joc  PL40                       ; BCS PL40
26421               
26422               B77:
26423 BC2A D360  30        movb @CNT2,ra                   ; LDA CNT2          ; Set CNT2 = (CNT2 + STP) mod 64
     BC2C 00A5     
26424                      .clc                            ; CLC
     **** ****     > CLC
0001 BC2E 0A16  18        sla  rzero,1
                   < elite.a99
26425                      .adc @STP,ra                    ; ADC STP
     **** ****     > ADC
0001 BC30 1701  14        jnc  !
0002 BC32 B347  18        ab   rone,ra
0003               !:
0004 BC34 B360  30        ab   @STP,ra
     BC36 00A6     
                   < elite.a99
26426 BC38 024D  22        andi ra,>3f*256                 ; AND #63
     BC3A 3F00     
26427 BC3C D80D  30        movb ra,@CNT2                   ; STA CNT2
     BC3E 00A5     
26428               
26429 BC40 0460  28        b    @PLL4                      ; JMP PLL4          ; Jump back to PLL4 to draw the next segment
     BC42 BA9C     
26430               
26431               PL40:
26432 BC44 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BC46 FE34     
26433               
26434               * ******************************************************************************
26435               *
26436               * Name: SUN (Part 1 of 4)
26437               * Type: Subroutine
26438               * Category: Drawing suns
26439               * Summary: Draw the sun: Set up all the variables needed to draw the sun
26440               * Deep dive: Drawing the sun
26441               *
26442               * ------------------------------------------------------------------------------
26443               *
26444               * Draw a new sun with radius K at pixel coordinate (K3, K4), removing the old
26445               * sun if there is one. This routine is used to draw the sun, as well as the
26446               * star systems on the Short-range Chart.
26447               *
26448               * The first part sets up all the variables needed to draw the new sun.
26449               *
26450               * ------------------------------------------------------------------------------
26451               *
26452               * Arguments:
26453               *
26454               * K                   The new sun's radius
26455               *
26456               * K3(1 0)             Pixel x-coordinate of the centre of the new sun
26457               *
26458               * K4(1 0)             Pixel y-coordinate of the centre of the new sun
26459               *
26460               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the old
26461               * sun (the one currently on-screen)
26462               *
26463               * ******************************************************************************
26464               
26465 BC48 0460  28        b    @WPLS                      ; JMP WPLS          ; Jump to WPLS to remove the old sun from the screen. We
     BC4A C048     
26466                                                                          ; only get here via the BCS just after the SUN entry
26467                                                                          ; point below, when there is no new sun to draw
26468               
26469               PLF3:
26470                                                                          ; This is called from below to negate X and set A to
26471                                                                          ; &FF, for when the new sun's centre is off the bottom
26472                                                                          ; of the screen (so we don't need to draw its bottom
26473                                                                          ; half)
26474                                                                          ;
26475                                                                          ; This happens when the y-coordinate of the centre of
26476                                                                          ; the sun is bigger than the y-coordinate of the bottom
26477                                                                          ; of the space view
26478 BC4C D34E  18        movb rx,ra                      ; TXA               ; Negate X using two's complement, so X = ~X + 1
26479                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 BC4E 0200  20        li   rtmp,(>FF*256)
     BC50 FF00     
0002 BC52 2B40  18        xor  rtmp,ra
                   < elite.a99
26480                      .clc                            ; CLC
     **** ****     > CLC
0001 BC54 0A16  18        sla  rzero,1
                   < elite.a99
26481                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 BC56 1701  14        jnc  !
0002 BC58 B347  18        ab   rone,ra
0003               !:
0004 BC5A 022D  22        ai   ra,(>01*256)
     BC5C 0100     
                   < elite.a99
26482 BC5E D38D  18        movb ra,rx                      ; TAX
26483               
26484               PLF17:
26485                                                                          ; This is called from below to set A to &FF, for when
26486                                                                          ; the new sun's centre is right on the bottom of the
26487                                                                          ; screen (so we don't need to draw its bottom half)
26488 BC60 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A = &FF
     BC62 FF00     
26489               
26490 BC64 0460  28        b    @PLF5                      ; JMP PLF5          ; Jump to PLF5
     BC66 BCF0     
26491               
26492               SUN:
26493 BC68 020D  20        li   ra,>01*256                 ; LDA #1            ; Set LSX = 1 to indicate the sun line heap is about to
     BC6A 0100     
26494 BC6C D80D  30        movb ra,@LSX                    ; STA LSX           ; be filled up
     BC6E 0D66     
26495               
26496 BC70 0200  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether any part of the new sun's
     BC72 C0F4     
26497 BC74 06A0  32        bl   @jsr                       ;
     BC76 FE28     
26498                                                                          ; circle appears on-screen, and if it does, set P(2 1)
26499                                                                          ; to the maximum y-coordinate of the new sun on-screen
26500               
26501 BC78 18E7  14        joc  PLF3-3                     ; BCS PLF3-3        ; If CHKON set the C flag then the new sun's circle does
26502                                                                          ; not appear on-screen, so jump to WPLS (via the JMP at
26503                                                                          ; the top of this routine) to remove the sun from the
26504                                                                          ; screen, returning from the subroutine using a tail
26505                                                                          ; call
26506               
26507 BC7A 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     BC7C 0000     
26508               
26509 BC7E D3A0  30        movb @K,rx                      ; LDX K             ; Set X = K = radius of the new sun
     BC80 003D     
26510               
26511 BC82 028E  22        ci   rx,>60*256                 ; CPX #96           ; If X >= 96, set the C flag and rotate it into bit 0
     BC84 6000     
26512 BC86 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     BC88 FE3E     
26513               
26514 BC8A 028E  22        ci   rx,>28*256                 ; CPX #40           ; If X >= 40, set the C flag and rotate it into bit 0
     BC8C 2800     
26515 BC8E 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     BC90 FE3E     
26516               
26517 BC92 028E  22        ci   rx,>10*256                 ; CPX #16           ; If X >= 16, set the C flag and rotate it into bit 0
     BC94 1000     
26518 BC96 06A0  32        bl   @rola                      ; ROL A             ; of A, otherwise rotate a 0 into bit 0
     BC98 FE3E     
26519               
26520                                                                          ; By now, A contains the following:
26521                                                                          ;
26522                                                                          ; * If radius is 96-255 then A = %111 = 7
26523                                                                          ;
26524                                                                          ; * If radius is 40-95  then A = %11  = 3
26525                                                                          ;
26526                                                                          ; * If radius is 16-39  then A = %1   = 1
26527                                                                          ;
26528                                                                          ; * If radius is 0-15   then A = %0   = 0
26529                                                                          ;
26530                                                                          ; The value of A determines the size of the new sun's
26531                                                                          ; ragged fringes - the bigger the sun, the bigger the
26532                                                                          ; fringes
26533               
26534               PLF18:
26535 BC9A D80D  30        movb ra,@CNT                    ; STA CNT           ; Store the fringe size in CNT
     BC9C 00A4     
26536               
26537                                                                          ; We now calculate the highest pixel y-coordinate of the
26538                                                                          ; new sun, given that P(2 1) contains the 16-bit maximum
26539                                                                          ; y-coordinate of the new sun on-screen
26540               
26541 BC9E 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     BCA0 BF00     
26542                                                                          ; view, so this sets Y to the y-coordinate of the bottom
26543                                                                          ; of the space view
26544               
26545 BCA2 D3A0  30        movb @P+2,rx                    ; LDX P+2           ; If P+2 is non-zero, the maximum y-coordinate is off
     BCA4 001D     
26546 BCA6 1608  14        jne  PLF2                       ; BNE PLF2          ; the bottom of the screen, so skip to PLF2 with A set
26547                                                                          ; to the y-coordinate of the bottom of the space view
26548               
26549 BCA8 9360  30        cb   @P+1,ra                    ; CMP P+1           ; If A < P+1, the maximum y-coordinate is underneath the
     BCAA 001C     
26550 BCAC 1705  14        jnc  PLF2                       ; BCC PLF2          ; dashboard, so skip to PLF2 with A set to the
26551                                                                          ; y-coordinate of the bottom of the space view
26552               
26553 BCAE D360  30        movb @P+1,ra                    ; LDA P+1           ; Set A = P+1, the low byte of the maximum y-coordinate
     BCB0 001C     
26554                                                                          ; of the sun on-screen
26555               
26556 BCB2 1602  14        jne  PLF2                       ; BNE PLF2          ; If A is non-zero, skip to PLF2 as it contains the
26557                                                                          ; value we are after
26558               
26559 BCB4 020D  20        li   ra,>01*256                 ; LDA #1            ; Otherwise set A = 1, the top line of the screen
     BCB6 0100     
26560               
26561               PLF2:
26562 BCB8 D80D  30        movb ra,@TGT                    ; STA TGT           ; Set TGT to A, the maximum y-coordinate of the sun on
     BCBA 00A0     
26563                                                                          ; screen
26564               
26565                                                                          ; We now calculate the number of lines we need to draw
26566                                                                          ; and the direction in which we need to draw them, both
26567                                                                          ; from the centre of the new sun
26568               
26569 BCBC 020D  20        li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set (A X) = y-coordinate of bottom of screen - K4(1 0)
     BCBE BF00     
26570                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 BCC0 0A18  18        sla  rmone,1
                   < elite.a99
26571                      .sbc @K4,ra                     ; SBC K4            ; Starting with the low bytes
     **** ****     > SBC
0001 BCC2 1801  14        joc  !
0002 BCC4 7347  18        sb   rone,ra
0003               !:
0004 BCC6 7360  30        sb   @K4,ra
     BCC8 00E0     
                   < elite.a99
26572 BCCA D38D  18        movb ra,rx                      ; TAX
26573               
26574 BCCC 020D  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so (A X) now contains
     BCCE 0000     
26575                      .sbc @K4+1,ra                   ; SBC K4+1          ; the number of lines between the centre of the sun and
     **** ****     > SBC
0001 BCD0 1801  14        joc  !
0002 BCD2 7347  18        sb   rone,ra
0003               !:
0004 BCD4 7360  30        sb   @K4+1,ra
     BCD6 00E1     
                   < elite.a99
26576                                                                          ; the bottom of the screen. If it is positive then the
26577                                                                          ; centre of the sun is above the bottom of the screen,
26578                                                                          ; if it is negative then the centre of the sun is below
26579                                                                          ; the bottom of the screen
26580               
26581 BCD8 11B9  14        jlt  PLF3                       ; BMI PLF3          ; If A < 0, then this means the new sun's centre is off
26582                                                                          ; the bottom of the screen, so jump up to PLF3 to negate
26583                                                                          ; the height in X (so it becomes positive), set A to &FF
26584                                                                          ; and jump down to PLF5
26585               
26586 BCDA 1606  14        jne  PLF4                       ; BNE PLF4          ; If A > 0, then the new sun's centre is at least a full
26587                                                                          ; screen above the bottom of the space view, so jump
26588                                                                          ; down to PLF4 to set X = radius and A = 0
26589               
26590 BCDC B387  18        ab   rone,rx                    ; INX               ; Set the flags depending on the value of X
26591 BCDE 7387  18        sb   rone,rx                    ; DEX
26592               
26593 BCE0 13BF  14        jeq  PLF17                      ; BEQ PLF17         ; If X = 0 (we already know A = 0 by this point) then
26594                                                                          ; jump up to PLF17 to set A to &FF before jumping down
26595                                                                          ; to PLF5
26596               
26597 BCE2 93A0  30        cb   @K,rx                      ; CPX K             ; If X < the radius in K, jump down to PLF5, so if
     BCE4 003D     
26598 BCE6 1704  14        jnc  PLF5                       ; BCC PLF5          ; X >= the radius in K, we set X = radius and A = 0
26599               
26600               PLF4:
26601 BCE8 D3A0  30        movb @K,rx                      ; LDX K             ; Set X to the radius
     BCEA 003D     
26602               
26603 BCEC 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     BCEE 0000     
26604               
26605               PLF5:
26606 BCF0 D80E  30        movb rx,@V                      ; STX V             ; Store the height in V
     BCF2 0022     
26607               
26608 BCF4 D80D  30        movb ra,@V+1                    ; STA V+1           ; Store the direction in V+1
     BCF6 0023     
26609               
26610 BCF8 D360  30        movb @K,ra                      ; LDA K             ; Set (A P) = K * K
     BCFA 003D     
26611 BCFC 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2
     BCFE 464E     
26612 BD00 06A0  32        bl   @jsr                       ;
     BD02 FE28     
26613               
26614 BD04 D80D  30        movb ra,@K2+1                   ; STA K2+1          ; Set K2(1 0) = (A P) = K * K
     BD06 00AD     
26615 BD08 D360  30        movb @P,ra                      ; LDA P
     BD0A 001B     
26616 BD0C D80D  30        movb ra,@K2                     ; STA K2
     BD0E 00AC     
26617               
26618                                                                          ; By the time we get here, the variables should be set
26619                                                                          ; up as shown in the header for part 3 below
26620               
26621               * ******************************************************************************
26622               *
26623               * Name: SUN (Part 2 of 4)
26624               * Type: Subroutine
26625               * Category: Drawing suns
26626               * Summary: Draw the sun: Start from the bottom of the screen and erase the
26627               * old sun line by line
26628               * Deep dive: Drawing the sun
26629               *
26630               * ------------------------------------------------------------------------------
26631               *
26632               * This part erases the old sun, starting at the bottom of the screen and working
26633               * upwards until we reach the bottom of the new sun.
26634               *
26635               * ******************************************************************************
26636               
26637 BD10 020F  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; Set Y = y-coordinate of the bottom of the screen,
     BD12 BF00     
26638                                                                          ; which we use as a counter in the following routine to
26639                                                                          ; redraw the old sun
26640               
26641 BD14 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     BD16 0028     
26642 BD18 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     BD1A 0026     
26643 BD1C D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     BD1E 0029     
26644 BD20 D80D  30        movb ra,@YY+1                   ; STA YY+1
     BD22 0027     
26645               
26646               PLFL2:
26647 BD24 93E0  30        cb   @TGT,ry                    ; CPY TGT           ; If Y = TGT, we have reached the line where we will
     BD26 00A0     
26648 BD28 130B  14        jeq  PLFL                       ; BEQ PLFL          ; start drawing the new sun, so there is no need to
26649                                                                          ; keep erasing the old one, so jump down to PLFL
26650               
26651 BD2A 06CF  14        swpb ry                         ;
26652 BD2C D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     BD2E 0D66     
26653 BD30 06CF  14        swpb ry                         ;
26654                                                                          ; gives us the half-width of the old sun's line on this
26655                                                                          ; line of the screen
26656               
26657 BD32 1304  14        jeq  PLF13                      ; BEQ PLF13         ; If A = 0, skip the following call to HLOIN2 as there
26658                                                                          ; is no sun line on this line of the screen
26659               
26660 BD34 0200  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     BD36 2762     
26661 BD38 06A0  32        bl   @jsr                       ;
     BD3A FE28     
26662                                                                          ; with centre point YY(1 0) and half-width A, and remove
26663                                                                          ; the line from the sun line heap once done
26664               
26665               PLF13:
26666 BD3C 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
26667               
26668 BD3E 16F2  14        jne  PLFL2                      ; BNE PLFL2         ; Loop back for the next line in the line heap until
26669                                                                          ; we have either gone through the entire heap, or
26670                                                                          ; reached the bottom row of the new sun
26671               
26672               * ******************************************************************************
26673               *
26674               * Name: SUN (Part 3 of 4)
26675               * Type: Subroutine
26676               * Category: Drawing suns
26677               * Summary: Draw the sun: Continue to move up the screen, drawing the new sun
26678               * line by line
26679               * Deep dive: Drawing the sun
26680               *
26681               * ------------------------------------------------------------------------------
26682               *
26683               * This part draws the new sun. By the time we get to this point, the following
26684               * variables should have been set up by parts 1 and 2:
26685               *
26686               * ------------------------------------------------------------------------------
26687               *
26688               * Arguments:
26689               *
26690               * V                   As we draw lines for the new sun, V contains the
26691               * vertical distance between the line we're drawing and the
26692               * centre of the new sun. As we draw lines and move up the
26693               * screen, we either decrement (bottom half) or increment
26694               * (top half) this value. See the deep dive on "Drawing the
26695               * sun" to see a diagram that shows V in action
26696               *
26697               * V+1                 This determines which half of the new sun we are drawing
26698               * as we work our way up the screen, line by line:
26699               *
26700               * * 0 means we are drawing the bottom half, so the lines
26701               * get wider as we work our way up towards the centre,
26702               * at which point we will move into the top half, and
26703               * V+1 will switch to &FF
26704               *
26705               * * &FF means we are drawing the top half, so the lines
26706               * get smaller as we work our way up, away from the
26707               * centre
26708               *
26709               * TGT                 The maximum y-coordinate of the new sun on-screen (i.e.
26710               * the screen y-coordinate of the bottom row of the new
26711               * sun)
26712               *
26713               * CNT                 The fringe size of the new sun
26714               *
26715               * K2(1 0)             The new sun's radius squared, i.e. K^2
26716               *
26717               * Y                   The y-coordinate of the bottom row of the new sun
26718               *
26719               * ******************************************************************************
26720               
26721               PLFL:
26722 BD40 D360  30        movb @V,ra                      ; LDA V             ; Set (T P) = V * V
     BD42 0022     
26723 BD44 0200  20        li   rtmp,SQUA2                 ; JSR SQUA2         ; = V^2
     BD46 464E     
26724 BD48 06A0  32        bl   @jsr                       ;
     BD4A FE28     
26725 BD4C D80D  30        movb ra,@T                      ; STA T
     BD4E 00D1     
26726               
26727 BD50 D360  30        movb @K2,ra                     ; LDA K2            ; Set (R Q) = K^2 - V^2
     BD52 00AC     
26728                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 BD54 0A18  18        sla  rmone,1
                   < elite.a99
26729                      .sbc @P,ra                      ; SBC P             ; First calculating the low bytes
     **** ****     > SBC
0001 BD56 1801  14        joc  !
0002 BD58 7347  18        sb   rone,ra
0003               !:
0004 BD5A 7360  30        sb   @P,ra
     BD5C 001B     
                   < elite.a99
26730 BD5E D80D  30        movb ra,@Q                      ; STA Q
     BD60 0090     
26731               
26732 BD62 D360  30        movb @K2+1,ra                   ; LDA K2+1          ; And then doing the high bytes
     BD64 00AD     
26733                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 BD66 1801  14        joc  !
0002 BD68 7347  18        sb   rone,ra
0003               !:
0004 BD6A 7360  30        sb   @T,ra
     BD6C 00D1     
                   < elite.a99
26734 BD6E D80D  30        movb ra,@R                      ; STA R
     BD70 0091     
26735               
26736 BD72 D80F  30        movb ry,@Y1                     ; STY Y1            ; Store Y in Y1, so we can restore it after the call to
     BD74 0032     
26737                                                                          ; LL5
26738               
26739 BD76 0200  20        li   rtmp,LL5                   ; JSR LL5           ; Set Q = SQRT(R Q)
     BD78 DA9E     
26740 BD7A 06A0  32        bl   @jsr                       ;
     BD7C FE28     
26741                                                                          ; = SQRT(K^2 - V^2)
26742                                                                          ;
26743                                                                          ; So Q contains the half-width of the new sun's line at
26744                                                                          ; height V from the sun's centre - in other words, it
26745                                                                          ; contains the half-width of the sun's line on the
26746                                                                          ; current pixel row Y
26747               
26748 BD7E D3E0  30        movb @Y1,ry                     ; LDY Y1            ; Restore Y from Y1
     BD80 0032     
26749               
26750 BD82 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     BD84 C7D0     
26751 BD86 06A0  32        bl   @jsr                       ;
     BD88 FE28     
26752               
26753                      .and @CNT                       ; AND CNT           ; Reduce A to a random number in the range 0 to CNT,
     **** ****     > AND
0001 BD8A D020  30        movb @CNT,rtmp
     BD8C 00A4     
0002 BD8E 0540  14        inv  rtmp
0003 BD90 5340  18        szcb rtmp,ra
                   < elite.a99
26754                                                                          ; where CNT is the fringe size of the new sun
26755               
26756                      .clc                            ; CLC               ; Set A = A + Q
     **** ****     > CLC
0001 BD92 0A16  18        sla  rzero,1
                   < elite.a99
26757                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 BD94 1701  14        jnc  !
0002 BD96 B347  18        ab   rone,ra
0003               !:
0004 BD98 B360  30        ab   @Q,ra
     BD9A 0090     
                   < elite.a99
26758                                                                          ; So A now contains the half-width of the sun on row
26759                                                                          ; V, plus a random variation based on the fringe size
26760               
26761 BD9C 1702  14        jnc  PLF44                      ; BCC PLF44         ; If the above addition did not overflow, skip the
26762                                                                          ; following instruction
26763               
26764 BD9E 020D  20        li   ra,>ff*256                 ; LDA #255          ; The above overflowed, so set the value of A to 255
     BDA0 FF00     
26765               
26766                                                                          ; So A contains the half-width of the new sun on pixel
26767                                                                          ; line Y, changed by a random amount within the size of
26768                                                                          ; the sun's fringe
26769               
26770               PLF44:
26771 BDA2 06CF  14        swpb ry                         ;
26772 BDA4 D3AF  34        movb @LSO(ry),rx                ; LDX LSO,Y         ; Set X to the line heap value for the old sun's line
     BDA6 0D66     
26773 BDA8 06CF  14        swpb ry                         ;
26774                                                                          ; at row Y
26775               
26776 BDAA 06CF  14        swpb ry                         ;
26777 BDAC DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; Store the half-width of the new row Y line in the line
     BDAE 0D66     
26778 BDB0 06CF  14        swpb ry                         ;
26779                                                                          ; heap
26780               
26781 BDB2 1348  14        jeq  PLF11                      ; BEQ PLF11         ; If X = 0 then there was no sun line on pixel row Y, so
26782                                                                          ; jump to PLF11
26783               
26784 BDB4 D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     BDB6 0028     
26785 BDB8 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     BDBA 0026     
26786 BDBC D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     BDBE 0029     
26787 BDC0 D80D  30        movb ra,@YY+1                   ; STA YY+1
     BDC2 0027     
26788               
26789 BDC4 D34E  18        movb rx,ra                      ; TXA               ; Transfer the line heap value for the old sun's line
26790                                                                          ; from X into A
26791               
26792 BDC6 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     BDC8 C082     
26793 BDCA 06A0  32        bl   @jsr                       ;
     BDCC FE28     
26794                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26795                                                                          ; the line for the old sun
26796               
26797 BDCE D360  30        movb @X1,ra                     ; LDA X1            ; Store X1 and X2, the ends of the line for the old sun,
     BDD0 0031     
26798 BDD2 D80D  30        movb ra,@XX                     ; STA XX            ; in XX and XX+1
     BDD4 0024     
26799 BDD6 D360  30        movb @X2,ra                     ; LDA X2
     BDD8 0033     
26800 BDDA D80D  30        movb ra,@XX+1                   ; STA XX+1
     BDDC 0025     
26801               
26802 BDDE D360  30        movb @K3,ra                     ; LDA K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     BDE0 00D2     
26803 BDE2 D80D  30        movb ra,@YY                     ; STA YY            ; of the new sun
     BDE4 0026     
26804 BDE6 D360  30        movb @K3+1,ra                   ; LDA K3+1
     BDE8 00D3     
26805 BDEA D80D  30        movb ra,@YY+1                   ; STA YY+1
     BDEC 0027     
26806               
26807 BDEE 06CF  14        swpb ry                         ;
26808 BDF0 D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the half-width of the new row Y line from the
     BDF2 0D66     
26809 BDF4 06CF  14        swpb ry                         ;
26810                                                                          ; line heap (which we stored above)
26811               
26812 BDF6 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     BDF8 C082     
26813 BDFA 06A0  32        bl   @jsr                       ;
     BDFC FE28     
26814                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26815                                                                          ; the line for the new sun
26816               
26817 BDFE 180C  14        joc  PLF23                      ; BCS PLF23         ; If the C flag is set, the new line doesn't fit on the
26818                                                                          ; screen, so jump to PLF23 to just draw the old line
26819                                                                          ; without drawing the new one
26820               
26821                                                                          ; At this point the old line is from XX to XX+1 and the
26822                                                                          ; new line is from X1 to X2, and both fit on-screen. We
26823                                                                          ; now want to remove the old line and draw the new one.
26824                                                                          ; We could do this by simply drawing the old one then
26825                                                                          ; drawing the new one, but instead Elite does this by
26826                                                                          ; drawing first from X1 to XX and then from X2 to XX+1,
26827                                                                          ; which you can see in action by looking at all the
26828                                                                          ; permutations below of the four points on the line and
26829                                                                          ; imagining what happens if you draw from X1 to XX and
26830                                                                          ; X2 to XX+1 using EOR logic. The six possible
26831                                                                          ; permutations are as follows, along with the result of
26832                                                                          ; drawing X1 to XX and then X2 to XX+1:
26833                                                                          ;
26834                                                                          ; X1    X2    XX____XX+1      ->      +__+  +  +
26835                                                                          ;
26836                                                                          ; X1    XX____X2____XX+1      ->      +__+__+  +
26837                                                                          ;
26838                                                                          ; X1    XX____XX+1  X2        ->      +__+__+__+
26839                                                                          ;
26840                                                                          ; XX____X1____XX+1  X2        ->      +  +__+__+
26841                                                                          ;
26842                                                                          ; XX____XX+1  X1    X2        ->      +  +  +__+
26843                                                                          ;
26844                                                                          ; XX____X1____X2____XX+1      ->      +  +__+  +
26845                                                                          ;
26846                                                                          ; They all end up with a line between X1 and X2, which
26847                                                                          ; is what we want. There's probably a mathematical proof
26848                                                                          ; of why this works somewhere, but the above is probably
26849                                                                          ; easier to follow.
26850                                                                          ;
26851                                                                          ; We can draw from X1 to XX and X2 to XX+1 by swapping
26852                                                                          ; XX and X2 and drawing from X1 to X2, and then drawing
26853                                                                          ; from XX to XX+1, so let's do this now
26854               
26855 BE00 D360  30        movb @X2,ra                     ; LDA X2            ; Swap XX and X2
     BE02 0033     
26856 BE04 D3A0  30        movb @XX,rx                     ; LDX XX
     BE06 0024     
26857 BE08 D80E  30        movb rx,@X2                     ; STX X2
     BE0A 0033     
26858 BE0C D80D  30        movb ra,@XX                     ; STA XX
     BE0E 0024     
26859               
26860 BE10 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     BE12 277A     
26861 BE14 06A0  32        bl   @jsr                       ;
     BE16 FE28     
26862               
26863               PLF23:
26864                                                                          ; If we jump here from the BCS above when there is no
26865                                                                          ; new line this will just draw the old line
26866 BE18 D360  30        movb @XX,ra                     ; LDA XX            ; Set X1 = XX
     BE1A 0024     
26867 BE1C D80D  30        movb ra,@X1                     ; STA X1
     BE1E 0031     
26868               
26869 BE20 D360  30        movb @XX+1,ra                   ; LDA XX+1          ; Set X2 = XX+1
     BE22 0025     
26870 BE24 D80D  30        movb ra,@X2                     ; STA X2
     BE26 0033     
26871               
26872               PLF16:
26873 BE28 0200  20        li   rtmp,HLOIN                 ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)
     BE2A 277A     
26874 BE2C 06A0  32        bl   @jsr                       ;
     BE2E FE28     
26875               
26876               PLF6:
26877 BE30 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26878                                                                          ; above
26879               
26880 BE32 1338  14        jeq  PLF8                       ; BEQ PLF8          ; If we have reached the top of the screen, jump to PLF8
26881                                                                          ; as we are done drawing (the top line of the screen is
26882                                                                          ; the border, so we don't draw there)
26883               
26884 BE34 D360  30        movb @V+1,ra                    ; LDA V+1           ; If V+1 is non-zero then we are doing the top half of
     BE36 0023     
26885 BE38 1619  14        jne  PLF10                      ; BNE PLF10         ; the new sun, so jump down to PLF10 to increment V and
26886                                                                          ; decrease the width of the line we draw
26887               
26888 BE3A 7347  18        sb   rone,ra                    ; DEC V             ; Decrement V, the height of the sun that we use to work
26889                                                                          ; out the width, so this makes the line get wider, as we
26890                                                                          ; move up towards the sun's centre
26891               
26892 BE3C 1681  14        jne  PLFL                       ; BNE PLFL          ; If V is non-zero, jump back up to PLFL to do the next
26893                                                                          ; screen line up
26894               
26895 BE3E 7347  18        sb   rone,ra                    ; DEC V+1           ; Otherwise V is 0 and we have reached the centre of the
26896                                                                          ; sun, so decrement V+1 to -1 so we start incrementing V
26897                                                                          ; each time, thus doing the top half of the new sun
26898               
26899               PLFLS:
26900 BE40 0460  28        b    @PLFL                      ; JMP PLFL          ; Jump back up to PLFL to do the next screen line up
     BE42 BD40     
26901               
26902               PLF11:
26903                                                                          ; If we get here then there is no old sun line on this
26904                                                                          ; line, so we can just draw the new sun's line
26905 BE44 D3A0  30        movb @K3,rx                     ; LDX K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
     BE46 00D2     
26906 BE48 D80E  30        movb rx,@YY                     ; STX YY            ; of the new sun's line
     BE4A 0026     
26907 BE4C D3A0  30        movb @K3+1,rx                   ; LDX K3+1
     BE4E 00D3     
26908 BE50 D80E  30        movb rx,@YY+1                   ; STX YY+1
     BE52 0027     
26909               
26910 BE54 0200  20        li   rtmp,EDGES                 ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
     BE56 C082     
26911 BE58 06A0  32        bl   @jsr                       ;
     BE5A FE28     
26912                                                                          ; line centred on YY(1 0) and with half-width A, i.e.
26913                                                                          ; the line for the new sun
26914               
26915 BE5C 17E5  14        jnc  PLF16                      ; BCC PLF16         ; If the line is on-screen, jump up to PLF16 to draw the
26916                                                                          ; line and loop round for the next line up
26917               
26918 BE5E 020D  20        li   ra,>00*256                 ; LDA #0            ; The line is not on-screen, so set the line heap for
     BE60 0000     
26919 BE62 06CF  14        swpb ry                         ;
26920 BE64 DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y         ; line Y to 0, which means there is no sun line here
     BE66 0D66     
26921 BE68 06CF  14        swpb ry                         ;
26922               
26923 BE6A 13E2  14        jeq  PLF6                       ; BEQ PLF6          ; Jump up to PLF6 to loop round for the next line up
26924                                                                          ; (this BEQ is effectively a JMP as A is always zero)
26925               
26926               PLF10:
26927 BE6C D3A0  30        movb @V,rx                      ; LDX V             ; Increment V, the height of the sun that we use to work
     BE6E 0022     
26928 BE70 B387  18        ab   rone,rx                    ; INX               ; out the width, so this makes the line get narrower, as
26929 BE72 D80E  30        movb rx,@V                      ; STX V             ; we move up and away from the sun's centre
     BE74 0022     
26930               
26931 BE76 93A0  30        cb   @K,rx                      ; CPX K             ; If V <= the radius of the sun, we still have lines to
     BE78 003D     
26932 BE7A 17E2  14        jnc  PLFLS                      ; BCC PLFLS         ; draw, so jump up to PLFL (via PLFLS) to do the next
26933 BE7C 13E1  14        jeq  PLFLS                      ; BEQ PLFLS         ; screen line up
26934               
26935               * ******************************************************************************
26936               *
26937               * Name: SUN (Part 4 of 4)
26938               * Type: Subroutine
26939               * Category: Drawing suns
26940               * Summary: Draw the sun: Continue to the top of the screen, erasing the old
26941               * sun line by line
26942               * Deep dive: Drawing the sun
26943               *
26944               * ------------------------------------------------------------------------------
26945               *
26946               * This part erases any remaining traces of the old sun, now that we have drawn
26947               * all the way to the top of the new sun.
26948               *
26949               * ------------------------------------------------------------------------------
26950               *
26951               * Other entry points:
26952               *
26953               * RTS2                Contains an RTS
26954               *
26955               * ******************************************************************************
26956               
26957 BE7E D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     BE80 0028     
26958 BE82 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
     BE84 0026     
26959 BE86 D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
     BE88 0029     
26960 BE8A D80D  30        movb ra,@YY+1                   ; STA YY+1
     BE8C 0027     
26961               
26962               PLFL3:
26963 BE8E 06CF  14        swpb ry                         ;
26964 BE90 D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     BE92 0D66     
26965 BE94 06CF  14        swpb ry                         ;
26966                                                                          ; gives us the half-width of the old sun's line on this
26967                                                                          ; line of the screen
26968               
26969 BE96 1304  14        jeq  PLF9                       ; BEQ PLF9          ; If A = 0, skip the following call to HLOIN2 as there
26970                                                                          ; is no sun line on this line of the screen
26971               
26972 BE98 0200  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     BE9A 2762     
26973 BE9C 06A0  32        bl   @jsr                       ;
     BE9E FE28     
26974                                                                          ; with centre point YY(1 0) and half-width A, and remove
26975                                                                          ; the line from the sun line heap once done
26976               
26977               PLF9:
26978 BEA0 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
26979                                                                          ; above
26980               
26981 BEA2 16F5  14        jne  PLFL3                      ; BNE PLFL3         ; Jump up to PLFL3 to redraw the next line up, until we
26982                                                                          ; have reached the top of the screen
26983               
26984               PLF8:
26985                                                                          ; If we get here, we have successfully made it from the
26986                                                                          ; bottom line of the screen to the top, and the old sun
26987                                                                          ; has been replaced by the new one
26988                      .clc                            ; CLC               ; Clear the C flag to indicate success in drawing the
     **** ****     > CLC
0001 BEA4 0A16  18        sla  rzero,1
                   < elite.a99
26989                                                                          ; sun
26990               
26991 BEA6 D360  30        movb @K3,ra                     ; LDA K3            ; Set SUNX(1 0) = K3(1 0)
     BEA8 00D2     
26992 BEAA D80D  30        movb ra,@SUNX                   ; STA SUNX
     BEAC 0028     
26993 BEAE D360  30        movb @K3+1,ra                   ; LDA K3+1
     BEB0 00D3     
26994 BEB2 D80D  30        movb ra,@SUNX+1                 ; STA SUNX+1
     BEB4 0029     
26995               
26996               RTS2:
26997 BEB6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BEB8 FE34     
26998               
26999               * ******************************************************************************
27000               *
27001               * Name: CIRCLE
27002               * Type: Subroutine
27003               * Category: Drawing circles
27004               * Summary: Draw a circle for the planet
27005               * Deep dive: Drawing circles
27006               *
27007               * ------------------------------------------------------------------------------
27008               *
27009               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
27010               * planet's main outline.
27011               *
27012               * ------------------------------------------------------------------------------
27013               *
27014               * Arguments:
27015               *
27016               * K                   The planet's radius
27017               *
27018               * K3(1 0)             Pixel x-coordinate of the centre of the planet
27019               *
27020               * K4(1 0)             Pixel y-coordinate of the centre of the planet
27021               *
27022               * ******************************************************************************
27023               
27024               CIRCLE:
27025 BEBA 0200  20        li   rtmp,CHKON                 ; JSR CHKON         ; Call CHKON to check whether the circle fits on-screen
     BEBC C0F4     
27026 BEBE 06A0  32        bl   @jsr                       ;
     BEC0 FE28     
27027               
27028 BEC2 18F9  14        joc  RTS2                       ; BCS RTS2          ; If CHKON set the C flag then the circle does not fit
27029                                                                          ; on-screen, so return from the subroutine (as RTS2
27030                                                                          ; contains an RTS)
27031               
27032 BEC4 020D  20        li   ra,>00*256                 ; LDA #0            ; Set LSX2 = 0 to indicate that the ball line heap is
     BEC6 0000     
27033 BEC8 D80D  30        movb ra,@LSX2                   ; STA LSX2          ; not empty, as we are about to fill it
     BECA 0E26     
27034               
27035 BECC D3A0  30        movb @K,rx                      ; LDX K             ; Set X = K = radius
     BECE 003D     
27036               
27037 BED0 020D  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8
     BED2 0800     
27038               
27039 BED4 028E  22        ci   rx,>08*256                 ; CPX #8            ; If the radius < 8, skip to PL89
     BED6 0800     
27040 BED8 1705  14        jnc  PL89                       ; BCC PL89
27041               
27042 BEDA 091D  18        srl  ra,1                       ; LSR A             ; Halve A so A = 4
27043               
27044 BEDC 028E  22        ci   rx,>3c*256                 ; CPX #60           ; If the radius < 60, skip to PL89
     BEDE 3C00     
27045 BEE0 1701  14        jnc  PL89                       ; BCC PL89
27046               
27047 BEE2 091D  18        srl  ra,1                       ; LSR A             ; Halve A so A = 2
27048               
27049               PL89:
27050 BEE4 D80D  30        movb ra,@STP                    ; STA STP           ; Set STP = A. STP is the step size for the circle, so
     BEE6 00A6     
27051                                                                          ; the above sets a smaller step size for bigger circles
27052               
27053                                                                          ; Fall through into CIRCLE2 to draw the circle with the
27054                                                                          ; correct step size
27055               
27056               * ******************************************************************************
27057               *
27058               * Name: CIRCLE2
27059               * Type: Subroutine
27060               * Category: Drawing circles
27061               * Summary: Draw a circle (for the planet or chart)
27062               * Deep dive: Drawing circles
27063               *
27064               * ------------------------------------------------------------------------------
27065               *
27066               * Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
27067               * planet and the chart circles.
27068               *
27069               * ------------------------------------------------------------------------------
27070               *
27071               * Arguments:
27072               *
27073               * STP                 The step size for the circle
27074               *
27075               * K                   The circle's radius
27076               *
27077               * K3(1 0)             Pixel x-coordinate of the centre of the circle
27078               *
27079               * K4(1 0)             Pixel y-coordinate of the centre of the circle
27080               *
27081               * ------------------------------------------------------------------------------
27082               *
27083               * Returns:
27084               *
27085               * C flag              The C flag is cleared
27086               *
27087               * ******************************************************************************
27088               
27089               CIRCLE2:
27090 BEE8 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set FLAG = &FF to reset the ball line heap in the call
     BEEA FF00     
27091 BEEC D80E  30        movb rx,@FLAG                   ; STX FLAG          ; to the BLINE routine below
     BEEE 00A3     
27092               
27093 BEF0 B387  18        ab   rone,rx                    ; INX               ; Set CNT = 0, our counter that goes up to 64, counting
27094 BEF2 D80E  30        movb rx,@CNT                    ; STX CNT           ; segments in our circle
     BEF4 00A4     
27095               
27096               PLL3:
27097 BEF6 D360  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT
     BEF8 00A4     
27098               
27099 BEFA 0200  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     BEFC 46BE     
27100 BEFE 06A0  32        bl   @jsr                       ;
     BF00 FE28     
27101                                                                          ;
27102                                                                          ; A = K * sin(A)
27103                                                                          ; = K * sin(CNT)
27104               
27105 BF02 020E  20        li   rx,>00*256                 ; LDX #0            ; Set T = 0, so we have the following:
     BF04 0000     
27106 BF06 D80E  30        movb rx,@T                      ; STX T             ;
     BF08 00D1     
27107                                                                          ; (T A) = K * sin(CNT)
27108                                                                          ;
27109                                                                          ; which is the x-coordinate of the circle for this count
27110               
27111 BF0A D3A0  30        movb @CNT,rx                    ; LDX CNT           ; If CNT < 33 then jump to PL37, as this is the right
     BF0C 00A4     
27112 BF0E 028E  22        ci   rx,>21*256                 ; CPX #33           ; half of the circle and the sign of the x-coordinate is
     BF10 2100     
27113 BF12 1712  14        jnc  PL37                       ; BCC PL37          ; correct
27114               
27115                      .eoi (>ff*256)                  ; EOR #%11111111    ; This is the left half of the circle, so we want to
     **** ****     > EOI
0001 BF14 0200  20        li   rtmp,(>FF*256)
     BF16 FF00     
0002 BF18 2B40  18        xor  rtmp,ra
                   < elite.a99
27116                      .adi (>00*256)                  ; ADC #0            ; flip the sign of the x-coordinate in (T A) using two's
     **** ****     > ADI
0001 BF1A 1701  14        jnc  !
0002 BF1C B347  18        ab   rone,ra
0003               !:
0004 BF1E 022D  22        ai   ra,(>00*256)
     BF20 0000     
                   < elite.a99
27117 BF22 D38D  18        movb ra,rx                      ; TAX               ; complement, so we start with the low byte and store it
27118                                                                          ; in X (the ADC adds 1 as we know the C flag is set)
27119               
27120 BF24 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T
     BF26 FF00     
27121                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 BF28 1701  14        jnc  !
0002 BF2A B347  18        ab   rone,ra
0003               !:
0004 BF2C 022D  22        ai   ra,(>00*256)
     BF2E 0000     
                   < elite.a99
27122 BF30 D80D  30        movb ra,@T                      ; STA T
     BF32 00D1     
27123               
27124 BF34 D34E  18        movb rx,ra                      ; TXA               ; Finally, we restore the low byte from X, so we have
27125                                                                          ; now negated the x-coordinate in (T A)
27126               
27127                      .clc                            ; CLC               ; Clear the C flag so we can do some more addition below
     **** ****     > CLC
0001 BF36 0A16  18        sla  rzero,1
                   < elite.a99
27128               
27129               PL37:
27130                      .adc @K3,ra                     ; ADC K3            ; We now calculate the following:
     **** ****     > ADC
0001 BF38 1701  14        jnc  !
0002 BF3A B347  18        ab   rone,ra
0003               !:
0004 BF3C B360  30        ab   @K3,ra
     BF3E 00D2     
                   < elite.a99
27131 BF40 D80D  30        movb ra,@K6                     ; STA K6            ;
     BF42 0082     
27132                                                                          ; K6(1 0) = (T A) + K3(1 0)
27133                                                                          ;
27134                                                                          ; to add the coordinates of the centre to our circle
27135                                                                          ; point, starting with the low bytes
27136               
27137 BF44 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; And then doing the high bytes, so we now have:
     BF46 00D3     
27138                      .adc @T,ra                      ; ADC T             ;
     **** ****     > ADC
0001 BF48 1701  14        jnc  !
0002 BF4A B347  18        ab   rone,ra
0003               !:
0004 BF4C B360  30        ab   @T,ra
     BF4E 00D1     
                   < elite.a99
27139 BF50 D80D  30        movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K * sin(CNT) + K3(1 0)
     BF52 0083     
27140                                                                          ;
27141                                                                          ; which is the result we want for the x-coordinate
27142               
27143 BF54 D360  30        movb @CNT,ra                    ; LDA CNT           ; Set A = CNT + 16
     BF56 00A4     
27144                      .clc                            ; CLC
     **** ****     > CLC
0001 BF58 0A16  18        sla  rzero,1
                   < elite.a99
27145                      .adi (>10*256)                  ; ADC #16
     **** ****     > ADI
0001 BF5A 1701  14        jnc  !
0002 BF5C B347  18        ab   rone,ra
0003               !:
0004 BF5E 022D  22        ai   ra,(>10*256)
     BF60 1000     
                   < elite.a99
27146               
27147 BF62 0200  20        li   rtmp,FMLTU2                ; JSR FMLTU2        ; Call FMLTU2 to calculate:
     BF64 46BE     
27148 BF66 06A0  32        bl   @jsr                       ;
     BF68 FE28     
27149                                                                          ;
27150                                                                          ; A = K * sin(A)
27151                                                                          ; = K * sin(CNT + 16)
27152                                                                          ; = K * cos(CNT)
27153               
27154 BF6A D38D  18        movb ra,rx                      ; TAX               ; Set X = A
27155                                                                          ; = K * cos(CNT)
27156               
27157 BF6C 020D  20        li   ra,>00*256                 ; LDA #0            ; Set T = 0, so we have the following:
     BF6E 0000     
27158 BF70 D80D  30        movb ra,@T                      ; STA T             ;
     BF72 00D1     
27159                                                                          ; (T X) = K * cos(CNT)
27160                                                                          ;
27161                                                                          ; which is the y-coordinate of the circle for this count
27162               
27163 BF74 D360  30        movb @CNT,ra                    ; LDA CNT           ; Set A = (CNT + 15) mod 64
     BF76 00A4     
27164                      .adi (>0f*256)                  ; ADC #15
     **** ****     > ADI
0001 BF78 1701  14        jnc  !
0002 BF7A B347  18        ab   rone,ra
0003               !:
0004 BF7C 022D  22        ai   ra,(>0F*256)
     BF7E 0F00     
                   < elite.a99
27165 BF80 024D  22        andi ra,>3f*256                 ; AND #63
     BF82 3F00     
27166               
27167 BF84 028D  22        ci   ra,>21*256                 ; CMP #33           ; If A < 33 (i.e. CNT is 0-16 or 48-64) then jump to
     BF86 2100     
27168 BF88 1712  14        jnc  PL38                       ; BCC PL38          ; PL38, as this is the bottom half of the circle and the
27169                                                                          ; sign of the y-coordinate is correct
27170               
27171 BF8A D34E  18        movb rx,ra                      ; TXA               ; This is the top half of the circle, so we want to
27172                      .eoi (>ff*256)                  ; EOR #%11111111    ; flip the sign of the y-coordinate in (T X) using two's
     **** ****     > EOI
0001 BF8C 0200  20        li   rtmp,(>FF*256)
     BF8E FF00     
0002 BF90 2B40  18        xor  rtmp,ra
                   < elite.a99
27173                      .adi (>00*256)                  ; ADC #0            ; complement, so we start with the low byte in X (the
     **** ****     > ADI
0001 BF92 1701  14        jnc  !
0002 BF94 B347  18        ab   rone,ra
0003               !:
0004 BF96 022D  22        ai   ra,(>00*256)
     BF98 0000     
                   < elite.a99
27174 BF9A D38D  18        movb ra,rx                      ; TAX               ; ADC adds 1 as we know the C flag is set)
27175               
27176 BF9C 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T, so we have
     BF9E FF00     
27177                      .adi (>00*256)                  ; ADC #0            ; now negated the y-coordinate in (T X)
     **** ****     > ADI
0001 BFA0 1701  14        jnc  !
0002 BFA2 B347  18        ab   rone,ra
0003               !:
0004 BFA4 022D  22        ai   ra,(>00*256)
     BFA6 0000     
                   < elite.a99
27178 BFA8 D80D  30        movb ra,@T                      ; STA T
     BFAA 00D1     
27179               
27180                      .clc                            ; CLC               ; Clear the C flag so the addition at the start of BLINE
     **** ****     > CLC
0001 BFAC 0A16  18        sla  rzero,1
                   < elite.a99
27181                                                                          ; will work
27182               
27183               PL38:
27184 BFAE 0200  20        li   rtmp,BLINE                 ; JSR BLINE         ; Call BLINE to draw this segment, which also increases
     BFB0 2A06     
27185 BFB2 06A0  32        bl   @jsr                       ;
     BFB4 FE28     
27186                                                                          ; CNT by STP, the step size
27187               
27188 BFB6 028D  22        ci   ra,>41*256                 ; CMP #65           ; If CNT >= 65 then skip the next instruction
     BFB8 4100     
27189 BFBA 1802  14        joc  B78                        ; BCS B78
27190               
27191 BFBC 0460  28        b    @PLL3                      ; JMP PLL3          ; Jump back for the next segment
     BFBE BEF6     
27192               
27193               B78:
27194                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 BFC0 0A16  18        sla  rzero,1
                   < elite.a99
27195               
27196 BFC2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     BFC4 FE34     
27197               
27198               * ******************************************************************************
27199               *
27200               * Name: WPLS2
27201               * Type: Subroutine
27202               * Category: Drawing planets
27203               * Summary: Remove the planet from the screen
27204               * Deep dive: The ball line heap
27205               *
27206               * ------------------------------------------------------------------------------
27207               *
27208               * We do this by redrawing it using the lines stored in the ball line heap when
27209               * the planet was originally drawn by the BLINE routine.
27210               *
27211               * ******************************************************************************
27212               
27213               WPLS2:
27214 BFC6 D3E0  30        movb @LSX2,ry                   ; LDY LSX2          ; If LSX2 is non-zero (which indicates the ball line
     BFC8 0E26     
27215 BFCA 1634  14        jne  WP1                        ; BNE WP1           ; heap is empty), jump to WP1 to reset the line heap
27216                                                                          ; without redrawing the planet
27217               
27218                                                                          ; Otherwise Y is now 0, so we can use it as a counter to
27219                                                                          ; loop through the lines in the line heap, redrawing
27220                                                                          ; each one to remove the planet from the screen, before
27221                                                                          ; resetting the line heap once we are done
27222               
27223               WPL1:
27224 BFCC 93E0  30        cb   @LSP,ry                    ; CPY LSP           ; If Y >= LSP then we have reached the end of the line
     BFCE 0077     
27225 BFD0 1831  14        joc  WP1                        ; BCS WP1           ; heap and have finished redrawing the planet (as LSP
27226                                                                          ; points to the end of the heap), so jump to WP1 to
27227                                                                          ; reset the line heap, returning from the subroutine
27228                                                                          ; using a tail call
27229               
27230 BFD2 06CF  14        swpb ry                         ;
27231 BFD4 D36F  34        movb @LSY2(ry),ra               ; LDA LSY2,Y        ; Set A to the y-coordinate of the current heap entry
     BFD6 0E74     
27232 BFD8 06CF  14        swpb ry                         ;
27233               
27234 BFDA 028D  22        ci   ra,>ff*256                 ; CMP #&FF          ; If the y-coordinate is &FF, this indicates that the
     BFDC FF00     
27235 BFDE 131A  14        jeq  WP2                        ; BEQ WP2           ; next point in the heap denotes the start of a line
27236                                                                          ; segment, so jump to WP2 to put it into (X1, Y1)
27237               
27238 BFE0 D80D  30        movb ra,@Y2                     ; STA Y2            ; Set (X2, Y2) to the x- and y-coordinates from the
     BFE2 0034     
27239 BFE4 06CF  14        swpb ry                         ;
27240 BFE6 D36F  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; heap
     BFE8 0E26     
27241 BFEA 06CF  14        swpb ry                         ;
27242 BFEC D80D  30        movb ra,@X2                     ; STA X2
     BFEE 0033     
27243               
27244 BFF0 0200  20        li   rtmp,LOIN                  ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)
     BFF2 23BE     
27245 BFF4 06A0  32        bl   @jsr                       ;
     BFF6 FE28     
27246               
27247 BFF8 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
27248               
27249 BFFA D360  30        movb @SWAP,ra                   ; LDA SWAP          ; If SWAP is non-zero then we swapped the coordinates
     BFFC 00A1     
27250 BFFE 16E6  14        jne  WPL1                       ; BNE WPL1          ; when filling the heap in BLINE, so loop back WPL1
27251                                                                          ; for the next point in the heap
27252               
27253 C000 D360  30        movb @X2,ra                     ; LDA X2            ; Swap (X1, Y1) and (X2, Y2), so the next segment will
     C002 0033     
27254 C004 D80D  30        movb ra,@X1                     ; STA X1            ; be drawn from the current (X2, Y2) to the next point
     C006 0031     
27255 C008 D360  30        movb @Y2,ra                     ; LDA Y2            ; in the heap
     C00A 0034     
27256 C00C D80D  30        movb ra,@Y1                     ; STA Y1
     C00E 0032     
27257               
27258 C010 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     C012 BFCC     
27259               
27260               WP2:
27261 C014 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
27262               
27263 C016 06CF  14        swpb ry                         ;
27264 C018 D36F  34        movb @LSX2(ry),ra               ; LDA LSX2,Y        ; Set (X1, Y1) to the x- and y-coordinates from the
     C01A 0E26     
27265 C01C 06CF  14        swpb ry                         ;
27266 C01E D80D  30        movb ra,@X1                     ; STA X1            ; heap
     C020 0031     
27267 C022 06CF  14        swpb ry                         ;
27268 C024 D36F  34        movb @LSY2(ry),ra               ; LDA LSY2,Y
     C026 0E74     
27269 C028 06CF  14        swpb ry                         ;
27270 C02A D80D  30        movb ra,@Y1                     ; STA Y1
     C02C 0032     
27271               
27272 C02E B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point
27273               
27274 C030 0460  28        b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap
     C032 BFCC     
27275               
27276               * ******************************************************************************
27277               *
27278               * Name: WP1
27279               * Type: Subroutine
27280               * Category: Drawing planets
27281               * Summary: Reset the ball line heap
27282               *
27283               * ******************************************************************************
27284               
27285               WP1:
27286 C034 020D  20        li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap pointer
     C036 0100     
27287 C038 D80D  30        movb ra,@LSP                    ; STA LSP
     C03A 0077     
27288               
27289 C03C 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set LSX2 = &FF to indicate the ball line heap is empty
     C03E FF00     
27290 C040 D80D  30        movb ra,@LSX2                   ; STA LSX2
     C042 0E26     
27291               
27292 C044 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C046 FE34     
27293               
27294               * ******************************************************************************
27295               *
27296               * Name: WPLS
27297               * Type: Subroutine
27298               * Category: Drawing suns
27299               * Summary: Remove the sun from the screen
27300               * Deep dive: Drawing the sun
27301               *
27302               * ------------------------------------------------------------------------------
27303               *
27304               * We do this by redrawing it using the lines stored in the sun line heap when
27305               * the sun was originally drawn by the SUN routine.
27306               *
27307               * ------------------------------------------------------------------------------
27308               *
27309               * Arguments:
27310               *
27311               * SUNX(1 0)           The x-coordinate of the vertical centre axis of the sun
27312               *
27313               * ------------------------------------------------------------------------------
27314               *
27315               * Other entry points:
27316               *
27317               * WPLS-1              Contains an RTS
27318               *
27319               * ******************************************************************************
27320               
27321               WPLS:
27322 C048 D360  30        movb @LSX,ra                    ; LDA LSX           ; If LSX < 0, the sun line heap is empty, so return from
     C04A 0D66     
27323 C04C 11FC  14        jlt  WPLS-1                     ; BMI WPLS-1        ; the subroutine (as WPLS-1 contains an RTS)
27324               
27325 C04E D360  30        movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
     C050 0028     
27326 C052 D80D  30        movb ra,@YY                     ; STA YY            ; vertical centre axis of the sun that's currently on
     C054 0026     
27327 C056 D360  30        movb @SUNX+1,ra                 ; LDA SUNX+1        ; screen
     C058 0029     
27328 C05A D80D  30        movb ra,@YY+1                   ; STA YY+1
     C05C 0027     
27329               
27330 C05E 020F  20        li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
     C060 BF00     
27331                                                                          ; view, so this sets Y as a counter for the number of
27332                                                                          ; lines in the space view (i.e. 191), which is also the
27333                                                                          ; number of lines in the LSO block
27334               
27335               WPL2:
27336 C062 06CF  14        swpb ry                         ;
27337 C064 D36F  34        movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
     C066 0D66     
27338 C068 06CF  14        swpb ry                         ;
27339                                                                          ; gives us the half-width of the sun's line on this line
27340                                                                          ; of the screen
27341               
27342 C06A 1304  14        jeq  B79                        ; BEQ B79           ; If A = 0, skip the following call to HLOIN2 as there
27343                                                                          ; is no sun line on this line of the screen
27344               
27345 C06C 0200  20        li   rtmp,HLOIN2                ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
     C06E 2762     
27346 C070 06A0  32        bl   @jsr                       ;
     C072 FE28     
27347                                                                          ; with centre point YY(1 0) and half-width A, and remove
27348                                                                          ; the line from the sun line heap once done
27349               
27350               B79:
27351 C074 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
27352               
27353 C076 16F5  14        jne  WPL2                       ; BNE WPL2          ; Loop back for the next line in the line heap until
27354                                                                          ; we have gone through the entire heap
27355               
27356 C078 73C7  18        sb   rone,ry                    ; DEY               ; This sets Y to &FF, as we end the loop with Y = 0
27357               
27358 C07A D80F  30        movb ry,@LSX                    ; STY LSX           ; Set LSX to &FF to indicate the sun line heap is empty
     C07C 0D66     
27359               
27360 C07E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C080 FE34     
27361               
27362               * ******************************************************************************
27363               *
27364               * Name: EDGES
27365               * Type: Subroutine
27366               * Category: Drawing lines
27367               * Summary: Draw a horizontal line given a centre and a half-width
27368               *
27369               * ------------------------------------------------------------------------------
27370               *
27371               * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
27372               * centre x-coordinate YY(1 0), and length A in either direction from the centre
27373               * (so a total line length of 2 * A). In other words, this line:
27374               *
27375               * X1             YY(1 0)             X2
27376               * +-----------------+-----------------+
27377               * <- A ->           <- A ->
27378               *
27379               * The resulting line gets clipped to the edges of the screen, if needed. If the
27380               * calculation doesn't overflow, we return with the C flag clear, otherwise the C
27381               * flag gets set to indicate failure and the Y-th LSO entry gets set to 0.
27382               *
27383               * ------------------------------------------------------------------------------
27384               *
27385               * Arguments:
27386               *
27387               * A                   The half-length of the line
27388               *
27389               * YY(1 0)             The centre x-coordinate
27390               *
27391               * ------------------------------------------------------------------------------
27392               *
27393               * Returns:
27394               *
27395               * C flag              Clear if the line fits on-screen, set if it doesn't
27396               *
27397               * X1, X2              The x-coordinates of the clipped line
27398               *
27399               * LSO+Y               If the line doesn't fit, LSO+Y is set to 0
27400               *
27401               * Y                   Y is preserved
27402               *
27403               * ******************************************************************************
27404               
27405               EDGES:
27406 C082 D80D  30        movb ra,@T                      ; STA T             ; Set T to the line's half-length in argument A
     C084 00D1     
27407               
27408                      .clc                            ; CLC               ; We now calculate:
     **** ****     > CLC
0001 C086 0A16  18        sla  rzero,1
                   < elite.a99
27409                      .adc @YY,ra                     ; ADC YY            ;
     **** ****     > ADC
0001 C088 1701  14        jnc  !
0002 C08A B347  18        ab   rone,ra
0003               !:
0004 C08C B360  30        ab   @YY,ra
     C08E 0026     
                   < elite.a99
27410 C090 D80D  30        movb ra,@X2                     ; STA X2            ; (A X2) = YY(1 0) + A
     C092 0033     
27411                                                                          ;
27412                                                                          ; to set X2 to the x-coordinate of the right end of the
27413                                                                          ; line, starting with the low bytes
27414               
27415 C094 D360  30        movb @YY+1,ra                   ; LDA YY+1          ; And then adding the high bytes
     C096 0027     
27416                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 C098 1701  14        jnc  !
0002 C09A B347  18        ab   rone,ra
0003               !:
0004 C09C 022D  22        ai   ra,(>00*256)
     C09E 0000     
                   < elite.a99
27417               
27418 C0A0 1120  14        jlt  ED1                        ; BMI ED1           ; If the addition is negative then the calculation has
27419                                                                          ; overflowed, so jump to ED1 to return a failure
27420               
27421 C0A2 1304  14        jeq  B80                        ; BEQ B80           ; If the high byte A from the result is 0, skip the
27422                                                                          ; next two instructions, as the result already fits on
27423                                                                          ; the screen
27424               
27425 C0A4 020D  20        li   ra,>fe*256                 ; LDA #254          ; The high byte is positive and non-zero, so we went
     C0A6 FE00     
27426 C0A8 D80D  30        movb ra,@X2                     ; STA X2            ; past the right edge of the screen, so clip X2 to the
     C0AA 0033     
27427                                                                          ; x-coordinate of the right edge of the screen
27428               
27429               B80:
27430 C0AC D360  30        movb @YY,ra                     ; LDA YY            ; We now calculate:
     C0AE 0026     
27431                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 C0B0 0A18  18        sla  rmone,1
                   < elite.a99
27432                      .sbc @T,ra                      ; SBC T             ; (A X1) = YY(1 0) - argument A
     **** ****     > SBC
0001 C0B2 1801  14        joc  !
0002 C0B4 7347  18        sb   rone,ra
0003               !:
0004 C0B6 7360  30        sb   @T,ra
     C0B8 00D1     
                   < elite.a99
27433 C0BA D80D  30        movb ra,@X1                     ; STA X1            ;
     C0BC 0031     
27434                                                                          ; to set X1 to the x-coordinate of the left end of the
27435                                                                          ; line, starting with the low bytes
27436               
27437 C0BE D360  30        movb @YY+1,ra                   ; LDA YY+1          ; And then subtracting the high bytes
     C0C0 0027     
27438                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 C0C2 1801  14        joc  !
0002 C0C4 7347  18        sb   rone,ra
0003               !:
0004 C0C6 022D  22        ai   ra,-(>00*256)
     C0C8 0000     
                   < elite.a99
27439               
27440 C0CA 1603  14        jne  ED3                        ; BNE ED3           ; If the high byte subtraction is non-zero, then skip
27441                                                                          ; to ED3
27442               
27443                      .clc                            ; CLC               ; Otherwise the high byte of the subtraction was zero,
     **** ****     > CLC
0001 C0CC 0A16  18        sla  rzero,1
                   < elite.a99
27444                                                                          ; so the line fits on-screen and we clear the C flag to
27445                                                                          ; indicate success
27446               
27447 C0CE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C0D0 FE34     
27448               
27449               ED3:
27450 C0D2 1507  14        jgt  ED1                        ; BPL ED1           ; If the addition is positive then the calculation has
27451                                                                          ; underflowed, so jump to ED1 to return a failure
27452               
27453 C0D4 020D  20        li   ra,>02*256                 ; LDA #2            ; The high byte is negative and non-zero, so we went
     C0D6 0200     
27454 C0D8 D80D  30        movb ra,@X1                     ; STA X1            ; past the left edge of the screen, so clip X1 to the
     C0DA 0031     
27455                                                                          ; x-coordinate of the left edge of the screen
27456               
27457                      .clc                            ; CLC               ; The line does fit on-screen, so clear the C flag to
     **** ****     > CLC
0001 C0DC 0A16  18        sla  rzero,1
                   < elite.a99
27458                                                                          ; indicate success
27459               
27460 C0DE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C0E0 FE34     
27461               
27462               ED1:
27463 C0E2 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
     C0E4 0000     
27464 C0E6 06CF  14        swpb ry                         ;
27465 C0E8 DBCD  38        movb ra,@LSO(ry)                ; STA LSO,Y
     C0EA 0D66     
27466 C0EC 06CF  14        swpb ry                         ;
27467               
27468                      .sec                            ; SEC               ; The line does not fit on the screen, so set the C flag
     **** ****     > SEC
0001 C0EE 0A18  18        sla  rmone,1
                   < elite.a99
27469                                                                          ; to indicate this result
27470               
27471 C0F0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C0F2 FE34     
27472               
27473               * ******************************************************************************
27474               *
27475               * Name: CHKON
27476               * Type: Subroutine
27477               * Category: Drawing circles
27478               * Summary: Check whether any part of a circle appears on the extended screen
27479               *
27480               * ------------------------------------------------------------------------------
27481               *
27482               * Arguments:
27483               *
27484               * K                   The circle's radius
27485               *
27486               * K3(1 0)             Pixel x-coordinate of the centre of the circle
27487               *
27488               * K4(1 0)             Pixel y-coordinate of the centre of the circle
27489               *
27490               * ------------------------------------------------------------------------------
27491               *
27492               * Returns:
27493               *
27494               * C flag              Clear if any part of the circle appears on-screen, set
27495               * if none of the circle appears on-screen
27496               *
27497               * (A X)               Minimum y-coordinate of the circle on-screen (i.e. the
27498               * y-coordinate of the top edge of the circle)
27499               *
27500               * P(2 1)              Maximum y-coordinate of the circle on-screen (i.e. the
27501               * y-coordinate of the bottom edge of the circle)
27502               *
27503               * ******************************************************************************
27504               
27505               CHKON:
27506 C0F4 D360  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 + K
     C0F6 00D2     
27507                      .clc                            ; CLC
     **** ****     > CLC
0001 C0F8 0A16  18        sla  rzero,1
                   < elite.a99
27508                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 C0FA 1701  14        jnc  !
0002 C0FC B347  18        ab   rone,ra
0003               !:
0004 C0FE B360  30        ab   @K,ra
     C100 003D     
                   < elite.a99
27509               
27510 C102 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 + 0 + any carry from above, so this
     C104 00D3     
27511                      .adi (>00*256)                  ; ADC #0            ; effectively sets A to the high byte of K3(1 0) + K:
     **** ****     > ADI
0001 C106 1701  14        jnc  !
0002 C108 B347  18        ab   rone,ra
0003               !:
0004 C10A 022D  22        ai   ra,(>00*256)
     C10C 0000     
                   < elite.a99
27512                                                                          ;
27513                                                                          ; (A ?) = K3(1 0) + K
27514                                                                          ;
27515                                                                          ; so A is the high byte of the x-coordinate of the right
27516                                                                          ; edge of the circle
27517               
27518 C10E 1135  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the right edge of the circle is
27519                                                                          ; to the left of the screen, so jump to PL21 to set the
27520                                                                          ; C flag and return from the subroutine, as the whole
27521                                                                          ; circle is off-screen to the left
27522               
27523 C110 D360  30        movb @K3,ra                     ; LDA K3            ; Set A = K3 - K
     C112 00D2     
27524                      .sec                            ; SEC
     **** ****     > SEC
0001 C114 0A18  18        sla  rmone,1
                   < elite.a99
27525                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 C116 1801  14        joc  !
0002 C118 7347  18        sb   rone,ra
0003               !:
0004 C11A 7360  30        sb   @K,ra
     C11C 003D     
                   < elite.a99
27526               
27527 C11E D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 - 0 - any carry from above, so this
     C120 00D3     
27528                      .sbi (>00*256)                  ; SBC #0            ; effectively sets A to the high byte of K3(1 0) - K:
     **** ****     > SBI
0001 C122 1801  14        joc  !
0002 C124 7347  18        sb   rone,ra
0003               !:
0004 C126 022D  22        ai   ra,-(>00*256)
     C128 0000     
                   < elite.a99
27529                                                                          ;
27530                                                                          ; (A ?) = K3(1 0) - K
27531                                                                          ;
27532                                                                          ; so A is the high byte of the x-coordinate of the left
27533                                                                          ; edge of the circle
27534               
27535 C12A 1101  14        jlt  PL31                       ; BMI PL31          ; If A is negative then the left edge of the circle is
27536                                                                          ; to the left of the screen, and we already know the
27537                                                                          ; right edge is either on-screen or off-screen to the
27538                                                                          ; right, so skip to PL31 to move on to the y-coordinate
27539                                                                          ; checks, as at least part of the circle is on-screen in
27540                                                                          ; terms of the x-axis
27541               
27542 C12C 1626  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the left edge of the circle is
27543                                                                          ; to the right of the screen, so jump to PL21 to set the
27544                                                                          ; C flag and return from the subroutine, as the whole
27545                                                                          ; circle is off-screen to the right
27546               
27547               PL31:
27548 C12E D360  30        movb @K4,ra                     ; LDA K4            ; Set P+1 = K4 + K
     C130 00E0     
27549                      .clc                            ; CLC
     **** ****     > CLC
0001 C132 0A16  18        sla  rzero,1
                   < elite.a99
27550                      .adc @K,ra                      ; ADC K
     **** ****     > ADC
0001 C134 1701  14        jnc  !
0002 C136 B347  18        ab   rone,ra
0003               !:
0004 C138 B360  30        ab   @K,ra
     C13A 003D     
                   < elite.a99
27551 C13C D80D  30        movb ra,@P+1                    ; STA P+1
     C13E 001C     
27552               
27553 C140 D360  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 + 0 + any carry from above, so this
     C142 00E1     
27554                      .adi (>00*256)                  ; ADC #0            ; does the following:
     **** ****     > ADI
0001 C144 1701  14        jnc  !
0002 C146 B347  18        ab   rone,ra
0003               !:
0004 C148 022D  22        ai   ra,(>00*256)
     C14A 0000     
                   < elite.a99
27555                                                                          ;
27556                                                                          ; (A P+1) = K4(1 0) + K
27557                                                                          ;
27558                                                                          ; so A is the high byte of the y-coordinate of the
27559                                                                          ; bottom edge of the circle
27560               
27561 C14C 1116  14        jlt  PL21                       ; BMI PL21          ; If A is negative then the bottom edge of the circle is
27562                                                                          ; above the top of the screen, so jump to PL21 to set
27563                                                                          ; the C flag and return from the subroutine, as the
27564                                                                          ; whole circle is off-screen to the top
27565               
27566 C14E D80D  30        movb ra,@P+2                    ; STA P+2           ; Store the high byte in P+2, so now we have:
     C150 001D     
27567                                                                          ;
27568                                                                          ; P(2 1) = K4(1 0) + K
27569                                                                          ;
27570                                                                          ; i.e. the maximum y-coordinate of the circle on-screen
27571                                                                          ; (which we return)
27572               
27573 C152 D360  30        movb @K4,ra                     ; LDA K4            ; Set X = K4 - K
     C154 00E0     
27574                      .sec                            ; SEC
     **** ****     > SEC
0001 C156 0A18  18        sla  rmone,1
                   < elite.a99
27575                      .sbc @K,ra                      ; SBC K
     **** ****     > SBC
0001 C158 1801  14        joc  !
0002 C15A 7347  18        sb   rone,ra
0003               !:
0004 C15C 7360  30        sb   @K,ra
     C15E 003D     
                   < elite.a99
27576 C160 D38D  18        movb ra,rx                      ; TAX
27577               
27578 C162 D360  30        movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 - 0 - any carry from above, so this
     C164 00E1     
27579                      .sbi (>00*256)                  ; SBC #0            ; does the following:
     **** ****     > SBI
0001 C166 1801  14        joc  !
0002 C168 7347  18        sb   rone,ra
0003               !:
0004 C16A 022D  22        ai   ra,-(>00*256)
     C16C 0000     
                   < elite.a99
27580                                                                          ;
27581                                                                          ; (A X) = K4(1 0) - K
27582                                                                          ;
27583                                                                          ; so A is the high byte of the y-coordinate of the top
27584                                                                          ; edge of the circle
27585               
27586 C16E 1179  14        jlt  PL44                       ; BMI PL44          ; If A is negative then the top edge of the circle is
27587                                                                          ; above the top of the screen, and we already know the
27588                                                                          ; bottom edge is either on-screen or below the bottom
27589                                                                          ; of the screen, so skip to PL44 to clear the C flag and
27590                                                                          ; return from the subroutine using a tail call, as part
27591                                                                          ; of the circle definitely appears on-screen
27592               
27593 C170 1604  14        jne  PL21                       ; BNE PL21          ; If A is non-zero, then the top edge of the circle is
27594                                                                          ; below the bottom of the screen, so jump to PL21 to set
27595                                                                          ; the C flag and return from the subroutine, as the
27596                                                                          ; whole circle is off-screen to the bottom
27597               
27598 C172 028E  22        ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If we get here then A is zero, which means the top
     C174 BF00     
27599                                                                          ; edge of the circle is within the screen boundary, so
27600                                                                          ; now we need to check whether it is in the space view
27601                                                                          ; (in which case it is on-screen) or the dashboard (in
27602                                                                          ; which case the top of the circle is hidden by the
27603                                                                          ; dashboard, so the circle isn't on-screen). We do this
27604                                                                          ; by checking the low byte of the result in X against
27605                                                                          ; 2 * #Y - 1, and returning the C flag from this
27606                                                                          ; comparison. The constant #Y is the y-coordinate of the
27607                                                                          ; mid-point of the space view, so 2 * #Y - 1, the
27608                                                                          ; y-coordinate of the bottom pixel row of the space
27609                                                                          ; view. So this does the following:
27610                                                                          ;
27611                                                                          ; * The C flag is set if coordinate (A X) is below the
27612                                                                          ; bottom row of the space view, i.e. the top edge of
27613                                                                          ; the circle is hidden by the dashboard
27614                                                                          ;
27615                                                                          ; * The C flag is clear if coordinate (A X) is above
27616                                                                          ; the bottom row of the space view, i.e. the top
27617                                                                          ; edge of the circle is on-screen
27618               
27619 C176 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C178 FE34     
27620               
27621               * ******************************************************************************
27622               *
27623               * Name: PL21
27624               * Type: Subroutine
27625               * Category: Drawing planets
27626               * Summary: Return from a planet/sun-drawing routine with a failure flag
27627               *
27628               * ------------------------------------------------------------------------------
27629               *
27630               * Set the C flag and return from the subroutine. This is used to return from a
27631               * planet- or sun-drawing routine with the C flag indicating an overflow in the
27632               * calculation.
27633               *
27634               * ******************************************************************************
27635               
27636               PL21:
27637                      .sec                            ; SEC               ; Set the C flag to indicate an overflow
     **** ****     > SEC
0001 C17A 0A18  18        sla  rmone,1
                   < elite.a99
27638               
27639 C17C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C17E FE34     
27640               
27641               * ******************************************************************************
27642               *
27643               * Name: PLS3
27644               * Type: Subroutine
27645               * Category: Drawing planets
27646               * Summary: Calculate (Y A P) = 222 * roofv_x / z
27647               *
27648               * ------------------------------------------------------------------------------
27649               *
27650               * Calculate the following, with X determining the vector to use:
27651               *
27652               * (Y A P) = 222 * roofv_x / z
27653               *
27654               * though in reality only (Y A) is used.
27655               *
27656               * Although the code below supports a range of values of X, in practice the
27657               * routine is only called with X = 15, and then again after X has been
27658               * incremented to 17. So the values calculated by PLS1 use roofv_x first, then
27659               * roofv_y. The comments below refer to roofv_x, for the first call.
27660               *
27661               * ------------------------------------------------------------------------------
27662               *
27663               * Arguments:
27664               *
27665               * X                   Determines which of the INWK orientation vectors to
27666               * divide:
27667               *
27668               * * X = 15: divides roofv_x
27669               *
27670               * * X = 17: divides roofv_y
27671               *
27672               * ------------------------------------------------------------------------------
27673               *
27674               * Returns:
27675               *
27676               * X                   X gets incremented by 2 so it points to the next
27677               * coordinate in this orientation vector (so consecutive
27678               * calls to the routine will start with x, then move onto y
27679               * and then z)
27680               *
27681               * ******************************************************************************
27682               
27683               PLS3:
27684 C180 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     C182 BA3C     
27685 C184 06A0  32        bl   @jsr                       ;
     C186 FE28     
27686 C188 D80D  30        movb ra,@P                      ; STA P             ;
     C18A 001B     
27687                                                                          ; P = |roofv_x / z|
27688                                                                          ; K+3 = sign of roofv_x / z
27689                                                                          ;
27690                                                                          ; and increment X to point to roofv_y for the next call
27691               
27692 C18C 020D  20        li   ra,>de*256                 ; LDA #222          ; Set Q = 222, the offset to the crater
     C18E DE00     
27693 C190 D80D  30        movb ra,@Q                      ; STA Q
     C192 0090     
27694               
27695 C194 D80E  30        movb rx,@U                      ; STX U             ; Store the vector index X in U for retrieval after the
     C196 008F     
27696                                                                          ; call to MULTU
27697               
27698 C198 0200  20        li   rtmp,MULTU                 ; JSR MULTU         ; Call MULTU to calculate
     C19A 4676     
27699 C19C 06A0  32        bl   @jsr                       ;
     C19E FE28     
27700                                                                          ;
27701                                                                          ; (A P) = P * Q
27702                                                                          ; = 222 * |roofv_x / z|
27703               
27704 C1A0 D3A0  30        movb @U,rx                      ; LDX U             ; Restore the vector index from U into X
     C1A2 008F     
27705               
27706 C1A4 D3E0  30        movb @K+3,ry                    ; LDY K+3           ; If the sign of the result in K+3 is positive, skip to
     C1A6 0040     
27707 C1A8 150D  14        jgt  PL12                       ; BPL PL12          ; PL12 to return with Y = 0
27708               
27709                      .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise the result should be negative, so negate the
     **** ****     > EOI
0001 C1AA 0200  20        li   rtmp,(>FF*256)
     C1AC FF00     
0002 C1AE 2B40  18        xor  rtmp,ra
                   < elite.a99
27710                      .clc                            ; CLC               ; high byte of the result using two's complement with
     **** ****     > CLC
0001 C1B0 0A16  18        sla  rzero,1
                   < elite.a99
27711                      .adi (>01*256)                  ; ADC #1            ; A = ~A + 1
     **** ****     > ADI
0001 C1B2 1701  14        jnc  !
0002 C1B4 B347  18        ab   rone,ra
0003               !:
0004 C1B6 022D  22        ai   ra,(>01*256)
     C1B8 0100     
                   < elite.a99
27712               
27713 C1BA 1304  14        jeq  PL12                       ; BEQ PL12          ; If A = 0, jump to PL12 to return with (Y A) = 0
27714               
27715 C1BC 020F  20        li   ry,>ff*256                 ; LDY #&FF          ; Set Y = &FF to be a negative high byte
     C1BE FF00     
27716               
27717 C1C0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C1C2 FE34     
27718               
27719               PL12:
27720 C1C4 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to be a positive high byte
     C1C6 0000     
27721               
27722 C1C8 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C1CA FE34     
27723               
27724               * ******************************************************************************
27725               *
27726               * Name: PLS4
27727               * Type: Subroutine
27728               * Category: Drawing planets
27729               * Summary: Calculate CNT2 = arctan(P / A) / 4
27730               *
27731               * ------------------------------------------------------------------------------
27732               *
27733               * Calculate the following:
27734               *
27735               * CNT2 = arctan(P / A) / 4
27736               *
27737               * and do the following if nosev_z_hi >= 0:
27738               *
27739               * CNT2 = CNT2 + 32
27740               *
27741               * which is the equivalent of adding 180 degrees to the result (or PI radians),
27742               * as there are 64 segments in a full circle.
27743               *
27744               * This routine is called with the following arguments when calculating the
27745               * equator and meridian for planets:
27746               *
27747               * * A = roofv_z_hi, P = -nosev_z_hi
27748               *
27749               * * A = sidev_z_hi, P = -nosev_z_hi
27750               *
27751               * So it calculates the angle between the planet's orientation vectors, in the
27752               * z-axis.
27753               *
27754               * ******************************************************************************
27755               
27756               PLS4:
27757 C1CC D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = A
     C1CE 0090     
27758               
27759 C1D0 0200  20        li   rtmp,ARCTAN                ; JSR ARCTAN        ; Call ARCTAN to calculate:
     C1D2 4B22     
27760 C1D4 06A0  32        bl   @jsr                       ;
     C1D6 FE28     
27761                                                                          ;
27762                                                                          ; A = arctan(P / Q)
27763                                                                          ; arctan(P / A)
27764                                                                          ;
27765                                                                          ; The result in A will be in the range 0 to 128, which
27766                                                                          ; represents an angle of 0 to 180 degrees (or 0 to PI
27767                                                                          ; radians)
27768               
27769 C1D8 D3A0  30        movb @INWK+14,rx                ; LDX INWK+14       ; If nosev_z_hi is negative, skip the following
     C1DA 0061     
27770 C1DC 1103  14        jlt  B81                        ; BMI B81           ; instruction to leave the angle in A as a positive
27771                                                                          ; integer in the range 0 to 128 (so when we calculate
27772                                                                          ; CNT2 below, it will be in the right half of the
27773                                                                          ; anti-clockwise arc that we describe when drawing
27774                                                                          ; circles, i.e. from 6 o'clock, through 3 o'clock and
27775                                                                          ; on to 12 o'clock)
27776               
27777                      .eoi (>80*256)                  ; EOR #%10000000    ; If we get here then nosev_z_hi is positive, so flip
     **** ****     > EOI
0001 C1DE 0200  20        li   rtmp,(>80*256)
     C1E0 8000     
0002 C1E2 2B40  18        xor  rtmp,ra
                   < elite.a99
27778                                                                          ; bit 7 of the angle in A, which is the same as adding
27779                                                                          ; 128 to give a result in the range 129 to 256 (i.e. 129
27780                                                                          ; to 0), or 180 to 360 degrees (so when we calculate
27781                                                                          ; CNT2 below, it will be in the left half of the
27782                                                                          ; anti-clockwise arc that we describe when drawing
27783                                                                          ; circles, i.e. from 12 o'clock, through 9 o'clock and
27784                                                                          ; on to 6 o'clock)
27785               
27786               B81:
27787 C1E4 091D  18        srl  ra,1                       ; LSR A             ; Set CNT2 = A / 4
27788 C1E6 091D  18        srl  ra,1                       ; LSR A
27789 C1E8 D80D  30        movb ra,@CNT2                   ; STA CNT2
     C1EA 00A5     
27790               
27791 C1EC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C1EE FE34     
27792               
27793               * ******************************************************************************
27794               *
27795               * Name: PLS5
27796               * Type: Subroutine
27797               * Category: Drawing planets
27798               * Summary: Calculate roofv_x / z and roofv_y / z
27799               *
27800               * ------------------------------------------------------------------------------
27801               *
27802               * Calculate the following divisions of a specified value from one of the
27803               * orientation vectors (in this example, roofv):
27804               *
27805               * (XX16+2 K2+2) = roofv_x / z
27806               *
27807               * (XX16+3 K2+3) = roofv_y / z
27808               *
27809               * ------------------------------------------------------------------------------
27810               *
27811               * Arguments:
27812               *
27813               * X                   Determines which of the INWK orientation vectors to
27814               * divide:
27815               *
27816               * * X = 15: divides roofv_x and roofv_y
27817               *
27818               * * X = 21: divides sidev_x and sidev_y
27819               *
27820               * INWK                The planet's ship data block
27821               *
27822               * ******************************************************************************
27823               
27824               PLS5:
27825 C1F0 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     C1F2 BA3C     
27826 C1F4 06A0  32        bl   @jsr                       ;
     C1F6 FE28     
27827 C1F8 D80D  30        movb ra,@K2+2                   ; STA K2+2          ;
     C1FA 00AE     
27828 C1FC D80F  30        movb ry,@XX16+2                 ; STY XX16+2        ; K+2    = |roofv_x / z|
     C1FE 000B     
27829                                                                          ; XX16+2 = sign of roofv_x / z
27830                                                                          ;
27831                                                                          ; i.e. (XX16+2 K2+2) = roofv_x / z
27832                                                                          ;
27833                                                                          ; and increment X to point to roofv_y for the next call
27834               
27835 C200 0200  20        li   rtmp,PLS1                  ; JSR PLS1          ; Call PLS1 to calculate the following:
     C202 BA3C     
27836 C204 06A0  32        bl   @jsr                       ;
     C206 FE28     
27837 C208 D80D  30        movb ra,@K2+3                   ; STA K2+3          ;
     C20A 00AF     
27838 C20C D80F  30        movb ry,@XX16+3                 ; STY XX16+3        ; K+3    = |roofv_y / z|
     C20E 000C     
27839                                                                          ; XX16+3 = sign of roofv_y / z
27840                                                                          ;
27841                                                                          ; i.e. (XX16+3 K2+3) = roofv_y / z
27842                                                                          ;
27843                                                                          ; and increment X to point to roofv_z for the next call
27844               
27845 C210 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C212 FE34     
27846               
27847               * ******************************************************************************
27848               *
27849               * Name: PLS6
27850               * Type: Subroutine
27851               * Category: Drawing planets
27852               * Summary: Calculate (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27853               *
27854               * ------------------------------------------------------------------------------
27855               *
27856               * Calculate the following:
27857               *
27858               * (X K) = (A P+1 P) / (z_sign z_hi z_lo)
27859               *
27860               * returning an overflow in the C flag if the result is >= 1024.
27861               *
27862               * ------------------------------------------------------------------------------
27863               *
27864               * Arguments:
27865               *
27866               * INWK                The planet or sun's ship data block
27867               *
27868               * ------------------------------------------------------------------------------
27869               *
27870               * Returns:
27871               *
27872               * C flag              Set if the result >= 1024, clear otherwise
27873               *
27874               * ------------------------------------------------------------------------------
27875               *
27876               * Other entry points:
27877               *
27878               * PL44                Clear the C flag and return from the subroutine
27879               *
27880               * ******************************************************************************
27881               
27882               PLS6:
27883 C214 0200  20        li   rtmp,DVID3B2               ; JSR DVID3B2       ; Call DVID3B2 to calculate:
     C216 4994     
27884 C218 06A0  32        bl   @jsr                       ;
     C21A FE28     
27885                                                                          ;
27886                                                                          ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
27887               
27888 C21C D360  30        movb @K+3,ra                    ; LDA K+3           ; Set A = |K+3| OR K+2
     C21E 0040     
27889 C220 024D  22        andi ra,>7f*256                 ; AND #%01111111
     C222 7F00     
27890 C224 F360  30        socb @K+2,ra                    ; ORA K+2
     C226 003F     
27891               
27892 C228 16A8  14        jne  PL21                       ; BNE PL21          ; If A is non-zero then the two high bytes of K(3 2 1 0)
27893                                                                          ; are non-zero, so jump to PL21 to set the C flag and
27894                                                                          ; return from the subroutine
27895               
27896                                                                          ; We can now just consider K(1 0), as we know the top
27897                                                                          ; two bytes of K(3 2 1 0) are both 0
27898               
27899 C22A D3A0  30        movb @K+1,rx                    ; LDX K+1           ; Set X = K+1, so now (X K) contains the result in
     C22C 003E     
27900                                                                          ; K(1 0), which is the format we want to return the
27901                                                                          ; result in
27902               
27903 C22E 028E  22        ci   rx,>04*256                 ; CPX #4            ; If the high byte of K(1 0) >= 4 then the result is
     C230 0400     
27904 C232 1818  14        joc  PL6                        ; BCS PL6           ; >= 1024, so return from the subroutine with the C flag
27905                                                                          ; set to indicate an overflow (as PL6 contains an RTS)
27906               
27907 C234 D360  30        movb @K+3,ra                    ; LDA K+3           ; Fetch the sign of the result from K+3 (which we know
     C236 0040     
27908                                                                          ; has zeroes in bits 0-6, so this just fetches the sign)
27909               
27910               * CLC                    \ This instruction is commented out in the original
27911                                                                          ; source. It would have no effect as we know the C flag
27912                                                                          ; is already clear, as we skipped past the BCS above
27913               
27914 C238 1515  14        jgt  PL6                        ; BPL PL6           ; If the sign bit is clear and the result is positive,
27915                                                                          ; then the result is already correct, so return from
27916                                                                          ; the subroutine with the C flag clear to indicate
27917                                                                          ; success (as PL6 contains an RTS)
27918               
27919 C23A D360  30        movb @K,ra                      ; LDA K             ; Otherwise we need to negate the result, which we do
     C23C 003D     
27920                      .eoi (>ff*256)                  ; EOR #%11111111    ; using two's complement, starting with the low byte:
     **** ****     > EOI
0001 C23E 0200  20        li   rtmp,(>FF*256)
     C240 FF00     
0002 C242 2B40  18        xor  rtmp,ra
                   < elite.a99
27921                      .adi (>01*256)                  ; ADC #1            ;
     **** ****     > ADI
0001 C244 1701  14        jnc  !
0002 C246 B347  18        ab   rone,ra
0003               !:
0004 C248 022D  22        ai   ra,(>01*256)
     C24A 0100     
                   < elite.a99
27922 C24C D80D  30        movb ra,@K                      ; STA K             ; K = ~K + 1
     C24E 003D     
27923               
27924 C250 D34E  18        movb rx,ra                      ; TXA               ; And then the high byte:
27925                      .eoi (>ff*256)                  ; EOR #%11111111    ;
     **** ****     > EOI
0001 C252 0200  20        li   rtmp,(>FF*256)
     C254 FF00     
0002 C256 2B40  18        xor  rtmp,ra
                   < elite.a99
27926                      .adi (>00*256)                  ; ADC #0            ; X = ~X
     **** ****     > ADI
0001 C258 1701  14        jnc  !
0002 C25A B347  18        ab   rone,ra
0003               !:
0004 C25C 022D  22        ai   ra,(>00*256)
     C25E 0000     
                   < elite.a99
27927 C260 D38D  18        movb ra,rx                      ; TAX
27928               
27929               PL44:
27930                      .clc                            ; CLC               ; Clear the C flag to indicate success
     **** ****     > CLC
0001 C262 0A16  18        sla  rzero,1
                   < elite.a99
27931               
27932               PL6:
27933 C264 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C266 FE34     
27934               
27935               * ******************************************************************************
27936               *
27937               * Name: TT17
27938               * Type: Subroutine
27939               * Category: Keyboard
27940               * Summary: Scan the keyboard for cursor key or joystick movement
27941               *
27942               * ------------------------------------------------------------------------------
27943               *
27944               * Scan the keyboard and joystick for cursor key or stick movement, and return
27945               * the result as deltas (changes) in x- and y-coordinates as follows:
27946               *
27947               * * For joystick, X and Y are integers between -2 and +2 depending on how far
27948               * the stick has moved
27949               *
27950               * * For keyboard, X and Y are integers between -1 and +1 depending on which
27951               * keys are pressed
27952               *
27953               * ------------------------------------------------------------------------------
27954               *
27955               * Returns:
27956               *
27957               * A                   The key pressed, if the arrow keys were used
27958               *
27959               * X                   Change in the x-coordinate according to the cursor keys
27960               * being pressed or joystick movement, as an integer (see
27961               * above)
27962               *
27963               * Y                   Change in the y-coordinate according to the cursor keys
27964               * being pressed or joystick movement, as an integer (see
27965               * above)
27966               *
27967               * ******************************************************************************
27968               
27969               TT17:
27970 C268 0200  20        li   rtmp,DOKEY                 ; JSR DOKEY         ; Scan the keyboard for flight controls and pause keys,
     C26A D4B6     
27971 C26C 06A0  32        bl   @jsr                       ;
     C26E FE28     
27972                                                                          ; (or the equivalent on joystick) and update the key
27973                                                                          ; logger, setting KL to the key pressed
27974               
27975 C270 D360  30        movb @JSTK,ra                   ; LDA JSTK          ; If the joystick is not configured, jump down to TJ1,
     C272 0F50     
27976 C274 132D  14        jeq  TJ1                        ; BEQ TJ1           ; otherwise we move the cursor with the joystick
27977               
27978 C276 D360  30        movb @JSTX,ra                   ; LDA JSTX          ; Fetch the joystick roll, ranging from 1 to 255 with
     C278 009C     
27979                                                                          ; 128 as the centre point
27980               
27981                      .eoi (>ff*256)                  ; EOR #&FF          ; Flip the sign so A = -JSTX, because the joystick roll
     **** ****     > EOI
0001 C27A 0200  20        li   rtmp,(>FF*256)
     C27C FF00     
0002 C27E 2B40  18        xor  rtmp,ra
                   < elite.a99
27982                                                                          ; works in the opposite way to moving a cursor on-screen
27983                                                                          ; in terms of left and right
27984               
27985 C280 0200  20        li   rtmp,TJS1                  ; JSR TJS1          ; Call TJS1 just below to set A to a value between -2
     C282 C290     
27986 C284 06A0  32        bl   @jsr                       ;
     C286 FE28     
27987                                                                          ; and +2 depending on the joystick roll value (moving
27988                                                                          ; the stick sideways)
27989               
27990 C288 D34F  18        movb ry,ra                      ; TYA               ; Copy Y to A
27991               
27992 C28A D38D  18        movb ra,rx                      ; TAX               ; Copy A to X, so X contains the joystick roll value
27993               
27994 C28C D360  30        movb @JSTY,ra                   ; LDA JSTY          ; Fetch the joystick pitch, ranging from 1 to 255 with
     C28E 009D     
27995                                                                          ; 128 as the centre point, and fall through into TJS1 to
27996                                                                          ; set Y to the joystick pitch value (moving the stick up
27997                                                                          ; and down)
27998               
27999               TJS1:
28000 C290 D3CD  18        movb ra,ry                      ; TAY               ; Store A in Y
28001               
28002 C292 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the result, A = 0
     C294 0000     
28003               
28004 C296 028F  22        ci   ry,>10*256                 ; CPY #16           ; If Y >= 16 set the C flag, so A = A - 1
     C298 1000     
28005                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 C29A 1801  14        joc  !
0002 C29C 7347  18        sb   rone,ra
0003               !:
0004 C29E 022D  22        ai   ra,-(>00*256)
     C2A0 0000     
                   < elite.a99
28006               
28007               * CPY #&20               \ These instructions are commented out in the original
28008               * SBC #0                 \ source, but they would make the joystick move the
28009                                                                          ; cursor faster by increasing the range of Y by -1 to +1
28010               
28011 C2A2 028F  22        ci   ry,>40*256                 ; CPY #64           ; If Y >= 64 set the C flag, so A = A - 1
     C2A4 4000     
28012                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 C2A6 1801  14        joc  !
0002 C2A8 7347  18        sb   rone,ra
0003               !:
0004 C2AA 022D  22        ai   ra,-(>00*256)
     C2AC 0000     
                   < elite.a99
28013               
28014 C2AE 028F  22        ci   ry,>c0*256                 ; CPY #192          ; If Y >= 192 set the C flag, so A = A + 1
     C2B0 C000     
28015                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 C2B2 1701  14        jnc  !
0002 C2B4 B347  18        ab   rone,ra
0003               !:
0004 C2B6 022D  22        ai   ra,(>00*256)
     C2B8 0000     
                   < elite.a99
28016               
28017 C2BA 028F  22        ci   ry,>e0*256                 ; CPY #224          ; If Y >= 224 set the C flag, so A = A + 1
     C2BC E000     
28018                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 C2BE 1701  14        jnc  !
0002 C2C0 B347  18        ab   rone,ra
0003               !:
0004 C2C2 022D  22        ai   ra,(>00*256)
     C2C4 0000     
                   < elite.a99
28019               
28020               * CPY #&F0               \ These instructions are commented out in the original
28021               * ADC #0                 \ source, but they would make the joystick move the
28022                                                                          ; cursor faster by increasing the range of Y by -1 to +1
28023               
28024 C2C6 D3CD  18        movb ra,ry                      ; TAY               ; Copy the value of A into Y
28025               
28026 C2C8 D360  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     C2CA 0041     
28027               
28028 C2CC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C2CE FE34     
28029               
28030               TJ1:
28031 C2D0 D360  30        movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)
     C2D2 0041     
28032               
28033 C2D4 020E  20        li   rx,>00*256                 ; LDX #0            ; Set the initial values for the results, X = Y = 0,
     C2D6 0000     
28034 C2D8 020F  20        li   ry,>00*256                 ; LDY #0            ; which we now increase or decrease appropriately
     C2DA 0000     
28035               
28036 C2DC 028D  22        ci   ra,>19*256                 ; CMP #&19          ; If left arrow was pressed, set X = X - 1
     C2DE 1900     
28037 C2E0 1601  14        jne  B82                        ; BNE B82
28038 C2E2 7387  18        sb   rone,rx                    ; DEX
28039               
28040               B82:
28041 C2E4 028D  22        ci   ra,>79*256                 ; CMP #&79          ; If right arrow was pressed, set X = X + 1
     C2E6 7900     
28042 C2E8 1601  14        jne  B83                        ; BNE B83
28043 C2EA B387  18        ab   rone,rx                    ; INX
28044               
28045               B83:
28046 C2EC 028D  22        ci   ra,>39*256                 ; CMP #&39          ; If up arrow was pressed, set Y = Y + 1
     C2EE 3900     
28047 C2F0 1601  14        jne  B84                        ; BNE B84
28048 C2F2 B3C7  18        ab   rone,ry                    ; INY
28049               
28050               B84:
28051 C2F4 028D  22        ci   ra,>29*256                 ; CMP #&29          ; If down arrow was pressed, set Y = Y - 1
     C2F6 2900     
28052 C2F8 1601  14        jne  B85                        ; BNE B85
28053 C2FA 73C7  18        sb   rone,ry                    ; DEY
28054               
28055               B85:
28056 C2FC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C2FE FE34     
28057               
28058               * ******************************************************************************
28059               *
28060               * Name: ping
28061               * Type: Subroutine
28062               * Category: Universe
28063               * Summary: Set the selected system to the current system
28064               *
28065               * ******************************************************************************
28066               
28067               ping_:
28068 C300 020E  20        li   rx,>01*256                 ; LDX #1            ; We want to copy the X- and Y-coordinates of the
     C302 0100     
28069                                                                          ; current system in (QQ0, QQ1) to the selected system's
28070                                                                          ; coordinates in (QQ9, QQ10), so set up a counter to
28071                                                                          ; copy two bytes
28072               
28073               pl1_:
28074 C304 06CE  14        swpb rx                         ;
28075 C306 D36E  34        movb @QQ0(rx),ra                ; LDA QQ0,X         ; Load byte X from the current system in QQ0/QQ1
     C308 0301     
28076 C30A 06CE  14        swpb rx                         ;
28077               
28078 C30C 06CE  14        swpb rx                         ;
28079 C30E DB8D  38        movb ra,@QQ9(rx)                ; STA QQ9,X         ; Store byte X in the selected system in QQ9/QQ10
     C310 0F31     
28080 C312 06CE  14        swpb rx                         ;
28081               
28082 C314 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28083               
28084 C316 15F6  14        jgt  pl1_                       ; BPL pl1           ; Loop back for the next byte to copy
28085               
28086 C318 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C31A FE34     
28087               
28088               * ******************************************************************************
28089               *
28090               * Save ELTE.bin
28091               *
28092               * ******************************************************************************
28093               
28094                      ; PRINT "ELITE E"
28095                      ; PRINT "Assembled at ", ~CODE_E%
28096                      ; PRINT "Ends at ", ~P%
28097                      ; PRINT "Code size is ", ~(P% - CODE_E%)
28098                      ; PRINT "Execute at ", ~LOAD%
28099                      ; PRINT "Reload at ", ~LOAD_E%
28100               
28101                      ; PRINT "S.ELTE ", ~CODE_E%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_E%
28102                      ; SAVE "3-assembled-output/ELTE.bin", CODE_E%, P%, LOAD%
28103               
28104               * ******************************************************************************
28105               *
28106               * ELITE F FILE
28107               *
28108               * Produces the binary file ELTF.bin that gets loaded by elite-bcfs.asm.
28109               *
28110               * ******************************************************************************
28111               
28112               CODE_F.:
28113                      equ $
28114               
28115               LOAD_F.:
28116                      equ LOAD. + $ - CODE.
28117               
28118               * ******************************************************************************
28119               *
28120               * Name: KS3
28121               * Type: Subroutine
28122               * Category: Universe
28123               * Summary: Set the SLSP ship line heap pointer after shuffling ship slots
28124               *
28125               * ------------------------------------------------------------------------------
28126               *
28127               * The final part of the KILLSHP routine, called after we have shuffled the ship
28128               * slots and sorted out our missiles. This simply sets SLSP to the new bottom of
28129               * the ship line heap.
28130               *
28131               * ------------------------------------------------------------------------------
28132               *
28133               * Arguments:
28134               *
28135               * P(1 0)              Points to the ship line heap of the ship in the last
28136               * occupied slot (i.e. it points to the bottom of the
28137               * descending heap)
28138               *
28139               * ******************************************************************************
28140               
28141               KS3:
28142 C31C D360  30        movb @P,ra                      ; LDA P             ; After shuffling the ship slots, P(1 0) will point to
     C31E 001B     
28143 C320 D80D  30        movb ra,@SLSP                   ; STA SLSP          ; the new bottom of the ship line heap, so store this in
     C322 0F1E     
28144 C324 D360  30        movb @P+1,ra                    ; LDA P+1           ; SLSP(1 0), which stores the bottom of the heap
     C326 001C     
28145 C328 D80D  30        movb ra,@SLSP+1                 ; STA SLSP+1
     C32A 0F1F     
28146               
28147 C32C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C32E FE34     
28148               
28149               * ******************************************************************************
28150               *
28151               * Name: KS1
28152               * Type: Subroutine
28153               * Category: Universe
28154               * Summary: Remove the current ship from our local bubble of universe
28155               *
28156               * ------------------------------------------------------------------------------
28157               *
28158               * Part 12 of the main flight loop calls this routine to remove the ship that is
28159               * currently being analysed by the flight loop. Once the ship is removed, it
28160               * jumps back to MAL1 to rejoin the main flight loop, with X pointing to the
28161               * same slot that we just cleared (and which now contains the next ship in the
28162               * local bubble of universe).
28163               *
28164               * ------------------------------------------------------------------------------
28165               *
28166               * Arguments:
28167               *
28168               * XX0                 The address of the blueprint for this ship
28169               *
28170               * INF                 The address of the data block for this ship
28171               *
28172               * ******************************************************************************
28173               
28174               KS1:
28175 C330 D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Store the current ship's slot number in XSAV
     C332 0093     
28176               
28177 C334 0200  20        li   rtmp,KILLSHP               ; JSR KILLSHP       ; Call KILLSHP to remove the ship in slot X from our
     C336 C410     
28178 C338 06A0  32        bl   @jsr                       ;
     C33A FE28     
28179                                                                          ; local bubble of universe
28180               
28181 C33C D3A0  30        movb @XSAV,rx                   ; LDX XSAV          ; Restore the current ship's slot number from XSAV,
     C33E 0093     
28182                                                                          ; which now points to the next ship in the bubble
28183               
28184 C340 0460  24        b    @MAL1                      ; JMP MAL1          ; Jump to MAL1 to rejoin the main flight loop at the
     C342 1190     
28185                                                                          ; start of the ship analysis loop
28186               
28187               * ******************************************************************************
28188               *
28189               * Name: KS4
28190               * Type: Subroutine
28191               * Category: Universe
28192               * Summary: Remove the space station and replace it with the sun
28193               *
28194               * ******************************************************************************
28195               
28196               KS4:
28197 C344 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     C346 C710     
28198 C348 06A0  32        bl   @jsr                       ;
     C34A FE28     
28199               
28200 C34C 0200  20        li   rtmp,FLFLLS                ; JSR FLFLLS        ; Reset the LSO block, returns with A = 0
     C34E B2C6     
28201 C350 06A0  32        bl   @jsr                       ;
     C352 FE28     
28202               
28203 C354 D80D  30        movb ra,@FRIN+1                 ; STA FRIN+1        ; Set the second slot in the FRIN table to 0, which
     C356 0D41     
28204                                                                          ; sets this slot to empty, so when we call NWSHP below
28205                                                                          ; the new sun that gets created will go into FRIN+1
28206               
28207 C358 D80D  30        movb ra,@SSPR                   ; STA SSPR          ; Set the "space station present" flag to 0, as we are
     C35A 0D55     
28208                                                                          ; no longer in the space station's safe zone
28209               
28210 C35C 0200  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Call SPBLB to redraw the space station bulb, which
     C35E B76E     
28211 C360 06A0  32        bl   @jsr                       ;
     C362 FE28     
28212                                                                          ; will erase it from the dashboard
28213               
28214 C364 020D  20        li   ra,>06*256                 ; LDA #6            ; Set the sun's y_sign to 6
     C366 0600     
28215 C368 D80D  30        movb ra,@INWK+5                 ; STA INWK+5
     C36A 0058     
28216               
28217 C36C 020D  20        li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun
     C36E 8100     
28218               
28219 C370 0460  28        b    @NWSHP                     ; JMP NWSHP         ; Call NWSHP to set up the sun's data block and add it
     C372 B5DA     
28220                                                                          ; to FRIN, where it will get put in the second slot as
28221                                                                          ; we just cleared out the second slot, and the first
28222                                                                          ; slot is already taken by the planet
28223               
28224               * ******************************************************************************
28225               *
28226               * Name: KS2
28227               * Type: Subroutine
28228               * Category: Universe
28229               * Summary: Check the local bubble for missiles with target lock
28230               *
28231               * ------------------------------------------------------------------------------
28232               *
28233               * Check the local bubble of universe to see if there are any missiles with
28234               * target lock in the vicinity. If there are, then check their targets; if we
28235               * just removed their target in the KILLSHP routine, then switch off their AI so
28236               * they just drift in space, otherwise update their targets to reflect the newly
28237               * shuffled slot numbers.
28238               *
28239               * This is called from KILLSHP once the slots have been shuffled down, following
28240               * the removal of a ship.
28241               *
28242               * ------------------------------------------------------------------------------
28243               *
28244               * Arguments:
28245               *
28246               * XX4                 The slot number of the ship we removed just before
28247               * calling this routine
28248               *
28249               * ******************************************************************************
28250               
28251               KS2:
28252 C374 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; We want to go through the ships in our local bubble
     C376 FF00     
28253                                                                          ; and pick out all the missiles, so set X to &FF to
28254                                                                          ; use as a counter
28255               
28256               KSL4:
28257 C378 B387  18        ab   rone,rx                    ; INX               ; Increment the counter (so it starts at 0 on the first
28258                                                                          ; iteration)
28259               
28260 C37A 06CE  14        swpb rx                         ;
28261 C37C D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; If slot X is empty then we have worked our way through
     C37E 0D40     
28262 C380 06CE  14        swpb rx                         ;
28263 C382 13CC  14        jeq  KS3                        ; BEQ KS3           ; all the slots, so jump to KS3 to stop looking
28264               
28265 C384 028D  22        ci   ra,(MSL)*256               ; CMP #MSL          ; If the slot does not contain a missile, loop back to
     C386 0900     
28266 C388 16F7  14        jne  KSL4                       ; BNE KSL4          ; KSL4 to check the next slot
28267               
28268                                                                          ; We have found a slot containing a missile, so now we
28269                                                                          ; want to check whether it has target lock
28270               
28271 C38A D34E  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 and fetch the Y-th address from UNIV
28272                      .asla                           ; ASL A             ; and store it in SC and SC+1 - in other words, set
     **** ****     > ASLA
0001 C38C 024D  22        andi ra,>ff00
     C38E FF00     
0002 C390 0A1D  18        sla  ra,1
                   < elite.a99
28273 C392 D3CD  18        movb ra,ry                      ; TAY               ; SC(1 0) to point to the missile's ship data block
28274 C394 06CF  14        swpb ry                         ;
28275 C396 D36F  34        movb @UNIV(ry),ra               ; LDA UNIV,Y
     C398 238F     
28276 C39A 06CF  14        swpb ry                         ;
28277 C39C D80D  30        movb ra,@SC                     ; STA SC
     C39E 0007     
28278 C3A0 06CF  14        swpb ry                         ;
28279 C3A2 D36F  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     C3A4 2390     
28280 C3A6 06CF  14        swpb ry                         ;
28281 C3A8 D80D  30        movb ra,@SC+1                   ; STA SC+1
     C3AA 0008     
28282               
28283 C3AC 020F  20        li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 from the missile's ship data (AI)
     C3AE 2000     
28284                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y
     **** ****     > LD_IND_Y_IDX
0001 C3B0 D820  42        movb @SC,@rtmplb
     C3B2 0007     
     C3B4 8301     
0002 C3B6 D020  30        movb @SC+1,rtmp
     C3B8 0008     
0003 C3BA 06CF  14        swpb ry
0004 C3BC A00F  18        a    ry,rtmp
0005 C3BE 06CF  14        swpb ry
0006 C3C0 D350  26        movb *rtmp,RA
                   < elite.a99
28285               
28286 C3C2 15DA  14        jgt  KSL4                       ; BPL KSL4          ; If bit 7 of byte #32 is clear, then the missile is
28287                                                                          ; dumb and has no AI, so loop back to KSL4 to move on
28288                                                                          ; to the next slot
28289               
28290 C3C4 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Otherwise this missile has AI, so clear bit 7 and
     C3C6 7F00     
28291 C3C8 091D  18        srl  ra,1                       ; LSR A             ; shift right to set the C flag to the missile's "is
28292                                                                          ; locked" flag, and A to the target's slot number
28293               
28294 C3CA 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If this missile's target is less than XX4, then the
     C3CC 00A7     
28295 C3CE 17D4  14        jnc  KSL4                       ; BCC KSL4          ; target's slot isn't being shuffled down, so jump to
28296                                                                          ; KSL4 to move on to the next slot
28297               
28298 C3D0 1313  14        jeq  KS6                        ; BEQ KS6           ; If this missile was locked onto the ship that we just
28299                                                                          ; removed in KILLSHP, jump to KS6 to stop the missile
28300                                                                          ; from continuing to hunt it down
28301               
28302                      .sbi (>01*256)                  ; SBC #1            ; Otherwise this missile is locked and has AI enabled,
     **** ****     > SBI
0001 C3D2 1801  14        joc  !
0002 C3D4 7347  18        sb   rone,ra
0003               !:
0004 C3D6 022D  22        ai   ra,-(>01*256)
     C3D8 FF00     
                   < elite.a99
28303                                                                          ; and its target will have moved down a slot, so
28304                                                                          ; subtract 1 from the target number (we know C is set
28305                                                                          ; from the BCC above)
28306               
28307                      .asla                           ; ASL A             ; Shift the target number left by 1, so it's in bits
     **** ****     > ASLA
0001 C3DA 024D  22        andi ra,>ff00
     C3DC FF00     
0002 C3DE 0A1D  18        sla  ra,1
                   < elite.a99
28308                                                                          ; 1-6 once again, and also set bit 0 to 1, as the C
28309                                                                          ; flag is still set, so this makes sure the missile is
28310                                                                          ; still set to being locked
28311               
28312 C3E0 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7, so the missile's AI is enabled
     C3E2 8000     
28313               
28314                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Update the missile's AI flag to the value in A
     **** ****     > ST_IND_Y_IDX
0001 C3E4 D820  42        movb @SC,@rtmplb
     C3E6 0007     
     C3E8 8301     
0002 C3EA D020  30        movb @SC+1,rtmp
     C3EC 0008     
0003 C3EE 06CF  14        swpb ry
0004 C3F0 A00F  18        a    ry,rtmp
0005 C3F2 06CF  14        swpb ry
0006 C3F4 D40D  30        movb RA,*rtmp
                   < elite.a99
28315               
28316 C3F6 16C0  14        jne  KSL4                       ; BNE KSL4          ; Loop back to KSL4 to move on to the next slot (this
28317                                                                          ; BNE is effectively a JMP as A will never be zero)
28318               
28319               KS6:
28320 C3F8 020D  20        li   ra,>00*256                 ; LDA #0            ; The missile's target lock just got removed, so set the
     C3FA 0000     
28321                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; AI flag to 0 to make it dumb and not locked
     **** ****     > ST_IND_Y_IDX
0001 C3FC D820  42        movb @SC,@rtmplb
     C3FE 0007     
     C400 8301     
0002 C402 D020  30        movb @SC+1,rtmp
     C404 0008     
0003 C406 06CF  14        swpb ry
0004 C408 A00F  18        a    ry,rtmp
0005 C40A 06CF  14        swpb ry
0006 C40C D40D  30        movb RA,*rtmp
                   < elite.a99
28322               
28323 C40E 13B4  14        jeq  KSL4                       ; BEQ KSL4          ; Loop back to KSL4 to move on to the next slot (this
28324                                                                          ; BEQ is effectively a JMP as A is always zero)
28325               
28326               * ******************************************************************************
28327               *
28328               * Name: KILLSHP
28329               * Type: Subroutine
28330               * Category: Universe
28331               * Summary: Remove a ship from our local bubble of universe
28332               *
28333               * ------------------------------------------------------------------------------
28334               *
28335               * Remove the ship in slot X from our local bubble of universe. This happens
28336               * when we kill a ship, collide with a ship and destroy it, or when a ship moves
28337               * outside our local bubble.
28338               *
28339               * We also use this routine when we move out of range of the space station, in
28340               * which case we replace it with the sun.
28341               *
28342               * When removing a ship, this creates a gap in the ship slots at FRIN, so we
28343               * shuffle all the later slots down to close the gap. We also shuffle the ship
28344               * data blocks at K% and ship line heap at WP, to reclaim all the memory that
28345               * the removed ship used to occupy.
28346               *
28347               * ------------------------------------------------------------------------------
28348               *
28349               * Arguments:
28350               *
28351               * X                   The slot number of the ship to remove
28352               *
28353               * XX0                 The address of the blueprint for the ship to remove
28354               *
28355               * INF                 The address of the data block for the ship to remove
28356               *
28357               * ******************************************************************************
28358               
28359               KILLSHP:
28360 C410 D80E  30        movb rx,@XX4                    ; STX XX4           ; Store the slot number of the ship to remove in XX4
     C412 00A7     
28361               
28368               
28369 C414 93A0  30        cb   @MSTG,rx                   ; CPX MSTG          ; Check whether this slot matches the slot number in
     C416 0052     
28370                                                                          ; MSTG, which is the target of our missile lock
28371                                                                          ;
28372                                                                          ; This instructions saves two bytes of memory over the
28373                                                                          ; LDA and CMP-based code in the source disc version, as
28374                                                                          ; CPX MSTG is a two-byte opcode, while LDA MSTG and
28375                                                                          ; CMP XX4 take up four bytes between them (the code does
28376                                                                          ; the same thing)
28377               
28379               
28380 C418 160C  14        jne  KS5                        ; BNE KS5           ; If our missile is not locked on this ship, jump to KS5
28381               
28382 C41A 020F  20        li   ry,>ee*256                 ; LDY #&EE          ; Otherwise we need to remove our missile lock, so call
     C41C EE00     
28383 C41E 0200  20        li   rtmp,ABORT                 ; JSR ABORT         ; ABORT to disarm the missile and update the missile
     C420 B72E     
28384 C422 06A0  32        bl   @jsr                       ;
     C424 FE28     
28385                                                                          ; indicators on the dashboard to green/cyan (Y = &EE)
28386               
28387 C426 020D  20        li   ra,>c8*256                 ; LDA #200          ; Print recursive token 40 ("TARGET LOST") as an
     C428 C800     
28388 C42A 0200  20        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     C42C D616     
28389 C42E 06A0  32        bl   @jsr                       ;
     C430 FE28     
28390               
28391               KS5:
28392 C432 D3E0  30        movb @XX4,ry                    ; LDY XX4           ; Restore the slot number of the ship to remove into Y
     C434 00A7     
28393               
28394 C436 06CF  14        swpb ry                         ;
28395 C438 D3AF  34        movb @FRIN(ry),rx               ; LDX FRIN,Y        ; Fetch the contents of the slot, which contains the
     C43A 0D40     
28396 C43C 06CF  14        swpb ry                         ;
28397                                                                          ; ship type
28398               
28399 C43E 028E  22        ci   rx,(SST)*256               ; CPX #SST          ; If this is the space station, then jump to KS4 to
     C440 0800     
28400 C442 1380  14        jeq  KS4                        ; BEQ KS4           ; replace the space station with the sun
28401               
28402 C444 7347  18        sb   rone,ra                    ; DEC MANY,X        ; Decrease the number of this type of ship in our little
28403                                                                          ; bubble, which is stored in MANY+X (where X is the ship
28404                                                                          ; type)
28405               
28406 C446 D3A0  30        movb @XX4,rx                    ; LDX XX4           ; Restore the slot number of the ship to remove into X
     C448 00A7     
28407               
28408                                                                          ; We now want to remove this ship and reclaim all the
28409                                                                          ; memory that it uses. Removing the ship will leave a
28410                                                                          ; gap in three places, which we need to close up:
28411                                                                          ;
28412                                                                          ; * The ship slots in FRIN
28413                                                                          ;
28414                                                                          ; * The ship data blocks in K%
28415                                                                          ;
28416                                                                          ; * The descending ship line heap at WP down
28417                                                                          ;
28418                                                                          ; The rest of this routine closes up these gaps by
28419                                                                          ; looping through all the occupied ship slots after the
28420                                                                          ; slot we are removing, one by one, and shuffling each
28421                                                                          ; ship's slot, data block and line heap down to close
28422                                                                          ; up the gaps left by the removed ship. As part of this,
28423                                                                          ; we have to make sure we update any address pointers
28424                                                                          ; so they point to the newly shuffled data blocks and
28425                                                                          ; line heaps
28426                                                                          ;
28427                                                                          ; In the following, when shuffling a ship's data down
28428                                                                          ; into the preceding empty slot, we call the ship that
28429                                                                          ; we are shuffling down the "source", and we call the
28430                                                                          ; empty slot we are shuffling it into the "destination"
28431                                                                          ;
28432                                                                          ; Before we start looping through the ships we need to
28433                                                                          ; shuffle down, we need to set up some variables to
28434                                                                          ; point to the source and destination line heaps
28435               
28436 C44A 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the removed ship's blueprint into A,
     C44C 0500     
28437                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; which gives the ship's maximum heap size for the ship
     **** ****     > LD_IND_Y_IDX
0001 C44E D820  42        movb @XX0,@rtmplb
     C450 001E     
     C452 8301     
0002 C454 D020  30        movb @XX0+1,rtmp
     C456 001F     
0003 C458 06CF  14        swpb ry
0004 C45A A00F  18        a    ry,rtmp
0005 C45C 06CF  14        swpb ry
0006 C45E D350  26        movb *rtmp,RA
                   < elite.a99
28438                                                                          ; we are removing (i.e. the size of the gap in the heap
28439                                                                          ; created by the ship removal)
28440               
28441                                                                          ; INF currently contains the ship data for the ship we
28442                                                                          ; are removing, and INF(34 33) contains the address of
28443                                                                          ; the bottom of the ship's heap, so we can calculate
28444                                                                          ; the address of the top of the heap by adding the heap
28445                                                                          ; size to this address
28446               
28447 C460 020F  20        li   ry,>21*256                 ; LDY #33           ; First we add A and the address in INF+33, to get the
     C462 2100     
28448                      .clc                            ; CLC               ; low byte of the top of the heap, which we store in P
     **** ****     > CLC
0001 C464 0A16  18        sla  rzero,1
                   < elite.a99
28449                      .adc_ind_y_idx @INF,ra          ; ADC (INF),Y
     **** ****     > ADC_IND_Y_IDX
0001 C466 04CD  14        clr  ra
0002 C468 1701  14        jnc  !
0003 C46A B347  18        ab   rone,ra
0004               !:
0005 C46C D820  42        movb @INF,@rtmplb
     C46E 0020     
     C470 8301     
0006 C472 D020  30        movb @INF+1,rtmp
     C474 0021     
0007 C476 06CF  14        swpb ry
0008 C478 A00F  18        a    ry,rtmp
0009 C47A 06CF  14        swpb ry
0010 C47C B350  26        ab   *rtmp,ra
                   < elite.a99
28450 C47E D80D  30        movb ra,@P                      ; STA P
     C480 001B     
28451               
28452 C482 B3C7  18        ab   rone,ry                    ; INY               ; And next we add A and the address in INF+34, with any
28453                      .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; carry from the previous addition, to get the high byte
     **** ****     > LD_IND_Y_IDX
0001 C484 D820  42        movb @INF,@rtmplb
     C486 0020     
     C488 8301     
0002 C48A D020  30        movb @INF+1,rtmp
     C48C 0021     
0003 C48E 06CF  14        swpb ry
0004 C490 A00F  18        a    ry,rtmp
0005 C492 06CF  14        swpb ry
0006 C494 D350  26        movb *rtmp,RA
                   < elite.a99
28454                      .adi (>00*256)                  ; ADC #0            ; of the top of the heap, which we store in P+1, so
     **** ****     > ADI
0001 C496 1701  14        jnc  !
0002 C498 B347  18        ab   rone,ra
0003               !:
0004 C49A 022D  22        ai   ra,(>00*256)
     C49C 0000     
                   < elite.a99
28455 C49E D80D  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) points to the top of this ship's heap
     C4A0 001C     
28456               
28457                                                                          ; Now, we're ready to start looping through the ships
28458                                                                          ; we want to move, moving the slots, data blocks and
28459                                                                          ; line heap from the source to the destination. In the
28460                                                                          ; following, we set up SC to point to the source data,
28461                                                                          ; and INF (which currently points to the removed ship's
28462                                                                          ; data that we can now overwrite) points to the
28463                                                                          ; destination
28464                                                                          ;
28465                                                                          ; So P(1 0) now points to the top of the line heap for
28466                                                                          ; the destination
28467               
28468               KSL1:
28469 C4A2 B387  18        ab   rone,rx                    ; INX               ; On entry, X points to the empty slot we want to
28470                                                                          ; shuffle the next ship into (the destination), so
28471                                                                          ; this increment points X to the next slot - i.e. the
28472                                                                          ; source slot we want to shuffle down
28473               
28474 C4A4 06CE  14        swpb rx                         ;
28475 C4A6 D36E  34        movb @FRIN(rx),ra               ; LDA FRIN,X        ; Copy the contents of the source slot into the
     C4A8 0D40     
28476 C4AA 06CE  14        swpb rx                         ;
28477 C4AC 06CE  14        swpb rx                         ;
28478 C4AE DB8D  38        movb ra,@FRIN-1(rx)             ; STA FRIN-1,X      ; destination slot
     C4B0 0D3F     
28479 C4B2 06CE  14        swpb rx                         ;
28480               
28481 C4B4 1602  14        jne  FIX009                     ; BNE FIX009        ; If the slot we just shuffled down contains 0, then
28482 C4B6 0460  28        b    @KS2                       ; JMP KS2           ; the source slot is empty and we are done shuffling,
     C4B8 C374     
28483                                                                          ; so jump to KS2 to move on to processing missiles
28484               FIX009:
28485                      .asla                           ; ASL A             ; Otherwise we have a source ship to shuffle down into
     **** ****     > ASLA
0001 C4BA 024D  22        andi ra,>ff00
     C4BC FF00     
0002 C4BE 0A1D  18        sla  ra,1
                   < elite.a99
28486 C4C0 D3CD  18        movb ra,ry                      ; TAY               ; the destination, so set Y = A * 2 so it can act as an
28487                                                                          ; index into the two-byte ship blueprint lookup table
28488                                                                          ; at XX21 for the source ship
28489               
28490 C4C2 06CF  14        swpb ry                         ;
28491 C4C4 D36F  34        movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; Set SC(0 1) to point to the blueprint data for the
     C4C6 F14C     
28492 C4C8 06CF  14        swpb ry                         ;
28493 C4CA D80D  30        movb ra,@SC                     ; STA SC            ; source ship
     C4CC 0007     
28494 C4CE 06CF  14        swpb ry                         ;
28495 C4D0 D36F  34        movb @XX21-1(ry),ra             ; LDA XX21-1,Y
     C4D2 F14D     
28496 C4D4 06CF  14        swpb ry                         ;
28497 C4D6 D80D  30        movb ra,@SC+1                   ; STA SC+1
     C4D8 0008     
28498               
28499 C4DA 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch blueprint byte #5 for the source ship, which
     C4DC 0500     
28500                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; gives us its maximum heap size, and store it in T
     **** ****     > LD_IND_Y_IDX
0001 C4DE D820  42        movb @SC,@rtmplb
     C4E0 0007     
     C4E2 8301     
0002 C4E4 D020  30        movb @SC+1,rtmp
     C4E6 0008     
0003 C4E8 06CF  14        swpb ry
0004 C4EA A00F  18        a    ry,rtmp
0005 C4EC 06CF  14        swpb ry
0006 C4EE D350  26        movb *rtmp,RA
                   < elite.a99
28501 C4F0 D80D  30        movb ra,@T                      ; STA T
     C4F2 00D1     
28502               
28503                                                                          ; We now subtract T from P(1 0), so P(1 0) will point to
28504                                                                          ; the bottom of the line heap for the destination
28505                                                                          ; (which we will use later when closing up the gap in
28506                                                                          ; the heap space)
28507               
28508 C4F4 D360  30        movb @P,ra                      ; LDA P             ; First, we subtract the low bytes
     C4F6 001B     
28509                      .sec                            ; SEC
     **** ****     > SEC
0001 C4F8 0A18  18        sla  rmone,1
                   < elite.a99
28510                      .sbc @T,ra                      ; SBC T
     **** ****     > SBC
0001 C4FA 1801  14        joc  !
0002 C4FC 7347  18        sb   rone,ra
0003               !:
0004 C4FE 7360  30        sb   @T,ra
     C500 00D1     
                   < elite.a99
28511 C502 D80D  30        movb ra,@P                      ; STA P
     C504 001B     
28512               
28513 C506 D360  30        movb @P+1,ra                    ; LDA P+1           ; And then we do the high bytes, for which we subtract
     C508 001C     
28514                      .sbi (>00*256)                  ; SBC #0            ; 0 to include any carry, so this is effectively doing
     **** ****     > SBI
0001 C50A 1801  14        joc  !
0002 C50C 7347  18        sb   rone,ra
0003               !:
0004 C50E 022D  22        ai   ra,-(>00*256)
     C510 0000     
                   < elite.a99
28515 C512 D80D  30        movb ra,@P+1                    ; STA P+1           ; P(1 0) = P(1 0) - (0 T)
     C514 001C     
28516               
28517                                                                          ; Next, we want to set SC(1 0) to point to the source
28518                                                                          ; ship's data block
28519               
28520 C516 D34E  18        movb rx,ra                      ; TXA               ; Set Y = X * 2 so it can act as an index into the
28521                      .asla                           ; ASL A             ; two-byte lookup table at UNIV, which contains the
     **** ****     > ASLA
0001 C518 024D  22        andi ra,>ff00
     C51A FF00     
0002 C51C 0A1D  18        sla  ra,1
                   < elite.a99
28522 C51E D3CD  18        movb ra,ry                      ; TAY               ; addresses of the ship data blocks. In this case we are
28523                                                                          ; multiplying X by 2, and X contains the source ship's
28524                                                                          ; slot number so Y is now an index for the source ship's
28525                                                                          ; entry in UNIV
28526               
28527 C520 06CF  14        swpb ry                         ;
28528 C522 D36F  34        movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Set SC(1 0) to the address of the data block for the
     C524 238F     
28529 C526 06CF  14        swpb ry                         ;
28530 C528 D80D  30        movb ra,@SC                     ; STA SC            ; source ship
     C52A 0007     
28531 C52C 06CF  14        swpb ry                         ;
28532 C52E D36F  34        movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y
     C530 2390     
28533 C532 06CF  14        swpb ry                         ;
28534 C534 D80D  30        movb ra,@SC+1                   ; STA SC+1
     C536 0008     
28535               
28536                                                                          ; We have now set up our variables as follows:
28537                                                                          ;
28538                                                                          ; SC(1 0) points to the source's ship data block
28539                                                                          ;
28540                                                                          ; INF(1 0) points to the destination's ship data block
28541                                                                          ;
28542                                                                          ; P(1 0) points to the destination's line heap
28543                                                                          ;
28544                                                                          ; so let's start copying data from the source to the
28545                                                                          ; destination
28546               
28547 C538 020F  20        li   ry,>23*256                 ; LDY #35           ; We are going to be using Y as a counter for the 36
     C53A 2300     
28548                                                                          ; bytes of ship data we want to copy from the source
28549                                                                          ; to the destination, so we set it to 35 to start things
28550                                                                          ; off, and will decrement Y for each byte we copy
28551               
28552                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Fetch byte #35 of the source's ship data block at SC,
     **** ****     > LD_IND_Y_IDX
0001 C53C D820  42        movb @SC,@rtmplb
     C53E 0007     
     C540 8301     
0002 C542 D020  30        movb @SC+1,rtmp
     C544 0008     
0003 C546 06CF  14        swpb ry
0004 C548 A00F  18        a    ry,rtmp
0005 C54A 06CF  14        swpb ry
0006 C54C D350  26        movb *rtmp,RA
                   < elite.a99
28553                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; and store it in byte #35 of the destination's block
     **** ****     > ST_IND_Y_IDX
0001 C54E D820  42        movb @INF,@rtmplb
     C550 0020     
     C552 8301     
0002 C554 D020  30        movb @INF+1,rtmp
     C556 0021     
0003 C558 06CF  14        swpb ry
0004 C55A A00F  18        a    ry,rtmp
0005 C55C 06CF  14        swpb ry
0006 C55E D40D  30        movb RA,*rtmp
                   < elite.a99
28554                                                                          ; at INF, so that's the ship's energy copied from the
28555                                                                          ; source to the destination. One down, quite a few to
28556                                                                          ; go...
28557               
28558 C560 73C7  18        sb   rone,ry                    ; DEY               ; Fetch byte #34 of the source ship, which is the
28559                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; high byte of the source ship's line heap, and store
     **** ****     > LD_IND_Y_IDX
0001 C562 D820  42        movb @SC,@rtmplb
     C564 0007     
     C566 8301     
0002 C568 D020  30        movb @SC+1,rtmp
     C56A 0008     
0003 C56C 06CF  14        swpb ry
0004 C56E A00F  18        a    ry,rtmp
0005 C570 06CF  14        swpb ry
0006 C572 D350  26        movb *rtmp,RA
                   < elite.a99
28560 C574 D80D  30        movb ra,@K+1                    ; STA K+1           ; in K+1
     C576 003E     
28561               
28562 C578 D360  30        movb @P+1,ra                    ; LDA P+1           ; Set the low byte of the destination's heap pointer
     C57A 001C     
28563                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P+1
     **** ****     > ST_IND_Y_IDX
0001 C57C D820  42        movb @INF,@rtmplb
     C57E 0020     
     C580 8301     
0002 C582 D020  30        movb @INF+1,rtmp
     C584 0021     
0003 C586 06CF  14        swpb ry
0004 C588 A00F  18        a    ry,rtmp
0005 C58A 06CF  14        swpb ry
0006 C58C D40D  30        movb RA,*rtmp
                   < elite.a99
28564               
28565 C58E 73C7  18        sb   rone,ry                    ; DEY               ; Fetch byte #33 of the source ship, which is the
28566                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; low byte of the source ship's heap, and store in K
     **** ****     > LD_IND_Y_IDX
0001 C590 D820  42        movb @SC,@rtmplb
     C592 0007     
     C594 8301     
0002 C596 D020  30        movb @SC+1,rtmp
     C598 0008     
0003 C59A 06CF  14        swpb ry
0004 C59C A00F  18        a    ry,rtmp
0005 C59E 06CF  14        swpb ry
0006 C5A0 D350  26        movb *rtmp,RA
                   < elite.a99
28567 C5A2 D80D  30        movb ra,@K                      ; STA K             ; so now we have the following:
     C5A4 003D     
28568                                                                          ;
28569                                                                          ; K(1 0) points to the source's line heap
28570               
28571 C5A6 D360  30        movb @P,ra                      ; LDA P             ; Set the low byte of the destination's heap pointer
     C5A8 001B     
28572                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P, so now the destination's heap pointer is to
     **** ****     > ST_IND_Y_IDX
0001 C5AA D820  42        movb @INF,@rtmplb
     C5AC 0020     
     C5AE 8301     
0002 C5B0 D020  30        movb @INF+1,rtmp
     C5B2 0021     
0003 C5B4 06CF  14        swpb ry
0004 C5B6 A00F  18        a    ry,rtmp
0005 C5B8 06CF  14        swpb ry
0006 C5BA D40D  30        movb RA,*rtmp
                   < elite.a99
28573                                                                          ; P(1 0), so that's the heap pointer in bytes #33 and
28574                                                                          ; #34 done
28575               
28576 C5BC 73C7  18        sb   rone,ry                    ; DEY               ; Luckily, we can just copy the rest of the source's
28577                                                                          ; ship data block into the destination, as there are no
28578                                                                          ; more address pointers, so first we decrement our
28579                                                                          ; counter in Y to point to the next byte (the AI flag)
28580                                                                          ; in byte #32) and then start looping
28581               
28582               KSL2:
28583                      .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Copy the Y-th byte of the source to the Y-th byte of
     **** ****     > LD_IND_Y_IDX
0001 C5BE D820  42        movb @SC,@rtmplb
     C5C0 0007     
     C5C2 8301     
0002 C5C4 D020  30        movb @SC+1,rtmp
     C5C6 0008     
0003 C5C8 06CF  14        swpb ry
0004 C5CA A00F  18        a    ry,rtmp
0005 C5CC 06CF  14        swpb ry
0006 C5CE D350  26        movb *rtmp,RA
                   < elite.a99
28584                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the destination
     **** ****     > ST_IND_Y_IDX
0001 C5D0 D820  42        movb @INF,@rtmplb
     C5D2 0020     
     C5D4 8301     
0002 C5D6 D020  30        movb @INF+1,rtmp
     C5D8 0021     
0003 C5DA 06CF  14        swpb ry
0004 C5DC A00F  18        a    ry,rtmp
0005 C5DE 06CF  14        swpb ry
0006 C5E0 D40D  30        movb RA,*rtmp
                   < elite.a99
28585               
28586 C5E2 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
28587               
28588 C5E4 15EC  14        jgt  KSL2                       ; BPL KSL2          ; Loop back to KSL2 to copy the next byte until we have
28589                                                                          ; copied the whole block
28590               
28591                                                                          ; We have now shuffled the ship's slot and the ship's
28592                                                                          ; data block, so we only have the heap data itself to do
28593               
28594 C5E6 D360  30        movb @SC,ra                     ; LDA SC            ; First, we copy SC into INF, so when we loop round
     C5E8 0007     
28595 C5EA D80D  30        movb ra,@INF                    ; STA INF           ; again, INF will correctly point to the destination for
     C5EC 0020     
28596 C5EE D360  30        movb @SC+1,ra                   ; LDA SC+1          ; the next iteration
     C5F0 0008     
28597 C5F2 D80D  30        movb ra,@INF+1                  ; STA INF+1
     C5F4 0021     
28598               
28599 C5F6 D3E0  30        movb @T,ry                      ; LDY T             ; Now we want to move the contents of the heap, as all
     C5F8 00D1     
28600                                                                          ; we did above was to update the pointers, so first
28601                                                                          ; we set a counter in Y that is initially set to T
28602                                                                          ; (which we set above to the maximum heap size for the
28603                                                                          ; source ship)
28604                                                                          ;
28605                                                                          ; As a reminder, we have already set the following:
28606                                                                          ;
28607                                                                          ; K(1 0) points to the source's line heap
28608                                                                          ;
28609                                                                          ; P(1 0) points to the destination's line heap
28610                                                                          ;
28611                                                                          ; so we can move the heap data by simply copying the
28612                                                                          ; correct number of bytes from K(1 0) to P(1 0)
28613               KSL3:
28614 C5FA 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
28615               
28616                      .ld_ind_y_idx @K,ra             ; LDA (K),Y         ; Copy the Y-th byte of the source heap at K(1 0) to
     **** ****     > LD_IND_Y_IDX
0001 C5FC D820  42        movb @K,@rtmplb
     C5FE 003D     
     C600 8301     
0002 C602 D020  30        movb @K+1,rtmp
     C604 003E     
0003 C606 06CF  14        swpb ry
0004 C608 A00F  18        a    ry,rtmp
0005 C60A 06CF  14        swpb ry
0006 C60C D350  26        movb *rtmp,RA
                   < elite.a99
28617                      .st_ind_y_idx @P,ra             ; STA (P),Y         ; the destination heap at P(1 0)
     **** ****     > ST_IND_Y_IDX
0001 C60E D820  42        movb @P,@rtmplb
     C610 001B     
     C612 8301     
0002 C614 D020  30        movb @P+1,rtmp
     C616 001C     
0003 C618 06CF  14        swpb ry
0004 C61A A00F  18        a    ry,rtmp
0005 C61C 06CF  14        swpb ry
0006 C61E D40D  30        movb RA,*rtmp
                   < elite.a99
28618               
28619 C620 D34F  18        movb ry,ra                      ; TYA               ; Loop back to KSL3 to copy the next byte, until we
28620 C622 16EB  14        jne  KSL3                       ; BNE KSL3          ; have done them all
28621               
28622 C624 1602  14        jne  FIX010                     ; BNE FIX010        ; We have now shuffled everything down one slot, so
28623 C626 0460  28        b    @KSL1                      ; JMP KSL1          ; jump back up to KSL1 to see if there is another slot
     C628 C4A2     
28624                                                                          ; that needs shuffling down (this BEQ is effectively a
28625                                                                          ; JMP as A will always be zero)
28626               FIX010:
28627               * ******************************************************************************
28628               *
28629               * Name: SFX
28630               * Type: Variable
28631               * Category: Sound
28632               * Summary: Sound data
28633               *
28634               * ------------------------------------------------------------------------------
28635               *
28636               * Sound data. To make a sound, the NOS1 routine copies the four relevant sound
28637               * bytes to XX16, and NO3 then makes the sound. The sound numbers are shown in
28638               * the table, and are always multiples of 8. Generally, sounds are made by
28639               * calling the NOISE routine with the sound number in A.
28640               *
28641               * These bytes are passed to OSWORD 7, and are the equivalents to the parameters
28642               * passed to the SOUND keyword in BASIC. The parameters therefore have these
28643               * meanings:
28644               *
28645               * channel/flush, amplitude (or envelope number if 1-4), pitch, duration
28646               *
28647               * For the channel/flush parameter, the high nibble of the low byte is the flush
28648               * control (where a flush control of 0 queues the sound, and a flush control of
28649               * 1 makes the sound instantly), while the low nibble of the low byte is the
28650               * channel number. When written in hexadecimal, the first figure gives the flush
28651               * control, while the second is the channel (so &13 indicates flush control = 1
28652               * and channel = 3).
28653               *
28654               * So when we call NOISE with A = 40 to make a long, low beep, then this is
28655               * effectively what the NOISE routine does:
28656               *
28657               * SOUND &13, &F4, &0C, &08
28658               *
28659               * which makes a sound with flush control 1 on channel 3, and with amplitude &F4
28660               * (-12), pitch &0C (2) and duration &08 (8). Meanwhile, to make the hyperspace
28661               * sound, the NOISE routine does this:
28662               *
28663               * SOUND &10, &02, &60, &10
28664               *
28665               * which makes a sound with flush control 1 on channel 0, using envelope 2,
28666               * and with pitch &60 (96) and duration &10 (16). The four sound envelopes (1-4)
28667               * are set up by the loading process.
28668               *
28669               * ******************************************************************************
28670                      equ  $
28671               SFX:
28672 C62A 1201            byte >12,>01,>00,>10                                ; 0  - Lasers fired by us
     C62C 0010     
28673 C62E 1202            byte >12,>02,>2c,>08                                ; 8  - We're being hit by lasers
     C630 2C08     
28674 C632 1103            byte >11,>03,>f0,>18                                ; 16 - We died 1 / We made a hit or kill 2
     C634 F018     
28675 C636 10F1            byte >10,>f1,>07,>1a                                ; 24 - We died 2 / We made a hit or kill 1
     C638 071A     
28676 C63A 03F1            byte >03,>f1,>bc,>01                                ; 32 - Short, high beep
     C63C BC01     
28677 C63E 13F4            byte >13,>f4,>0c,>08                                ; 40 - Long, low beep
     C640 0C08     
28678 C642 10F1            byte >10,>f1,>06,>0c                                ; 48 - Missile launched / Ship launched from station
     C644 060C     
28679 C646 1002            byte >10,>02,>60,>10                                ; 56 - Hyperspace drive engaged
     C648 6010     
28680 C64A 1304            byte >13,>04,>c2,>ff                                ; 64 - E.C.M. on
     C64C C2FF     
28681 C64E 1300            byte >13,>00,>00,>00                                ; 72 - E.C.M. off
     C650 0000     
28682               
28683               * ******************************************************************************
28684               *
28685               * Name: RESET
28686               * Type: Subroutine
28687               * Category: Start and end
28688               * Summary: Reset most variables
28689               *
28690               * ------------------------------------------------------------------------------
28691               *
28692               * Reset our ship and various controls, recharge shields and energy, and then
28693               * fall through into RES2 to reset the stardust and the ship workspace at INWK.
28694               *
28695               * In this subroutine, this means zero-filling the following locations:
28696               *
28697               * * Pages &9, &A, &B, &C and &D
28698               *
28699               * * BETA to BETA+6, which covers the following:
28700               *
28701               * * BETA, BET1 - Set pitch to 0
28702               *
28703               * * XC, YC - Set text cursor to (0, 0)
28704               *
28705               * * QQ22 - Set hyperspace counters to 0
28706               *
28707               * * ECMA - Turn E.C.M. off
28708               *
28709               * It also sets QQ12 to &FF, to indicate we are docked, recharges the shields and
28710               * energy banks, and then falls through into RES2.
28711               *
28712               * ------------------------------------------------------------------------------
28713               *
28714               * Other entry points:
28715               *
28716               * RES4                Reset the shields and energy banks, then fall through
28717               * into RES2 to reset the stardust and the ship workspace
28718               * at INWK
28719               *
28720               * ******************************************************************************
28721               
28722               RESET:
28723 C652 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     C654 CF82     
28724 C656 06A0  32        bl   @jsr                       ;
     C658 FE28     
28725                                                                          ; the ship data blocks, the ship line heap, the ship
28726                                                                          ; slots for the local bubble of universe, and various
28727                                                                          ; flight and ship status variables
28728               
28729 C65A 020E  20        li   rx,>06*256                 ; LDX #6            ; Set up a counter for zeroing BETA through BETA+6
     C65C 0600     
28730               
28731               SAL3:
28732 C65E 06CE  14        swpb rx                         ;
28733 C660 DB8D  38        movb ra,@BETA(rx)               ; STA BETA,X        ; Zero the X-th byte after BETA
     C662 002A     
28734 C664 06CE  14        swpb rx                         ;
28735               
28736 C666 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28737               
28738 C668 15FA  14        jgt  SAL3                       ; BPL SAL3          ; Loop back for the next byte to zero
28739               
28740 C66A D80E  30        movb rx,@QQ12                   ; STX QQ12          ; X is now negative - i.e. &FF - so this sets QQ12 to
     C66C 009F     
28741                                                                          ; &FF to indicate we are docked
28742               
28743                                                                          ; We now fall through into RES4 to restore shields and
28744                                                                          ; energy, and reset the stardust and ship workspace at
28745                                                                          ; INWK
28746               
28747               RES4:
28748 C66E 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can fill up the shields and energy
     C670 FF00     
28749                                                                          ; bars with a full charge
28750               
28751 C672 020E  20        li   rx,>02*256                 ; LDX #2            ; We're now going to recharge both shields and the
     C674 0200     
28752                                                                          ; energy bank, which live in the three bytes at FSH,
28753                                                                          ; ASH (FSH+1) and ENERGY (FSH+2), so set a loop counter
28754                                                                          ; in X for 3 bytes
28755               
28756               REL5:
28757 C676 06CE  14        swpb rx                         ;
28758 C678 DB8D  38        movb ra,@FSH(rx)                ; STA FSH,X         ; Set the X-th byte of FSH to &FF to charge up that
     C67A 0F11     
28759 C67C 06CE  14        swpb rx                         ;
28760                                                                          ; shield/bank
28761               
28762 C67E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
28763               
28764 C680 15FA  14        jgt  REL5                       ; BPL REL5          ; Loop back to REL5 until we have recharged both shields
28765                                                                          ; and the energy bank
28766               
28767                                                                          ; Fall through into RES2 to reset the stardust and ship
28768                                                                          ; workspace at INWK
28769               
28770               * ******************************************************************************
28771               *
28772               * Name: RES2
28773               * Type: Subroutine
28774               * Category: Start and end
28775               * Summary: Reset a number of flight variables and workspaces
28776               *
28777               * ------------------------------------------------------------------------------
28778               *
28779               * This is called after we launch from a space station, arrive in a new system
28780               * after hyperspace, launch an escape pod, or die a cold, lonely death in the
28781               * depths of space.
28782               *
28783               * ------------------------------------------------------------------------------
28784               *
28785               * Returns:
28786               *
28787               * Y                   Y is set to &FF
28788               *
28789               * ******************************************************************************
28790               
28791               RES2:
28792 C682 020D  20        li   ra,(NOST)*256              ; LDA #NOST         ; Reset NOSTM, the number of stardust particles, to the
     C684 1200     
28793 C686 D80D  30        movb ra,@NOSTM                  ; STA NOSTM         ; maximum allowed (18)
     C688 0F33     
28794               
28795 C68A 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Reset LSX2 and LSY2, the ball line heaps used by the
     C68C FF00     
28796 C68E D80E  30        movb rx,@LSX2                   ; STX LSX2          ; BLINE routine for drawing circles, to &FF, to set the
     C690 0E26     
28797 C692 D80E  30        movb rx,@LSY2                   ; STX LSY2          ; heap to empty
     C694 0E74     
28798               
28799 C696 D80E  30        movb rx,@MSTG                   ; STX MSTG          ; Reset MSTG, the missile target, to &FF (no target)
     C698 0052     
28800               
28801 C69A 020D  20        li   ra,>80*256                 ; LDA #128          ; Set the current pitch rate to the mid-point, 128
     C69C 8000     
28802 C69E D80D  30        movb ra,@JSTY                   ; STA JSTY
     C6A0 009D     
28803               
28804 C6A2 D80D  30        movb ra,@ALP2                   ; STA ALP2          ; Reset ALP2 (roll sign) and BET2 (pitch sign)
     C6A4 0088     
28805 C6A6 D80D  30        movb ra,@BET2                   ; STA BET2          ; to negative, i.e. pitch and roll negative
     C6A8 008A     
28806               
28807                      .asla                           ; ASL A             ; This sets A to 0
     **** ****     > ASLA
0001 C6AA 024D  22        andi ra,>ff00
     C6AC FF00     
0002 C6AE 0A1D  18        sla  ra,1
                   < elite.a99
28808               
28809 C6B0 D80D  30        movb ra,@ALP2+1                 ; STA ALP2+1        ; Reset ALP2+1 (flipped roll sign) and BET2+1 (flipped
     C6B2 0089     
28810 C6B4 D80D  30        movb ra,@BET2+1                 ; STA BET2+1        ; pitch sign) to positive, i.e. pitch and roll negative
     C6B6 008B     
28811               
28812 C6B8 D80D  30        movb ra,@MCNT                   ; STA MCNT          ; Reset MCNT (the main loop counter) to 0
     C6BA 0099     
28813               
28814 C6BC 020D  20        li   ra,>03*256                 ; LDA #3            ; Reset DELTA (speed) to 3
     C6BE 0300     
28815 C6C0 D80D  30        movb ra,@DELTA                  ; STA DELTA
     C6C2 008C     
28816               
28817 C6C4 D80D  30        movb ra,@ALPHA                  ; STA ALPHA         ; Reset ALPHA (roll angle alpha) to 3
     C6C6 009E     
28818               
28819 C6C8 D80D  30        movb ra,@ALP1                   ; STA ALP1          ; Reset ALP1 (magnitude of roll angle alpha) to 3
     C6CA 0087     
28820               
28821 C6CC D360  30        movb @SSPR,ra                   ; LDA SSPR          ; Fetch the "space station present" flag, and if we are
     C6CE 0D55     
28822 C6D0 1304  14        jeq  B86                        ; BEQ B86           ; not inside the safe zone, skip the next instruction
28823               
28824 C6D2 0200  20        li   rtmp,SPBLB                 ; JSR SPBLB         ; Light up the space station bulb on the dashboard
     C6D4 B76E     
28825 C6D6 06A0  32        bl   @jsr                       ;
     C6D8 FE28     
28826               
28827               B86:
28828 C6DA D360  30        movb @ECMA,ra                   ; LDA ECMA          ; Fetch the E.C.M. status flag, and if E.C.M. is off,
     C6DC 0030     
28829 C6DE 1304  14        jeq  yu_                        ; BEQ yu            ; skip the next instruction
28830               
28831 C6E0 0200  20        li   rtmp,ECMOF                 ; JSR ECMOF         ; Turn off the E.C.M. sound
     C6E2 D2A4     
28832 C6E4 06A0  32        bl   @jsr                       ;
     C6E6 FE28     
28833               
28834               yu_:
28835 C6E8 0200  20        li   rtmp,WPSHPS                ; JSR WPSHPS        ; Wipe all ships from the scanner
     C6EA B23C     
28836 C6EC 06A0  32        bl   @jsr                       ;
     C6EE FE28     
28837               
28838 C6F0 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     C6F2 CF82     
28839 C6F4 06A0  32        bl   @jsr                       ;
     C6F6 FE28     
28840                                                                          ; the ship data blocks, the ship line heap, the ship
28841                                                                          ; slots for the local bubble of universe, and various
28842                                                                          ; flight and ship status variables
28843               
28844 C6F8 020D  20        li   ra,((WP.-1)%256)*256       ; LDA #LO(WP%-1)    ; We have reset the ship line heap, so we now point
     C6FA 3F00     
28845 C6FC D80D  30        movb ra,@SLSP                   ; STA SLSP          ; SLSP to the byte before the WP workspace to indicate
     C6FE 0F1E     
28846 C700 020D  20        li   ra,((WP.-1)/256)*256       ; LDA #HI(WP%-1)    ; that the heap is empty
     C702 0D00     
28847 C704 D80D  30        movb ra,@SLSP+1                 ; STA SLSP+1
     C706 0F1F     
28848               
28849 C708 0200  20        li   rtmp,DIALS                 ; JSR DIALS         ; Update the dashboard
     C70A 3522     
28850 C70C 06A0  32        bl   @jsr                       ;
     C70E FE28     
28851               
28852                                                                          ; Finally, fall through into ZINF to reset the INWK
28853                                                                          ; ship workspace
28854               
28855               * ******************************************************************************
28856               *
28857               * Name: ZINF
28858               * Type: Subroutine
28859               * Category: Universe
28860               * Summary: Reset the INWK workspace and orientation vectors
28861               * Deep dive: Orientation vectors
28862               *
28863               * ------------------------------------------------------------------------------
28864               *
28865               * Zero-fill the INWK ship workspace and reset the orientation vectors, with
28866               * nosev pointing out of the screen, towards us.
28867               *
28868               * ------------------------------------------------------------------------------
28869               *
28870               * Returns:
28871               *
28872               * Y                   Y is set to &FF
28873               *
28874               * ******************************************************************************
28875               
28876               ZINF:
28877 C710 020F  20        li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in the INWK workspace, so set a
     C712 2300     
28878                                                                          ; counter in Y so we can loop through them
28879               
28880 C714 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the workspace
     C716 0000     
28881               
28882               ZI1:
28883 C718 06CF  14        swpb ry                         ;
28884 C71A DBCD  38        movb ra,@INWK(ry)               ; STA INWK,Y        ; Zero the Y-th byte of the INWK workspace
     C71C 0053     
28885 C71E 06CF  14        swpb ry                         ;
28886               
28887 C720 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
28888               
28889 C722 15FA  14        jgt  ZI1                        ; BPL ZI1           ; Loop back for the next byte, ending when we have
28890                                                                          ; zero-filled the last byte at INWK, which leaves Y
28891                                                                          ; with a value of &FF
28892               
28893                                                                          ; Finally, we reset the orientation vectors as follows:
28894                                                                          ;
28895                                                                          ; sidev = (1,  0,  0)
28896                                                                          ; roofv = (0,  1,  0)
28897                                                                          ; nosev = (0,  0, -1)
28898                                                                          ;
28899                                                                          ; 96 * 256 (&6000) represents 1 in the orientation
28900                                                                          ; vectors, while -96 * 256 (&E000) represents -1. We
28901                                                                          ; already set the vectors to zero above, so we just
28902                                                                          ; need to set up the high bytes of the diagonal values
28903                                                                          ; and we're done. The negative nosev makes the ship
28904                                                                          ; point towards us, as the z-axis points into the screen
28905               
28906 C724 020D  20        li   ra,>60*256                 ; LDA #96           ; Set A to represent a 1 (in vector terms)
     C726 6000     
28907               
28908 C728 D80D  30        movb ra,@INWK+18                ; STA INWK+18       ; Set byte #18 = roofv_y_hi = 96 = 1
     C72A 0065     
28909               
28910 C72C D80D  30        movb ra,@INWK+22                ; STA INWK+22       ; Set byte #22 = sidev_x_hi = 96 = 1
     C72E 0069     
28911               
28912 C730 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Flip the sign of A to represent a -1
     C732 8000     
28913               
28914 C734 D80D  30        movb ra,@INWK+14                ; STA INWK+14       ; Set byte #14 = nosev_z_hi = -96 = -1
     C736 0061     
28915               
28916 C738 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C73A FE34     
28917               
28918               * ******************************************************************************
28919               *
28920               * Name: msblob
28921               * Type: Subroutine
28922               * Category: Dashboard
28923               * Summary: Display the dashboard's missile indicators in green
28924               *
28925               * ------------------------------------------------------------------------------
28926               *
28927               * Display the dashboard's missile indicators, with all the missiles reset to
28928               * green/cyan (i.e. not armed or locked).
28929               *
28930               * ******************************************************************************
28931               
28932               msblob_:
28933 C73C 020E  20        li   rx,>04*256                 ; LDX #4            ; Set up a loop counter in X to count through all four
     C73E 0400     
28934                                                                          ; missile indicators
28935               
28936               ss_:
28937 C740 93A0  30        cb   @NOMSL,rx                  ; CPX NOMSL         ; If the counter is equal to the number of missiles,
     C742 0333     
28938 C744 130A  14        jeq  SAL8                       ; BEQ SAL8          ; jump down to SAL8 to draw the remaining missiles, as
28939                                                                          ; the rest of them are present and should be drawn in
28940                                                                          ; green/cyan
28941               
28942 C746 020F  20        li   ry,>00*256                 ; LDY #0            ; Draw the missile indicator at position X in black
     C748 0000     
28943 C74A 0200  20        li   rtmp,MSBAR                 ; JSR MSBAR
     C74C B79A     
28944 C74E 06A0  32        bl   @jsr                       ;
     C750 FE28     
28945               
28946 C752 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28947               
28948 C754 16F5  14        jne  ss_                        ; BNE ss            ; Loop back to ss if we still have missiles to draw
28949               
28950 C756 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C758 FE34     
28951               
28952               SAL8:
28953 C75A 020F  20        li   ry,>ee*256                 ; LDY #&EE          ; Draw the missile indicator at position X in green/cyan
     C75C EE00     
28954 C75E 0200  20        li   rtmp,MSBAR                 ; JSR MSBAR
     C760 B79A     
28955 C762 06A0  32        bl   @jsr                       ;
     C764 FE28     
28956               
28957 C766 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile
28958               
28959 C768 16F8  14        jne  SAL8                       ; BNE SAL8          ; Loop back to SAL8 if we still have missiles to draw
28960               
28961 C76A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C76C FE34     
28962               
28963               * ******************************************************************************
28964               *
28965               * Name: me2
28966               * Type: Subroutine
28967               * Category: Flight
28968               * Summary: Remove an in-flight message from the space view
28969               *
28970               * ******************************************************************************
28971               
28972               me2_:
28973 C76E D360  30        movb @MCH,ra                    ; LDA MCH           ; Fetch the token number of the current message into A
     C770 0F10     
28974               
28975 C772 0200  20        li   rtmp,MESS                  ; JSR MESS          ; Call MESS to print the token, which will remove it
     C774 D616     
28976 C776 06A0  32        bl   @jsr                       ;
     C778 FE28     
28977                                                                          ; from the screen as printing uses EOR logic
28978               
28979 C77A 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the delay in DLY to 0, so any new in-flight
     C77C 0000     
28980 C77E D80D  30        movb ra,@DLY                    ; STA DLY           ; messages will be shown instantly
     C780 0D64     
28981               
28982 C782 0460  28        b    @me3_                      ; JMP me3           ; Jump back into the main spawning loop at me3
     C784 C83E     
28983               
28984               * ******************************************************************************
28985               *
28986               * Name: Ze
28987               * Type: Subroutine
28988               * Category: Universe
28989               * Summary: Initialise the INWK workspace to a hostile ship
28990               * Deep dive: Fixing ship positions
28991               *
28992               * ------------------------------------------------------------------------------
28993               *
28994               * Specifically, this routine does the following:
28995               *
28996               * * Reset the INWK ship workspace
28997               *
28998               * * Set the ship to a fair distance away in all axes, in front of us but
28999               * randomly up or down, left or right
29000               *
29001               * * Give the ship a 4% chance of having E.C.M.
29002               *
29003               * * Set the ship to hostile, with AI enabled
29004               *
29005               * This routine also sets A, X, T1 and the C flag to random values.
29006               *
29007               * Note that because this routine uses the value of X returned by DORND, and X
29008               * contains the value of A returned by the previous call to DORND, this routine
29009               * does not necessarily set the new ship to a totally random location. See the
29010               * deep dive on "Fixing ship positions" for details.
29011               *
29012               * ******************************************************************************
29013               
29014               Ze:
29015 C786 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     C788 C710     
29016 C78A 06A0  32        bl   @jsr                       ;
     C78C FE28     
29017               
29018 C78E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C790 C7D0     
29019 C792 06A0  32        bl   @jsr                       ;
     C794 FE28     
29020               
29021 C796 D80D  30        movb ra,@T1                     ; STA T1            ; Store A in T1
     C798 0006     
29022               
29023 C79A 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Extract the sign of A and store in x_sign
     C79C 8000     
29024 C79E D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     C7A0 0055     
29025               
29026 C7A2 D34E  18        movb rx,ra                      ; TXA               ; Extract the sign of X and store in y_sign
29027 C7A4 024D  22        andi ra,>80*256                 ; AND #%10000000
     C7A6 8000     
29028 C7A8 D80D  30        movb ra,@INWK+5                 ; STA INWK+5
     C7AA 0058     
29029               
29030 C7AC 020D  20        li   ra,>20*256                 ; LDA #32           ; Set x_hi = y_hi = z_hi = 32, a fair distance away
     C7AE 2000     
29031 C7B0 D80D  30        movb ra,@INWK+1                 ; STA INWK+1
     C7B2 0054     
29032 C7B4 D80D  30        movb ra,@INWK+4                 ; STA INWK+4
     C7B6 0057     
29033 C7B8 D80D  30        movb ra,@INWK+7                 ; STA INWK+7
     C7BA 005A     
29034               
29035 C7BC D34E  18        movb rx,ra                      ; TXA               ; Set the C flag if X >= 245 (4% chance)
29036 C7BE 028D  22        ci   ra,>f5*256                 ; CMP #245
     C7C0 F500     
29037               
29038 C7C2 06A0  32        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 4%
     C7C4 FE3E     
29039                                                                          ; chance of this ship having E.C.M.)
29040               
29041 C7C6 026D  22        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6
     C7C8 C000     
29042                                                                          ; and has AI (bit 7)
29043               
29044 C7CA D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     C7CC 0073     
29045               
29046                                                                          ; Fall through into DORND2 to set A, X and the C flag
29047                                                                          ; randomly
29048               
29049               * ******************************************************************************
29050               *
29051               * Name: DORND
29052               * Type: Subroutine
29053               * Category: Maths (Arithmetic)
29054               * Summary: Generate random numbers
29055               * Deep dive: Generating random numbers
29056               * Fixing ship positions
29057               *
29058               * ------------------------------------------------------------------------------
29059               *
29060               * Set A and X to random numbers (though note that X is set to the random number
29061               * that was returned in A the last time DORND was called).
29062               *
29063               * The C and V flags are also set randomly.
29064               *
29065               * If we want to generate a repeatable sequence of random numbers, when
29066               * generating explosion clouds, for example, then we call DORND2 to ensure that
29067               * the value of the C flag on entry doesn't affect the outcome, as otherwise we
29068               * might not get the same sequence of numbers if the C flag changes.
29069               *
29070               * ------------------------------------------------------------------------------
29071               *
29072               * Other entry points:
29073               *
29074               * DORND2              Make sure the C flag doesn't affect the outcome
29075               *
29076               * ******************************************************************************
29077               
29078               DORND2:
29079                      .clc                            ; CLC               ; Clear the C flag so the value of the C flag on entry
     **** ****     > CLC
0001 C7CE 0A16  18        sla  rzero,1
                   < elite.a99
29080                                                                          ; doesn't affect the outcome
29081               
29082               DORND:
29083 C7D0 D360  30        movb @RAND,ra                   ; LDA RAND          ; Calculate the next two values f2 and f3 in the feeder
     C7D2 0000     
29084 C7D4 06A0  32        bl   @rola                      ; ROL A             ; sequence:
     C7D6 FE3E     
29085 C7D8 D38D  18        movb ra,rx                      ; TAX               ;
29086                      .adc @RAND+2,ra                 ; ADC RAND+2        ; * f2 = (f1 << 1) mod 256 + C flag on entry
     **** ****     > ADC
0001 C7DA 1701  14        jnc  !
0002 C7DC B347  18        ab   rone,ra
0003               !:
0004 C7DE B360  30        ab   @RAND+2,ra
     C7E0 0002     
                   < elite.a99
29087 C7E2 D80D  30        movb ra,@RAND                   ; STA RAND          ; * f3 = f0 + f2 + (1 if bit 7 of f1 is set)
     C7E4 0000     
29088 C7E6 D80E  30        movb rx,@RAND+2                 ; STX RAND+2        ; * C flag is set according to the f3 calculation
     C7E8 0002     
29089               
29090 C7EA D360  30        movb @RAND+1,ra                 ; LDA RAND+1        ; Calculate the next value m2 in the main sequence:
     C7EC 0001     
29091 C7EE D38D  18        movb ra,rx                      ; TAX               ;
29092                      .adc @RAND+3,ra                 ; ADC RAND+3        ; * A = m2 = m0 + m1 + C flag from feeder calculation
     **** ****     > ADC
0001 C7F0 1701  14        jnc  !
0002 C7F2 B347  18        ab   rone,ra
0003               !:
0004 C7F4 B360  30        ab   @RAND+3,ra
     C7F6 0003     
                   < elite.a99
29093 C7F8 D80D  30        movb ra,@RAND+1                 ; STA RAND+1        ; * X = m1
     C7FA 0001     
29094 C7FC D80E  30        movb rx,@RAND+3                 ; STX RAND+3        ; * C and V flags set according to the m2 calculation
     C7FE 0003     
29095               
29096 C800 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     C802 FE34     
29097               
29098               * ******************************************************************************
29099               *
29100               * Name: Main game loop (Part 1 of 6)
29101               * Type: Subroutine
29102               * Category: Main loop
29103               * Summary: Spawn a trader (a peaceful Cobra Mk III)
29104               * Deep dive: Program flow of the main game loop
29105               * Ship data blocks
29106               *
29107               * ------------------------------------------------------------------------------
29108               *
29109               * This is part of the main game loop. This is where the core loop of the game
29110               * lives, and it's in two parts. The shorter loop (just parts 5 and 6) is
29111               * iterated when we are docked, while the entire loop from part 1 to 6 iterates
29112               * if we are in space.
29113               *
29114               * This section covers the following:
29115               *
29116               * * Spawn a trader, i.e. a Cobra Mk III that isn't hostile, with a 50% chance
29117               * of it having a missile, a 50% chance of it having an E.C.M., a speed
29118               * between 16 and 31, and a gentle clockwise roll
29119               *
29120               * We call this from within the main loop, with A set to a random number.
29121               *
29122               * ******************************************************************************
29123               
29124               MTT4:
29125 C804 091D  18        srl  ra,1                       ; LSR A             ; Clear bit 7 of our random number in A and set the C
29126                                                                          ; flag to bit 0 of A, which is random
29127               
29128 C806 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; Store this in the ship's AI flag, so this ship does
     C808 0073     
29129                                                                          ; not have AI
29130               
29131 C80A D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; Store A in the ship's roll counter, giving it a
     C80C 0070     
29132                                                                          ; clockwise roll (as bit 7 is clear), and a 1 in 127
29133                                                                          ; chance of it having no damping
29134               
29135 C80E 0204  20        li   rarg1,INWK+31              ; ROL INWK+31       ; Set bit 0 of the ship's missile count randomly (as the
     C810 0072     
29136 C812 06A0  32        bl   @rol                       ;
     C814 FE4E     
29137                                                                          ; C flag was set), giving the ship either no missiles or
29138                                                                          ; one missile
29139               
29140 C816 024D  22        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     C818 1F00     
29141 C81A 026D  22        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     C81C 1000     
29142 C81E D80D  30        movb ra,@INWK+27                ; STA INWK+27
     C820 006E     
29143               
29144 C822 020D  20        li   ra,(CYL)*256               ; LDA #CYL          ; Add a new Cobra Mk III to the local bubble and fall
     C824 0700     
29145 C826 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; through into the main game loop again
     C828 B5DA     
29146 C82A 06A0  32        bl   @jsr                       ;
     C82C FE28     
29147               
29148               * ******************************************************************************
29149               *
29150               * Name: Main game loop (Part 2 of 6)
29151               * Type: Subroutine
29152               * Category: Main loop
29153               * Summary: Call the main flight loop, and potentially spawn a trader, an
29154               * asteroid, or a cargo canister
29155               * Deep dive: Program flow of the main game loop
29156               * Ship data blocks
29157               * Fixing ship positions
29158               *
29159               * ------------------------------------------------------------------------------
29160               *
29161               * This section covers the following:
29162               *
29163               * * Call M% to do the main flight loop
29164               *
29165               * * Potentially spawn a trader, asteroid or cargo canister
29166               *
29167               * ------------------------------------------------------------------------------
29168               *
29169               * Other entry points:
29170               *
29171               * TT100               The entry point for the start of the main game loop,
29172               * which calls the main flight loop and the moves into the
29173               * spawning routine
29174               *
29175               * me3                 Used by me2 to jump back into the main game loop after
29176               * printing an in-flight message
29177               *
29178               * ******************************************************************************
29179               
29180               TT100:
29181 C82E 0200  20        li   rtmp,M.                    ; JSR M%            ; Call M% to iterate through the main flight loop
     C830 0F52     
29182 C832 06A0  32        bl   @jsr                       ;
     C834 FE28     
29183               
29184 C836 7347  18        sb   rone,ra                    ; DEC DLY           ; Decrement the delay counter in DLY, so any in-flight
29185                                                                          ; messages get removed once the counter reaches zero
29186               
29187 C838 139A  14        jeq  me2_                       ; BEQ me2           ; If DLY is now 0, jump to me2 to remove any in-flight
29188                                                                          ; message from the space view, and once done, return to
29189                                                                          ; me3 below, skipping the following two instructions
29190               
29191 C83A 1501  14        jgt  me3_                       ; BPL me3           ; If DLY is positive, jump to me3 to skip the next
29192                                                                          ; instruction
29193               
29194 C83C B347  18        ab   rone,ra                    ; INC DLY           ; If we get here, DLY is negative, so we have gone too
29195                                                                          ; and need to increment DLY back to 0
29196               
29197               me3_:
29198 C83E 7347  18        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter in MCNT
29199               
29200 C840 1302  14        jeq  B87                        ; BEQ B87           ; If the counter has reached zero, which it will do
29201                                                                          ; every 256 main loops, skip the next JMP instruction
29202                                                                          ; (or to put it another way, if the counter hasn't
29203                                                                          ; reached zero, jump down to MLOOP, skipping all the
29204                                                                          ; following checks)
29205               
29206               ytq_:
29207 C842 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP to do some end-of-loop tidying and
     C844 C9CA     
29208                                                                          ; restart the main loop
29209               
29210                                                                          ; We only get here once every 256 iterations of the
29211                                                                          ; main loop. If we aren't in witchspace and don't
29212                                                                          ; already have 3 or more asteroids in our local bubble,
29213                                                                          ; then this section has a 13% chance of spawning
29214                                                                          ; something benign (the other 87% of the time we jump
29215                                                                          ; down to consider spawning cops, pirates and bounty
29216                                                                          ; hunters)
29217                                                                          ;
29218                                                                          ; If we are in that 13%, then 50% of the time this will
29219                                                                          ; be a Cobra Mk III trader, and the other 50% of the
29220                                                                          ; time it will either be an asteroid (98.5% chance) or,
29221                                                                          ; very rarely, a cargo canister (1.5% chance)
29222               
29223               B87:
29224 C846 D360  30        movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace following a mis-jump, skip the
     C848 0D5C     
29225 C84A 16FB  14        jne  ytq_                       ; BNE ytq           ; following by jumping down to MLOOP (via ytq above)
29226               
29227 C84C 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C84E C7D0     
29228 C850 06A0  32        bl   @jsr                       ;
     C852 FE28     
29229               
29230 C854 028D  22        ci   ra,>23*256                 ; CMP #35           ; If A >= 35 (87% chance), jump down to MTT1 to skip
     C856 2300     
29231 C858 184F  14        joc  MTT1                       ; BCS MTT1          ; the spawning of an asteroid or cargo canister and
29232                                                                          ; potentially spawn something else
29233               
29234 C85A D360  30        movb @MANY+AST,ra               ; LDA MANY+AST      ; If we already have 3 or more asteroids in the local
     C85C 0D57     
29235 C85E 028D  22        ci   ra,>03*256                 ; CMP #3            ; bubble, jump down to MTT1 to skip the following and
     C860 0300     
29236 C862 184A  14        joc  MTT1                       ; BCS MTT1          ; potentially spawn something else
29237               
29238 C864 0200  20        li   rtmp,ZINF                  ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace
     C866 C710     
29239 C868 06A0  32        bl   @jsr                       ;
     C86A FE28     
29240               
29241 C86C 020D  20        li   ra,>26*256                 ; LDA #38           ; Set z_hi = 38 (far away)
     C86E 2600     
29242 C870 D80D  30        movb ra,@INWK+7                 ; STA INWK+7
     C872 005A     
29243               
29244 C874 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and C flag to random numbers
     C876 C7D0     
29245 C878 06A0  32        bl   @jsr                       ;
     C87A FE28     
29246               
29247 C87C D80D  30        movb ra,@INWK                   ; STA INWK          ; Set x_lo = random
     C87E 0053     
29248               
29249 C880 D80E  30        movb rx,@INWK+3                 ; STX INWK+3        ; Set y_lo = random
     C882 0056     
29250                                                                          ;
29251                                                                          ; Note that because we use the value of X returned by
29252                                                                          ; DORND, and X contains the value of A returned by the
29253                                                                          ; previous call to DORND, this does not set the new ship
29254                                                                          ; to a totally random location. See the deep dive on
29255                                                                          ; "Fixing ship positions" for details
29256               
29257 C884 024D  22        andi ra,>80*256                 ; AND #%10000000    ; Set x_sign = bit 7 of x_lo
     C886 8000     
29258 C888 D80D  30        movb ra,@INWK+2                 ; STA INWK+2
     C88A 0055     
29259               
29260 C88C D34E  18        movb rx,ra                      ; TXA               ; Set y_sign = bit 7 of y_lo
29261 C88E 024D  22        andi ra,>80*256                 ; AND #%10000000
     C890 8000     
29262 C892 D80D  30        movb ra,@INWK+5                 ; STA INWK+5
     C894 0058     
29263               
29264 C896 0204  20        li   rarg1,INWK+1               ; ROL INWK+1        ; Set bit 1 of x_hi to the C flag, which is random, so
     C898 0054     
29265 C89A 06A0  32        bl   @rol                       ;
     C89C FE4E     
29266 C89E 0204  20        li   rarg1,INWK+1               ; ROL INWK+1        ; this randomly moves us off-centre by 512 (as if x_hi
     C8A0 0054     
29267 C8A2 06A0  32        bl   @rol                       ;
     C8A4 FE4E     
29268                                                                          ; is %00000010, then (x_hi x_lo) is 512 + x_lo)
29269               
29270 C8A6 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A, X and V flag to random numbers
     C8A8 C7D0     
29271 C8AA 06A0  32        bl   @jsr                       ;
     C8AC FE28     
29272               
29273                      .bvs MTT4                       ; BVS MTT4          ; If V flag is set (50% chance), jump up to MTT4 to
     **** ****     > BVS
0001 C8AE 1801  14        joc  !
0002 C8B0 10A9  14        jmp  MTT4
0003               !:
                   < elite.a99
29274                                                                          ; spawn a trader
29275               
29276 C8B2 026D  22        ori  ra,>6f*256                 ; ORA #%01101111    ; Take the random number in A and set bits 0-3 and 5-6,
     C8B4 6F00     
29277 C8B6 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; so the result has a 50% chance of being positive or
     C8B8 0070     
29278                                                                          ; negative, and a 50% chance of bits 0-6 being 127.
29279                                                                          ; Storing this number in the roll counter therefore
29280                                                                          ; gives our new ship a fast roll speed with a 50%
29281                                                                          ; chance of having no damping, plus a 50% chance of
29282                                                                          ; rolling clockwise or anti-clockwise
29283               
29284 C8BA D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump
     C8BC 0D55     
29285 C8BE 161C  14        jne  MTT1                       ; BNE MTT1          ; down to MTT1 to skip the following and potentially
29286                                                                          ; spawn something else
29287               
29288 C8C0 D34E  18        movb rx,ra                      ; TXA               ; Set A to the random X we set above, which we haven't
29289 C8C2 1807  14        joc  MTT2                       ; BCS MTT2          ; used yet, and if the C flag is set (50% chance) jump
29290                                                                          ; down to MTT2 to skip the following
29291               
29292 C8C4 024D  22        andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
     C8C6 1F00     
29293 C8C8 026D  22        ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
     C8CA 1000     
29294 C8CC D80D  30        movb ra,@INWK+27                ; STA INWK+27
     C8CE 006E     
29295               
29296 C8D0 1704  14        jnc  MTT3                       ; BCC MTT3          ; Jump down to MTT3, skipping the following (this BCC
29297                                                                          ; is effectively a JMP as we know the C flag is clear,
29298                                                                          ; having passed through the BCS above)
29299               
29300               MTT2:
29301 C8D2 026D  22        ori  ra,>7f*256                 ; ORA #%01111111    ; Set bits 0-6 of A to 127, leaving bit 7 as random, so
     C8D4 7F00     
29302 C8D6 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; storing this number in the pitch counter means we have
     C8D8 0071     
29303                                                                          ; full pitch with no damping, with a 50% chance of
29304                                                                          ; pitching up or down
29305               
29306               MTT3:
29307 C8DA 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C8DC C7D0     
29308 C8DE 06A0  32        bl   @jsr                       ;
     C8E0 FE28     
29309               
29310 C8E2 028D  22        ci   ra,>05*256                 ; CMP #5            ; Set A to the ship number of an asteroid, and keep
     C8E4 0500     
29311 C8E6 020D  20        li   ra,(AST)*256               ; LDA #AST          ; this value for 98.5% of the time (i.e. if random
     C8E8 0A00     
29312 C8EA 1802  14        joc  B88                        ; BCS B88           ; A >= 5 then skip the following instruction)
29313               
29314 C8EC 020D  20        li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship number of a cargo canister
     C8EE 0B00     
29315               
29316               B88:
29317 C8F0 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Add our new asteroid or canister to the universe
     C8F2 B5DA     
29318 C8F4 06A0  32        bl   @jsr                       ;
     C8F6 FE28     
29319               
29320               * ******************************************************************************
29321               *
29322               * Name: Main game loop (Part 3 of 6)
29323               * Type: Subroutine
29324               * Category: Main loop
29325               * Summary: Potentially spawn a cop, particularly if we've been bad
29326               * Deep dive: Program flow of the main game loop
29327               * Ship data blocks
29328               * Fixing ship positions
29329               *
29330               * ------------------------------------------------------------------------------
29331               *
29332               * This section covers the following:
29333               *
29334               * * Potentially spawn a cop (in a Viper), very rarely if we have been good,
29335               * more often if have been naughty, and very often if we have been properly
29336               * bad
29337               *
29338               * ******************************************************************************
29339               
29340               MTT1:
29341 C8F8 D360  30        movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station's safe zone, jump
     C8FA 0D55     
29342 C8FC 1666  14        jne  MLOOP                      ; BNE MLOOP         ; to MLOOP to skip the following
29343               
29344 C8FE 0200  20        li   rtmp,BAD                   ; JSR BAD           ; Call BAD to work out how much illegal contraband we
     C900 CB8A     
29345 C902 06A0  32        bl   @jsr                       ;
     C904 FE28     
29346                                                                          ; are carrying in our hold (A is up to 40 for a
29347                                                                          ; standard hold crammed with contraband, up to 70 for
29348                                                                          ; an extended cargo hold full of narcotics and slaves)
29349               
29350                      .asla                           ; ASL A             ; Double A to a maximum of 80 or 140
     **** ****     > ASLA
0001 C906 024D  22        andi ra,>ff00
     C908 FF00     
0002 C90A 0A1D  18        sla  ra,1
                   < elite.a99
29351               
29352 C90C D3A0  30        movb @MANY+COPS,rx              ; LDX MANY+COPS     ; If there are no cops in the local bubble, skip the
     C90E 0D4F     
29353 C910 1302  14        jeq  B89                        ; BEQ B89           ; next instruction
29354               
29355 C912 F360  30        socb @FIST,ra                   ; ORA FIST          ; There are cops in the vicinity and we've got a hold
     C914 0334     
29356                                                                          ; full of jail time, so OR the value in A with FIST to
29357                                                                          ; get a new value that is at least as high as both
29358                                                                          ; values, to reflect the fact that they have almost
29359                                                                          ; certainly scanned our ship
29360               
29361               B89:
29362 C916 D80D  30        movb ra,@T                      ; STA T             ; Store our badness level in T
     C918 00D1     
29363               
29364 C91A 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C91C C786     
29365 C91E 06A0  32        bl   @jsr                       ;
     C920 FE28     
29366                                                                          ; ship, and set A and X to random values
29367                                                                          ;
29368                                                                          ; Note that because Ze uses the value of X returned by
29369                                                                          ; DORND, and X contains the value of A returned by the
29370                                                                          ; previous call to DORND, this does not set the new ship
29371                                                                          ; to a totally random location. See the deep dive on
29372                                                                          ; "Fixing ship positions" for details
29373               
29374 C922 9360  30        cb   @T,ra                      ; CMP T             ; If the random value in A >= our badness level, which
     C924 00D1     
29375 C926 1806  14        joc  B90                        ; BCS B90           ; will be the case unless we have been really, really
29376                                                                          ; bad, then skip the following two instructions (so
29377                                                                          ; if we are really bad, there's a higher chance of
29378                                                                          ; spawning a cop, otherwise we got away with it, for
29379                                                                          ; now)
29380               
29381 C928 020D  20        li   ra,(COPS)*256              ; LDA #COPS         ; Add a new police ship to the local bubble
     C92A 0200     
29382 C92C 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP
     C92E B5DA     
29383 C930 06A0  32        bl   @jsr                       ;
     C932 FE28     
29384               
29385               B90:
29386 C934 D360  30        movb @MANY+COPS,ra              ; LDA MANY+COPS     ; If we now have at least one cop in the local bubble,
     C936 0D4F     
29387 C938 1648  14        jne  MLOOP                      ; BNE MLOOP         ; jump down to MLOOP, otherwise fall through into the
29388                                                                          ; next part to look at spawning something else
29389               
29390               * ******************************************************************************
29391               *
29392               * Name: Main game loop (Part 4 of 6)
29393               * Type: Subroutine
29394               * Category: Main loop
29395               * Summary: Potentially spawn a lone bounty hunter, a Thargoid, or up to four
29396               * pirates
29397               * Deep dive: Program flow of the main game loop
29398               * Ship data blocks
29399               * Fixing ship positions
29400               *
29401               * ------------------------------------------------------------------------------
29402               *
29403               * This section covers the following:
29404               *
29405               * * Potentially spawn (35% chance) either a lone bounty hunter (a Mamba,
29406               * Python or Cobra Mk III), a Thargoid, or a group of up to 4 pirates
29407               * (Sidewinders and/or Mambas)
29408               *
29409               * ******************************************************************************
29410               
29411 C93A 7347  18        sb   rone,ra                    ; DEC EV            ; Decrement EV, the extra vessels spawning delay, and
29412 C93C 1546  14        jgt  MLOOP                      ; BPL MLOOP         ; jump to MLOOP if it is still positive, so we only
29413                                                                          ; do the following when the EV counter runs down
29414               
29415 C93E B347  18        ab   rone,ra                    ; INC EV            ; EV is negative, so bump it up again, setting it back
29416                                                                          ; to 0
29417               
29418 C940 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C942 C7D0     
29419 C944 06A0  32        bl   @jsr                       ;
     C946 FE28     
29420               
29421 C948 D3E0  30        movb @gov_,ry                   ; LDY gov           ; If the government of this system is 0 (anarchy), jump
     C94A 0F1C     
29422 C94C 1308  14        jeq  LABEL_2                    ; BEQ LABEL_2       ; straight to LABEL_2 to start spawning pirates or a
29423                                                                          ; lone bounty hunter
29424               
29425 C94E 028D  22        ci   ra,>5a*256                 ; CMP #90           ; If the random number in A >= 90 (65% chance), jump to
     C950 5A00     
29426 C952 183B  14        joc  MLOOP                      ; BCS MLOOP         ; MLOOP to stop spawning (so there's a 35% chance of
29427                                                                          ; spawning pirates or a lone bounty hunter)
29428               
29429 C954 024D  22        andi ra,>07*256                 ; AND #7            ; Reduce the random number in A to the range 0-7, and
     C956 0700     
29430 C958 9360  30        cb   @gov_,ra                   ; CMP gov           ; if A is less than government of this system, jump
     C95A 0F1C     
29431 C95C 1736  14        jnc  MLOOP                      ; BCC MLOOP         ; to MLOOP to stop spawning (so safer governments with
29432                                                                          ; larger gov numbers have a greater chance of jumping
29433                                                                          ; out, which is another way of saying that more
29434                                                                          ; dangerous systems spawn pirates and bounty hunters
29435                                                                          ; more often)
29436               
29437               LABEL_2:
29438                                                                          ; Now to spawn a lone bounty hunter, a Thargoid or a
29439                                                                          ; group of pirates
29440 C95E 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     C960 C786     
29441 C962 06A0  32        bl   @jsr                       ;
     C964 FE28     
29442                                                                          ; ship, and set A and X to random values
29443                                                                          ;
29444                                                                          ; Note that because Ze uses the value of X returned by
29445                                                                          ; DORND, and X contains the value of A returned by the
29446                                                                          ; previous call to DORND, this does not set the new ship
29447                                                                          ; to a totally random location. See the deep dive on
29448                                                                          ; "Fixing ship positions" for details
29449               
29450 C966 028D  22        ci   ra,>c8*256                 ; CMP #200          ; If the random number in A >= 200 (13% chance), jump
     C968 C800     
29451 C96A 181B  14        joc  mt1_                       ; BCS mt1           ; to mt1 to spawn pirates, otherwise keep going to
29452                                                                          ; spawn a lone bounty hunter or a Thargoid
29453               
29454 C96C B347  18        ab   rone,ra                    ; INC EV            ; Increase the extra vessels spawning counter, to
29455                                                                          ; prevent the next attempt to spawn extra vessels
29456               
29457 C96E 024D  22        andi ra,>03*256                 ; AND #3            ; Set A = Y = random number in the range 3-6, which
     C970 0300     
29458                      .adi (>03*256)                  ; ADC #3            ; we will use to determine the type of ship
     **** ****     > ADI
0001 C972 1701  14        jnc  !
0002 C974 B347  18        ab   rone,ra
0003               !:
0004 C976 022D  22        ai   ra,(>03*256)
     C978 0300     
                   < elite.a99
29459 C97A D3CD  18        movb ra,ry                      ; TAY
29460               
29461                                                                          ; We now build the AI flag for this ship in A
29462               
29463 C97C D34E  18        movb rx,ra                      ; TXA               ; First, copy the random number in X to A
29464               
29465 C97E 028D  22        ci   ra,>c8*256                 ; CMP #200          ; First, set the C flag if X >= 200 (22% chance)
     C980 C800     
29466               
29467 C982 06A0  32        bl   @rola                      ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 22%
     C984 FE3E     
29468                                                                          ; chance of this ship having E.C.M.)
29469               
29470 C986 026D  22        ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6)
     C988 C000     
29471                                                                          ; and has AI (bit 7)
29472               
29473 C98A 028F  22        ci   ry,>06*256                 ; CPY #6            ; If Y = 6 (i.e. a Thargoid), jump down to the tha
     C98C 0600     
29474 C98E 1347  14        jeq  tha_                       ; BEQ tha           ; routine in part 6 to decide whether or not to spawn it
29475                                                                          ; (where there's a 22% chance of this happening)
29476               
29477 C990 D80D  30        movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship
     C992 0073     
29478               
29479 C994 D34F  18        movb ry,ra                      ; TYA               ; Add a new ship of type Y to the local bubble, so
29480 C996 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; that's a Mamba, Cobra Mk III or Python
     C998 B5DA     
29481 C99A 06A0  32        bl   @jsr                       ;
     C99C FE28     
29482               
29483               mj1_:
29484 C99E 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP, as we are done spawning ships
     C9A0 C9CA     
29485               
29486               mt1_:
29487 C9A2 024D  22        andi ra,>03*256                 ; AND #3            ; It's time to spawn a group of pirates, so set A to a
     C9A4 0300     
29488                                                                          ; random number in the range 0-3, which will be the
29489                                                                          ; loop counter for spawning pirates below (so we will
29490                                                                          ; spawn 1-4 pirates)
29491               
29492 C9A6 D80D  30        movb ra,@EV                     ; STA EV            ; Delay further spawnings by this number
     C9A8 0D63     
29493               
29494 C9AA D80D  30        movb ra,@XX13                   ; STA XX13          ; Store the number in XX13, the pirate counter
     C9AC 0098     
29495               
29496               mt3_:
29497 C9AE 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     C9B0 C7D0     
29498 C9B2 06A0  32        bl   @jsr                       ;
     C9B4 FE28     
29499               
29500 C9B6 024D  22        andi ra,>03*256                 ; AND #3            ; Set A to a random number in the range 0-3
     C9B8 0300     
29501               
29502 C9BA 026D  22        ori  ra,>01*256                 ; ORA #1            ; Set A to %01 or %11 (Sidewinder or Mamba)
     C9BC 0100     
29503               
29504 C9BE 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP         ; Try adding a new ship of type A to the local bubble
     C9C0 B5DA     
29505 C9C2 06A0  32        bl   @jsr                       ;
     C9C4 FE28     
29506               
29507 C9C6 7347  18        sb   rone,ra                    ; DEC XX13          ; Decrement the pirate counter
29508               
29509 C9C8 15F2  14        jgt  mt3_                       ; BPL mt3           ; If we need more pirates, loop back up to mt3,
29510                                                                          ; otherwise we are done spawning, so fall through into
29511                                                                          ; the end of the main loop at MLOOP
29512               
29513               * ******************************************************************************
29514               *
29515               * Name: Main game loop (Part 5 of 6)
29516               * Type: Subroutine
29517               * Category: Main loop
29518               * Summary: Cool down lasers, make calls to update the dashboard
29519               * Deep dive: Program flow of the main game loop
29520               * The dashboard indicators
29521               *
29522               * ------------------------------------------------------------------------------
29523               *
29524               * This is the first half of the minimal game loop, which we iterate when we are
29525               * docked. This section covers the following:
29526               *
29527               * * Cool down lasers
29528               *
29529               * * Make calls to update the dashboard
29530               *
29531               * ------------------------------------------------------------------------------
29532               *
29533               * Other entry points:
29534               *
29535               * MLOOP               The entry point for the main game loop. This entry point
29536               * comes after the call to the main flight loop and
29537               * spawning routines, so it marks the start of the main
29538               * game loop for when we are docked (as we don't need to
29539               * call the main flight loop or spawning routines if we
29540               * aren't in space)
29541               *
29542               * ******************************************************************************
29543               
29544               MLOOP:
29545 C9CA 020D  20        li   ra,>01*256                 ; LDA #%00000001    ; Set 6522 System VIA interrupt enable register IER
     C9CC 0100     
29546 C9CE D80D  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. disable the CA2 interrupt,
     C9D0 FE4E     
29547                                                                          ; which comes from the keyboard)
29548               
29549 C9D2 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     C9D4 FF00     
29550 C9D6 D80E  30        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     C9D8 8315     
29551                                                                          ; effectively resets the stack
29552               
29553 C9DA D3A0  30        movb @GNTMP,rx                  ; LDX GNTMP         ; If the laser temperature in GNTMP is non-zero,
     C9DC 0D61     
29554 C9DE 1301  14        jeq  EE20                       ; BEQ EE20          ; decrement it (i.e. cool it down a bit)
29555 C9E0 7347  18        sb   rone,ra                    ; DEC GNTMP
29556               
29557               EE20:
29558 C9E2 0200  20        li   rtmp,DIALS                 ; JSR DIALS         ; Call DIALS to update the dashboard
     C9E4 3522     
29559 C9E6 06A0  32        bl   @jsr                       ;
     C9E8 FE28     
29560               
29561 C9EA D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, skip the following four
     C9EC 0096     
29562 C9EE 130A  14        jeq  B91                        ; BEQ B91           ; instructions (i.e. jump to JSR TT17 below)
29563               
29564                      .and @PATG                      ; AND PATG          ; If PATG = &FF (author names are shown on start-up)
     **** ****     > AND
0001 C9F0 D020  30        movb @PATG,rtmp
     C9F2 0F4C     
0002 C9F4 0540  14        inv  rtmp
0003 C9F6 5340  18        szcb rtmp,ra
                   < elite.a99
29565 C9F8 091D  18        srl  ra,1                       ; LSR A             ; and bit 0 of QQ11 is 1 (the current view is type 1),
29566 C9FA 1804  14        joc  B91                        ; BCS B91           ; then skip the following instruction
29567               
29568 C9FC 0200  20        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds), to
     C9FE 4FCB     
29569 CA00 06A0  32        bl   @jsr                       ;
     CA02 FE28     
29570                                                                          ; slow the main loop down a bit
29571               
29572               B91:
29573 CA04 0200  20        li   rtmp,TT17                  ; JSR TT17          ; Scan the keyboard for the cursor keys or joystick,
     CA06 C268     
29574 CA08 06A0  32        bl   @jsr                       ;
     CA0A FE28     
29575                                                                          ; returning the cursor's delta values in X and Y and
29576                                                                          ; the key pressed in A
29577               
29578               * ******************************************************************************
29579               *
29580               * Name: Main game loop (Part 6 of 6)
29581               * Type: Subroutine
29582               * Category: Main loop
29583               * Summary: Process non-flight key presses (red function keys, docked keys)
29584               * Deep dive: Program flow of the main game loop
29585               *
29586               * ------------------------------------------------------------------------------
29587               *
29588               * This is the second half of the minimal game loop, which we iterate when we are
29589               * docked. This section covers the following:
29590               *
29591               * * Process more key presses (red function keys, docked keys etc.)
29592               *
29593               * It also supports joining the main loop with a key already "pressed", so we can
29594               * jump into the main game loop to perform a specific action. In practice, this
29595               * is used when we enter the docking bay in BAY to display Status Mode (red key
29596               * f8), and when we finish buying or selling cargo in BAY2 to jump to the
29597               * Inventory (red key f9).
29598               *
29599               * ------------------------------------------------------------------------------
29600               *
29601               * Other entry points:
29602               *
29603               * FRCE                The entry point for the main game loop if we want to
29604               * jump straight to a specific screen, by pretending to
29605               * "press" a key, in which case A contains the internal key
29606               * number of the key we want to "press"
29607               *
29608               * tha                 Consider spawning a Thargoid (22% chance)
29609               *
29610               * ******************************************************************************
29611               
29612               FRCE:
29613 CA0C 0200  20        li   rtmp,TT102                 ; JSR TT102         ; Call TT102 to process the key pressed in A
     CA0E CA38     
29614 CA10 06A0  32        bl   @jsr                       ;
     CA12 FE28     
29615               
29616 CA14 D360  30        movb @QQ12,ra                   ; LDA QQ12          ; Fetch the docked flag from QQ12 into A
     CA16 009F     
29617               
29618 CA18 16D8  14        jne  MLOOP                      ; BNE MLOOP         ; If we are docked, loop back up to MLOOP just above
29619                                                                          ; to restart the main loop, but skipping all the flight
29620                                                                          ; and spawning code in the top part of the main loop
29621               
29622 CA1A 0460  28        b    @TT100                     ; JMP TT100         ; Otherwise jump to TT100 to restart the main loop from
     CA1C C82E     
29623                                                                          ; the start
29624               
29625               tha_:
29626 CA1E 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     CA20 C7D0     
29627 CA22 06A0  32        bl   @jsr                       ;
     CA24 FE28     
29628               
29629 CA26 028D  22        ci   ra,>c8*256                 ; CMP #200          ; If A < 200 (78% chance), skip the next instruction
     CA28 C800     
29630 CA2A 1704  14        jnc  B92                        ; BCC B92
29631               
29632 CA2C 0200  20        li   rtmp,GTHG                  ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
     CA2E A578     
29633 CA30 06A0  32        bl   @jsr                       ;
     CA32 FE28     
29634                                                                          ; companion
29635               
29636               B92:
29637 CA34 0460  28        b    @MLOOP                     ; JMP MLOOP         ; Jump back into the main loop at MLOOP, which is just
     CA36 C9CA     
29638                                                                          ; after the ship-spawning section
29639               
29640               * ******************************************************************************
29641               *
29642               * Name: TT102
29643               * Type: Subroutine
29644               * Category: Keyboard
29645               * Summary: Process function key, save key, hyperspace and chart key presses
29646               * and update the hyperspace counter
29647               *
29648               * ------------------------------------------------------------------------------
29649               *
29650               * Process function key presses, plus "@" (save commander), "H" (hyperspace),
29651               * "D" (show distance to system) and "O" (move chart cursor back to current
29652               * system). We can also pass cursor position deltas in X and Y to indicate that
29653               * the cursor keys or joystick have been used (i.e. the values that are returned
29654               * by routine TT17).
29655               *
29656               * ------------------------------------------------------------------------------
29657               *
29658               * Arguments:
29659               *
29660               * A                   The internal key number of the key pressed (see p.142 of
29661               * the Advanced User Guide for a list of internal key
29662               * numbers)
29663               *
29664               * X                   The amount to move the crosshairs in the x-axis
29665               *
29666               * Y                   The amount to move the crosshairs in the y-axis
29667               *
29668               * ------------------------------------------------------------------------------
29669               *
29670               * Other entry points:
29671               *
29672               * T95                 Print the distance to the selected system
29673               *
29674               * ******************************************************************************
29675               
29676               TT102:
29677 CA38 028D  22        ci   ra,(f8_)*256               ; CMP #f8           ; If red key f8 was pressed, jump to STATUS to show the
     CA3A 7600     
29678 CA3C 1602  14        jne  B93                        ; BNE B93           ; Status Mode screen, returning from the subroutine
29679 CA3E 0460  28        b    @STATUS                    ; JMP STATUS        ; using a tail call
     CA40 3096     
29680               
29681               B93:
29682 CA42 028D  22        ci   ra,(f4_)*256               ; CMP #f4           ; If red key f4 was pressed, jump to TT22 to show the
     CA44 1400     
29683 CA46 1602  14        jne  B94                        ; BNE B94           ; Long-range Chart, returning from the subroutine using
29684 CA48 0460  28        b    @TT22                      ; JMP TT22          ; a tail call
     CA4A 565A     
29685               
29686               B94:
29687 CA4C 028D  22        ci   ra,(f5_)*256               ; CMP #f5           ; If red key f5 was pressed, jump to TT23 to show the
     CA4E 7400     
29688 CA50 1602  14        jne  B95                        ; BNE B95           ; Short-range Chart, returning from the subroutine using
29689 CA52 0460  28        b    @TT23                      ; JMP TT23          ; a tail call
     CA54 5D32     
29690               
29691               B95:
29692 CA56 028D  22        ci   ra,(f6_)*256               ; CMP #f6           ; If red key f6 was pressed, call TT111 to select the
     CA58 7500     
29693 CA5A 1606  14        jne  TT92                       ; BNE TT92          ; system nearest to galactic coordinates (QQ9, QQ10)
29694 CA5C 0200  20        li   rtmp,TT111                 ; JSR TT111         ; (the location of the chart crosshairs) and jump to
     CA5E A000     
29695 CA60 06A0  32        bl   @jsr                       ;
     CA62 FE28     
29696 CA64 0460  28        b    @TT25                      ; JMP TT25          ; TT25 to show the Data on System screen, returning
     CA66 52F2     
29697                                                                          ; from the subroutine using a tail call
29698               
29699               TT92:
29700 CA68 028D  22        ci   ra,(f9_)*256               ; CMP #f9           ; If red key f9 was pressed, jump to TT213 to show the
     CA6A 7700     
29701 CA6C 1602  14        jne  B96                        ; BNE B96           ; Inventory screen, returning from the subroutine
29702 CA6E 0460  28        b    @TT213                     ; JMP TT213         ; using a tail call
     CA70 5B80     
29703               
29704               B96:
29705 CA72 028D  22        ci   ra,(f7_)*256               ; CMP #f7           ; If red key f7 was pressed, jump to TT167 to show the
     CA74 1600     
29706 CA76 1602  14        jne  B97                        ; BNE B97           ; Market Price screen, returning from the subroutine
29707 CA78 0460  28        b    @TT167                     ; JMP TT167         ; using a tail call
     CA7A A408     
29708               
29709               B97:
29710 CA7C 028D  22        ci   ra,(f0_)*256               ; CMP #f0           ; If red key f0 was pressed, jump to TT110 to launch our
     CA7E 2000     
29711 CA80 1602  14        jne  fvw_                       ; BNE fvw           ; ship (if docked), returning from the subroutine using
29712 CA82 0460  28        b    @TT110                     ; JMP TT110         ; a tail call
     CA84 A682     
29713               
29714               fvw_:
29715                      .bit @QQ12                      ; BIT QQ12          ; If bit 7 of QQ12 is clear (i.e. we are not docked, but
     **** ****     > BIT
0001 CA86 D020  30        movb @QQ12,rtmp
     CA88 009F     
0002 CA8A 0540  14        inv  rtmp
0003 CA8C D047  18        movb rone,rtmp2
0004 CA8E 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
29716 CA90 1514  14        jgt  INSP                       ; BPL INSP          ; in space), jump to INSP to skip the following checks
29717                                                                          ; for f1-f3 and "@" (save commander file) key presses
29718               
29719 CA92 028D  22        ci   ra,(f3_)*256               ; CMP #f3           ; If red key f3 was pressed, jump to EQSHP to show the
     CA94 7300     
29720 CA96 1602  14        jne  B98                        ; BNE B98           ; Equip Ship screen, returning from the subroutine using
29721 CA98 0460  28        b    @EQSHP                     ; JMP EQSHP         ; a tail call
     CA9A A7B4     
29722               
29723               B98:
29724 CA9C 028D  22        ci   ra,(f1_)*256               ; CMP #f1           ; If red key f1 was pressed, jump to TT219 to show the
     CA9E 7100     
29725 CAA0 1602  14        jne  B99                        ; BNE B99           ; Buy Cargo screen, returning from the subroutine using
29726 CAA2 0460  28        b    @TT219                     ; JMP TT219         ; a tail call
     CAA4 585E     
29727               
29728               B99:
29729 CAA6 028D  22        ci   ra,>47*256                 ; CMP #&47          ; If "@" was pressed, jump to SVE to save the commander
     CAA8 4700     
29730 CAAA 1602  14        jne  B100                       ; BNE B100          ; file, returning from the subroutine using a tail call
29731 CAAC 0460  28        b    @SVE                       ; JMP SVE
     CAAE CFC0     
29732               
29733               B100:
29734 CAB0 028D  22        ci   ra,(f2_)*256               ; CMP #f2           ; If red key f2 was pressed, jump to TT208 to show the
     CAB2 7200     
29735 CAB4 160D  14        jne  LABEL_3                    ; BNE LABEL_3       ; Sell Cargo screen, returning from the subroutine using
29736 CAB6 0460  28        b    @TT208                     ; JMP TT208         ; a tail call
     CAB8 5A4C     
29737               
29738               INSP:
29739 CABA 028D  22        ci   ra,(f1_)*256               ; CMP #f1           ; If the key pressed is < red key f1 or > red key f3,
     CABC 7100     
29740 CABE 1708  14        jnc  LABEL_3                    ; BCC LABEL_3       ; jump to LABEL_3 (so only do the following if the key
29741 CAC0 028D  22        ci   ra,(f3_+1)*256             ; CMP #f3+1         ; pressed is f1, f2 or f3)
     CAC2 7400     
29742 CAC4 1805  14        joc  LABEL_3                    ; BCS LABEL_3
29743               
29744 CAC6 024D  22        andi ra,>03*256                 ; AND #3            ; If we get here then we are either in space, or we are
     CAC8 0300     
29745 CACA D38D  18        movb ra,rx                      ; TAX               ; docked and none of f1-f3 were pressed, so we can now
29746 CACC 0460  28        b    @LOOK1                     ; JMP LOOK1         ; process f1-f3 with their in-flight functions, i.e.
     CACE 4E90     
29747                                                                          ; switching space views
29748                                                                          ;
29749                                                                          ; A will contain &71, &72 or &73 (for f1, f2 or f3), so
29750                                                                          ; set X to the last digit (1, 2 or 3) and jump to LOOK1
29751                                                                          ; to switch to view X (rear, left or right), returning
29752                                                                          ; from the subroutine using a tail call
29753               
29754               LABEL_3:
29755 CAD0 028D  22        ci   ra,>54*256                 ; CMP #&54          ; If "H" was pressed, jump to hyp to do a hyperspace
     CAD2 5400     
29756 CAD4 1602  14        jne  B101                       ; BNE B101          ; jump (if we are in space), returning from the
29757 CAD6 0460  28        b    @hyp_                      ; JMP hyp           ; subroutine using a tail call
     CAD8 A184     
29758               
29759               B101:
29760 CADA 028D  22        ci   ra,>32*256                 ; CMP #&32          ; If "D" was pressed, jump to T95 to print the distance
     CADC 3200     
29761 CADE 133B  14        jeq  T95                        ; BEQ T95           ; to a system (if we are in one of the chart screens)
29762               
29763 CAE0 D80D  30        movb ra,@T1                     ; STA T1            ; Store A (the key that's been pressed) in T1
     CAE2 0006     
29764               
29765 CAE4 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     CAE6 0096     
29766 CAE8 024D  22        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise jump down to TT107 to skip the
     CAEA C000     
29767 CAEC 1318  14        jeq  TT107                      ; BEQ TT107         ; following
29768               
29769 CAEE D360  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is non-zero,
     CAF0 002F     
29770 CAF2 1615  14        jne  TT107                      ; BNE TT107         ; then we are already counting down, so jump to TT107
29771                                                                          ; to skip the following
29772               
29773 CAF4 D360  30        movb @T1,ra                     ; LDA T1            ; Restore the original value of A (the key that's been
     CAF6 0006     
29774                                                                          ; pressed) from T1
29775               
29776 CAF8 028D  22        ci   ra,>36*256                 ; CMP #&36          ; If "O" was pressed, do the following three jumps,
     CAFA 3600     
29777 CAFC 160C  14        jne  ee2_                       ; BNE ee2           ; otherwise skip to ee2 to continue
29778               
29779 CAFE 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     CB00 5C7A     
29780 CB02 06A0  32        bl   @jsr                       ;
     CB04 FE28     
29781                                                                          ; which will erase the crosshairs currently there
29782               
29783 CB06 0200  20        li   rtmp,ping_                 ; JSR ping          ; Set the target system to the current system (which
     CB08 C300     
29784 CB0A 06A0  32        bl   @jsr                       ;
     CB0C FE28     
29785                                                                          ; will move the location in (QQ9, QQ10) to the current
29786                                                                          ; home system
29787               
29788 CB0E 0200  20        li   rtmp,TT103                 ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
     CB10 5C7A     
29789 CB12 06A0  32        bl   @jsr                       ;
     CB14 FE28     
29790                                                                          ; which will draw the crosshairs at our current home
29791                                                                          ; system
29792               
29793               ee2_:
29794 CB16 0200  20        li   rtmp,TT16                  ; JSR TT16          ; Call TT16 to move the crosshairs by the amount in X
     CB18 5C16     
29795 CB1A 06A0  32        bl   @jsr                       ;
     CB1C FE28     
29796                                                                          ; and Y, which were passed to this subroutine as
29797                                                                          ; arguments
29798               
29799               TT107:
29800 CB1E D360  30        movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is zero, return
     CB20 002F     
29801 CB22 1317  14        jeq  t95_                       ; BEQ t95           ; from the subroutine (as t95 contains an RTS), as we
29802                                                                          ; are not currently counting down to a hyperspace jump
29803               
29804 CB24 7347  18        sb   rone,ra                    ; DEC QQ22          ; Decrement the internal hyperspace counter
29805               
29806 CB26 1615  14        jne  t95_                       ; BNE t95           ; If the internal hyperspace counter is still non-zero,
29807                                                                          ; then we are still counting down, so return from the
29808                                                                          ; subroutine (as t95 contains an RTS)
29809               
29810                                                                          ; If we get here then the internal hyperspace counter
29811                                                                          ; has just reached zero and it wasn't zero before, so
29812                                                                          ; we need to reduce the on-screen counter and update
29813                                                                          ; the screen. We do this by first printing the next
29814                                                                          ; number in the countdown sequence, and then printing
29815                                                                          ; the old number, which will erase the old number
29816                                                                          ; and display the new one because printing uses EOR
29817                                                                          ; logic
29818               
29819 CB28 D3A0  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter - 1
     CB2A 002F     
29820 CB2C 7387  18        sb   rone,rx                    ; DEX               ; (i.e. the next number in the sequence)
29821               
29822 CB2E 0200  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1)
     CB30 A292     
29823 CB32 06A0  32        bl   @jsr                       ;
     CB34 FE28     
29824               
29825 CB36 020D  20        li   ra,>05*256                 ; LDA #5            ; Reset the internal hyperspace counter to 5
     CB38 0500     
29826 CB3A D80D  30        movb ra,@QQ22                   ; STA QQ22
     CB3C 002E     
29827               
29828 CB3E D3A0  30        movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter (i.e. the
     CB40 002F     
29829                                                                          ; current number in the sequence, which is already
29830                                                                          ; shown on-screen)
29831               
29832 CB42 0200  20        li   rtmp,ee3_                  ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
     CB44 A292     
29833 CB46 06A0  32        bl   @jsr                       ;
     CB48 FE28     
29834                                                                          ; i.e. print the hyperspace countdown in the top-left
29835                                                                          ; corner
29836               
29837 CB4A 7347  18        sb   rone,ra                    ; DEC QQ22+1        ; Decrement the on-screen hyperspace countdown
29838               
29839 CB4C 1602  14        jne  t95_                       ; BNE t95           ; If the countdown is not yet at zero, return from the
29840                                                                          ; subroutine (as t95 contains an RTS)
29841               
29842 CB4E 0460  28        b    @TT18                      ; JMP TT18          ; Otherwise the countdown has finished, so jump to TT18
     CB50 A600     
29843                                                                          ; to do a hyperspace jump, returning from the subroutine
29844                                                                          ; using a tail call
29845               
29846               t95_:
29847 CB52 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CB54 FE34     
29848               
29849               T95:
29850                                                                          ; If we get here, "D" was pressed, so we need to show
29851                                                                          ; the distance to the selected system (if we are in a
29852                                                                          ; chart view)
29853 CB56 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
     CB58 0096     
29854 CB5A 024D  22        andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise return from the subroutine (as
     CB5C C000     
29855 CB5E 13F9  14        jeq  t95_                       ; BEQ t95           ; t95 contains an RTS)
29856               
29857 CB60 0200  20        li   rtmp,hm_                   ; JSR hm            ; Call hm to move the crosshairs to the target system
     CB62 4FE0     
29858 CB64 06A0  32        bl   @jsr                       ;
     CB66 FE28     
29859                                                                          ; in (QQ9, QQ10), returning with A = 0
29860               
29861 CB68 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0 to switch to ALL CAPS
     CB6A 007E     
29862               
29863 CB6C 0200  20        li   rtmp,cpl_                  ; JSR cpl           ; Print control code 3 (the selected system name)
     CB6E AB54     
29864 CB70 06A0  32        bl   @jsr                       ;
     CB72 FE28     
29865               
29866 CB74 020D  20        li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
     CB76 8000     
29867 CB78 D80D  30        movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals
     CB7A 007E     
29868               
29869 CB7C 020D  20        li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1 and down one line
     CB7E 0100     
29870 CB80 D80D  30        movb ra,@XC                     ; STA XC            ; (in other words, to the start of the next line)
     CB82 002C     
29871 CB84 B347  18        ab   rone,ra                    ; INC YC
29872               
29873 CB86 0460  28        b    @TT146                     ; JMP TT146         ; Print the distance to the selected system and return
     CB88 528A     
29874                                                                          ; from the subroutine using a tail call
29875               
29876               * ******************************************************************************
29877               *
29878               * Name: BAD
29879               * Type: Subroutine
29880               * Category: Status
29881               * Summary: Calculate how bad we have been
29882               *
29883               * ------------------------------------------------------------------------------
29884               *
29885               * Work out how bad we are from the amount of contraband in our hold. The
29886               * formula is:
29887               *
29888               * (slaves + narcotics) * 2 + firearms
29889               *
29890               * so slaves and narcotics are twice as illegal as firearms. The value in FIST
29891               * (our legal status) is set to at least this value whenever we launch from a
29892               * space station, and a FIST of 50 or more gives us fugitive status, so leaving a
29893               * station carrying 25 tonnes of slaves/narcotics, or 50 tonnes of firearms
29894               * across multiple trips, is enough to make us a fugitive.
29895               *
29896               * ------------------------------------------------------------------------------
29897               *
29898               * Returns:
29899               *
29900               * A                   A value that determines how bad we are from the amount
29901               * of contraband in our hold
29902               *
29903               * ******************************************************************************
29904               
29905               BAD:
29906 CB8A D360  30        movb @QQ20+3,ra                 ; LDA QQ20+3        ; Set A to the number of tonnes of slaves in the hold
     CB8C 031A     
29907               
29908                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 CB8E 0A16  18        sla  rzero,1
                   < elite.a99
29909                                                                          ; C flag affecting the result
29910               
29911                      .adc @QQ20+6,ra                 ; ADC QQ20+6        ; Add the number of tonnes of narcotics in the hold
     **** ****     > ADC
0001 CB90 1701  14        jnc  !
0002 CB92 B347  18        ab   rone,ra
0003               !:
0004 CB94 B360  30        ab   @QQ20+6,ra
     CB96 031D     
                   < elite.a99
29912               
29913                      .asla                           ; ASL A             ; Double the result and add the number of tonnes of
     **** ****     > ASLA
0001 CB98 024D  22        andi ra,>ff00
     CB9A FF00     
0002 CB9C 0A1D  18        sla  ra,1
                   < elite.a99
29914                      .adc @QQ20+10,ra                ; ADC QQ20+10       ; firearms in the hold
     **** ****     > ADC
0001 CB9E 1701  14        jnc  !
0002 CBA0 B347  18        ab   rone,ra
0003               !:
0004 CBA2 B360  30        ab   @QQ20+10,ra
     CBA4 0321     
                   < elite.a99
29915               
29916 CBA6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CBA8 FE34     
29917               
29918               * ******************************************************************************
29919               *
29920               * Name: FAROF
29921               * Type: Subroutine
29922               * Category: Maths (Geometry)
29923               * Summary: Compare x_hi, y_hi and z_hi with 224
29924               *
29925               * ------------------------------------------------------------------------------
29926               *
29927               * Compare x_hi, y_hi and z_hi with 224, and set the C flag if all three <= 224,
29928               * otherwise clear the C flag.
29929               *
29930               * ------------------------------------------------------------------------------
29931               *
29932               * Returns:
29933               *
29934               * C flag              Set if x_hi <= 224 and y_hi <= 224 and z_hi <= 224
29935               *
29936               * Clear otherwise (i.e. if any one of them are bigger than
29937               * 224)
29938               *
29939               * ******************************************************************************
29940               
29941               FAROF:
29942 CBAA 020D  20        li   ra,>e0*256                 ; LDA #224          ; Set A = 224 and fall through into FAROF2 to do the
     CBAC E000     
29943                                                                          ; comparison
29944               
29945               * ******************************************************************************
29946               *
29947               * Name: FAROF2
29948               * Type: Subroutine
29949               * Category: Maths (Geometry)
29950               * Summary: Compare x_hi, y_hi and z_hi with A
29951               *
29952               * ------------------------------------------------------------------------------
29953               *
29954               * Compare x_hi, y_hi and z_hi with A, and set the C flag if all three <= A,
29955               * otherwise clear the C flag.
29956               *
29957               * ------------------------------------------------------------------------------
29958               *
29959               * Returns:
29960               *
29961               * C flag              Set if x_hi <= A and y_hi <= A and z_hi <= A
29962               *
29963               * Clear otherwise (i.e. if any one of them are bigger than
29964               * A)
29965               *
29966               * ******************************************************************************
29967               
29968               FAROF2:
29969 CBAE 9360  30        cb   @INWK+1,ra                 ; CMP INWK+1        ; If A < x_hi, C will be clear so jump to MA34 to
     CBB0 0054     
29970 CBB2 1705  14        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29971                                                                          ; C will be set so move on to the next one
29972               
29973 CBB4 9360  30        cb   @INWK+4,ra                 ; CMP INWK+4        ; If A < y_hi, C will be clear so jump to MA34 to
     CBB6 0057     
29974 CBB8 1702  14        jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
29975                                                                          ; C will be set so move on to the next one
29976               
29977 CBBA 9360  30        cb   @INWK+7,ra                 ; CMP INWK+7        ; If A < z_hi, C will be clear, otherwise C will be set
     CBBC 005A     
29978               
29979               MA34:
29980 CBBE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CBC0 FE34     
29981               
29982               * ******************************************************************************
29983               *
29984               * Name: MAS4
29985               * Type: Subroutine
29986               * Category: Maths (Geometry)
29987               * Summary: Calculate a cap on the maximum distance to a ship
29988               *
29989               * ------------------------------------------------------------------------------
29990               *
29991               * Logical OR the value in A with the high bytes of the ship's position (x_hi,
29992               * y_hi and z_hi).
29993               *
29994               * ------------------------------------------------------------------------------
29995               *
29996               * Returns:
29997               *
29998               * A                   A OR x_hi OR y_hi OR z_hi
29999               *
30000               * ******************************************************************************
30001               
30002               MAS4:
30003 CBC2 F360  30        socb @INWK+1,ra                 ; ORA INWK+1        ; OR A with x_hi, y_hi and z_hi
     CBC4 0054     
30004 CBC6 F360  30        socb @INWK+4,ra                 ; ORA INWK+4
     CBC8 0057     
30005 CBCA F360  30        socb @INWK+7,ra                 ; ORA INWK+7
     CBCC 005A     
30006               
30007 CBCE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CBD0 FE34     
30008               
30009               * ******************************************************************************
30010               *
30011               * Name: DEATH
30012               * Type: Subroutine
30013               * Category: Start and end
30014               * Summary: Display the death screen
30015               *
30016               * ------------------------------------------------------------------------------
30017               *
30018               * We have been killed, so display the chaos of our destruction above a "GAME
30019               * OVER" sign, and clean up the mess ready for the next attempt.
30020               *
30021               * ******************************************************************************
30022               
30023               DEATH:
30024 CBD2 0200  20        li   rtmp,EXNO3                 ; JSR EXNO3         ; Make the sound of us dying
     CBD4 D2BE     
30025 CBD6 06A0  32        bl   @jsr                       ;
     CBD8 FE28     
30026               
30027 CBDA 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     CBDC C682     
30028 CBDE 06A0  32        bl   @jsr                       ;
     CBE0 FE28     
30029               
30030                      .asl @DELTA                     ; ASL DELTA         ; Divide our speed in DELTA by 4
     **** ****     > ASL
0001 CBE2 D020  30        movb @DELTA,rtmp
     CBE4 008C     
0002 CBE6 0240  22        andi rtmp,>ff00
     CBE8 FF00     
0003 CBEA 0A10  18        sla  rtmp,1
0004 CBEC D800  30        movb rtmp,@DELTA
     CBEE 008C     
                   < elite.a99
30031                      .asl @DELTA                     ; ASL DELTA
     **** ****     > ASL
0001 CBF0 D020  30        movb @DELTA,rtmp
     CBF2 008C     
0002 CBF4 0240  22        andi rtmp,>ff00
     CBF6 FF00     
0003 CBF8 0A10  18        sla  rtmp,1
0004 CBFA D800  30        movb rtmp,@DELTA
     CBFC 008C     
                   < elite.a99
30032               
30033 CBFE 020E  20        li   rx,>18*256                 ; LDX #24           ; Set the screen to only show 24 text rows, which hides
     CC00 1800     
30034 CC02 0200  20        li   rtmp,DET1                  ; JSR DET1          ; the dashboard, setting A to 6 in the process
     CC04 B2E4     
30035 CC06 06A0  32        bl   @jsr                       ;
     CC08 FE28     
30036               
30037 CC0A 0200  20        li   rtmp,TT66                  ; JSR TT66          ; Clear the top part of the screen, draw a white border,
     CC0C 4EFA     
30038 CC0E 06A0  32        bl   @jsr                       ;
     CC10 FE28     
30039                                                                          ; and set the current view type in QQ11 to 6 (death
30040                                                                          ; screen)
30041               
30042 CC12 0200  20        li   rtmp,BOX                   ; JSR BOX           ; Call BOX to redraw the same white border (BOX is part
     CC14 4F3A     
30043 CC16 06A0  32        bl   @jsr                       ;
     CC18 FE28     
30044                                                                          ; of TT66), which removes the border as it is drawn
30045                                                                          ; using EOR logic
30046               
30047 CC1A 0200  20        li   rtmp,nWq                   ; JSR nWq           ; Create a cloud of stardust containing the correct
     CC1C B1EC     
30048 CC1E 06A0  32        bl   @jsr                       ;
     CC20 FE28     
30049                                                                          ; number of dust particles (i.e. NOSTM of them)
30050               
30051 CC22 020D  20        li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12 on row 12
     CC24 0C00     
30052 CC26 D80D  30        movb ra,@YC                     ; STA YC
     CC28 002D     
30053 CC2A D80D  30        movb ra,@XC                     ; STA XC
     CC2C 002C     
30054               
30055 CC2E 020D  20        li   ra,>92*256                 ; LDA #146          ; Print recursive token 146 ("{all caps}GAME OVER")
     CC30 9200     
30056 CC32 0200  20        li   rtmp,ex_                   ; JSR ex
     CC34 ADC2     
30057 CC36 06A0  32        bl   @jsr                       ;
     CC38 FE28     
30058               
30059               D1:
30060 CC3A 0200  20        li   rtmp,Ze                    ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
     CC3C C786     
30061 CC3E 06A0  32        bl   @jsr                       ;
     CC40 FE28     
30062                                                                          ; ship, and set A and X to random values
30063               
30064 CC42 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 4, so A is now between 0 and 63, and
30065 CC44 091D  18        srl  ra,1                       ; LSR A             ; store in byte #0 (x_lo)
30066 CC46 D80D  30        movb ra,@INWK                   ; STA INWK
     CC48 0053     
30067               
30068 CC4A 020F  20        li   ry,>00*256                 ; LDY #0            ; Set the following to 0: the current view in QQ11
     CC4C 0000     
30069 CC4E D80F  30        movb ry,@QQ11                   ; STY QQ11          ; (space view), x_hi, y_hi, z_hi and the AI flag (no AI
     CC50 0096     
30070 CC52 D80F  30        movb ry,@INWK+1                 ; STY INWK+1        ; or E.C.M. and not hostile)
     CC54 0054     
30071 CC56 D80F  30        movb ry,@INWK+4                 ; STY INWK+4
     CC58 0057     
30072 CC5A D80F  30        movb ry,@INWK+7                 ; STY INWK+7
     CC5C 005A     
30073 CC5E D80F  30        movb ry,@INWK+32                ; STY INWK+32
     CC60 0073     
30074               
30075 CC62 73C7  18        sb   rone,ry                    ; DEY               ; Set Y = 255
30076               
30077 CC64 D80F  30        movb ry,@MCNT                   ; STY MCNT          ; Reset the main loop counter to 255, so all timer-based
     CC66 0099     
30078                                                                          ; calls will be stopped
30079               
30080 CC68 D80F  30        movb ry,@LASCT                  ; STY LASCT         ; Set the laser count to 255 to act as a counter in the
     CC6A 0D60     
30081                                                                          ; D2 loop below, so this setting determines how long the
30082                                                                          ; death animation lasts (it's 5.1 seconds, as LASCT is
30083                                                                          ; decremented every vertical sync, or 50 times a second,
30084                                                                          ; and 255 / 50 = 5.1)
30085               
30086                      .eoi (>2a*256)                  ; EOR #%00101010    ; Flip bits 1, 3 and 5 in A (x_lo) to get another number
     **** ****     > EOI
0001 CC6C 0200  20        li   rtmp,(>2A*256)
     CC6E 2A00     
0002 CC70 2B40  18        xor  rtmp,ra
                   < elite.a99
30087 CC72 D80D  30        movb ra,@INWK+3                 ; STA INWK+3        ; between 48 and 63, and store in byte #3 (y_lo)
     CC74 0056     
30088               
30089 CC76 026D  22        ori  ra,>50*256                 ; ORA #%01010000    ; Set bits 4 and 6 of A to bump it up to between 112 and
     CC78 5000     
30090 CC7A D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; 127, and store in byte #6 (z_lo)
     CC7C 0059     
30091               
30092 CC7E D34E  18        movb rx,ra                      ; TXA               ; Set A to the random number in X and keep bits 0-3 and
30093 CC80 024D  22        andi ra,>8f*256                 ; AND #%10001111    ; the sign in bit 7 to get a number between -15 and +15,
     CC82 8F00     
30094 CC84 D80D  30        movb ra,@INWK+29                ; STA INWK+29       ; and store in byte #29 (roll counter) to give our ship
     CC86 0070     
30095                                                                          ; a gentle roll with damping
30096               
30097 CC88 06A0  32        bl   @rora                      ; ROR A             ; The C flag is randomly set from the above call to Ze,
     CC8A FE62     
30098 CC8C 024D  22        andi ra,>87*256                 ; AND #%10000111    ; so this sets A to a number between -7 and +7, which
     CC8E 8700     
30099 CC90 D80D  30        movb ra,@INWK+30                ; STA INWK+30       ; we store in byte #30 (the pitch counter) to give our
     CC92 0071     
30100                                                                          ; ship a very gentle pitch with damping
30101               
30102                      .php                            ; PHP               ; Store the processor flags
     **** ****     > PHP
0001 CC94 02C0  12        stst rtmp
0002 CC96 D680  30        movb rtmp,*rsp
0003 CC98 060A  14        dec  rsp
                   < elite.a99
30103               
30104 CC9A 020E  20        li   rx,(OIL)*256               ; LDX #OIL          ; Call fq1 with X set to #OIL, which adds a new cargo
     CC9C 0B00     
30105 CC9E 0200  20        li   rtmp,fq1_                  ; JSR fq1           ; canister to our local bubble of universe and points it
     CCA0 3F3C     
30106 CCA2 06A0  32        bl   @jsr                       ;
     CCA4 FE28     
30107                                                                          ; away from us with double DELTA speed (i.e. 6, as DELTA
30108                                                                          ; was set to 3 by the call to RES2 above). INF is set to
30109                                                                          ; point to the canister's ship data block in K%
30110               
30111                      .plp                            ; PLP               ; Restore the processor flags, including our random C
     **** ****     > PLP
0001 CCA6 058A  14        inc  rsp
0002 CCA8 D01A  26        movb *rsp,rtmp
0003                      ; todo: restore status
                   < elite.a99
30112                                                                          ; flag from before
30113               
30114 CCAA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to our random C flag and store in byte
     CCAC 0000     
30115 CCAE 06A0  32        bl   @rora                      ; ROR A             ; #31 of the ship's data block, so this has a 50% chance
     CCB0 FE62     
30116 CCB2 020F  20        li   ry,>1f*256                 ; LDY #31           ; of marking our new canister as being killed (so it
     CCB4 1F00     
30117                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; will explode)
     **** ****     > ST_IND_Y_IDX
0001 CCB6 D820  42        movb @INF,@rtmplb
     CCB8 0020     
     CCBA 8301     
0002 CCBC D020  30        movb @INF+1,rtmp
     CCBE 0021     
0003 CCC0 06CF  14        swpb ry
0004 CCC2 A00F  18        a    ry,rtmp
0005 CCC4 06CF  14        swpb ry
0006 CCC6 D40D  30        movb RA,*rtmp
                   < elite.a99
30118               
30119 CCC8 D360  30        movb @FRIN+3,ra                 ; LDA FRIN+3        ; The call we made to RES2 before we entered the loop at
     CCCA 0D43     
30120 CCCC 13B6  14        jeq  D1                         ; BEQ D1            ; D1 will have reset all the ship slots at FRIN, so this
30121                                                                          ; checks to see if the fourth slot is empty, and if it
30122                                                                          ; is we loop back to D1 to add another canister, until
30123                                                                          ; we have added four of them
30124               
30125 CCCE 0200  20        li   rtmp,U.                    ; JSR U%            ; Clear the key logger, which also sets A = 0
     CCD0 D49E     
30126 CCD2 06A0  32        bl   @jsr                       ;
     CCD4 FE28     
30127               
30128 CCD6 D80D  30        movb ra,@DELTA                  ; STA DELTA         ; Set our speed in DELTA to 0, as we aren't going
     CCD8 008C     
30129                                                                          ; anywhere any more
30130               
30131               D2:
30132 CCDA 0200  20        li   rtmp,M.                    ; JSR M%            ; Call the M% routine to do the main flight loop once,
     CCDC 0F52     
30133 CCDE 06A0  32        bl   @jsr                       ;
     CCE0 FE28     
30134                                                                          ; which will display our exploding canister scene and
30135                                                                          ; move everything about
30136               
30137 CCE2 D360  30        movb @LASCT,ra                  ; LDA LASCT         ; Loop back to D2 to run the main flight loop until
     CCE4 0D60     
30138 CCE6 16F9  14        jne  D2                         ; BNE D2            ; LASCT reaches zero (which will take 5.1 seconds, as
30139                                                                          ; explained above)
30140               
30141 CCE8 020E  20        li   rx,>1f*256                 ; LDX #31           ; Set the screen to show all 31 text rows, which shows
     CCEA 1F00     
30142 CCEC 0200  20        li   rtmp,DET1                  ; JSR DET1          ; the dashboard
     CCEE B2E4     
30143 CCF0 06A0  32        bl   @jsr                       ;
     CCF2 FE28     
30144               
30145                                                                          ; Fall through into DEATH2 to reset and restart the game
30146               
30147               * ******************************************************************************
30148               *
30149               * Name: DEATH2
30150               * Type: Subroutine
30151               * Category: Start and end
30152               * Summary: Reset most of the game and restart from the title screen
30153               *
30154               * ------------------------------------------------------------------------------
30155               *
30156               * This routine is called following death, and when the game is quit by pressing
30157               * ESCAPE when paused.
30158               *
30159               * ******************************************************************************
30160               
30161               DEATH2:
30162 CCF4 0200  20        li   rtmp,RES2                  ; JSR RES2          ; Reset a number of flight variables and workspaces
     CCF6 C682     
30163 CCF8 06A0  32        bl   @jsr                       ;
     CCFA FE28     
30164                                                                          ; and fall through into the entry code for the game
30165                                                                          ; to restart from the title screen
30166               
30167               * ******************************************************************************
30168               *
30169               * Name: TT170
30170               * Type: Subroutine
30171               * Category: Start and end
30172               * Summary: Main entry point for the Elite game code
30173               * Deep dive: Program flow of the main game loop
30174               *
30175               * ------------------------------------------------------------------------------
30176               *
30177               * This is the main entry point for the main game code.
30178               *
30179               * ******************************************************************************
30180               
30181               TT170:
30182 CCFC 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
     CCFE FF00     
30183 CD00 D80E  30        movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
     CD02 8315     
30184                                                                          ; effectively resets the stack. We need to do this
30185                                                                          ; because the loader code in elite-loader.asm pushes
30186                                                                          ; code onto the stack, and this effectively removes that
30187                                                                          ; code so we start afresh
30188               
30189                                                                          ; Fall through into BR1 to start the game
30190               
30191               * ******************************************************************************
30192               *
30193               * Name: BR1 (Part 1 of 2)
30194               * Type: Subroutine
30195               * Category: Start and end
30196               * Summary: Show the "Load New Commander (Y/N)?" screen and start the game
30197               *
30198               * ------------------------------------------------------------------------------
30199               *
30200               * BRKV is set to point to BR1 by the loading process.
30201               *
30202               * ******************************************************************************
30203               
30204               BR1:
30205 CD04 020E  20        li   rx,>03*256                 ; LDX #3            ; Set XC = 3 (set text cursor to column 3)
     CD06 0300     
30206 CD08 D80E  30        movb rx,@XC                     ; STX XC
     CD0A 002C     
30207               
30208 CD0C 0200  20        li   rtmp,FX200                 ; JSR FX200         ; Disable the ESCAPE key and clear memory if the BREAK
     CD0E D0FA     
30209 CD10 06A0  32        bl   @jsr                       ;
     CD12 FE28     
30210                                                                          ; key is pressed (*FX 200,3)
30211               
30212 CD14 020E  20        li   rx,(CYL)*256               ; LDX #CYL          ; Call TITLE to show a rotating Cobra Mk III (#CYL) and
     CD16 0700     
30213 CD18 020D  20        li   ra,>80*256                 ; LDA #128          ; token 128 ("  LOAD NEW COMMANDER (Y/N)?{crlf}{crlf}"),
     CD1A 8000     
30214 CD1C 0200  20        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     CD1E CDCC     
30215 CD20 06A0  32        bl   @jsr                       ;
     CD22 FE28     
30216                                                                          ; in A
30217               
30218 CD24 028D  22        ci   ra,>44*256                 ; CMP #&44          ; Did we press "Y"? If not, jump to QU5, otherwise
     CD26 4400     
30219 CD28 1610  14        jne  QU5                        ; BNE QU5           ; continue on to load a new commander
30220               
30221               * BR1                    \ These instructions are commented out in the original
30222               * LDX #3                 \ source. This block starts with the same *FX call as
30223               * STX XC                 \ above, then clears the screen, calls a routine to
30224               * JSR FX200              \ flush the keyboard buffer (FLKB) that isn't present
30225               * LDA #1                 \ in the cassette version but is in other versions,
30226               * JSR TT66               \ and then it displays "LOAD NEW COMMANDER (Y/N)?" and
30227               * JSR FLKB               \ lists the current cargo, before falling straight into
30228               * LDA #14                \ the load routine below, whether or not we have
30229               * JSR TT214              \ pressed "Y". This may be a bit of testing code, as the
30230               * BCC QU5                \ first line is a commented label, BR1, which is where
30231                                                                          ; BRKV points, so when this is uncommented, pressing
30232                                                                          ; the BREAK key should jump straight to the load screen
30233               
30234 CD2A 0200  20        li   rtmp,GTNME                 ; JSR GTNME         ; We want to load a new commander, so we need to get
     CD2C CF28     
30235 CD2E 06A0  32        bl   @jsr                       ;
     CD30 FE28     
30236                                                                          ; the commander name to load
30237               
30238 CD32 0200  20        li   rtmp,LOD                   ; JSR LOD           ; We then call the LOD subroutine to load the commander
     CD34 D0AC     
30239 CD36 06A0  32        bl   @jsr                       ;
     CD38 FE28     
30240                                                                          ; file to address NA%+8, which is where we store the
30241                                                                          ; commander save file
30242               
30243 CD3A 0200  20        li   rtmp,TRNME                 ; JSR TRNME         ; Once loaded, we copy the commander name to NA%
     CD3C CEF4     
30244 CD3E 06A0  32        bl   @jsr                       ;
     CD40 FE28     
30245               
30246 CD42 0200  20        li   rtmp,TTX66                 ; JSR TTX66         ; And we clear the top part of the screen and draw a
     CD44 4EFE     
30247 CD46 06A0  32        bl   @jsr                       ;
     CD48 FE28     
30248                                                                          ; white border
30249               
30250               * ******************************************************************************
30251               *
30252               * Name: QU5
30253               * Type: Subroutine
30254               * Category: Start and end
30255               * Summary: Reset the current commander data block to the last saved commander
30256               *
30257               * ******************************************************************************
30258               
30259               QU5:
30260                                                                          ; By the time we get here, the correct commander name
30261                                                                          ; is at NA% and the correct commander data is at NA%+8.
30262                                                                          ; Specifically:
30263                                                                          ;
30264                                                                          ; * If we loaded a commander file, then the name and
30265                                                                          ; data from that file will be at NA% and NA%+8
30266                                                                          ;
30267                                                                          ; * If this is a brand new game, then NA% will contain
30268                                                                          ; the default starting commander name ("JAMESON")
30269                                                                          ; and NA%+8 will contain the default commander data
30270                                                                          ;
30271                                                                          ; * If this is not a new game (because they died or
30272                                                                          ; quit) and we didn't want to load a commander file,
30273                                                                          ; then NA% will contain the last saved commander
30274                                                                          ; name, and NA%+8 the last saved commander data. If
30275                                                                          ; the game has never been saved, this will still be
30276                                                                          ; the default commander
30277               * JSR TTX66              \ This instruction is commented out in the original
30278                                                                          ; source; it clears the screen and draws a border
30279 CD4A 020E  20        li   rx,(NT.)*256               ; LDX #NT%          ; The size of the commander data block is NT% bytes,
     CD4C 4B00     
30280                                                                          ; and it starts at NA%+8, so we need to copy the data
30281                                                                          ; from the "last saved" buffer at NA%+8 to the current
30282                                                                          ; commander workspace at TP. So we set up a counter in X
30283                                                                          ; for the NT% bytes that we want to copy
30284               
30285               QUL1:
30286 CD4E 06CE  14        swpb rx                         ;
30287 CD50 D36E  34        movb @NA.+7(rx),ra              ; LDA NA%+7,X       ; Copy the X-th byte of NA%+7 to the X-th byte of TP-1,
     CD52 233F     
30288 CD54 06CE  14        swpb rx                         ;
30289 CD56 06CE  14        swpb rx                         ;
30290 CD58 DB8D  38        movb ra,@TP-1(rx)               ; STA TP-1,X        ; (the -1 is because X is counting down from NT% to 1)
     CD5A 02FF     
30291 CD5C 06CE  14        swpb rx                         ;
30292               
30293 CD5E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30294               
30295 CD60 16F6  14        jne  QUL1                       ; BNE QUL1          ; Loop back for the next byte of the commander data
30296                                                                          ; block
30297               
30298 CD62 D80E  30        movb rx,@QQ11                   ; STX QQ11          ; X is 0 by the end of the above loop, so this sets QQ11
     CD64 0096     
30299                                                                          ; to 0, which means we will be showing a view without a
30300                                                                          ; boxed title at the top (i.e. we're going to use the
30301                                                                          ; screen layout of a space view in the following)
30302               
30303                                                                          ; If the commander check below fails, we keep jumping
30304                                                                          ; back to here to crash the game with an infinite loop
30305               
30306               B102:
30307 CD66 0200  20        li   rtmp,CHECK                 ; JSR CHECK         ; Call the CHECK subroutine to calculate the checksum
     CD68 CECE     
30308 CD6A 06A0  32        bl   @jsr                       ;
     CD6C FE28     
30309                                                                          ; for the current commander block at NA%+8 and put it
30310                                                                          ; in A
30311               
30312 CD6E 9360  34        cb   @CHK,ra                    ; CMP CHK           ; Test the calculated checksum against CHK
     CD70 238E     
30313               
30315               
30316 CD72 1000  14        nop                             ; NOP               ; If we have disabled checksums, then ignore the result
30317 CD74 1000  14        nop                             ; NOP               ; of the comparison and fall through into the next part
30318               
30327               
30328                                                                          ; The checksum CHK is correct, so now we check whether
30329                                                                          ; CHK2 = CHK EOR A9, and if this check fails, bit 7 of
30330                                                                          ; the competition flags at COK gets set, to indicate
30331                                                                          ; to Acornsoft via the competition code that there has
30332                                                                          ; been some hacking going on with this competition entry
30333               
30334                      .eoi (>a9*256)                  ; EOR #&A9          ; X = checksum EOR &A9
     **** ****     > EOI
0001 CD76 0200  20        li   rtmp,(>A9*256)
     CD78 A900     
0002 CD7A 2B40  18        xor  rtmp,ra
                   < elite.a99
30335 CD7C D38D  18        movb ra,rx                      ; TAX
30336               
30337 CD7E D360  30        movb @COK,ra                    ; LDA COK           ; Set A to the competition flags in COK
     CD80 030E     
30338               
30339 CD82 93A0  34        cb   @CHK2,rx                   ; CPX CHK2          ; If X = CHK2, then skip the next instruction
     CD84 238D     
30340 CD86 1302  14        jeq  tZ                         ; BEQ tZ
30341               
30342 CD88 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A to indicate this commander file has
     CD8A 8000     
30343                                                                          ; been tampered with
30344               
30345               tZ:
30346 CD8C 026D  22        ori  ra,>02*256                 ; ORA #%00000010    ; Set bit 1 of A to denote that this is the cassette
     CD8E 0200     
30347                                                                          ; version
30348               
30349 CD90 D80D  30        movb ra,@COK                    ; STA COK           ; Store the updated competition flags in COK
     CD92 030E     
30350               
30351               * ******************************************************************************
30352               *
30353               * Name: BR1 (Part 2 of 2)
30354               * Type: Subroutine
30355               * Category: Start and end
30356               * Summary: Show the "Press Fire or Space, Commander" screen and start the
30357               * game
30358               *
30359               * ------------------------------------------------------------------------------
30360               *
30361               * BRKV is set to point to BR1 by the loading process.
30362               *
30363               * ******************************************************************************
30364               
30365 CD94 0200  20        li   rtmp,msblob_               ; JSR msblob        ; Reset the dashboard's missile indicators so none of
     CD96 C73C     
30366 CD98 06A0  32        bl   @jsr                       ;
     CD9A FE28     
30367                                                                          ; them are targeted
30368               
30369 CD9C 020D  20        li   ra,>93*256                 ; LDA #147          ; Call TITLE to show a rotating Mamba (#3) and token
     CD9E 9300     
30370 CDA0 020E  20        li   rx,>03*256                 ; LDX #3            ; 147 ("PRESS FIRE OR SPACE,COMMANDER.{crlf}{crlf}"),
     CDA2 0300     
30371 CDA4 0200  20        li   rtmp,TITLE                 ; JSR TITLE         ; returning with the internal number of the key pressed
     CDA6 CDCC     
30372 CDA8 06A0  32        bl   @jsr                       ;
     CDAA FE28     
30373                                                                          ; in A
30374               
30375 CDAC 0200  20        li   rtmp,ping_                 ; JSR ping          ; Set the target system coordinates (QQ9, QQ10) to the
     CDAE C300     
30376 CDB0 06A0  32        bl   @jsr                       ;
     CDB2 FE28     
30377                                                                          ; current system coordinates (QQ0, QQ1) we just loaded
30378               
30379 CDB4 0200  20        li   rtmp,hyp1_                 ; JSR hyp1          ; Arrive in the system closest to (QQ9, QQ10)
     CDB6 A494     
30380 CDB8 06A0  32        bl   @jsr                       ;
     CDBA FE28     
30381               
30382                                                                          ; Fall through into the docking bay routine below
30383               
30384               * ******************************************************************************
30385               *
30386               * Name: BAY
30387               * Type: Subroutine
30388               * Category: Status
30389               * Summary: Go to the docking bay (i.e. show the Status Mode screen)
30390               *
30391               * ------------------------------------------------------------------------------
30392               *
30393               * We end up here after the start-up process (load commander etc.), as well as
30394               * after a successful save, an escape pod launch, a successful docking, the end
30395               * of a cargo sell, and various errors (such as not having enough cash, entering
30396               * too many items when buying, trying to fit an item to your ship when you
30397               * already have it, running out of cargo space, and so on).
30398               *
30399               * ******************************************************************************
30400               
30401               BAY:
30402 CDBC 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set QQ12 = &FF (the docked flag) to indicate that we
     CDBE FF00     
30403 CDC0 D80D  30        movb ra,@QQ12                   ; STA QQ12          ; are docked
     CDC2 009F     
30404               
30405 CDC4 020D  20        li   ra,(f8_)*256               ; LDA #f8           ; Jump into the main loop at FRCE, setting the key
     CDC6 7600     
30406 CDC8 0460  28        b    @FRCE                      ; JMP FRCE          ; that's "pressed" to red key f8 (so we show the Status
     CDCA CA0C     
30407                                                                          ; Mode screen)
30408               
30409               * ******************************************************************************
30410               *
30411               * Name: TITLE
30412               * Type: Subroutine
30413               * Category: Start and end
30414               * Summary: Display a title screen with a rotating ship and prompt
30415               *
30416               * ------------------------------------------------------------------------------
30417               *
30418               * Display the title screen, with a rotating ship and a text token at the bottom
30419               * of the screen.
30420               *
30421               * ------------------------------------------------------------------------------
30422               *
30423               * Arguments:
30424               *
30425               * A                   The number of the recursive token to show below the
30426               * rotating ship (see variable QQ18 for details of
30427               * recursive tokens)
30428               *
30429               * X                   The type of the ship to show (see variable XX21 for a
30430               * list of ship types)
30431               *
30432               * ------------------------------------------------------------------------------
30433               *
30434               * Returns:
30435               *
30436               * X                   If a key is being pressed, X contains the internal key
30437               * number, otherwise it contains 0
30438               *
30439               * ******************************************************************************
30440               
30441               TITLE:
30442                      .pha                            ; PHA               ; Store the token number on the stack for later
     **** ****     > PHA
0001 CDCC D68D  30        movb ra,*rsp
0002 CDCE 060A  14        dec  rsp
                   < elite.a99
30443               
30444 CDD0 D80E  30        movb rx,@TYPE                   ; STX TYPE          ; Store the ship type in location TYPE
     CDD2 009B     
30445               
30446 CDD4 0200  20        li   rtmp,RESET                 ; JSR RESET         ; Reset our ship so we can use it for the rotating
     CDD6 C652     
30447 CDD8 06A0  32        bl   @jsr                       ;
     CDDA FE28     
30448                                                                          ; title ship
30449               
30450 CDDC 020D  20        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     CDDE 0100     
30451 CDE0 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     CDE2 4EFA     
30452 CDE4 06A0  32        bl   @jsr                       ;
     CDE6 FE28     
30453               
30454 CDE8 7347  18        sb   rone,ra                    ; DEC QQ11          ; Decrement QQ11 to 0, so from here on we are using a
30455                                                                          ; space view
30456               
30457 CDEA 020D  20        li   ra,>60*256                 ; LDA #96           ; Set nosev_z hi = 96 (96 is the value of unity in the
     CDEC 6000     
30458 CDEE D80D  30        movb ra,@INWK+14                ; STA INWK+14       ; rotation vector)
     CDF0 0061     
30459               
30460               * LSR A                  \ This instruction is commented out in the original
30461                                                                          ; source. It would halve the value of z_hi to 48, so the
30462                                                                          ; ship would start off closer to the viewer
30463               
30464 CDF2 D80D  30        movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi, the high byte of the ship's z-coordinate,
     CDF4 005A     
30465                                                                          ; to 96, which is the distance at which the rotating
30466                                                                          ; ship starts out before coming towards us
30467               
30468 CDF6 020E  20        li   rx,>7f*256                 ; LDX #127          ; Set roll counter = 127, so don't dampen the roll and
     CDF8 7F00     
30469 CDFA D80E  30        movb rx,@INWK+29                ; STX INWK+29       ; make the roll direction clockwise
     CDFC 0070     
30470               
30471 CDFE D80E  30        movb rx,@INWK+30                ; STX INWK+30       ; Set pitch counter = 127, so don't dampen the pitch and
     CE00 0071     
30472                                                                          ; set the pitch direction to dive
30473               
30474 CE02 B387  18        ab   rone,rx                    ; INX               ; Set QQ17 to 128 (so bit 7 is set) to switch to
30475 CE04 D80E  30        movb rx,@QQ17                   ; STX QQ17          ; Sentence Case, with the next letter printing in upper
     CE06 007E     
30476                                                                          ; case
30477               
30478 CE08 D360  30        movb @TYPE,ra                   ; LDA TYPE          ; Set up a new ship, using the ship type in TYPE
     CE0A 009B     
30479 CE0C 0200  20        li   rtmp,NWSHP                 ; JSR NWSHP
     CE0E B5DA     
30480 CE10 06A0  32        bl   @jsr                       ;
     CE12 FE28     
30481               
30482 CE14 020F  20        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6
     CE16 0600     
30483 CE18 D80F  30        movb ry,@XC                     ; STY XC
     CE1A 002C     
30484               
30485 CE1C 0200  20        li   rtmp,DELAY                 ; JSR DELAY         ; Delay for 6 vertical syncs (6/50 = 0.12 seconds)
     CE1E 4FD0     
30486 CE20 06A0  32        bl   @jsr                       ;
     CE22 FE28     
30487               
30488 CE24 020D  20        li   ra,>1e*256                 ; LDA #30           ; Print recursive token 144 ("---- E L I T E ----")
     CE26 1E00     
30489 CE28 0200  20        li   rtmp,plf_                  ; JSR plf           ; followed by a newline
     CE2A AC88     
30490 CE2C 06A0  32        bl   @jsr                       ;
     CE2E FE28     
30491               
30492 CE30 020F  20        li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6 again
     CE32 0600     
30493 CE34 D80F  30        movb ry,@XC                     ; STY XC
     CE36 002C     
30494               
30495 CE38 B347  18        ab   rone,ra                    ; INC YC            ; Move the text cursor down a row
30496               
30497 CE3A D360  30        movb @PATG,ra                   ; LDA PATG          ; If PATG = 0, skip the following two lines, which
     CE3C 0F4C     
30498 CE3E 1306  14        jeq  awe_                       ; BEQ awe           ; print the author credits (PATG can be toggled by
30499                                                                          ; pausing the game and pressing "X")
30500               
30501 CE40 020D  20        li   ra,>fe*256                 ; LDA #254          ; Print recursive token 94 ("BY D.BRABEN & I.BELL")
     CE42 FE00     
30502 CE44 0200  20        li   rtmp,TT27                  ; JSR TT27
     CE46 ACA0     
30503 CE48 06A0  32        bl   @jsr                       ;
     CE4A FE28     
30504               
30505               awe_:
30506 CE4C 0200  20        li   rtmp,CLYNS                 ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
     CE4E 4FFE     
30507 CE50 06A0  32        bl   @jsr                       ;
     CE52 FE28     
30508                                                                          ; and move the text cursor to column 1 on row 21, i.e.
30509                                                                          ; the start of the top row of the three bottom rows.
30510                                                                          ; It also returns with Y = 0
30511               
30512 CE54 D80F  30        movb ry,@DELTA                  ; STY DELTA         ; Set DELTA = 0 (i.e. ship speed = 0)
     CE56 008C     
30513               
30514 CE58 D80F  30        movb ry,@JSTK                   ; STY JSTK          ; Set JSTK = 0 (i.e. keyboard, not joystick)
     CE5A 0F50     
30515               
30516                      .pla                            ; PLA               ; Restore the recursive token number we stored on the
     **** ****     > PLA
0001 CE5C 058A  14        inc  rsp
0002 CE5E D35A  26        movb *rsp,ra
                   < elite.a99
30517 CE60 0200  20        li   rtmp,ex_                   ; JSR ex            ; stack at the start of this subroutine, and print that
     CE62 ADC2     
30518 CE64 06A0  32        bl   @jsr                       ;
     CE66 FE28     
30519                                                                          ; token
30520               
30521 CE68 020D  20        li   ra,>94*256                 ; LDA #148          ; Set A to recursive token 148
     CE6A 9400     
30522               
30523 CE6C 020E  20        li   rx,>07*256                 ; LDX #7            ; Move the text cursor to column 7
     CE6E 0700     
30524 CE70 D80E  30        movb rx,@XC                     ; STX XC
     CE72 002C     
30525               
30526 CE74 0200  20        li   rtmp,ex_                   ; JSR ex            ; Print recursive token 148 ("(C) ACORNSOFT 1984")
     CE76 ADC2     
30527 CE78 06A0  32        bl   @jsr                       ;
     CE7A FE28     
30528               
30529               TLL2:
30530 CE7C D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi (the ship's distance) is 1, jump to TL1 to
     CE7E 005A     
30531 CE80 028D  22        ci   ra,>01*256                 ; CMP #1            ; skip the following decrement
     CE82 0100     
30532 CE84 1301  14        jeq  TL1                        ; BEQ TL1
30533               
30534 CE86 7347  18        sb   rone,ra                    ; DEC INWK+7        ; Decrement the ship's distance, to bring the ship
30535                                                                          ; a bit closer to us
30536               
30537               TL1:
30538 CE88 0200  20        li   rtmp,MVEIT                 ; JSR MVEIT         ; Move the ship in space according to the orientation
     CE8A 184A     
30539 CE8C 06A0  32        bl   @jsr                       ;
     CE8E FE28     
30540                                                                          ; vectors and the new value in z_hi
30541               
30542 CE90 020D  20        li   ra,>80*256                 ; LDA #128          ; Set z_lo = 128, so the closest the ship gets to us is
     CE92 8000     
30543 CE94 D80D  30        movb ra,@INWK+6                 ; STA INWK+6        ; z_hi = 1, z_lo = 128, or 256 + 128 = 384
     CE96 0059     
30544               
30545                      .asla                           ; ASL A             ; Set A = 0
     **** ****     > ASLA
0001 CE98 024D  22        andi ra,>ff00
     CE9A FF00     
0002 CE9C 0A1D  18        sla  ra,1
                   < elite.a99
30546               
30547 CE9E D80D  30        movb ra,@INWK                   ; STA INWK          ; Set x_lo = 0, so the ship remains in the screen centre
     CEA0 0053     
30548               
30549 CEA2 D80D  30        movb ra,@INWK+3                 ; STA INWK+3        ; Set y_lo = 0, so the ship remains in the screen centre
     CEA4 0056     
30550               
30551 CEA6 0200  20        li   rtmp,LL9                   ; JSR LL9           ; Call LL9 to display the ship
     CEA8 DCBC     
30552 CEAA 06A0  32        bl   @jsr                       ;
     CEAC FE28     
30553               
30554 CEAE 7347  18        sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter
30555               
30556 CEB0 D360  34        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     CEB2 FE40     
30557               
30558 CEB4 024D  22        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     CEB6 1000     
30559                                                                          ; button is pressed, otherwise it is set, so AND'ing
30560                                                                          ; the value of IRB with %10000 extracts this bit
30561               
30562               * TAX                    \ This instruction is commented out in the original
30563                                                                          ; source; it would have no effect, as the comparison
30564                                                                          ; flags are already set by the AND, and the value of X
30565                                                                          ; is not used anywhere
30566               
30567 CEB8 1307  14        jeq  TL2                        ; BEQ TL2           ; If the joystick fire button is pressed, jump to TL2
30568               
30569 CEBA 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press
     CEBC D284     
30570 CEBE 06A0  32        bl   @jsr                       ;
     CEC0 FE28     
30571               
30572 CEC2 13DC  14        jeq  TLL2                       ; BEQ TLL2          ; If no key was pressed, loop back up to move/rotate
30573                                                                          ; the ship and check again for a key press
30574               
30575 CEC4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CEC6 FE34     
30576               
30577               TL2:
30578 CEC8 7347  18        sb   rone,ra                    ; DEC JSTK          ; Joystick fire button was pressed, so set JSTK to &FF
30579                                                                          ; (it was set to 0 above), to disable keyboard and
30580                                                                          ; enable joysticks
30581               
30582 CECA 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CECC FE34     
30583               
30584               * ******************************************************************************
30585               *
30586               * Name: CHECK
30587               * Type: Subroutine
30588               * Category: Save and load
30589               * Summary: Calculate the checksum for the last saved commander data block
30590               * Deep dive: Commander save files
30591               *
30592               * ------------------------------------------------------------------------------
30593               *
30594               * The checksum for the last saved commander data block is saved as part of the
30595               * commander file, in two places (CHK AND CHK2), to protect against file
30596               * tampering. This routine calculates the checksum and returns it in A.
30597               *
30598               * This algorithm is also implemented in elite-checksum.py.
30599               *
30600               * ------------------------------------------------------------------------------
30601               *
30602               * Returns:
30603               *
30604               * A                   The checksum for the last saved commander data block
30605               *
30606               * ******************************************************************************
30607               
30608               CHECK:
30609 CECE 020E  20        li   rx,(NT.-2)*256             ; LDX #NT%-2        ; Set X to the size of the commander data block, less
     CED0 4900     
30610                                                                          ; 2 (to omit the checksum bytes and the save count)
30611               
30612                      .clc                            ; CLC               ; Clear the C flag so we can do addition without the
     **** ****     > CLC
0001 CED2 0A16  18        sla  rzero,1
                   < elite.a99
30613                                                                          ; C flag affecting the result
30614               
30615 CED4 D34E  18        movb rx,ra                      ; TXA               ; Seed the checksum calculation by setting A to the
30616                                                                          ; size of the commander data block, less 2
30617               
30618                                                                          ; We now loop through the commander data block,
30619                                                                          ; starting at the end and looping down to the start
30620                                                                          ; (so at the start of this loop, the X-th byte is the
30621                                                                          ; last byte of the commander data block, i.e. the save
30622                                                                          ; count)
30623               
30624               QUL2:
30625 CED6 06CE  14        swpb rx                         ;
30626                      .adc @NA.+7(rx),ra              ; ADC NA%+7,X       ; Add the X-1-th byte of the data block to A, plus the
     **** ****     > ADC
0001 CED8 1701  14        jnc  !
0002 CEDA B347  18        ab   rone,ra
0003               !:
0004 CEDC B36E  34        ab   @NA.+7(RX),ra
     CEDE 233F     
                   < elite.a99
30627 CEE0 06CE  14        swpb rx                         ;
30628                                                                          ; C flag
30629               
30630 CEE2 06CE  14        swpb rx                         ;
30631                      .eor @NA.+8(rx)                 ; EOR NA%+8,X       ; EOR A with the X-th byte of the data block
     **** ****     > EOR
0001 CEE4 D02E  34        movb @NA.+8(RX),rtmp
     CEE6 2340     
0002 CEE8 2B40  18        xor  rtmp,ra
                   < elite.a99
30632 CEEA 06CE  14        swpb rx                         ;
30633               
30634 CEEC 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30635               
30636 CEEE 16F3  14        jne  QUL2                       ; BNE QUL2          ; Loop back for the next byte in the calculation, until
30637                                                                          ; we have added byte #0 and EOR'd with byte #1 of the
30638                                                                          ; data block
30639               
30640 CEF0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CEF2 FE34     
30641               
30642               * ******************************************************************************
30643               *
30644               * Name: TRNME
30645               * Type: Subroutine
30646               * Category: Save and load
30647               * Summary: Copy the last saved commander's name from INWK to NA%
30648               *
30649               * ******************************************************************************
30650               
30651               TRNME:
30652 CEF4 020E  20        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     CEF6 0700     
30653                                                                          ; characters, and is terminated by a carriage return,
30654                                                                          ; so set up a counter in X to copy 8 characters
30655               
30656               GTL1:
30657 CEF8 06CE  14        swpb rx                         ;
30658 CEFA D36E  34        movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte of INWK to the X-th byte of NA%
     CEFC 0053     
30659 CEFE 06CE  14        swpb rx                         ;
30660 CF00 06CE  14        swpb rx                         ;
30661 CF02 DB8D  38        movb ra,@NA.(rx)                ; STA NA%,X
     CF04 2338     
30662 CF06 06CE  14        swpb rx                         ;
30663               
30664 CF08 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30665               
30666 CF0A 15F6  14        jgt  GTL1                       ; BPL GTL1          ; Loop back until we have copied all 8 bytes
30667               
30668                                                                          ; Fall through into TR1 to copy the name back from NA%
30669                                                                          ; to INWK. This isn't necessary as the name is already
30670                                                                          ; there, but it does save one byte, as we don't need an
30671                                                                          ; RTS here
30672               
30673               * ******************************************************************************
30674               *
30675               * Name: TR1
30676               * Type: Subroutine
30677               * Category: Save and load
30678               * Summary: Copy the last saved commander's name from NA% to INWK
30679               *
30680               * ******************************************************************************
30681               
30682               TR1:
30683 CF0C 020E  20        li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
     CF0E 0700     
30684                                                                          ; characters, and is terminated by a carriage return,
30685                                                                          ; so set up a counter in X to copy 8 characters
30686               
30687               GTL2:
30688 CF10 06CE  14        swpb rx                         ;
30689 CF12 D36E  34        movb @NA.(rx),ra                ; LDA NA%,X         ; Copy the X-th byte of NA% to the X-th byte of INWK
     CF14 2338     
30690 CF16 06CE  14        swpb rx                         ;
30691 CF18 06CE  14        swpb rx                         ;
30692 CF1A DB8D  38        movb ra,@INWK(rx)               ; STA INWK,X
     CF1C 0053     
30693 CF1E 06CE  14        swpb rx                         ;
30694               
30695 CF20 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30696               
30697 CF22 15F6  14        jgt  GTL2                       ; BPL GTL2          ; Loop back until we have copied all 8 bytes
30698               
30699 CF24 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CF26 FE34     
30700               
30701               * ******************************************************************************
30702               *
30703               * Name: GTNME
30704               * Type: Subroutine
30705               * Category: Save and load
30706               * Summary: Fetch the name of a commander file to save or load
30707               *
30708               * ------------------------------------------------------------------------------
30709               *
30710               * Get the commander's name for loading or saving a commander file. The name is
30711               * stored in the INWK workspace and is terminated by a return character (13).
30712               *
30713               * If ESCAPE is pressed or a blank name is entered, then the name stored is set
30714               * to the name from the last saved commander block.
30715               *
30716               * ------------------------------------------------------------------------------
30717               *
30718               * Returns:
30719               *
30720               * INWK                The commander name entered, terminated by a return
30721               * character (13)
30722               *
30723               * ******************************************************************************
30724               
30725               GTNME:
30726 CF28 020D  20        li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
     CF2A 0100     
30727 CF2C 0200  20        li   rtmp,TT66                  ; JSR TT66          ; and set the current view type in QQ11 to 1
     CF2E 4EFA     
30728 CF30 06A0  32        bl   @jsr                       ;
     CF32 FE28     
30729               
30730 CF34 020D  20        li   ra,>7b*256                 ; LDA #123          ; Print recursive token 123 ("{crlf}COMMANDER'S NAME? ")
     CF36 7B00     
30731 CF38 0200  20        li   rtmp,TT27                  ; JSR TT27
     CF3A ACA0     
30732 CF3C 06A0  32        bl   @jsr                       ;
     CF3E FE28     
30733               
30734 CF40 0200  20        li   rtmp,DEL8                  ; JSR DEL8          ; Wait for 8/50 of a second (0.16 seconds)
     CF42 4FCC     
30735 CF44 06A0  32        bl   @jsr                       ;
     CF46 FE28     
30736               
30737 CF48 020D  20        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     CF4A 8100     
30738 CF4C D80D  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     CF4E FE4E     
30739                                                                          ; which comes from the keyboard)
30740               
30741 CF50 020D  20        li   ra,>0f*256                 ; LDA #15           ; Call OSBYTE with A = 15 (flush all buffers)
     CF52 0F00     
30742 CF54 D38D  18        movb ra,rx                      ; TAX
30743 CF56 0200  20        li   rtmp,OSBYTE                ; JSR OSBYTE
     CF58 FE22     
30744 CF5A 06A0  32        bl   @jsr                       ;
     CF5C FE28     
30745               
30746 CF5E 020E  20        li   rx,((RLINE)%256)*256       ; LDX #LO(RLINE)    ; Set (Y X) to point to the RLINE parameter block
     CF60 8400     
30747 CF62 020F  20        li   ry,((RLINE)/256)*256       ; LDY #HI(RLINE)    ; configuration block below
     CF64 D000     
30748               
30749 CF66 020D  20        li   ra,>00*256                 ; LDA #0            ; Call OSWORD with A = 0 to read a line from the current
     CF68 0000     
30750 CF6A 0200  20        li   rtmp,OSWORD                ; JSR OSWORD        ; input stream (i.e. the keyboard)
     CF6C FE24     
30751 CF6E 06A0  32        bl   @jsr                       ;
     CF70 FE28     
30752               
30753               * LDA #%00000001         \ These instructions are commented out in the original
30754               * STA VIA+&4E            \ source, but they would set 6522 System VIA interrupt
30755                                                                          ; enable register IER (SHEILA &4E) bit 1 (i.e. disable
30756                                                                          ; the CA2 interrupt, which comes from the keyboard)
30757               
30758 CF72 18CC  14        joc  TR1                        ; BCS TR1           ; The C flag will be set if we pressed ESCAPE when
30759                                                                          ; entering the name, in which case jump to TR1 to copy
30760                                                                          ; the last saved commander's name from NA% to INWK
30761                                                                          ; and return from the subroutine there
30762               
30763 CF74 D34F  18        movb ry,ra                      ; TYA               ; The OSWORD call returns the length of the commander's
30764                                                                          ; name in Y, so transfer this to A
30765               
30766 CF76 13CA  14        jeq  TR1                        ; BEQ TR1           ; If A = 0, no name was entered, so jump to TR1 to copy
30767                                                                          ; the last saved commander's name from NA% to INWK
30768                                                                          ; and return from the subroutine there
30769               
30770 CF78 0460  28        b    @TT67                      ; JMP TT67          ; We have a name, so jump to TT67 to print a newline
     CF7A 52CE     
30771                                                                          ; and return from the subroutine using a tail call
30772               
30773               * ******************************************************************************
30774               *
30775               * Name: RLINE
30776               * Type: Variable
30777               * Category: Text
30778               * Summary: The OSWORD configuration block used to fetch a line of text from
30779               * the keyboard
30780               *
30781               * ******************************************************************************
30782               
30783               RLINE:
30784 CF7C 0053            data INWK                                           ; The address to store the input, so the commander's
30785                                                                          ; name will be stored in INWK as it is typed
30786               
30787 CF7E 07              byte >07                                            ; Maximum line length = 7, as that's the maximum size
30788                                                                          ; for a commander's name
30789               
30790 CF7F   21            byte '!'                                            ; Allow ASCII characters from "!" through to "z" in
30791 CF80 7A              byte 'z'                                            ; the name
30792               
30793               * ******************************************************************************
30794               *
30795               * Name: ZERO
30796               * Type: Subroutine
30797               * Category: Utility routines
30798               * Summary: Zero-fill pages &9, &A, &B, &C and &D
30799               *
30800               * ------------------------------------------------------------------------------
30801               *
30802               * This resets the following workspaces to zero:
30803               *
30804               * * The ship data blocks ascending from K% at &0900
30805               *
30806               * * The ship line heap descending from WP at &0D40
30807               *
30808               * * WP workspace variables from FRIN to de, which include the ship slots for
30809               * the local bubble of universe, and various flight and ship status variables
30810               * (only a portion of the LSX/LSO sun line heap is cleared)
30811               *
30812               * ******************************************************************************
30813               
30814               ZERO:
30815 CF82 020E  20        li   rx,>0d*256                 ; LDX #&D           ; Point X to page &D
     CF84 0D00     
30816               
30817               ZEL:
30818 CF86 0200  20        li   rtmp,ZES1                  ; JSR ZES1          ; Call ZES1 to zero-fill the page in X
     CF88 CF96     
30819 CF8A 06A0  32        bl   @jsr                       ;
     CF8C FE28     
30820               
30821 CF8E 7387  18        sb   rone,rx                    ; DEX               ; Decrement X to point to the next page
30822               
30823 CF90 028E  22        ci   rx,>09*256                 ; CPX #9            ; If X is > 9 (i.e. is &A, &B or &C), then loop back
     CF92 0900     
30824 CF94 16F8  14        jne  ZEL                        ; BNE ZEL           ; up to clear the next page
30825               
30826                                                                          ; Then fall through into ZES1 with X set to 9, so we
30827                                                                          ; clear page &9 too
30828               
30829               * ******************************************************************************
30830               *
30831               * Name: ZES1
30832               * Type: Subroutine
30833               * Category: Utility routines
30834               * Summary: Zero-fill the page whose number is in X
30835               *
30836               * ------------------------------------------------------------------------------
30837               *
30838               * Arguments:
30839               *
30840               * X                   The page we want to zero-fill
30841               *
30842               * ******************************************************************************
30843               
30844               ZES1:
30845 CF96 020F  20        li   ry,>00*256                 ; LDY #0            ; If we set Y = SC = 0 and fall through into ZES2
     CF98 0000     
30846 CF9A D80F  30        movb ry,@SC                     ; STY SC            ; below, then we will zero-fill 255 bytes starting from
     CF9C 0007     
30847                                                                          ; SC - in other words, we will zero-fill the whole of
30848                                                                          ; page X
30849               
30850               * ******************************************************************************
30851               *
30852               * Name: ZES2
30853               * Type: Subroutine
30854               * Category: Utility routines
30855               * Summary: Zero-fill a specific page
30856               *
30857               * ------------------------------------------------------------------------------
30858               *
30859               * Zero-fill from address (X SC) + Y to (X SC) + &FF.
30860               *
30861               * ------------------------------------------------------------------------------
30862               *
30863               * Arguments:
30864               *
30865               * X                   The high byte (i.e. the page) of the starting point of
30866               * the zero-fill
30867               *
30868               * Y                   The offset from (X SC) where we start zeroing, counting
30869               * up to &FF
30870               *
30871               * SC                  The low byte (i.e. the offset into the page) of the
30872               * starting point of the zero-fill
30873               *
30874               * ------------------------------------------------------------------------------
30875               *
30876               * Returns:
30877               *
30878               * Z flag              Z flag is set
30879               *
30880               * ******************************************************************************
30881               
30882               ZES2:
30883 CF9E 020D  20        li   ra,>00*256                 ; LDA #0            ; Load A with the byte we want to fill the memory block
     CFA0 0000     
30884                                                                          ; with - i.e. zero
30885               
30886 CFA2 D80E  30        movb rx,@SC+1                   ; STX SC+1          ; We want to zero-fill page X, so store this in the
     CFA4 0008     
30887                                                                          ; high byte of SC, so the 16-bit address in SC and
30888                                                                          ; SC+1 is now pointing to the SC-th byte of page X
30889               
30890               ZEL1:
30891                      .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Zero the Y-th byte of the block pointed to by SC,
     **** ****     > ST_IND_Y_IDX
0001 CFA6 D820  42        movb @SC,@rtmplb
     CFA8 0007     
     CFAA 8301     
0002 CFAC D020  30        movb @SC+1,rtmp
     CFAE 0008     
0003 CFB0 06CF  14        swpb ry
0004 CFB2 A00F  18        a    ry,rtmp
0005 CFB4 06CF  14        swpb ry
0006 CFB6 D40D  30        movb RA,*rtmp
                   < elite.a99
30892                                                                          ; so that's effectively the Y-th byte before SC
30893               
30894 CFB8 B3C7  18        ab   rone,ry                    ; INY               ; Increment the loop counter
30895               
30896 CFBA 16F5  14        jne  ZEL1                       ; BNE ZEL1          ; Loop back to zero the next byte
30897               
30898 CFBC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     CFBE FE34     
30899               
30900               * ******************************************************************************
30901               *
30902               * Name: SVE
30903               * Type: Subroutine
30904               * Category: Save and load
30905               * Summary: Save the commander file
30906               * Deep dive: Commander save files
30907               * The competition code
30908               *
30909               * ******************************************************************************
30910               
30911               SVE:
30912 CFC0 0200  20        li   rtmp,GTNME                 ; JSR GTNME         ; Clear the screen and ask for the commander filename
     CFC2 CF28     
30913 CFC4 06A0  32        bl   @jsr                       ;
     CFC6 FE28     
30914                                                                          ; to save, storing the name at INWK
30915               
30916 CFC8 0200  20        li   rtmp,TRNME                 ; JSR TRNME         ; Transfer the commander filename from INWK to NA%
     CFCA CEF4     
30917 CFCC 06A0  32        bl   @jsr                       ;
     CFCE FE28     
30918               
30919 CFD0 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     CFD2 CF82     
30920 CFD4 06A0  32        bl   @jsr                       ;
     CFD6 FE28     
30921                                                                          ; the ship data blocks, the ship line heap, the ship
30922                                                                          ; slots for the local bubble of universe, and various
30923                                                                          ; flight and ship status variables
30924               
30925                      .lsr @SVC                       ; LSR SVC           ; Halve the save count value in SVC
     **** ****     > LSR
0001 CFD8 D020  30        movb @SVC,rtmp
     CFDA 0349     
0002 CFDC 0910  18        srl  rtmp,1
0003 CFDE D800  30        movb rtmp,@SVC
     CFE0 0349     
                   < elite.a99
30926               
30927 CFE2 020E  20        li   rx,(NT.)*256               ; LDX #NT%          ; We now want to copy the current commander data block
     CFE4 4B00     
30928                                                                          ; from location TP to the last saved commander block at
30929                                                                          ; NA%+8, so set a counter in X to copy the NT% bytes in
30930                                                                          ; the commander data block
30931                                                                          ;
30932                                                                          ; We also want to copy the data block to another
30933                                                                          ; location &0B00, which is normally used for the ship
30934                                                                          ; lines heap
30935               
30936               SVL1:
30937 CFE6 06CE  14        swpb rx                         ;
30938 CFE8 D36E  34        movb @TP(rx),ra                 ; LDA TP,X          ; Copy the X-th byte of TP to the X-th byte of &0B00
     CFEA 0300     
30939 CFEC 06CE  14        swpb rx                         ;
30940 CFEE 06CE  14        swpb rx                         ;
30941 CFF0 DB8D  38        movb ra,@>0B00(rx)              ; STA &0B00,X       ; and NA%+8
     CFF2 0B00     
30942 CFF4 06CE  14        swpb rx                         ;
30943 CFF6 06CE  14        swpb rx                         ;
30944 CFF8 DB8D  38        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     CFFA 2340     
30945 CFFC 06CE  14        swpb rx                         ;
30946               
30947 CFFE 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
30948               
30949 D000 15F2  14        jgt  SVL1                       ; BPL SVL1          ; Loop back until we have copied all the bytes in the
30950                                                                          ; commander data block
30951               
30952 D002 0200  20        li   rtmp,CHECK                 ; JSR CHECK         ; Call CHECK to calculate the checksum for the last
     D004 CECE     
30953 D006 06A0  32        bl   @jsr                       ;
     D008 FE28     
30954                                                                          ; saved commander and return it in A
30955               
30956 D00A D80D  38        movb ra,@CHK                    ; STA CHK           ; Store the checksum in CHK, which is at the end of the
     D00C 238E     
30957                                                                          ; last saved commander block
30958               
30959                      .pha                            ; PHA               ; Store the checksum on the stack
     **** ****     > PHA
0001 D00E D68D  30        movb ra,*rsp
0002 D010 060A  14        dec  rsp
                   < elite.a99
30960               
30961 D012 026D  22        ori  ra,>80*256                 ; ORA #%10000000    ; Set K = checksum with bit 7 set
     D014 8000     
30962 D016 D80D  30        movb ra,@K                      ; STA K
     D018 003D     
30963               
30964                      .eor @COK                       ; EOR COK           ; Set K+2 = K EOR COK (the competition flags)
     **** ****     > EOR
0001 D01A D020  30        movb @COK,rtmp
     D01C 030E     
0002 D01E 2B40  18        xor  rtmp,ra
                   < elite.a99
30965 D020 D80D  30        movb ra,@K+2                    ; STA K+2
     D022 003F     
30966               
30967                      .eor @CASH+2                    ; EOR CASH+2        ; Set K+1 = K+2 EOR CASH+2 (the third cash byte)
     **** ****     > EOR
0001 D024 D020  30        movb @CASH+2,rtmp
     D026 030B     
0002 D028 2B40  18        xor  rtmp,ra
                   < elite.a99
30968 D02A D80D  30        movb ra,@K+1                    ; STA K+1
     D02C 003E     
30969               
30970                      .eoi (>5a*256)                  ; EOR #&5A          ; Set K+3 = K+1 EOR &5A EOR TALLY+1 (the high byte of
     **** ****     > EOI
0001 D02E 0200  20        li   rtmp,(>5A*256)
     D030 5A00     
0002 D032 2B40  18        xor  rtmp,ra
                   < elite.a99
30971                      .eor @TALLY+1                   ; EOR TALLY+1       ; the kill tally)
     **** ****     > EOR
0001 D034 D020  30        movb @TALLY+1,rtmp
     D036 0348     
0002 D038 2B40  18        xor  rtmp,ra
                   < elite.a99
30972 D03A D80D  30        movb ra,@K+3                    ; STA K+3
     D03C 0040     
30973               
30974 D03E 0200  20        li   rtmp,BPRNT                 ; JSR BPRNT         ; Print the competition number stored in K to K+3. The
     D040 324C     
30975 D042 06A0  32        bl   @jsr                       ;
     D044 FE28     
30976                                                                          ; value of U might affect how this is printed, and as
30977                                                                          ; it's a temporary variable in zero page that isn't
30978                                                                          ; reset by ZERO, it might have any value, but as the
30979                                                                          ; competition code is a 10-digit number, this just means
30980                                                                          ; it may or may not have an extra space of padding
30981               
30982 D046 0200  20        li   rtmp,TT67                  ; JSR TT67          ; Call TT67 twice to print two newlines
     D048 52CE     
30983 D04A 06A0  32        bl   @jsr                       ;
     D04C FE28     
30984 D04E 0200  20        li   rtmp,TT67                  ; JSR TT67
     D050 52CE     
30985 D052 06A0  32        bl   @jsr                       ;
     D054 FE28     
30986               
30987                      .pla                            ; PLA               ; Restore the checksum from the stack
     **** ****     > PLA
0001 D056 058A  14        inc  rsp
0002 D058 D35A  26        movb *rsp,ra
                   < elite.a99
30988               
30989 D05A D80D  30        movb ra,@>0B00+NT.              ; STA &0B00+NT%     ; Store the checksum in the last byte of the save file
     D05C 0B4B     
30990                                                                          ; at &0B00 (the equivalent of CHK in the last saved
30991                                                                          ; block)
30992               
30993                      .eoi (>a9*256)                  ; EOR #&A9          ; Store the checksum EOR &A9 in CHK2, the penultimate
     **** ****     > EOI
0001 D05E 0200  20        li   rtmp,(>A9*256)
     D060 A900     
0002 D062 2B40  18        xor  rtmp,ra
                   < elite.a99
30994 D064 D80D  38        movb ra,@CHK2                   ; STA CHK2          ; byte of the last saved commander block
     D066 238D     
30995               
30996 D068 D80D  30        movb ra,@>0AFF+NT.              ; STA &0AFF+NT%     ; Store the checksum EOR &A9 in the penultimate byte of
     D06A 0B4A     
30997                                                                          ; the save file at &0B00 (the equivalent of CHK2 in the
30998                                                                          ; last saved block)
30999               
31000 D06C 020F  20        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     D06E 0B00     
31001 D070 D80F  30        movb ry,@>0C0B                  ; STY &0C0B         ;
     D072 0C0B     
31002 D074 B3C7  18        ab   rone,ry                    ; INY               ; Start address for save = &00000B00 in &0C0A to &0C0D
31003 D076 D80F  30        movb ry,@>0C0F                  ; STY &0C0F         ;
     D078 0C0F     
31004                                                                          ; End address for save = &00000C00 in &0C0E to &0C11
31005                                                                          ;
31006                                                                          ; Y is left containing &C which we use below
31007               
31008 D07A 020D  20        li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
     D07C 8100     
31009 D07E D80D  38        movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
     D080 FE4E     
31010                                                                          ; which comes from the keyboard)
31011               
31012 D082 B347  18        ab   rone,ra                    ; INC SVN           ; Increment SVN to indicate we are about to start saving
31013               
31014 D084 020D  20        li   ra,>00*256                 ; LDA #0            ; Call QUS1 with A = 0, Y = &C to save the commander
     D086 0000     
31015 D088 0200  20        li   rtmp,QUS1                  ; JSR QUS1          ; file with the filename we copied to INWK at the start
     D08A D09C     
31016 D08C 06A0  32        bl   @jsr                       ;
     D08E FE28     
31017                                                                          ; of this routine
31018               
31019 D090 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0 for storing in SVN below
     D092 0000     
31020               
31021               * STX VIA+&4E            \ This instruction is commented out in the original
31022                                                                          ; source. It would affect the 6522 System VIA interrupt
31023                                                                          ; enable register IER (SHEILA &4E) if any of bits 0-6
31024                                                                          ; of X were set, but they aren't, so this instruction
31025                                                                          ; would have no effect anyway
31026               
31027               * DEX                    \ This instruction is commented out in the original
31028                                                                          ; source. It would end up setting SVN to &FF, which
31029                                                                          ; affects the logic in the IRQ1 handler
31030               
31031 D094 D80E  38        movb rx,@SVN                    ; STX SVN           ; Set SVN to 0 to indicate we are done saving
     D096 FC29     
31032               
31033 D098 0460  28        b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show Status Mode)
     D09A CDBC     
31034               
31035               * ******************************************************************************
31036               *
31037               * Name: QUS1
31038               * Type: Subroutine
31039               * Category: Save and load
31040               * Summary: Save or load the commander file
31041               * Deep dive: Commander save files
31042               *
31043               * ------------------------------------------------------------------------------
31044               *
31045               * The filename should be stored at INWK, terminated with a carriage return (13).
31046               * The routine should be called with Y set to &C.
31047               *
31048               * ------------------------------------------------------------------------------
31049               *
31050               * Arguments:
31051               *
31052               * A                   File operation to be performed. Can be one of the
31053               * following:
31054               *
31055               * * 0 (save file)
31056               *
31057               * * &FF (load file)
31058               *
31059               * Y                   Points to the page number containing the OSFILE block,
31060               * which must be &C because that's where the pointer to the
31061               * filename in INWK is stored below (by the STX &0C00
31062               * instruction)
31063               *
31064               * ******************************************************************************
31065               
31066               QUS1:
31067 D09C 020E  20        li   rx,(INWK)*256              ; LDX #INWK         ; Store a pointer to INWK at the start of the block at
     D09E 5300     
31068 D0A0 D80E  30        movb rx,@>0C00                  ; STX &0C00         ; &0C00, storing #INWK in the low byte because INWK is
     D0A2 0C00     
31069                                                                          ; in zero page
31070               
31071 D0A4 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X to 0 so (Y X) = &0C00
     D0A6 0000     
31072               
31073 D0A8 0460  28        b    @OSFILE                    ; JMP OSFILE        ; Jump to OSFILE to do the file operation specified in
     D0AA FE26     
31074                                                                          ; &0C00 (i.e. save or load a file depending on the value
31075                                                                          ; of A), returning from the subroutine using a tail call
31076               
31077               * ******************************************************************************
31078               *
31079               * Name: LOD
31080               * Type: Subroutine
31081               * Category: Save and load
31082               * Summary: Load a commander file
31083               *
31084               * ------------------------------------------------------------------------------
31085               *
31086               * The filename should be stored at INWK, terminated with a carriage return (13).
31087               *
31088               * ******************************************************************************
31089               
31090               LOD:
31091 D0AC 020E  20        li   rx,>02*256                 ; LDX #2            ; Enable the ESCAPE key and clear memory if the BREAK
     D0AE 0200     
31092 D0B0 0200  20        li   rtmp,FX200                 ; JSR FX200         ; key is pressed (*FX 200,2)
     D0B2 D0FA     
31093 D0B4 06A0  32        bl   @jsr                       ;
     D0B6 FE28     
31094               
31095 D0B8 0200  20        li   rtmp,ZERO                  ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
     D0BA CF82     
31096 D0BC 06A0  32        bl   @jsr                       ;
     D0BE FE28     
31097                                                                          ; the ship data blocks, the ship line heap, the ship
31098                                                                          ; slots for the local bubble of universe, and various
31099                                                                          ; flight and ship status variables
31100               
31101 D0C0 020F  20        li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
     D0C2 0B00     
31102 D0C4 D80F  30        movb ry,@>0C03                  ; STY &0C03         ;
     D0C6 0C03     
31103 D0C8 B347  18        ab   rone,ra                    ; INC &0C0B         ; Load address = &00000B00 in &0C02 to &0C05
31104                                                                          ;
31105                                                                          ; Length of file = &00000100 in &0C0A to &0C0D
31106               
31107 D0CA B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to &C, which we use next
31108               
31109 D0CC 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Call QUS1 with A = &FF, Y = &C to load the commander
     D0CE FF00     
31110 D0D0 0200  20        li   rtmp,QUS1                  ; JSR QUS1          ; file to address &0B00
     D0D2 D09C     
31111 D0D4 06A0  32        bl   @jsr                       ;
     D0D6 FE28     
31112               
31113 D0D8 D360  30        movb @>0B00,ra                  ; LDA &0B00         ; If the first byte of the loaded file has bit 7 set,
     D0DA 0B00     
31114 D0DC 1116  14        jlt  SPS1+1                     ; BMI SPS1+1        ; jump to SPS+1, which is the second byte of an LDA #0
31115                                                                          ; instruction, i.e. a BRK instruction, which will force
31116                                                                          ; an interrupt to call the address in BRKV, which is set
31117                                                                          ; to BR1... so this instruction restarts the game from
31118                                                                          ; the title screen. Valid commander files for the
31119                                                                          ; cassette version of Elite only have 0 for the first
31120                                                                          ; byte, as there are no missions in this version, so
31121                                                                          ; having bit 7 set is invalid anyway
31122               
31123 D0DE 020E  20        li   rx,(NT.)*256               ; LDX #NT%          ; We have successfully loaded the commander file at
     D0E0 4B00     
31124                                                                          ; &0B00, so now we want to copy it to the last saved
31125                                                                          ; commander data block at NA%+8, so we set up a counter
31126                                                                          ; in X to copy NT% bytes
31127               
31128               LOL1:
31129 D0E2 06CE  14        swpb rx                         ;
31130 D0E4 D36E  34        movb @>0B00(rx),ra              ; LDA &0B00,X       ; Copy the X-th byte of &0B00 to the X-th byte of NA%+8
     D0E6 0B00     
31131 D0E8 06CE  14        swpb rx                         ;
31132 D0EA 06CE  14        swpb rx                         ;
31133 D0EC DB8D  38        movb ra,@NA.+8(rx)              ; STA NA%+8,X
     D0EE 2340     
31134 D0F0 06CE  14        swpb rx                         ;
31135               
31136 D0F2 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
31137               
31138 D0F4 15F6  14        jgt  LOL1                       ; BPL LOL1          ; Loop back until we have copied all NT% bytes
31139               
31140 D0F6 020E  20        li   rx,>03*256                 ; LDX #3            ; Fall through into FX200 to disable the ESCAPE key and
     D0F8 0300     
31141                                                                          ; clear memory if the BREAK key is pressed (*FX 200,3)
31142                                                                          ; and return from the subroutine there
31143               
31144               * ******************************************************************************
31145               *
31146               * Name: FX200
31147               * Type: Subroutine
31148               * Category: Utility routines
31149               * Summary: Set the behaviour of the ESCAPE and BREAK keys
31150               *
31151               * ------------------------------------------------------------------------------
31152               *
31153               * This is the equivalent of a *FX 200 command, which controls the behaviour of
31154               * the ESCAPE and BREAK keys.
31155               *
31156               * ------------------------------------------------------------------------------
31157               *
31158               * Arguments:
31159               *
31160               * X                   Controls the behaviour as follows:
31161               *
31162               * * 0 = Enable ESCAPE key
31163               * Normal BREAK key action
31164               *
31165               * * 1 = Disable ESCAPE key
31166               * Normal BREAK key action
31167               *
31168               * * 2 = Enable ESCAPE key
31169               * Clear memory if the BREAK key is pressed
31170               *
31171               * * 3 = Disable ESCAPE key
31172               * Clear memory if the BREAK key is pressed
31173               *
31174               * ******************************************************************************
31175               
31176               FX200:
31177 D0FA 020F  20        li   ry,>00*256                 ; LDY #0            ; Call OSBYTE 200 with Y = 0, so the new value is set to
     D0FC 0000     
31178 D0FE 020D  20        li   ra,>c8*256                 ; LDA #200          ; X, and return from the subroutine using a tail call
     D100 C800     
31179 D102 0460  28        b    @OSBYTE                    ; JMP OSBYTE
     D104 FE22     
31180               
31181 D106 0460  28        b    @rts                       ; RTS               ; This instruction has no effect, as we already returned
     D108 FE34     
31182                                                                          ; from the subroutine
31183               
31184               * ******************************************************************************
31185               *
31186               * Name: SPS1
31187               * Type: Subroutine
31188               * Category: Maths (Geometry)
31189               * Summary: Calculate the vector to the planet and store it in XX15
31190               *
31191               * ------------------------------------------------------------------------------
31192               *
31193               * Other entry points:
31194               *
31195               * SPS1+1              A BRK instruction
31196               *
31197               * ******************************************************************************
31198               
31199               SPS1:
31200 D10A 020E  20        li   rx,>00*256                 ; LDX #0            ; Copy the two high bytes of the planet's x-coordinate
     D10C 0000     
31201 D10E 0200  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(2 1 0), separating out the sign bit into K3+2
     D110 B52C     
31202 D112 06A0  32        bl   @jsr                       ;
     D114 FE28     
31203               
31204 D116 020E  20        li   rx,>03*256                 ; LDX #3            ; Copy the two high bytes of the planet's y-coordinate
     D118 0300     
31205 D11A 0200  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(5 4 3), separating out the sign bit into K3+5
     D11C B52C     
31206 D11E 06A0  32        bl   @jsr                       ;
     D120 FE28     
31207               
31208 D122 020E  20        li   rx,>06*256                 ; LDX #6            ; Copy the two high bytes of the planet's z-coordinate
     D124 0600     
31209 D126 0200  20        li   rtmp,SPS3                  ; JSR SPS3          ; into K3(8 7 6), separating out the sign bit into K3+8
     D128 B52C     
31210 D12A 06A0  32        bl   @jsr                       ;
     D12C FE28     
31211               
31212                                                                          ; Fall through into TAS2 to build XX15 from K3
31213               
31214               * ******************************************************************************
31215               *
31216               * Name: TAS2
31217               * Type: Subroutine
31218               * Category: Maths (Geometry)
31219               * Summary: Normalise the three-coordinate vector in K3
31220               *
31221               * ------------------------------------------------------------------------------
31222               *
31223               * Normalise the vector in K3, which has 16-bit values and separate sign bits,
31224               * and store the normalised version in XX15 as a signed 8-bit vector.
31225               *
31226               * A normalised vector (also known as a unit vector) has length 1, so this
31227               * routine takes an existing vector in K3 and scales it so the length of the
31228               * new vector is 1. This is used in two places: when drawing the compass, and
31229               * when applying AI tactics to ships.
31230               *
31231               * We do this in two stages. This stage shifts the 16-bit vector coordinates in
31232               * K3 to the left as far as they will go without losing any bits off the end, so
31233               * we can then take the high bytes and use them as the most accurate 8-bit vector
31234               * to normalise. Then the next stage (in routine NORM) does the normalisation.
31235               *
31236               * ------------------------------------------------------------------------------
31237               *
31238               * Arguments:
31239               *
31240               * K3(2 1 0)           The 16-bit x-coordinate as (x_sign x_hi x_lo), where
31241               * x_sign is just bit 7
31242               *
31243               * K3(5 4 3)           The 16-bit y-coordinate as (y_sign y_hi y_lo), where
31244               * y_sign is just bit 7
31245               *
31246               * K3(8 7 6)           The 16-bit z-coordinate as (z_sign z_hi z_lo), where
31247               * z_sign is just bit 7
31248               *
31249               * ------------------------------------------------------------------------------
31250               *
31251               * Returns:
31252               *
31253               * XX15                The normalised vector, with:
31254               *
31255               * * The x-coordinate in XX15
31256               *
31257               * * The y-coordinate in XX15+1
31258               *
31259               * * The z-coordinate in XX15+2
31260               *
31261               * ------------------------------------------------------------------------------
31262               *
31263               * Other entry points:
31264               *
31265               * TA2                 Calculate the length of the vector in XX15 (ignoring the
31266               * low coordinates), returning it in Q
31267               *
31268               * ******************************************************************************
31269               
31270               TAS2:
31271 D12E D360  30        movb @K3,ra                     ; LDA K3            ; OR the three low bytes and 1 to get a byte that has
     D130 00D2     
31272 D132 F360  30        socb @K3+3,ra                   ; ORA K3+3          ; a 1 wherever any of the three low bytes has a 1
     D134 00D5     
31273 D136 F360  30        socb @K3+6,ra                   ; ORA K3+6          ; (as well as always having bit 0 set), and store in
     D138 00D8     
31274 D13A 026D  22        ori  ra,>01*256                 ; ORA #1            ; K3+9
     D13C 0100     
31275 D13E D80D  30        movb ra,@K3+9                   ; STA K3+9
     D140 00DB     
31276               
31277 D142 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; OR the three high bytes to get a byte in A that has a
     D144 00D3     
31278 D146 F360  30        socb @K3+4,ra                   ; ORA K3+4          ; 1 wherever any of the three high bytes has a 1
     D148 00D6     
31279 D14A F360  30        socb @K3+7,ra                   ; ORA K3+7
     D14C 00D9     
31280               
31281                                                                          ; (A K3+9) now has a 1 wherever any of the 16-bit
31282                                                                          ; values in K3 has a 1
31283               TAL2:
31284                      .asl @K3+9                      ; ASL K3+9          ; Shift (A K3+9) to the left, so bit 7 of the high byte
     **** ****     > ASL
0001 D14E D020  30        movb @K3+9,rtmp
     D150 00DB     
0002 D152 0240  22        andi rtmp,>ff00
     D154 FF00     
0003 D156 0A10  18        sla  rtmp,1
0004 D158 D800  30        movb rtmp,@K3+9
     D15A 00DB     
                   < elite.a99
31285 D15C 06A0  32        bl   @rola                      ; ROL A             ; goes into the C flag
     D15E FE3E     
31286               
31287 D160 1822  14        joc  TA2                        ; BCS TA2           ; If the left shift pushed a 1 out of the end, then we
31288                                                                          ; know that at least one of the coordinates has a 1 in
31289                                                                          ; this position, so jump to TA2 as we can't shift the
31290                                                                          ; values in K3 any further to the left
31291               
31292                      .asl @K3                        ; ASL K3            ; Shift K3(1 0), the x-coordinate, to the left
     **** ****     > ASL
0001 D162 D020  30        movb @K3,rtmp
     D164 00D2     
0002 D166 0240  22        andi rtmp,>ff00
     D168 FF00     
0003 D16A 0A10  18        sla  rtmp,1
0004 D16C D800  30        movb rtmp,@K3
     D16E 00D2     
                   < elite.a99
31293 D170 0204  20        li   rarg1,K3+1                 ; ROL K3+1
     D172 00D3     
31294 D174 06A0  32        bl   @rol                       ;
     D176 FE4E     
31295               
31296                      .asl @K3+3                      ; ASL K3+3          ; Shift K3(4 3), the y-coordinate, to the left
     **** ****     > ASL
0001 D178 D020  30        movb @K3+3,rtmp
     D17A 00D5     
0002 D17C 0240  22        andi rtmp,>ff00
     D17E FF00     
0003 D180 0A10  18        sla  rtmp,1
0004 D182 D800  30        movb rtmp,@K3+3
     D184 00D5     
                   < elite.a99
31297 D186 0204  20        li   rarg1,K3+4                 ; ROL K3+4
     D188 00D6     
31298 D18A 06A0  32        bl   @rol                       ;
     D18C FE4E     
31299               
31300                      .asl @K3+6                      ; ASL K3+6          ; Shift K3(6 7), the z-coordinate, to the left
     **** ****     > ASL
0001 D18E D020  30        movb @K3+6,rtmp
     D190 00D8     
0002 D192 0240  22        andi rtmp,>ff00
     D194 FF00     
0003 D196 0A10  18        sla  rtmp,1
0004 D198 D800  30        movb rtmp,@K3+6
     D19A 00D8     
                   < elite.a99
31301 D19C 0204  20        li   rarg1,K3+7                 ; ROL K3+7
     D19E 00D9     
31302 D1A0 06A0  32        bl   @rol                       ;
     D1A2 FE4E     
31303               
31304 D1A4 17D4  14        jnc  TAL2                       ; BCC TAL2          ; Jump back to TAL2 to do another shift left (this BCC
31305                                                                          ; is effectively a JMP as we know bit 7 of K3+7 is not a
31306                                                                          ; 1, as otherwise bit 7 of A would have been a 1 and we
31307                                                                          ; would have taken the BCS above)
31308               
31309               TA2:
31310 D1A6 D360  30        movb @K3+1,ra                   ; LDA K3+1          ; Fetch the high byte of the x-coordinate from our left-
     D1A8 00D3     
31311 D1AA 091D  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
31312 D1AC F360  30        socb @K3+2,ra                   ; ORA K3+2          ; sign bit in there from the x_sign part of K3, and
     D1AE 00D4     
31313 D1B0 D80D  30        movb ra,@XX15                   ; STA XX15          ; store the resulting signed 8-bit x-coordinate in XX15
     D1B2 0031     
31314               
31315 D1B4 D360  30        movb @K3+4,ra                   ; LDA K3+4          ; Fetch the high byte of the y-coordinate from our left-
     D1B6 00D6     
31316 D1B8 091D  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
31317 D1BA F360  30        socb @K3+5,ra                   ; ORA K3+5          ; sign bit in there from the y_sign part of K3, and
     D1BC 00D7     
31318 D1BE D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; store the resulting signed 8-bit y-coordinate in
     D1C0 0032     
31319                                                                          ; XX15+1
31320               
31321 D1C2 D360  30        movb @K3+7,ra                   ; LDA K3+7          ; Fetch the high byte of the z-coordinate from our left-
     D1C4 00D9     
31322 D1C6 091D  18        srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
31323 D1C8 F360  30        socb @K3+8,ra                   ; ORA K3+8          ; sign bit in there from the z_sign part of K3, and
     D1CA 00DA     
31324 D1CC D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; store the resulting signed 8-bit  z-coordinate in
     D1CE 0033     
31325                                                                          ; XX15+2
31326               
31327                                                                          ; Now we have a signed 8-bit version of the vector K3 in
31328                                                                          ; XX15, so fall through into NORM to normalise it
31329               
31330               * ******************************************************************************
31331               *
31332               * Name: NORM
31333               * Type: Subroutine
31334               * Category: Maths (Geometry)
31335               * Summary: Normalise the three-coordinate vector in XX15
31336               * Deep dive: Tidying orthonormal vectors
31337               * Orientation vectors
31338               *
31339               * ------------------------------------------------------------------------------
31340               *
31341               * We do this by dividing each of the three coordinates by the length of the
31342               * vector, which we can calculate using Pythagoras. Once normalised, 96 (&60) is
31343               * used to represent a value of 1, and 96 with bit 7 set (&E0) is used to
31344               * represent -1. This enables us to represent fractional values of less than 1
31345               * using integers.
31346               *
31347               * ------------------------------------------------------------------------------
31348               *
31349               * Arguments:
31350               *
31351               * XX15                The vector to normalise, with:
31352               *
31353               * * The x-coordinate in XX15
31354               *
31355               * * The y-coordinate in XX15+1
31356               *
31357               * * The z-coordinate in XX15+2
31358               *
31359               * ------------------------------------------------------------------------------
31360               *
31361               * Returns:
31362               *
31363               * XX15                The normalised vector
31364               *
31365               * Q                   The length of the original XX15 vector
31366               *
31367               * ------------------------------------------------------------------------------
31368               *
31369               * Other entry points:
31370               *
31371               * NO1                 Contains an RTS
31372               *
31373               * ******************************************************************************
31374               
31375               NORM:
31376 D1D0 D360  30        movb @XX15,ra                   ; LDA XX15          ; Fetch the x-coordinate into A
     D1D2 0031     
31377               
31378 D1D4 0200  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = x^2
     D1D6 464A     
31379 D1D8 06A0  32        bl   @jsr                       ;
     D1DA FE28     
31380               
31381 D1DC D80D  30        movb ra,@R                      ; STA R             ; Set (R Q) = (A P) = x^2
     D1DE 0091     
31382 D1E0 D360  30        movb @P,ra                      ; LDA P
     D1E2 001B     
31383 D1E4 D80D  30        movb ra,@Q                      ; STA Q
     D1E6 0090     
31384               
31385 D1E8 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Fetch the y-coordinate into A
     D1EA 0032     
31386               
31387 D1EC 0200  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = y^2
     D1EE 464A     
31388 D1F0 06A0  32        bl   @jsr                       ;
     D1F2 FE28     
31389               
31390 D1F4 D80D  30        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = y^2
     D1F6 00D1     
31391               
31392 D1F8 D360  30        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2
     D1FA 001B     
31393                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 D1FC 1701  14        jnc  !
0002 D1FE B347  18        ab   rone,ra
0003               !:
0004 D200 B360  30        ab   @Q,ra
     D202 0090     
                   < elite.a99
31394 D204 D80D  30        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     D206 0090     
31395               
31396 D208 D360  30        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     D20A 00D1     
31397                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 D20C 1701  14        jnc  !
0002 D20E B347  18        ab   rone,ra
0003               !:
0004 D210 B360  30        ab   @R,ra
     D212 0091     
                   < elite.a99
31398 D214 D80D  30        movb ra,@R                      ; STA R
     D216 0091     
31399               
31400 D218 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Fetch the z-coordinate into A
     D21A 0033     
31401               
31402 D21C 0200  20        li   rtmp,SQUA                  ; JSR SQUA          ; Set (A P) = A * A = z^2
     D21E 464A     
31403 D220 06A0  32        bl   @jsr                       ;
     D222 FE28     
31404               
31405 D224 D80D  30        movb ra,@T                      ; STA T             ; Set (T P) = (A P) = z^2
     D226 00D1     
31406               
31407 D228 D360  30        movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2 + z^2
     D22A 001B     
31408                      .adc @Q,ra                      ; ADC Q             ;
     **** ****     > ADC
0001 D22C 1701  14        jnc  !
0002 D22E B347  18        ab   rone,ra
0003               !:
0004 D230 B360  30        ab   @Q,ra
     D232 0090     
                   < elite.a99
31409 D234 D80D  30        movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P
     D236 0090     
31410               
31411 D238 D360  30        movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
     D23A 00D1     
31412                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 D23C 1701  14        jnc  !
0002 D23E B347  18        ab   rone,ra
0003               !:
0004 D240 B360  30        ab   @R,ra
     D242 0091     
                   < elite.a99
31413 D244 D80D  30        movb ra,@R                      ; STA R
     D246 0091     
31414               
31415 D248 0200  20        li   rtmp,LL5                   ; JSR LL5           ; We now have the following:
     D24A DA9E     
31416 D24C 06A0  32        bl   @jsr                       ;
     D24E FE28     
31417                                                                          ;
31418                                                                          ; (R Q) = x^2 + y^2 + z^2
31419                                                                          ;
31420                                                                          ; so we can call LL5 to use Pythagoras to get:
31421                                                                          ;
31422                                                                          ; Q = SQRT(R Q)
31423                                                                          ; = SQRT(x^2 + y^2 + z^2)
31424                                                                          ;
31425                                                                          ; So Q now contains the length of the vector (x, y, z),
31426                                                                          ; and we can normalise the vector by dividing each of
31427                                                                          ; the coordinates by this value, which we do by calling
31428                                                                          ; routine TIS2. TIS2 returns the divided figure, using
31429                                                                          ; 96 to represent 1 and 96 with bit 7 set for -1
31430               
31431 D250 D360  30        movb @XX15,ra                   ; LDA XX15          ; Call TIS2 to divide the x-coordinate in XX15 by Q,
     D252 0031     
31432 D254 0200  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     D256 D88E     
31433 D258 06A0  32        bl   @jsr                       ;
     D25A FE28     
31434 D25C D80D  30        movb ra,@XX15                   ; STA XX15
     D25E 0031     
31435               
31436 D260 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Call TIS2 to divide the y-coordinate in XX15+1 by Q,
     D262 0032     
31437 D264 0200  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     D266 D88E     
31438 D268 06A0  32        bl   @jsr                       ;
     D26A FE28     
31439 D26C D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D26E 0032     
31440               
31441 D270 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Call TIS2 to divide the z-coordinate in XX15+2 by Q,
     D272 0033     
31442 D274 0200  20        li   rtmp,TIS2                  ; JSR TIS2          ; with 1 being represented by 96
     D276 D88E     
31443 D278 06A0  32        bl   @jsr                       ;
     D27A FE28     
31444 D27C D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     D27E 0033     
31445               
31446               NO1:
31447 D280 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D282 FE34     
31448               
31449               * ******************************************************************************
31450               *
31451               * Name: RDKEY
31452               * Type: Subroutine
31453               * Category: Keyboard
31454               * Summary: Scan the keyboard for key presses
31455               *
31456               * ------------------------------------------------------------------------------
31457               *
31458               * Scan the keyboard, starting with internal key number 16 ("Q") and working
31459               * through the set of internal key numbers (see p.142 of the Advanced User Guide
31460               * for a list of internal key numbers).
31461               *
31462               * This routine is effectively the same as OSBYTE 122, though the OSBYTE call
31463               * preserves A, unlike this routine.
31464               *
31465               * ------------------------------------------------------------------------------
31466               *
31467               * Returns:
31468               *
31469               * X                   If a key is being pressed, X contains the internal key
31470               * number, otherwise it contains 0
31471               *
31472               * A                   Contains the same as X
31473               *
31474               * ******************************************************************************
31475               
31476               RDKEY:
31477 D284 020E  20        li   rx,>10*256                 ; LDX #16           ; Start the scan with internal key number 16 ("Q")
     D286 1000     
31478               
31479               Rd1:
31480 D288 0200  20        li   rtmp,DKS4                  ; JSR DKS4          ; Scan the keyboard to see if the key in X is currently
     D28A D3C8     
31481 D28C 06A0  32        bl   @jsr                       ;
     D28E FE28     
31482                                                                          ; being pressed, returning the result in A and X
31483               
31484 D290 1103  14        jlt  Rd2                        ; BMI Rd2           ; Jump to Rd2 if this key is being pressed (in which
31485                                                                          ; case DKS4 will have returned the key number with bit
31486                                                                          ; 7 set, which is negative)
31487               
31488 D292 B387  18        ab   rone,rx                    ; INX               ; Increment the key number, which was unchanged by the
31489                                                                          ; above call to DKS4
31490               
31491 D294 15F9  14        jgt  Rd1                        ; BPL Rd1           ; Loop back to test the next key, ending the loop when
31492                                                                          ; X is negative (i.e. 128)
31493               
31494 D296 D34E  18        movb rx,ra                      ; TXA               ; If we get here, nothing is being pressed, so copy X
31495                                                                          ; into A so that X = A = 128 = %10000000
31496               
31497               Rd2:
31498                      .eoi (>80*256)                  ; EOR #%10000000    ; EOR A with #%10000000 to flip bit 7, so A now contains
     **** ****     > EOI
0001 D298 0200  20        li   rtmp,(>80*256)
     D29A 8000     
0002 D29C 2B40  18        xor  rtmp,ra
                   < elite.a99
31499                                                                          ; 0 if no key has been pressed, or the internal key
31500                                                                          ; number if a key has been pressed
31501               
31502 D29E D38D  18        movb ra,rx                      ; TAX               ; Copy A into X
31503               
31504 D2A0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D2A2 FE34     
31505               
31506               * ******************************************************************************
31507               *
31508               * Name: ECMOF
31509               * Type: Subroutine
31510               * Category: Sound
31511               * Summary: Switch off the E.C.M.
31512               *
31513               * ------------------------------------------------------------------------------
31514               *
31515               * Switch the E.C.M. off, turn off the dashboard bulb and make the sound of the
31516               * E.C.M. switching off).
31517               *
31518               * ******************************************************************************
31519               
31520               ECMOF:
31521 D2A4 020D  20        li   ra,>00*256                 ; LDA #0            ; Set ECMA and ECMP to 0 to indicate that no E.C.M. is
     D2A6 0000     
31522 D2A8 D80D  30        movb ra,@ECMA                   ; STA ECMA          ; currently running
     D2AA 0030     
31523 D2AC D80D  30        movb ra,@ECMP                   ; STA ECMP
     D2AE 0D5B     
31524               
31525 D2B0 0200  20        li   rtmp,ECBLB                 ; JSR ECBLB         ; Update the E.C.M. indicator bulb on the dashboard
     D2B2 B760     
31526 D2B4 06A0  32        bl   @jsr                       ;
     D2B6 FE28     
31527               
31528 D2B8 020D  20        li   ra,>48*256                 ; LDA #72           ; Call the NOISE routine with A = 72 to make the sound
     D2BA 4800     
31529 D2BC 1641  14        jne  NOISE                      ; BNE NOISE         ; of the E.C.M. being turned off and return from the
31530                                                                          ; subroutine using a tail call (this BNE is effectively
31531                                                                          ; a JMP as A will never be zero)
31532               
31533               * ******************************************************************************
31534               *
31535               * Name: EXNO3
31536               * Type: Subroutine
31537               * Category: Sound
31538               * Summary: Make an explosion sound
31539               *
31540               * ------------------------------------------------------------------------------
31541               *
31542               * Make the sound of death in the cold, hard vacuum of space. Apparently, in
31543               * Elite space, everyone can hear you scream.
31544               *
31545               * This routine also makes the sound of a destroyed cargo canister if we don't
31546               * get scooping right, the sound of us colliding with another ship, and the sound
31547               * of us being hit with depleted shields. It is not a good sound to hear.
31548               *
31549               * ******************************************************************************
31550               
31551               EXNO3:
31552 D2BE 020D  20        li   ra,>10*256                 ; LDA #16           ; Call the NOISE routine with A = 16 to make the first
     D2C0 1000     
31553 D2C2 0200  20        li   rtmp,NOISE                 ; JSR NOISE         ; death sound
     D2C4 D340     
31554 D2C6 06A0  32        bl   @jsr                       ;
     D2C8 FE28     
31555               
31556 D2CA 020D  20        li   ra,>18*256                 ; LDA #24           ; Call the NOISE routine with A = 24 to make the second
     D2CC 1800     
31557 D2CE 1638  14        jne  NOISE                      ; BNE NOISE         ; death sound and return from the subroutine using a
31558                                                                          ; tail call (this BNE is effectively a JMP as A will
31559                                                                          ; never be zero)
31560               
31561               * ******************************************************************************
31562               *
31563               * Name: SFRMIS
31564               * Type: Subroutine
31565               * Category: Tactics
31566               * Summary: Add an enemy missile to our local bubble of universe
31567               *
31568               * ------------------------------------------------------------------------------
31569               *
31570               * An enemy has fired a missile, so add the missile to our universe if there is
31571               * room, and if there is, make the appropriate warnings and noises.
31572               *
31573               * ******************************************************************************
31574               
31575               SFRMIS:
31576 D2D0 020E  20        li   rx,(MSL)*256               ; LDX #MSL          ; Set X to the ship type of a missile, and call SFS1-2
     D2D2 0900     
31577 D2D4 0200  20        li   rtmp,SFS1-2                ; JSR SFS1-2        ; to add the missile to our universe with an AI flag
     D2D6 4048     
31578 D2D8 06A0  32        bl   @jsr                       ;
     D2DA FE28     
31579                                                                          ; of %11111110 (AI enabled, hostile, no E.C.M.)
31580               
31581 D2DC 17D1  14        jnc  NO1                        ; BCC NO1           ; The C flag will be set if the call to SFS1-2 was a
31582                                                                          ; success, so if it's clear, jump to NO1 to return from
31583                                                                          ; the subroutine (as NO1 contains an RTS)
31584               
31585 D2DE 020D  20        li   ra,>78*256                 ; LDA #120          ; Print recursive token 120 ("INCOMING MISSILE") as an
     D2E0 7800     
31586 D2E2 0200  20        li   rtmp,MESS                  ; JSR MESS          ; in-flight message
     D2E4 D616     
31587 D2E6 06A0  32        bl   @jsr                       ;
     D2E8 FE28     
31588               
31589 D2EA 020D  20        li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
     D2EC 3000     
31590 D2EE 1628  14        jne  NOISE                      ; BNE NOISE         ; of the missile being launched and return from the
31591                                                                          ; subroutine using a tail call (this BNE is effectively
31592                                                                          ; a JMP as A will never be zero)
31593               
31594               * ******************************************************************************
31595               *
31596               * Name: EXNO2
31597               * Type: Subroutine
31598               * Category: Status
31599               * Summary: Process us making a kill
31600               * Deep dive: Combat rank
31601               *
31602               * ------------------------------------------------------------------------------
31603               *
31604               * We have killed a ship, so increase the kill tally, displaying an iconic
31605               * message of encouragement if the kill total is a multiple of 256, and then
31606               * make a nearby explosion sound.
31607               *
31608               * ******************************************************************************
31609               
31610               EXNO2:
31611 D2F0 B347  18        ab   rone,ra                    ; INC TALLY         ; Increment the low byte of the kill count in TALLY
31612               
31613 D2F2 1608  14        jne  EXNO-2                     ; BNE EXNO-2        ; If there is no carry, jump to the LDX #7 below (at
31614                                                                          ; EXNO-2)
31615               
31616 D2F4 B347  18        ab   rone,ra                    ; INC TALLY+1       ; Increment the high byte of the kill count in TALLY
31617               
31618 D2F6 020D  20        li   ra,>65*256                 ; LDA #101          ; The kill total is a multiple of 256, so it's time
     D2F8 6500     
31619 D2FA 0200  20        li   rtmp,MESS                  ; JSR MESS          ; for a pat on the back, so print recursive token 101
     D2FC D616     
31620 D2FE 06A0  32        bl   @jsr                       ;
     D300 FE28     
31621                                                                          ; ("RIGHT ON COMMANDER!") as an in-flight message
31622               
31623 D302 020E  20        li   rx,>07*256                 ; LDX #7            ; Set X = 7 and fall through into EXNO to make the
     D304 0700     
31624                                                                          ; sound of a ship exploding
31625               
31626               * ******************************************************************************
31627               *
31628               * Name: EXNO
31629               * Type: Subroutine
31630               * Category: Sound
31631               * Summary: Make the sound of a laser strike or ship explosion
31632               *
31633               * ------------------------------------------------------------------------------
31634               *
31635               * Make the two-part explosion sound of us making a laser strike, or of another
31636               * ship exploding.
31637               *
31638               * The volume of the first explosion is affected by the distance of the ship
31639               * being hit, with more distant ships being quieter. The value in X also affects
31640               * the volume of the first explosion, with a higher X giving a quieter sound
31641               * (so X can be used to differentiate a laser strike from an explosion).
31642               *
31643               * ------------------------------------------------------------------------------
31644               *
31645               * Arguments:
31646               *
31647               * X                   The larger the value of X, the fainter the explosion.
31648               * Allowed values are:
31649               *
31650               * * 7  = explosion is louder (i.e. the ship has just
31651               * exploded)
31652               *
31653               * * 15 = explosion is quieter (i.e. this is just a laser
31654               * strike)
31655               *
31656               * ------------------------------------------------------------------------------
31657               *
31658               * Other entry points:
31659               *
31660               * EXNO-2              Set X = 7 and fall through into EXNO to make the sound
31661               * of a ship exploding
31662               *
31663               * ******************************************************************************
31664               
31665               EXNO:
31666 D306 D80E  30        movb rx,@T                      ; STX T             ; Store the distance in T
     D308 00D1     
31667               
31668 D30A 020D  20        li   ra,>18*256                 ; LDA #24           ; Set A = 24 to denote the sound of us making a hit or
     D30C 1800     
31669 D30E 0200  20        li   rtmp,NOS1                  ; JSR NOS1          ; kill (part 1 of the explosion), and call NOS1 to set
     D310 D35E     
31670 D312 06A0  32        bl   @jsr                       ;
     D314 FE28     
31671                                                                          ; up the sound block in XX16
31672               
31673 D316 D360  30        movb @INWK+7,ra                 ; LDA INWK+7        ; Fetch z_hi, the distance of the ship being hit in
     D318 005A     
31674 D31A 091D  18        srl  ra,1                       ; LSR A             ; terms of the z-axis (in and out of the screen), and
31675 D31C 091D  18        srl  ra,1                       ; LSR A             ; divide by 4. If z_hi has either bit 6 or 7 set then
31676                                                                          ; that ship is too far away to be shown on the scanner
31677                                                                          ; (as per the SCAN routine), so we know the maximum
31678                                                                          ; z_hi at this point is %00111111, and shifting z_hi
31679                                                                          ; to the right twice gives us a maximum value of
31680                                                                          ; %00001111
31681               
31682                      .and @T                         ; AND T             ; This reduces A to a maximum of X; X can be either
     **** ****     > AND
0001 D31E D020  30        movb @T,rtmp
     D320 00D1     
0002 D322 0540  14        inv  rtmp
0003 D324 5340  18        szcb rtmp,ra
                   < elite.a99
31683                                                                          ; 7 = %0111 or 15 = %1111, so AND'ing with 15 will
31684                                                                          ; not affect A, while AND'ing with 7 will clear bit
31685                                                                          ; 3, reducing the maximum value in A to 7
31686               
31687 D326 026D  22        ori  ra,>f1*256                 ; ORA #%11110001    ; The SOUND statement's amplitude ranges from 0 (for no
     D328 F100     
31688                                                                          ; sound) to -15 (full volume), so we can set bits 0 and
31689                                                                          ; 4-7 in A, and keep bits 1-3 from the above to get
31690                                                                          ; a value between -15 (%11110001) and -1 (%11111111),
31691                                                                          ; with lower values of z_hi and argument X leading
31692                                                                          ; to a more negative, or quieter number (so the closer
31693                                                                          ; the ship, i.e. the smaller the value of X, the louder
31694                                                                          ; the sound)
31695               
31696 D32A D80D  30        movb ra,@XX16+2                 ; STA XX16+2        ; The amplitude byte of the sound block in XX16 is in
     D32C 000B     
31697                                                                          ; byte #3 (where it's the low byte of the amplitude), so
31698                                                                          ; this sets the amplitude to the value in A
31699               
31700 D32E 0200  20        li   rtmp,NO3                   ; JSR NO3           ; Make the sound from our updated sound block in XX16
     D330 D348     
31701 D332 06A0  32        bl   @jsr                       ;
     D334 FE28     
31702               
31703 D336 020D  20        li   ra,>10*256                 ; LDA #16           ; Set A = 16 to denote we have made a hit or kill
     D338 1000     
31704                                                                          ; (part 2 of the explosion), and fall through into NOISE
31705                                                                          ; to make the sound
31706               
31707 D33A 2C              byte >2c                                            ; Skip the next instruction by turning it into
31708                                                                          ; &2C &A9 &20, or BIT &20A9, which does nothing apart
31709                                                                          ; from affect the flags
31710               
31711               * ******************************************************************************
31712               *
31713               * Name: BEEP
31714               * Type: Subroutine
31715               * Category: Sound
31716               * Summary: Make a short, high beep
31717               *
31718               * ******************************************************************************
31719               
31720               BEEP:
31721 D33C 020D  20        li   ra,>20*256                 ; LDA #32           ; Set A = 32 to denote a short, high beep, and fall
     D33E 2000     
31722                                                                          ; through into the NOISE routine to make the sound
31723               
31724               * ******************************************************************************
31725               *
31726               * Name: NOISE
31727               * Type: Subroutine
31728               * Category: Sound
31729               * Summary: Make the sound whose number is in A
31730               *
31731               * ------------------------------------------------------------------------------
31732               *
31733               * Arguments:
31734               *
31735               * A                   The number of the sound to be made. See the
31736               * documentation for variable SFX for a list of sound
31737               * numbers
31738               *
31739               * ******************************************************************************
31740               
31741               NOISE:
31742 D340 0200  20        li   rtmp,NOS1                  ; JSR NOS1          ; Set up the sound block in XX16 for the sound in A and
     D342 D35E     
31743 D344 06A0  32        bl   @jsr                       ;
     D346 FE28     
31744                                                                          ; fall through into NO3 to make the sound
31745               
31746               * ******************************************************************************
31747               *
31748               * Name: NO3
31749               * Type: Subroutine
31750               * Category: Sound
31751               * Summary: Make a sound from a prepared sound block
31752               *
31753               * ------------------------------------------------------------------------------
31754               *
31755               * Make a sound from a prepared sound block in XX16 (if sound is enabled). See
31756               * routine NOS1 for details of preparing the XX16 sound block.
31757               *
31758               * ******************************************************************************
31759               
31760               NO3:
31761 D348 D3A0  30        movb @DNOIZ,rx                  ; LDX DNOIZ         ; Set X to the DNOIZ configuration setting
     D34A 0F49     
31762               
31763 D34C 1699  14        jne  NO1                        ; BNE NO1           ; If DNOIZ is non-zero, then sound is disabled, so
31764                                                                          ; return from the subroutine (as NO1 contains an RTS)
31765               
31766 D34E 020E  20        li   rx,((XX16)%256)*256        ; LDX #LO(XX16)     ; Otherwise set (Y X) to point to the sound block in
     D350 0900     
31767 D352 020F  20        li   ry,((XX16)/256)*256        ; LDY #HI(XX16)     ; XX16
     D354 0000     
31768               
31769 D356 020D  20        li   ra,>07*256                 ; LDA #7            ; Call OSWORD 7 to makes the sound, as described in the
     D358 0700     
31770 D35A 0460  28        b    @OSWORD                    ; JMP OSWORD        ; documentation for variable SFX, and return from the
     D35C FE24     
31771                                                                          ; subroutine using a tail call
31772               
31773               * ******************************************************************************
31774               *
31775               * Name: NOS1
31776               * Type: Subroutine
31777               * Category: Sound
31778               * Summary: Prepare a sound block
31779               *
31780               * ------------------------------------------------------------------------------
31781               *
31782               * Copy four sound bytes from SFX into XX16, interspersing them with null bytes,
31783               * with Y indicating the sound number to copy (from the values in the sound
31784               * table at SFX). So, for example, if we call this routine with A = 40 (long,
31785               * low beep), the following bytes will be set in XX16 to XX16+7:
31786               *
31787               * &13 &00 &F4 &00 &0C &00 &08 &00
31788               *
31789               * This block will be passed to OSWORD 7 to make the sound, which expects the
31790               * four sound attributes as 16-bit big-endian values - in other words, with the
31791               * low byte first. So the above block would pass the values &0013, &00F4, &000C
31792               * and &0008 to the SOUND statement when used with OSWORD 7, or:
31793               *
31794               * SOUND &13, &F4, &0C, &08
31795               *
31796               * as the high bytes are always zero.
31797               *
31798               * ------------------------------------------------------------------------------
31799               *
31800               * Arguments:
31801               *
31802               * A                   The sound number to copy from SFX to XX16, which is
31803               * always a multiple of 8
31804               *
31805               * ******************************************************************************
31806               
31807               NOS1:
31808 D35E 091D  18        srl  ra,1                       ; LSR A             ; Divide A by 2, and also clear the C flag, as bit 0 of
31809                                                                          ; A is always zero (as A is a multiple of 8)
31810               
31811                      .adi (>03*256)                  ; ADC #3            ; Set Y = A + 3, so Y now points to the last byte of
     **** ****     > ADI
0001 D360 1701  14        jnc  !
0002 D362 B347  18        ab   rone,ra
0003               !:
0004 D364 022D  22        ai   ra,(>03*256)
     D366 0300     
                   < elite.a99
31812 D368 D3CD  18        movb ra,ry                      ; TAY               ; four within the block of four-byte values
31813               
31814 D36A 020E  20        li   rx,>07*256                 ; LDX #7            ; We want to copy four bytes, spread out into an 8-byte
     D36C 0700     
31815                                                                          ; block, so set a counter in Y to cover 8 bytes
31816               
31817               NOL1:
31818 D36E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the X-th byte of XX16 to 0
     D370 0000     
31819 D372 06CE  14        swpb rx                         ;
31820 D374 DB8D  38        movb ra,@XX16(rx)               ; STA XX16,X
     D376 0009     
31821 D378 06CE  14        swpb rx                         ;
31822               
31823 D37A 7387  18        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer
31824               
31825 D37C 06CF  14        swpb ry                         ;
31826 D37E D36F  34        movb @SFX(ry),ra                ; LDA SFX,Y         ; Set the X-th byte of XX16 to the value from SFX+Y
     D380 C62A     
31827 D382 06CF  14        swpb ry                         ;
31828 D384 06CE  14        swpb rx                         ;
31829 D386 DB8D  38        movb ra,@XX16(rx)               ; STA XX16,X
     D388 0009     
31830 D38A 06CE  14        swpb rx                         ;
31831               
31832 D38C 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the source byte pointer again
31833               
31834 D38E 7387  18        sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer again
31835               
31836 D390 15EE  14        jgt  NOL1                       ; BPL NOL1          ; Loop back for the next source byte
31837               
31838 D392 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D394 FE34     
31839               
31840               * ******************************************************************************
31841               *
31842               * Name: KYTB
31843               * Type: Variable
31844               * Category: Keyboard
31845               * Summary: Lookup table for in-flight keyboard controls
31846               * Deep dive: The key logger
31847               *
31848               * ------------------------------------------------------------------------------
31849               *
31850               * Keyboard table for in-flight controls. This table contains the internal key
31851               * codes for the flight keys (see p.142 of the Advanced User Guide for a list of
31852               * internal key numbers).
31853               *
31854               * The pitch, roll, speed and laser keys (i.e. the seven primary flight
31855               * control keys) have bit 7 set, so they have 128 added to their internal
31856               * values. This doesn't appear to be used anywhere.
31857               *
31858               * ******************************************************************************
31859               
31860               KYTB:                                                      ; Point KYTB to the byte before the start of the table
31861                      equ $ - 1
31862               
31863                                                                          ; These are the primary flight controls (pitch, roll,
31864                                                                          ; speed and lasers):
31865               
31866 D396 E8              byte >68 + 128                                      ; ?         KYTB+1      Slow down
31867 D397   E2            byte >62 + 128                                      ; Space     KYTB+2      Speed up
31868 D398 E6              byte >66 + 128                                      ; <         KYTB+3      Roll left
31869 D399   E7            byte >67 + 128                                      ; >         KYTB+4      Roll right
31870 D39A C2              byte >42 + 128                                      ; X         KYTB+5      Pitch up
31871 D39B   D1            byte >51 + 128                                      ; S         KYTB+6      Pitch down
31872 D39C C1              byte >41 + 128                                      ; A         KYTB+7      Fire lasers
31873               
31874                                                                          ; These are the secondary flight controls:
31875               
31876 D39D   60            byte >60                                            ; TAB       KYTB+8      Energy bomb
31877 D39E 70              byte >70                                            ; ESCAPE    KYTB+9      Launch escape pod
31878 D39F   23            byte >23                                            ; T         KYTB+10     Arm missile
31879 D3A0 35              byte >35                                            ; U         KYTB+11     Unarm missile
31880 D3A1   65            byte >65                                            ; M         KYTB+12     Fire missile
31881 D3A2 22              byte >22                                            ; E         KYTB+13     E.C.M.
31882 D3A3   45            byte >45                                            ; J         KYTB+14     In-system jump
31883 D3A4 52              byte >52                                            ; C         KYTB+15     Docking computer
31884               
31885               * ******************************************************************************
31886               *
31887               * Name: DKS1
31888               * Type: Subroutine
31889               * Category: Keyboard
31890               * Summary: Scan the keyboard for a flight key
31891               * Deep dive: The key logger
31892               *
31893               * ------------------------------------------------------------------------------
31894               *
31895               * Scan the keyboard for the flight key given in register Y, where Y is the
31896               * offset into the KYTB table above (so we can scan for Space by setting Y to
31897               * 2, for example). If the key is pressed, set the corresponding byte in the
31898               * key logger at KL to &FF.
31899               *
31900               * ------------------------------------------------------------------------------
31901               *
31902               * Arguments:
31903               *
31904               * Y                   The offset into the KYTB table above of the key that we
31905               * want to scan on the keyboard
31906               *
31907               * ******************************************************************************
31908               
31909               DKS1:
31910 D3A6 06CF  14        swpb ry                         ;
31911 D3A8 D3AF  34        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number from the Y-th byte of the
     D3AA D395     
31912 D3AC 06CF  14        swpb ry                         ;
31913                                                                          ; KYTB table above
31914               
31915 D3AE 0200  20        li   rtmp,DKS4                  ; JSR DKS4          ; Call DKS4, which will set A and X to a negative value
     D3B0 D3C8     
31916 D3B2 06A0  32        bl   @jsr                       ;
     D3B4 FE28     
31917                                                                          ; if the key is being pressed
31918               
31919 D3B6 151E  14        jgt  DKS2-1                     ; BPL DKS2-1        ; The key is not being pressed, so return from the
31920                                                                          ; subroutine (as DKS2-1 contains an RTS)
31921               
31922 D3B8 020E  20        li   rx,>ff*256                 ; LDX #&FF          ; Store &FF in the Y-th byte of the key logger at KL
     D3BA FF00     
31923 D3BC DBCE  38        movb rx,@KL(ry)                 ; STX KL,Y
     D3BE 0041     
31924               
31925 D3C0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D3C2 FE34     
31926               
31927               * ******************************************************************************
31928               *
31929               * Name: CTRL
31930               * Type: Subroutine
31931               * Category: Keyboard
31932               * Summary: Scan the keyboard to see if CTRL is currently pressed
31933               *
31934               * ------------------------------------------------------------------------------
31935               *
31936               * Returns:
31937               *
31938               * X                   X = %10000001 (i.e. 129 or -127) if CTRL is being
31939               * pressed
31940               *
31941               * X = 1 if CTRL is not being pressed
31942               *
31943               * A                   Contains the same as X
31944               *
31945               * ******************************************************************************
31946               
31947               CTRL:
31948 D3C4 020E  20        li   rx,>01*256                 ; LDX #1            ; Set X to the internal key number for CTRL and fall
     D3C6 0100     
31949                                                                          ; through to DKS4 to scan the keyboard
31950               
31951               * ******************************************************************************
31952               *
31953               * Name: DKS4
31954               * Type: Subroutine
31955               * Category: Keyboard
31956               * Summary: Scan the keyboard to see if a specific key is being pressed
31957               * Deep dive: The key logger
31958               *
31959               * ------------------------------------------------------------------------------
31960               *
31961               * Arguments:
31962               *
31963               * X                   The internal number of the key to check (see p.142 of
31964               * the Advanced User Guide for a list of internal key
31965               * numbers)
31966               *
31967               * ------------------------------------------------------------------------------
31968               *
31969               * Returns:
31970               *
31971               * A                   If the key in A is being pressed, A contains the
31972               * original argument A, but with bit 7 set (i.e. A + 128).
31973               * If the key in A is not being pressed, the value in A is
31974               * unchanged
31975               *
31976               * X                   Contains the same as A
31977               *
31978               * ******************************************************************************
31979               
31980               DKS4:
31981 D3C8 020D  20        li   ra,>03*256                 ; LDA #%00000011    ; Set A to %00000011, so it's ready to send to SHEILA
     D3CA 0300     
31982                                                                          ; once interrupts have been disabled
31983               
31984 D3CC 0300  22        limi 0                          ; SEI               ; Disable interrupts so we can scan the keyboard
     D3CE 0000     
31985                                                                          ; without being hijacked
31986               
31987 D3D0 D80D  38        movb ra,@VIA+>40                ; STA VIA+&40       ; Set 6522 System VIA output register ORB (SHEILA &40)
     D3D2 FE40     
31988                                                                          ; to %00000011 to stop auto scan of keyboard
31989               
31990 D3D4 020D  20        li   ra,>7f*256                 ; LDA #%01111111    ; Set 6522 System VIA data direction register DDRA
     D3D6 7F00     
31991 D3D8 D80D  38        movb ra,@VIA+>43                ; STA VIA+&43       ; (SHEILA &43) to %01111111. This sets the A registers
     D3DA FE43     
31992                                                                          ; (IRA and ORA) so that:
31993                                                                          ;
31994                                                                          ; * Bits 0-6 of ORA will be sent to the keyboard
31995                                                                          ;
31996                                                                          ; * Bit 7 of IRA will be read from the keyboard
31997               
31998 D3DC D80E  38        movb rx,@VIA+>4F                ; STX VIA+&4F       ; Set 6522 System VIA output register ORA (SHEILA &4F)
     D3DE FE4F     
31999                                                                          ; to X, the key we want to scan for; bits 0-6 will be
32000                                                                          ; sent to the keyboard, of which bits 0-3 determine the
32001                                                                          ; keyboard column, and bits 4-6 the keyboard row
32002               
32003 D3E0 D3A0  34        movb @VIA+>4F,rx                ; LDX VIA+&4F       ; Read 6522 System VIA output register IRA (SHEILA &4F)
     D3E2 FE4F     
32004                                                                          ; into X; bit 7 is the only bit that will have changed.
32005                                                                          ; If the key is pressed, then bit 7 will be set,
32006                                                                          ; otherwise it will be clear
32007               
32008 D3E4 020D  20        li   ra,>0b*256                 ; LDA #%00001011    ; Set 6522 System VIA output register ORB (SHEILA &40)
     D3E6 0B00     
32009 D3E8 D80D  38        movb ra,@VIA+>40                ; STA VIA+&40       ; to %00001011 to restart auto scan of keyboard
     D3EA FE40     
32010               
32011 D3EC 0300  22        limi 2                          ; CLI               ; Allow interrupts again
     D3EE 0002     
32012               
32013 D3F0 D34E  18        movb rx,ra                      ; TXA               ; Transfer X into A
32014               
32015 D3F2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D3F4 FE34     
32016               
32017               * ******************************************************************************
32018               *
32019               * Name: DKS2
32020               * Type: Subroutine
32021               * Category: Keyboard
32022               * Summary: Read the joystick position
32023               *
32024               * ------------------------------------------------------------------------------
32025               *
32026               * Return the value of ADC channel in X (used to read the joystick). The value
32027               * will be inverted if the game has been configured to reverse both joystick
32028               * channels (which can be done by pausing the game and pressing J).
32029               *
32030               * ------------------------------------------------------------------------------
32031               *
32032               * Arguments:
32033               *
32034               * X                   The ADC channel to read:
32035               *
32036               * * 1 = joystick X
32037               *
32038               * * 2 = joystick Y
32039               *
32040               * ------------------------------------------------------------------------------
32041               *
32042               * Returns:
32043               *
32044               * (A X)               The 16-bit value read from channel X, with the value
32045               * inverted if the game has been configured to reverse the
32046               * joystick
32047               *
32048               * ------------------------------------------------------------------------------
32049               *
32050               * Other entry points:
32051               *
32052               * DKS2-1              Contains an RTS
32053               *
32054               * ******************************************************************************
32055               
32056               DKS2:
32057 D3F6 020D  20        li   ra,>80*256                 ; LDA #128          ; Call OSBYTE with A = 128 to fetch the 16-bit value
     D3F8 8000     
32058 D3FA 0200  20        li   rtmp,OSBYTE                ; JSR OSBYTE        ; from ADC channel X, returning (Y X), i.e. the high
     D3FC FE22     
32059 D3FE 06A0  32        bl   @jsr                       ;
     D400 FE28     
32060                                                                          ; byte in Y and the low byte in X
32061                                                                          ;
32062                                                                          ; * Channel 1 is the x-axis: 0 = right, 65520 = left
32063                                                                          ;
32064                                                                          ; * Channel 2 is the y-axis: 0 = down,  65520 = up
32065               
32066 D402 D34F  18        movb ry,ra                      ; TYA               ; Copy Y to A, so the result is now in (A X)
32067               
32068                      .eor @JSTE                      ; EOR JSTE          ; The high byte A is now EOR'd with the value in
     **** ****     > EOR
0001 D404 D020  30        movb @JSTE,rtmp
     D406 0F4F     
0002 D408 2B40  18        xor  rtmp,ra
                   < elite.a99
32069                                                                          ; location JSTE, which contains &FF if both joystick
32070                                                                          ; channels are reversed and 0 otherwise (so A now
32071                                                                          ; contains the high byte but inverted, if that's what
32072                                                                          ; the current settings say)
32073               
32074 D40A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D40C FE34     
32075               
32076               * ******************************************************************************
32077               *
32078               * Name: DKS3
32079               * Type: Subroutine
32080               * Category: Keyboard
32081               * Summary: Toggle a configuration setting and emit a beep
32082               *
32083               * ------------------------------------------------------------------------------
32084               *
32085               * This is called when the game is paused and a key is pressed that changes the
32086               * game's configuration.
32087               *
32088               * Specifically, this routine toggles the configuration settings for the
32089               * following keys:
32090               *
32091               * * CAPS LOCK toggles keyboard flight damping (&40)
32092               * * A toggles keyboard auto-recentre (&41)
32093               * * X toggles author names on start-up screen (&42)
32094               * * F toggles flashing console bars (&43)
32095               * * Y toggles reverse joystick Y channel (&44)
32096               * * J toggles reverse both joystick channels (&45)
32097               * * K toggles keyboard and joystick (&46)
32098               *
32099               * The numbers in brackets are the internal key numbers (see p.142 of the
32100               * Advanced User Guide for a list of internal key numbers). We pass the key that
32101               * has been pressed in X, and the configuration option to check it against in Y,
32102               * so this routine is typically called in a loop that loops through the various
32103               * configuration options.
32104               *
32105               * ------------------------------------------------------------------------------
32106               *
32107               * Arguments:
32108               *
32109               * X                   The internal number of the key that's been pressed
32110               *
32111               * Y                   The internal number of the configuration key to check
32112               * against, from the list above (i.e. Y must be from &40 to
32113               * &46)
32114               *
32115               * ******************************************************************************
32116               
32117               DKS3:
32118 D40E D80F  30        movb ry,@T                      ; STY T             ; Store the configuration key argument in T
     D410 00D1     
32119               
32120 D412 93A0  30        cb   @T,rx                      ; CPX T             ; If X <> Y, jump to Dk3 to return from the subroutine
     D414 00D1     
32121 D416 1615  14        jne  Dk3                        ; BNE Dk3
32122               
32123                                                                          ; We have a match between X and Y, so now to toggle
32124                                                                          ; the relevant configuration byte. CAPS LOCK has a key
32125                                                                          ; value of &40 and has its configuration byte at
32126                                                                          ; location DAMP, A has a value of &41 and has its byte
32127                                                                          ; at location DJD, which is DAMP+1, and so on. So we
32128                                                                          ; can toggle the configuration byte by changing the
32129                                                                          ; byte at DAMP + (X - &40), or to put it in indexing
32130                                                                          ; terms, DAMP-&40,X. It's no coincidence that the
32131                                                                          ; game's configuration bytes are set up in this order
32132                                                                          ; and with these keys (and this is also why the sound
32133                                                                          ; on/off keys are dealt with elsewhere, as the internal
32134                                                                          ; key for S and Q are &51 and &10, which don't fit
32135                                                                          ; nicely into this approach)
32136               
32137 D418 06CE  14        swpb rx                         ;
32138 D41A D36E  34        movb @DAMP->40(rx),ra           ; LDA DAMP-&40,X    ; Fetch the byte from DAMP + (X - &40), invert it and
     D41C 0F0A     
32139 D41E 06CE  14        swpb rx                         ;
32140                      .eoi (>ff*256)                  ; EOR #&FF          ; put it back (0 means no and &FF means yes in the
     **** ****     > EOI
0001 D420 0200  20        li   rtmp,(>FF*256)
     D422 FF00     
0002 D424 2B40  18        xor  rtmp,ra
                   < elite.a99
32141 D426 06CE  14        swpb rx                         ;
32142 D428 DB8D  38        movb ra,@DAMP->40(rx)           ; STA DAMP-&40,X    ; configuration bytes, so this toggles the setting)
     D42A 0F0A     
32143 D42C 06CE  14        swpb rx                         ;
32144               
32145 D42E 0200  20        li   rtmp,BELL                  ; JSR BELL          ; Make a beep sound so we know something has happened
     D430 3416     
32146 D432 06A0  32        bl   @jsr                       ;
     D434 FE28     
32147               
32148 D436 0200  20        li   rtmp,DELAY                 ; JSR DELAY         ; Wait for Y vertical syncs (Y is between 64 and 70, so
     D438 4FD0     
32149 D43A 06A0  32        bl   @jsr                       ;
     D43C FE28     
32150                                                                          ; this is always a bit longer than a second)
32151               
32152 D43E D3E0  30        movb @T,ry                      ; LDY T             ; Restore the configuration key argument into Y
     D440 00D1     
32153               
32154               Dk3:
32155 D442 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D444 FE34     
32156               
32157               * ******************************************************************************
32158               *
32159               * Name: DKJ1
32160               * Type: Subroutine
32161               * Category: Keyboard
32162               * Summary: Read joystick and flight controls
32163               *
32164               * ------------------------------------------------------------------------------
32165               *
32166               * Specifically, scan the keyboard for the speed up and slow down keys, and read
32167               * the joystick's fire button and X and Y axes, storing the results in the key
32168               * logger and the joystick position variables.
32169               *
32170               * This routine is only called if joysticks are enabled (JSTK = non-zero).
32171               *
32172               * ******************************************************************************
32173               
32174               DKJ1:
32175 D446 020F  20        li   ry,>01*256                 ; LDY #1            ; Update the key logger for key 1 in the KYTB table, so
     D448 0100     
32176 D44A 0200  20        li   rtmp,DKS1                  ; JSR DKS1          ; KY1 will be &FF if "?" (slow down) is being pressed
     D44C D3A6     
32177 D44E 06A0  32        bl   @jsr                       ;
     D450 FE28     
32178               
32179 D452 B3C7  18        ab   rone,ry                    ; INY               ; Update the key logger for key 2 in the KYTB table, so
32180 D454 0200  20        li   rtmp,DKS1                  ; JSR DKS1          ; KY2 will be &FF if Space (speed up) is being pressed
     D456 D3A6     
32181 D458 06A0  32        bl   @jsr                       ;
     D45A FE28     
32182               
32183 D45C D360  34        movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)
     D45E FE40     
32184               
32185 D460 D38D  18        movb ra,rx                      ; TAX               ; This instruction doesn't seem to have any effect, as
32186                                                                          ; X is overwritten in a few instructions. When the
32187                                                                          ; joystick is checked in a similar way in the TITLE
32188                                                                          ; subroutine for the "Press Fire Or Space,Commander."
32189                                                                          ; stage of the start-up screen, there's another
32190                                                                          ; unnecessary TAX instruction present, but there it's
32191                                                                          ; commented out
32192               
32193 D462 024D  22        andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
     D464 1000     
32194                                                                          ; button is pressed, otherwise it is set, so AND'ing
32195                                                                          ; the value of IRB with %10000 extracts this bit
32196               
32197                      .eoi (>10*256)                  ; EOR #%00010000    ; Flip bit 4 so that it's set if the fire button has
     **** ****     > EOI
0001 D466 0200  20        li   rtmp,(>10*256)
     D468 1000     
0002 D46A 2B40  18        xor  rtmp,ra
                   < elite.a99
32198 D46C D80D  30        movb ra,@KY7                    ; STA KY7           ; been pressed, and store the result in the keyboard
     D46E 0048     
32199                                                                          ; logger at location KY7, which is also where the A key
32200                                                                          ; (fire lasers) key is logged
32201               
32202 D470 020E  20        li   rx,>01*256                 ; LDX #1            ; Call DKS2 to fetch the value of ADC channel 1 (the
     D472 0100     
32203 D474 0200  20        li   rtmp,DKS2                  ; JSR DKS2          ; joystick X value) into (A X), and OR A with 1. This
     D476 D3F6     
32204 D478 06A0  32        bl   @jsr                       ;
     D47A FE28     
32205 D47C 026D  22        ori  ra,>01*256                 ; ORA #1            ; ensures that the high byte is at least 1, and then we
     D47E 0100     
32206 D480 D80D  30        movb ra,@JSTX                   ; STA JSTX          ; store the result in JSTX
     D482 009C     
32207               
32208 D484 020E  20        li   rx,>02*256                 ; LDX #2            ; Call DKS2 to fetch the value of ADC channel 2 (the
     D486 0200     
32209 D488 0200  20        li   rtmp,DKS2                  ; JSR DKS2          ; joystick Y value) into (A X), and EOR A with JSTGY.
     D48A D3F6     
32210 D48C 06A0  32        bl   @jsr                       ;
     D48E FE28     
32211                      .eor @JSTGY                     ; EOR JSTGY         ; JSTGY will be &FF if the game is configured to
     **** ****     > EOR
0001 D490 D020  30        movb @JSTGY,rtmp
     D492 0F4E     
0002 D494 2B40  18        xor  rtmp,ra
                   < elite.a99
32212 D496 D80D  30        movb ra,@JSTY                   ; STA JSTY          ; reverse the joystick Y channel, so this EOR does
     D498 009D     
32213                                                                          ; exactly that, and then we store the result in JSTY
32214               
32215 D49A 0460  28        b    @DK4                       ; JMP DK4           ; We are done scanning the joystick flight controls,
     D49C D526     
32216                                                                          ; so jump to DK4 to scan for other keys, using a tail
32217                                                                          ; call so we can return from the subroutine there
32218               
32219               * ******************************************************************************
32220               *
32221               * Name: U%
32222               * Type: Subroutine
32223               * Category: Keyboard
32224               * Summary: Clear the key logger
32225               *
32226               * ------------------------------------------------------------------------------
32227               *
32228               * Returns:
32229               *
32230               * A                   A is set to 0
32231               *
32232               * Y                   Y is set to 0
32233               *
32234               * ******************************************************************************
32235               
32236               U.:
32237 D49E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A to 0, as this means "key not pressed" in the
     D4A0 0000     
32238                                                                          ; key logger at KL
32239               
32240 D4A2 020F  20        li   ry,>0f*256                 ; LDY #15           ; We want to clear the 15 key logger locations from
     D4A4 0F00     
32241                                                                          ; KY1 to KY19, so set a counter in Y
32242               
32243               DKL3:
32244 D4A6 06CF  14        swpb ry                         ;
32245 D4A8 DBCD  38        movb ra,@KL(ry)                 ; STA KL,Y          ; Store 0 in the Y-th byte of the key logger
     D4AA 0041     
32246 D4AC 06CF  14        swpb ry                         ;
32247               
32248 D4AE 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the counter
32249               
32250 D4B0 16FA  14        jne  DKL3                       ; BNE DKL3          ; And loop back for the next key, until we have just
32251                                                                          ; KL+1. We don't want to clear the first key logger
32252                                                                          ; location at KL, as the keyboard table at KYTB starts
32253                                                                          ; with offset 1, not 0, so KL is not technically part of
32254                                                                          ; the key logger (it's actually used for logging keys
32255                                                                          ; that don't appear in the keyboard table, and which
32256                                                                          ; therefore don't use the key logger)
32257               
32258 D4B2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D4B4 FE34     
32259               
32260               * ******************************************************************************
32261               *
32262               * Name: DOKEY
32263               * Type: Subroutine
32264               * Category: Keyboard
32265               * Summary: Scan for the seven primary flight controls
32266               * Deep dive: The key logger
32267               * The docking computer
32268               *
32269               * ------------------------------------------------------------------------------
32270               *
32271               * Scan for the seven primary flight controls (or the equivalent on joystick),
32272               * pause and configuration keys, and secondary flight controls, and update the
32273               * key logger accordingly. Specifically:
32274               *
32275               * * If we are on keyboard configuration, clear the key logger and update it
32276               * for the seven primary flight controls, and update the pitch and roll
32277               * rates accordingly.
32278               *
32279               * * If we are on joystick configuration, clear the key logger and jump to
32280               * DKJ1, which reads the joystick equivalents of the primary flight
32281               * controls.
32282               *
32283               * Both options end up at DK4 to scan for other keys, beyond the seven primary
32284               * flight controls.
32285               *
32286               * ******************************************************************************
32287               
32288               DOKEY:
32289 D4B6 0200  20        li   rtmp,U.                    ; JSR U%            ; Call U% to clear the key logger
     D4B8 D49E     
32290 D4BA 06A0  32        bl   @jsr                       ;
     D4BC FE28     
32291               
32292 D4BE D360  30        movb @JSTK,ra                   ; LDA JSTK          ; If JSTK is non-zero, then we are configured to use
     D4C0 0F50     
32293 D4C2 16C1  14        jne  DKJ1                       ; BNE DKJ1          ; the joystick rather than keyboard, so jump to DKJ1
32294                                                                          ; to read the joystick flight controls, before jumping
32295                                                                          ; to DK4 to scan for pause, configuration and secondary
32296                                                                          ; flight keys
32297               
32298 D4C4 020F  20        li   ry,>07*256                 ; LDY #7            ; We're going to work our way through the primary flight
     D4C6 0700     
32299                                                                          ; control keys (pitch, roll, speed and laser), so set a
32300                                                                          ; counter in Y so we can loop through all 7
32301               
32302               DKL2:
32303 D4C8 0200  20        li   rtmp,DKS1                  ; JSR DKS1          ; Call DKS1 to see if the KYTB key at offset Y is being
     D4CA D3A6     
32304 D4CC 06A0  32        bl   @jsr                       ;
     D4CE FE28     
32305                                                                          ; pressed, and set the key logger accordingly
32306               
32307 D4D0 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
32308               
32309 D4D2 16FA  14        jne  DKL2                       ; BNE DKL2          ; Loop back for the next key, working our way from A at
32310                                                                          ; KYTB+7 down to ? at KYTB+1
32311               
32312 D4D4 D3A0  30        movb @JSTX,rx                   ; LDX JSTX          ; Set X = JSTX, the current roll rate (as shown in the
     D4D6 009C     
32313                                                                          ; RL indicator on the dashboard)
32314               
32315 D4D8 020D  20        li   ra,>07*256                 ; LDA #7            ; Set A to 7, which is the amount we want to alter the
     D4DA 0700     
32316                                                                          ; roll rate by if the roll keys are being pressed
32317               
32318 D4DC D3E0  30        movb @KL+3,ry                   ; LDY KL+3          ; If the "<" key is being pressed, then call the BUMP2
     D4DE 0044     
32319 D4E0 1304  14        jeq  B103                       ; BEQ B103          ; routine to increase the roll rate in X by A
32320 D4E2 0200  20        li   rtmp,BUMP2                 ; JSR BUMP2
     D4E4 4ADA     
32321 D4E6 06A0  32        bl   @jsr                       ;
     D4E8 FE28     
32322               
32323               B103:
32324 D4EA D3E0  30        movb @KL+4,ry                   ; LDY KL+4          ; If the ">" key is being pressed, then call the REDU2
     D4EC 0045     
32325 D4EE 1304  14        jeq  B104                       ; BEQ B104          ; routine to decrease the roll rate in X by A, taking
32326 D4F0 0200  20        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     D4F2 4AFC     
32327 D4F4 06A0  32        bl   @jsr                       ;
     D4F6 FE28     
32328               
32329               B104:
32330 D4F8 D80E  30        movb rx,@JSTX                   ; STX JSTX          ; Store the updated roll rate in JSTX
     D4FA 009C     
32331               
32332                      .asla                           ; ASL A             ; Double the value of A, to 14
     **** ****     > ASLA
0001 D4FC 024D  22        andi ra,>ff00
     D4FE FF00     
0002 D500 0A1D  18        sla  ra,1
                   < elite.a99
32333               
32334 D502 D3A0  30        movb @JSTY,rx                   ; LDX JSTY          ; Set X = JSTY, the current pitch rate (as shown in the
     D504 009D     
32335                                                                          ; DC indicator on the dashboard)
32336               
32337 D506 D3E0  30        movb @KL+5,ry                   ; LDY KL+5          ; If the "X" key is being pressed, then call the REDU2
     D508 0046     
32338 D50A 1304  14        jeq  B105                       ; BEQ B105          ; routine to decrease the pitch rate in X by A, taking
32339 D50C 0200  20        li   rtmp,REDU2                 ; JSR REDU2         ; the keyboard auto re-centre setting into account
     D50E 4AFC     
32340 D510 06A0  32        bl   @jsr                       ;
     D512 FE28     
32341               
32342               B105:
32343 D514 D3E0  30        movb @KL+6,ry                   ; LDY KL+6          ; If the "S" key is being pressed, then call the BUMP2
     D516 0047     
32344 D518 1304  14        jeq  B106                       ; BEQ B106          ; routine to increase the pitch rate in X by A
32345 D51A 0200  20        li   rtmp,BUMP2                 ; JSR BUMP2
     D51C 4ADA     
32346 D51E 06A0  32        bl   @jsr                       ;
     D520 FE28     
32347               
32348               B106:
32349 D522 D80E  30        movb rx,@JSTY                   ; STX JSTY          ; Store the updated roll rate in JSTY
     D524 009D     
32350               
32351                                                                          ; Fall through into DK4 to scan for other keys
32352               
32353               * ******************************************************************************
32354               *
32355               * Name: DK4
32356               * Type: Subroutine
32357               * Category: Keyboard
32358               * Summary: Scan for pause, configuration and secondary flight keys
32359               * Deep dive: The key logger
32360               *
32361               * ------------------------------------------------------------------------------
32362               *
32363               * Scan for pause and configuration keys, and if this is a space view, also scan
32364               * for secondary flight controls.
32365               *
32366               * Specifically:
32367               *
32368               * * Scan for the pause button (COPY) and if it's pressed, pause the game and
32369               * process any configuration key presses until the game is unpaused (DELETE)
32370               *
32371               * * If this is a space view, scan for secondary flight keys and update the
32372               * relevant bytes in the key logger
32373               *
32374               * ******************************************************************************
32375               
32376               DK4:
32377 D526 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     D528 D284     
32378 D52A 06A0  32        bl   @jsr                       ;
     D52C FE28     
32379                                                                          ; internal key number in X (or 0 for no key press)
32380               
32381 D52E D80E  30        movb rx,@KL                     ; STX KL            ; Store X in KL, byte #0 of the key logger
     D530 0041     
32382               
32383 D532 028E  22        ci   rx,>69*256                 ; CPX #&69          ; If COPY is not being pressed, jump to DK2 below,
     D534 6900     
32384 D536 1626  14        jne  DK2                        ; BNE DK2           ; otherwise let's process the configuration keys
32385               
32386               FREEZE:
32387                                                                          ; COPY is being pressed, so we enter a loop that
32388                                                                          ; listens for configuration keys, and we keep looping
32389                                                                          ; until we detect a DELETE key press. This effectively
32390                                                                          ; pauses the game when COPY is pressed, and unpauses
32391                                                                          ; it when DELETE is pressed
32392 D538 0200  20        li   rtmp,WSCAN                 ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
     D53A 51C2     
32393 D53C 06A0  32        bl   @jsr                       ;
     D53E FE28     
32394                                                                          ; screen gets drawn
32395               
32396 D540 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     D542 D284     
32397 D544 06A0  32        bl   @jsr                       ;
     D546 FE28     
32398                                                                          ; internal key number in X (or 0 for no key press)
32399               
32400 D548 028E  22        ci   rx,>51*256                 ; CPX #&51          ; If "S" is not being pressed, skip to DK6
     D54A 5100     
32401 D54C 1604  14        jne  DK6                        ; BNE DK6
32402               
32403 D54E 020D  20        li   ra,>00*256                 ; LDA #0            ; "S" is being pressed, so set DNOIZ to 0 to turn the
     D550 0000     
32404 D552 D80D  30        movb ra,@DNOIZ                  ; STA DNOIZ         ; sound on
     D554 0F49     
32405               
32406               DK6:
32407 D556 020F  20        li   ry,>40*256                 ; LDY #&40          ; We now want to loop through the keys that toggle
     D558 4000     
32408                                                                          ; various settings. These have internal key numbers
32409                                                                          ; between &40 (CAPS LOCK) and &46 ("K"), so we set up
32410                                                                          ; the first key number in Y to act as a loop counter.
32411                                                                          ; See subroutine DKS3 for more details on this
32412               
32413               DKL4:
32414 D55A 0200  20        li   rtmp,DKS3                  ; JSR DKS3          ; Call DKS3 to scan for the key given in Y, and toggle
     D55C D40E     
32415 D55E 06A0  32        bl   @jsr                       ;
     D560 FE28     
32416                                                                          ; the relevant setting if it is pressed
32417               
32418 D562 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to the next toggle key
32419               
32420 D564 028F  22        ci   ry,>47*256                 ; CPY #&47          ; The last toggle key is &46 (K), so check whether we
     D566 4700     
32421                                                                          ; have just done that one
32422               
32423 D568 16F8  14        jne  DKL4                       ; BNE DKL4          ; If not, loop back to check for the next toggle key
32424               
32425               DK55:
32426 D56A 028E  22        ci   rx,>10*256                 ; CPX #&10          ; If "Q" is not being pressed, skip to DK7
     D56C 1000     
32427 D56E 1602  14        jne  DK7                        ; BNE DK7
32428               
32429 D570 D80E  30        movb rx,@DNOIZ                  ; STX DNOIZ         ; "Q" is being pressed, so set DNOIZ to X, which is
     D572 0F49     
32430                                                                          ; non-zero (&10), so this will turn the sound off
32431               
32432               DK7:
32433 D574 028E  22        ci   rx,>70*256                 ; CPX #&70          ; If ESCAPE is not being pressed, skip over the next
     D576 7000     
32434 D578 1602  14        jne  B107                       ; BNE B107          ; instruction
32435               
32436 D57A 0460  28        b    @DEATH2                    ; JMP DEATH2        ; ESCAPE is being pressed, so jump to DEATH2 to end
     D57C CCF4     
32437                                                                          ; the game
32438               
32439               B107:
32440 D57E 028E  22        ci   rx,>59*256                 ; CPX #&59          ; If DELETE is not being pressed, we are still paused,
     D580 5900     
32441 D582 16DA  14        jne  FREEZE                     ; BNE FREEZE        ; so loop back up to keep listening for configuration
32442                                                                          ; keys, otherwise fall through into the rest of the
32443                                                                          ; key detection code, which unpauses the game
32444               
32445               DK2:
32446 D584 D360  30        movb @QQ11,ra                   ; LDA QQ11          ; If the current view is non-zero (i.e. not a space
     D586 0096     
32447 D588 1613  14        jne  DK5                        ; BNE DK5           ; view), return from the subroutine (as DK5 contains
32448                                                                          ; an RTS)
32449               
32450 D58A 020F  20        li   ry,>0f*256                 ; LDY #15           ; This is a space view, so now we want to check for all
     D58C 0F00     
32451                                                                          ; the secondary flight keys. The internal key numbers
32452                                                                          ; are in the keyboard table KYTB from KYTB+8 to
32453                                                                          ; KYTB+15, and their key logger locations are from KL+8
32454                                                                          ; to KL+15. So set a decreasing counter in Y for the
32455                                                                          ; index, starting at 15, so we can loop through them
32456               
32457 D58E 020D  20        li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can store this in the keyboard
     D590 FF00     
32458                                                                          ; logger for keys that are being pressed
32459               
32460               DKL1:
32461 D592 06CF  14        swpb ry                         ;
32462 D594 D3AF  34        movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number of the Y-th flight key
     D596 D395     
32463 D598 06CF  14        swpb ry                         ;
32464                                                                          ; the KYTB keyboard table
32465               
32466 D59A 93A0  30        cb   @KL,rx                     ; CPX KL            ; We stored the key that's being pressed in KL above,
     D59C 0041     
32467                                                                          ; so check to see if the Y-th flight key is being
32468                                                                          ; pressed
32469               
32470 D59E 1604  14        jne  DK1                        ; BNE DK1           ; If it is not being pressed, skip to DK1 below
32471               
32472 D5A0 06CF  14        swpb ry                         ;
32473 D5A2 DBCD  38        movb ra,@KL(ry)                 ; STA KL,Y          ; The Y-th flight key is being pressed, so set that
     D5A4 0041     
32474 D5A6 06CF  14        swpb ry                         ;
32475                                                                          ; key's location in the key logger to &FF
32476               
32477               DK1:
32478 D5A8 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter
32479               
32480 D5AA 028F  22        ci   ry,>07*256                 ; CPY #7            ; Have we just done the last key?
     D5AC 0700     
32481               
32482 D5AE 16F1  14        jne  DKL1                       ; BNE DKL1          ; If not, loop back to process the next key
32483               
32484               DK5:
32485 D5B0 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D5B2 FE34     
32486               
32487               * ******************************************************************************
32488               *
32489               * Name: TT217
32490               * Type: Subroutine
32491               * Category: Keyboard
32492               * Summary: Scan the keyboard until a key is pressed
32493               *
32494               * ------------------------------------------------------------------------------
32495               *
32496               * Scan the keyboard until a key is pressed, and return the key's ASCII code.
32497               * If, on entry, a key is already being held down, then wait until that key is
32498               * released first (so this routine detects the first key down event following
32499               * the subroutine call).
32500               *
32501               * ------------------------------------------------------------------------------
32502               *
32503               * Returns:
32504               *
32505               * X                   The ASCII code of the key that was pressed
32506               *
32507               * A                   Contains the same as X
32508               *
32509               * Y                   Y is preserved
32510               *
32511               * ------------------------------------------------------------------------------
32512               *
32513               * Other entry points:
32514               *
32515               * out                 Contains an RTS
32516               *
32517               * ******************************************************************************
32518               
32519               TT217:
32520 D5B4 D80F  30        movb ry,@YSAV                   ; STY YSAV          ; Store Y in temporary storage, so we can restore it
     D5B6 0094     
32521                                                                          ; later
32522               
32523               t_:
32524 D5B8 0200  20        li   rtmp,DELAY-5               ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds) so we
     D5BA 4FCB     
32525 D5BC 06A0  32        bl   @jsr                       ;
     D5BE FE28     
32526                                                                          ; don't take up too much CPU time while looping round
32527               
32528 D5C0 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Scan the keyboard for a key press and return the
     D5C2 D284     
32529 D5C4 06A0  32        bl   @jsr                       ;
     D5C6 FE28     
32530                                                                          ; internal key number in X (or 0 for no key press)
32531               
32532 D5C8 16F7  14        jne  t_                         ; BNE t             ; If a key was already being held down when we entered
32533                                                                          ; this routine, keep looping back up to t, until the
32534                                                                          ; key is released
32535               
32536               t2_:
32537 D5CA 0200  20        li   rtmp,RDKEY                 ; JSR RDKEY         ; Any pre-existing key press is now gone, so we can
     D5CC D284     
32538 D5CE 06A0  32        bl   @jsr                       ;
     D5D0 FE28     
32539                                                                          ; start scanning the keyboard again, returning the
32540                                                                          ; internal key number in X (or 0 for no key press)
32541               
32542 D5D2 13FB  14        jeq  t2_                        ; BEQ t2            ; Keep looping up to t2 until a key is pressed
32543               
32544 D5D4 D3CD  18        movb ra,ry                      ; TAY               ; Copy A to Y, so Y contains the internal key number
32545                                                                          ; of the key pressed
32546               
32547                      .ld_ind_y_idx @TRTB.,ra         ; LDA (TRTB%),Y     ; The address in TRTB% points to the MOS key
     **** ****     > LD_IND_Y_IDX
0001 D5D6 D820  42        movb @TRTB.,@rtmplb
     D5D8 0004     
     D5DA 8301     
0002 D5DC D020  30        movb @TRTB.+1,rtmp
     D5DE 0005     
0003 D5E0 06CF  14        swpb ry
0004 D5E2 A00F  18        a    ry,rtmp
0005 D5E4 06CF  14        swpb ry
0006 D5E6 D350  26        movb *rtmp,RA
                   < elite.a99
32548                                                                          ; translation table, which is used to translate
32549                                                                          ; internal key numbers to ASCII, so this fetches the
32550                                                                          ; key's ASCII code into A
32551               
32552 D5E8 D3E0  30        movb @YSAV,ry                   ; LDY YSAV          ; Restore the original value of Y we stored above
     D5EA 0094     
32553               
32554 D5EC D38D  18        movb ra,rx                      ; TAX               ; Copy A into X
32555               
32556               out_:
32557 D5EE 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D5F0 FE34     
32558               
32559               * ******************************************************************************
32560               *
32561               * Name: me1
32562               * Type: Subroutine
32563               * Category: Flight
32564               * Summary: Erase an old in-flight message and display a new one
32565               *
32566               * ------------------------------------------------------------------------------
32567               *
32568               * Arguments:
32569               *
32570               * A                   The text token to be printed
32571               *
32572               * X                   Must be set to 0
32573               *
32574               * ******************************************************************************
32575               
32576               me1_:
32577 D5F2 D80E  30        movb rx,@DLY                    ; STX DLY           ; Set the message delay in DLY to 0, so any new
     D5F4 0D64     
32578                                                                          ; in-flight messages will be shown instantly
32579               
32580                      .pha                            ; PHA               ; Store the new message token we want to print
     **** ****     > PHA
0001 D5F6 D68D  30        movb ra,*rsp
0002 D5F8 060A  14        dec  rsp
                   < elite.a99
32581               
32582 D5FA D360  30        movb @MCH,ra                    ; LDA MCH           ; Set A to the token number of the message that is
     D5FC 0F10     
32583 D5FE 0200  20        li   rtmp,mes9_                 ; JSR mes9          ; currently on-screen, and call mes9 to print it (which
     D600 D63C     
32584 D602 06A0  32        bl   @jsr                       ;
     D604 FE28     
32585                                                                          ; will remove it from the screen, as printing is done
32586                                                                          ; using EOR logic)
32587               
32588                      .pla                            ; PLA               ; Restore the new message token
     **** ****     > PLA
0001 D606 058A  14        inc  rsp
0002 D608 D35A  26        movb *rsp,ra
                   < elite.a99
32589               
32590 D60A 2C              byte >2c                                            ; Fall through into ou2 to print the new message, but
32591                                                                          ; skip the first instruction by turning it into
32592                                                                          ; &2C &A9 &6C, or BIT &6CA9, which does nothing apart
32593                                                                          ; from affect the flags
32594               
32595               * ******************************************************************************
32596               *
32597               * Name: ou2
32598               * Type: Subroutine
32599               * Category: Flight
32600               * Summary: Display "E.C.M.SYSTEM DESTROYED" as an in-flight message
32601               *
32602               * ******************************************************************************
32603               
32604               ou2_:
32605 D60C 020D  20        li   ra,>6c*256                 ; LDA #108          ; Set A to recursive token 108 ("E.C.M.SYSTEM")
     D60E 6C00     
32606               
32607 D610 2C              byte >2c                                            ; Fall through into ou3 to print the new message, but
32608                                                                          ; skip the first instruction by turning it into
32609                                                                          ; &2C &A9 &6F, or BIT &6FA9, which does nothing apart
32610                                                                          ; from affect the flags
32611               
32612               * ******************************************************************************
32613               *
32614               * Name: ou3
32615               * Type: Subroutine
32616               * Category: Flight
32617               * Summary: Display "FUEL SCOOPS DESTROYED" as an in-flight message
32618               *
32619               * ******************************************************************************
32620               
32621               ou3_:
32622 D612 020D  20        li   ra,>6f*256                 ; LDA #111          ; Set A to recursive token 111 ("FUEL SCOOPS")
     D614 6F00     
32623               
32624               * ******************************************************************************
32625               *
32626               * Name: MESS
32627               * Type: Subroutine
32628               * Category: Flight
32629               * Summary: Display an in-flight message
32630               *
32631               * ------------------------------------------------------------------------------
32632               *
32633               * Display an in-flight message in capitals at the bottom of the space view,
32634               * erasing any existing in-flight message first.
32635               *
32636               * ------------------------------------------------------------------------------
32637               *
32638               * Arguments:
32639               *
32640               * A                   The text token to be printed
32641               *
32642               * ******************************************************************************
32643               
32644               MESS:
32645 D616 020E  20        li   rx,>00*256                 ; LDX #0            ; Set QQ17 = 0 to switch to ALL CAPS
     D618 0000     
32646 D61A D80E  30        movb rx,@QQ17                   ; STX QQ17
     D61C 007E     
32647               
32648 D61E 020F  20        li   ry,>09*256                 ; LDY #9            ; Move the text cursor to column 9, row 22, at the
     D620 0900     
32649 D622 D80F  30        movb ry,@XC                     ; STY XC            ; bottom middle of the screen, and set Y = 22
     D624 002C     
32650 D626 020F  20        li   ry,>16*256                 ; LDY #22
     D628 1600     
32651 D62A D80F  30        movb ry,@YC                     ; STY YC
     D62C 002D     
32652               
32653 D62E 93A0  30        cb   @DLY,rx                    ; CPX DLY           ; If the message delay in DLY is not zero, jump up to
     D630 0D64     
32654 D632 16DF  14        jne  me1_                       ; BNE me1           ; me1 to erase the current message first (whose token
32655                                                                          ; number will be in MCH)
32656               
32657 D634 D80F  30        movb ry,@DLY                    ; STY DLY           ; Set the message delay in DLY to 22
     D636 0D64     
32658               
32659 D638 D80D  30        movb ra,@MCH                    ; STA MCH           ; Set MCH to the token we are about to display
     D63A 0F10     
32660               
32661                                                                          ; Fall through into mes9 to print the token in A
32662               
32663               * ******************************************************************************
32664               *
32665               * Name: mes9
32666               * Type: Subroutine
32667               * Category: Flight
32668               * Summary: Print a text token, possibly followed by " DESTROYED"
32669               *
32670               * ------------------------------------------------------------------------------
32671               *
32672               * Print a text token, followed by " DESTROYED" if the destruction flag is set
32673               * (for when a piece of equipment is destroyed).
32674               *
32675               * ******************************************************************************
32676               
32677               mes9_:
32678 D63C 0200  20        li   rtmp,TT27                  ; JSR TT27          ; Call TT27 to print the text token in A
     D63E ACA0     
32679 D640 06A0  32        bl   @jsr                       ;
     D642 FE28     
32680               
32681                      .lsr @de_                       ; LSR de            ; If bit 0 of variable de is clear, return from the
     **** ****     > LSR
0001 D644 D020  30        movb @DE_,rtmp
     D646 0D65     
0002 D648 0910  18        srl  rtmp,1
0003 D64A D800  30        movb rtmp,@DE_
     D64C 0D65     
                   < elite.a99
32682 D64E 17CF  14        jnc  out_                       ; BCC out           ; subroutine (as out contains an RTS)
32683               
32684 D650 020D  20        li   ra,>fd*256                 ; LDA #253          ; Print recursive token 93 (" DESTROYED") and return
     D652 FD00     
32685 D654 0460  28        b    @TT27                      ; JMP TT27          ; from the subroutine using a tail call
     D656 ACA0     
32686               
32687               * ******************************************************************************
32688               *
32689               * Name: OUCH
32690               * Type: Subroutine
32691               * Category: Flight
32692               * Summary: Potentially lose cargo or equipment following damage
32693               *
32694               * ------------------------------------------------------------------------------
32695               *
32696               * Our shields are dead and we are taking damage, so there is a small chance of
32697               * losing cargo or equipment.
32698               *
32699               * ******************************************************************************
32700               
32701               OUCH:
32702 D658 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     D65A C7D0     
32703 D65C 06A0  32        bl   @jsr                       ;
     D65E FE28     
32704               
32705 D660 11C6  14        jlt  out_                       ; BMI out           ; If A < 0 (50% chance), return from the subroutine
32706                                                                          ; (as out contains an RTS)
32707               
32708 D662 028E  22        ci   rx,>16*256                 ; CPX #22           ; If X >= 22 (91% chance), return from the subroutine
     D664 1600     
32709 D666 18C3  14        joc  out_                       ; BCS out           ; (as out contains an RTS)
32710               
32711 D668 06CE  14        swpb rx                         ;
32712 D66A D36E  34        movb @QQ20(rx),ra               ; LDA QQ20,X        ; If we do not have any of item QQ20+X, return from the
     D66C 0317     
32713 D66E 06CE  14        swpb rx                         ;
32714 D670 13BE  14        jeq  out_                       ; BEQ out           ; subroutine (as out contains an RTS). X is in the range
32715                                                                          ; 0-21, so this not only checks for cargo, but also for
32716                                                                          ; E.C.M., fuel scoops, energy bomb, energy unit and
32717                                                                          ; docking computer, all of which can be destroyed
32718               
32719 D672 D360  30        movb @DLY,ra                    ; LDA DLY           ; If there is already an in-flight message on-screen,
     D674 0D64     
32720 D676 16BB  14        jne  out_                       ; BNE out           ; return from the subroutine (as out contains an RTS)
32721               
32722 D678 020F  20        li   ry,>03*256                 ; LDY #3            ; Set bit 1 of de, the equipment destruction flag, so
     D67A 0300     
32723 D67C D80F  30        movb ry,@de_                    ; STY de            ; that when we call MESS below, " DESTROYED" is appended
     D67E 0D65     
32724                                                                          ; to the in-flight message
32725               
32726 D680 06CE  14        swpb rx                         ;
32727 D682 DB8D  38        movb ra,@QQ20(rx)               ; STA QQ20,X        ; A is 0 (as we didn't branch with the BNE above), so
     D684 0317     
32728 D686 06CE  14        swpb rx                         ;
32729                                                                          ; this sets QQ20+X to 0, which destroys any cargo or
32730                                                                          ; equipment we have of that type
32731               
32732 D688 028E  22        ci   rx,>11*256                 ; CPX #17           ; If X >= 17 then we just lost a piece of equipment, so
     D68A 1100     
32733 D68C 1806  14        joc  ou1_                       ; BCS ou1           ; jump to ou1 to print the relevant message
32734               
32735 D68E D34E  18        movb rx,ra                      ; TXA               ; Print recursive token 48 + A as an in-flight token,
32736                      .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
     **** ****     > ADI
0001 D690 1701  14        jnc  !
0002 D692 B347  18        ab   rone,ra
0003               !:
0004 D694 022D  22        ai   ra,(>D0*256)
     D696 D000     
                   < elite.a99
32737 D698 16BE  14        jne  MESS                       ; BNE MESS          ; ITEMS") as the C flag is clear, so this prints the
32738                                                                          ; destroyed item's name, followed by " DESTROYED" (as we
32739                                                                          ; set bit 1 of the de flag above), and returns from the
32740                                                                          ; subroutine using a tail call
32741               
32742               ou1_:
32743 D69A 13B8  14        jeq  ou2_                       ; BEQ ou2           ; If X = 17, jump to ou2 to print "E.C.M.SYSTEM
32744                                                                          ; DESTROYED" and return from the subroutine using a tail
32745                                                                          ; call
32746               
32747 D69C 028E  22        ci   rx,>12*256                 ; CPX #18           ; If X = 18, jump to ou3 to print "FUEL SCOOPS
     D69E 1200     
32748 D6A0 13B8  14        jeq  ou3_                       ; BEQ ou3           ; DESTROYED" and return from the subroutine using a tail
32749                                                                          ; call
32750               
32751 D6A2 D34E  18        movb rx,ra                      ; TXA               ; Otherwise X is in the range 19 to 21 and the C flag is
32752                      .adi ((113-20)*256)             ; ADC #113-20       ; set (as we got here via a BCS to ou1), so we set A as
     **** ****     > ADI
0001 D6A4 1701  14        jnc  !
0002 D6A6 B347  18        ab   rone,ra
0003               !:
0004 D6A8 022D  22        ai   ra,((113-20)*256)
     D6AA 5D00     
                   < elite.a99
32753                                                                          ; follows:
32754                                                                          ;
32755                                                                          ; A = 113 - 20 + X + C
32756                                                                          ; = 113 - 19 + X
32757                                                                          ; = 113 to 115
32758               
32759 D6AC 16B4  14        jne  MESS                       ; BNE MESS          ; Print recursive token A ("ENERGY BOMB", "ENERGY UNIT"
32760                                                                          ; or "DOCKING COMPUTERS") as an in-flight message,
32761                                                                          ; followed by " DESTROYED", and return from the
32762                                                                          ; subroutine using a tail call
32763               
32764               * ******************************************************************************
32765               *
32766               * Name: QQ16
32767               * Type: Variable
32768               * Category: Text
32769               * Summary: The two-letter token lookup table
32770               * Deep dive: Printing text tokens
32771               *
32772               * ------------------------------------------------------------------------------
32773               *
32774               * Two-letter token lookup table for tokens 128-159. See the deep dive on
32775               * "Printing text tokens" for details of how the two-letter token system works.
32776               *
32777               * ******************************************************************************
32778               
32779               QQ16:
32780 D6AE 414C            text 'AL'                                           ; Token 128
32781 D6B0 4C45            text 'LE'                                           ; Token 129
32782 D6B2 5845            text 'XE'                                           ; Token 130
32783 D6B4 4745            text 'GE'                                           ; Token 131
32784 D6B6 5A41            text 'ZA'                                           ; Token 132
32785 D6B8 4345            text 'CE'                                           ; Token 133
32786 D6BA 4249            text 'BI'                                           ; Token 134
32787 D6BC 534F            text 'SO'                                           ; Token 135
32788 D6BE 5553            text 'US'                                           ; Token 136
32789 D6C0 4553            text 'ES'                                           ; Token 137
32790 D6C2 4152            text 'AR'                                           ; Token 138
32791 D6C4 4D41            text 'MA'                                           ; Token 139
32792 D6C6 494E            text 'IN'                                           ; Token 140
32793 D6C8 4449            text 'DI'                                           ; Token 141
32794 D6CA 5245            text 'RE'                                           ; Token 142
32795 D6CC 413F            text 'A?'                                           ; Token 143
32796 D6CE 4552            text 'ER'                                           ; Token 144
32797 D6D0 4154            text 'AT'                                           ; Token 145
32798 D6D2 454E            text 'EN'                                           ; Token 146
32799 D6D4 4245            text 'BE'                                           ; Token 147
32800 D6D6 5241            text 'RA'                                           ; Token 148
32801 D6D8 4C41            text 'LA'                                           ; Token 149
32802 D6DA 5645            text 'VE'                                           ; Token 150
32803 D6DC 5449            text 'TI'                                           ; Token 151
32804 D6DE 4544            text 'ED'                                           ; Token 152
32805 D6E0 4F52            text 'OR'                                           ; Token 153
32806 D6E2 5155            text 'QU'                                           ; Token 154
32807 D6E4 414E            text 'AN'                                           ; Token 155
32808 D6E6 5445            text 'TE'                                           ; Token 156
32809 D6E8 4953            text 'IS'                                           ; Token 157
32810 D6EA 5249            text 'RI'                                           ; Token 158
32811 D6EC 4F4E            text 'ON'                                           ; Token 159
32812               
32813               * ******************************************************************************
32814               *
32815               * Name: ITEM
32816               * Type: Macro
32817               * Category: Market
32818               * Summary: Macro definition for the market prices table
32819               * Deep dive: Market item prices and availability
32820               *
32821               * ------------------------------------------------------------------------------
32822               *
32823               * The following macro is used to build the market prices table:
32824               *
32825               * ITEM price, factor, units, quantity, mask
32826               *
32827               * It inserts an item into the market prices table at QQ23. See the deep dive on
32828               * "Market item prices and availability" for more information on how the market
32829               * system works.
32830               *
32831               * ------------------------------------------------------------------------------
32832               *
32833               * Arguments:
32834               *
32835               * price               Base price
32836               *
32837               * factor              Economic factor
32838               *
32839               * units               Units: "t", "g" or "k"
32840               *
32841               * quantity            Base quantity
32842               *
32843               * mask                Fluctuations mask
32844               *
32845               * ******************************************************************************
32846               
32847                      ; MACRO ITEM price, factor, units, quantity, mask
32848               
32849                      ; IF factor < 0                 ;
32850                      ; s = 1 << 7                    ;
32851                      ; ELSE                          ;
32852                      ; s = 0                         ;
32853                      ; ENDIF                         ;
32854               
32855                      ; IF units = 't'                ;
32856                      ; u = 0                         ;
32857                      ; ELIF units = 'k'              ;
32858                      ; u = 1 << 5                    ;
32859                      ; ELSE                          ;
32860                      ; u = 1 << 6                    ;
32861                      ; ENDIF                         ;
32862               
32863                      ; e = ABS(factor)               ;
32864               
32865                      ; EQUB price                    ;
32866                      ; EQUB s + u + e                ;
32867                      ; EQUB quantity                 ;
32868                      ; EQUB mask                     ;
32869               
32870                      ; ENDMACRO
32871               
32872               * ******************************************************************************
32873               *
32874               * Name: QQ23
32875               * Type: Variable
32876               * Category: Market
32877               * Summary: Market prices table
32878               *
32879               * ------------------------------------------------------------------------------
32880               *
32881               * Each item has four bytes of data, like this:
32882               *
32883               * Byte #0 = Base price
32884               * Byte #1 = Economic factor in bits 0-4, with the sign in bit 7
32885               * Unit in bits 5-6
32886               * Byte #2 = Base quantity
32887               * Byte #3 = Mask to control price fluctuations
32888               *
32889               * To make it easier for humans to follow, we've defined a macro called ITEM
32890               * that takes the following arguments and builds the four bytes for us:
32891               *
32892               * ITEM base price, economic factor, units, base quantity, mask
32893               *
32894               * So for food, we have the following:
32895               *
32896               * * Base price = 19
32897               * * Economic factor = -2
32898               * * Unit = tonnes
32899               * * Base quantity = 6
32900               * * Mask = %00000001
32901               *
32902               * ******************************************************************************
32903               
32904               QQ23:
32905 D6EE 1382            byte >13, >82, >06, >01                             ; 0 = Food
     D6F0 0601     
32906 D6F2 1481            byte >14, >81, >0a, >03                             ; 1 = Textiles
     D6F4 0A03     
32907 D6F6 4183            byte >41, >83, >02, >07                             ; 2 = Radioactives
     D6F8 0207     
32908 D6FA 2885            byte >28, >85, >e2, >1f                             ; 3 = Slaves
     D6FC E21F     
32909 D6FE 5385            byte >53, >85, >fb, >0f                             ; 4 = Liquor/Wines
     D700 FB0F     
32910 D702 C408            byte >c4, >08, >36, >03                             ; 5 = Luxuries
     D704 3603     
32911 D706 EB1D            byte >eb, >1d, >08, >78                             ; 6 = Narcotics
     D708 0878     
32912 D70A 9A0E            byte >9a, >0e, >38, >03                             ; 7 = Computers
     D70C 3803     
32913 D70E 7506            byte >75, >06, >28, >07                             ; 8 = Machinery
     D710 2807     
32914 D712 4E01            byte >4e, >01, >11, >1f                             ; 9 = Alloys
     D714 111F     
32915 D716 7C0D            byte >7c, >0d, >1d, >07                             ; 10 = Firearms
     D718 1D07     
32916 D71A B089            byte >b0, >89, >dc, >3f                             ; 11 = Furs
     D71C DC3F     
32917 D71E 2081            byte >20, >81, >35, >03                             ; 12 = Minerals
     D720 3503     
32918 D722 61A1            byte >61, >a1, >42, >07                             ; 13 = Gold
     D724 4207     
32919 D726 ABA2            byte >ab, >a2, >37, >1f                             ; 14 = Platinum
     D728 371F     
32920 D72A 2DC1            byte >2d, >c1, >fa, >0f                             ; 15 = Gem-Stones
     D72C FA0F     
32921 D72E 350F            byte >35, >0f, >c0, >07                             ; 16 = Alien items
     D730 C007     
32922               
32923               * ******************************************************************************
32924               *
32925               * Name: TIDY
32926               * Type: Subroutine
32927               * Category: Maths (Geometry)
32928               * Summary: Orthonormalise the orientation vectors for a ship
32929               * Deep dive: Tidying orthonormal vectors
32930               * Orientation vectors
32931               *
32932               * ------------------------------------------------------------------------------
32933               *
32934               * This routine orthonormalises the orientation vectors for a ship. This means
32935               * making the three orientation vectors orthogonal (perpendicular to each other),
32936               * and normal (so each of the vectors has length 1).
32937               *
32938               * We do this because we use the small angle approximation to rotate these
32939               * vectors in space. It is not completely accurate, so the three vectors tend
32940               * to get stretched over time, so periodically we tidy the vectors with this
32941               * routine to ensure they remain as orthonormal as possible.
32942               *
32943               * ******************************************************************************
32944               
32945               TI2:
32946                                                                          ; Called from below with A = 0, X = 0, Y = 4 when
32947                                                                          ; nosev_x and nosev_y are small, so we assume that
32948                                                                          ; nosev_z is big
32949 D732 D34F  18        movb ry,ra                      ; TYA               ; A = Y = 4
32950 D734 020F  20        li   ry,>02*256                 ; LDY #2
     D736 0200     
32951 D738 0200  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 2, A = 4, to set roofv_z =
     D73A D8F6     
32952 D73C 06A0  32        bl   @jsr                       ;
     D73E FE28     
32953 D740 D80D  30        movb ra,@INWK+20                ; STA INWK+20       ; -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
     D742 0067     
32954               
32955 D744 0460  28        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     D746 D7C2     
32956               
32957               TI1:
32958                                                                          ; Called from below with A = 0, Y = 4 when nosev_x is
32959                                                                          ; small
32960 D748 D38D  18        movb ra,rx                      ; TAX               ; Set X = A = 0
32961               
32962 D74A D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = nosev_y, and if the top two magnitude bits
     D74C 0032     
32963 D74E 024D  22        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI2 with A = 0, X = 0, Y = 4
     D750 6000     
32964 D752 13EF  14        jeq  TI2                        ; BEQ TI2
32965               
32966 D754 020D  20        li   ra,>02*256                 ; LDA #2            ; Otherwise nosev_y is big, so set up the index values
     D756 0200     
32967                                                                          ; to pass to TIS3
32968               
32969 D758 0200  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 0, Y = 4, A = 2, to set roofv_y =
     D75A D8F6     
32970 D75C 06A0  32        bl   @jsr                       ;
     D75E FE28     
32971 D760 D80D  30        movb ra,@INWK+18                ; STA INWK+18       ; -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
     D762 0065     
32972               
32973 D764 0460  28        b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying
     D766 D7C2     
32974               
32975               TIDY:
32976 D768 D360  30        movb @INWK+10,ra                ; LDA INWK+10       ; Set (XX15, XX15+1, XX15+2) = nosev
     D76A 005D     
32977 D76C D80D  30        movb ra,@XX15                   ; STA XX15
     D76E 0031     
32978 D770 D360  30        movb @INWK+12,ra                ; LDA INWK+12
     D772 005F     
32979 D774 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D776 0032     
32980 D778 D360  30        movb @INWK+14,ra                ; LDA INWK+14
     D77A 0061     
32981 D77C D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     D77E 0033     
32982               
32983 D780 0200  20        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. nosev
     D782 D1D0     
32984 D784 06A0  32        bl   @jsr                       ;
     D786 FE28     
32985               
32986 D788 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set nosev = (XX15, XX15+1, XX15+2)
     D78A 0031     
32987 D78C D80D  30        movb ra,@INWK+10                ; STA INWK+10
     D78E 005D     
32988 D790 D360  30        movb @XX15+1,ra                 ; LDA XX15+1
     D792 0032     
32989 D794 D80D  30        movb ra,@INWK+12                ; STA INWK+12
     D796 005F     
32990 D798 D360  30        movb @XX15+2,ra                 ; LDA XX15+2
     D79A 0033     
32991 D79C D80D  30        movb ra,@INWK+14                ; STA INWK+14
     D79E 0061     
32992               
32993 D7A0 020F  20        li   ry,>04*256                 ; LDY #4            ; Set Y = 4
     D7A2 0400     
32994               
32995 D7A4 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = nosev_x, and if the top two magnitude bits
     D7A6 0031     
32996 D7A8 024D  22        andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI1 with A = 0, Y = 4
     D7AA 6000     
32997 D7AC 13CD  14        jeq  TI1                        ; BEQ TI1
32998               
32999 D7AE 020E  20        li   rx,>02*256                 ; LDX #2            ; Otherwise nosev_x is big, so set up the index values
     D7B0 0200     
33000 D7B2 020D  20        li   ra,>00*256                 ; LDA #0            ; to pass to TIS3
     D7B4 0000     
33001               
33002 D7B6 0200  20        li   rtmp,TIS3                  ; JSR TIS3          ; Call TIS3 with X = 2, Y = 4, A = 0, to set roofv_x =
     D7B8 D8F6     
33003 D7BA 06A0  32        bl   @jsr                       ;
     D7BC FE28     
33004 D7BE D80D  30        movb ra,@INWK+16                ; STA INWK+16       ; -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
     D7C0 0063     
33005               
33006               TI3:
33007 D7C2 D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set (XX15, XX15+1, XX15+2) = roofv
     D7C4 0063     
33008 D7C6 D80D  30        movb ra,@XX15                   ; STA XX15
     D7C8 0031     
33009 D7CA D360  30        movb @INWK+18,ra                ; LDA INWK+18
     D7CC 0065     
33010 D7CE D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     D7D0 0032     
33011 D7D2 D360  30        movb @INWK+20,ra                ; LDA INWK+20
     D7D4 0067     
33012 D7D6 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     D7D8 0033     
33013               
33014 D7DA 0200  20        li   rtmp,NORM                  ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. roofv
     D7DC D1D0     
33015 D7DE 06A0  32        bl   @jsr                       ;
     D7E0 FE28     
33016               
33017 D7E2 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set roofv = (XX15, XX15+1, XX15+2)
     D7E4 0031     
33018 D7E6 D80D  30        movb ra,@INWK+16                ; STA INWK+16
     D7E8 0063     
33019 D7EA D360  30        movb @XX15+1,ra                 ; LDA XX15+1
     D7EC 0032     
33020 D7EE D80D  30        movb ra,@INWK+18                ; STA INWK+18
     D7F0 0065     
33021 D7F2 D360  30        movb @XX15+2,ra                 ; LDA XX15+2
     D7F4 0033     
33022 D7F6 D80D  30        movb ra,@INWK+20                ; STA INWK+20
     D7F8 0067     
33023               
33024 D7FA D360  30        movb @INWK+12,ra                ; LDA INWK+12       ; Set Q = nosev_y
     D7FC 005F     
33025 D7FE D80D  30        movb ra,@Q                      ; STA Q
     D800 0090     
33026               
33027 D802 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     D804 0067     
33028               
33029 D806 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_y * roofv_z
     D808 47FA     
33030 D80A 06A0  32        bl   @jsr                       ;
     D80C FE28     
33031               
33032 D80E D3A0  30        movb @INWK+14,rx                ; LDX INWK+14       ; Set X = nosev_z
     D810 0061     
33033               
33034 D812 D360  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     D814 0065     
33035               
33036 D816 0200  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D818 48F8     
33037 D81A 06A0  32        bl   @jsr                       ;
     D81C FE28     
33038                                                                          ; = (-nosev_z * roofv_y + nosev_y * roofv_z) / 96
33039                                                                          ;
33040                                                                          ; This also sets Q = nosev_z
33041               
33042                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_x = -A
     **** ****     > EOI
0001 D81E 0200  20        li   rtmp,(>80*256)
     D820 8000     
0002 D822 2B40  18        xor  rtmp,ra
                   < elite.a99
33043 D824 D80D  30        movb ra,@INWK+22                ; STA INWK+22       ; = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
     D826 0069     
33044               
33045 D828 D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     D82A 0063     
33046               
33047 D82C 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_z * roofv_x
     D82E 47FA     
33048 D830 06A0  32        bl   @jsr                       ;
     D832 FE28     
33049               
33050 D834 D3A0  30        movb @INWK+10,rx                ; LDX INWK+10       ; Set X = nosev_x
     D836 005D     
33051               
33052 D838 D360  30        movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z
     D83A 0067     
33053               
33054 D83C 0200  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D83E 48F8     
33055 D840 06A0  32        bl   @jsr                       ;
     D842 FE28     
33056                                                                          ; = (-nosev_x * roofv_z + nosev_z * roofv_x) / 96
33057                                                                          ;
33058                                                                          ; This also sets Q = nosev_x
33059               
33060                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_y = -A
     **** ****     > EOI
0001 D844 0200  20        li   rtmp,(>80*256)
     D846 8000     
0002 D848 2B40  18        xor  rtmp,ra
                   < elite.a99
33061 D84A D80D  30        movb ra,@INWK+24                ; STA INWK+24       ; = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
     D84C 006B     
33062               
33063 D84E D360  30        movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y
     D850 0065     
33064               
33065 D852 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A = nosev_x * roofv_y
     D854 47FA     
33066 D856 06A0  32        bl   @jsr                       ;
     D858 FE28     
33067               
33068 D85A D3A0  30        movb @INWK+12,rx                ; LDX INWK+12       ; Set X = nosev_y
     D85C 005F     
33069               
33070 D85E D360  30        movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x
     D860 0063     
33071               
33072 D862 0200  20        li   rtmp,TIS1                  ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
     D864 48F8     
33073 D866 06A0  32        bl   @jsr                       ;
     D868 FE28     
33074                                                                          ; = (-nosev_y * roofv_x + nosev_x * roofv_y) / 96
33075               
33076                      .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_z = -A
     **** ****     > EOI
0001 D86A 0200  20        li   rtmp,(>80*256)
     D86C 8000     
0002 D86E 2B40  18        xor  rtmp,ra
                   < elite.a99
33077 D870 D80D  30        movb ra,@INWK+26                ; STA INWK+26       ; = (nosev_y * roofv_x - nosev_x * roofv_y) / 96
     D872 006D     
33078               
33079 D874 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can clear the low bytes of the
     D876 0000     
33080                                                                          ; orientation vectors
33081               
33082 D878 020E  20        li   rx,>0e*256                 ; LDX #14           ; We want to clear the low bytes, so start from sidev_y
     D87A 0E00     
33083                                                                          ; at byte #9+14 (we clear all except sidev_z_lo, though
33084                                                                          ; I suspect this is in error and that X should be 16)
33085               
33086               TIL1:
33087 D87C 06CE  14        swpb rx                         ;
33088 D87E DB8D  38        movb ra,@INWK+9(rx)             ; STA INWK+9,X      ; Set the low byte in byte #9+X to zero
     D880 005C     
33089 D882 06CE  14        swpb rx                         ;
33090               
33091 D884 7387  18        sb   rone,rx                    ; DEX               ; Set X = X - 2 to jump down to the next low byte
33092 D886 7387  18        sb   rone,rx                    ; DEX
33093               
33094 D888 15F9  14        jgt  TIL1                       ; BPL TIL1          ; Loop back until we have zeroed all the low bytes
33095               
33096 D88A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D88C FE34     
33097               
33098               * ******************************************************************************
33099               *
33100               * Name: TIS2
33101               * Type: Subroutine
33102               * Category: Maths (Arithmetic)
33103               * Summary: Calculate A = A / Q
33104               * Deep dive: Shift-and-subtract division
33105               *
33106               * ------------------------------------------------------------------------------
33107               *
33108               * Calculate the following division, where A is a sign-magnitude number and Q is
33109               * a positive integer:
33110               *
33111               * A = A / Q
33112               *
33113               * The value of A is returned as a sign-magnitude number with 96 representing 1,
33114               * and the maximum value returned is 1 (i.e. 96). This routine is used when
33115               * normalising vectors, where we represent fractions using integers, so this
33116               * gives us an approximation to two decimal places.
33117               *
33118               * ******************************************************************************
33119               
33120               TIS2:
33121 D88E D3CD  18        movb ra,ry                      ; TAY               ; Store the argument A in Y
33122               
33123 D890 024D  22        andi ra,>7f*256                 ; AND #%01111111    ; Strip the sign bit from the argument, so A = |A|
     D892 7F00     
33124               
33125 D894 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q then jump to TI4 to return a 1 with the
     D896 0090     
33126 D898 1827  14        joc  TI4                        ; BCS TI4           ; correct sign
33127               
33128 D89A 020E  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set T to have bits 1-7 set, so we can rotate through 7
     D89C FE00     
33129 D89E D80E  30        movb rx,@T                      ; STX T             ; loop iterations, getting a 1 each time, and then
     D8A0 00D1     
33130                                                                          ; getting a 0 on the 8th iteration... and we can also
33131                                                                          ; use T to catch our result bits into bit 0 each time
33132               
33133               TIL2:
33134                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 D8A2 024D  22        andi ra,>ff00
     D8A4 FF00     
0002 D8A6 0A1D  18        sla  ra,1
                   < elite.a99
33135               
33136 D8A8 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     D8AA 0090     
33137 D8AC 1704  14        jnc  B108                       ; BCC B108
33138               
33139                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 D8AE 1801  14        joc  !
0002 D8B0 7347  18        sb   rone,ra
0003               !:
0004 D8B2 7360  30        sb   @Q,ra
     D8B4 0090     
                   < elite.a99
33140                                                                          ;
33141                                                                          ; Going into this subtraction we know the C flag is
33142                                                                          ; set as we passed through the BCC above, and we also
33143                                                                          ; know that A >= Q, so the C flag will still be set once
33144                                                                          ; we are done
33145               
33146               B108:
33147 D8B6 0204  20        li   rarg1,T                    ; ROL T             ; Rotate the counter in T to the left, and catch the
     D8B8 00D1     
33148 D8BA 06A0  32        bl   @rol                       ;
     D8BC FE4E     
33149                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
33150                                                                          ; do the subtraction, or 1 if we did)
33151               
33152 D8BE 18F1  14        joc  TIL2                       ; BCS TIL2          ; If we still have set bits in T, loop back to TIL2 to
33153                                                                          ; do the next iteration of 7
33154               
33155                                                                          ; We've done the division and now have a result in the
33156                                                                          ; range 0-255 here, which we need to reduce to the range
33157                                                                          ; 0-96. We can do that by multiplying the result by 3/8,
33158                                                                          ; as 256 * 3/8 = 96
33159               
33160 D8C0 D360  30        movb @T,ra                      ; LDA T             ; Set T = T / 4
     D8C2 00D1     
33161 D8C4 091D  18        srl  ra,1                       ; LSR A
33162 D8C6 091D  18        srl  ra,1                       ; LSR A
33163 D8C8 D80D  30        movb ra,@T                      ; STA T
     D8CA 00D1     
33164               
33165 D8CC 091D  18        srl  ra,1                       ; LSR A             ; Set T = T / 8 + T / 4
33166                      .adc @T,ra                      ; ADC T             ; = 3T / 8
     **** ****     > ADC
0001 D8CE 1701  14        jnc  !
0002 D8D0 B347  18        ab   rone,ra
0003               !:
0004 D8D2 B360  30        ab   @T,ra
     D8D4 00D1     
                   < elite.a99
33167 D8D6 D80D  30        movb ra,@T                      ; STA T
     D8D8 00D1     
33168               
33169 D8DA D34F  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
33170 D8DC 024D  22        andi ra,>80*256                 ; AND #%10000000
     D8DE 8000     
33171               
33172 D8E0 F360  30        socb @T,ra                      ; ORA T             ; Apply the sign bit to T
     D8E2 00D1     
33173               
33174 D8E4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D8E6 FE34     
33175               
33176               TI4:
33177 D8E8 D34F  18        movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
33178 D8EA 024D  22        andi ra,>80*256                 ; AND #%10000000
     D8EC 8000     
33179               
33180 D8EE 026D  22        ori  ra,>60*256                 ; ORA #96           ; Apply the sign bit to 96 (which represents 1)
     D8F0 6000     
33181               
33182 D8F2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D8F4 FE34     
33183               
33184               * ******************************************************************************
33185               *
33186               * Name: TIS3
33187               * Type: Subroutine
33188               * Category: Maths (Arithmetic)
33189               * Summary: Calculate -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
33190               *
33191               * ------------------------------------------------------------------------------
33192               *
33193               * Calculate the following expression:
33194               *
33195               * A = -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
33196               *
33197               * where 1, 2 and 3 are x, y, or z, depending on the values of X, Y and A. This
33198               * routine is called with the following values:
33199               *
33200               * X = 0, Y = 2, A = 4 ->
33201               * A = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
33202               *
33203               * X = 0, Y = 4, A = 2 ->
33204               * A = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
33205               *
33206               * X = 2, Y = 4, A = 0 ->
33207               * A = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
33208               *
33209               * ------------------------------------------------------------------------------
33210               *
33211               * Arguments:
33212               *
33213               * X                   Index 1 (0 = x, 2 = y, 4 = z)
33214               *
33215               * Y                   Index 2 (0 = x, 2 = y, 4 = z)
33216               *
33217               * A                   Index 3 (0 = x, 2 = y, 4 = z)
33218               *
33219               * ******************************************************************************
33220               
33221               TIS3:
33222 D8F6 D80D  30        movb ra,@P+2                    ; STA P+2           ; Store P+2 in A for later
     D8F8 001D     
33223               
33224 D8FA 06CE  14        swpb rx                         ;
33225 D8FC D36E  34        movb @INWK+10(rx),ra            ; LDA INWK+10,X     ; Set Q = nosev_x_hi (plus X)
     D8FE 005D     
33226 D900 06CE  14        swpb rx                         ;
33227 D902 D80D  30        movb ra,@Q                      ; STA Q
     D904 0090     
33228               
33229 D906 06CE  14        swpb rx                         ;
33230 D908 D36E  34        movb @INWK+16(rx),ra            ; LDA INWK+16,X     ; Set A = roofv_x_hi (plus X)
     D90A 0063     
33231 D90C 06CE  14        swpb rx                         ;
33232               
33233 D90E 0200  20        li   rtmp,MULT12                ; JSR MULT12        ; Set (S R) = Q * A
     D910 47FA     
33234 D912 06A0  32        bl   @jsr                       ;
     D914 FE28     
33235                                                                          ; = nosev_x_hi * roofv_x_hi
33236               
33237 D916 06CF  14        swpb ry                         ;
33238 D918 D3AF  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y     ; Set Q = nosev_x_hi (plus Y)
     D91A 005D     
33239 D91C 06CF  14        swpb ry                         ;
33240 D91E D80E  30        movb rx,@Q                      ; STX Q
     D920 0090     
33241               
33242 D922 06CF  14        swpb ry                         ;
33243 D924 D36F  34        movb @INWK+16(ry),ra            ; LDA INWK+16,Y     ; Set A = roofv_x_hi (plus Y)
     D926 0063     
33244 D928 06CF  14        swpb ry                         ;
33245               
33246 D92A 0200  20        li   rtmp,MAD                   ; JSR MAD           ; Set (A X) = Q * A + (S R)
     D92C 485A     
33247 D92E 06A0  32        bl   @jsr                       ;
     D930 FE28     
33248                                                                          ; = (nosev_x,X * roofv_x,X) +
33249                                                                          ; (nosev_x,Y * roofv_x,Y)
33250               
33251 D932 D80E  30        movb rx,@P                      ; STX P             ; Store low byte of result in P, so result is now in
     D934 001B     
33252                                                                          ; (A P)
33253               
33254 D936 D3E0  30        movb @P+2,ry                    ; LDY P+2           ; Set Q = roofv_x_hi (plus argument A)
     D938 001D     
33255 D93A 06CF  14        swpb ry                         ;
33256 D93C D3AF  34        movb @INWK+10(ry),rx            ; LDX INWK+10,Y
     D93E 005D     
33257 D940 06CF  14        swpb ry                         ;
33258 D942 D80E  30        movb rx,@Q                      ; STX Q
     D944 0090     
33259               
33260                      .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A
     **** ****     > EOI
0001 D946 0200  20        li   rtmp,(>80*256)
     D948 8000     
0002 D94A 2B40  18        xor  rtmp,ra
                   < elite.a99
33261               
33262                                                                          ; Fall through into DIVDT to do:
33263                                                                          ;
33264                                                                          ; (P+1 A) = (A P) / Q
33265                                                                          ;
33266                                                                          ; = -((nosev_x,X * roofv_x,X) +
33267                                                                          ; (nosev_x,Y * roofv_x,Y))
33268                                                                          ; / nosev_x,A
33269               
33270               * ******************************************************************************
33271               *
33272               * Name: DVIDT
33273               * Type: Subroutine
33274               * Category: Maths (Arithmetic)
33275               * Summary: Calculate (P+1 A) = (A P) / Q
33276               *
33277               * ------------------------------------------------------------------------------
33278               *
33279               * Calculate the following integer division between sign-magnitude numbers:
33280               *
33281               * (P+1 A) = (A P) / Q
33282               *
33283               * This uses the same shift-and-subtract algorithm as TIS2.
33284               *
33285               * ******************************************************************************
33286               
33287               DVIDT:
33288 D94C D80D  30        movb ra,@P+1                    ; STA P+1           ; Set P+1 = A, so P(1 0) = (A P)
     D94E 001C     
33289               
33290                      .eor @Q                         ; EOR Q             ; Set T = the sign bit of A EOR Q, so it's 1 if A and Q
     **** ****     > EOR
0001 D950 D020  30        movb @Q,rtmp
     D952 0090     
0002 D954 2B40  18        xor  rtmp,ra
                   < elite.a99
33291 D956 024D  22        andi ra,>80*256                 ; AND #%10000000    ; have different signs, i.e. it's the sign of the result
     D958 8000     
33292 D95A D80D  30        movb ra,@T                      ; STA T             ; of A / Q
     D95C 00D1     
33293               
33294 D95E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a result
     D960 0000     
33295               
33296 D962 020E  20        li   rx,>10*256                 ; LDX #16           ; Set a counter in X to count the 16 bits in P(1 0)
     D964 1000     
33297               
33298                      .asl @P                         ; ASL P             ; Shift P(1 0) left
     **** ****     > ASL
0001 D966 D020  30        movb @P,rtmp
     D968 001B     
0002 D96A 0240  22        andi rtmp,>ff00
     D96C FF00     
0003 D96E 0A10  18        sla  rtmp,1
0004 D970 D800  30        movb rtmp,@P
     D972 001B     
                   < elite.a99
33299 D974 0204  20        li   rarg1,P+1                  ; ROL P+1
     D976 001C     
33300 D978 06A0  32        bl   @rol                       ;
     D97A FE4E     
33301               
33302                      .asl @Q                         ; ASL Q             ; Clear the sign bit of Q the C flag at the same time
     **** ****     > ASL
0001 D97C D020  30        movb @Q,rtmp
     D97E 0090     
0002 D980 0240  22        andi rtmp,>ff00
     D982 FF00     
0003 D984 0A10  18        sla  rtmp,1
0004 D986 D800  30        movb rtmp,@Q
     D988 0090     
                   < elite.a99
33303                      .lsr @Q                         ; LSR Q
     **** ****     > LSR
0001 D98A D020  30        movb @Q,rtmp
     D98C 0090     
0002 D98E 0910  18        srl  rtmp,1
0003 D990 D800  30        movb rtmp,@Q
     D992 0090     
                   < elite.a99
33304               
33305               DVL2:
33306 D994 06A0  32        bl   @rola                      ; ROL A             ; Shift A to the left
     D996 FE3E     
33307               
33308 D998 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
     D99A 0090     
33309 D99C 1704  14        jnc  B109                       ; BCC B109
33310               
33311                      .sbc @Q,ra                      ; SBC Q             ; Set A = A - Q
     **** ****     > SBC
0001 D99E 1801  14        joc  !
0002 D9A0 7347  18        sb   rone,ra
0003               !:
0004 D9A2 7360  30        sb   @Q,ra
     D9A4 0090     
                   < elite.a99
33312                                                                          ;
33313                                                                          ; Going into this subtraction we know the C flag is
33314                                                                          ; set as we passed through the BCC above, and we also
33315                                                                          ; know that A >= Q, so the C flag will still be set once
33316                                                                          ; we are done
33317               
33318               B109:
33319 D9A6 0204  20        li   rarg1,P                    ; ROL P             ; Rotate P(1 0) to the left, and catch the result bit
     D9A8 001B     
33320 D9AA 06A0  32        bl   @rol                       ;
     D9AC FE4E     
33321 D9AE 0204  20        li   rarg1,P+1                  ; ROL P+1           ; into the C flag (which will be a 0 if we didn't
     D9B0 001C     
33322 D9B2 06A0  32        bl   @rol                       ;
     D9B4 FE4E     
33323                                                                          ; do the subtraction, or 1 if we did)
33324               
33325 D9B6 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
33326               
33327 D9B8 16ED  14        jne  DVL2                       ; BNE DVL2          ; Loop back for the next bit until we have done all 16
33328                                                                          ; bits of P(1 0)
33329               
33330 D9BA D360  30        movb @P,ra                      ; LDA P             ; Set A = P so the low byte is in the result in A
     D9BC 001B     
33331               
33332 D9BE F360  30        socb @T,ra                      ; ORA T             ; Set A to the correct sign bit that we set in T above
     D9C0 00D1     
33333               
33334 D9C2 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     D9C4 FE34     
33335               
33336               * ******************************************************************************
33337               *
33338               * Save ELTF.bin
33339               *
33340               * ******************************************************************************
33341               
33342                      ; PRINT "ELITE F"
33343                      ; PRINT "Assembled at ", ~CODE_F%
33344                      ; PRINT "Ends at ", ~P%
33345                      ; PRINT "Code size is ", ~(P% - CODE_F%)
33346                      ; PRINT "Execute at ", ~LOAD%
33347                      ; PRINT "Reload at ", ~LOAD_F%
33348               
33349                      ; PRINT "S.ELTF ", ~CODE_F%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_F%
33350                      ; SAVE "3-assembled-output/ELTF.bin", CODE_F%, P%, LOAD%
33351               
33352               * ******************************************************************************
33353               *
33354               * ELITE G FILE
33355               *
33356               * Produces the binary file ELTG.bin that gets loaded by elite-bcfs.asm.
33357               *
33358               * ******************************************************************************
33359               
33360               CODE_G.:
33361                      equ $
33362               
33363               LOAD_G.:
33364                      equ LOAD. + $ - CODE.
33365               
33366               * ******************************************************************************
33367               *
33368               * Name: SHPPT
33369               * Type: Subroutine
33370               * Category: Drawing ships
33371               * Summary: Draw a distant ship as a point rather than a full wireframe
33372               *
33373               * ******************************************************************************
33374               
33375               SHPPT:
33376 D9C6 0200  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship's wireframe from the
     D9C8 DDA8     
33377 D9CA 06A0  32        bl   @jsr                       ;
     D9CC FE28     
33378                                                                          ; screen, if there is one
33379               
33380 D9CE 0200  20        li   rtmp,PROJ                  ; JSR PROJ          ; Project the ship onto the screen, returning:
     D9D0 B7EA     
33381 D9D2 06A0  32        bl   @jsr                       ;
     D9D4 FE28     
33382                                                                          ;
33383                                                                          ; * K3(1 0) = the screen x-coordinate
33384                                                                          ; * K4(1 0) = the screen y-coordinate
33385                                                                          ; * A = K4+1
33386               
33387 D9D6 F360  30        socb @K3+1,ra                   ; ORA K3+1          ; If either of the high bytes of the screen coordinates
     D9D8 00D3     
33388 D9DA 1625  14        jne  nono_                      ; BNE nono          ; are non-zero, jump to nono as the ship is off-screen
33389               
33390 D9DC D360  30        movb @K4,ra                     ; LDA K4            ; Set A = the y-coordinate of the dot
     D9DE 00E0     
33391               
33392 D9E0 028D  22        ci   ra,(Y*2-2)*256             ; CMP #Y*2-2        ; If the y-coordinate is bigger than the y-coordinate of
     D9E2 BE00     
33393 D9E4 1820  14        joc  nono_                      ; BCS nono          ; the bottom of the screen, jump to nono as the ship's
33394                                                                          ; dot is off the bottom of the space view
33395               
33396 D9E6 020F  20        li   ry,>02*256                 ; LDY #2            ; Call Shpt with Y = 2 to set up bytes 1-4 in the ship
     D9E8 0200     
33397 D9EA 0200  20        li   rtmp,Shpt                  ; JSR Shpt          ; lines space, aborting the call to LL9 if the dot is
     D9EC DA3A     
33398 D9EE 06A0  32        bl   @jsr                       ;
     D9F0 FE28     
33399                                                                          ; off the side of the screen. This call sets up the
33400                                                                          ; first row of the dot (i.e. a four-pixel dash)
33401               
33402 D9F2 020F  20        li   ry,>06*256                 ; LDY #6            ; Set Y to 6 for the next call to Shpt
     D9F4 0600     
33403               
33404 D9F6 D360  30        movb @K4,ra                     ; LDA K4            ; Set A = y-coordinate of dot + 1 (so this is the second
     D9F8 00E0     
33405                      .adi (>01*256)                  ; ADC #1            ; row of the two-pixel-high dot)
     **** ****     > ADI
0001 D9FA 1701  14        jnc  !
0002 D9FC B347  18        ab   rone,ra
0003               !:
0004 D9FE 022D  22        ai   ra,(>01*256)
     DA00 0100     
                   < elite.a99
33406                                                                          ;
33407                                                                          ; The addition works as the Shpt routine clears the C
33408                                                                          ; flag
33409               
33410 DA02 0200  20        li   rtmp,Shpt                  ; JSR Shpt          ; Call Shpt with Y = 6 to set up bytes 5-8 in the ship
     DA04 DA3A     
33411 DA06 06A0  32        bl   @jsr                       ;
     DA08 FE28     
33412                                                                          ; lines space, aborting the call to LL9 if the dot is
33413                                                                          ; off the side of the screen. This call sets up the
33414                                                                          ; second row of the dot (i.e. another four-pixel dash,
33415                                                                          ; on the row below the first one)
33416               
33417 DA0A 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of the ship's byte #31 to record that we
     DA0C 0800     
33418 DA0E F360  30        socb @XX1+31,ra                 ; ORA XX1+31        ; have now drawn something on-screen for this ship
     DA10 0072     
33419 DA12 D80D  30        movb ra,@XX1+31                 ; STA XX1+31
     DA14 0072     
33420               
33421 DA16 020D  20        li   ra,>08*256                 ; LDA #8            ; Set A = 8 so when we call LL18+2 next, byte #0 of the
     DA18 0800     
33422                                                                          ; heap gets set to 8, for the 8 bytes we just stuck on
33423                                                                          ; the heap
33424               
33425 DA1A 0460  28        b    @LL81+2                    ; JMP LL81+2        ; Call LL81+2 to draw the ship's dot, returning from the
     DA1C EB9C     
33426                                                                          ; subroutine using a tail call
33427               
33428                      .pla                            ; PLA               ; Pull the return address from the stack, so the RTS
     **** ****     > PLA
0001 DA1E 058A  14        inc  rsp
0002 DA20 D35A  26        movb *rsp,ra
                   < elite.a99
33429                      .pla                            ; PLA               ; below actually returns from the subroutine that called
     **** ****     > PLA
0001 DA22 058A  14        inc  rsp
0002 DA24 D35A  26        movb *rsp,ra
                   < elite.a99
33430                                                                          ; LL9 (as we called SHPPT from LL9 with a JMP)
33431               
33432               nono_:
33433 DA26 020D  20        li   ra,>f7*256                 ; LDA #%11110111    ; Clear bit 3 of the ship's byte #31 to record that
     DA28 F700     
33434                      .and @XX1+31                    ; AND XX1+31        ; nothing is being drawn on-screen for this ship
     **** ****     > AND
0001 DA2A D020  30        movb @XX1+31,rtmp
     DA2C 0072     
0002 DA2E 0540  14        inv  rtmp
0003 DA30 5340  18        szcb rtmp,ra
                   < elite.a99
33435 DA32 D80D  30        movb ra,@XX1+31                 ; STA XX1+31
     DA34 0072     
33436               
33437 DA36 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DA38 FE34     
33438               
33439               Shpt:
33440                                                                          ; This routine sets up four bytes in the ship line heap,
33441                                                                          ; from byte Y-1 to byte Y+2. If the ship's screen point
33442                                                                          ; turns out to be off-screen, then this routine aborts
33443                                                                          ; the entire call to LL9, exiting via nono. The four
33444                                                                          ; bytes define a horizontal 4-pixel dash, for either the
33445                                                                          ; top or the bottom of the ship's dot
33446                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in byte Y of the ship line heap (i.e. Y1)
     **** ****     > ST_IND_Y_IDX
0001 DA3A D820  42        movb @XX19,@rtmplb
     DA3C 0074     
     DA3E 8301     
0002 DA40 D020  30        movb @XX19+1,rtmp
     DA42 0075     
0003 DA44 06CF  14        swpb ry
0004 DA46 A00F  18        a    ry,rtmp
0005 DA48 06CF  14        swpb ry
0006 DA4A D40D  30        movb RA,*rtmp
                   < elite.a99
33447               
33448 DA4C B3C7  18        ab   rone,ry                    ; INY               ; Store A in byte Y+2 of the ship line heap (i.e. Y2)
33449 DA4E B3C7  18        ab   rone,ry                    ; INY
33450                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 DA50 D820  42        movb @XX19,@rtmplb
     DA52 0074     
     DA54 8301     
0002 DA56 D020  30        movb @XX19+1,rtmp
     DA58 0075     
0003 DA5A 06CF  14        swpb ry
0004 DA5C A00F  18        a    ry,rtmp
0005 DA5E 06CF  14        swpb ry
0006 DA60 D40D  30        movb RA,*rtmp
                   < elite.a99
33451               
33452 DA62 D360  30        movb @K3,ra                     ; LDA K3            ; Set A = screen x-coordinate of the ship dot
     DA64 00D2     
33453               
33454 DA66 73C7  18        sb   rone,ry                    ; DEY               ; Store A in byte Y+1 of the ship line heap (i.e. X2)
33455                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 DA68 D820  42        movb @XX19,@rtmplb
     DA6A 0074     
     DA6C 8301     
0002 DA6E D020  30        movb @XX19+1,rtmp
     DA70 0075     
0003 DA72 06CF  14        swpb ry
0004 DA74 A00F  18        a    ry,rtmp
0005 DA76 06CF  14        swpb ry
0006 DA78 D40D  30        movb RA,*rtmp
                   < elite.a99
33456               
33457                      .adi (>03*256)                  ; ADC #3            ; Set A = screen x-coordinate of the ship dot + 3
     **** ****     > ADI
0001 DA7A 1701  14        jnc  !
0002 DA7C B347  18        ab   rone,ra
0003               !:
0004 DA7E 022D  22        ai   ra,(>03*256)
     DA80 0300     
                   < elite.a99
33458               
33459 DA82 18D0  14        joc  nono_-2                    ; BCS nono-2        ; If the addition pushed the dot off the right side of
33460                                                                          ; the screen, jump to nono-2 to return from the parent
33461                                                                          ; subroutine early (i.e. LL9). This works because we
33462                                                                          ; called Shpt from above with a JSR, so nono-2 removes
33463                                                                          ; that return address from the stack, leaving the next
33464                                                                          ; return address exposed. LL9 called SHPPT with a JMP,
33465                                                                          ; so the next return address is the one that was put on
33466                                                                          ; the stack by the original call to LL9. So the RTS in
33467                                                                          ; nono will actually return us from the original call
33468                                                                          ; to LL9, thus aborting the entire drawing process
33469               
33470 DA84 73C7  18        sb   rone,ry                    ; DEY               ; Store A in byte Y-1 of the ship line heap (i.e. X1)
33471 DA86 73C7  18        sb   rone,ry                    ; DEY
33472                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 DA88 D820  42        movb @XX19,@rtmplb
     DA8A 0074     
     DA8C 8301     
0002 DA8E D020  30        movb @XX19+1,rtmp
     DA90 0075     
0003 DA92 06CF  14        swpb ry
0004 DA94 A00F  18        a    ry,rtmp
0005 DA96 06CF  14        swpb ry
0006 DA98 D40D  30        movb RA,*rtmp
                   < elite.a99
33473               
33474 DA9A 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DA9C FE34     
33475               
33476               * ******************************************************************************
33477               *
33478               * Name: LL5
33479               * Type: Subroutine
33480               * Category: Maths (Arithmetic)
33481               * Summary: Calculate Q = SQRT(R Q)
33482               * Deep dive: Calculating square roots
33483               *
33484               * ------------------------------------------------------------------------------
33485               *
33486               * Calculate the following square root:
33487               *
33488               * Q = SQRT(R Q)
33489               *
33490               * ******************************************************************************
33491               
33492               LL5:
33493 DA9E D3E0  30        movb @R,ry                      ; LDY R             ; Set (Y S) = (R Q)
     DAA0 0091     
33494 DAA2 D360  30        movb @Q,ra                      ; LDA Q
     DAA4 0090     
33495 DAA6 D80D  30        movb ra,@S                      ; STA S
     DAA8 0092     
33496               
33497                                                                          ; So now to calculate Q = SQRT(Y S)
33498               
33499 DAAA 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, to hold the remainder
     DAAC 0000     
33500               
33501 DAAE D80E  30        movb rx,@Q                      ; STX Q             ; Set Q = 0, to hold the result
     DAB0 0090     
33502               
33503 DAB2 020D  20        li   ra,>08*256                 ; LDA #8            ; Set T = 8, to use as a loop counter
     DAB4 0800     
33504 DAB6 D80D  30        movb ra,@T                      ; STA T
     DAB8 00D1     
33505               
33506               LL6:
33507 DABA 93A0  30        cb   @Q,rx                      ; CPX Q             ; If X < Q, jump to LL7
     DABC 0090     
33508 DABE 1710  14        jnc  LL7                        ; BCC LL7
33509               
33510 DAC0 1603  14        jne  LL8                        ; BNE LL8           ; If X > Q, jump to LL8
33511               
33512 DAC2 028F  22        ci   ry,>40*256                 ; CPY #64           ; If Y < 64, jump to LL7 with the C flag clear,
     DAC4 4000     
33513 DAC6 170C  14        jnc  LL7                        ; BCC LL7           ; otherwise fall through into LL8 with the C flag set
33514               
33515               LL8:
33516 DAC8 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y - 64
33517                      .sbi (>40*256)                  ; SBC #64           ;
     **** ****     > SBI
0001 DACA 1801  14        joc  !
0002 DACC 7347  18        sb   rone,ra
0003               !:
0004 DACE 022D  22        ai   ra,-(>40*256)
     DAD0 C000     
                   < elite.a99
33518 DAD2 D3CD  18        movb ra,ry                      ; TAY               ; This subtraction will work as we know C is set from
33519                                                                          ; the BCC above, and the result will not underflow as we
33520                                                                          ; already checked that Y >= 64, so the C flag is also
33521                                                                          ; set for the next subtraction
33522               
33523 DAD4 D34E  18        movb rx,ra                      ; TXA               ; Set X = X - Q
33524                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 DAD6 1801  14        joc  !
0002 DAD8 7347  18        sb   rone,ra
0003               !:
0004 DADA 7360  30        sb   @Q,ra
     DADC 0090     
                   < elite.a99
33525 DADE D38D  18        movb ra,rx                      ; TAX
33526               
33527               LL7:
33528 DAE0 0204  20        li   rarg1,Q                    ; ROL Q             ; Shift the result in Q to the left, shifting the C flag
     DAE2 0090     
33529 DAE4 06A0  32        bl   @rol                       ;
     DAE6 FE4E     
33530                                                                          ; into bit 0 and bit 7 into the C flag
33531               
33532                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left, inserting
     **** ****     > ASL
0001 DAE8 D020  30        movb @S,rtmp
     DAEA 0092     
0002 DAEC 0240  22        andi rtmp,>ff00
     DAEE FF00     
0003 DAF0 0A10  18        sla  rtmp,1
0004 DAF2 D800  30        movb rtmp,@S
     DAF4 0092     
                   < elite.a99
33533 DAF6 D34F  18        movb ry,ra                      ; TYA               ; bit 7 from above into bit 0
33534 DAF8 06A0  32        bl   @rola                      ; ROL A
     DAFA FE3E     
33535 DAFC D3CD  18        movb ra,ry                      ; TAY
33536               
33537 DAFE D34E  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
33538 DB00 06A0  32        bl   @rola                      ; ROL A
     DB02 FE3E     
33539 DB04 D38D  18        movb ra,rx                      ; TAX
33540               
33541                      .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left
     **** ****     > ASL
0001 DB06 D020  30        movb @S,rtmp
     DB08 0092     
0002 DB0A 0240  22        andi rtmp,>ff00
     DB0C FF00     
0003 DB0E 0A10  18        sla  rtmp,1
0004 DB10 D800  30        movb rtmp,@S
     DB12 0092     
                   < elite.a99
33542 DB14 D34F  18        movb ry,ra                      ; TYA
33543 DB16 06A0  32        bl   @rola                      ; ROL A
     DB18 FE3E     
33544 DB1A D3CD  18        movb ra,ry                      ; TAY
33545               
33546 DB1C D34E  18        movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
33547 DB1E 06A0  32        bl   @rola                      ; ROL A
     DB20 FE3E     
33548 DB22 D38D  18        movb ra,rx                      ; TAX
33549               
33550 DB24 7347  18        sb   rone,ra                    ; DEC T             ; Decrement the loop counter
33551               
33552 DB26 16C9  14        jne  LL6                        ; BNE LL6           ; Loop back to LL6 until we have done 8 loops
33553               
33554 DB28 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DB2A FE34     
33555               
33556               * ******************************************************************************
33557               *
33558               * Name: LL28
33559               * Type: Subroutine
33560               * Category: Maths (Arithmetic)
33561               * Summary: Calculate R = 256 * A / Q
33562               * Deep dive: Shift-and-subtract division
33563               *
33564               * ------------------------------------------------------------------------------
33565               *
33566               * Calculate the following, where A < Q:
33567               *
33568               * R = 256 * A / Q
33569               *
33570               * This is a sister routine to LL61, which does the division when A >= Q.
33571               *
33572               * If A >= Q then 255 is returned and the C flag is set to indicate an overflow
33573               * (the C flag is clear if the division was a success).
33574               *
33575               * The result is returned in one byte as the result of the division multiplied
33576               * by 256, so we can return fractional results using integers.
33577               *
33578               * This routine uses the same shift-and-subtract algorithm that's documented in
33579               * TIS2, but it leaves the fractional result in the integer range 0-255.
33580               *
33581               * ------------------------------------------------------------------------------
33582               *
33583               * Returns:
33584               *
33585               * C flag              Set if the answer is too big for one byte, clear if the
33586               * division was a success
33587               *
33588               * ------------------------------------------------------------------------------
33589               *
33590               * Other entry points:
33591               *
33592               * LL28+4              Skips the A >= Q check and always returns with C flag
33593               * cleared, so this can be called if we know the division
33594               * will work
33595               *
33596               * LL31                Skips the A >= Q check and does not set the R counter,
33597               * so this can be used for jumping straight into the
33598               * division loop if R is already set to 254 and we know the
33599               * division will work
33600               *
33601               * ******************************************************************************
33602               
33603               LL28:
33604 DB2C 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, then the answer will not fit in one byte,
     DB2E 0090     
33605 DB30 1822  14        joc  LL2                        ; BCS LL2           ; so jump to LL2 to return 255
33606               
33607 DB32 020E  20        li   rx,>fe*256                 ; LDX #%11111110    ; Set R to have bits 1-7 set, so we can rotate through 7
     DB34 FE00     
33608 DB36 D80E  30        movb rx,@R                      ; STX R             ; loop iterations, getting a 1 each time, and then
     DB38 0091     
33609                                                                          ; getting a 0 on the 8th iteration... and we can also
33610                                                                          ; use R to catch our result bits into bit 0 each time
33611               
33612               LL31:
33613                      .asla                           ; ASL A             ; Shift A to the left
     **** ****     > ASLA
0001 DB3A 024D  22        andi ra,>ff00
     DB3C FF00     
0002 DB3E 0A1D  18        sla  ra,1
                   < elite.a99
33614               
33615 DB40 180E  14        joc  LL29                       ; BCS LL29          ; If bit 7 of A was set, then jump straight to the
33616                                                                          ; subtraction
33617               
33618 DB42 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
     DB44 0090     
33619 DB46 1704  14        jnc  B110                       ; BCC B110
33620               
33621                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 DB48 1801  14        joc  !
0002 DB4A 7347  18        sb   rone,ra
0003               !:
0004 DB4C 7360  30        sb   @Q,ra
     DB4E 0090     
                   < elite.a99
33622               
33623               B110:
33624 DB50 0204  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     DB52 0091     
33625 DB54 06A0  32        bl   @rol                       ;
     DB56 FE4E     
33626                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
33627                                                                          ; do the subtraction, or 1 if we did)
33628               
33629 DB58 18F0  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
33630                                                                          ; do the next iteration of 7
33631               
33632 DB5A 0460  28        b    @rts                       ; RTS               ; R left with remainder of division
     DB5C FE34     
33633               
33634               LL29:
33635                      .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
     **** ****     > SBC
0001 DB5E 1801  14        joc  !
0002 DB60 7347  18        sb   rone,ra
0003               !:
0004 DB62 7360  30        sb   @Q,ra
     DB64 0090     
                   < elite.a99
33636               
33637                      .sec                            ; SEC               ; Set the C flag to rotate into the result in R
     **** ****     > SEC
0001 DB66 0A18  18        sla  rmone,1
                   < elite.a99
33638               
33639 DB68 0204  20        li   rarg1,R                    ; ROL R             ; Rotate the counter in R to the left, and catch the
     DB6A 0091     
33640 DB6C 06A0  32        bl   @rol                       ;
     DB6E FE4E     
33641                                                                          ; result bit into bit 0 (which will be a 0 if we didn't
33642                                                                          ; do the subtraction, or 1 if we did)
33643               
33644 DB70 18E4  14        joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
33645                                                                          ; do the next iteration of 7
33646               
33647 DB72 0460  28        b    @rts                       ; RTS               ; Return from the subroutine with R containing the
     DB74 FE34     
33648                                                                          ; remainder of the division
33649               
33650               LL2:
33651 DB76 020D  20        li   ra,>ff*256                 ; LDA #255          ; The division is very close to 1, so return the closest
     DB78 FF00     
33652 DB7A D80D  30        movb ra,@R                      ; STA R             ; possible answer to 256, i.e. R = 255
     DB7C 0091     
33653               
33654 DB7E 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DB80 FE34     
33655               
33656               * ******************************************************************************
33657               *
33658               * Name: LL38
33659               * Type: Subroutine
33660               * Category: Maths (Arithmetic)
33661               * Summary: Calculate (S A) = (S R) + (A Q)
33662               *
33663               * ------------------------------------------------------------------------------
33664               *
33665               * Calculate the following between sign-magnitude numbers:
33666               *
33667               * (S A) = (S R) + (A Q)
33668               *
33669               * where the sign bytes only contain the sign bits, not magnitudes.
33670               *
33671               * ------------------------------------------------------------------------------
33672               *
33673               * Returns:
33674               *
33675               * C flag              Set if the addition overflowed, clear otherwise
33676               *
33677               * ******************************************************************************
33678               
33679               LL38:
33680                      .eor @S                         ; EOR S             ; If the sign of A * S is negative, skip to LL35, as
     **** ****     > EOR
0001 DB82 D020  30        movb @S,rtmp
     DB84 0092     
0002 DB86 2B40  18        xor  rtmp,ra
                   < elite.a99
33681 DB88 1109  14        jlt  LL39                       ; BMI LL39          ; A and S have different signs so we need to subtract
33682               
33683 DB8A D360  30        movb @Q,ra                      ; LDA Q             ; Otherwise set A = R + Q, which is the result we need,
     DB8C 0090     
33684                      .clc                            ; CLC               ; as S already contains the correct sign
     **** ****     > CLC
0001 DB8E 0A16  18        sla  rzero,1
                   < elite.a99
33685                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 DB90 1701  14        jnc  !
0002 DB92 B347  18        ab   rone,ra
0003               !:
0004 DB94 B360  30        ab   @R,ra
     DB96 0091     
                   < elite.a99
33686               
33687 DB98 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DB9A FE34     
33688               
33689               LL39:
33690 DB9C D360  30        movb @R,ra                      ; LDA R             ; Set A = R - Q
     DB9E 0091     
33691                      .sec                            ; SEC
     **** ****     > SEC
0001 DBA0 0A18  18        sla  rmone,1
                   < elite.a99
33692                      .sbc @Q,ra                      ; SBC Q
     **** ****     > SBC
0001 DBA2 1801  14        joc  !
0002 DBA4 7347  18        sb   rone,ra
0003               !:
0004 DBA6 7360  30        sb   @Q,ra
     DBA8 0090     
                   < elite.a99
33693               
33694 DBAA 1701  14        jnc  B111                       ; BCC B111          ; If the subtraction underflowed, skip the next two
33695                                                                          ; instructions so we can negate the result
33696               
33697                      .clc                            ; CLC               ; Otherwise the result is correct, and S contains the
     **** ****     > CLC
0001 DBAC 0A16  18        sla  rzero,1
                   < elite.a99
33698                                                                          ; correct sign of the result as R is the dominant side
33699                                                                          ; of the subtraction, so clear the C flag
33700               
33701               B111:
33702 DBAE 0460  28        b    @rts                       ; RTS               ; And return from the subroutine
     DBB0 FE34     
33703               
33704                                                                          ; If we get here we need to negate both the result and
33705                                                                          ; the sign in S, as both are the wrong sign
33706               
33707                      .pha                            ; PHA               ; Store the result of the subtraction on the stack
     **** ****     > PHA
0001 DBB2 D68D  30        movb ra,*rsp
0002 DBB4 060A  14        dec  rsp
                   < elite.a99
33708               
33709 DBB6 D360  30        movb @S,ra                      ; LDA S             ; Flip the sign of S
     DBB8 0092     
33710                      .eoi (>80*256)                  ; EOR #%10000000
     **** ****     > EOI
0001 DBBA 0200  20        li   rtmp,(>80*256)
     DBBC 8000     
0002 DBBE 2B40  18        xor  rtmp,ra
                   < elite.a99
33711 DBC0 D80D  30        movb ra,@S                      ; STA S
     DBC2 0092     
33712               
33713                      .pla                            ; PLA               ; Restore the subtraction result into A
     **** ****     > PLA
0001 DBC4 058A  14        inc  rsp
0002 DBC6 D35A  26        movb *rsp,ra
                   < elite.a99
33714               
33715                      .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A using two's complement, i.e.
     **** ****     > EOI
0001 DBC8 0200  20        li   rtmp,(>FF*256)
     DBCA FF00     
0002 DBCC 2B40  18        xor  rtmp,ra
                   < elite.a99
33716                      .adi (>01*256)                  ; ADC #1            ; set A = ~A + 1
     **** ****     > ADI
0001 DBCE 1701  14        jnc  !
0002 DBD0 B347  18        ab   rone,ra
0003               !:
0004 DBD2 022D  22        ai   ra,(>01*256)
     DBD4 0100     
                   < elite.a99
33717               
33718 DBD6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DBD8 FE34     
33719               
33720               * ******************************************************************************
33721               *
33722               * Name: LL51
33723               * Type: Subroutine
33724               * Category: Maths (Geometry)
33725               * Summary: Calculate the dot product of XX15 and XX16
33726               *
33727               * ------------------------------------------------------------------------------
33728               *
33729               * Calculate the following dot products:
33730               *
33731               * XX12(1 0) = XX15(5 0) . XX16(5 0)
33732               * XX12(3 2) = XX15(5 0) . XX16(11 6)
33733               * XX12(5 4) = XX15(5 0) . XX16(12 17)
33734               *
33735               * storing the results as sign-magnitude numbers in XX12 through XX12+5.
33736               *
33737               * When called from part 5 of LL9, XX12 contains the vector [x y z] to the ship
33738               * we're drawing, and XX16 contains the orientation vectors, so it returns:
33739               *
33740               * [ x ]   [ sidev_x ]         [ x ]   [ roofv_x ]         [ x ]   [ nosev_x ]
33741               * [ y ] . [ sidev_y ]         [ y ] . [ roofv_y ]         [ y ] . [ nosev_y ]
33742               * [ z ]   [ sidev_z ]         [ z ]   [ roofv_z ]         [ z ]   [ nosev_z ]
33743               *
33744               * When called from part 6 of LL9, XX12 contains the vector [x y z] of the vertex
33745               * we're analysing, and XX16 contains the transposed orientation vectors with
33746               * each of them containing the x, y and z elements of the original vectors, so it
33747               * ------------------------------------------------------------------------------
33748               *
33749               * Returns:
33750               *
33751               * [ x ]   [ sidev_x ]         [ x ]   [ sidev_y ]         [ x ]   [ sidev_z ]
33752               * [ y ] . [ roofv_x ]         [ y ] . [ roofv_y ]         [ y ] . [ roofv_z ]
33753               * [ z ]   [ nosev_x ]         [ z ]   [ nosev_y ]         [ z ]   [ nosev_z ]
33754               *
33755               * ------------------------------------------------------------------------------
33756               *
33757               * Arguments:
33758               *
33759               * XX15(1 0)           The ship (or vertex)'s x-coordinate as (x_sign x_lo)
33760               *
33761               * XX15(3 2)           The ship (or vertex)'s y-coordinate as (y_sign y_lo)
33762               *
33763               * XX15(5 4)           The ship (or vertex)'s z-coordinate as (z_sign z_lo)
33764               *
33765               * XX16 to XX16+5      The scaled sidev (or _x) vector, with:
33766               *
33767               * * x, y, z magnitudes in XX16, XX16+2, XX16+4
33768               *
33769               * * x, y, z signs in XX16+1, XX16+3, XX16+5
33770               *
33771               * XX16+6 to XX16+11   The scaled roofv (or _y) vector, with:
33772               *
33773               * * x, y, z magnitudes in XX16+6, XX16+8, XX16+10
33774               *
33775               * * x, y, z signs in XX16+7, XX16+9, XX16+11
33776               *
33777               * XX16+12 to XX16+17  The scaled nosev (or _z) vector, with:
33778               *
33779               * * x, y, z magnitudes in XX16+12, XX16+14, XX16+16
33780               *
33781               * * x, y, z signs in XX16+13, XX16+15, XX16+17
33782               *
33783               * ------------------------------------------------------------------------------
33784               *
33785               * Returns:
33786               *
33787               * XX12(1 0)           The dot product of [x y z] vector with the sidev (or _x)
33788               * vector, with the sign in XX12+1 and magnitude in XX12
33789               *
33790               * XX12(3 2)           The dot product of [x y z] vector with the roofv (or _y)
33791               * vector, with the sign in XX12+3 and magnitude in XX12+2
33792               *
33793               * XX12(5 4)           The dot product of [x y z] vector with the nosev (or _z)
33794               * vector, with the sign in XX12+5 and magnitude in XX12+4
33795               *
33796               * ******************************************************************************
33797               
33798               LL51:
33799 DBDA 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0, which will contain the offset of the vector
     DBDC 0000     
33800                                                                          ; to use in the calculation, increasing by 6 for each
33801                                                                          ; new vector
33802               
33803 DBDE 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y = 0, which will contain the offset of the
     DBE0 0000     
33804                                                                          ; result bytes in XX12, increasing by 2 for each new
33805                                                                          ; result
33806               
33807               ll51_:
33808 DBE2 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set Q = x_lo
     DBE4 0031     
33809 DBE6 D80D  30        movb ra,@Q                      ; STA Q
     DBE8 0090     
33810               
33811 DBEA 06CE  14        swpb rx                         ;
33812 DBEC D36E  34        movb @XX16(rx),ra               ; LDA XX16,X        ; Set A = |sidev_x|
     DBEE 0009     
33813 DBF0 06CE  14        swpb rx                         ;
33814               
33815 DBF2 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     DBF4 46D4     
33816 DBF6 06A0  32        bl   @jsr                       ;
     DBF8 FE28     
33817 DBFA D80D  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo / 256
     DBFC 00D1     
33818               
33819 DBFE D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Set S to the sign of x_sign * sidev_x
     DC00 0032     
33820 DC02 06CE  14        swpb rx                         ;
33821                      .eor @XX16+1(rx)                ; EOR XX16+1,X
     **** ****     > EOR
0001 DC04 D02E  34        movb @XX16+1(RX),rtmp
     DC06 000A     
0002 DC08 2B40  18        xor  rtmp,ra
                   < elite.a99
33822 DC0A 06CE  14        swpb rx                         ;
33823 DC0C D80D  30        movb ra,@S                      ; STA S
     DC0E 0092     
33824               
33825 DC10 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Q = y_lo
     DC12 0033     
33826 DC14 D80D  30        movb ra,@Q                      ; STA Q
     DC16 0090     
33827               
33828 DC18 06CE  14        swpb rx                         ;
33829 DC1A D36E  34        movb @XX16+2(rx),ra             ; LDA XX16+2,X      ; Set A = |sidev_y|
     DC1C 000B     
33830 DC1E 06CE  14        swpb rx                         ;
33831               
33832 DC20 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     DC22 46D4     
33833 DC24 06A0  32        bl   @jsr                       ;
     DC26 FE28     
33834 DC28 D80D  30        movb ra,@Q                      ; STA Q             ; = |sidev_y| * y_lo / 256
     DC2A 0090     
33835               
33836 DC2C D360  30        movb @T,ra                      ; LDA T             ; Set R = T
     DC2E 00D1     
33837 DC30 D80D  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo / 256
     DC32 0091     
33838               
33839 DC34 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A to the sign of y_sign * sidev_y
     DC36 0034     
33840 DC38 06CE  14        swpb rx                         ;
33841                      .eor @XX16+3(rx)                ; EOR XX16+3,X
     **** ****     > EOR
0001 DC3A D02E  34        movb @XX16+3(RX),rtmp
     DC3C 000C     
0002 DC3E 2B40  18        xor  rtmp,ra
                   < elite.a99
33842 DC40 06CE  14        swpb rx                         ;
33843               
33844 DC42 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     DC44 DB82     
33845 DC46 06A0  32        bl   @jsr                       ;
     DC48 FE28     
33846 DC4A D80D  30        movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     DC4C 00D1     
33847               
33848 DC4E D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set Q = z_lo
     DC50 0035     
33849 DC52 D80D  30        movb ra,@Q                      ; STA Q
     DC54 0090     
33850               
33851 DC56 06CE  14        swpb rx                         ;
33852 DC58 D36E  34        movb @XX16+4(rx),ra             ; LDA XX16+4,X      ; Set A = |sidev_z|
     DC5A 000D     
33853 DC5C 06CE  14        swpb rx                         ;
33854               
33855 DC5E 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q / 256
     DC60 46D4     
33856 DC62 06A0  32        bl   @jsr                       ;
     DC64 FE28     
33857 DC66 D80D  30        movb ra,@Q                      ; STA Q             ; = |sidev_z| * z_lo / 256
     DC68 0090     
33858               
33859 DC6A D360  30        movb @T,ra                      ; LDA T             ; Set R = T
     DC6C 00D1     
33860 DC6E D80D  30        movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo + |sidev_y| * y_lo
     DC70 0091     
33861               
33862 DC72 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A to the sign of z_sign * sidev_z
     DC74 0036     
33863 DC76 06CE  14        swpb rx                         ;
33864                      .eor @XX16+5(rx)                ; EOR XX16+5,X
     **** ****     > EOR
0001 DC78 D02E  34        movb @XX16+5(RX),rtmp
     DC7A 000E     
0002 DC7C 2B40  18        xor  rtmp,ra
                   < elite.a99
33865 DC7E 06CE  14        swpb rx                         ;
33866               
33867 DC80 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     DC82 DB82     
33868 DC84 06A0  32        bl   @jsr                       ;
     DC86 FE28     
33869                                                                          ; = |sidev_x| * x_lo + |sidev_y| * y_lo
33870                                                                          ; + |sidev_z| * z_lo
33871               
33872 DC88 06CF  14        swpb ry                         ;
33873 DC8A DBCD  38        movb ra,@XX12(ry)               ; STA XX12,Y        ; Store the result in XX12+Y(1 0)
     DC8C 0037     
33874 DC8E 06CF  14        swpb ry                         ;
33875 DC90 D360  30        movb @S,ra                      ; LDA S
     DC92 0092     
33876 DC94 06CF  14        swpb ry                         ;
33877 DC96 DBCD  38        movb ra,@XX12+1(ry)             ; STA XX12+1,Y
     DC98 0038     
33878 DC9A 06CF  14        swpb ry                         ;
33879               
33880 DC9C B3C7  18        ab   rone,ry                    ; INY               ; Set Y = Y + 2
33881 DC9E B3C7  18        ab   rone,ry                    ; INY
33882               
33883 DCA0 D34E  18        movb rx,ra                      ; TXA               ; Set X = X + 6
33884                      .clc                            ; CLC
     **** ****     > CLC
0001 DCA2 0A16  18        sla  rzero,1
                   < elite.a99
33885                      .adi (>06*256)                  ; ADC #6
     **** ****     > ADI
0001 DCA4 1701  14        jnc  !
0002 DCA6 B347  18        ab   rone,ra
0003               !:
0004 DCA8 022D  22        ai   ra,(>06*256)
     DCAA 0600     
                   < elite.a99
33886 DCAC D38D  18        movb ra,rx                      ; TAX
33887               
33888 DCAE 028D  22        ci   ra,>11*256                 ; CMP #17           ; If X < 17, loop back to ll51 for the next vector
     DCB0 1100     
33889 DCB2 1797  14        jnc  ll51_                      ; BCC ll51
33890               
33891 DCB4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DCB6 FE34     
33892               
33893               * ******************************************************************************
33894               *
33895               * Name: LL9 (Part 1 of 12)
33896               * Type: Subroutine
33897               * Category: Drawing ships
33898               * Summary: Draw ship: Check if ship is exploding, check if ship is in front
33899               * Deep dive: Drawing ships
33900               *
33901               * ------------------------------------------------------------------------------
33902               *
33903               * This routine draws the current ship on the screen. This part checks to see if
33904               * the ship is exploding, or if it should start exploding, and if it does it sets
33905               * things up accordingly.
33906               *
33907               * It also does some basic checks to see if we can see the ship, and if not it
33908               * removes it from the screen.
33909               *
33910               * In this code, XX1 is used to point to the current ship's data block at INWK
33911               * (the two labels are interchangeable).
33912               *
33913               * ------------------------------------------------------------------------------
33914               *
33915               * Arguments:
33916               *
33917               * XX1                 XX1 shares its location with INWK, which contains the
33918               * zero-page copy of the data block for this ship from the
33919               * K% workspace
33920               *
33921               * INF                 The address of the data block for this ship in workspace
33922               * K%
33923               *
33924               * XX19(1 0)           XX19(1 0) shares its location with INWK(34 33), which
33925               * contains the ship line heap address pointer
33926               *
33927               * XX0                 The address of the blueprint for this ship
33928               *
33929               * ------------------------------------------------------------------------------
33930               *
33931               * Other entry points:
33932               *
33933               * EE51                Remove the current ship from the screen, called from
33934               * SHPPT before drawing the ship as a point
33935               *
33936               * ******************************************************************************
33937               
33938               LL25:
33939 DCB8 0460  28        b    @PLANET                    ; JMP PLANET        ; Jump to the PLANET routine, returning from the
     DCBA B87E     
33940                                                                          ; subroutine using a tail call
33941               
33942               LL9:
33943 DCBC D360  30        movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
     DCBE 009B     
33944 DCC0 11FB  14        jlt  LL25                       ; BMI LL25          ; planet or sun, so jump to PLANET via LL25 above
33945               
33946 DCC2 020D  20        li   ra,>1f*256                 ; LDA #31           ; Set XX4 = 31 to store the ship's distance for later
     DCC4 1F00     
33947 DCC6 D80D  30        movb ra,@XX4                    ; STA XX4           ; comparison with the visibility distance. We will
     DCC8 00A7     
33948                                                                          ; update this value below with the actual ship's
33949                                                                          ; distance if it turns out to be visible on-screen
33950               
33951 DCCA 020D  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the ship
     DCCC 2000     
33952                      .bit @XX1+31                    ; BIT XX1+31        ; is currently exploding, so jump down to EE28
     **** ****     > BIT
0001 DCCE D020  30        movb @XX1+31,rtmp
     DCD0 0072     
0002 DCD2 0540  14        inv  rtmp
0003 DCD4 D047  18        movb rone,rtmp2
0004 DCD6 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
33953 DCD8 1657  14        jne  EE28                       ; BNE EE28
33954               
33955 DCDA 1556  14        jgt  EE28                       ; BPL EE28          ; If bit 7 of the ship's byte #31 is clear then the ship
33956                                                                          ; has not just been killed, so jump down to EE28
33957               
33958                                                                          ; Otherwise bit 5 is clear and bit 7 is set, so the ship
33959                                                                          ; is not yet exploding but it has been killed, so we
33960                                                                          ; need to start an explosion
33961               
33962 DCDC F360  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Clear bits 6 and 7 of the ship's byte #31, to stop the
     DCDE 0072     
33963 DCE0 024D  22        andi ra,>3f*256                 ; AND #%00111111    ; ship from firing its laser and to mark it as no longer
     DCE2 3F00     
33964 DCE4 D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; having just been killed
     DCE6 0072     
33965               
33966 DCE8 020D  20        li   ra,>00*256                 ; LDA #0            ; Set the ship's acceleration in byte #31 to 0, updating
     DCEA 0000     
33967 DCEC 020F  20        li   ry,>1c*256                 ; LDY #28           ; the byte in the workspace K% data block so we don't
     DCEE 1C00     
33968                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; have to copy it back from INWK later
     **** ****     > ST_IND_Y_IDX
0001 DCF0 D820  42        movb @INF,@rtmplb
     DCF2 0020     
     DCF4 8301     
0002 DCF6 D020  30        movb @INF+1,rtmp
     DCF8 0021     
0003 DCFA 06CF  14        swpb ry
0004 DCFC A00F  18        a    ry,rtmp
0005 DCFE 06CF  14        swpb ry
0006 DD00 D40D  30        movb RA,*rtmp
                   < elite.a99
33969               
33970 DD02 020F  20        li   ry,>1e*256                 ; LDY #30           ; Set the ship's pitch counter in byte #30 to 0, to stop
     DD04 1E00     
33971                      .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the ship from pitching
     **** ****     > ST_IND_Y_IDX
0001 DD06 D820  42        movb @INF,@rtmplb
     DD08 0020     
     DD0A 8301     
0002 DD0C D020  30        movb @INF+1,rtmp
     DD0E 0021     
0003 DD10 06CF  14        swpb ry
0004 DD12 A00F  18        a    ry,rtmp
0005 DD14 06CF  14        swpb ry
0006 DD16 D40D  30        movb RA,*rtmp
                   < elite.a99
33972               
33973 DD18 0200  20        li   rtmp,EE51                  ; JSR EE51          ; Call EE51 to remove the ship from the screen
     DD1A DDA8     
33974 DD1C 06A0  32        bl   @jsr                       ;
     DD1E FE28     
33975               
33976                                                                          ; We now need to set up a new explosion cloud. We
33977                                                                          ; initialise it with a size of 18 (which gets increased
33978                                                                          ; by 4 every time the cloud gets redrawn), and the
33979                                                                          ; explosion count (i.e. the number of particles in the
33980                                                                          ; explosion), which go into bytes 1 and 2 of the ship
33981                                                                          ; line heap. See DOEXP for more details of explosion
33982                                                                          ; clouds
33983               
33984 DD20 020F  20        li   ry,>01*256                 ; LDY #1            ; Set byte #1 of the ship line heap to 18, the initial
     DD22 0100     
33985 DD24 020D  20        li   ra,>12*256                 ; LDA #18           ; size of the explosion cloud
     DD26 1200     
33986                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 DD28 D820  42        movb @XX19,@rtmplb
     DD2A 0074     
     DD2C 8301     
0002 DD2E D020  30        movb @XX19+1,rtmp
     DD30 0075     
0003 DD32 06CF  14        swpb ry
0004 DD34 A00F  18        a    ry,rtmp
0005 DD36 06CF  14        swpb ry
0006 DD38 D40D  30        movb RA,*rtmp
                   < elite.a99
33987               
33988 DD3A 020F  20        li   ry,>07*256                 ; LDY #7            ; Fetch byte #7 from the ship's blueprint, which
     DD3C 0700     
33989                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; determines the explosion count (i.e. the number of
     **** ****     > LD_IND_Y_IDX
0001 DD3E D820  42        movb @XX0,@rtmplb
     DD40 001E     
     DD42 8301     
0002 DD44 D020  30        movb @XX0+1,rtmp
     DD46 001F     
0003 DD48 06CF  14        swpb ry
0004 DD4A A00F  18        a    ry,rtmp
0005 DD4C 06CF  14        swpb ry
0006 DD4E D350  26        movb *rtmp,RA
                   < elite.a99
33990 DD50 020F  20        li   ry,>02*256                 ; LDY #2            ; vertices used as origins for explosion clouds), and
     DD52 0200     
33991                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; store it in byte #2 of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 DD54 D820  42        movb @XX19,@rtmplb
     DD56 0074     
     DD58 8301     
0002 DD5A D020  30        movb @XX19+1,rtmp
     DD5C 0075     
0003 DD5E 06CF  14        swpb ry
0004 DD60 A00F  18        a    ry,rtmp
0005 DD62 06CF  14        swpb ry
0006 DD64 D40D  30        movb RA,*rtmp
                   < elite.a99
33992               
33993               * LDA XX1+32             \ These instructions are commented out in the original
33994               * AND #&7F               \ source
33995               
33996                                                                          ; The following loop sets bytes 3-6 of the of the ship
33997                                                                          ; line heap to random numbers
33998               
33999               EE55:
34000 DD66 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y (so the loop starts at 3)
34001               
34002 DD68 0200  20        li   rtmp,DORND                 ; JSR DORND         ; Set A and X to random numbers
     DD6A C7D0     
34003 DD6C 06A0  32        bl   @jsr                       ;
     DD6E FE28     
34004               
34005                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in the Y-th byte of the ship line heap
     **** ****     > ST_IND_Y_IDX
0001 DD70 D820  42        movb @XX19,@rtmplb
     DD72 0074     
     DD74 8301     
0002 DD76 D020  30        movb @XX19+1,rtmp
     DD78 0075     
0003 DD7A 06CF  14        swpb ry
0004 DD7C A00F  18        a    ry,rtmp
0005 DD7E 06CF  14        swpb ry
0006 DD80 D40D  30        movb RA,*rtmp
                   < elite.a99
34006               
34007 DD82 028F  22        ci   ry,>06*256                 ; CPY #6            ; Loop back until we have randomised the 6th byte
     DD84 0600     
34008 DD86 16EF  14        jne  EE55                       ; BNE EE55
34009               
34010               EE28:
34011 DD88 D360  30        movb @XX1+8,ra                  ; LDA XX1+8         ; Set A = z_sign
     DD8A 005B     
34012               
34013               EE49:
34014 DD8C 151E  14        jgt  LL10                       ; BPL LL10          ; If A is positive, i.e. the ship is in front of us,
34015                                                                          ; jump down to LL10
34016               
34017               LL14:
34018                                                                          ; The following removes the ship from the screen by
34019                                                                          ; redrawing it (or, if it is exploding, by redrawing the
34020                                                                          ; explosion cloud). We call it when the ship is no
34021                                                                          ; longer on-screen, is too far away to be fully drawn,
34022                                                                          ; and so on
34023 DD8E D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     DD90 0072     
34024 DD92 024D  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE51
     DD94 2000     
34025 DD96 1308  14        jeq  EE51                       ; BEQ EE51          ; to redraw its wireframe
34026               
34027 DD98 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so clear bit 3 of the ship's
     DD9A 0072     
34028 DD9C 024D  22        andi ra,>f7*256                 ; AND #%11110111    ; byte #31 to denote that the ship is no longer being
     DD9E F700     
34029 DDA0 D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; drawn on-screen
     DDA2 0072     
34030               
34031 DDA4 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud, which
     DDA6 AE6C     
34032                                                                          ; will remove it from the screen, returning from the
34033                                                                          ; subroutine using a tail call
34034               
34035               EE51:
34036 DDA8 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     DDAA 0800     
34037                      .bit @XX1+31                    ; BIT XX1+31        ; is already nothing being shown for this ship, so
     **** ****     > BIT
0001 DDAC D020  30        movb @XX1+31,rtmp
     DDAE 0072     
0002 DDB0 0540  14        inv  rtmp
0003 DDB2 D047  18        movb rone,rtmp2
0004 DDB4 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34038 DDB6 1308  14        jeq  LL10-1                     ; BEQ LL10-1        ; return from the subroutine (as LL10-1 contains an RTS)
34039               
34040                      .eor @XX1+31                    ; EOR XX1+31        ; Otherwise flip bit 3 of byte #31 and store it (which
     **** ****     > EOR
0001 DDB8 D020  30        movb @XX1+31,rtmp
     DDBA 0072     
0002 DDBC 2B40  18        xor  rtmp,ra
                   < elite.a99
34041 DDBE D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; clears bit 3 as we know it was set before the EOR), so
     DDC0 0072     
34042                                                                          ; this sets this ship as no longer being drawn on-screen
34043               
34044 DDC2 0460  28        b    @LL155                     ; JMP LL155         ; Jump to LL155 to draw the ship, which removes it from
     DDC4 EBB4     
34045                                                                          ; the screen, returning from the subroutine using a
34046                                                                          ; tail call
34047               
34048               * .LL24                  \ This label is commented out in the original source,
34049                                                                          ; and was presumably used to label the RTS which is
34050                                                                          ; actually called by LL10-1 above, not LL24
34051               
34052 DDC6 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     DDC8 FE34     
34053               
34054               * ******************************************************************************
34055               *
34056               * Name: LL9 (Part 2 of 12)
34057               * Type: Subroutine
34058               * Category: Drawing ships
34059               * Summary: Draw ship: Check if ship is in field of view, close enough to draw
34060               * Deep dive: Drawing ships
34061               *
34062               * ------------------------------------------------------------------------------
34063               *
34064               * This part checks whether the ship is in our field of view, and whether it is
34065               * close enough to be fully drawn (if not, we jump to SHPPT to draw it as a dot).
34066               *
34067               * ------------------------------------------------------------------------------
34068               *
34069               * Other entry points:
34070               *
34071               * LL10-1              Contains an RTS
34072               *
34073               * ******************************************************************************
34074               
34075               LL10:
34076 DDCA D360  30        movb @XX1+7,ra                  ; LDA XX1+7         ; Set A = z_hi
     DDCC 005A     
34077               
34078 DDCE 028D  22        ci   ra,>c0*256                 ; CMP #192          ; If A >= 192 then the ship is a long way away, so jump
     DDD0 C000     
34079 DDD2 18DD  14        joc  LL14                       ; BCS LL14          ; to LL14 to remove the ship from the screen
34080               
34081 DDD4 D360  30        movb @XX1,ra                    ; LDA XX1           ; If x_lo >= z_lo, set the C flag, otherwise clear it
     DDD6 0053     
34082 DDD8 9360  30        cb   @XX1+6,ra                  ; CMP XX1+6
     DDDA 0059     
34083               
34084 DDDC D360  30        movb @XX1+1,ra                  ; LDA XX1+1         ; Set A = x_hi - z_hi using the carry from the low
     DDDE 0054     
34085                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 DDE0 1801  14        joc  !
0002 DDE2 7347  18        sb   rone,ra
0003               !:
0004 DDE4 7360  30        sb   @XX1+7,ra
     DDE6 005A     
                   < elite.a99
34086                                                                          ; two-byte subtraction (x_hi x_lo) - (z_hi z_lo)
34087               
34088 DDE8 18D2  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then x >= z, so the ship is
34089                                                                          ; further to the side than it is in front of us, so it's
34090                                                                          ; outside our viewing angle of 45 degrees, and we jump
34091                                                                          ; to LL14 to remove it from the screen
34092               
34093 DDEA D360  30        movb @XX1+3,ra                  ; LDA XX1+3         ; If y_lo >= z_lo, set the C flag, otherwise clear it
     DDEC 0056     
34094 DDEE 9360  30        cb   @XX1+6,ra                  ; CMP XX1+6
     DDF0 0059     
34095               
34096 DDF2 D360  30        movb @XX1+4,ra                  ; LDA XX1+4         ; Set A = y_hi - z_hi using the carry from the low
     DDF4 0057     
34097                      .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
     **** ****     > SBC
0001 DDF6 1801  14        joc  !
0002 DDF8 7347  18        sb   rone,ra
0003               !:
0004 DDFA 7360  30        sb   @XX1+7,ra
     DDFC 005A     
                   < elite.a99
34098                                                                          ; two-byte subtraction (y_hi y_lo) - (z_hi z_lo)
34099               
34100 DDFE 18C7  14        joc  LL14                       ; BCS LL14          ; If the C flag is set then y >= z, so the ship is
34101                                                                          ; further above us than it is in front of us, so it's
34102                                                                          ; outside our viewing angle of 45 degrees, and we jump
34103                                                                          ; to LL14 to remove it from the screen
34104               
34105 DE00 020F  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 from the ship's blueprint into X, which
     DE02 0600     
34106                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; is the number * 4 of the vertex used for the ship's
     **** ****     > LD_IND_Y_IDX
0001 DE04 D820  42        movb @XX0,@rtmplb
     DE06 001E     
     DE08 8301     
0002 DE0A D020  30        movb @XX0+1,rtmp
     DE0C 001F     
0003 DE0E 06CF  14        swpb ry
0004 DE10 A00F  18        a    ry,rtmp
0005 DE12 06CF  14        swpb ry
0006 DE14 D350  26        movb *rtmp,RA
                   < elite.a99
34107 DE16 D38D  18        movb ra,rx                      ; TAX               ; laser
34108               
34109 DE18 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set bytes X and X+1 of the XX3 heap to 255. We're
     DE1A FF00     
34110 DE1C 06CE  14        swpb rx                         ;
34111 DE1E DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; going to use XX3 to store the screen coordinates of
     DE20 0100     
34112 DE22 06CE  14        swpb rx                         ;
34113 DE24 06CE  14        swpb rx                         ;
34114 DE26 DB8D  38        movb ra,@XX3+1(rx)              ; STA XX3+1,X       ; all the visible vertices of this ship, so setting the
     DE28 0101     
34115 DE2A 06CE  14        swpb rx                         ;
34116                                                                          ; laser vertex to 255 means that if we don't update this
34117                                                                          ; vertex with its screen coordinates in parts 6 and 7,
34118                                                                          ; this vertex's entry in the XX3 heap will still be 255,
34119                                                                          ; which we can check in part 9 to see if the laser
34120                                                                          ; vertex is visible (and therefore whether we should
34121                                                                          ; draw laser lines if the ship is firing on us)
34122               
34123 DE2C D360  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (A T) = (z_hi z_lo)
     DE2E 0059     
34124 DE30 D80D  30        movb ra,@T                      ; STA T
     DE32 00D1     
34125 DE34 D360  30        movb @XX1+7,ra                  ; LDA XX1+7
     DE36 005A     
34126               
34127 DE38 091D  18        srl  ra,1                       ; LSR A             ; Set (A T) = (A T) / 8
34128 DE3A 0204  20        li   rarg1,T                    ; ROR T
     DE3C 00D1     
34129 DE3E 06A0  32        bl   @ror                       ;
     DE40 FE7A     
34130 DE42 091D  18        srl  ra,1                       ; LSR A
34131 DE44 0204  20        li   rarg1,T                    ; ROR T
     DE46 00D1     
34132 DE48 06A0  32        bl   @ror                       ;
     DE4A FE7A     
34133 DE4C 091D  18        srl  ra,1                       ; LSR A
34134 DE4E 0204  20        li   rarg1,T                    ; ROR T
     DE50 00D1     
34135 DE52 06A0  32        bl   @ror                       ;
     DE54 FE7A     
34136               
34137 DE56 091D  18        srl  ra,1                       ; LSR A             ; If A >> 4 is non-zero, i.e. z_hi >= 16, jump to LL13
34138 DE58 160A  14        jne  LL13                       ; BNE LL13          ; as the ship is possibly far away enough to be shown as
34139                                                                          ; a dot
34140               
34141 DE5A D360  30        movb @T,ra                      ; LDA T             ; Otherwise the C flag contains the previous bit 0 of A,
     DE5C 00D1     
34142 DE5E 06A0  32        bl   @rora                      ; ROR A             ; which could have been set, so rotate A right four
     DE60 FE62     
34143 DE62 091D  18        srl  ra,1                       ; LSR A             ; times so it's in the form %000xxxxx, i.e. z_hi reduced
34144 DE64 091D  18        srl  ra,1                       ; LSR A             ; to a maximum value of 31
34145 DE66 091D  18        srl  ra,1                       ; LSR A
34146               
34147 DE68 D80D  30        movb ra,@XX4                    ; STA XX4           ; Store A in XX4, which is now the distance of the ship
     DE6A 00A7     
34148                                                                          ; we can use for visibility testing
34149               
34150 DE6C 1517  14        jgt  LL17                       ; BPL LL17          ; Jump down to LL17 (this BPL is effectively a JMP as we
34151                                                                          ; know bit 7 of A is definitely clear)
34152               
34153               LL13:
34154                                                                          ; If we get here then the ship is possibly far enough
34155                                                                          ; away to be shown as a dot
34156 DE6E 020F  20        li   ry,>0d*256                 ; LDY #13           ; Fetch byte #13 from the ship's blueprint, which gives
     DE70 0D00     
34157                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the ship's visibility distance, beyond which we show
     **** ****     > LD_IND_Y_IDX
0001 DE72 D820  42        movb @XX0,@rtmplb
     DE74 001E     
     DE76 8301     
0002 DE78 D020  30        movb @XX0+1,rtmp
     DE7A 001F     
0003 DE7C 06CF  14        swpb ry
0004 DE7E A00F  18        a    ry,rtmp
0005 DE80 06CF  14        swpb ry
0006 DE82 D350  26        movb *rtmp,RA
                   < elite.a99
34158                                                                          ; the ship as a dot
34159               
34160 DE84 9360  30        cb   @XX1+7,ra                  ; CMP XX1+7         ; If z_hi <= the visibility distance, skip to LL17 to
     DE86 005A     
34161 DE88 1809  14        joc  LL17                       ; BCS LL17          ; draw the ship fully, rather than as a dot, as it is
34162                                                                          ; closer than the visibility distance
34163               
34164 DE8A 020D  20        li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the
     DE8C 2000     
34165                      .and @XX1+31                    ; AND XX1+31        ; ship is currently exploding, so skip to LL17 to draw
     **** ****     > AND
0001 DE8E D020  30        movb @XX1+31,rtmp
     DE90 0072     
0002 DE92 0540  14        inv  rtmp
0003 DE94 5340  18        szcb rtmp,ra
                   < elite.a99
34166 DE96 1602  14        jne  LL17                       ; BNE LL17          ; the ship's explosion cloud
34167               
34168 DE98 0460  28        b    @SHPPT                     ; JMP SHPPT         ; Otherwise jump to SHPPT to draw the ship as a dot,
     DE9A D9C6     
34169                                                                          ; returning from the subroutine using a tail call
34170               
34171               * ******************************************************************************
34172               *
34173               * Name: LL9 (Part 3 of 12)
34174               * Type: Subroutine
34175               * Category: Drawing ships
34176               * Summary: Draw ship: Set up orientation vector, ship coordinate variables
34177               * Deep dive: Drawing ships
34178               *
34179               * ------------------------------------------------------------------------------
34180               *
34181               * This part sets up the following variable blocks:
34182               *
34183               * * XX16 contains the orientation vectors, divided to normalise them
34184               *
34185               * * XX18 contains the ship's x, y and z coordinates in space
34186               *
34187               * ******************************************************************************
34188               
34189               LL17:
34190 DE9C 020E  20        li   rx,>05*256                 ; LDX #5            ; First we copy the three orientation vectors into XX16,
     DE9E 0500     
34191                                                                          ; so set up a counter in X for the 6 bytes in each
34192                                                                          ; vector
34193               
34194               LL15:
34195 DEA0 06CE  14        swpb rx                         ;
34196 DEA2 D36E  34        movb @XX1+21(rx),ra             ; LDA XX1+21,X      ; Copy the X-th byte of sidev to the X-th byte of XX16
     DEA4 0068     
34197 DEA6 06CE  14        swpb rx                         ;
34198 DEA8 06CE  14        swpb rx                         ;
34199 DEAA DB8D  38        movb ra,@XX16(rx)               ; STA XX16,X
     DEAC 0009     
34200 DEAE 06CE  14        swpb rx                         ;
34201               
34202 DEB0 06CE  14        swpb rx                         ;
34203 DEB2 D36E  34        movb @XX1+15(rx),ra             ; LDA XX1+15,X      ; Copy the X-th byte of roofv to XX16+6 to the X-th byte
     DEB4 0062     
34204 DEB6 06CE  14        swpb rx                         ;
34205 DEB8 06CE  14        swpb rx                         ;
34206 DEBA DB8D  38        movb ra,@XX16+6(rx)             ; STA XX16+6,X      ; of XX16+6
     DEBC 000F     
34207 DEBE 06CE  14        swpb rx                         ;
34208               
34209 DEC0 06CE  14        swpb rx                         ;
34210 DEC2 D36E  34        movb @XX1+9(rx),ra              ; LDA XX1+9,X       ; Copy the X-th byte of nosev to XX16+12 to the X-th
     DEC4 005C     
34211 DEC6 06CE  14        swpb rx                         ;
34212 DEC8 06CE  14        swpb rx                         ;
34213 DECA DB8D  38        movb ra,@XX16+12(rx)            ; STA XX16+12,X     ; byte of XX16+12
     DECC 0015     
34214 DECE 06CE  14        swpb rx                         ;
34215               
34216 DED0 7387  18        sb   rone,rx                    ; DEX               ; Decrement the counter
34217               
34218 DED2 15E6  14        jgt  LL15                       ; BPL LL15          ; Loop back to copy the next byte of each vector, until
34219                                                                          ; we have the following:
34220                                                                          ;
34221                                                                          ; * XX16(1 0) = sidev_x
34222                                                                          ; * XX16(3 2) = sidev_y
34223                                                                          ; * XX16(5 4) = sidev_z
34224                                                                          ;
34225                                                                          ; * XX16(7 6) = roofv_x
34226                                                                          ; * XX16(9 8) = roofv_y
34227                                                                          ; * XX16(11 10) = roofv_z
34228                                                                          ;
34229                                                                          ; * XX16(13 12) = nosev_x
34230                                                                          ; * XX16(15 14) = nosev_y
34231                                                                          ; * XX16(17 16) = nosev_z
34232               
34233 DED4 020D  20        li   ra,>c5*256                 ; LDA #197          ; Set Q = 197
     DED6 C500     
34234 DED8 D80D  30        movb ra,@Q                      ; STA Q
     DEDA 0090     
34235               
34236 DEDC 020F  20        li   ry,>10*256                 ; LDY #16           ; Set Y to be a counter that counts down by 2 each time,
     DEDE 1000     
34237                                                                          ; starting with 16, then 14, 12 and so on. We use this
34238                                                                          ; to work through each of the coordinates in each of the
34239                                                                          ; orientation vectors
34240               
34241               LL21:
34242 DEE0 06CF  14        swpb ry                         ;
34243 DEE2 D36F  34        movb @XX16(ry),ra               ; LDA XX16,Y        ; Set A = the low byte of the vector coordinate, e.g.
     DEE4 0009     
34244 DEE6 06CF  14        swpb ry                         ;
34245                                                                          ; nosev_z_lo when Y = 16
34246               
34247                      .asla                           ; ASL A             ; Shift bit 7 into the C flag
     **** ****     > ASLA
0001 DEE8 024D  22        andi ra,>ff00
     DEEA FF00     
0002 DEEC 0A1D  18        sla  ra,1
                   < elite.a99
34248               
34249 DEEE 06CF  14        swpb ry                         ;
34250 DEF0 D36F  34        movb @XX16+1(ry),ra             ; LDA XX16+1,Y      ; Set A = the high byte of the vector coordinate, e.g.
     DEF2 000A     
34251 DEF4 06CF  14        swpb ry                         ;
34252                                                                          ; nosev_z_hi when Y = 16
34253               
34254 DEF6 06A0  32        bl   @rola                      ; ROL A             ; Rotate A left, incorporating the C flag, so A now
     DEF8 FE3E     
34255                                                                          ; contains the original high byte, doubled, and without
34256                                                                          ; a sign bit, e.g. A = |nosev_z_hi| * 2
34257               
34258 DEFA 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     DEFC DB2C     
34259 DEFE 06A0  32        bl   @jsr                       ;
     DF00 FE28     
34260                                                                          ;
34261                                                                          ; R = 256 * A / Q
34262                                                                          ;
34263                                                                          ; so, for nosev, this would be:
34264                                                                          ;
34265                                                                          ; R = 256 * |nosev_z_hi| * 2 / 197
34266                                                                          ; = 2.6 * |nosev_z_hi|
34267               
34268 DF02 D3A0  30        movb @R,rx                      ; LDX R             ; Store R in the low byte's location, so we can keep the
     DF04 0091     
34269 DF06 DBCE  38        movb rx,@XX16(ry)               ; STX XX16,Y        ; old, unscaled high byte intact for the sign
     DF08 0009     
34270               
34271 DF0A 73C7  18        sb   rone,ry                    ; DEY               ; Decrement the loop counter twice
34272 DF0C 73C7  18        sb   rone,ry                    ; DEY
34273               
34274 DF0E 15E8  14        jgt  LL21                       ; BPL LL21          ; Loop back for the next vector coordinate until we have
34275                                                                          ; divided them all
34276               
34277                                                                          ; By this point, the vectors have been turned into
34278                                                                          ; scaled magnitudes, so we have the following:
34279                                                                          ;
34280                                                                          ; * XX16   = scaled |sidev_x|
34281                                                                          ; * XX16+2 = scaled |sidev_y|
34282                                                                          ; * XX16+4 = scaled |sidev_z|
34283                                                                          ;
34284                                                                          ; * XX16+6  = scaled |roofv_x|
34285                                                                          ; * XX16+8  = scaled |roofv_y|
34286                                                                          ; * XX16+10 = scaled |roofv_z|
34287                                                                          ;
34288                                                                          ; * XX16+12 = scaled |nosev_x|
34289                                                                          ; * XX16+14 = scaled |nosev_y|
34290                                                                          ; * XX16+16 = scaled |nosev_z|
34291               
34292 DF10 020E  20        li   rx,>08*256                 ; LDX #8            ; Next we copy the ship's coordinates into XX18, so set
     DF12 0800     
34293                                                                          ; up a counter in X for 9 bytes
34294               
34295               ll91_:
34296 DF14 06CE  14        swpb rx                         ;
34297 DF16 D36E  34        movb @XX1(rx),ra                ; LDA XX1,X         ; Copy the X-th byte from XX1 to XX18
     DF18 0053     
34298 DF1A 06CE  14        swpb rx                         ;
34299 DF1C 06CE  14        swpb rx                         ;
34300 DF1E DB8D  38        movb ra,@XX18(rx)               ; STA XX18,X
     DF20 007E     
34301 DF22 06CE  14        swpb rx                         ;
34302               
34303 DF24 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
34304               
34305 DF26 15F6  14        jgt  ll91_                      ; BPL ll91          ; Loop back for the next byte until we have copied all
34306                                                                          ; three coordinates
34307               
34308                                                                          ; So we now have the following:
34309                                                                          ;
34310                                                                          ; * XX18(2 1 0) = (x_sign x_hi x_lo)
34311                                                                          ;
34312                                                                          ; * XX18(5 4 3) = (y_sign y_hi y_lo)
34313                                                                          ;
34314                                                                          ; * XX18(8 7 6) = (z_sign z_hi z_lo)
34315               
34316 DF28 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set the 15th byte of XX2 to 255, so that face 15 is
     DF2A FF00     
34317 DF2C D80D  30        movb ra,@XX2+15                 ; STA XX2+15        ; always visible. No ship definitions actually have this
     DF2E 00E1     
34318                                                                          ; number of faces, but this allows us to force a vertex
34319                                                                          ; to always be visible by associating it with face 15
34320                                                                          ; (see the ship blueprints for the Cobra Mk III at
34321                                                                          ; SHIP_COBRA_MK_3 and the asteroid at SHIP_ASTEROID for
34322                                                                          ; examples of vertices that are associated with face 15)
34323               
34324 DF30 020F  20        li   ry,>0c*256                 ; LDY #12           ; Set Y = 12 to point to the ship blueprint byte #12,
     DF32 0C00     
34325               
34326 DF34 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     DF36 0072     
34327 DF38 024D  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE29
     DF3A 2000     
34328 DF3C 1319  14        jeq  EE29                       ; BEQ EE29          ; to skip the following
34329               
34330                                                                          ; Otherwise we fall through to set up the visibility
34331                                                                          ; block for an exploding ship
34332               
34333               * ******************************************************************************
34334               *
34335               * Name: LL9 (Part 4 of 12)
34336               * Type: Subroutine
34337               * Category: Drawing ships
34338               * Summary: Draw ship: Set visibility for exploding ship (all faces visible)
34339               * Deep dive: Drawing ships
34340               *
34341               * ------------------------------------------------------------------------------
34342               *
34343               * This part sets up the visibility block in XX2 for a ship that is exploding.
34344               *
34345               * The XX2 block consists of one byte for each face in the ship's blueprint,
34346               * which holds the visibility of that face. Because the ship is exploding, we
34347               * want to set all the faces to be visible. A value of 255 in the visibility
34348               * table means the face is visible, so the following code sets each face to 255
34349               * and then skips over the face visibility calculations that we would apply to a
34350               * non-exploding ship.
34351               *
34352               * ******************************************************************************
34353               
34354                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Fetch byte #12 of the ship's blueprint, which contains
     **** ****     > LD_IND_Y_IDX
0001 DF3E D820  42        movb @XX0,@rtmplb
     DF40 001E     
     DF42 8301     
0002 DF44 D020  30        movb @XX0+1,rtmp
     DF46 001F     
0003 DF48 06CF  14        swpb ry
0004 DF4A A00F  18        a    ry,rtmp
0005 DF4C 06CF  14        swpb ry
0006 DF4E D350  26        movb *rtmp,RA
                   < elite.a99
34355                                                                          ; the number of faces * 4
34356               
34357 DF50 091D  18        srl  ra,1                       ; LSR A             ; Set X = A / 4
34358 DF52 091D  18        srl  ra,1                       ; LSR A             ; = the number of faces
34359 DF54 D38D  18        movb ra,rx                      ; TAX
34360               
34361 DF56 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set A = 255
     DF58 FF00     
34362               
34363               EE30:
34364 DF5A 06CE  14        swpb rx                         ;
34365 DF5C DB8D  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Set the X-th byte of XX2 to 255
     DF5E 00D2     
34366 DF60 06CE  14        swpb rx                         ;
34367               
34368 DF62 7387  18        sb   rone,rx                    ; DEX               ; Decrement the loop counter
34369               
34370 DF64 15FA  14        jgt  EE30                       ; BPL EE30          ; Loop back for the next byte until there is one byte
34371                                                                          ; set to 255 for each face
34372               
34373 DF66 B387  18        ab   rone,rx                    ; INX               ; Set XX4 = 0 for the distance value we use to test
34374 DF68 D80E  30        movb rx,@XX4                    ; STX XX4           ; for visibility, so we always shows everything
     DF6A 00A7     
34375               
34376               LL41:
34377 DF6C 0460  28        b    @LL42                      ; JMP LL42          ; Jump to LL42 to skip the face visibility calculations
     DF6E E31C     
34378                                                                          ; as we don't need to do them now we've set up the XX2
34379                                                                          ; block for the explosion
34380               
34381               * ******************************************************************************
34382               *
34383               * Name: LL9 (Part 5 of 12)
34384               * Type: Subroutine
34385               * Category: Drawing ships
34386               * Summary: Draw ship: Calculate the visibility of each of the ship's faces
34387               * Deep dive: Drawing ships
34388               * Back-face culling
34389               *
34390               * ******************************************************************************
34391               
34392               EE29:
34393                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; We set Y to 12 above before jumping down to EE29, so
     **** ****     > LD_IND_Y_IDX
0001 DF70 D820  42        movb @XX0,@rtmplb
     DF72 001E     
     DF74 8301     
0002 DF76 D020  30        movb @XX0+1,rtmp
     DF78 001F     
0003 DF7A 06CF  14        swpb ry
0004 DF7C A00F  18        a    ry,rtmp
0005 DF7E 06CF  14        swpb ry
0006 DF80 D350  26        movb *rtmp,RA
                   < elite.a99
34394                                                                          ; this fetches byte #12 of the ship's blueprint, which
34395                                                                          ; contains the number of faces * 4
34396               
34397 DF82 13F4  14        jeq  LL41                       ; BEQ LL41          ; If there are no faces in this ship, jump to LL42 (via
34398                                                                          ; LL41) to skip the face visibility calculations
34399               
34400 DF84 D80D  30        movb ra,@XX20                   ; STA XX20          ; Set A = the number of faces * 4
     DF86 00A8     
34401               
34402 DF88 020F  20        li   ry,>12*256                 ; LDY #18           ; Fetch byte #18 of the ship's blueprint, which contains
     DF8A 1200     
34403                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the factor by which we scale the face normals, into X
     **** ****     > LD_IND_Y_IDX
0001 DF8C D820  42        movb @XX0,@rtmplb
     DF8E 001E     
     DF90 8301     
0002 DF92 D020  30        movb @XX0+1,rtmp
     DF94 001F     
0003 DF96 06CF  14        swpb ry
0004 DF98 A00F  18        a    ry,rtmp
0005 DF9A 06CF  14        swpb ry
0006 DF9C D350  26        movb *rtmp,RA
                   < elite.a99
34404 DF9E D38D  18        movb ra,rx                      ; TAX
34405               
34406 DFA0 D360  30        movb @XX18+7,ra                 ; LDA XX18+7        ; Set A = z_hi
     DFA2 0085     
34407               
34408               LL90:
34409 DFA4 D3CD  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
34410               
34411 DFA6 131A  14        jeq  LL91                       ; BEQ LL91          ; If z_hi = 0 then jump to LL91
34412               
34413                                                                          ; The following is a loop that jumps back to LL90+3,
34414                                                                          ; i.e. here. LL90 is only used for this loop, so it's a
34415                                                                          ; bit of a strange use of the label here
34416               
34417 DFA8 B387  18        ab   rone,rx                    ; INX               ; Increment the scale factor in X
34418               
34419                      .lsr @XX18+4                    ; LSR XX18+4        ; Divide (y_hi y_lo) by 2
     **** ****     > LSR
0001 DFAA D020  30        movb @XX18+4,rtmp
     DFAC 0082     
0002 DFAE 0910  18        srl  rtmp,1
0003 DFB0 D800  30        movb rtmp,@XX18+4
     DFB2 0082     
                   < elite.a99
34420 DFB4 0204  20        li   rarg1,XX18+3               ; ROR XX18+3
     DFB6 0081     
34421 DFB8 06A0  32        bl   @ror                       ;
     DFBA FE7A     
34422               
34423                      .lsr @XX18+1                    ; LSR XX18+1        ; Divide (x_hi x_lo) by 2
     **** ****     > LSR
0001 DFBC D020  30        movb @XX18+1,rtmp
     DFBE 007F     
0002 DFC0 0910  18        srl  rtmp,1
0003 DFC2 D800  30        movb rtmp,@XX18+1
     DFC4 007F     
                   < elite.a99
34424 DFC6 0204  20        li   rarg1,XX18                 ; ROR XX18
     DFC8 007E     
34425 DFCA 06A0  32        bl   @ror                       ;
     DFCC FE7A     
34426               
34427 DFCE 091D  18        srl  ra,1                       ; LSR A             ; Divide (z_hi z_lo) by 2 (as A contains z_hi)
34428 DFD0 0204  20        li   rarg1,XX18+6               ; ROR XX18+6
     DFD2 0084     
34429 DFD4 06A0  32        bl   @ror                       ;
     DFD6 FE7A     
34430               
34431 DFD8 D3CD  18        movb ra,ry                      ; TAY               ; Set Y = z_hi
34432               
34433 DFDA 16E5  14        jne  LL90+3                     ; BNE LL90+3        ; If Y is non-zero, loop back to LL90+3 to divide the
34434                                                                          ; three coordinates until z_hi is 0
34435               
34436               LL91:
34437                                                                          ; By this point z_hi is 0 and X contains the number of
34438                                                                          ; right shifts we had to do, plus the scale factor from
34439                                                                          ; the blueprint
34440 DFDC D80E  30        movb rx,@XX17                   ; STX XX17          ; Store the updated scale factor in XX17
     DFDE 0095     
34441               
34442 DFE0 D360  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set XX15+5 = z_sign
     DFE2 0086     
34443 DFE4 D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     DFE6 0036     
34444               
34445 DFE8 D360  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = (x_sign x_lo)
     DFEA 007E     
34446 DFEC D80D  30        movb ra,@XX15                   ; STA XX15
     DFEE 0031     
34447 DFF0 D360  30        movb @XX18+2,ra                 ; LDA XX18+2
     DFF2 0080     
34448 DFF4 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     DFF6 0032     
34449               
34450 DFF8 D360  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = (y_sign y_lo)
     DFFA 0081     
34451 DFFC D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     DFFE 0033     
34452 E000 D360  30        movb @XX18+5,ra                 ; LDA XX18+5
     E002 0083     
34453 E004 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E006 0034     
34454               
34455 E008 D360  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15+4 = z_lo, so now XX15(5 4) = (z_sign z_lo)
     E00A 0084     
34456 E00C D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     E00E 0035     
34457               
34458 E010 0200  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     E012 DBDA     
34459 E014 06A0  32        bl   @jsr                       ;
     E016 FE28     
34460                                                                          ; XX16, which we'll call dot_sidev, dot_roofv and
34461                                                                          ; dot_nosev:
34462                                                                          ;
34463                                                                          ; XX12(1 0) = [x y z] . sidev
34464                                                                          ; = (dot_sidev_sign dot_sidev_lo)
34465                                                                          ; = dot_sidev
34466                                                                          ;
34467                                                                          ; XX12(3 2) = [x y z] . roofv
34468                                                                          ; = (dot_roofv_sign dot_roofv_lo)
34469                                                                          ; = dot_roofv
34470                                                                          ;
34471                                                                          ; XX12(5 4) = [x y z] . nosev
34472                                                                          ; = (dot_nosev_sign dot_nosev_lo)
34473                                                                          ; = dot_nosev
34474               
34475 E018 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set XX18(2 0) = dot_sidev
     E01A 0037     
34476 E01C D80D  30        movb ra,@XX18                   ; STA XX18
     E01E 007E     
34477 E020 D360  30        movb @XX12+1,ra                 ; LDA XX12+1
     E022 0038     
34478 E024 D80D  30        movb ra,@XX18+2                 ; STA XX18+2
     E026 0080     
34479               
34480 E028 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX18(5 3) = dot_roofv
     E02A 0039     
34481 E02C D80D  30        movb ra,@XX18+3                 ; STA XX18+3
     E02E 0081     
34482 E030 D360  30        movb @XX12+3,ra                 ; LDA XX12+3
     E032 003A     
34483 E034 D80D  30        movb ra,@XX18+5                 ; STA XX18+5
     E036 0083     
34484               
34485 E038 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set XX18(8 6) = dot_nosev
     E03A 003B     
34486 E03C D80D  30        movb ra,@XX18+6                 ; STA XX18+6
     E03E 0084     
34487 E040 D360  30        movb @XX12+5,ra                 ; LDA XX12+5
     E042 003C     
34488 E044 D80D  30        movb ra,@XX18+8                 ; STA XX18+8
     E046 0086     
34489               
34490 E048 020F  20        li   ry,>04*256                 ; LDY #4            ; Fetch byte #4 of the ship's blueprint, which contains
     E04A 0400     
34491                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the low byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 E04C D820  42        movb @XX0,@rtmplb
     E04E 001E     
     E050 8301     
0002 E052 D020  30        movb @XX0+1,rtmp
     E054 001F     
0003 E056 06CF  14        swpb ry
0004 E058 A00F  18        a    ry,rtmp
0005 E05A 06CF  14        swpb ry
0006 E05C D350  26        movb *rtmp,RA
                   < elite.a99
34492               
34493                      .clc                            ; CLC               ; Set V = low byte faces offset + XX0
     **** ****     > CLC
0001 E05E 0A16  18        sla  rzero,1
                   < elite.a99
34494                      .adc @XX0,ra                    ; ADC XX0
     **** ****     > ADC
0001 E060 1701  14        jnc  !
0002 E062 B347  18        ab   rone,ra
0003               !:
0004 E064 B360  30        ab   @XX0,ra
     E066 001E     
                   < elite.a99
34495 E068 D80D  30        movb ra,@V                      ; STA V
     E06A 0022     
34496               
34497 E06C 020F  20        li   ry,>11*256                 ; LDY #17           ; Fetch byte #17 of the ship's blueprint, which contains
     E06E 1100     
34498                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the faces data
     **** ****     > LD_IND_Y_IDX
0001 E070 D820  42        movb @XX0,@rtmplb
     E072 001E     
     E074 8301     
0002 E076 D020  30        movb @XX0+1,rtmp
     E078 001F     
0003 E07A 06CF  14        swpb ry
0004 E07C A00F  18        a    ry,rtmp
0005 E07E 06CF  14        swpb ry
0006 E080 D350  26        movb *rtmp,RA
                   < elite.a99
34499               
34500                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte faces offset + XX0+1
     **** ****     > ADC
0001 E082 1701  14        jnc  !
0002 E084 B347  18        ab   rone,ra
0003               !:
0004 E086 B360  30        ab   @XX0+1,ra
     E088 001F     
                   < elite.a99
34501 E08A D80D  30        movb ra,@V+1                    ; STA V+1           ;
     E08C 0023     
34502                                                                          ; So V(1 0) now points to the start of the faces data
34503                                                                          ; for this ship
34504               
34505 E08E 020F  20        li   ry,>00*256                 ; LDY #0            ; We're now going to loop through all the faces for this
     E090 0000     
34506                                                                          ; ship, so set a counter in Y, starting from 0, which we
34507                                                                          ; will increment by 4 each loop to step through the
34508                                                                          ; four bytes of data for each face
34509               
34510               LL86:
34511                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this face into A, so:
     **** ****     > LD_IND_Y_IDX
0001 E092 D820  42        movb @V,@rtmplb
     E094 0022     
     E096 8301     
0002 E098 D020  30        movb @V+1,rtmp
     E09A 0023     
0003 E09C 06CF  14        swpb ry
0004 E09E A00F  18        a    ry,rtmp
0005 E0A0 06CF  14        swpb ry
0006 E0A2 D350  26        movb *rtmp,RA
                   < elite.a99
34512                                                                          ;
34513                                                                          ; A = %xyz vvvvv, where:
34514                                                                          ;
34515                                                                          ; * Bits 0-4 = visibility distance, beyond which the
34516                                                                          ; face is always shown
34517                                                                          ;
34518                                                                          ; * Bits 7-5 = the sign bits of normal_x, normal_y
34519                                                                          ; and normal_z
34520               
34521 E0A4 D80D  30        movb ra,@XX12+1                 ; STA XX12+1        ; Store byte #0 in XX12+1, so XX12+1 now has the sign of
     E0A6 0038     
34522                                                                          ; normal_x
34523               
34524 E0A8 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to give the visibility distance
     E0AA 1F00     
34525               
34526 E0AC 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 <= the visibility distance, where XX4 contains
     E0AE 00A7     
34527 E0B0 1812  14        joc  LL87                       ; BCS LL87          ; the ship's z-distance reduced to 0-31 (which we set in
34528                                                                          ; part 2), skip to LL87 as this face is close enough
34529                                                                          ; that we have to test its visibility using the face
34530                                                                          ; normals
34531               
34532                                                                          ; Otherwise this face is within range and is therefore
34533                                                                          ; always shown
34534               
34535 E0B2 D34F  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
34536 E0B4 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
34537 E0B6 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face
34538 E0B8 D38D  18        movb ra,rx                      ; TAX
34539               
34540 E0BA 020D  20        li   ra,>ff*256                 ; LDA #255          ; Set the X-th byte of XX2 to 255 to denote that this
     E0BC FF00     
34541 E0BE 06CE  14        swpb rx                         ;
34542 E0C0 DB8D  38        movb ra,@XX2(rx)                ; STA XX2,X         ; face is visible
     E0C2 00D2     
34543 E0C4 06CE  14        swpb rx                         ;
34544               
34545 E0C6 D34F  18        movb ry,ra                      ; TYA               ; Set Y = Y + 4 to point to the next face
34546                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 E0C8 1701  14        jnc  !
0002 E0CA B347  18        ab   rone,ra
0003               !:
0004 E0CC 022D  22        ai   ra,(>04*256)
     E0CE 0400     
                   < elite.a99
34547 E0D0 D3CD  18        movb ra,ry                      ; TAY
34548               
34549 E0D2 0460  28        b    @LL88                      ; JMP LL88          ; Jump down to LL88 to skip the following, as we don't
     E0D4 E312     
34550                                                                          ; need to test the face normals
34551               
34552               LL87:
34553 E0D6 D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Fetch byte #0 for this face into A
     E0D8 0038     
34554               
34555                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+3 now has the sign
     **** ****     > ASLA
0001 E0DA 024D  22        andi ra,>ff00
     E0DC FF00     
0002 E0DE 0A1D  18        sla  ra,1
                   < elite.a99
34556 E0E0 D80D  30        movb ra,@XX12+3                 ; STA XX12+3        ; of normal_y
     E0E2 003A     
34557               
34558                      .asla                           ; ASL A             ; Shift A left and store it, so XX12+5 now has the sign
     **** ****     > ASLA
0001 E0E4 024D  22        andi ra,>ff00
     E0E6 FF00     
0002 E0E8 0A1D  18        sla  ra,1
                   < elite.a99
34559 E0EA D80D  30        movb ra,@XX12+5                 ; STA XX12+5        ; of normal_z
     E0EC 003C     
34560               
34561 E0EE B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
34562               
34563                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this face and store in XX12, so
     **** ****     > LD_IND_Y_IDX
0001 E0F0 D820  42        movb @V,@rtmplb
     E0F2 0022     
     E0F4 8301     
0002 E0F6 D020  30        movb @V+1,rtmp
     E0F8 0023     
0003 E0FA 06CF  14        swpb ry
0004 E0FC A00F  18        a    ry,rtmp
0005 E0FE 06CF  14        swpb ry
0006 E100 D350  26        movb *rtmp,RA
                   < elite.a99
34564 E102 D80D  30        movb ra,@XX12                   ; STA XX12          ; XX12 = normal_x
     E104 0037     
34565               
34566 E106 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
34567               
34568                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this face and store in XX12+2, so
     **** ****     > LD_IND_Y_IDX
0001 E108 D820  42        movb @V,@rtmplb
     E10A 0022     
     E10C 8301     
0002 E10E D020  30        movb @V+1,rtmp
     E110 0023     
0003 E112 06CF  14        swpb ry
0004 E114 A00F  18        a    ry,rtmp
0005 E116 06CF  14        swpb ry
0006 E118 D350  26        movb *rtmp,RA
                   < elite.a99
34569 E11A D80D  30        movb ra,@XX12+2                 ; STA XX12+2        ; XX12+2 = normal_y
     E11C 0039     
34570               
34571 E11E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
34572               
34573                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this face and store in XX12+4, so
     **** ****     > LD_IND_Y_IDX
0001 E120 D820  42        movb @V,@rtmplb
     E122 0022     
     E124 8301     
0002 E126 D020  30        movb @V+1,rtmp
     E128 0023     
0003 E12A 06CF  14        swpb ry
0004 E12C A00F  18        a    ry,rtmp
0005 E12E 06CF  14        swpb ry
0006 E130 D350  26        movb *rtmp,RA
                   < elite.a99
34574 E132 D80D  30        movb ra,@XX12+4                 ; STA XX12+4        ; XX12+4 = normal_z
     E134 003B     
34575               
34576                                                                          ; So we now have:
34577                                                                          ;
34578                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
34579                                                                          ;
34580                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
34581                                                                          ;
34582                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
34583               
34584 E136 D3A0  30        movb @XX17,rx                   ; LDX XX17          ; If XX17 < 4 then jump to LL92, otherwise we stored a
     E138 0095     
34585 E13A 028E  22        ci   rx,>04*256                 ; CPX #4            ; larger scale factor above
     E13C 0400     
34586 E13E 172B  14        jnc  LL92                       ; BCC LL92
34587               
34588               LL143:
34589 E140 D360  30        movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = XX18(2 0)
     E142 007E     
34590 E144 D80D  30        movb ra,@XX15                   ; STA XX15          ; = dot_sidev
     E146 0031     
34591 E148 D360  30        movb @XX18+2,ra                 ; LDA XX18+2
     E14A 0080     
34592 E14C D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E14E 0032     
34593               
34594 E150 D360  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = XX18(5 3)
     E152 0081     
34595 E154 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; = dot_roofv
     E156 0033     
34596 E158 D360  30        movb @XX18+5,ra                 ; LDA XX18+5
     E15A 0083     
34597 E15C D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E15E 0034     
34598               
34599 E160 D360  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15(5 4) = XX18(8 6)
     E162 0084     
34600 E164 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; = dot_nosev
     E166 0035     
34601 E168 D360  30        movb @XX18+8,ra                 ; LDA XX18+8
     E16A 0086     
34602 E16C D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     E16E 0036     
34603               
34604 E170 0460  28        b    @LL89                      ; JMP LL89          ; Jump down to LL89
     E172 E25A     
34605               
34606               ovflw_:
34607                                                                          ; If we get here then the addition below overflowed, so
34608                                                                          ; we halve the dot products and normal vector
34609                      .lsr @XX18                      ; LSR XX18          ; Divide dot_sidev_lo by 2, so dot_sidev = dot_sidev / 2
     **** ****     > LSR
0001 E174 D020  30        movb @XX18,rtmp
     E176 007E     
0002 E178 0910  18        srl  rtmp,1
0003 E17A D800  30        movb rtmp,@XX18
     E17C 007E     
                   < elite.a99
34610               
34611                      .lsr @XX18+6                    ; LSR XX18+6        ; Divide dot_nosev_lo by 2, so dot_nosev = dot_nosev / 2
     **** ****     > LSR
0001 E17E D020  30        movb @XX18+6,rtmp
     E180 0084     
0002 E182 0910  18        srl  rtmp,1
0003 E184 D800  30        movb rtmp,@XX18+6
     E186 0084     
                   < elite.a99
34612               
34613                      .lsr @XX18+3                    ; LSR XX18+3        ; Divide dot_roofv_lo by 2, so dot_roofv = dot_roofv / 2
     **** ****     > LSR
0001 E188 D020  30        movb @XX18+3,rtmp
     E18A 0081     
0002 E18C 0910  18        srl  rtmp,1
0003 E18E D800  30        movb rtmp,@XX18+3
     E190 0081     
                   < elite.a99
34614               
34615 E192 020E  20        li   rx,>01*256                 ; LDX #1            ; Set X = 1 so when we fall through into LL92, we divide
     E194 0100     
34616                                                                          ; the normal vector by 2 as well
34617               
34618               LL92:
34619                                                                          ; We jump here from above with the scale factor in X,
34620                                                                          ; and now we apply it by scaling the normal vector down
34621                                                                          ; by a factor of 2^X (i.e. divide by 2^X)
34622 E196 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set XX15 = normal_x
     E198 0037     
34623 E19A D80D  30        movb ra,@XX15                   ; STA XX15
     E19C 0031     
34624               
34625 E19E D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX15+2 = normal_y
     E1A0 0039     
34626 E1A2 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E1A4 0033     
34627               
34628 E1A6 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = normal_z
     E1A8 003B     
34629               
34630               LL93:
34631 E1AA 7387  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
34632               
34633 E1AC 110D  14        jlt  LL94                       ; BMI LL94          ; If X was 0 before the decrement, there is no scaling
34634                                                                          ; to do, so jump to LL94 to exit the loop
34635               
34636                      .lsr @XX15                      ; LSR XX15          ; Set XX15 = XX15 / 2
     **** ****     > LSR
0001 E1AE D020  30        movb @XX15,rtmp
     E1B0 0031     
0002 E1B2 0910  18        srl  rtmp,1
0003 E1B4 D800  30        movb rtmp,@XX15
     E1B6 0031     
                   < elite.a99
34637                                                                          ; = normal_x / 2
34638               
34639                      .lsr @XX15+2                    ; LSR XX15+2        ; Set XX15+2 = XX15+2 / 2
     **** ****     > LSR
0001 E1B8 D020  30        movb @XX15+2,rtmp
     E1BA 0033     
0002 E1BC 0910  18        srl  rtmp,1
0003 E1BE D800  30        movb rtmp,@XX15+2
     E1C0 0033     
                   < elite.a99
34640                                                                          ; = normal_y / 2
34641               
34642 E1C2 091D  18        srl  ra,1                       ; LSR A             ; Set A = A / 2
34643                                                                          ; = normal_z / 2
34644               
34645 E1C4 7387  18        sb   rone,rx                    ; DEX               ; Decrement the scale factor in X
34646               
34647 E1C6 15F2  14        jgt  LL93+3                     ; BPL LL93+3        ; If we have more scaling to do, loop back up to the
34648                                                                          ; first LSR above until the normal vector is scaled down
34649               
34650               LL94:
34651 E1C8 D80D  30        movb ra,@R                      ; STA R             ; Set R = normal_z
     E1CA 0091     
34652               
34653 E1CC D360  30        movb @XX12+5,ra                 ; LDA XX12+5        ; Set S = normal_z_sign
     E1CE 003C     
34654 E1D0 D80D  30        movb ra,@S                      ; STA S
     E1D2 0092     
34655               
34656 E1D4 D360  30        movb @XX18+6,ra                 ; LDA XX18+6        ; Set Q = dot_nosev_lo
     E1D6 0084     
34657 E1D8 D80D  30        movb ra,@Q                      ; STA Q
     E1DA 0090     
34658               
34659 E1DC D360  30        movb @XX18+8,ra                 ; LDA XX18+8        ; Set A = dot_nosev_sign
     E1DE 0086     
34660               
34661 E1E0 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     E1E2 DB82     
34662 E1E4 06A0  32        bl   @jsr                       ;
     E1E6 FE28     
34663                                                                          ; = normal_z + dot_nosev
34664                                                                          ;
34665                                                                          ; setting the sign of the result in S
34666               
34667 E1E8 18C5  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
34668                                                                          ; both the normal vector and dot products by 2 and try
34669                                                                          ; again
34670               
34671 E1EA D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; Set XX15(5 4) = (S A)
     E1EC 0035     
34672 E1EE D360  30        movb @S,ra                      ; LDA S             ; = normal_z + dot_nosev
     E1F0 0092     
34673 E1F2 D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     E1F4 0036     
34674               
34675 E1F6 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set R = normal_x
     E1F8 0031     
34676 E1FA D80D  30        movb ra,@R                      ; STA R
     E1FC 0091     
34677               
34678 E1FE D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = normal_x_sign
     E200 0038     
34679 E202 D80D  30        movb ra,@S                      ; STA S
     E204 0092     
34680               
34681 E206 D360  30        movb @XX18,ra                   ; LDA XX18          ; Set Q = dot_sidev_lo
     E208 007E     
34682 E20A D80D  30        movb ra,@Q                      ; STA Q
     E20C 0090     
34683               
34684 E20E D360  30        movb @XX18+2,ra                 ; LDA XX18+2        ; Set A = dot_sidev_sign
     E210 0080     
34685               
34686 E212 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     E214 DB82     
34687 E216 06A0  32        bl   @jsr                       ;
     E218 FE28     
34688                                                                          ; = normal_x + dot_sidev
34689                                                                          ;
34690                                                                          ; setting the sign of the result in S
34691               
34692 E21A 18AC  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
34693                                                                          ; both the normal vector and dot products by 2 and try
34694                                                                          ; again
34695               
34696 E21C D80D  30        movb ra,@XX15                   ; STA XX15          ; Set XX15(1 0) = (S A)
     E21E 0031     
34697 E220 D360  30        movb @S,ra                      ; LDA S             ; = normal_x + dot_sidev
     E222 0092     
34698 E224 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E226 0032     
34699               
34700 E228 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = normal_y
     E22A 0033     
34701 E22C D80D  30        movb ra,@R                      ; STA R
     E22E 0091     
34702               
34703 E230 D360  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set S = normal_y_sign
     E232 003A     
34704 E234 D80D  30        movb ra,@S                      ; STA S
     E236 0092     
34705               
34706 E238 D360  30        movb @XX18+3,ra                 ; LDA XX18+3        ; Set Q = dot_roofv_lo
     E23A 0081     
34707 E23C D80D  30        movb ra,@Q                      ; STA Q
     E23E 0090     
34708               
34709 E240 D360  30        movb @XX18+5,ra                 ; LDA XX18+5        ; Set A = dot_roofv_sign
     E242 0083     
34710               
34711 E244 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     E246 DB82     
34712 E248 06A0  32        bl   @jsr                       ;
     E24A FE28     
34713                                                                          ; = normal_y + dot_roofv
34714               
34715 E24C 1893  14        joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
34716                                                                          ; both the normal vector and dot products by 2 and try
34717                                                                          ; again
34718               
34719 E24E D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15(3 2) = (S A)
     E250 0033     
34720 E252 D360  30        movb @S,ra                      ; LDA S             ; = normal_y + dot_roofv
     E254 0092     
34721 E256 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E258 0034     
34722               
34723               LL89:
34724                                                                          ; When we get here, we have set up the following:
34725                                                                          ;
34726                                                                          ; XX15(1 0) = normal_x + dot_sidev
34727                                                                          ; = normal_x + [x y z] . sidev
34728                                                                          ;
34729                                                                          ; XX15(3 2) = normal_y + dot_roofv
34730                                                                          ; = normal_y + [x y z] . roofv
34731                                                                          ;
34732                                                                          ; XX15(5 4) = normal_z + dot_nosev
34733                                                                          ; = normal_z + [x y z] . nosev
34734                                                                          ;
34735                                                                          ; and:
34736                                                                          ;
34737                                                                          ; XX12(1 0) = (normal_x_sign normal_x)
34738                                                                          ;
34739                                                                          ; XX12(3 2) = (normal_y_sign normal_y)
34740                                                                          ;
34741                                                                          ; XX12(5 4) = (normal_z_sign normal_z)
34742                                                                          ;
34743                                                                          ; We now calculate the dot product XX12 . XX15 to tell
34744                                                                          ; us whether or not this face is visible
34745 E25A D360  30        movb @XX12,ra                   ; LDA XX12          ; Set Q = XX12
     E25C 0037     
34746 E25E D80D  30        movb ra,@Q                      ; STA Q
     E260 0090     
34747               
34748 E262 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = XX15
     E264 0031     
34749               
34750 E266 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set T = A * Q / 256
     E268 46D4     
34751 E26A 06A0  32        bl   @jsr                       ;
     E26C FE28     
34752 E26E D80D  30        movb ra,@T                      ; STA T             ; = XX15 * XX12 / 256
     E270 00D1     
34753               
34754 E272 D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = sign of XX15(1 0) * XX12(1 0), so:
     E274 0038     
34755                      .eor @XX15+1                    ; EOR XX15+1        ;
     **** ****     > EOR
0001 E276 D020  30        movb @XX15+1,rtmp
     E278 0032     
0002 E27A 2B40  18        xor  rtmp,ra
                   < elite.a99
34756 E27C D80D  30        movb ra,@S                      ; STA S             ; (S T) = XX15(1 0) * XX12(1 0) / 256
     E27E 0092     
34757               
34758 E280 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set Q = XX12+2
     E282 0039     
34759 E284 D80D  30        movb ra,@Q                      ; STA Q
     E286 0090     
34760               
34761 E288 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2
     E28A 0033     
34762               
34763 E28C 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     E28E 46D4     
34764 E290 06A0  32        bl   @jsr                       ;
     E292 FE28     
34765 E294 D80D  30        movb ra,@Q                      ; STA Q             ; = XX15+2 * XX12+2 / 256
     E296 0090     
34766               
34767 E298 D360  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     E29A 00D1     
34768 E29C D80D  30        movb ra,@R                      ; STA R             ;
     E29E 0091     
34769                                                                          ; (S R) = XX15(1 0) * XX12(1 0) / 256
34770               
34771 E2A0 D360  30        movb @XX12+3,ra                 ; LDA XX12+3        ; Set A = sign of XX15+3 * XX12+3, so:
     E2A2 003A     
34772                      .eor @XX15+3                    ; EOR XX15+3        ;
     **** ****     > EOR
0001 E2A4 D020  30        movb @XX15+3,rtmp
     E2A6 0034     
0002 E2A8 2B40  18        xor  rtmp,ra
                   < elite.a99
34773                                                                          ; (A Q) = XX15(3 2) * XX12(3 2) / 256
34774               
34775 E2AA 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S T) = (S R) + (A Q)
     E2AC DB82     
34776 E2AE 06A0  32        bl   @jsr                       ;
     E2B0 FE28     
34777 E2B2 D80D  30        movb ra,@T                      ; STA T             ; =   XX15(1 0) * XX12(1 0) / 256
     E2B4 00D1     
34778                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34779               
34780 E2B6 D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = XX12+4
     E2B8 003B     
34781 E2BA D80D  30        movb ra,@Q                      ; STA Q
     E2BC 0090     
34782               
34783 E2BE D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set A = XX15+4
     E2C0 0035     
34784               
34785 E2C2 0200  20        li   rtmp,FMLTU                 ; JSR FMLTU         ; Set Q = A * Q
     E2C4 46D4     
34786 E2C6 06A0  32        bl   @jsr                       ;
     E2C8 FE28     
34787 E2CA D80D  30        movb ra,@Q                      ; STA Q             ; = XX15+4 * XX12+4 / 256
     E2CC 0090     
34788               
34789 E2CE D360  30        movb @T,ra                      ; LDA T             ; Set T = R, so now:
     E2D0 00D1     
34790 E2D2 D80D  30        movb ra,@R                      ; STA R             ;
     E2D4 0091     
34791                                                                          ; (S R) =   XX15(1 0) * XX12(1 0) / 256
34792                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34793               
34794 E2D6 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = sign of XX15+5 * XX12+5, so:
     E2D8 0036     
34795                      .eor @XX12+5                    ; EOR XX12+5        ;
     **** ****     > EOR
0001 E2DA D020  30        movb @XX12+5,rtmp
     E2DC 003C     
0002 E2DE 2B40  18        xor  rtmp,ra
                   < elite.a99
34796                                                                          ; (A Q) = XX15(5 4) * XX12(5 4) / 256
34797               
34798 E2E0 0200  20        li   rtmp,LL38                  ; JSR LL38          ; Set (S A) = (S R) + (A Q)
     E2E2 DB82     
34799 E2E4 06A0  32        bl   @jsr                       ;
     E2E6 FE28     
34800                                                                          ; =   XX15(1 0) * XX12(1 0) / 256
34801                                                                          ; + XX15(3 2) * XX12(3 2) / 256
34802                                                                          ; + XX15(5 4) * XX12(5 4) / 256
34803               
34804                      .pha                            ; PHA               ; Push the result A onto the stack, so the stack now
     **** ****     > PHA
0001 E2E8 D68D  30        movb ra,*rsp
0002 E2EA 060A  14        dec  rsp
                   < elite.a99
34805                                                                          ; contains the dot product XX12 . XX15
34806               
34807 E2EC D34F  18        movb ry,ra                      ; TYA               ; Set X = Y / 4
34808 E2EE 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
34809 E2F0 091D  18        srl  ra,1                       ; LSR A             ; = the number of this face
34810 E2F2 D38D  18        movb ra,rx                      ; TAX
34811               
34812                      .pla                            ; PLA               ; Pull the dot product off the stack into A
     **** ****     > PLA
0001 E2F4 058A  14        inc  rsp
0002 E2F6 D35A  26        movb *rsp,ra
                   < elite.a99
34813               
34814                      .bit @S                         ; BIT S             ; If bit 7 of S is set, i.e. the dot product is
     **** ****     > BIT
0001 E2F8 D020  30        movb @S,rtmp
     E2FA 0092     
0002 E2FC 0540  14        inv  rtmp
0003 E2FE D047  18        movb rone,rtmp2
0004 E300 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
34815 E302 1102  14        jlt  B112                       ; BMI B112          ; negative, then this face is visible as its normal is
34816                                                                          ; pointing towards us, so skip the following instruction
34817               
34818 E304 020D  20        li   ra,>00*256                 ; LDA #0            ; Otherwise the face is not visible, so set A = 0 so we
     E306 0000     
34819                                                                          ; can store this to mean "not visible"
34820               
34821               B112:
34822 E308 06CE  14        swpb rx                         ;
34823 E30A DB8D  38        movb ra,@XX2(rx)                ; STA XX2,X         ; Store the face's visibility in the X-th byte of XX2
     E30C 00D2     
34824 E30E 06CE  14        swpb rx                         ;
34825               
34826 E310 B3C7  18        ab   rone,ry                    ; INY               ; Above we incremented Y to point to byte #3, so this
34827                                                                          ; increments Y to point to byte #4, i.e. byte #0 of the
34828                                                                          ; next face
34829               
34830               LL88:
34831 E312 93E0  30        cb   @XX20,ry                   ; CPY XX20          ; If Y >= XX20, the number of faces * 4, jump down to
     E314 00A8     
34832 E316 1802  14        joc  LL42                       ; BCS LL42          ; LL42 to move on to the
34833               
34834 E318 0460  28        b    @LL86                      ; JMP LL86          ; Otherwise loop back to LL86 to work out the visibility
     E31A E092     
34835                                                                          ; of the next face
34836               
34837               * ******************************************************************************
34838               *
34839               * Name: LL9 (Part 6 of 12)
34840               * Type: Subroutine
34841               * Category: Drawing ships
34842               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
34843               * Deep dive: Drawing ships
34844               * Calculating vertex coordinates
34845               *
34846               * ------------------------------------------------------------------------------
34847               *
34848               * This section calculates the visibility of each of the ship's vertices, and for
34849               * those that are visible, it starts the process of calculating the screen
34850               * coordinates of each vertex
34851               *
34852               * ******************************************************************************
34853               
34854               LL42:
34855                                                                          ; The first task is to set up the inverse matrix, ready
34856                                                                          ; for us to send to the dot product routine at LL51.
34857                                                                          ; Back up in part 3, we set up the following variables:
34858                                                                          ;
34859                                                                          ; * XX16(1 0) = sidev_x
34860                                                                          ; * XX16(3 2) = sidev_y
34861                                                                          ; * XX16(5 4) = sidev_z
34862                                                                          ;
34863                                                                          ; * XX16(7 6) = roofv_x
34864                                                                          ; * XX16(9 8) = roofv_y
34865                                                                          ; * XX16(11 10) = roofv_z
34866                                                                          ;
34867                                                                          ; * XX16(13 12) = nosev_x
34868                                                                          ; * XX16(15 14) = nosev_y
34869                                                                          ; * XX16(17 16) = nosev_z
34870                                                                          ;
34871                                                                          ; and we then scaled the vectors to give the following:
34872                                                                          ;
34873                                                                          ; * XX16   = scaled |sidev_x|
34874                                                                          ; * XX16+2 = scaled |sidev_y|
34875                                                                          ; * XX16+4 = scaled |sidev_z|
34876                                                                          ;
34877                                                                          ; * XX16+6  = scaled |roofv_x|
34878                                                                          ; * XX16+8  = scaled |roofv_y|
34879                                                                          ; * XX16+10 = scaled |roofv_z|
34880                                                                          ;
34881                                                                          ; * XX16+12 = scaled |nosev_x|
34882                                                                          ; * XX16+14 = scaled |nosev_y|
34883                                                                          ; * XX16+16 = scaled |nosev_z|
34884                                                                          ;
34885                                                                          ; We now need to rearrange these locations so they
34886                                                                          ; effectively transpose the matrix into its inverse
34887 E31C D3E0  30        movb @XX16+2,ry                 ; LDY XX16+2        ; Set XX16+2 = XX16+6 = scaled |roofv_x|
     E31E 000B     
34888 E320 D3A0  30        movb @XX16+3,rx                 ; LDX XX16+3        ; Set XX16+3 = XX16+7 = roofv_x_hi
     E322 000C     
34889 E324 D360  30        movb @XX16+6,ra                 ; LDA XX16+6        ; Set XX16+6 = XX16+2 = scaled |sidev_y|
     E326 000F     
34890 E328 D80D  30        movb ra,@XX16+2                 ; STA XX16+2        ; Set XX16+7 = XX16+3 = sidev_y_hi
     E32A 000B     
34891 E32C D360  30        movb @XX16+7,ra                 ; LDA XX16+7
     E32E 0010     
34892 E330 D80D  30        movb ra,@XX16+3                 ; STA XX16+3
     E332 000C     
34893 E334 D80F  30        movb ry,@XX16+6                 ; STY XX16+6
     E336 000F     
34894 E338 D80E  30        movb rx,@XX16+7                 ; STX XX16+7
     E33A 0010     
34895               
34896 E33C D3E0  30        movb @XX16+4,ry                 ; LDY XX16+4        ; Set XX16+4 = XX16+12 = scaled |nosev_x|
     E33E 000D     
34897 E340 D3A0  30        movb @XX16+5,rx                 ; LDX XX16+5        ; Set XX16+5 = XX16+13 = nosev_x_hi
     E342 000E     
34898 E344 D360  30        movb @XX16+12,ra                ; LDA XX16+12       ; Set XX16+12 = XX16+4 = scaled |sidev_z|
     E346 0015     
34899 E348 D80D  30        movb ra,@XX16+4                 ; STA XX16+4        ; Set XX16+13 = XX16+5 = sidev_z_hi
     E34A 000D     
34900 E34C D360  30        movb @XX16+13,ra                ; LDA XX16+13
     E34E 0016     
34901 E350 D80D  30        movb ra,@XX16+5                 ; STA XX16+5
     E352 000E     
34902 E354 D80F  30        movb ry,@XX16+12                ; STY XX16+12
     E356 0015     
34903 E358 D80E  30        movb rx,@XX16+13                ; STX XX16+13
     E35A 0016     
34904               
34905 E35C D3E0  30        movb @XX16+10,ry                ; LDY XX16+10       ; Set XX16+10 = XX16+14 = scaled |nosev_y|
     E35E 0013     
34906 E360 D3A0  30        movb @XX16+11,rx                ; LDX XX16+11       ; Set XX16+11 = XX16+15 = nosev_y_hi
     E362 0014     
34907 E364 D360  30        movb @XX16+14,ra                ; LDA XX16+14       ; Set XX16+14 = XX16+10 = scaled |roofv_z|
     E366 0017     
34908 E368 D80D  30        movb ra,@XX16+10                ; STA XX16+10       ; Set XX16+15 = XX16+11 = roofv_z
     E36A 0013     
34909 E36C D360  30        movb @XX16+15,ra                ; LDA XX16+15
     E36E 0018     
34910 E370 D80D  30        movb ra,@XX16+11                ; STA XX16+11
     E372 0014     
34911 E374 D80F  30        movb ry,@XX16+14                ; STY XX16+14
     E376 0017     
34912 E378 D80E  30        movb rx,@XX16+15                ; STX XX16+15
     E37A 0018     
34913               
34914                                                                          ; So now we have the following sign-magnitude variables
34915                                                                          ; containing parts of the scaled orientation vectors:
34916                                                                          ;
34917                                                                          ; XX16(1 0)   = scaled sidev_x
34918                                                                          ; XX16(3 2)   = scaled roofv_x
34919                                                                          ; XX16(5 4)   = scaled nosev_x
34920                                                                          ;
34921                                                                          ; XX16(7 6)   = scaled sidev_y
34922                                                                          ; XX16(9 8)   = scaled roofv_y
34923                                                                          ; XX16(11 10) = scaled nosev_y
34924                                                                          ;
34925                                                                          ; XX16(13 12) = scaled sidev_z
34926                                                                          ; XX16(15 14) = scaled roofv_z
34927                                                                          ; XX16(17 16) = scaled nosev_z
34928                                                                          ;
34929                                                                          ; which is what we want, as the various vectors are now
34930                                                                          ; arranged so we can use LL51 to multiply by the
34931                                                                          ; transpose (i.e. the inverse of the matrix)
34932               
34933 E37C 020F  20        li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 of the ship's blueprint, which is the
     E37E 0800     
34934                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of vertices * 8, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 E380 D820  42        movb @XX0,@rtmplb
     E382 001E     
     E384 8301     
0002 E386 D020  30        movb @XX0+1,rtmp
     E388 001F     
0003 E38A 06CF  14        swpb ry
0004 E38C A00F  18        a    ry,rtmp
0005 E38E 06CF  14        swpb ry
0006 E390 D350  26        movb *rtmp,RA
                   < elite.a99
34935 E392 D80D  30        movb ra,@XX20                   ; STA XX20
     E394 00A8     
34936               
34937                                                                          ; We now set V(1 0) = XX0(1 0) + 20, so V(1 0) points
34938                                                                          ; to byte #20 of the ship's blueprint, which is always
34939                                                                          ; where the vertex data starts (i.e. just after the 20
34940                                                                          ; byte block that define the ship's characteristics)
34941               
34942 E396 D360  30        movb @XX0,ra                    ; LDA XX0           ; We start with the low bytes
     E398 001E     
34943                      .clc                            ; CLC
     **** ****     > CLC
0001 E39A 0A16  18        sla  rzero,1
                   < elite.a99
34944                      .adi (>14*256)                  ; ADC #20
     **** ****     > ADI
0001 E39C 1701  14        jnc  !
0002 E39E B347  18        ab   rone,ra
0003               !:
0004 E3A0 022D  22        ai   ra,(>14*256)
     E3A2 1400     
                   < elite.a99
34945 E3A4 D80D  30        movb ra,@V                      ; STA V
     E3A6 0022     
34946               
34947 E3A8 D360  30        movb @XX0+1,ra                  ; LDA XX0+1         ; And then do the high bytes
     E3AA 001F     
34948                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 E3AC 1701  14        jnc  !
0002 E3AE B347  18        ab   rone,ra
0003               !:
0004 E3B0 022D  22        ai   ra,(>00*256)
     E3B2 0000     
                   < elite.a99
34949 E3B4 D80D  30        movb ra,@V+1                    ; STA V+1
     E3B6 0023     
34950               
34951 E3B8 020F  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the vertices, using
     E3BA 0000     
34952                                                                          ; Y as a counter. There are six data bytes for each
34953                                                                          ; vertex, so we will increment Y by 6 for each iteration
34954                                                                          ; so it can act as an offset from V(1 0) to the current
34955                                                                          ; vertex's data
34956               
34957 E3BC D80F  30        movb ry,@CNT                    ; STY CNT           ; Set CNT = 0, which we will use as a pointer to the
     E3BE 00A4     
34958                                                                          ; heap at XX3, starting it at zero so the heap starts
34959                                                                          ; out empty
34960               
34961               LL48:
34962 E3C0 D80F  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = Y, so XX17 now contains the offset of the
     E3C2 0095     
34963                                                                          ; current vertex's data
34964               
34965                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this vertex into XX15, so:
     **** ****     > LD_IND_Y_IDX
0001 E3C4 D820  42        movb @V,@rtmplb
     E3C6 0022     
     E3C8 8301     
0002 E3CA D020  30        movb @V+1,rtmp
     E3CC 0023     
0003 E3CE 06CF  14        swpb ry
0004 E3D0 A00F  18        a    ry,rtmp
0005 E3D2 06CF  14        swpb ry
0006 E3D4 D350  26        movb *rtmp,RA
                   < elite.a99
34966 E3D6 D80D  30        movb ra,@XX15                   ; STA XX15          ;
     E3D8 0031     
34967                                                                          ; XX15 = magnitude of the vertex's x-coordinate
34968               
34969 E3DA B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
34970               
34971                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this vertex into XX15+2, so:
     **** ****     > LD_IND_Y_IDX
0001 E3DC D820  42        movb @V,@rtmplb
     E3DE 0022     
     E3E0 8301     
0002 E3E2 D020  30        movb @V+1,rtmp
     E3E4 0023     
0003 E3E6 06CF  14        swpb ry
0004 E3E8 A00F  18        a    ry,rtmp
0005 E3EA 06CF  14        swpb ry
0006 E3EC D350  26        movb *rtmp,RA
                   < elite.a99
34972 E3EE D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ;
     E3F0 0033     
34973                                                                          ; XX15+2 = magnitude of the vertex's y-coordinate
34974               
34975 E3F2 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
34976               
34977                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this vertex into XX15+4, so:
     **** ****     > LD_IND_Y_IDX
0001 E3F4 D820  42        movb @V,@rtmplb
     E3F6 0022     
     E3F8 8301     
0002 E3FA D020  30        movb @V+1,rtmp
     E3FC 0023     
0003 E3FE 06CF  14        swpb ry
0004 E400 A00F  18        a    ry,rtmp
0005 E402 06CF  14        swpb ry
0006 E404 D350  26        movb *rtmp,RA
                   < elite.a99
34978 E406 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ;
     E408 0035     
34979                                                                          ; XX15+4 = magnitude of the vertex's z-coordinate
34980               
34981 E40A B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
34982               
34983                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this vertex into T, so:
     **** ****     > LD_IND_Y_IDX
0001 E40C D820  42        movb @V,@rtmplb
     E40E 0022     
     E410 8301     
0002 E412 D020  30        movb @V+1,rtmp
     E414 0023     
0003 E416 06CF  14        swpb ry
0004 E418 A00F  18        a    ry,rtmp
0005 E41A 06CF  14        swpb ry
0006 E41C D350  26        movb *rtmp,RA
                   < elite.a99
34984 E41E D80D  30        movb ra,@T                      ; STA T             ;
     E420 00D1     
34985                                                                          ; T = %xyz vvvvv, where:
34986                                                                          ;
34987                                                                          ; * Bits 0-4 = visibility distance, beyond which the
34988                                                                          ; vertex is not shown
34989                                                                          ;
34990                                                                          ; * Bits 7-5 = the sign bits of x, y and z
34991               
34992 E422 024D  22        andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to get the visibility distance
     E424 1F00     
34993               
34994 E426 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     E428 00A7     
34995 E42A 1740  14        jnc  LL49-3                     ; BCC LL49-3        ; the ship's z-distance reduced to 0-31 (which we set in
34996                                                                          ; part 2), then this vertex is too far away to be
34997                                                                          ; visible, so jump down to LL50 (via the JMP instruction
34998                                                                          ; in LL49-3) to move on to the next vertex
34999               
35000 E42C B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #4
35001               
35002                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #4 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 E42E D820  42        movb @V,@rtmplb
     E430 0022     
     E432 8301     
0002 E434 D020  30        movb @V+1,rtmp
     E436 0023     
0003 E438 06CF  14        swpb ry
0004 E43A A00F  18        a    ry,rtmp
0005 E43C 06CF  14        swpb ry
0006 E43E D350  26        movb *rtmp,RA
                   < elite.a99
35003 E440 D80D  30        movb ra,@P                      ; STA P             ;
     E442 001B     
35004                                                                          ; P = %ffff ffff, where:
35005                                                                          ;
35006                                                                          ; * Bits 0-3 = the number of face 1
35007                                                                          ;
35008                                                                          ; * Bits 4-7 = the number of face 2
35009               
35010 E444 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     E446 0F00     
35011 E448 D38D  18        movb ra,rx                      ; TAX
35012               
35013 E44A 06CE  14        swpb rx                         ;
35014 E44C D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     E44E 00D2     
35015 E450 06CE  14        swpb rx                         ;
35016 E452 162E  14        jne  LL49                       ; BNE LL49          ; face 1 is visible, so jump to LL49
35017               
35018 E454 D360  30        movb @P,ra                      ; LDA P             ; Fetch byte #4 for this vertex into A
     E456 001B     
35019               
35020 E458 091D  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
35021 E45A 091D  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
35022 E45C 091D  18        srl  ra,1                       ; LSR A
35023 E45E 091D  18        srl  ra,1                       ; LSR A
35024 E460 D38D  18        movb ra,rx                      ; TAX
35025               
35026 E462 06CE  14        swpb rx                         ;
35027 E464 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     E466 00D2     
35028 E468 06CE  14        swpb rx                         ;
35029 E46A 1622  14        jne  LL49                       ; BNE LL49          ; face 2 is visible, so jump to LL49
35030               
35031 E46C B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #5
35032               
35033                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #5 for this vertex into P, so:
     **** ****     > LD_IND_Y_IDX
0001 E46E D820  42        movb @V,@rtmplb
     E470 0022     
     E472 8301     
0002 E474 D020  30        movb @V+1,rtmp
     E476 0023     
0003 E478 06CF  14        swpb ry
0004 E47A A00F  18        a    ry,rtmp
0005 E47C 06CF  14        swpb ry
0006 E47E D350  26        movb *rtmp,RA
                   < elite.a99
35034 E480 D80D  30        movb ra,@P                      ; STA P             ;
     E482 001B     
35035                                                                          ; P = %ffff ffff, where:
35036                                                                          ;
35037                                                                          ; * Bits 0-3 = the number of face 3
35038                                                                          ;
35039                                                                          ; * Bits 4-7 = the number of face 4
35040               
35041 E484 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     E486 0F00     
35042 E488 D38D  18        movb ra,rx                      ; TAX
35043               
35044 E48A 06CE  14        swpb rx                         ;
35045 E48C D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     E48E 00D2     
35046 E490 06CE  14        swpb rx                         ;
35047 E492 160E  14        jne  LL49                       ; BNE LL49          ; face 3 is visible, so jump to LL49
35048               
35049 E494 D360  30        movb @P,ra                      ; LDA P             ; Fetch byte #5 for this vertex into A
     E496 001B     
35050               
35051 E498 091D  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 4
35052 E49A 091D  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
35053 E49C 091D  18        srl  ra,1                       ; LSR A
35054 E49E 091D  18        srl  ra,1                       ; LSR A
35055 E4A0 D38D  18        movb ra,rx                      ; TAX
35056               
35057 E4A2 06CE  14        swpb rx                         ;
35058 E4A4 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     E4A6 00D2     
35059 E4A8 06CE  14        swpb rx                         ;
35060 E4AA 1602  14        jne  LL49                       ; BNE LL49          ; face 4 is visible, so jump to LL49
35061               
35062 E4AC 0460  28        b    @LL50                      ; JMP LL50          ; If we get here then none of the four faces associated
     E4AE E818     
35063                                                                          ; with this vertex are visible, so this vertex is also
35064                                                                          ; not visible, so jump to LL50 to move on to the next
35065                                                                          ; vertex
35066               
35067               LL49:
35068 E4B0 D360  30        movb @T,ra                      ; LDA T             ; Fetch byte #5 for this vertex into A and store it, so
     E4B2 00D1     
35069 E4B4 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; XX15+1 now has the sign of the vertex's x-coordinate
     E4B6 0032     
35070               
35071                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+3 now has the sign
     **** ****     > ASLA
0001 E4B8 024D  22        andi ra,>ff00
     E4BA FF00     
0002 E4BC 0A1D  18        sla  ra,1
                   < elite.a99
35072 E4BE D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; of the vertex's y-coordinate
     E4C0 0034     
35073               
35074                      .asla                           ; ASL A             ; Shift A left and store it, so XX15+5 now has the sign
     **** ****     > ASLA
0001 E4C2 024D  22        andi ra,>ff00
     E4C4 FF00     
0002 E4C6 0A1D  18        sla  ra,1
                   < elite.a99
35075 E4C8 D80D  30        movb ra,@XX15+5                 ; STA XX15+5        ; of the vertex's z-coordinate
     E4CA 0036     
35076               
35077                                                                          ; By this point we have the following:
35078                                                                          ;
35079                                                                          ; XX15(1 0) = vertex x-coordinate
35080                                                                          ; XX15(3 2) = vertex y-coordinate
35081                                                                          ; XX15(5 4) = vertex z-coordinate
35082                                                                          ;
35083                                                                          ; XX16(1 0)   = scaled sidev_x
35084                                                                          ; XX16(3 2)   = scaled roofv_x
35085                                                                          ; XX16(5 4)   = scaled nosev_x
35086                                                                          ;
35087                                                                          ; XX16(7 6)   = scaled sidev_y
35088                                                                          ; XX16(9 8)   = scaled roofv_y
35089                                                                          ; XX16(11 10) = scaled nosev_y
35090                                                                          ;
35091                                                                          ; XX16(13 12) = scaled sidev_z
35092                                                                          ; XX16(15 14) = scaled roofv_z
35093                                                                          ; XX16(17 16) = scaled nosev_z
35094               
35095 E4CC 0200  20        li   rtmp,LL51                  ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
     E4CE DBDA     
35096 E4D0 06A0  32        bl   @jsr                       ;
     E4D2 FE28     
35097                                                                          ; XX16, as follows:
35098                                                                          ;
35099                                                                          ; XX12(1 0) = [ x y z ] . [ sidev_x roofv_x nosev_x ]
35100                                                                          ;
35101                                                                          ; XX12(3 2) = [ x y z ] . [ sidev_y roofv_y nosev_y ]
35102                                                                          ;
35103                                                                          ; XX12(5 4) = [ x y z ] . [ sidev_z roofv_z nosev_z ]
35104                                                                          ;
35105                                                                          ; XX12 contains the vector from the ship's centre to
35106                                                                          ; the vertex, transformed from the orientation vector
35107                                                                          ; space to the universe orientated around our ship. So
35108                                                                          ; we can refer to this vector below, let's call it
35109                                                                          ; vertv, so:
35110                                                                          ;
35111                                                                          ; vertv_x = [ x y z ] . [ sidev_x roofv_x nosev_x ]
35112                                                                          ;
35113                                                                          ; vertv_y = [ x y z ] . [ sidev_y roofv_y nosev_y ]
35114                                                                          ;
35115                                                                          ; vertv_z = [ x y z ] . [ sidev_z roofv_z nosev_z ]
35116                                                                          ;
35117                                                                          ; To finish the calculation, we now want to calculate:
35118                                                                          ;
35119                                                                          ; vertv + [ x y z ]
35120                                                                          ;
35121                                                                          ; So let's start with the vertv_x + x
35122               
35123 E4D4 D360  30        movb @XX1+2,ra                  ; LDA XX1+2         ; Set A = x_sign of the ship's location
     E4D6 0055     
35124               
35125 E4D8 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 = x_sign
     E4DA 0033     
35126               
35127                      .eor @XX12+1                    ; EOR XX12+1        ; If the sign of x_sign * the sign of vertv_x is
     **** ****     > EOR
0001 E4DC D020  30        movb @XX12+1,rtmp
     E4DE 0038     
0002 E4E0 2B40  18        xor  rtmp,ra
                   < elite.a99
35128 E4E2 1113  14        jlt  LL52                       ; BMI LL52          ; negative (i.e. they have different signs), skip to
35129                                                                          ; LL52
35130               
35131                      .clc                            ; CLC               ; Set XX15(2 1 0) = XX1(2 1 0) + XX12(1 0)
     **** ****     > CLC
0001 E4E4 0A16  18        sla  rzero,1
                   < elite.a99
35132 E4E6 D360  30        movb @XX12,ra                   ; LDA XX12          ; = (x_sign x_hi x_lo) + vertv_x
     E4E8 0037     
35133                      .adc @XX1,ra                    ; ADC XX1           ;
     **** ****     > ADC
0001 E4EA 1701  14        jnc  !
0002 E4EC B347  18        ab   rone,ra
0003               !:
0004 E4EE B360  30        ab   @XX1,ra
     E4F0 0053     
                   < elite.a99
35134 E4F2 D80D  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     E4F4 0031     
35135               
35136 E4F6 D360  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can add 0 here as
     E4F8 0054     
35137                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_x is 0)
     **** ****     > ADI
0001 E4FA 1701  14        jnc  !
0002 E4FC B347  18        ab   rone,ra
0003               !:
0004 E4FE 022D  22        ai   ra,(>00*256)
     E500 0000     
                   < elite.a99
35138 E502 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E504 0032     
35139               
35140 E506 0460  28        b    @LL53                      ; JMP LL53          ; We've added the x-coordinates, so jump to LL53 to do
     E508 E55A     
35141                                                                          ; the y-coordinates
35142               
35143               LL52:
35144                                                                          ; If we get here then x_sign and vertv_x have different
35145                                                                          ; signs, so we need to subtract them to get the result
35146 E50A D360  30        movb @XX1,ra                    ; LDA XX1           ; Set XX15(2 1 0) = XX1(2 1 0) - XX12(1 0)
     E50C 0053     
35147                      .sec                            ; SEC               ; = (x_sign x_hi x_lo) - vertv_x
     **** ****     > SEC
0001 E50E 0A18  18        sla  rmone,1
                   < elite.a99
35148                      .sbc @XX12,ra                   ; SBC XX12          ;
     **** ****     > SBC
0001 E510 1801  14        joc  !
0002 E512 7347  18        sb   rone,ra
0003               !:
0004 E514 7360  30        sb   @XX12,ra
     E516 0037     
                   < elite.a99
35149 E518 D80D  30        movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes
     E51A 0031     
35150               
35151 E51C D360  30        movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can subtract 0 here
     E51E 0054     
35152                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_x is 0)
     **** ****     > SBI
0001 E520 1801  14        joc  !
0002 E522 7347  18        sb   rone,ra
0003               !:
0004 E524 022D  22        ai   ra,-(>00*256)
     E526 0000     
                   < elite.a99
35153 E528 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     E52A 0032     
35154               
35155 E52C 1816  14        joc  LL53                       ; BCS LL53          ; If the subtraction didn't underflow, then the sign of
35156                                                                          ; the result is the same sign as x_sign, and that's what
35157                                                                          ; we want, so we can jump down to LL53 to do the
35158                                                                          ; y-coordinates
35159               
35160                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 E52E 0200  20        li   rtmp,(>FF*256)
     E530 FF00     
0002 E532 2B40  18        xor  rtmp,ra
                   < elite.a99
35161 E534 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; complement, so first we flip the bits of the high byte
     E536 0032     
35162               
35163 E538 020D  20        li   ra,>01*256                 ; LDA #1            ; And then subtract the low byte from 1
     E53A 0100     
35164                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 E53C 1801  14        joc  !
0002 E53E 7347  18        sb   rone,ra
0003               !:
0004 E540 7360  30        sb   @XX15,ra
     E542 0031     
                   < elite.a99
35165 E544 D80D  30        movb ra,@XX15                   ; STA XX15
     E546 0031     
35166               
35167 E548 1701  14        jnc  B113                       ; BCC B113          ; If the above subtraction underflowed then we need to
35168 E54A B347  18        ab   rone,ra                    ; INC XX15+1        ; bump the high byte of the result up by 1
35169               
35170               B113:
35171 E54C D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; And now we flip the sign of the result to get the
     E54E 0033     
35172                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 E550 0200  20        li   rtmp,(>80*256)
     E552 8000     
0002 E554 2B40  18        xor  rtmp,ra
                   < elite.a99
35173 E556 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     E558 0033     
35174               
35175               LL53:
35176                                                                          ; Now for the y-coordinates, vertv_y + y
35177 E55A D360  30        movb @XX1+5,ra                  ; LDA XX1+5         ; Set A = y_sign of the ship's location
     E55C 0058     
35178               
35179 E55E D80D  30        movb ra,@XX15+5                 ; STA XX15+5        ; Set XX15+5 = y_sign
     E560 0036     
35180               
35181                      .eor @XX12+3                    ; EOR XX12+3        ; If the sign of y_sign * the sign of vertv_y is
     **** ****     > EOR
0001 E562 D020  30        movb @XX12+3,rtmp
     E564 003A     
0002 E566 2B40  18        xor  rtmp,ra
                   < elite.a99
35182 E568 1113  14        jlt  LL54                       ; BMI LL54          ; negative (i.e. they have different signs), skip to
35183                                                                          ; LL54
35184               
35185                      .clc                            ; CLC               ; Set XX15(5 4 3) = XX1(5 4 3) + XX12(3 2)
     **** ****     > CLC
0001 E56A 0A16  18        sla  rzero,1
                   < elite.a99
35186 E56C D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; = (y_sign y_hi y_lo) + vertv_y
     E56E 0039     
35187                      .adc @XX1+3,ra                  ; ADC XX1+3         ;
     **** ****     > ADC
0001 E570 1701  14        jnc  !
0002 E572 B347  18        ab   rone,ra
0003               !:
0004 E574 B360  30        ab   @XX1+3,ra
     E576 0056     
                   < elite.a99
35188 E578 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     E57A 0034     
35189               
35190 E57C D360  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can add 0 here as
     E57E 0057     
35191                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 E580 1701  14        jnc  !
0002 E582 B347  18        ab   rone,ra
0003               !:
0004 E584 022D  22        ai   ra,(>00*256)
     E586 0000     
                   < elite.a99
35192 E588 D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     E58A 0035     
35193               
35194 E58C 0460  28        b    @LL55                      ; JMP LL55          ; We've added the y-coordinates, so jump to LL55 to do
     E58E E5E6     
35195                                                                          ; the z-coordinates
35196               
35197               LL54:
35198                                                                          ; If we get here then y_sign and vertv_y have different
35199                                                                          ; signs, so we need to subtract them to get the result
35200 E590 D360  30        movb @XX1+3,ra                  ; LDA XX1+3         ; Set XX15(5 4 3) = XX1(5 4 3) - XX12(3 2)
     E592 0056     
35201                      .sec                            ; SEC               ; = (y_sign y_hi y_lo) - vertv_y
     **** ****     > SEC
0001 E594 0A18  18        sla  rmone,1
                   < elite.a99
35202                      .sbc @XX12+2,ra                 ; SBC XX12+2        ;
     **** ****     > SBC
0001 E596 1801  14        joc  !
0002 E598 7347  18        sb   rone,ra
0003               !:
0004 E59A 7360  30        sb   @XX12+2,ra
     E59C 0039     
                   < elite.a99
35203 E59E D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes
     E5A0 0034     
35204               
35205 E5A2 D360  30        movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can subtract 0 here
     E5A4 0057     
35206                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 E5A6 1801  14        joc  !
0002 E5A8 7347  18        sb   rone,ra
0003               !:
0004 E5AA 022D  22        ai   ra,-(>00*256)
     E5AC 0000     
                   < elite.a99
35207 E5AE D80D  30        movb ra,@XX15+4                 ; STA XX15+4
     E5B0 0035     
35208               
35209 E5B2 1819  14        joc  LL55                       ; BCS LL55          ; If the subtraction didn't underflow, then the sign of
35210                                                                          ; the result is the same sign as y_sign, and that's what
35211                                                                          ; we want, so we can jump down to LL55 to do the
35212                                                                          ; z-coordinates
35213               
35214                      .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
     **** ****     > EOI
0001 E5B4 0200  20        li   rtmp,(>FF*256)
     E5B6 FF00     
0002 E5B8 2B40  18        xor  rtmp,ra
                   < elite.a99
35215 E5BA D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; complement, so first we flip the bits of the high byte
     E5BC 0035     
35216               
35217 E5BE D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then flip the bits of the low byte and add 1
     E5C0 0034     
35218                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 E5C2 0200  20        li   rtmp,(>FF*256)
     E5C4 FF00     
0002 E5C6 2B40  18        xor  rtmp,ra
                   < elite.a99
35219                      .adi (>01*256)                  ; ADC #1
     **** ****     > ADI
0001 E5C8 1701  14        jnc  !
0002 E5CA B347  18        ab   rone,ra
0003               !:
0004 E5CC 022D  22        ai   ra,(>01*256)
     E5CE 0100     
                   < elite.a99
35220 E5D0 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     E5D2 0034     
35221               
35222 E5D4 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; And now we flip the sign of the result to get the
     E5D6 0036     
35223                      .eoi (>80*256)                  ; EOR #%10000000    ; correct result
     **** ****     > EOI
0001 E5D8 0200  20        li   rtmp,(>80*256)
     E5DA 8000     
0002 E5DC 2B40  18        xor  rtmp,ra
                   < elite.a99
35224 E5DE D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     E5E0 0036     
35225               
35226 E5E2 1701  14        jnc  LL55                       ; BCC LL55          ; If the above subtraction underflowed then we need to
35227 E5E4 B347  18        ab   rone,ra                    ; INC XX15+4        ; bump the high byte of the result up by 1
35228               
35229               LL55:
35230                                                                          ; Now for the z-coordinates, vertv_z + z
35231 E5E6 D360  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If vertv_z_hi is negative, jump down to LL56
     E5E8 003C     
35232 E5EA 1155  14        jlt  LL56                       ; BMI LL56
35233               
35234 E5EC D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set (U T) = XX1(7 6) + XX12(5 4)
     E5EE 003B     
35235                      .clc                            ; CLC               ; = (z_hi z_lo) + vertv_z
     **** ****     > CLC
0001 E5F0 0A16  18        sla  rzero,1
                   < elite.a99
35236                      .adc @XX1+6,ra                  ; ADC XX1+6         ;
     **** ****     > ADC
0001 E5F2 1701  14        jnc  !
0002 E5F4 B347  18        ab   rone,ra
0003               !:
0004 E5F6 B360  30        ab   @XX1+6,ra
     E5F8 0059     
                   < elite.a99
35237 E5FA D80D  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     E5FC 00D1     
35238               
35239 E5FE D360  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can add 0 here as
     E600 005A     
35240                      .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
     **** ****     > ADI
0001 E602 1701  14        jnc  !
0002 E604 B347  18        ab   rone,ra
0003               !:
0004 E606 022D  22        ai   ra,(>00*256)
     E608 0000     
                   < elite.a99
35241 E60A D80D  30        movb ra,@U                      ; STA U
     E60C 008F     
35242               
35243 E60E 0460  28        b    @LL57                      ; JMP LL57          ; We've added the z-coordinates, so jump to LL57
     E610 E6D6     
35244               
35245                                                                          ; The adding process is continued in part 7, after a
35246                                                                          ; couple of subroutines that we don't need quite yet
35247               
35248               * ******************************************************************************
35249               *
35250               * Name: LL61
35251               * Type: Subroutine
35252               * Category: Maths (Arithmetic)
35253               * Summary: Calculate (U R) = 256 * A / Q
35254               *
35255               * ------------------------------------------------------------------------------
35256               *
35257               * Calculate the following, where A >= Q:
35258               *
35259               * (U R) = 256 * A / Q
35260               *
35261               * This is a sister routine to LL28, which does the division when A < Q.
35262               *
35263               * ******************************************************************************
35264               
35265               LL61:
35266 E612 D3A0  30        movb @Q,rx                      ; LDX Q             ; If Q = 0, jump down to LL84 to return a division
     E614 0090     
35267 E616 131F  14        jeq  LL84                       ; BEQ LL84          ; error
35268               
35269                                                                          ; The LL28 routine returns A / Q, but only if A < Q. In
35270                                                                          ; our case A >= Q, but we still want to use the LL28
35271                                                                          ; routine, so we halve A until it's less than Q, call
35272                                                                          ; the division routine, and then double A by the same
35273                                                                          ; number of times
35274               
35275 E618 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0 to count the number of times we halve A
     E61A 0000     
35276               
35277               LL63:
35278 E61C 091D  18        srl  ra,1                       ; LSR A             ; Halve A by shifting right
35279               
35280 E61E B387  18        ab   rone,rx                    ; INX               ; Increment X
35281               
35282 E620 9360  30        cb   @Q,ra                      ; CMP Q             ; If A >= Q, loop back to LL63 to halve it again
     E622 0090     
35283 E624 18FB  14        joc  LL63                       ; BCS LL63
35284               
35285 E626 D80E  30        movb rx,@S                      ; STX S             ; Otherwise store the number of times we halved A in S
     E628 0092     
35286               
35287 E62A 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E62C DB2C     
35288 E62E 06A0  32        bl   @jsr                       ;
     E630 FE28     
35289                                                                          ;
35290                                                                          ; R = 256 * A / Q
35291                                                                          ;
35292                                                                          ; which we can do now as A < Q
35293               
35294 E632 D3A0  30        movb @S,rx                      ; LDX S             ; Otherwise restore the number of times we halved A
     E634 0092     
35295                                                                          ; above into X
35296               
35297 E636 D360  30        movb @R,ra                      ; LDA R             ; Set A = our division result
     E638 0091     
35298               
35299               LL64:
35300                      .asla                           ; ASL A             ; Double (U A) by shifting left
     **** ****     > ASLA
0001 E63A 024D  22        andi ra,>ff00
     E63C FF00     
0002 E63E 0A1D  18        sla  ra,1
                   < elite.a99
35301 E640 0204  20        li   rarg1,U                    ; ROL U
     E642 008F     
35302 E644 06A0  32        bl   @rol                       ;
     E646 FE4E     
35303               
35304 E648 1106  14        jlt  LL84                       ; BMI LL84          ; If bit 7 of U is set, the doubling has overflowed, so
35305                                                                          ; jump to LL84 to return a division error
35306               
35307 E64A 7387  18        sb   rone,rx                    ; DEX               ; Decrement X
35308               
35309 E64C 16F6  14        jne  LL64                       ; BNE LL64          ; If X is not yet zero then we haven't done as many
35310                                                                          ; doublings as we did halvings earlier, so loop back for
35311                                                                          ; another doubling
35312               
35313 E64E D80D  30        movb ra,@R                      ; STA R             ; Store the low byte of the division result in R
     E650 0091     
35314               
35315 E652 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E654 FE34     
35316               
35317               LL84:
35318 E656 020D  20        li   ra,>32*256                 ; LDA #50           ; If we get here then either we tried to divide by 0, or
     E658 3200     
35319 E65A D80D  30        movb ra,@R                      ; STA R             ; the result overflowed, so we set U and R to 50
     E65C 0091     
35320 E65E D80D  30        movb ra,@U                      ; STA U
     E660 008F     
35321               
35322 E662 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     E664 FE34     
35323               
35324               * ******************************************************************************
35325               *
35326               * Name: LL62
35327               * Type: Subroutine
35328               * Category: Maths (Arithmetic)
35329               * Summary: Calculate 128 - (U R)
35330               *
35331               * ------------------------------------------------------------------------------
35332               *
35333               * Calculate the following for a positive sign-magnitude number (U R):
35334               *
35335               * 128 - (U R)
35336               *
35337               * and then store the result, low byte then high byte, on the end of the heap at
35338               * XX3, where X points to the first free byte on the heap. Return by jumping down
35339               * to LL66.
35340               *
35341               * ------------------------------------------------------------------------------
35342               *
35343               * Returns:
35344               *
35345               * X                   X is incremented by 1
35346               *
35347               * ******************************************************************************
35348               
35349               LL62:
35350 E666 020D  20        li   ra,>80*256                 ; LDA #128          ; Calculate 128 - (U R), starting with the low bytes
     E668 8000     
35351                      .sec                            ; SEC
     **** ****     > SEC
0001 E66A 0A18  18        sla  rmone,1
                   < elite.a99
35352                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 E66C 1801  14        joc  !
0002 E66E 7347  18        sb   rone,ra
0003               !:
0004 E670 7360  30        sb   @R,ra
     E672 0091     
                   < elite.a99
35353               
35354 E674 06CE  14        swpb rx                         ;
35355 E676 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     E678 0100     
35356 E67A 06CE  14        swpb rx                         ;
35357                                                                          ; the heap at XX3
35358               
35359 E67C B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
35360                                                                          ; byte
35361               
35362 E67E 020D  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     E680 0000     
35363                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 E682 1801  14        joc  !
0002 E684 7347  18        sb   rone,ra
0003               !:
0004 E686 7360  30        sb   @U,ra
     E688 008F     
                   < elite.a99
35364               
35365 E68A 06CE  14        swpb rx                         ;
35366 E68C DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     E68E 0100     
35367 E690 06CE  14        swpb rx                         ;
35368                                                                          ; the heap at XX3
35369               
35370 E692 0460  28        b    @LL66                      ; JMP LL66          ; Jump down to LL66
     E694 E77A     
35371               
35372               * ******************************************************************************
35373               *
35374               * Name: LL9 (Part 7 of 12)
35375               * Type: Subroutine
35376               * Category: Drawing ships
35377               * Summary: Draw ship: Calculate the visibility of each of the ship's vertices
35378               * Deep dive: Drawing ships
35379               * Calculating vertex coordinates
35380               *
35381               * ------------------------------------------------------------------------------
35382               *
35383               * This section continues the coordinate adding from part 6 by finishing off the
35384               * calculation that we started above:
35385               *
35386               * [ sidev_x roofv_x nosev_x ]   [ x ]   [ x ]
35387               * vector to vertex = [ sidev_y roofv_y nosev_y ] . [ y ] + [ y ]
35388               * [ sidev_z roofv_z nosev_z ]   [ z ]   [ z ]
35389               *
35390               * The gets stored as follows, in sign-magnitude values with the magnitudes
35391               * fitting into the low bytes:
35392               *
35393               * XX15(2 0)           [ x y z ] . [ sidev_x roofv_x nosev_x ] + [ x y z ]
35394               *
35395               * XX15(5 3)           [ x y z ] . [ sidev_y roofv_y nosev_y ] + [ x y z ]
35396               *
35397               * (U T)               [ x y z ] . [ sidev_z roofv_z nosev_z ] + [ x y z ]
35398               *
35399               * Finally, because this vector is from our ship to the vertex, and we are at the
35400               * origin, this vector is the same as the coordinates of the vertex. In other
35401               * words, we have just worked out:
35402               *
35403               * XX15(2 0)           x-coordinate of the current vertex
35404               *
35405               * XX15(5 3)           y-coordinate of the current vertex
35406               *
35407               * (U T)               z-coordinate of the current vertex
35408               *
35409               * ******************************************************************************
35410               
35411               LL56:
35412 E696 D360  30        movb @XX1+6,ra                  ; LDA XX1+6         ; Set (U T) = XX1(7 6) - XX12(5 4)
     E698 0059     
35413                      .sec                            ; SEC               ; = (z_hi z_lo) - vertv_z
     **** ****     > SEC
0001 E69A 0A18  18        sla  rmone,1
                   < elite.a99
35414                      .sbc @XX12+4,ra                 ; SBC XX12+4        ;
     **** ****     > SBC
0001 E69C 1801  14        joc  !
0002 E69E 7347  18        sb   rone,ra
0003               !:
0004 E6A0 7360  30        sb   @XX12+4,ra
     E6A2 003B     
                   < elite.a99
35415 E6A4 D80D  30        movb ra,@T                      ; STA T             ; Starting with the low bytes
     E6A6 00D1     
35416               
35417 E6A8 D360  30        movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can subtract 0 here
     E6AA 005A     
35418                      .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
     **** ****     > SBI
0001 E6AC 1801  14        joc  !
0002 E6AE 7347  18        sb   rone,ra
0003               !:
0004 E6B0 022D  22        ai   ra,-(>00*256)
     E6B2 0000     
                   < elite.a99
35419 E6B4 D80D  30        movb ra,@U                      ; STA U
     E6B6 008F     
35420               
35421 E6B8 1706  14        jnc  LL140                      ; BCC LL140         ; If the subtraction just underflowed, skip to LL140 to
35422                                                                          ; set (U T) to the minimum value of 4
35423               
35424 E6BA 160D  14        jne  LL57                       ; BNE LL57          ; If U is non-zero, jump down to LL57
35425               
35426 E6BC D360  30        movb @T,ra                      ; LDA T             ; If T >= 4, jump down to LL57
     E6BE 00D1     
35427 E6C0 028D  22        ci   ra,>04*256                 ; CMP #4
     E6C2 0400     
35428 E6C4 1808  14        joc  LL57                       ; BCS LL57
35429               
35430               LL140:
35431 E6C6 020D  20        li   ra,>00*256                 ; LDA #0            ; If we get here then either (U T) < 4 or the
     E6C8 0000     
35432 E6CA D80D  30        movb ra,@U                      ; STA U             ; subtraction underflowed, so set (U T) = 4
     E6CC 008F     
35433 E6CE 020D  20        li   ra,>04*256                 ; LDA #4
     E6D0 0400     
35434 E6D2 D80D  30        movb ra,@T                      ; STA T
     E6D4 00D1     
35435               
35436               LL57:
35437                                                                          ; By this point we have our results, so now to scale
35438                                                                          ; the 16-bit results down into 8-bit values
35439 E6D6 D360  30        movb @U,ra                      ; LDA U             ; If the high bytes of the result are all zero, we are
     E6D8 008F     
35440 E6DA F360  30        socb @XX15+1,ra                 ; ORA XX15+1        ; done, so jump down to LL60 for the next stage
     E6DC 0032     
35441 E6DE F360  30        socb @XX15+4,ra                 ; ORA XX15+4
     E6E0 0035     
35442 E6E2 131D  14        jeq  LL60                       ; BEQ LL60
35443               
35444                      .lsr @XX15+1                    ; LSR XX15+1        ; Shift XX15(1 0) to the right
     **** ****     > LSR
0001 E6E4 D020  30        movb @XX15+1,rtmp
     E6E6 0032     
0002 E6E8 0910  18        srl  rtmp,1
0003 E6EA D800  30        movb rtmp,@XX15+1
     E6EC 0032     
                   < elite.a99
35445 E6EE 0204  20        li   rarg1,XX15                 ; ROR XX15
     E6F0 0031     
35446 E6F2 06A0  32        bl   @ror                       ;
     E6F4 FE7A     
35447               
35448                      .lsr @XX15+4                    ; LSR XX15+4        ; Shift XX15(4 3) to the right
     **** ****     > LSR
0001 E6F6 D020  30        movb @XX15+4,rtmp
     E6F8 0035     
0002 E6FA 0910  18        srl  rtmp,1
0003 E6FC D800  30        movb rtmp,@XX15+4
     E6FE 0035     
                   < elite.a99
35449 E700 0204  20        li   rarg1,XX15+3               ; ROR XX15+3
     E702 0034     
35450 E704 06A0  32        bl   @ror                       ;
     E706 FE7A     
35451               
35452                      .lsr @U                         ; LSR U             ; Shift (U T) to the right
     **** ****     > LSR
0001 E708 D020  30        movb @U,rtmp
     E70A 008F     
0002 E70C 0910  18        srl  rtmp,1
0003 E70E D800  30        movb rtmp,@U
     E710 008F     
                   < elite.a99
35453 E712 0204  20        li   rarg1,T                    ; ROR T
     E714 00D1     
35454 E716 06A0  32        bl   @ror                       ;
     E718 FE7A     
35455               
35456 E71A 0460  28        b    @LL57                      ; JMP LL57          ; Jump back to LL57 to see if we can shift the result
     E71C E6D6     
35457                                                                          ; any more
35458               
35459               * ******************************************************************************
35460               *
35461               * Name: LL9 (Part 8 of 12)
35462               * Type: Subroutine
35463               * Category: Drawing ships
35464               * Summary: Draw ship: Calculate the screen coordinates of visible vertices
35465               * Deep dive: Drawing ships
35466               *
35467               * ------------------------------------------------------------------------------
35468               *
35469               * This section projects the coordinate of the vertex into screen coordinates and
35470               * stores them on the XX3 heap. By the end of this part, the XX3 heap contains
35471               * four bytes containing the 16-bit screen coordinates of the current vertex, in
35472               * the order: x_lo, x_hi, y_lo, y_hi.
35473               *
35474               * When we reach here, we are looping through the vertices, and we've just worked
35475               * out the coordinates of the vertex in our normal coordinate system, as follows
35476               *
35477               * XX15(2 0)           (x_sign x_lo) = x-coordinate of the current vertex
35478               *
35479               * XX15(5 3)           (y_sign y_lo) = y-coordinate of the current vertex
35480               *
35481               * (U T)               (z_sign z_lo) = z-coordinate of the current vertex
35482               *
35483               * Note that U is always zero when we get to this point, as the vertex is always
35484               * in front of us (so it has a positive z-coordinate, into the screen).
35485               *
35486               * ------------------------------------------------------------------------------
35487               *
35488               * Other entry points:
35489               *
35490               * LL70+1              Contains an RTS (as the first byte of an LDA
35491               * instruction)
35492               *
35493               * LL66                A re-entry point into the ship-drawing routine, used by
35494               * the LL62 routine to store 128 - (U R) on the XX3 heap
35495               *
35496               * ******************************************************************************
35497               
35498               LL60:
35499 E71E D360  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     E720 00D1     
35500 E722 D80D  30        movb ra,@Q                      ; STA Q
     E724 0090     
35501               
35502 E726 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set A = x_lo
     E728 0031     
35503               
35504 E72A 9360  30        cb   @Q,ra                      ; CMP Q             ; If x_lo < z_lo jump to LL69
     E72C 0090     
35505 E72E 1706  14        jnc  LL69                       ; BCC LL69
35506               
35507 E730 0200  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     E732 E612     
35508 E734 06A0  32        bl   @jsr                       ;
     E736 FE28     
35509                                                                          ;
35510                                                                          ; (U R) = 256 * A / Q
35511                                                                          ; = 256 * x / z
35512                                                                          ;
35513                                                                          ; which we can do as x >= z
35514               
35515 E738 0460  28        b    @LL65                      ; JMP LL65          ; Jump to LL65 to skip the division for x_lo < z_lo
     E73A E744     
35516               
35517               LL69:
35518 E73C 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E73E DB2C     
35519 E740 06A0  32        bl   @jsr                       ;
     E742 FE28     
35520                                                                          ;
35521                                                                          ; R = 256 * A / Q
35522                                                                          ; = 256 * x / z
35523                                                                          ;
35524                                                                          ; Because x < z, the result fits into one byte, and we
35525                                                                          ; also know that U = 0, so (U R) also contains the
35526                                                                          ; result
35527               
35528               LL65:
35529                                                                          ; At this point we have:
35530                                                                          ;
35531                                                                          ; (U R) = x / z
35532                                                                          ;
35533                                                                          ; so (U R) contains the vertex's x-coordinate projected
35534                                                                          ; on screen
35535                                                                          ;
35536                                                                          ; The next task is to convert (U R) to a pixel screen
35537                                                                          ; coordinate and stick it on the XX3 heap.
35538                                                                          ;
35539                                                                          ; We start with the x-coordinate. To convert the
35540                                                                          ; x-coordinate to a screen pixel we add 128, the
35541                                                                          ; x-coordinate of the centre of the screen, because the
35542                                                                          ; projected value is relative to an origin at the centre
35543                                                                          ; of the screen, but the origin of the screen pixels is
35544                                                                          ; at the top-left of the screen
35545 E744 D3A0  30        movb @CNT,rx                    ; LDX CNT           ; Fetch the pointer to the end of the XX3 heap from CNT
     E746 00A4     
35546                                                                          ; into X
35547               
35548 E748 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If x_sign is negative, jump up to LL62, which will
     E74A 0033     
35549 E74C 118C  14        jlt  LL62                       ; BMI LL62          ; store 128 - (U R) on the XX3 heap and return by
35550                                                                          ; jumping down to LL66 below
35551               
35552 E74E D360  30        movb @R,ra                      ; LDA R             ; Calculate 128 + (U R), starting with the low bytes
     E750 0091     
35553                      .clc                            ; CLC
     **** ****     > CLC
0001 E752 0A16  18        sla  rzero,1
                   < elite.a99
35554                      .adi (>80*256)                  ; ADC #128
     **** ****     > ADI
0001 E754 1701  14        jnc  !
0002 E756 B347  18        ab   rone,ra
0003               !:
0004 E758 022D  22        ai   ra,(>80*256)
     E75A 8000     
                   < elite.a99
35555               
35556 E75C 06CE  14        swpb rx                         ;
35557 E75E DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     E760 0100     
35558 E762 06CE  14        swpb rx                         ;
35559                                                                          ; the heap at XX3
35560               
35561 E764 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
35562                                                                          ; byte
35563               
35564 E766 D360  30        movb @U,ra                      ; LDA U             ; And then add the high bytes
     E768 008F     
35565                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 E76A 1701  14        jnc  !
0002 E76C B347  18        ab   rone,ra
0003               !:
0004 E76E 022D  22        ai   ra,(>00*256)
     E770 0000     
                   < elite.a99
35566               
35567 E772 06CE  14        swpb rx                         ;
35568 E774 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     E776 0100     
35569 E778 06CE  14        swpb rx                         ;
35570                                                                          ; the heap at XX3
35571               
35572               LL66:
35573                                                                          ; We've just stored the screen x-coordinate of the
35574                                                                          ; vertex on the XX3 heap, so now for the y-coordinate
35575 E77A D34E  18        movb rx,ra                      ; TXA               ; Store the heap pointer in X on the stack (at this
35576                      .pha                            ; PHA               ; it points to the last entry on the heap, not the first
     **** ****     > PHA
0001 E77C D68D  30        movb ra,*rsp
0002 E77E 060A  14        dec  rsp
                   < elite.a99
35577                                                                          ; free byte)
35578               
35579 E780 020D  20        li   ra,>00*256                 ; LDA #0            ; Set U = 0
     E782 0000     
35580 E784 D80D  30        movb ra,@U                      ; STA U
     E786 008F     
35581               
35582 E788 D360  30        movb @T,ra                      ; LDA T             ; Set Q = z_lo
     E78A 00D1     
35583 E78C D80D  30        movb ra,@Q                      ; STA Q
     E78E 0090     
35584               
35585 E790 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set A = y_lo
     E792 0034     
35586               
35587 E794 9360  30        cb   @Q,ra                      ; CMP Q             ; If y_lo < z_lo jump to LL67
     E796 0090     
35588 E798 171E  14        jnc  LL67                       ; BCC LL67
35589               
35590 E79A 0200  20        li   rtmp,LL61                  ; JSR LL61          ; Call LL61 to calculate:
     E79C E612     
35591 E79E 06A0  32        bl   @jsr                       ;
     E7A0 FE28     
35592                                                                          ;
35593                                                                          ; (U R) = 256 * A / Q
35594                                                                          ; = 256 * y / z
35595                                                                          ;
35596                                                                          ; which we can do as y >= z
35597               
35598 E7A2 0460  28        b    @LL68                      ; JMP LL68          ; Jump to LL68 to skip the division for y_lo < z_lo
     E7A4 E7DE     
35599               
35600               LL70:
35601                                                                          ; This gets called from below when y_sign is negative
35602 E7A6 020D  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y + (U R), starting with the low bytes
     E7A8 6000     
35603                      .clc                            ; CLC
     **** ****     > CLC
0001 E7AA 0A16  18        sla  rzero,1
                   < elite.a99
35604                      .adc @R,ra                      ; ADC R
     **** ****     > ADC
0001 E7AC 1701  14        jnc  !
0002 E7AE B347  18        ab   rone,ra
0003               !:
0004 E7B0 B360  30        ab   @R,ra
     E7B2 0091     
                   < elite.a99
35605               
35606 E7B4 06CE  14        swpb rx                         ;
35607 E7B6 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     E7B8 0100     
35608 E7BA 06CE  14        swpb rx                         ;
35609                                                                          ; the heap at XX3
35610               
35611 E7BC B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
35612                                                                          ; byte
35613               
35614 E7BE 020D  20        li   ra,>00*256                 ; LDA #0            ; And then add the high bytes
     E7C0 0000     
35615                      .adc @U,ra                      ; ADC U
     **** ****     > ADC
0001 E7C2 1701  14        jnc  !
0002 E7C4 B347  18        ab   rone,ra
0003               !:
0004 E7C6 B360  30        ab   @U,ra
     E7C8 008F     
                   < elite.a99
35616               
35617 E7CA 06CE  14        swpb rx                         ;
35618 E7CC DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     E7CE 0100     
35619 E7D0 06CE  14        swpb rx                         ;
35620                                                                          ; the heap at XX3
35621               
35622 E7D2 0460  28        b    @LL50                      ; JMP LL50          ; Jump to LL50 to move on to the next vertex
     E7D4 E818     
35623               
35624               LL67:
35625 E7D6 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     E7D8 DB2C     
35626 E7DA 06A0  32        bl   @jsr                       ;
     E7DC FE28     
35627                                                                          ;
35628                                                                          ; R = 256 * A / Q
35629                                                                          ; = 256 * y / z
35630                                                                          ;
35631                                                                          ; Because y < z, the result fits into one byte, and we
35632                                                                          ; also know that U = 0, so (U R) also contains the
35633                                                                          ; result
35634               
35635               LL68:
35636                                                                          ; At this point we have:
35637                                                                          ;
35638                                                                          ; (U R) = y / z
35639                                                                          ;
35640                                                                          ; so (U R) contains the vertex's y-coordinate projected
35641                                                                          ; on screen
35642                                                                          ;
35643                                                                          ; We now want to convert this to a screen y-coordinate
35644                                                                          ; and stick it on the XX3 heap, much like we did with
35645                                                                          ; the x-coordinate above. Again, we convert the
35646                                                                          ; coordinate by adding or subtracting the y-coordinate
35647                                                                          ; of the centre of the screen, which is in the constant
35648                                                                          ; #Y, but this time we do the opposite, as a positive
35649                                                                          ; projected y-coordinate, i.e. up the space y-axis and
35650                                                                          ; up the screen, converts to a low y-coordinate, which
35651                                                                          ; is the opposite way round to the x-coordinates
35652                      .pla                            ; PLA               ; Restore the heap pointer from the stack into X
     **** ****     > PLA
0001 E7DE 058A  14        inc  rsp
0002 E7E0 D35A  26        movb *rsp,ra
                   < elite.a99
35653 E7E2 D38D  18        movb ra,rx                      ; TAX
35654               
35655 E7E4 B387  18        ab   rone,rx                    ; INX               ; When we stored the heap pointer, it pointed to the
35656                                                                          ; last entry on the heap, not the first free byte, so we
35657                                                                          ; increment it so it does point to the next free byte
35658               
35659 E7E6 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; If y_sign is negative, jump up to LL70, which will
     E7E8 0036     
35660 E7EA 11DD  14        jlt  LL70                       ; BMI LL70          ; store #Y + (U R) on the XX3 heap and return by jumping
35661                                                                          ; down to LL50 below
35662               
35663 E7EC 020D  20        li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y - (U R), starting with the low bytes
     E7EE 6000     
35664                      .sec                            ; SEC
     **** ****     > SEC
0001 E7F0 0A18  18        sla  rmone,1
                   < elite.a99
35665                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 E7F2 1801  14        joc  !
0002 E7F4 7347  18        sb   rone,ra
0003               !:
0004 E7F6 7360  30        sb   @R,ra
     E7F8 0091     
                   < elite.a99
35666               
35667 E7FA 06CE  14        swpb rx                         ;
35668 E7FC DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
     E7FE 0100     
35669 E800 06CE  14        swpb rx                         ;
35670                                                                          ; the heap at XX3
35671               
35672 E802 B387  18        ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
35673                                                                          ; byte
35674               
35675 E804 020D  20        li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
     E806 0000     
35676                      .sbc @U,ra                      ; SBC U
     **** ****     > SBC
0001 E808 1801  14        joc  !
0002 E80A 7347  18        sb   rone,ra
0003               !:
0004 E80C 7360  30        sb   @U,ra
     E80E 008F     
                   < elite.a99
35677               
35678 E810 06CE  14        swpb rx                         ;
35679 E812 DB8D  38        movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
     E814 0100     
35680 E816 06CE  14        swpb rx                         ;
35681                                                                          ; the heap at XX3
35682               
35683               LL50:
35684                                                                          ; By the time we get here, the XX3 heap contains four
35685                                                                          ; bytes containing the screen coordinates of the current
35686                                                                          ; vertex, in the order: x_lo, x_hi, y_lo, y_hi
35687                      .clc                            ; CLC               ; Set CNT = CNT + 4, so the heap pointer points to the
     **** ****     > CLC
0001 E818 0A16  18        sla  rzero,1
                   < elite.a99
35688 E81A D360  30        movb @CNT,ra                    ; LDA CNT           ; next free byte on the heap
     E81C 00A4     
35689                      .adi (>04*256)                  ; ADC #4
     **** ****     > ADI
0001 E81E 1701  14        jnc  !
0002 E820 B347  18        ab   rone,ra
0003               !:
0004 E822 022D  22        ai   ra,(>04*256)
     E824 0400     
                   < elite.a99
35690 E826 D80D  30        movb ra,@CNT                    ; STA CNT
     E828 00A4     
35691               
35692 E82A D360  30        movb @XX17,ra                   ; LDA XX17          ; Set A to the offset of the current vertex's data,
     E82C 0095     
35693                                                                          ; which we set in part 6
35694               
35695                      .adi (>06*256)                  ; ADC #6            ; Set Y = A + 6, so Y now points to the data for the
     **** ****     > ADI
0001 E82E 1701  14        jnc  !
0002 E830 B347  18        ab   rone,ra
0003               !:
0004 E832 022D  22        ai   ra,(>06*256)
     E834 0600     
                   < elite.a99
35696 E836 D3CD  18        movb ra,ry                      ; TAY               ; next vertex
35697               
35698 E838 1805  14        joc  LL72                       ; BCS LL72          ; If the addition just overflowed, meaning we just tried
35699                                                                          ; to access vertex #43, jump to LL72, as the maximum
35700                                                                          ; number of vertices allowed is 42
35701               
35702 E83A 9360  30        cb   @XX20,ra                   ; CMP XX20          ; If Y >= number of vertices * 6 (which we stored in
     E83C 00A8     
35703 E83E 1802  14        joc  LL72                       ; BCS LL72          ; XX20 in part 6), jump to LL72, as we have processed
35704                                                                          ; all the vertices for this ship
35705               
35706 E840 0460  28        b    @LL48                      ; JMP LL48          ; Loop back to LL48 in part 6 to calculate visibility
     E842 E3C0     
35707                                                                          ; and screen coordinates for the next vertex
35708               
35709               * ******************************************************************************
35710               *
35711               * Name: LL9 (Part 9 of 12)
35712               * Type: Subroutine
35713               * Category: Drawing ships
35714               * Summary: Draw ship: Draw laser beams if the ship is firing its laser at us
35715               * Deep dive: Drawing ships
35716               *
35717               * ------------------------------------------------------------------------------
35718               *
35719               * This part sets things up so we can loop through the edges in the next part. It
35720               * also adds a line to the ship line heap, if the ship is firing at us.
35721               *
35722               * When we get here, the heap at XX3 contains all the visible vertex screen
35723               * coordinates.
35724               *
35725               * ******************************************************************************
35726               
35727               LL72:
35728 E844 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
     E846 0072     
35729 E848 024D  22        andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE31
     E84A 2000     
35730 E84C 1308  14        jeq  EE31                       ; BEQ EE31
35731               
35732 E84E D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so set bit 3 of the ship's byte
     E850 0072     
35733 E852 026D  22        ori  ra,>08*256                 ; ORA #%00001000    ; #31 to denote that we are drawing something on-screen
     E854 0800     
35734 E856 D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; for this ship
     E858 0072     
35735               
35736 E85A 0460  28        b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud,
     E85C AE6C     
35737                                                                          ; returning from the subroutine using a tail call
35738               
35739               EE31:
35740 E85E 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
     E860 0800     
35741                      .bit @XX1+31                    ; BIT XX1+31        ; is nothing already being shown for this ship, so skip
     **** ****     > BIT
0001 E862 D020  30        movb @XX1+31,rtmp
     E864 0072     
0002 E866 0540  14        inv  rtmp
0003 E868 D047  18        movb rone,rtmp2
0004 E86A 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
35742 E86C 1306  14        jeq  LL74                       ; BEQ LL74          ; to LL74 as we don't need to erase anything from the
35743                                                                          ; screen
35744               
35745 E86E 0200  20        li   rtmp,LL155                 ; JSR LL155         ; Otherwise call LL155 to draw the existing ship, which
     E870 EBB4     
35746 E872 06A0  32        bl   @jsr                       ;
     E874 FE28     
35747                                                                          ; removes it from the screen
35748               
35749 E876 020D  20        li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of A so the next instruction sets bit 3 of
     E878 0800     
35750                                                                          ; the ship's byte #31 to denote that we are drawing
35751                                                                          ; something on-screen for this ship
35752               
35753               LL74:
35754 E87A F360  30        socb @XX1+31,ra                 ; ORA XX1+31        ; Apply bit 3 of A to the ship's byte #31, so if there
     E87C 0072     
35755 E87E D80D  30        movb ra,@XX1+31                 ; STA XX1+31        ; was no ship already on screen, the bit is clear,
     E880 0072     
35756                                                                          ; otherwise it is set
35757               
35758 E882 020F  20        li   ry,>09*256                 ; LDY #9            ; Fetch byte #9 of the ship's blueprint, which is the
     E884 0900     
35759                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of edges, and store it in XX20
     **** ****     > LD_IND_Y_IDX
0001 E886 D820  42        movb @XX0,@rtmplb
     E888 001E     
     E88A 8301     
0002 E88C D020  30        movb @XX0+1,rtmp
     E88E 001F     
0003 E890 06CF  14        swpb ry
0004 E892 A00F  18        a    ry,rtmp
0005 E894 06CF  14        swpb ry
0006 E896 D350  26        movb *rtmp,RA
                   < elite.a99
35760 E898 D80D  30        movb ra,@XX20                   ; STA XX20
     E89A 00A8     
35761               
35762 E89C 020F  20        li   ry,>00*256                 ; LDY #0            ; We are about to step through all the edges, using Y
     E89E 0000     
35763                                                                          ; as a counter
35764               
35765 E8A0 D80F  30        movb ry,@U                      ; STY U             ; Set U = 0 (though we increment it to 1 below)
     E8A2 008F     
35766               
35767 E8A4 D80F  30        movb ry,@XX17                   ; STY XX17          ; Set XX17 = 0, which we are going to use as a counter
     E8A6 0095     
35768                                                                          ; for stepping through the ship's edges
35769               
35770 E8A8 B347  18        ab   rone,ra                    ; INC U             ; We are going to start calculating the lines we need to
35771                                                                          ; draw for this ship, and will store them in the ship
35772                                                                          ; line heap, using U to point to the end of the heap, so
35773                                                                          ; we start by setting U = 1
35774               
35775                      .bit @XX1+31                    ; BIT XX1+31        ; If bit 6 of the ship's byte #31 is clear, then the
     **** ****     > BIT
0001 E8AA D020  30        movb @XX1+31,rtmp
     E8AC 0072     
0002 E8AE 0540  14        inv  rtmp
0003 E8B0 D047  18        movb rone,rtmp2
0004 E8B2 5001  18        szcb rtmp2,rtmp
0005                      ; todo: bit 6 and 7
                   < elite.a99
35776 E8B4 1977  14        jno  LL170                      ; BVC LL170         ; ship is not firing its lasers, so jump to LL170 to
35777                                                                          ; skip the drawing of laser lines
35778               
35779                                                                          ; The ship is firing its laser at us, so we need to draw
35780                                                                          ; the laser lines
35781               
35782 E8B6 D360  30        movb @XX1+31,ra                 ; LDA XX1+31        ; Clear bit 6 of the ship's byte #31 so the ship doesn't
     E8B8 0072     
35783 E8BA 024D  22        andi ra,>bf*256                 ; AND #%10111111    ; keep firing endlessly
     E8BC BF00     
35784 E8BE D80D  30        movb ra,@XX1+31                 ; STA XX1+31
     E8C0 0072     
35785               
35786 E8C2 020F  20        li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 of the ship's blueprint, which is the
     E8C4 0600     
35787                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number * 4 of the vertex where the ship has its lasers
     **** ****     > LD_IND_Y_IDX
0001 E8C6 D820  42        movb @XX0,@rtmplb
     E8C8 001E     
     E8CA 8301     
0002 E8CC D020  30        movb @XX0+1,rtmp
     E8CE 001F     
0003 E8D0 06CF  14        swpb ry
0004 E8D2 A00F  18        a    ry,rtmp
0005 E8D4 06CF  14        swpb ry
0006 E8D6 D350  26        movb *rtmp,RA
                   < elite.a99
35788               
35789 E8D8 D3CD  18        movb ra,ry                      ; TAY               ; Put the vertex number into Y, where it can act as an
35790                                                                          ; index into list of vertex screen coordinates we added
35791                                                                          ; to the XX3 heap
35792               
35793 E8DA 06CF  14        swpb ry                         ;
35794 E8DC D3AF  34        movb @XX3(ry),rx                ; LDX XX3,Y         ; Fetch the x_lo coordinate of the laser vertex from the
     E8DE 0100     
35795 E8E0 06CF  14        swpb ry                         ;
35796 E8E2 D80E  30        movb rx,@XX15                   ; STX XX15          ; XX3 heap into XX15
     E8E4 0031     
35797               
35798 E8E6 B387  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35799 E8E8 135D  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35800                                                                          ; the vertex calculation in part 6 and 7, so jump to
35801                                                                          ; LL170 to skip drawing the laser lines
35802               
35803                                                                          ; We now build a laser beam from the ship's laser vertex
35804                                                                          ; towards our ship, as follows:
35805                                                                          ;
35806                                                                          ; XX15(1 0) = laser vertex x-coordinate
35807                                                                          ;
35808                                                                          ; XX15(3 2) = laser vertex y-coordinate
35809                                                                          ;
35810                                                                          ; XX15(5 4) = x-coordinate of the end of the beam
35811                                                                          ;
35812                                                                          ; XX12(1 0) = y-coordinate of the end of the beam
35813                                                                          ;
35814                                                                          ; The end of the laser beam will be positioned to look
35815                                                                          ; good, rather than being directly aimed at us, as
35816                                                                          ; otherwise we would only see a flashing point of light
35817                                                                          ; as they unleashed their attack
35818               
35819 E8EA 06CF  14        swpb ry                         ;
35820 E8EC D3AF  34        movb @XX3+1(ry),rx              ; LDX XX3+1,Y       ; Fetch the x_hi coordinate of the laser vertex from the
     E8EE 0101     
35821 E8F0 06CF  14        swpb ry                         ;
35822 E8F2 D80E  30        movb rx,@XX15+1                 ; STX XX15+1        ; XX3 heap into XX15+1
     E8F4 0032     
35823               
35824 E8F6 B387  18        ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
35825 E8F8 1355  14        jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
35826                                                                          ; a vertex calculation in part 6 and 7, so jump to LL170
35827                                                                          ; to skip drawing the laser beam
35828               
35829 E8FA 06CF  14        swpb ry                         ;
35830 E8FC D3AF  34        movb @XX3+2(ry),rx              ; LDX XX3+2,Y       ; Fetch the y_lo coordinate of the laser vertex from the
     E8FE 0102     
35831 E900 06CF  14        swpb ry                         ;
35832 E902 D80E  30        movb rx,@XX15+2                 ; STX XX15+2        ; XX3 heap into XX15+2
     E904 0033     
35833               
35834 E906 06CF  14        swpb ry                         ;
35835 E908 D3AF  34        movb @XX3+3(ry),rx              ; LDX XX3+3,Y       ; Fetch the y_hi coordinate of the laser vertex from the
     E90A 0103     
35836 E90C 06CF  14        swpb ry                         ;
35837 E90E D80E  30        movb rx,@XX15+3                 ; STX XX15+3        ; XX3 heap into XX15+3
     E910 0034     
35838               
35839 E912 020D  20        li   ra,>00*256                 ; LDA #0            ; Set XX15(5 4) = 0, so their laser beam fires to the
     E914 0000     
35840 E916 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; left edge of the screen
     E918 0035     
35841 E91A D80D  30        movb ra,@XX15+5                 ; STA XX15+5
     E91C 0036     
35842               
35843 E91E D80D  30        movb ra,@XX12+1                 ; STA XX12+1        ; Set XX12(1 0) = the ship's z_lo coordinate, which will
     E920 0038     
35844 E922 D360  30        movb @XX1+6,ra                  ; LDA XX1+6         ; effectively make the vertical position of the end of
     E924 0059     
35845 E926 D80D  30        movb ra,@XX12                   ; STA XX12          ; the laser beam move around as the ship moves in space
     E928 0037     
35846               
35847 E92A D360  30        movb @XX1+2,ra                  ; LDA XX1+2         ; If the ship's x_sign is positive, skip the next
     E92C 0055     
35848 E92E 1501  14        jgt  B114                       ; BPL B114          ; instruction
35849               
35850 E930 7347  18        sb   rone,ra                    ; DEC XX15+4        ; The ship's x_sign is negative (i.e. it's on the left
35851                                                                          ; side of the screen), so switch the laser beam so it
35852                                                                          ; goes to the right edge of the screen by decrementing
35853                                                                          ; XX15(5 4) to 255
35854               
35855               B114:
35856 E932 0200  20        li   rtmp,LL145                 ; JSR LL145         ; Call LL145 to see if the laser beam needs to be
     E934 EED8     
35857 E936 06A0  32        bl   @jsr                       ;
     E938 FE28     
35858                                                                          ; clipped to fit on-screen, returning the clipped line's
35859                                                                          ; end-points in (X1, Y1) and (X2, Y2)
35860               
35861 E93A 1834  14        joc  LL170                      ; BCS LL170         ; If the C flag is set then the line is not visible on
35862                                                                          ; screen, so jump to LL170 so we don't store this line
35863                                                                          ; in the ship line heap
35864               
35865 E93C D3E0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     E93E 008F     
35866                                                                          ; next free byte on the heap, into Y
35867               
35868 E940 D360  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     E942 0031     
35869                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E944 D820  42        movb @XX19,@rtmplb
     E946 0074     
     E948 8301     
0002 E94A D020  30        movb @XX19+1,rtmp
     E94C 0075     
0003 E94E 06CF  14        swpb ry
0004 E950 A00F  18        a    ry,rtmp
0005 E952 06CF  14        swpb ry
0006 E954 D40D  30        movb RA,*rtmp
                   < elite.a99
35870               
35871 E956 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35872               
35873 E958 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     E95A 0032     
35874                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E95C D820  42        movb @XX19,@rtmplb
     E95E 0074     
     E960 8301     
0002 E962 D020  30        movb @XX19+1,rtmp
     E964 0075     
0003 E966 06CF  14        swpb ry
0004 E968 A00F  18        a    ry,rtmp
0005 E96A 06CF  14        swpb ry
0006 E96C D40D  30        movb RA,*rtmp
                   < elite.a99
35875               
35876 E96E B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35877               
35878 E970 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     E972 0033     
35879                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E974 D820  42        movb @XX19,@rtmplb
     E976 0074     
     E978 8301     
0002 E97A D020  30        movb @XX19+1,rtmp
     E97C 0075     
0003 E97E 06CF  14        swpb ry
0004 E980 A00F  18        a    ry,rtmp
0005 E982 06CF  14        swpb ry
0006 E984 D40D  30        movb RA,*rtmp
                   < elite.a99
35880               
35881 E986 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35882               
35883 E988 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     E98A 0034     
35884                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 E98C D820  42        movb @XX19,@rtmplb
     E98E 0074     
     E990 8301     
0002 E992 D020  30        movb @XX19+1,rtmp
     E994 0075     
0003 E996 06CF  14        swpb ry
0004 E998 A00F  18        a    ry,rtmp
0005 E99A 06CF  14        swpb ry
0006 E99C D40D  30        movb RA,*rtmp
                   < elite.a99
35885               
35886 E99E B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
35887               
35888 E9A0 D80F  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     E9A2 008F     
35889               
35890               * ******************************************************************************
35891               *
35892               * Name: LL9 (Part 10 of 12)
35893               * Type: Subroutine
35894               * Category: Drawing ships
35895               * Summary: Draw ship: Calculate the visibility of each of the ship's edges
35896               * Deep dive: Drawing ships
35897               *
35898               * ------------------------------------------------------------------------------
35899               *
35900               * This part calculates which edges are visible - in other words, which lines we
35901               * should draw - and clips them to fit on the screen.
35902               *
35903               * When we get here, the heap at XX3 contains all the visible vertex screen
35904               * coordinates.
35905               *
35906               * ******************************************************************************
35907               
35908               LL170:
35909 E9A4 020F  20        li   ry,>03*256                 ; LDY #3            ; Fetch byte #3 of the ship's blueprint, which contains
     E9A6 0300     
35910                      .clc                            ; CLC               ; the low byte of the offset to the edges data
     **** ****     > CLC
0001 E9A8 0A16  18        sla  rzero,1
                   < elite.a99
35911                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y
     **** ****     > LD_IND_Y_IDX
0001 E9AA D820  42        movb @XX0,@rtmplb
     E9AC 001E     
     E9AE 8301     
0002 E9B0 D020  30        movb @XX0+1,rtmp
     E9B2 001F     
0003 E9B4 06CF  14        swpb ry
0004 E9B6 A00F  18        a    ry,rtmp
0005 E9B8 06CF  14        swpb ry
0006 E9BA D350  26        movb *rtmp,RA
                   < elite.a99
35912               
35913                      .adc @XX0,ra                    ; ADC XX0           ; Set V = low byte edges offset + XX0
     **** ****     > ADC
0001 E9BC 1701  14        jnc  !
0002 E9BE B347  18        ab   rone,ra
0003               !:
0004 E9C0 B360  30        ab   @XX0,ra
     E9C2 001E     
                   < elite.a99
35914 E9C4 D80D  30        movb ra,@V                      ; STA V
     E9C6 0022     
35915               
35916 E9C8 020F  20        li   ry,>10*256                 ; LDY #16           ; Fetch byte #16 of the ship's blueprint, which contains
     E9CA 1000     
35917                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the edges data
     **** ****     > LD_IND_Y_IDX
0001 E9CC D820  42        movb @XX0,@rtmplb
     E9CE 001E     
     E9D0 8301     
0002 E9D2 D020  30        movb @XX0+1,rtmp
     E9D4 001F     
0003 E9D6 06CF  14        swpb ry
0004 E9D8 A00F  18        a    ry,rtmp
0005 E9DA 06CF  14        swpb ry
0006 E9DC D350  26        movb *rtmp,RA
                   < elite.a99
35918               
35919                      .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte edges offset + XX0+1
     **** ****     > ADC
0001 E9DE 1701  14        jnc  !
0002 E9E0 B347  18        ab   rone,ra
0003               !:
0004 E9E2 B360  30        ab   @XX0+1,ra
     E9E4 001F     
                   < elite.a99
35920 E9E6 D80D  30        movb ra,@V+1                    ; STA V+1           ;
     E9E8 0023     
35921                                                                          ; So V(1 0) now points to the start of the edges data
35922                                                                          ; for this ship
35923               
35924 E9EA 020F  20        li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the ship's blueprint, which contains
     E9EC 0500     
35925                      .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the maximum heap size for plotting the ship (which is
     **** ****     > LD_IND_Y_IDX
0001 E9EE D820  42        movb @XX0,@rtmplb
     E9F0 001E     
     E9F2 8301     
0002 E9F4 D020  30        movb @XX0+1,rtmp
     E9F6 001F     
0003 E9F8 06CF  14        swpb ry
0004 E9FA A00F  18        a    ry,rtmp
0005 E9FC 06CF  14        swpb ry
0006 E9FE D350  26        movb *rtmp,RA
                   < elite.a99
35926 EA00 D80D  30        movb ra,@T1                     ; STA T1            ; 1 + 4 * the maximum number of visible edges) and store
     EA02 0006     
35927                                                                          ; it in T1
35928               
35929 EA04 D3E0  30        movb @XX17,ry                   ; LDY XX17          ; Set Y to the edge counter in XX17
     EA06 0095     
35930               
35931               LL75:
35932                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this edge, which contains the
     **** ****     > LD_IND_Y_IDX
0001 EA08 D820  42        movb @V,@rtmplb
     EA0A 0022     
     EA0C 8301     
0002 EA0E D020  30        movb @V+1,rtmp
     EA10 0023     
0003 EA12 06CF  14        swpb ry
0004 EA14 A00F  18        a    ry,rtmp
0005 EA16 06CF  14        swpb ry
0006 EA18 D350  26        movb *rtmp,RA
                   < elite.a99
35933                                                                          ; visibility distance for this edge, beyond which the
35934                                                                          ; edge is not shown
35935               
35936 EA1A 9360  30        cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
     EA1C 00A7     
35937 EA1E 1802  14        joc  FIX011                     ; BCS FIX011        ; the ship's z-distance reduced to 0-31 (which we set in
35938 EA20 0460  28        b    @LL78                      ; JMP LL78          ; part 2), then this edge is too far away to be visible,
     EA22 EB72     
35939                                                                          ; so jump down to LL78 to move on to the next edge
35940               FIX011:
35941 EA24 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #1
35942               
35943                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this edge into A, so:
     **** ****     > LD_IND_Y_IDX
0001 EA26 D820  42        movb @V,@rtmplb
     EA28 0022     
     EA2A 8301     
0002 EA2C D020  30        movb @V+1,rtmp
     EA2E 0023     
0003 EA30 06CF  14        swpb ry
0004 EA32 A00F  18        a    ry,rtmp
0005 EA34 06CF  14        swpb ry
0006 EA36 D350  26        movb *rtmp,RA
                   < elite.a99
35944                                                                          ;
35945                                                                          ; A = %ffff ffff, where:
35946                                                                          ;
35947                                                                          ; * Bits 0-3 = the number of face 1
35948                                                                          ;
35949                                                                          ; * Bits 4-7 = the number of face 2
35950               
35951 EA38 B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #2
35952               
35953 EA3A D80D  30        movb ra,@P                      ; STA P             ; Store byte #1 into P
     EA3C 001B     
35954               
35955 EA3E 024D  22        andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
     EA40 0F00     
35956 EA42 D38D  18        movb ra,rx                      ; TAX
35957               
35958 EA44 06CE  14        swpb rx                         ;
35959 EA46 D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
     EA48 00D2     
35960 EA4A 06CE  14        swpb rx                         ;
35961 EA4C 160E  14        jne  LL79                       ; BNE LL79          ; face 1 is visible, so jump to LL79
35962               
35963 EA4E D360  30        movb @P,ra                      ; LDA P             ; Fetch byte #1 for this edge into A
     EA50 001B     
35964               
35965 EA52 091D  18        srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
35966 EA54 091D  18        srl  ra,1                       ; LSR A             ; from bits 4-7 into X
35967 EA56 091D  18        srl  ra,1                       ; LSR A
35968 EA58 091D  18        srl  ra,1                       ; LSR A
35969 EA5A D38D  18        movb ra,rx                      ; TAX
35970               
35971 EA5C 06CE  14        swpb rx                         ;
35972 EA5E D36E  34        movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is zero then we decided in part 5 that
     EA60 00D2     
35973 EA62 06CE  14        swpb rx                         ;
35974 EA64 1602  14        jne  LL79                       ; BNE LL79          ; face 2 is hidden, so jump to LL78
35975 EA66 0460  28        b    @LL78                      ; JMP LL78
     EA68 EB72     
35976               
35977               LL79:
35978                                                                          ; We now build the screen line for this edge, as
35979                                                                          ; follows:
35980                                                                          ;
35981                                                                          ; XX15(1 0) = start x-coordinate
35982                                                                          ;
35983                                                                          ; XX15(3 2) = start y-coordinate
35984                                                                          ;
35985                                                                          ; XX15(5 4) = end x-coordinate
35986                                                                          ;
35987                                                                          ; XX12(1 0) = end y-coordinate
35988                                                                          ;
35989                                                                          ; We can then pass this to the line clipping routine
35990                                                                          ; before storing the resulting line in the ship line
35991                                                                          ; heap
35992                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this edge into X, which contains
     **** ****     > LD_IND_Y_IDX
0001 EA6A D820  42        movb @V,@rtmplb
     EA6C 0022     
     EA6E 8301     
0002 EA70 D020  30        movb @V+1,rtmp
     EA72 0023     
0003 EA74 06CF  14        swpb ry
0004 EA76 A00F  18        a    ry,rtmp
0005 EA78 06CF  14        swpb ry
0006 EA7A D350  26        movb *rtmp,RA
                   < elite.a99
35993 EA7C D38D  18        movb ra,rx                      ; TAX               ; the number of the vertex at the start of the edge
35994               
35995 EA7E B3C7  18        ab   rone,ry                    ; INY               ; Increment Y to point to byte #3
35996               
35997                      .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this edge into Q, which contains
     **** ****     > LD_IND_Y_IDX
0001 EA80 D820  42        movb @V,@rtmplb
     EA82 0022     
     EA84 8301     
0002 EA86 D020  30        movb @V+1,rtmp
     EA88 0023     
0003 EA8A 06CF  14        swpb ry
0004 EA8C A00F  18        a    ry,rtmp
0005 EA8E 06CF  14        swpb ry
0006 EA90 D350  26        movb *rtmp,RA
                   < elite.a99
35998 EA92 D80D  30        movb ra,@Q                      ; STA Q             ; the number of the vertex at the end of the edge
     EA94 0090     
35999               
36000 EA96 06CE  14        swpb rx                         ;
36001 EA98 D36E  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's start vertex
     EA9A 0101     
36002 EA9C 06CE  14        swpb rx                         ;
36003 EA9E D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; from the XX3 heap into XX15+1
     EAA0 0032     
36004               
36005 EAA2 06CE  14        swpb rx                         ;
36006 EAA4 D36E  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's start vertex
     EAA6 0100     
36007 EAA8 06CE  14        swpb rx                         ;
36008 EAAA D80D  30        movb ra,@XX15                   ; STA XX15          ; from the XX3 heap into XX15
     EAAC 0031     
36009               
36010 EAAE 06CE  14        swpb rx                         ;
36011 EAB0 D36E  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's start vertex
     EAB2 0102     
36012 EAB4 06CE  14        swpb rx                         ;
36013 EAB6 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; from the XX3 heap into XX15+2
     EAB8 0033     
36014               
36015 EABA 06CE  14        swpb rx                         ;
36016 EABC D36E  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's start vertex
     EABE 0103     
36017 EAC0 06CE  14        swpb rx                         ;
36018 EAC2 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; from the XX3 heap into XX15+3
     EAC4 0034     
36019               
36020 EAC6 D3A0  30        movb @Q,rx                      ; LDX Q             ; Set X to the number of the vertex at the end of the
     EAC8 0090     
36021                                                                          ; edge, which we stored in Q
36022               
36023 EACA 06CE  14        swpb rx                         ;
36024 EACC D36E  34        movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's end vertex
     EACE 0100     
36025 EAD0 06CE  14        swpb rx                         ;
36026 EAD2 D80D  30        movb ra,@XX15+4                 ; STA XX15+4        ; from the XX3 heap into XX15+4
     EAD4 0035     
36027               
36028 EAD6 06CE  14        swpb rx                         ;
36029 EAD8 D36E  34        movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's end vertex
     EADA 0103     
36030 EADC 06CE  14        swpb rx                         ;
36031 EADE D80D  30        movb ra,@XX12+1                 ; STA XX12+1        ; from the XX3 heap into XX12+1
     EAE0 0038     
36032               
36033 EAE2 06CE  14        swpb rx                         ;
36034 EAE4 D36E  34        movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's end vertex
     EAE6 0102     
36035 EAE8 06CE  14        swpb rx                         ;
36036 EAEA D80D  30        movb ra,@XX12                   ; STA XX12          ; from the XX3 heap into XX12
     EAEC 0037     
36037               
36038 EAEE 06CE  14        swpb rx                         ;
36039 EAF0 D36E  34        movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's end vertex
     EAF2 0101     
36040 EAF4 06CE  14        swpb rx                         ;
36041 EAF6 D80D  30        movb ra,@XX15+5                 ; STA XX15+5        ; from the XX3 heap into XX15+5
     EAF8 0036     
36042               
36043 EAFA 0200  20        li   rtmp,LL147                 ; JSR LL147         ; Call LL147 to see if the new line segment needs to be
     EAFC EEE4     
36044 EAFE 06A0  32        bl   @jsr                       ;
     EB00 FE28     
36045                                                                          ; clipped to fit on-screen, returning the clipped line's
36046                                                                          ; end-points in (X1, Y1) and (X2, Y2)
36047               
36048 EB02 1837  14        joc  LL78                       ; BCS LL78          ; If the C flag is set then the line is not visible on
36049                                                                          ; screen, so jump to LL78 so we don't store this line
36050                                                                          ; in the ship line heap
36051               
36052               * ******************************************************************************
36053               *
36054               * Name: LL9 (Part 11 of 12)
36055               * Type: Subroutine
36056               * Category: Drawing ships
36057               * Summary: Draw ship: Add all visible edges to the ship line heap
36058               * Deep dive: Drawing ships
36059               *
36060               * ------------------------------------------------------------------------------
36061               *
36062               * This part adds all the visible edges to the ship line heap, so we can draw
36063               * them in part 12.
36064               *
36065               * Other entry points:
36066               *
36067               * LL81+2              Draw the contents of the ship line heap, used to draw
36068               * the ship as a dot from SHPPT
36069               *
36070               * ******************************************************************************
36071               
36072               LL80:
36073 EB04 D3E0  30        movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
     EB06 008F     
36074                                                                          ; next free byte on the heap, into Y
36075               
36076 EB08 D360  30        movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
     EB0A 0031     
36077                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 EB0C D820  42        movb @XX19,@rtmplb
     EB0E 0074     
     EB10 8301     
0002 EB12 D020  30        movb @XX19+1,rtmp
     EB14 0075     
0003 EB16 06CF  14        swpb ry
0004 EB18 A00F  18        a    ry,rtmp
0005 EB1A 06CF  14        swpb ry
0006 EB1C D40D  30        movb RA,*rtmp
                   < elite.a99
36078               
36079 EB1E B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
36080               
36081 EB20 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
     EB22 0032     
36082                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 EB24 D820  42        movb @XX19,@rtmplb
     EB26 0074     
     EB28 8301     
0002 EB2A D020  30        movb @XX19+1,rtmp
     EB2C 0075     
0003 EB2E 06CF  14        swpb ry
0004 EB30 A00F  18        a    ry,rtmp
0005 EB32 06CF  14        swpb ry
0006 EB34 D40D  30        movb RA,*rtmp
                   < elite.a99
36083               
36084 EB36 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
36085               
36086 EB38 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
     EB3A 0033     
36087                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 EB3C D820  42        movb @XX19,@rtmplb
     EB3E 0074     
     EB40 8301     
0002 EB42 D020  30        movb @XX19+1,rtmp
     EB44 0075     
0003 EB46 06CF  14        swpb ry
0004 EB48 A00F  18        a    ry,rtmp
0005 EB4A 06CF  14        swpb ry
0006 EB4C D40D  30        movb RA,*rtmp
                   < elite.a99
36088               
36089 EB4E B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
36090               
36091 EB50 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
     EB52 0034     
36092                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y
     **** ****     > ST_IND_Y_IDX
0001 EB54 D820  42        movb @XX19,@rtmplb
     EB56 0074     
     EB58 8301     
0002 EB5A D020  30        movb @XX19+1,rtmp
     EB5C 0075     
0003 EB5E 06CF  14        swpb ry
0004 EB60 A00F  18        a    ry,rtmp
0005 EB62 06CF  14        swpb ry
0006 EB64 D40D  30        movb RA,*rtmp
                   < elite.a99
36093               
36094 EB66 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
36095               
36096 EB68 D80F  30        movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U
     EB6A 008F     
36097               
36098 EB6C 93E0  30        cb   @T1,ry                     ; CPY T1            ; If Y >= T1 then we have reached the maximum number of
     EB6E 0006     
36099 EB70 1814  14        joc  LL81                       ; BCS LL81          ; edge lines that we can store in the ship line heap, so
36100                                                                          ; skip to LL81 so we don't loop back for the next edge
36101               
36102               LL78:
36103 EB72 B347  18        ab   rone,ra                    ; INC XX17          ; Increment the edge counter to point to the next edge
36104               
36105 EB74 D3E0  30        movb @XX17,ry                   ; LDY XX17          ; If Y >= XX20, which contains the number of edges in
     EB76 0095     
36106 EB78 93E0  30        cb   @XX20,ry                   ; CPY XX20          ; the blueprint, jump to LL81 as we have processed all
     EB7A 00A8     
36107 EB7C 180E  14        joc  LL81                       ; BCS LL81          ; the edges and don't need to loop back for the next one
36108               
36109 EB7E 020F  20        li   ry,>00*256                 ; LDY #0            ; Set Y to point to byte #0 again, ready for the next
     EB80 0000     
36110                                                                          ; edge
36111               
36112 EB82 D360  30        movb @V,ra                      ; LDA V             ; Increment V by 4 so V(1 0) points to the data for the
     EB84 0022     
36113                      .adi (>04*256)                  ; ADC #4            ; next edge
     **** ****     > ADI
0001 EB86 1701  14        jnc  !
0002 EB88 B347  18        ab   rone,ra
0003               !:
0004 EB8A 022D  22        ai   ra,(>04*256)
     EB8C 0400     
                   < elite.a99
36114 EB8E D80D  30        movb ra,@V                      ; STA V
     EB90 0022     
36115               
36116 EB92 1701  14        jnc  ll81_                      ; BCC ll81          ; If the above addition didn't overflow, jump to ll81 to
36117                                                                          ; skip the following instruction
36118               
36119 EB94 B347  18        ab   rone,ra                    ; INC V+1           ; Otherwise increment the high byte of V(1 0), as we
36120                                                                          ; just moved the V(1 0) pointer past a page boundary
36121               
36122               ll81_:
36123 EB96 0460  28        b    @LL75                      ; JMP LL75          ; Loop back to LL75 to process the next edge
     EB98 EA08     
36124               
36125               LL81:
36126                                                                          ; We have finished adding lines to the ship line heap,
36127                                                                          ; so now we need to set the first byte of the heap to
36128                                                                          ; the number of bytes stored there
36129 EB9A D360  30        movb @U,ra                      ; LDA U             ; Fetch the ship line heap pointer from U into A, which
     EB9C 008F     
36130                                                                          ; points to the end of the heap, and therefore contains
36131                                                                          ; the heap size
36132               
36133 EB9E 020F  20        li   ry,>00*256                 ; LDY #0            ; Store A as the first byte of the ship line heap, so
     EBA0 0000     
36134                      .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the heap is now correctly set up
     **** ****     > ST_IND_Y_IDX
0001 EBA2 D820  42        movb @XX19,@rtmplb
     EBA4 0074     
     EBA6 8301     
0002 EBA8 D020  30        movb @XX19+1,rtmp
     EBAA 0075     
0003 EBAC 06CF  14        swpb ry
0004 EBAE A00F  18        a    ry,rtmp
0005 EBB0 06CF  14        swpb ry
0006 EBB2 D40D  30        movb RA,*rtmp
                   < elite.a99
36135               
36136               * ******************************************************************************
36137               *
36138               * Name: LL9 (Part 12 of 12)
36139               * Type: Subroutine
36140               * Category: Drawing ships
36141               * Summary: Draw ship: Draw all the visible edges from the ship line heap
36142               * Deep dive: Drawing ships
36143               *
36144               * ------------------------------------------------------------------------------
36145               *
36146               * This part draws the lines in the ship line heap, which is used both to draw
36147               * the ship, and to remove it from the screen.
36148               *
36149               * ******************************************************************************
36150               
36151               LL155:
36152 EBB4 020F  20        li   ry,>00*256                 ; LDY #0            ; Fetch the first byte from the ship line heap into A,
     EBB6 0000     
36153                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; which contains the number of bytes in the heap
     **** ****     > LD_IND_Y_IDX
0001 EBB8 D820  42        movb @XX19,@rtmplb
     EBBA 0074     
     EBBC 8301     
0002 EBBE D020  30        movb @XX19+1,rtmp
     EBC0 0075     
0003 EBC2 06CF  14        swpb ry
0004 EBC4 A00F  18        a    ry,rtmp
0005 EBC6 06CF  14        swpb ry
0006 EBC8 D350  26        movb *rtmp,RA
                   < elite.a99
36154               
36155 EBCA D80D  30        movb ra,@XX20                   ; STA XX20          ; Store the heap size in XX20
     EBCC 00A8     
36156               
36157 EBCE 028D  22        ci   ra,>04*256                 ; CMP #4            ; If the heap size is less than 4, there is nothing to
     EBD0 0400     
36158 EBD2 1739  14        jnc  LL118-1                    ; BCC LL118-1       ; draw, so return from the subroutine (as LL118-1
36159                                                                          ; contains an RTS)
36160               
36161 EBD4 B3C7  18        ab   rone,ry                    ; INY               ; Set Y = 1, which we will use as an index into the ship
36162                                                                          ; line heap, starting at byte #1 (as byte #0 contains
36163                                                                          ; the heap size)
36164               
36165               LL27:
36166                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 EBD6 D820  42        movb @XX19,@rtmplb
     EBD8 0074     
     EBDA 8301     
0002 EBDC D020  30        movb @XX19+1,rtmp
     EBDE 0075     
0003 EBE0 06CF  14        swpb ry
0004 EBE2 A00F  18        a    ry,rtmp
0005 EBE4 06CF  14        swpb ry
0006 EBE6 D350  26        movb *rtmp,RA
                   < elite.a99
36167 EBE8 D80D  30        movb ra,@XX15                   ; STA XX15          ; it in XX15
     EBEA 0031     
36168               
36169 EBEC B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
36170               
36171                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y1 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 EBEE D820  42        movb @XX19,@rtmplb
     EBF0 0074     
     EBF2 8301     
0002 EBF4 D020  30        movb @XX19+1,rtmp
     EBF6 0075     
0003 EBF8 06CF  14        swpb ry
0004 EBFA A00F  18        a    ry,rtmp
0005 EBFC 06CF  14        swpb ry
0006 EBFE D350  26        movb *rtmp,RA
                   < elite.a99
36172 EC00 D80D  30        movb ra,@XX15+1                 ; STA XX15+1        ; it in XX15+1
     EC02 0032     
36173               
36174 EC04 B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
36175               
36176                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 EC06 D820  42        movb @XX19,@rtmplb
     EC08 0074     
     EC0A 8301     
0002 EC0C D020  30        movb @XX19+1,rtmp
     EC0E 0075     
0003 EC10 06CF  14        swpb ry
0004 EC12 A00F  18        a    ry,rtmp
0005 EC14 06CF  14        swpb ry
0006 EC16 D350  26        movb *rtmp,RA
                   < elite.a99
36177 EC18 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; it in XX15+2
     EC1A 0033     
36178               
36179 EC1C B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
36180               
36181                      .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y2 line coordinate from the heap and store
     **** ****     > LD_IND_Y_IDX
0001 EC1E D820  42        movb @XX19,@rtmplb
     EC20 0074     
     EC22 8301     
0002 EC24 D020  30        movb @XX19+1,rtmp
     EC26 0075     
0003 EC28 06CF  14        swpb ry
0004 EC2A A00F  18        a    ry,rtmp
0005 EC2C 06CF  14        swpb ry
0006 EC2E D350  26        movb *rtmp,RA
                   < elite.a99
36182 EC30 D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; it in XX15+3
     EC32 0034     
36183               
36184 EC34 0200  20        li   rtmp,LL30                  ; JSR LL30          ; Draw a line from (X1, Y1) to (X2, Y2)
     EC36 23BE     
36185 EC38 06A0  32        bl   @jsr                       ;
     EC3A FE28     
36186               
36187 EC3C B3C7  18        ab   rone,ry                    ; INY               ; Increment the heap pointer
36188               
36189 EC3E 93E0  30        cb   @XX20,ry                   ; CPY XX20          ; If the heap counter is less than the size of the heap,
     EC40 00A8     
36190 EC42 17C9  14        jnc  LL27                       ; BCC LL27          ; loop back to LL27 to draw the next line from the heap
36191               
36192               * .LL82                  \ This label is commented out in the original source
36193               
36194 EC44 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     EC46 FE34     
36195               
36196               * ******************************************************************************
36197               *
36198               * Name: LL118
36199               * Type: Subroutine
36200               * Category: Drawing lines
36201               * Summary: Move a point along a line until it is on-screen
36202               * Deep dive: Line-clipping
36203               *
36204               * ------------------------------------------------------------------------------
36205               *
36206               * Given a point (x1, y1), a gradient and a direction of slope, move the point
36207               * along the line until it is on-screen, so this effectively clips the (x1, y1)
36208               * end of a line to be on the screen.
36209               *
36210               * See the deep dive on "Line-clipping" for more details.
36211               *
36212               * ------------------------------------------------------------------------------
36213               *
36214               * Arguments:
36215               *
36216               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
36217               *
36218               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
36219               *
36220               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
36221               *
36222               * XX12+3              The direction of slope:
36223               *
36224               * * Positive (bit 7 clear) = top left to bottom right
36225               *
36226               * * Negative (bit 7 set) = top right to bottom left
36227               *
36228               * T                   The gradient of slope:
36229               *
36230               * * 0 if it's a shallow slope
36231               *
36232               * * &FF if it's a steep slope
36233               *
36234               * ------------------------------------------------------------------------------
36235               *
36236               * Returns:
36237               *
36238               * XX15                x1 as an 8-bit coordinate
36239               *
36240               * XX15+2              y1 as an 8-bit coordinate
36241               *
36242               * ------------------------------------------------------------------------------
36243               *
36244               * Other entry points:
36245               *
36246               * LL118-1             Contains an RTS
36247               *
36248               * ******************************************************************************
36249               
36250               LL118:
36251 EC48 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If x1_hi is positive, jump down to LL119 to skip the
     EC4A 0032     
36252 EC4C 151C  14        jgt  LL119                      ; BPL LL119         ; following
36253               
36254 EC4E D80D  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is negative, i.e. off the left of the
     EC50 0092     
36255                                                                          ; screen, so set S = x1_hi
36256               
36257 EC52 0200  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     EC54 ED64     
36258 EC56 06A0  32        bl   @jsr                       ;
     EC58 FE28     
36259                                                                          ;
36260                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
36261                                                                          ; = x1 * gradient
36262                                                                          ;
36263                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
36264                                                                          ; = x1 / gradient
36265                                                                          ;
36266                                                                          ; with the sign of (Y X) set to the opposite of the
36267                                                                          ; line's direction of slope
36268               
36269 EC5A D34E  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
36270                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 EC5C 0A16  18        sla  rzero,1
                   < elite.a99
36271                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 EC5E 1701  14        jnc  !
0002 EC60 B347  18        ab   rone,ra
0003               !:
0004 EC62 B360  30        ab   @XX15+2,ra
     EC64 0033     
                   < elite.a99
36272 EC66 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     EC68 0033     
36273               
36274 EC6A D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
36275                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 EC6C 1701  14        jnc  !
0002 EC6E B347  18        ab   rone,ra
0003               !:
0004 EC70 B360  30        ab   @XX15+3,ra
     EC72 0034     
                   < elite.a99
36276 EC74 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     EC76 0034     
36277               
36278 EC78 020D  20        li   ra,>00*256                 ; LDA #0            ; Set x1 = 0
     EC7A 0000     
36279 EC7C D80D  30        movb ra,@XX15                   ; STA XX15
     EC7E 0031     
36280 EC80 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     EC82 0032     
36281               
36282 EC84 D38D  18        movb ra,rx                      ; TAX               ; Set X = 0 so the next instruction becomes a JMP
36283               
36284               LL119:
36285 EC86 131D  14        jeq  LL134                      ; BEQ LL134         ; If x1_hi = 0 then jump down to LL134 to skip the
36286                                                                          ; following, as the x-coordinate is already on-screen
36287                                                                          ; (as 0 <= (x_hi x_lo) <= 255)
36288               
36289 EC88 D80D  30        movb ra,@S                      ; STA S             ; Otherwise x1_hi is positive, i.e. x1 >= 256 and off
     EC8A 0092     
36290 EC8C 7347  18        sb   rone,ra                    ; DEC S             ; the right side of the screen, so set S = x1_hi - 1
36291               
36292 EC8E 0200  20        li   rtmp,LL120                 ; JSR LL120         ; Call LL120 to calculate:
     EC90 ED64     
36293 EC92 06A0  32        bl   @jsr                       ;
     EC94 FE28     
36294                                                                          ;
36295                                                                          ; (Y X) = (S x1_lo) * XX12+2      if T = 0
36296                                                                          ; = (x1 - 256) * gradient
36297                                                                          ;
36298                                                                          ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
36299                                                                          ; = (x1 - 256) / gradient
36300                                                                          ;
36301                                                                          ; with the sign of (Y X) set to the opposite of the
36302                                                                          ; line's direction of slope
36303               
36304 EC96 D34E  18        movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
36305                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 EC98 0A16  18        sla  rzero,1
                   < elite.a99
36306                      .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
     **** ****     > ADC
0001 EC9A 1701  14        jnc  !
0002 EC9C B347  18        ab   rone,ra
0003               !:
0004 EC9E B360  30        ab   @XX15+2,ra
     ECA0 0033     
                   < elite.a99
36307 ECA2 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     ECA4 0033     
36308               
36309 ECA6 D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
36310                      .adc @XX15+3,ra                 ; ADC XX15+3
     **** ****     > ADC
0001 ECA8 1701  14        jnc  !
0002 ECAA B347  18        ab   rone,ra
0003               !:
0004 ECAC B360  30        ab   @XX15+3,ra
     ECAE 0034     
                   < elite.a99
36311 ECB0 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     ECB2 0034     
36312               
36313 ECB4 020E  20        li   rx,>ff*256                 ; LDX #255          ; Set x1 = 255
     ECB6 FF00     
36314 ECB8 D80E  30        movb rx,@XX15                   ; STX XX15
     ECBA 0031     
36315 ECBC B387  18        ab   rone,rx                    ; INX
36316 ECBE D80E  30        movb rx,@XX15+1                 ; STX XX15+1
     ECC0 0032     
36317               
36318               LL134:
36319                                                                          ; We have moved the point so the x-coordinate is on
36320                                                                          ; screen (i.e. in the range 0-255), so now for the
36321                                                                          ; y-coordinate
36322 ECC2 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If y1_hi is positive, jump down to LL119 to skip
     ECC4 0034     
36323 ECC6 151F  14        jgt  LL135                      ; BPL LL135         ; the following
36324               
36325 ECC8 D80D  30        movb ra,@S                      ; STA S             ; Otherwise y1_hi is negative, i.e. off the top of the
     ECCA 0092     
36326                                                                          ; screen, so set S = y1_hi
36327               
36328 ECCC D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = y1_lo
     ECCE 0033     
36329 ECD0 D80D  30        movb ra,@R                      ; STA R
     ECD2 0091     
36330               
36331 ECD4 0200  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     ECD6 EDF0     
36332 ECD8 06A0  32        bl   @jsr                       ;
     ECDA FE28     
36333                                                                          ;
36334                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
36335                                                                          ; = y1 / gradient
36336                                                                          ;
36337                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
36338                                                                          ; = y1 * gradient
36339                                                                          ;
36340                                                                          ; with the sign of (Y X) set to the opposite of the
36341                                                                          ; line's direction of slope
36342               
36343 ECDC D34E  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
36344                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 ECDE 0A16  18        sla  rzero,1
                   < elite.a99
36345                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 ECE0 1701  14        jnc  !
0002 ECE2 B347  18        ab   rone,ra
0003               !:
0004 ECE4 B360  30        ab   @XX15,ra
     ECE6 0031     
                   < elite.a99
36346 ECE8 D80D  30        movb ra,@XX15                   ; STA XX15
     ECEA 0031     
36347               
36348 ECEC D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
36349                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 ECEE 1701  14        jnc  !
0002 ECF0 B347  18        ab   rone,ra
0003               !:
0004 ECF2 B360  30        ab   @XX15+1,ra
     ECF4 0032     
                   < elite.a99
36350 ECF6 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     ECF8 0032     
36351               
36352 ECFA 020D  20        li   ra,>00*256                 ; LDA #0            ; Set y1 = 0
     ECFC 0000     
36353 ECFE D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     ED00 0033     
36354 ED02 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     ED04 0034     
36355               
36356               LL135:
36357               * BNE LL139              \ This instruction is commented out in the original
36358                                                                          ; source
36359 ED06 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set (S R) = (y1_hi y1_lo) - screen height
     ED08 0033     
36360                      .sec                            ; SEC               ;
     **** ****     > SEC
0001 ED0A 0A18  18        sla  rmone,1
                   < elite.a99
36361                      .sbi ((Y*2)*256)                ; SBC #Y*2          ; starting with the low bytes
     **** ****     > SBI
0001 ED0C 1801  14        joc  !
0002 ED0E 7347  18        sb   rone,ra
0003               !:
0004 ED10 022D  22        ai   ra,-((Y*2)*256)
     ED12 4000     
                   < elite.a99
36362 ED14 D80D  30        movb ra,@R                      ; STA R
     ED16 0091     
36363               
36364 ED18 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; And then subtracting the high bytes
     ED1A 0034     
36365                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 ED1C 1801  14        joc  !
0002 ED1E 7347  18        sb   rone,ra
0003               !:
0004 ED20 022D  22        ai   ra,-(>00*256)
     ED22 0000     
                   < elite.a99
36366 ED24 D80D  30        movb ra,@S                      ; STA S
     ED26 0092     
36367               
36368 ED28 171B  14        jnc  LL136                      ; BCC LL136         ; If the subtraction underflowed, i.e. if y1 < screen
36369                                                                          ; height, then y1 is already on-screen, so jump to LL136
36370                                                                          ; to return from the subroutine, as we are done
36371               
36372               LL139:
36373                                                                          ; If we get here then y1 >= screen height, i.e. off the
36374                                                                          ; bottom of the screen
36375 ED2A 0200  20        li   rtmp,LL123                 ; JSR LL123         ; Call LL123 to calculate:
     ED2C EDF0     
36376 ED2E 06A0  32        bl   @jsr                       ;
     ED30 FE28     
36377                                                                          ;
36378                                                                          ; (Y X) = (S R) / XX12+2      if T = 0
36379                                                                          ; = (y1 - screen height) / gradient
36380                                                                          ;
36381                                                                          ; (Y X) = (S R) * XX12+2      if T <> 0
36382                                                                          ; = (y1 - screen height) * gradient
36383                                                                          ;
36384                                                                          ; with the sign of (Y X) set to the opposite of the
36385                                                                          ; line's direction of slope
36386               
36387 ED32 D34E  18        movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
36388                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 ED34 0A16  18        sla  rzero,1
                   < elite.a99
36389                      .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
     **** ****     > ADC
0001 ED36 1701  14        jnc  !
0002 ED38 B347  18        ab   rone,ra
0003               !:
0004 ED3A B360  30        ab   @XX15,ra
     ED3C 0031     
                   < elite.a99
36390 ED3E D80D  30        movb ra,@XX15                   ; STA XX15
     ED40 0031     
36391               
36392 ED42 D34F  18        movb ry,ra                      ; TYA               ; And then adding the high bytes
36393                      .adc @XX15+1,ra                 ; ADC XX15+1
     **** ****     > ADC
0001 ED44 1701  14        jnc  !
0002 ED46 B347  18        ab   rone,ra
0003               !:
0004 ED48 B360  30        ab   @XX15+1,ra
     ED4A 0032     
                   < elite.a99
36394 ED4C D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     ED4E 0032     
36395               
36396 ED50 020D  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; Set y1 = 2 * #Y - 1. The constant #Y is 96, the
     ED52 BF00     
36397 ED54 D80D  30        movb ra,@XX15+2                 ; STA XX15+2        ; y-coordinate of the mid-point of the space view, so
     ED56 0033     
36398 ED58 020D  20        li   ra,>00*256                 ; LDA #0            ; this sets Y2 to 191, the y-coordinate of the bottom
     ED5A 0000     
36399 ED5C D80D  30        movb ra,@XX15+3                 ; STA XX15+3        ; pixel row of the space view
     ED5E 0034     
36400               
36401               LL136:
36402 ED60 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     ED62 FE34     
36403               
36404               * ******************************************************************************
36405               *
36406               * Name: LL120
36407               * Type: Subroutine
36408               * Category: Maths (Arithmetic)
36409               * Summary: Calculate (Y X) = (S x1_lo) * XX12+2 or (S x1_lo) / XX12+2
36410               *
36411               * ------------------------------------------------------------------------------
36412               *
36413               * Calculate the following:
36414               *
36415               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
36416               *
36417               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
36418               *
36419               * giving (Y X) the opposite sign to the slope direction in XX12+3.
36420               *
36421               * ------------------------------------------------------------------------------
36422               *
36423               * Arguments:
36424               *
36425               * T                   The gradient of slope:
36426               *
36427               * * 0 if it's a shallow slope
36428               *
36429               * * &FF if it's a steep slope
36430               *
36431               * ------------------------------------------------------------------------------
36432               *
36433               * Other entry points:
36434               *
36435               * LL122               Calculate (Y X) = (S R) * Q and set the sign to the
36436               * opposite of the top byte on the stack
36437               *
36438               * ******************************************************************************
36439               
36440               LL120:
36441 ED64 D360  30        movb @XX15,ra                   ; LDA XX15          ; Set R = x1_lo
     ED66 0031     
36442 ED68 D80D  30        movb ra,@R                      ; STA R
     ED6A 0091     
36443               
36444               * .LL120                 \ This label is commented out in the original source
36445               
36446 ED6C 0200  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     ED6E EE90     
36447 ED70 06A0  32        bl   @jsr                       ;
     ED72 FE28     
36448                                                                          ;
36449                                                                          ; Q = XX12+2
36450                                                                          ; = line gradient
36451                                                                          ;
36452                                                                          ; A = S EOR XX12+3
36453                                                                          ; = S EOR slope direction
36454                                                                          ;
36455                                                                          ; (S R) = |S R|
36456                                                                          ;
36457                                                                          ; So A contains the sign of S * slope direction
36458               
36459                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 ED74 D68D  30        movb ra,*rsp
0002 ED76 060A  14        dec  rsp
                   < elite.a99
36460               
36461 ED78 D3A0  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump
     ED7A 00D1     
36462 ED7C 1642  14        jne  LL121                      ; BNE LL121         ; down to LL121 to calculate this instead:
36463                                                                          ;
36464                                                                          ; (Y X) = (S R) / Q
36465               
36466               LL122:
36467                                                                          ; The following calculates:
36468                                                                          ;
36469                                                                          ; (Y X) = (S R) * Q
36470                                                                          ;
36471                                                                          ; using the same shift-and-add algorithm that's
36472                                                                          ; documented in MULT1
36473 ED7E 020D  20        li   ra,>00*256                 ; LDA #0            ; Set A = 0
     ED80 0000     
36474               
36475 ED82 D38D  18        movb ra,rx                      ; TAX               ; Set (Y X) = 0 so we can start building the answer here
36476 ED84 D3CD  18        movb ra,ry                      ; TAY
36477               
36478                      .lsr @S                         ; LSR S             ; Shift (S R) to the right, so we extract bit 0 of (S R)
     **** ****     > LSR
0001 ED86 D020  30        movb @S,rtmp
     ED88 0092     
0002 ED8A 0910  18        srl  rtmp,1
0003 ED8C D800  30        movb rtmp,@S
     ED8E 0092     
                   < elite.a99
36479 ED90 0204  20        li   rarg1,R                    ; ROR R             ; into the C flag
     ED92 0091     
36480 ED94 06A0  32        bl   @ror                       ;
     ED96 FE7A     
36481               
36482                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 ED98 D020  30        movb @Q,rtmp
     ED9A 0090     
0002 ED9C 0240  22        andi rtmp,>ff00
     ED9E FF00     
0003 EDA0 0A10  18        sla  rtmp,1
0004 EDA2 D800  30        movb rtmp,@Q
     EDA4 0090     
                   < elite.a99
36483               
36484 EDA6 170D  14        jnc  LL126                      ; BCC LL126         ; If C (i.e. the next bit from Q) is clear, do not do
36485                                                                          ; the addition for this bit of Q, and instead skip to
36486                                                                          ; LL126 to just do the shifts
36487               
36488               LL125:
36489 EDA8 D34E  18        movb rx,ra                      ; TXA               ; Set (Y X) = (Y X) + (S R)
36490                      .clc                            ; CLC               ;
     **** ****     > CLC
0001 EDAA 0A16  18        sla  rzero,1
                   < elite.a99
36491                      .adc @R,ra                      ; ADC R             ; starting with the low bytes
     **** ****     > ADC
0001 EDAC 1701  14        jnc  !
0002 EDAE B347  18        ab   rone,ra
0003               !:
0004 EDB0 B360  30        ab   @R,ra
     EDB2 0091     
                   < elite.a99
36492 EDB4 D38D  18        movb ra,rx                      ; TAX
36493               
36494 EDB6 D34F  18        movb ry,ra                      ; TYA               ; And then doing the high bytes
36495                      .adc @S,ra                      ; ADC S
     **** ****     > ADC
0001 EDB8 1701  14        jnc  !
0002 EDBA B347  18        ab   rone,ra
0003               !:
0004 EDBC B360  30        ab   @S,ra
     EDBE 0092     
                   < elite.a99
36496 EDC0 D3CD  18        movb ra,ry                      ; TAY
36497               
36498               LL126:
36499                      .lsr @S                         ; LSR S             ; Shift (S R) to the right
     **** ****     > LSR
0001 EDC2 D020  30        movb @S,rtmp
     EDC4 0092     
0002 EDC6 0910  18        srl  rtmp,1
0003 EDC8 D800  30        movb rtmp,@S
     EDCA 0092     
                   < elite.a99
36500 EDCC 0204  20        li   rarg1,R                    ; ROR R
     EDCE 0091     
36501 EDD0 06A0  32        bl   @ror                       ;
     EDD2 FE7A     
36502               
36503                      .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag
     **** ****     > ASL
0001 EDD4 D020  30        movb @Q,rtmp
     EDD6 0090     
0002 EDD8 0240  22        andi rtmp,>ff00
     EDDA FF00     
0003 EDDC 0A10  18        sla  rtmp,1
0004 EDDE D800  30        movb rtmp,@Q
     EDE0 0090     
                   < elite.a99
36504               
36505 EDE2 18E2  14        joc  LL125                      ; BCS LL125         ; If C (i.e. the next bit from Q) is set, loop back to
36506                                                                          ; LL125 to do the addition for this bit of Q
36507               
36508 EDE4 16EE  14        jne  LL126                      ; BNE LL126         ; If Q has not yet run out of set bits, loop back to
36509                                                                          ; LL126 to do the "shift" part of shift-and-add until
36510                                                                          ; we have done additions for all the set bits in Q, to
36511                                                                          ; give us our multiplication result
36512               
36513                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 EDE6 058A  14        inc  rsp
0002 EDE8 D35A  26        movb *rsp,ra
                   < elite.a99
36514               
36515 EDEA 153E  14        jgt  LL133                      ; BPL LL133         ; If A is positive jump to LL133 to negate (Y X) and
36516                                                                          ; return from the subroutine using a tail call
36517               
36518 EDEC 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     EDEE FE34     
36519               
36520               * ******************************************************************************
36521               *
36522               * Name: LL123
36523               * Type: Subroutine
36524               * Category: Maths (Arithmetic)
36525               * Summary: Calculate (Y X) = (S R) / XX12+2 or (S R) * XX12+2
36526               *
36527               * ------------------------------------------------------------------------------
36528               *
36529               * Calculate the following:
36530               *
36531               * * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2
36532               *
36533               * * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2
36534               *
36535               * giving (Y X) the opposite sign to the slope direction in XX12+3.
36536               *
36537               * ------------------------------------------------------------------------------
36538               *
36539               * Arguments:
36540               *
36541               * XX12+2              The line's gradient * 256 (so 1.0 = 256)
36542               *
36543               * XX12+3              The direction of slope:
36544               *
36545               * * Bit 7 clear means top left to bottom right
36546               *
36547               * * Bit 7 set means top right to bottom left
36548               *
36549               * T                   The gradient of slope:
36550               *
36551               * * 0 if it's a shallow slope
36552               *
36553               * * &FF if it's a steep slope
36554               *
36555               * ------------------------------------------------------------------------------
36556               *
36557               * Other entry points:
36558               *
36559               * LL121               Calculate (Y X) = (S R) / Q and set the sign to the
36560               * opposite of the top byte on the stack
36561               *
36562               * LL133               Negate (Y X) and return from the subroutine
36563               *
36564               * LL128               Contains an RTS
36565               *
36566               * ******************************************************************************
36567               
36568               LL123:
36569 EDF0 0200  20        li   rtmp,LL129                 ; JSR LL129         ; Call LL129 to do the following:
     EDF2 EE90     
36570 EDF4 06A0  32        bl   @jsr                       ;
     EDF6 FE28     
36571                                                                          ;
36572                                                                          ; Q = XX12+2
36573                                                                          ; = line gradient
36574                                                                          ;
36575                                                                          ; A = S EOR XX12+3
36576                                                                          ; = S EOR slope direction
36577                                                                          ;
36578                                                                          ; (S R) = |S R|
36579                                                                          ;
36580                                                                          ; So A contains the sign of S * slope direction
36581               
36582                      .pha                            ; PHA               ; Store A on the stack so we can use it later
     **** ****     > PHA
0001 EDF8 D68D  30        movb ra,*rsp
0002 EDFA 060A  14        dec  rsp
                   < elite.a99
36583               
36584 EDFC D3A0  30        movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump up
     EDFE 00D1     
36585 EE00 16BE  14        jne  LL122                      ; BNE LL122         ; to LL122 to calculate this instead:
36586                                                                          ;
36587                                                                          ; (Y X) = (S R) * Q
36588               
36589               LL121:
36590                                                                          ; The following calculates:
36591                                                                          ;
36592                                                                          ; (Y X) = (S R) / Q
36593                                                                          ;
36594                                                                          ; using the same shift-and-subtract algorithm that's
36595                                                                          ; documented in TIS2
36596 EE02 020D  20        li   ra,>ff*256                 ; LDA #%11111111    ; Set Y = %11111111
     EE04 FF00     
36597 EE06 D3CD  18        movb ra,ry                      ; TAY
36598               
36599                      .asla                           ; ASL A             ; Set X = %11111110
     **** ****     > ASLA
0001 EE08 024D  22        andi ra,>ff00
     EE0A FF00     
0002 EE0C 0A1D  18        sla  ra,1
                   < elite.a99
36600 EE0E D38D  18        movb ra,rx                      ; TAX
36601               
36602                                                                          ; This sets (Y X) = %1111111111111110, so we can rotate
36603                                                                          ; through 15 loop iterations, getting a 1 each time, and
36604                                                                          ; then getting a 0 on the 16th iteration... and we can
36605                                                                          ; also use it to catch our result bits into bit 0 each
36606                                                                          ; time
36607               
36608               LL130:
36609                      .asl @R                         ; ASL R             ; Shift (S R) to the left
     **** ****     > ASL
0001 EE10 D020  30        movb @R,rtmp
     EE12 0091     
0002 EE14 0240  22        andi rtmp,>ff00
     EE16 FF00     
0003 EE18 0A10  18        sla  rtmp,1
0004 EE1A D800  30        movb rtmp,@R
     EE1C 0091     
                   < elite.a99
36610 EE1E 0204  20        li   rarg1,S                    ; ROL S
     EE20 0092     
36611 EE22 06A0  32        bl   @rol                       ;
     EE24 FE4E     
36612               
36613 EE26 D360  30        movb @S,ra                      ; LDA S             ; Set A = S
     EE28 0092     
36614               
36615 EE2A 1803  14        joc  LL131                      ; BCS LL131         ; If bit 7 of S was set, then jump straight to the
36616                                                                          ; subtraction
36617               
36618 EE2C 9360  30        cb   @Q,ra                      ; CMP Q             ; If A < Q (i.e. S < Q), skip the following subtractions
     EE2E 0090     
36619 EE30 170F  14        jnc  LL132                      ; BCC LL132
36620               
36621               LL131:
36622                      .sbc @Q,ra                      ; SBC Q             ; A >= Q (i.e. S >= Q) so set:
     **** ****     > SBC
0001 EE32 1801  14        joc  !
0002 EE34 7347  18        sb   rone,ra
0003               !:
0004 EE36 7360  30        sb   @Q,ra
     EE38 0090     
                   < elite.a99
36623 EE3A D80D  30        movb ra,@S                      ; STA S             ;
     EE3C 0092     
36624                                                                          ; S = (A R) - Q
36625                                                                          ; = (S R) - Q
36626                                                                          ;
36627                                                                          ; starting with the low bytes (we know the C flag is
36628                                                                          ; set so the subtraction will be correct)
36629               
36630 EE3E D360  30        movb @R,ra                      ; LDA R             ; And then doing the high bytes
     EE40 0091     
36631                      .sbi (>00*256)                  ; SBC #0
     **** ****     > SBI
0001 EE42 1801  14        joc  !
0002 EE44 7347  18        sb   rone,ra
0003               !:
0004 EE46 022D  22        ai   ra,-(>00*256)
     EE48 0000     
                   < elite.a99
36632 EE4A D80D  30        movb ra,@R                      ; STA R
     EE4C 0091     
36633               
36634                      .sec                            ; SEC               ; Set the C flag to rotate into the result in (Y X)
     **** ****     > SEC
0001 EE4E 0A18  18        sla  rmone,1
                   < elite.a99
36635               
36636               LL132:
36637 EE50 D34E  18        movb rx,ra                      ; TXA               ; Rotate the counter in (Y X) to the left, and catch the
36638 EE52 06A0  32        bl   @rola                      ; ROL A             ; result bit into bit 0 (which will be a 0 if we didn't
     EE54 FE3E     
36639 EE56 D38D  18        movb ra,rx                      ; TAX               ; do the subtraction, or 1 if we did)
36640 EE58 D34F  18        movb ry,ra                      ; TYA
36641 EE5A 06A0  32        bl   @rola                      ; ROL A
     EE5C FE3E     
36642 EE5E D3CD  18        movb ra,ry                      ; TAY
36643               
36644 EE60 18D7  14        joc  LL130                      ; BCS LL130         ; If we still have set bits in (Y X), loop back to LL130
36645                                                                          ; to do the next iteration of 15, until we have done the
36646                                                                          ; whole division
36647               
36648                      .pla                            ; PLA               ; Restore A, which we calculated above, from the stack
     **** ****     > PLA
0001 EE62 058A  14        inc  rsp
0002 EE64 D35A  26        movb *rsp,ra
                   < elite.a99
36649               
36650 EE66 1112  14        jlt  LL128                      ; BMI LL128         ; If A is negative jump to LL128 to return from the
36651                                                                          ; subroutine with (Y X) as is
36652               
36653               LL133:
36654 EE68 D34E  18        movb rx,ra                      ; TXA               ; Otherwise negate (Y X) using two's complement by first
36655                      .eoi (>ff*256)                  ; EOR #%11111111    ; setting the low byte to ~X + 1
     **** ****     > EOI
0001 EE6A 0200  20        li   rtmp,(>FF*256)
     EE6C FF00     
0002 EE6E 2B40  18        xor  rtmp,ra
                   < elite.a99
36656               * CLC                    \
36657                      .adi (>01*256)                  ; ADC #1            ; The CLC instruction is commented out in the original
     **** ****     > ADI
0001 EE70 1701  14        jnc  !
0002 EE72 B347  18        ab   rone,ra
0003               !:
0004 EE74 022D  22        ai   ra,(>01*256)
     EE76 0100     
                   < elite.a99
36658 EE78 D38D  18        movb ra,rx                      ; TAX               ; source. It would have no effect as we know the C flag
36659                                                                          ; is clear from when we passed through the BCS above
36660               
36661 EE7A D34F  18        movb ry,ra                      ; TYA               ; Then set the high byte to ~Y + C
36662                      .eoi (>ff*256)                  ; EOR #%11111111
     **** ****     > EOI
0001 EE7C 0200  20        li   rtmp,(>FF*256)
     EE7E FF00     
0002 EE80 2B40  18        xor  rtmp,ra
                   < elite.a99
36663                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 EE82 1701  14        jnc  !
0002 EE84 B347  18        ab   rone,ra
0003               !:
0004 EE86 022D  22        ai   ra,(>00*256)
     EE88 0000     
                   < elite.a99
36664 EE8A D3CD  18        movb ra,ry                      ; TAY
36665               
36666               LL128:
36667 EE8C 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     EE8E FE34     
36668               
36669               * ******************************************************************************
36670               *
36671               * Name: LL129
36672               * Type: Subroutine
36673               * Category: Maths (Arithmetic)
36674               * Summary: Calculate Q = XX12+2, A = S EOR XX12+3 and (S R) = |S R|
36675               *
36676               * ------------------------------------------------------------------------------
36677               *
36678               * Do the following, in this order:
36679               *
36680               * Q = XX12+2
36681               *
36682               * A = S EOR XX12+3
36683               *
36684               * (S R) = |S R|
36685               *
36686               * This sets up the variables required above to calculate (S R) / XX12+2 and give
36687               * the result the opposite sign to XX13+3.
36688               *
36689               * ******************************************************************************
36690               
36691               LL129:
36692 EE90 D3A0  30        movb @XX12+2,rx                 ; LDX XX12+2        ; Set Q = XX12+2
     EE92 0039     
36693 EE94 D80E  30        movb rx,@Q                      ; STX Q
     EE96 0090     
36694               
36695 EE98 D360  30        movb @S,ra                      ; LDA S             ; If S is positive, jump to LL127
     EE9A 0092     
36696 EE9C 1518  14        jgt  LL127                      ; BPL LL127
36697               
36698 EE9E 020D  20        li   ra,>00*256                 ; LDA #0            ; Otherwise set R = -R
     EEA0 0000     
36699                      .sec                            ; SEC
     **** ****     > SEC
0001 EEA2 0A18  18        sla  rmone,1
                   < elite.a99
36700                      .sbc @R,ra                      ; SBC R
     **** ****     > SBC
0001 EEA4 1801  14        joc  !
0002 EEA6 7347  18        sb   rone,ra
0003               !:
0004 EEA8 7360  30        sb   @R,ra
     EEAA 0091     
                   < elite.a99
36701 EEAC D80D  30        movb ra,@R                      ; STA R
     EEAE 0091     
36702               
36703 EEB0 D360  30        movb @S,ra                      ; LDA S             ; Push S onto the stack
     EEB2 0092     
36704                      .pha                            ; PHA
     **** ****     > PHA
0001 EEB4 D68D  30        movb ra,*rsp
0002 EEB6 060A  14        dec  rsp
                   < elite.a99
36705               
36706                      .eoi (>ff*256)                  ; EOR #%11111111    ; Set S = ~S + 1 + C
     **** ****     > EOI
0001 EEB8 0200  20        li   rtmp,(>FF*256)
     EEBA FF00     
0002 EEBC 2B40  18        xor  rtmp,ra
                   < elite.a99
36707                      .adi (>00*256)                  ; ADC #0
     **** ****     > ADI
0001 EEBE 1701  14        jnc  !
0002 EEC0 B347  18        ab   rone,ra
0003               !:
0004 EEC2 022D  22        ai   ra,(>00*256)
     EEC4 0000     
                   < elite.a99
36708 EEC6 D80D  30        movb ra,@S                      ; STA S
     EEC8 0092     
36709               
36710                      .pla                            ; PLA               ; Pull the original, negative S from the stack into A
     **** ****     > PLA
0001 EECA 058A  14        inc  rsp
0002 EECC D35A  26        movb *rsp,ra
                   < elite.a99
36711               
36712               LL127:
36713                      .eor @XX12+3                    ; EOR XX12+3        ; Set A = original argument S EOR'd with XX12+3
     **** ****     > EOR
0001 EECE D020  30        movb @XX12+3,rtmp
     EED0 003A     
0002 EED2 2B40  18        xor  rtmp,ra
                   < elite.a99
36714               
36715 EED4 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     EED6 FE34     
36716               
36717               * ******************************************************************************
36718               *
36719               * Name: LL145 (Part 1 of 4)
36720               * Type: Subroutine
36721               * Category: Drawing lines
36722               * Summary: Clip line: Work out which end-points are on-screen, if any
36723               * Deep dive: Line-clipping
36724               * Extended screen coordinates
36725               *
36726               * ------------------------------------------------------------------------------
36727               *
36728               * This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or
36729               * returns an error if it can't be clipped to fit. The arguments are 16-bit
36730               * coordinates, and the clipped line is returned using 8-bit screen coordinates.
36731               *
36732               * This part sets XX13 to reflect which of the two points are on-screen and
36733               * off-screen.
36734               *
36735               * ------------------------------------------------------------------------------
36736               *
36737               * Arguments:
36738               *
36739               * XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
36740               *
36741               * XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
36742               *
36743               * XX15(5 4)           x2 as a 16-bit coordinate (x2_hi x2_lo)
36744               *
36745               * XX12(1 0)           y2 as a 16-bit coordinate (y2_hi y2_lo)
36746               *
36747               * ------------------------------------------------------------------------------
36748               *
36749               * Returns:
36750               *
36751               * (X1, Y1)            Screen coordinate of the start of the clipped line
36752               *
36753               * (X2, Y2)            Screen coordinate of the end of the clipped line
36754               *
36755               * C flag              Clear if the clipped line fits on-screen, set if it
36756               * doesn't
36757               *
36758               * XX13                The state of the original coordinates on-screen:
36759               *
36760               * * 0   = (x2, y2) on-screen
36761               *
36762               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36763               *
36764               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36765               *
36766               * So XX13 is non-zero if the end of the line was clipped,
36767               * meaning the next line sent to BLINE can't join onto the
36768               * end but has to start a new segment
36769               *
36770               * SWAP                The swap status of the returned coordinates:
36771               *
36772               * * &FF if we swapped the values of (x1, y1) and
36773               * (x2, y2) as part of the clipping process
36774               *
36775               * * 0 if the coordinates are still in the same order
36776               *
36777               * Y                   Y is preserved
36778               *
36779               * ------------------------------------------------------------------------------
36780               *
36781               * Other entry points:
36782               *
36783               * LL147               Don't initialise the values in SWAP or A
36784               *
36785               * ******************************************************************************
36786               
36787               LL145:
36788 EED8 020D  20        li   ra,>00*256                 ; LDA #0            ; Set SWAP = 0
     EEDA 0000     
36789 EEDC D80D  30        movb ra,@SWAP                   ; STA SWAP
     EEDE 00A1     
36790               
36791 EEE0 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = x2_hi
     EEE2 0036     
36792               
36793               LL147:
36794 EEE4 020E  20        li   rx,(Y*2-1)*256             ; LDX #Y*2-1        ; Set X = #Y * 2 - 1. The constant #Y is 96, the
     EEE6 BF00     
36795                                                                          ; y-coordinate of the mid-point of the space view, so
36796                                                                          ; this sets Y2 to 191, the y-coordinate of the bottom
36797                                                                          ; pixel row of the space view
36798               
36799 EEE8 F360  30        socb @XX12+1,ra                 ; ORA XX12+1        ; If one or both of x2_hi and y2_hi are non-zero, jump
     EEEA 0038     
36800 EEEC 1605  14        jne  LL107                      ; BNE LL107         ; to LL107 to skip the following, leaving X at 191
36801               
36802 EEEE 93A0  30        cb   @XX12,rx                   ; CPX XX12          ; If y2_lo > the y-coordinate of the bottom of screen
     EEF0 0037     
36803 EEF2 1702  14        jnc  LL107                      ; BCC LL107         ; then (x2, y2) is off the bottom of the screen, so skip
36804                                                                          ; the following instruction, leaving X at 191
36805               
36806 EEF4 020E  20        li   rx,>00*256                 ; LDX #0            ; Set X = 0
     EEF6 0000     
36807               
36808               LL107:
36809 EEF8 D80E  30        movb rx,@XX13                   ; STX XX13          ; Set XX13 = X, so we have:
     EEFA 0098     
36810                                                                          ;
36811                                                                          ; * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen
36812                                                                          ;
36813                                                                          ; * XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo
36814                                                                          ; is off the bottom of the screen
36815                                                                          ;
36816                                                                          ; In other words, XX13 is 191 if (x2, y2) is off-screen,
36817                                                                          ; otherwise it is 0
36818               
36819 EEFC D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If one or both of x1_hi and y1_hi are non-zero, jump
     EEFE 0032     
36820 EF00 F360  30        socb @XX15+3,ra                 ; ORA XX15+3        ; to LL83
     EF02 0034     
36821 EF04 161F  14        jne  LL83                       ; BNE LL83
36822               
36823 EF06 020D  20        li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; If y1_lo > the y-coordinate of the bottom of screen
     EF08 BF00     
36824 EF0A 9360  30        cb   @XX15+2,ra                 ; CMP XX15+2        ; then (x1, y1) is off the bottom of the screen, so jump
     EF0C 0033     
36825 EF0E 171A  14        jnc  LL83                       ; BCC LL83          ; to LL83
36826               
36827                                                                          ; If we get here, (x1, y1) is on-screen
36828               
36829 EF10 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
     EF12 0098     
36830 EF14 1612  14        jne  LL108                      ; BNE LL108         ; to LL108 to halve it before continuing at LL83
36831               
36832                                                                          ; If we get here, the high bytes are all zero, which
36833                                                                          ; means the x-coordinates are < 256 and therefore fit on
36834                                                                          ; screen, and neither coordinate is off the bottom of
36835                                                                          ; the screen. That means both coordinates are already on
36836                                                                          ; screen, so we don't need to do any clipping, all we
36837                                                                          ; need to do is move the low bytes into (X1, Y1) and
36838                                                                          ; X2, Y2) and return
36839               
36840               LL146:
36841                                                                          ; If we get here then we have clipped our line to the
36842                                                                          ; screen edge (if we had to clip it at all), so we move
36843                                                                          ; the low bytes from (x1, y1) and (x2, y2) into (X1, Y1)
36844                                                                          ; and (X2, Y2), remembering that they share locations
36845                                                                          ; with XX15:
36846                                                                          ;
36847                                                                          ; X1 = XX15
36848                                                                          ; Y1 = XX15+1
36849                                                                          ; X2 = XX15+2
36850                                                                          ; Y2 = XX15+3
36851                                                                          ;
36852                                                                          ; X1 already contains x1_lo, so now we do the rest
36853 EF16 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; Set Y1 (aka XX15+1) = y1_lo
     EF18 0033     
36854 EF1A D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     EF1C 0032     
36855               
36856 EF1E D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set X2 (aka XX15+2) = x2_lo
     EF20 0035     
36857 EF22 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     EF24 0033     
36858               
36859 EF26 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set Y2 (aka XX15+3) = y2_lo
     EF28 0037     
36860 EF2A D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     EF2C 0034     
36861               
36862                      .clc                            ; CLC               ; Clear the C flag as the clipped line fits on-screen
     **** ****     > CLC
0001 EF2E 0A16  18        sla  rzero,1
                   < elite.a99
36863               
36864 EF30 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     EF32 FE34     
36865               
36866               LL109:
36867                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 EF34 0A18  18        sla  rmone,1
                   < elite.a99
36868                                                                          ; fit on-screen
36869               
36870 EF36 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     EF38 FE34     
36871               
36872               LL108:
36873                      .lsr @XX13                      ; LSR XX13          ; If we get here then (x2, y2) is off-screen and XX13 is
     **** ****     > LSR
0001 EF3A D020  30        movb @XX13,rtmp
     EF3C 0098     
0002 EF3E 0910  18        srl  rtmp,1
0003 EF40 D800  30        movb rtmp,@XX13
     EF42 0098     
                   < elite.a99
36874                                                                          ; 191, so shift XX13 right to halve it to 95
36875               
36876               * ******************************************************************************
36877               *
36878               * Name: LL145 (Part 2 of 4)
36879               * Type: Subroutine
36880               * Category: Drawing lines
36881               * Summary: Clip line: Work out if any part of the line is on-screen
36882               * Deep dive: Line-clipping
36883               * Extended screen coordinates
36884               *
36885               * ------------------------------------------------------------------------------
36886               *
36887               * This part does a number of tests to see if the line is on or off the screen.
36888               *
36889               * If we get here then at least one of (x1, y1) and (x2, y2) is off-screen, with
36890               * XX13 set as follows:
36891               *
36892               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
36893               *
36894               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
36895               *
36896               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
36897               *
36898               * where "off-screen" is defined as having a non-zero high byte in one of the
36899               * coordinates, or in the case of y-coordinates, having a low byte > 191, the
36900               * y-coordinate of the bottom of the space view.
36901               *
36902               * ******************************************************************************
36903               
36904               LL83:
36905 EF44 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 < 128 then only one of the points is on-screen
     EF46 0098     
36906 EF48 1533  14        jgt  LL115                      ; BPL LL115         ; so jump down to LL115 to skip the checks of whether
36907                                                                          ; both points are in the strips to the right or bottom
36908                                                                          ; of the screen
36909               
36910                                                                          ; If we get here, both points are off-screen
36911               
36912 EF4A D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If both x1_hi and x2_hi have bit 7 set, jump to LL109
     EF4C 0032     
36913                      .and @XX15+5                    ; AND XX15+5        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 EF4E D020  30        movb @XX15+5,rtmp
     EF50 0036     
0002 EF52 0540  14        inv  rtmp
0003 EF54 5340  18        szcb rtmp,ra
                   < elite.a99
36914 EF56 11EE  14        jlt  LL109                      ; BMI LL109         ; the entire line is above the top of the screen
36915               
36916 EF58 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; If both y1_hi and y2_hi have bit 7 set, jump to LL109
     EF5A 0034     
36917                      .and @XX12+1                    ; AND XX12+1        ; to return from the subroutine with the C flag set, as
     **** ****     > AND
0001 EF5C D020  30        movb @XX12+1,rtmp
     EF5E 0038     
0002 EF60 0540  14        inv  rtmp
0003 EF62 5340  18        szcb rtmp,ra
                   < elite.a99
36918 EF64 11E7  14        jlt  LL109                      ; BMI LL109         ; the entire line is to the left of the screen
36919               
36920 EF66 D3A0  30        movb @XX15+1,rx                 ; LDX XX15+1        ; Set A = X = x1_hi - 1
     EF68 0032     
36921 EF6A 7387  18        sb   rone,rx                    ; DEX
36922 EF6C D34E  18        movb rx,ra                      ; TXA
36923               
36924 EF6E D3A0  30        movb @XX15+5,rx                 ; LDX XX15+5        ; Set XX12+2 = x2_hi - 1
     EF70 0036     
36925 EF72 7387  18        sb   rone,rx                    ; DEX
36926 EF74 D80E  30        movb rx,@XX12+2                 ; STX XX12+2
     EF76 0039     
36927               
36928 EF78 F360  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
     EF7A 0039     
36929 EF7C 15DB  14        jgt  LL109                      ; BPL LL109         ; jump to LL109 to return from the subroutine with the C
36930                                                                          ; flag set, as the line doesn't fit on-screen
36931               
36932 EF7E D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo < y-coordinate of screen bottom, clear the C
     EF80 0033     
36933 EF82 028D  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     EF84 C000     
36934               
36935 EF86 D360  30        movb @XX15+3,ra                 ; LDA XX15+3        ; Set XX12+2 = y1_hi - (1 - C), so:
     EF88 0034     
36936                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 EF8A 1801  14        joc  !
0002 EF8C 7347  18        sb   rone,ra
0003               !:
0004 EF8E 022D  22        ai   ra,-(>00*256)
     EF90 0000     
                   < elite.a99
36937 EF92 D80D  30        movb ra,@XX12+2                 ; STA XX12+2        ; * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen
     EF94 0039     
36938                                                                          ; * Set XX12+2 = y1_hi     otherwise
36939                                                                          ;
36940                                                                          ; We do this subtraction because we are only interested
36941                                                                          ; in trying to move the points up by a screen if that
36942                                                                          ; might move the point into the space view portion of
36943                                                                          ; the screen, i.e. if y1_lo is on-screen
36944               
36945 EF96 D360  30        movb @XX12,ra                   ; LDA XX12          ; If y2_lo < y-coordinate of screen bottom, clear the C
     EF98 0037     
36946 EF9A 028D  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it
     EF9C C000     
36947               
36948 EF9E D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+2 = y2_hi - (1 - C), so:
     EFA0 0038     
36949                      .sbi (>00*256)                  ; SBC #0            ;
     **** ****     > SBI
0001 EFA2 1801  14        joc  !
0002 EFA4 7347  18        sb   rone,ra
0003               !:
0004 EFA6 022D  22        ai   ra,-(>00*256)
     EFA8 0000     
                   < elite.a99
36950                                                                          ; * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen
36951                                                                          ; * Set XX12+1 = y2_hi     otherwise
36952                                                                          ;
36953                                                                          ; We do this subtraction because we are only interested
36954                                                                          ; in trying to move the points up by a screen if that
36955                                                                          ; might move the point into the space view portion of
36956                                                                          ; the screen, i.e. if y1_lo is on-screen
36957               
36958 EFAA F360  30        socb @XX12+2,ra                 ; ORA XX12+2        ; If neither XX12+1 or XX12+2 have bit 7 set, jump to
     EFAC 0039     
36959 EFAE 15C2  14        jgt  LL109                      ; BPL LL109         ; LL109 to return from the subroutine with the C flag
36960                                                                          ; set, as the line doesn't fit on-screen
36961               
36962               * ******************************************************************************
36963               *
36964               * Name: LL145 (Part 3 of 4)
36965               * Type: Subroutine
36966               * Category: Drawing lines
36967               * Summary: Clip line: Calculate the line's gradient
36968               * Deep dive: Line-clipping
36969               * Extended screen coordinates
36970               *
36971               * ******************************************************************************
36972               
36973               LL115:
36974 EFB0 D34F  18        movb ry,ra                      ; TYA               ; Store Y on the stack so we can preserve it through the
36975                      .pha                            ; PHA               ; call to this subroutine
     **** ****     > PHA
0001 EFB2 D68D  30        movb ra,*rsp
0002 EFB4 060A  14        dec  rsp
                   < elite.a99
36976               
36977 EFB6 D360  30        movb @XX15+4,ra                 ; LDA XX15+4        ; Set XX12+2 = x2_lo - x1_lo
     EFB8 0035     
36978                      .sec                            ; SEC
     **** ****     > SEC
0001 EFBA 0A18  18        sla  rmone,1
                   < elite.a99
36979                      .sbc @XX15,ra                   ; SBC XX15
     **** ****     > SBC
0001 EFBC 1801  14        joc  !
0002 EFBE 7347  18        sb   rone,ra
0003               !:
0004 EFC0 7360  30        sb   @XX15,ra
     EFC2 0031     
                   < elite.a99
36980 EFC4 D80D  30        movb ra,@XX12+2                 ; STA XX12+2
     EFC6 0039     
36981               
36982 EFC8 D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Set XX12+3 = x2_hi - x1_hi
     EFCA 0036     
36983                      .sbc @XX15+1,ra                 ; SBC XX15+1
     **** ****     > SBC
0001 EFCC 1801  14        joc  !
0002 EFCE 7347  18        sb   rone,ra
0003               !:
0004 EFD0 7360  30        sb   @XX15+1,ra
     EFD2 0032     
                   < elite.a99
36984 EFD4 D80D  30        movb ra,@XX12+3                 ; STA XX12+3
     EFD6 003A     
36985               
36986 EFD8 D360  30        movb @XX12,ra                   ; LDA XX12          ; Set XX12+4 = y2_lo - y1_lo
     EFDA 0037     
36987                      .sec                            ; SEC
     **** ****     > SEC
0001 EFDC 0A18  18        sla  rmone,1
                   < elite.a99
36988                      .sbc @XX15+2,ra                 ; SBC XX15+2
     **** ****     > SBC
0001 EFDE 1801  14        joc  !
0002 EFE0 7347  18        sb   rone,ra
0003               !:
0004 EFE2 7360  30        sb   @XX15+2,ra
     EFE4 0033     
                   < elite.a99
36989 EFE6 D80D  30        movb ra,@XX12+4                 ; STA XX12+4
     EFE8 003B     
36990               
36991 EFEA D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+5 = y2_hi - y1_hi
     EFEC 0038     
36992                      .sbc @XX15+3,ra                 ; SBC XX15+3
     **** ****     > SBC
0001 EFEE 1801  14        joc  !
0002 EFF0 7347  18        sb   rone,ra
0003               !:
0004 EFF2 7360  30        sb   @XX15+3,ra
     EFF4 0034     
                   < elite.a99
36993 EFF6 D80D  30        movb ra,@XX12+5                 ; STA XX12+5
     EFF8 003C     
36994               
36995                                                                          ; So we now have:
36996                                                                          ;
36997                                                                          ; delta_x in XX12(3 2)
36998                                                                          ; delta_y in XX12(5 4)
36999                                                                          ;
37000                                                                          ; where the delta is (x1, y1) - (x2, y2))
37001               
37002                      .eor @XX12+3                    ; EOR XX12+3        ; Set S = the sign of delta_x * the sign of delta_y, so
     **** ****     > EOR
0001 EFFA D020  30        movb @XX12+3,rtmp
     EFFC 003A     
0002 EFFE 2B40  18        xor  rtmp,ra
                   < elite.a99
37003 F000 D80D  30        movb ra,@S                      ; STA S             ; if bit 7 of S is set, the deltas have different signs
     F002 0092     
37004               
37005 F004 D360  30        movb @XX12+5,ra                 ; LDA XX12+5        ; If delta_y_hi is positive, jump down to LL110 to skip
     F006 003C     
37006 F008 1511  14        jgt  LL110                      ; BPL LL110         ; the following
37007               
37008 F00A 020D  20        li   ra,>00*256                 ; LDA #0            ; Otherwise flip the sign of delta_y to make it
     F00C 0000     
37009                      .sec                            ; SEC               ; positive, starting with the low bytes
     **** ****     > SEC
0001 F00E 0A18  18        sla  rmone,1
                   < elite.a99
37010                      .sbc @XX12+4,ra                 ; SBC XX12+4
     **** ****     > SBC
0001 F010 1801  14        joc  !
0002 F012 7347  18        sb   rone,ra
0003               !:
0004 F014 7360  30        sb   @XX12+4,ra
     F016 003B     
                   < elite.a99
37011 F018 D80D  30        movb ra,@XX12+4                 ; STA XX12+4
     F01A 003B     
37012               
37013 F01C 020D  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     F01E 0000     
37014                      .sbc @XX12+5,ra                 ; SBC XX12+5        ;
     **** ****     > SBC
0001 F020 1801  14        joc  !
0002 F022 7347  18        sb   rone,ra
0003               !:
0004 F024 7360  30        sb   @XX12+5,ra
     F026 003C     
                   < elite.a99
37015 F028 D80D  30        movb ra,@XX12+5                 ; STA XX12+5        ; XX12(5 4) = |delta_y|
     F02A 003C     
37016               
37017               LL110:
37018 F02C D360  30        movb @XX12+3,ra                 ; LDA XX12+3        ; If delta_x_hi is positive, jump down to LL111 to skip
     F02E 003A     
37019 F030 150F  14        jgt  LL111                      ; BPL LL111         ; the following
37020               
37021                      .sec                            ; SEC               ; Otherwise flip the sign of delta_x to make it
     **** ****     > SEC
0001 F032 0A18  18        sla  rmone,1
                   < elite.a99
37022 F034 020D  20        li   ra,>00*256                 ; LDA #0            ; positive, starting with the low bytes
     F036 0000     
37023                      .sbc @XX12+2,ra                 ; SBC XX12+2
     **** ****     > SBC
0001 F038 1801  14        joc  !
0002 F03A 7347  18        sb   rone,ra
0003               !:
0004 F03C 7360  30        sb   @XX12+2,ra
     F03E 0039     
                   < elite.a99
37024 F040 D80D  30        movb ra,@XX12+2                 ; STA XX12+2
     F042 0039     
37025               
37026 F044 020D  20        li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
     F046 0000     
37027                      .sbc @XX12+3,ra                 ; SBC XX12+3        ;
     **** ****     > SBC
0001 F048 1801  14        joc  !
0002 F04A 7347  18        sb   rone,ra
0003               !:
0004 F04C 7360  30        sb   @XX12+3,ra
     F04E 003A     
                   < elite.a99
37028                                                                          ; (A XX12+2) = |delta_x|
37029               
37030               LL111:
37031                                                                          ; We now keep halving |delta_x| and |delta_y| until
37032                                                                          ; both of them have zero in their high bytes
37033 F050 D38D  18        movb ra,rx                      ; TAX               ; If |delta_x_hi| is non-zero, skip the following
37034 F052 1603  14        jne  LL112                      ; BNE LL112
37035               
37036 F054 D3A0  30        movb @XX12+5,rx                 ; LDX XX12+5        ; If |delta_y_hi| = 0, jump down to LL113 (as both
     F056 003C     
37037 F058 1310  14        jeq  LL113                      ; BEQ LL113         ; |delta_x_hi| and |delta_y_hi| are 0)
37038               
37039               LL112:
37040 F05A 091D  18        srl  ra,1                       ; LSR A             ; Halve the value of delta_x in (A XX12+2)
37041 F05C 0204  20        li   rarg1,XX12+2               ; ROR XX12+2
     F05E 0039     
37042 F060 06A0  32        bl   @ror                       ;
     F062 FE7A     
37043               
37044                      .lsr @XX12+5                    ; LSR XX12+5        ; Halve the value of delta_y XX12(5 4)
     **** ****     > LSR
0001 F064 D020  30        movb @XX12+5,rtmp
     F066 003C     
0002 F068 0910  18        srl  rtmp,1
0003 F06A D800  30        movb rtmp,@XX12+5
     F06C 003C     
                   < elite.a99
37045 F06E 0204  20        li   rarg1,XX12+4               ; ROR XX12+4
     F070 003B     
37046 F072 06A0  32        bl   @ror                       ;
     F074 FE7A     
37047               
37048 F076 0460  28        b    @LL111                     ; JMP LL111         ; Loop back to LL111
     F078 F050     
37049               
37050               LL113:
37051                                                                          ; By now, the high bytes of both |delta_x| and |delta_y|
37052                                                                          ; are zero
37053 F07A D80E  30        movb rx,@T                      ; STX T             ; We know that X = 0 as that's what we tested with a BEQ
     F07C 00D1     
37054                                                                          ; above, so this sets T = 0
37055               
37056 F07E D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; If delta_x_lo < delta_y_lo, so our line is more
     F080 0039     
37057 F082 9360  30        cb   @XX12+4,ra                 ; CMP XX12+4        ; vertical than horizontal, jump to LL114
     F084 003B     
37058 F086 170A  14        jnc  LL114                      ; BCC LL114
37059               
37060                                                                          ; If we get here then our line is more horizontal than
37061                                                                          ; vertical, so it is a shallow slope
37062               
37063 F088 D80D  30        movb ra,@Q                      ; STA Q             ; Set Q = delta_x_lo
     F08A 0090     
37064               
37065 F08C D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = delta_y_lo
     F08E 003B     
37066               
37067 F090 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     F092 DB2C     
37068 F094 06A0  32        bl   @jsr                       ;
     F096 FE28     
37069                                                                          ;
37070                                                                          ; R = 256 * A / Q
37071                                                                          ; = 256 * delta_y_lo / delta_x_lo
37072               
37073 F098 0460  28        b    @LL116                     ; JMP LL116         ; Jump to LL116, as we now have the line's gradient in R
     F09A F0B2     
37074               
37075               LL114:
37076                                                                          ; If we get here then our line is more vertical than
37077                                                                          ; horizontal, so it is a steep slope
37078 F09C D360  30        movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = delta_y_lo
     F09E 003B     
37079 F0A0 D80D  30        movb ra,@Q                      ; STA Q
     F0A2 0090     
37080 F0A4 D360  30        movb @XX12+2,ra                 ; LDA XX12+2        ; Set A = delta_x_lo
     F0A6 0039     
37081               
37082 F0A8 0200  20        li   rtmp,LL28                  ; JSR LL28          ; Call LL28 to calculate:
     F0AA DB2C     
37083 F0AC 06A0  32        bl   @jsr                       ;
     F0AE FE28     
37084                                                                          ;
37085                                                                          ; R = 256 * A / Q
37086                                                                          ; = 256 * delta_x_lo / delta_y_lo
37087               
37088 F0B0 7347  18        sb   rone,ra                    ; DEC T             ; T was set to 0 above, so this sets T = &FF when our
37089                                                                          ; line is steep
37090               
37091               * ******************************************************************************
37092               *
37093               * Name: LL145 (Part 4 of 4)
37094               * Type: Subroutine
37095               * Category: Drawing lines
37096               * Summary: Clip line: Call the routine in LL188 to do the actual clipping
37097               * Deep dive: Line-clipping
37098               * Extended screen coordinates
37099               *
37100               * ------------------------------------------------------------------------------
37101               *
37102               * This part sets things up to call the routine in LL188, which does the actual
37103               * clipping.
37104               *
37105               * If we get here, then R has been set to the gradient of the line (x1, y1) to
37106               * (x2, y2), with T indicating the gradient of slope:
37107               *
37108               * * 0   = shallow slope (more horizontal than vertical)
37109               *
37110               * * &FF = steep slope (more vertical than horizontal)
37111               *
37112               * and XX13 has been set as follows:
37113               *
37114               * * 0   = (x1, y1) off-screen, (x2, y2) on-screen
37115               *
37116               * * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
37117               *
37118               * * 191 = (x1, y1) off-screen, (x2, y2) off-screen
37119               *
37120               * ******************************************************************************
37121               
37122               LL116:
37123 F0B2 D360  30        movb @R,ra                      ; LDA R             ; Store the gradient in XX12+2
     F0B4 0091     
37124 F0B6 D80D  30        movb ra,@XX12+2                 ; STA XX12+2
     F0B8 0039     
37125               
37126 F0BA D360  30        movb @S,ra                      ; LDA S             ; Store the type of slope in XX12+3, bit 7 clear means
     F0BC 0092     
37127 F0BE D80D  30        movb ra,@XX12+3                 ; STA XX12+3        ; top left to bottom right, bit 7 set means top right to
     F0C0 003A     
37128                                                                          ; bottom left
37129               
37130 F0C2 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, skip the following instruction
     F0C4 0098     
37131 F0C6 1301  14        jeq  LL138                      ; BEQ LL138
37132               
37133 F0C8 1511  14        jgt  LLX117                     ; BPL LLX117        ; If XX13 is positive, it must be 95. This means
37134                                                                          ; (x1, y1) is on-screen but (x2, y2) isn't, so we jump
37135                                                                          ; to LLX117 to swap the (x1, y1) and (x2, y2)
37136                                                                          ; coordinates around before doing the actual clipping,
37137                                                                          ; because we need to clip (x2, y2) but the clipping
37138                                                                          ; routine at LL118 only clips (x1, y1)
37139               
37140               LL138:
37141                                                                          ; If we get here, XX13 = 0 or 191, so (x1, y1) is
37142                                                                          ; off-screen and needs clipping
37143 F0CA 0200  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     F0CC EC48     
37144 F0CE 06A0  32        bl   @jsr                       ;
     F0D0 FE28     
37145                                                                          ; screen, i.e. clip the line at the (x1, y1) end
37146               
37147 F0D2 D360  30        movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
     F0D4 0098     
37148 F0D6 152F  14        jgt  LL124                      ; BPL LL124         ; LL124 to return with a successfully clipped line
37149               
37150               LL117:
37151                                                                          ; If we get here, XX13 = 191 (both coordinates are
37152                                                                          ; off-screen)
37153 F0D8 D360  30        movb @XX15+1,ra                 ; LDA XX15+1        ; If either of x1_hi or y1_hi are non-zero, jump to
     F0DA 0032     
37154 F0DC F360  30        socb @XX15+3,ra                 ; ORA XX15+3        ; LL137 to return from the subroutine with the C flag
     F0DE 0034     
37155 F0E0 162F  14        jne  LL137                      ; BNE LL137         ; set, as the line doesn't fit on-screen
37156               
37157 F0E2 D360  30        movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo > y-coordinate of the bottom of the screen
     F0E4 0033     
37158 F0E6 028D  22        ci   ra,(Y*2)*256               ; CMP #Y*2          ; jump to LL137 to return from the subroutine with the
     F0E8 C000     
37159 F0EA 182A  14        joc  LL137                      ; BCS LL137         ; C flag set, as the line doesn't fit on-screen
37160               
37161               LLX117:
37162                                                                          ; If we get here, XX13 = 95 or 191, and in both cases
37163                                                                          ; (x2, y2) is off-screen, so we now need to swap the
37164                                                                          ; (x1, y1) and (x2, y2) coordinates around before doing
37165                                                                          ; the actual clipping, because we need to clip (x2, y2)
37166                                                                          ; but the clipping routine at LL118 only clips (x1, y1)
37167 F0EC D3A0  30        movb @XX15,rx                   ; LDX XX15          ; Swap x1_lo = x2_lo
     F0EE 0031     
37168 F0F0 D360  30        movb @XX15+4,ra                 ; LDA XX15+4
     F0F2 0035     
37169 F0F4 D80D  30        movb ra,@XX15                   ; STA XX15
     F0F6 0031     
37170 F0F8 D80E  30        movb rx,@XX15+4                 ; STX XX15+4
     F0FA 0035     
37171               
37172 F0FC D360  30        movb @XX15+5,ra                 ; LDA XX15+5        ; Swap x2_lo = x1_lo
     F0FE 0036     
37173 F100 D3A0  30        movb @XX15+1,rx                 ; LDX XX15+1
     F102 0032     
37174 F104 D80E  30        movb rx,@XX15+5                 ; STX XX15+5
     F106 0036     
37175 F108 D80D  30        movb ra,@XX15+1                 ; STA XX15+1
     F10A 0032     
37176               
37177 F10C D3A0  30        movb @XX15+2,rx                 ; LDX XX15+2        ; Swap y1_lo = y2_lo
     F10E 0033     
37178 F110 D360  30        movb @XX12,ra                   ; LDA XX12
     F112 0037     
37179 F114 D80D  30        movb ra,@XX15+2                 ; STA XX15+2
     F116 0033     
37180 F118 D80E  30        movb rx,@XX12                   ; STX XX12
     F11A 0037     
37181               
37182 F11C D360  30        movb @XX12+1,ra                 ; LDA XX12+1        ; Swap y2_lo = y1_lo
     F11E 0038     
37183 F120 D3A0  30        movb @XX15+3,rx                 ; LDX XX15+3
     F122 0034     
37184 F124 D80E  30        movb rx,@XX12+1                 ; STX XX12+1
     F126 0038     
37185 F128 D80D  30        movb ra,@XX15+3                 ; STA XX15+3
     F12A 0034     
37186               
37187 F12C 0200  20        li   rtmp,LL118                 ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
     F12E EC48     
37188 F130 06A0  32        bl   @jsr                       ;
     F132 FE28     
37189                                                                          ; screen, i.e. clip the line at the (x1, y1) end
37190               
37191 F134 7347  18        sb   rone,ra                    ; DEC SWAP          ; Set SWAP = &FF to indicate that we just clipped the
37192                                                                          ; line at the (x2, y2) end by swapping the coordinates
37193                                                                          ; (the DEC does this as we set SWAP to 0 at the start of
37194                                                                          ; this subroutine)
37195               
37196               LL124:
37197                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 F136 058A  14        inc  rsp
0002 F138 D35A  26        movb *rsp,ra
                   < elite.a99
37198 F13A D3CD  18        movb ra,ry                      ; TAY               ; the call to this subroutine
37199               
37200 F13C 0460  28        b    @LL146                     ; JMP LL146         ; Jump up to LL146 to move the low bytes of (x1, y1) and
     F13E EF16     
37201                                                                          ; (x2, y2) into (X1, Y1) and (X2, Y2), and return from
37202                                                                          ; the subroutine with a successfully clipped line
37203               
37204               LL137:
37205                      .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
     **** ****     > PLA
0001 F140 058A  14        inc  rsp
0002 F142 D35A  26        movb *rsp,ra
                   < elite.a99
37206 F144 D3CD  18        movb ra,ry                      ; TAY               ; the call to this subroutine
37207               
37208                      .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
     **** ****     > SEC
0001 F146 0A18  18        sla  rmone,1
                   < elite.a99
37209                                                                          ; fit on-screen
37210               
37211 F148 0460  28        b    @rts                       ; RTS               ; Return from the subroutine
     F14A FE34     
37212               
37213               * ******************************************************************************
37214               *
37215               * Save ELTG.bin
37216               *
37217               * ******************************************************************************
37218               
37219                      ; PRINT "ELITE G"
37220                      ; PRINT "Assembled at ", ~CODE_G%
37221                      ; PRINT "Ends at ", ~P%
37222                      ; PRINT "Code size is ", ~(P% - CODE_G%)
37223                      ; PRINT "Execute at ", ~LOAD%
37224                      ; PRINT "Reload at ", ~LOAD_G%
37225               
37226                      ; PRINT "S.ELTG ", ~CODE_G%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_G%
37227                      ; SAVE "3-assembled-output/ELTG.bin", CODE_G%, P%, LOAD%
37228               
37229               * ******************************************************************************
37230               *
37231               * Name: checksum0
37232               * Type: Variable
37233               * Category: Copy protection
37234               * Summary: Checksum for the entire main game code
37235               *
37236               * ------------------------------------------------------------------------------
37237               *
37238               * This byte contains a checksum for the entire main game code. It is populated
37239               * by elite-checksum.py and is used by the encryption checks in elite-loader.asm
37240               * (see the CHK routine in the loader for more details).
37241               *
37242               * ******************************************************************************
37243               
37244               checksum0_:
37245 F14C                 bss 1                                               ; This value is checked against the calculated checksum
37246                                                                          ; in part 6 of the loader in elite-loader.asm
37247               
37248               * ******************************************************************************
37249               *
37250               * ELITE SHIP BLUEPRINTS FILE
37251               *
37252               * Produces the binary file SHIPS.bin that gets loaded by elite-bcfs.asm.
37253               *
37254               * ******************************************************************************
37255               
37256               CODE_SHIPS.:
37257                      equ $
37258               
37259               LOAD_SHIPS.:
37260                      equ LOAD. + $ - CODE.
37261               
37262               * ******************************************************************************
37263               *
37264               * Name: XX21
37265               * Type: Variable
37266               * Category: Drawing ships
37267               * Summary: Ship blueprints lookup table
37268               * Deep dive: Ship blueprints
37269               *
37270               * ******************************************************************************
37271               
37272               XX21:
37273 F14E F168            data SHIP_SIDEWINDER                                ; 1 = Sidewinder
37274 F150 F212            data SHIP_VIPER                                     ; COPS =  2 = Viper
37275 F152 F2EE            data SHIP_MAMBA                                     ; 3 = Mamba
37276 F154 FB2A            data SHIP_PYTHON                                    ; 4 = Python
37277 F156 F41E            data SHIP_COBRA_MK_3                                ; 5 = Cobra Mk III (bounty hunter)
37278 F158 F5A8            data SHIP_THARGOID                                  ; THG  =  6 = Thargoid
37279 F15A F41E            data SHIP_COBRA_MK_3                                ; CYL  =  7 = Cobra Mk III (trader)
37280 F15C F6C6            data SHIP_CORIOLIS                                  ; SST  =  8 = Coriolis space station
37281 F15E F7E4            data SHIP_MISSILE                                   ; MSL  =  9 = Missile
37282 F160 F8E4            data SHIP_ASTEROID                                  ; AST  = 10 = Asteroid
37283 F162 F9BC            data SHIP_CANISTER                                  ; OIL  = 11 = Cargo canister
37284 F164 FA66            data SHIP_THARGON                                   ; TGL  = 12 = Thargon
37285 F166 FAD4            data SHIP_ESCAPE_POD                                ; ESC  = 13 = Escape pod
37286               
37287               * ******************************************************************************
37288               *
37289               * Name: VERTEX
37290               * Type: Macro
37291               * Category: Drawing ships
37292               * Summary: Macro definition for adding vertices to ship blueprints
37293               * Deep dive: Ship blueprints
37294               *
37295               * ------------------------------------------------------------------------------
37296               *
37297               * The following macro is used to build the ship blueprints:
37298               *
37299               * VERTEX x, y, z, face1, face2, face3, face4, visibility
37300               *
37301               * See the deep dive on "Ship blueprints" for details of how vertices are stored
37302               * in the ship blueprints, and the deep dive on "Drawing ships" for information
37303               * on how vertices are used to draw 3D wireframe ships.
37304               *
37305               * ------------------------------------------------------------------------------
37306               *
37307               * Arguments:
37308               *
37309               * x                   The vertex's x-coordinate
37310               *
37311               * y                   The vertex's y-coordinate
37312               *
37313               * z                   The vertex's z-coordinate
37314               *
37315               * face1               The number of face 1 associated with this vertex
37316               *
37317               * face2               The number of face 2 associated with this vertex
37318               *
37319               * face3               The number of face 3 associated with this vertex
37320               *
37321               * face4               The number of face 4 associated with this vertex
37322               *
37323               * visibility          The visibility distance, beyond which the vertex is not
37324               * shown
37325               *
37326               * ******************************************************************************
37327               
37328                      ; MACRO VERTEX x, y, z, face1, face2, face3, face4, visibility
37329               
37330                      ; IF x < 0                      ;
37331                      ; s_x = 1 << 7                  ;
37332                      ; ELSE                          ;
37333                      ; s_x = 0                       ;
37334                      ; ENDIF                         ;
37335               
37336                      ; IF y < 0                      ;
37337                      ; s_y = 1 << 6                  ;
37338                      ; ELSE                          ;
37339                      ; s_y = 0                       ;
37340                      ; ENDIF                         ;
37341               
37342                      ; IF z < 0                      ;
37343                      ; s_z = 1 << 5                  ;
37344                      ; ELSE                          ;
37345                      ; s_z = 0                       ;
37346                      ; ENDIF                         ;
37347               
37348                      ; s = s_x + s_y + s_z + visibility ;
37349                      ; f1 = face1 + (face2 << 4)     ;
37350                      ; f2 = face3 + (face4 << 4)     ;
37351                      ; ax = ABS(x)                   ;
37352                      ; ay = ABS(y)                   ;
37353                      ; az = ABS(z)                   ;
37354               
37355                      ; EQUB ax, ay, az, s, f1, f2    ;
37356               
37357                      ; ENDMACRO
37358               
37359               * ******************************************************************************
37360               *
37361               * Name: EDGE
37362               * Type: Macro
37363               * Category: Drawing ships
37364               * Summary: Macro definition for adding edges to ship blueprints
37365               * Deep dive: Ship blueprints
37366               *
37367               * ------------------------------------------------------------------------------
37368               *
37369               * The following macro is used to build the ship blueprints:
37370               *
37371               * EDGE vertex1, vertex2, face1, face2, visibility
37372               *
37373               * See the deep dive on "Ship blueprints" for details of how edges are stored
37374               * in the ship blueprints, and the deep dive on "Drawing ships" for information
37375               * on how edges are used to draw 3D wireframe ships.
37376               *
37377               * ------------------------------------------------------------------------------
37378               *
37379               * Arguments:
37380               *
37381               * vertex1             The number of the vertex at the start of the edge
37382               *
37383               * vertex1             The number of the vertex at the end of the edge
37384               *
37385               * face1               The number of face 1 associated with this edge
37386               *
37387               * face2               The number of face 2 associated with this edge
37388               *
37389               * visibility          The visibility distance, beyond which the edge is not
37390               * shown
37391               *
37392               * ******************************************************************************
37393               
37394                      ; MACRO EDGE vertex1, vertex2, face1, face2, visibility
37395               
37396                      ; f = face1 + (face2 << 4)      ;
37397                      ; EQUB visibility, f, vertex1 << 2, vertex2 << 2 ;
37398               
37399                      ; ENDMACRO
37400               
37401               * ******************************************************************************
37402               *
37403               * Name: FACE
37404               * Type: Macro
37405               * Category: Drawing ships
37406               * Summary: Macro definition for adding faces to ship blueprints
37407               * Deep dive: Ship blueprints
37408               *
37409               * ------------------------------------------------------------------------------
37410               *
37411               * The following macro is used to build the ship blueprints:
37412               *
37413               * FACE normal_x, normal_y, normal_z, visibility
37414               *
37415               * See the deep dive on "Ship blueprints" for details of how faces are stored
37416               * in the ship blueprints, and the deep dive on "Drawing ships" for information
37417               * on how faces are used to draw 3D wireframe ships.
37418               *
37419               * ------------------------------------------------------------------------------
37420               *
37421               * Arguments:
37422               *
37423               * normal_x            The face normal's x-coordinate
37424               *
37425               * normal_y            The face normal's y-coordinate
37426               *
37427               * normal_z            The face normal's z-coordinate
37428               *
37429               * visibility          The visibility distance, beyond which the edge is always
37430               * shown
37431               *
37432               * ******************************************************************************
37433               
37434                      ; MACRO FACE normal_x, normal_y, normal_z, visibility
37435               
37436                      ; IF normal_x < 0               ;
37437                      ; s_x = 1 << 7                  ;
37438                      ; ELSE                          ;
37439                      ; s_x = 0                       ;
37440                      ; ENDIF                         ;
37441               
37442                      ; IF normal_y < 0               ;
37443                      ; s_y = 1 << 6                  ;
37444                      ; ELSE                          ;
37445                      ; s_y = 0                       ;
37446                      ; ENDIF                         ;
37447               
37448                      ; IF normal_z < 0               ;
37449                      ; s_z = 1 << 5                  ;
37450                      ; ELSE                          ;
37451                      ; s_z = 0                       ;
37452                      ; ENDIF                         ;
37453               
37454                      ; s = s_x + s_y + s_z + visibility ;
37455                      ; ax = ABS(normal_x)            ;
37456                      ; ay = ABS(normal_y)            ;
37457                      ; az = ABS(normal_z)            ;
37458               
37459                      ; EQUB s, ax, ay, az            ;
37460               
37461                      ; ENDMACRO
37462               
37463               * ******************************************************************************
37464               *
37465               * Name: SHIP_SIDEWINDER
37466               * Type: Variable
37467               * Category: Drawing ships
37468               * Summary: Ship blueprint for a Sidewinder
37469               * Deep dive: Ship blueprints
37470               *
37471               * ******************************************************************************
37472               
37473               SHIP_SIDEWINDER:
37474 F168 00              byte >00                                            ; Max. canisters on demise = 0
37475 F16A 1081            data 65 * 65                                        ; Targetable area          = 65 * 65
37476               
37477 F16C 52              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)%256  ; Edges data offset (low)
37478 F16D   8E            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)%256  ; Faces data offset (low)
37479               
37480 F16E 3D              byte >3d                                            ; Max. edge count          = (61 - 1) / 4 = 15
37481 F16F   00            byte >00                                            ; Gun vertex               = 0
37482 F170 1E              byte >1e                                            ; Explosion count          = 6, as (4 * n) + 6 = 30
37483 F171   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
37484 F172 0F              byte >0f                                            ; Number of edges          = 15
37485 F174 3200            data >3200                                          ; Bounty                   = 50
37486 F176 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37487 F177   14            byte >14                                            ; Visibility distance      = 20
37488 F178 46              byte >46                                            ; Max. energy              = 70
37489 F179   25            byte >25                                            ; Max. speed               = 37
37490               
37491 F17A 00              byte (SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)/256  ; Edges data offset (high)
37492 F17B   00            byte (SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)/256  ; Faces data offset (high)
37493               
37494 F17C 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37495 F17D   10            byte >10                                            ; Laser power              = 2
37496                                                                          ; Missiles                 = 0
37497               
37498               SHIP_SIDEWINDER_VERTICES:
37499                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37500 F17E 2000            byte >20, >00, >24, >9f, >10, >54                   ; Vertex 0
     F180 249F     
     F182 1054     
37501 F184 2000            byte >20, >00, >24, >1f, >20, >65                   ; Vertex 1
     F186 241F     
     F188 2065     
37502 F18A 4000            byte >40, >00, >1c, >3f, >32, >66                   ; Vertex 2
     F18C 1C3F     
     F18E 3266     
37503 F190 4000            byte >40, >00, >1c, >bf, >31, >44                   ; Vertex 3
     F192 1CBF     
     F194 3144     
37504 F196 0010            byte >00, >10, >1c, >3f, >10, >32                   ; Vertex 4
     F198 1C3F     
     F19A 1032     
37505 F19C 0010            byte >00, >10, >1c, >7f, >43, >65                   ; Vertex 5
     F19E 1C7F     
     F1A0 4365     
37506 F1A2 0C06            byte >0c, >06, >1c, >af, >33, >33                   ; Vertex 6
     F1A4 1CAF     
     F1A6 3333     
37507 F1A8 0C06            byte >0c, >06, >1c, >2f, >33, >33                   ; Vertex 7
     F1AA 1C2F     
     F1AC 3333     
37508 F1AE 0C06            byte >0c, >06, >1c, >6c, >33, >33                   ; Vertex 8
     F1B0 1C6C     
     F1B2 3333     
37509 F1B4 0C06            byte >0c, >06, >1c, >ec, >33, >33                   ; Vertex 9
     F1B6 1CEC     
     F1B8 3333     
37510               
37511               SHIP_SIDEWINDER_EDGES:
37512                                                                          ; vertex1, vertex2, face1, face2, visibility
37513 F1BA 1F50            byte >1f, >50, >00, >04                             ; Edge 0
     F1BC 0004     
37514 F1BE 1F62            byte >1f, >62, >04, >08                             ; Edge 1
     F1C0 0408     
37515 F1C2 1F20            byte >1f, >20, >04, >10                             ; Edge 2
     F1C4 0410     
37516 F1C6 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     F1C8 0010     
37517 F1CA 1F41            byte >1f, >41, >00, >0c                             ; Edge 4
     F1CC 000C     
37518 F1CE 1F31            byte >1f, >31, >0c, >10                             ; Edge 5
     F1D0 0C10     
37519 F1D2 1F32            byte >1f, >32, >08, >10                             ; Edge 6
     F1D4 0810     
37520 F1D6 1F43            byte >1f, >43, >0c, >14                             ; Edge 7
     F1D8 0C14     
37521 F1DA 1F63            byte >1f, >63, >08, >14                             ; Edge 8
     F1DC 0814     
37522 F1DE 1F65            byte >1f, >65, >04, >14                             ; Edge 9
     F1E0 0414     
37523 F1E2 1F54            byte >1f, >54, >00, >14                             ; Edge 10
     F1E4 0014     
37524 F1E6 0F33            byte >0f, >33, >18, >1c                             ; Edge 11
     F1E8 181C     
37525 F1EA 0C33            byte >0c, >33, >1c, >20                             ; Edge 12
     F1EC 1C20     
37526 F1EE 0C33            byte >0c, >33, >18, >24                             ; Edge 13
     F1F0 1824     
37527 F1F2 0C33            byte >0c, >33, >20, >24                             ; Edge 14
     F1F4 2024     
37528               
37529               SHIP_SIDEWINDER_FACES:
37530                                                                          ; normal_x, normal_y, normal_z, visibility
37531 F1F6 1F00            byte >1f, >00, >20, >08                             ; Face 0
     F1F8 2008     
37532 F1FA 9F0C            byte >9f, >0c, >2f, >06                             ; Face 1
     F1FC 2F06     
37533 F1FE 1F0C            byte >1f, >0c, >2f, >06                             ; Face 2
     F200 2F06     
37534 F202 3F00            byte >3f, >00, >00, >70                             ; Face 3
     F204 0070     
37535 F206 DF0C            byte >df, >0c, >2f, >06                             ; Face 4
     F208 2F06     
37536 F20A 5F00            byte >5f, >00, >20, >08                             ; Face 5
     F20C 2008     
37537 F20E 5F0C            byte >5f, >0c, >2f, >06                             ; Face 6
     F210 2F06     
37538               
37539               * ******************************************************************************
37540               *
37541               * Name: SHIP_VIPER
37542               * Type: Variable
37543               * Category: Drawing ships
37544               * Summary: Ship blueprint for a Viper
37545               * Deep dive: Ship blueprints
37546               *
37547               * ******************************************************************************
37548               
37549               SHIP_VIPER:
37550 F212 00              byte >00                                            ; Max. canisters on demise = 0
37551 F214 15F9            data 75 * 75                                        ; Targetable area          = 75 * 75
37552               
37553 F216 70              byte (SHIP_VIPER_EDGES - SHIP_VIPER)%256            ; Edges data offset (low)
37554 F217   C0            byte (SHIP_VIPER_FACES - SHIP_VIPER)%256            ; Faces data offset (low)
37555               
37556 F218 4D              byte >4d                                            ; Max. edge count          = (77 - 1) / 4 = 19
37557 F219   00            byte >00                                            ; Gun vertex               = 0
37558 F21A 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
37559 F21B   5A            byte >5a                                            ; Number of vertices       = 90 / 6 = 15
37560 F21C 14              byte >14                                            ; Number of edges          = 20
37561 F21E 0000            data >0000                                          ; Bounty                   = 0
37562 F220 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
37563 F221   17            byte >17                                            ; Visibility distance      = 23
37564 F222 78              byte >78                                            ; Max. energy              = 120
37565 F223   20            byte >20                                            ; Max. speed               = 32
37566               
37567 F224 00              byte (SHIP_VIPER_EDGES - SHIP_VIPER)/256            ; Edges data offset (high)
37568 F225   00            byte (SHIP_VIPER_FACES - SHIP_VIPER)/256            ; Faces data offset (high)
37569               
37570 F226 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
37571 F227   11            byte >11                                            ; Laser power              = 2
37572                                                                          ; Missiles                 = 1
37573               
37574               SHIP_VIPER_VERTICES:
37575                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37576 F228 0000            byte >00, >00, >48, >1f, >21, >43                   ; Vertex 0
     F22A 481F     
     F22C 2143     
37577 F22E 0010            byte >00, >10, >18, >1e, >10, >22                   ; Vertex 1
     F230 181E     
     F232 1022     
37578 F234 0010            byte >00, >10, >18, >5e, >43, >55                   ; Vertex 2
     F236 185E     
     F238 4355     
37579 F23A 3000            byte >30, >00, >18, >3f, >42, >66                   ; Vertex 3
     F23C 183F     
     F23E 4266     
37580 F240 3000            byte >30, >00, >18, >bf, >31, >66                   ; Vertex 4
     F242 18BF     
     F244 3166     
37581 F246 1810            byte >18, >10, >18, >7e, >54, >66                   ; Vertex 5
     F248 187E     
     F24A 5466     
37582 F24C 1810            byte >18, >10, >18, >fe, >35, >66                   ; Vertex 6
     F24E 18FE     
     F250 3566     
37583 F252 1810            byte >18, >10, >18, >3f, >20, >66                   ; Vertex 7
     F254 183F     
     F256 2066     
37584 F258 1810            byte >18, >10, >18, >bf, >10, >66                   ; Vertex 8
     F25A 18BF     
     F25C 1066     
37585 F25E 2000            byte >20, >00, >18, >b3, >66, >66                   ; Vertex 9
     F260 18B3     
     F262 6666     
37586 F264 2000            byte >20, >00, >18, >33, >66, >66                   ; Vertex 10
     F266 1833     
     F268 6666     
37587 F26A 0808            byte >08, >08, >18, >33, >66, >66                   ; Vertex 11
     F26C 1833     
     F26E 6666     
37588 F270 0808            byte >08, >08, >18, >b3, >66, >66                   ; Vertex 12
     F272 18B3     
     F274 6666     
37589 F276 0808            byte >08, >08, >18, >f2, >66, >66                   ; Vertex 13
     F278 18F2     
     F27A 6666     
37590 F27C 0808            byte >08, >08, >18, >72, >66, >66                   ; Vertex 14
     F27E 1872     
     F280 6666     
37591               
37592               SHIP_VIPER_EDGES:
37593                                                                          ; vertex1, vertex2, face1, face2, visibility
37594 F282 1F42            byte >1f, >42, >00, >0c                             ; Edge 0
     F284 000C     
37595 F286 1E21            byte >1e, >21, >00, >04                             ; Edge 1
     F288 0004     
37596 F28A 1E43            byte >1e, >43, >00, >08                             ; Edge 2
     F28C 0008     
37597 F28E 1F31            byte >1f, >31, >00, >10                             ; Edge 3
     F290 0010     
37598 F292 1E20            byte >1e, >20, >04, >1c                             ; Edge 4
     F294 041C     
37599 F296 1E10            byte >1e, >10, >04, >20                             ; Edge 5
     F298 0420     
37600 F29A 1E54            byte >1e, >54, >08, >14                             ; Edge 6
     F29C 0814     
37601 F29E 1E53            byte >1e, >53, >08, >18                             ; Edge 7
     F2A0 0818     
37602 F2A2 1F60            byte >1f, >60, >1c, >20                             ; Edge 8
     F2A4 1C20     
37603 F2A6 1E65            byte >1e, >65, >14, >18                             ; Edge 9
     F2A8 1418     
37604 F2AA 1F61            byte >1f, >61, >10, >20                             ; Edge 10
     F2AC 1020     
37605 F2AE 1E63            byte >1e, >63, >10, >18                             ; Edge 11
     F2B0 1018     
37606 F2B2 1F62            byte >1f, >62, >0c, >1c                             ; Edge 12
     F2B4 0C1C     
37607 F2B6 1E46            byte >1e, >46, >0c, >14                             ; Edge 13
     F2B8 0C14     
37608 F2BA 1366            byte >13, >66, >24, >30                             ; Edge 14
     F2BC 2430     
37609 F2BE 1266            byte >12, >66, >24, >34                             ; Edge 15
     F2C0 2434     
37610 F2C2 1366            byte >13, >66, >28, >2c                             ; Edge 16
     F2C4 282C     
37611 F2C6 1266            byte >12, >66, >28, >38                             ; Edge 17
     F2C8 2838     
37612 F2CA 1066            byte >10, >66, >2c, >38                             ; Edge 18
     F2CC 2C38     
37613 F2CE 1066            byte >10, >66, >30, >34                             ; Edge 19
     F2D0 3034     
37614               
37615               SHIP_VIPER_FACES:
37616                                                                          ; normal_x, normal_y, normal_z, visibility
37617 F2D2 1F00            byte >1f, >00, >20, >00                             ; Face 0
     F2D4 2000     
37618 F2D6 9F16            byte >9f, >16, >21, >0b                             ; Face 1
     F2D8 210B     
37619 F2DA 1F16            byte >1f, >16, >21, >0b                             ; Face 2
     F2DC 210B     
37620 F2DE DF16            byte >df, >16, >21, >0b                             ; Face 3
     F2E0 210B     
37621 F2E2 5F16            byte >5f, >16, >21, >0b                             ; Face 4
     F2E4 210B     
37622 F2E6 5F00            byte >5f, >00, >20, >00                             ; Face 5
     F2E8 2000     
37623 F2EA 3F00            byte >3f, >00, >00, >30                             ; Face 6
     F2EC 0030     
37624               
37625               * ******************************************************************************
37626               *
37627               * Name: SHIP_MAMBA
37628               * Type: Variable
37629               * Category: Drawing ships
37630               * Summary: Ship blueprint for a Mamba
37631               * Deep dive: Ship blueprints
37632               *
37633               * ******************************************************************************
37634               
37635               SHIP_MAMBA:
37636 F2EE 01              byte >01                                            ; Max. canisters on demise = 1
37637 F2F0 1324            data 70 * 70                                        ; Targetable area          = 70 * 70
37638               
37639 F2F2 AC              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)%256            ; Edges data offset (low)
37640 F2F3   1C            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)%256            ; Faces data offset (low)
37641               
37642 F2F4 5D              byte >5d                                            ; Max. edge count          = (93 - 1) / 4 = 23
37643 F2F5   00            byte >00                                            ; Gun vertex               = 0
37644 F2F6 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
37645 F2F7   96            byte >96                                            ; Number of vertices       = 150 / 6 = 25
37646 F2F8 1C              byte >1c                                            ; Number of edges          = 28
37647 F2FA 9600            data >9600                                          ; Bounty                   = 150
37648 F2FC 14              byte >14                                            ; Number of faces          = 20 / 4 = 5
37649 F2FD   19            byte >19                                            ; Visibility distance      = 25
37650 F2FE 5A              byte >5a                                            ; Max. energy              = 90
37651 F2FF   1E            byte >1e                                            ; Max. speed               = 30
37652               
37653 F300 00              byte (SHIP_MAMBA_EDGES - SHIP_MAMBA)/256            ; Edges data offset (high)
37654 F301   01            byte (SHIP_MAMBA_FACES - SHIP_MAMBA)/256            ; Faces data offset (high)
37655               
37656 F302 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37657 F303   12            byte >12                                            ; Laser power              = 2
37658                                                                          ; Missiles                 = 2
37659               
37660               SHIP_MAMBA_VERTICES:
37661                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37662 F304 0000            byte >00, >00, >40, >1f, >10, >32                   ; Vertex 0
     F306 401F     
     F308 1032     
37663 F30A 4008            byte >40, >08, >20, >ff, >20, >44                   ; Vertex 1
     F30C 20FF     
     F30E 2044     
37664 F310 2008            byte >20, >08, >20, >be, >21, >44                   ; Vertex 2
     F312 20BE     
     F314 2144     
37665 F316 2008            byte >20, >08, >20, >3e, >31, >44                   ; Vertex 3
     F318 203E     
     F31A 3144     
37666 F31C 4008            byte >40, >08, >20, >7f, >30, >44                   ; Vertex 4
     F31E 207F     
     F320 3044     
37667 F322 0404            byte >04, >04, >10, >8e, >11, >11                   ; Vertex 5
     F324 108E     
     F326 1111     
37668 F328 0404            byte >04, >04, >10, >0e, >11, >11                   ; Vertex 6
     F32A 100E     
     F32C 1111     
37669 F32E 0803            byte >08, >03, >1c, >0d, >11, >11                   ; Vertex 7
     F330 1C0D     
     F332 1111     
37670 F334 0803            byte >08, >03, >1c, >8d, >11, >11                   ; Vertex 8
     F336 1C8D     
     F338 1111     
37671 F33A 1404            byte >14, >04, >10, >d4, >00, >00                   ; Vertex 9
     F33C 10D4     
     F33E 0000     
37672 F340 1404            byte >14, >04, >10, >54, >00, >00                   ; Vertex 10
     F342 1054     
     F344 0000     
37673 F346 1807            byte >18, >07, >14, >f4, >00, >00                   ; Vertex 11
     F348 14F4     
     F34A 0000     
37674 F34C 1007            byte >10, >07, >14, >f0, >00, >00                   ; Vertex 12
     F34E 14F0     
     F350 0000     
37675 F352 1007            byte >10, >07, >14, >70, >00, >00                   ; Vertex 13
     F354 1470     
     F356 0000     
37676 F358 1807            byte >18, >07, >14, >74, >00, >00                   ; Vertex 14
     F35A 1474     
     F35C 0000     
37677 F35E 0804            byte >08, >04, >20, >ad, >44, >44                   ; Vertex 15
     F360 20AD     
     F362 4444     
37678 F364 0804            byte >08, >04, >20, >2d, >44, >44                   ; Vertex 16
     F366 202D     
     F368 4444     
37679 F36A 0804            byte >08, >04, >20, >6e, >44, >44                   ; Vertex 17
     F36C 206E     
     F36E 4444     
37680 F370 0804            byte >08, >04, >20, >ee, >44, >44                   ; Vertex 18
     F372 20EE     
     F374 4444     
37681 F376 2004            byte >20, >04, >20, >a7, >44, >44                   ; Vertex 19
     F378 20A7     
     F37A 4444     
37682 F37C 2004            byte >20, >04, >20, >27, >44, >44                   ; Vertex 20
     F37E 2027     
     F380 4444     
37683 F382 2404            byte >24, >04, >20, >67, >44, >44                   ; Vertex 21
     F384 2067     
     F386 4444     
37684 F388 2404            byte >24, >04, >20, >e7, >44, >44                   ; Vertex 22
     F38A 20E7     
     F38C 4444     
37685 F38E 2600            byte >26, >00, >20, >a5, >44, >44                   ; Vertex 23
     F390 20A5     
     F392 4444     
37686 F394 2600            byte >26, >00, >20, >25, >44, >44                   ; Vertex 24
     F396 2025     
     F398 4444     
37687               
37688               SHIP_MAMBA_EDGES:
37689                                                                          ; vertex1, vertex2, face1, face2, visibility
37690 F39A 1F20            byte >1f, >20, >00, >04                             ; Edge 0
     F39C 0004     
37691 F39E 1F30            byte >1f, >30, >00, >10                             ; Edge 1
     F3A0 0010     
37692 F3A2 1F40            byte >1f, >40, >04, >10                             ; Edge 2
     F3A4 0410     
37693 F3A6 1E42            byte >1e, >42, >04, >08                             ; Edge 3
     F3A8 0408     
37694 F3AA 1E41            byte >1e, >41, >08, >0c                             ; Edge 4
     F3AC 080C     
37695 F3AE 1E43            byte >1e, >43, >0c, >10                             ; Edge 5
     F3B0 0C10     
37696 F3B2 0E11            byte >0e, >11, >14, >18                             ; Edge 6
     F3B4 1418     
37697 F3B6 0C11            byte >0c, >11, >18, >1c                             ; Edge 7
     F3B8 181C     
37698 F3BA 0D11            byte >0d, >11, >1c, >20                             ; Edge 8
     F3BC 1C20     
37699 F3BE 0C11            byte >0c, >11, >14, >20                             ; Edge 9
     F3C0 1420     
37700 F3C2 1400            byte >14, >00, >24, >2c                             ; Edge 10
     F3C4 242C     
37701 F3C6 1000            byte >10, >00, >24, >30                             ; Edge 11
     F3C8 2430     
37702 F3CA 1000            byte >10, >00, >28, >34                             ; Edge 12
     F3CC 2834     
37703 F3CE 1400            byte >14, >00, >28, >38                             ; Edge 13
     F3D0 2838     
37704 F3D2 0E00            byte >0e, >00, >34, >38                             ; Edge 14
     F3D4 3438     
37705 F3D6 0E00            byte >0e, >00, >2c, >30                             ; Edge 15
     F3D8 2C30     
37706 F3DA 0D44            byte >0d, >44, >3c, >40                             ; Edge 16
     F3DC 3C40     
37707 F3DE 0E44            byte >0e, >44, >44, >48                             ; Edge 17
     F3E0 4448     
37708 F3E2 0C44            byte >0c, >44, >3c, >48                             ; Edge 18
     F3E4 3C48     
37709 F3E6 0C44            byte >0c, >44, >40, >44                             ; Edge 19
     F3E8 4044     
37710 F3EA 0744            byte >07, >44, >50, >54                             ; Edge 20
     F3EC 5054     
37711 F3EE 0544            byte >05, >44, >50, >60                             ; Edge 21
     F3F0 5060     
37712 F3F2 0544            byte >05, >44, >54, >60                             ; Edge 22
     F3F4 5460     
37713 F3F6 0744            byte >07, >44, >4c, >58                             ; Edge 23
     F3F8 4C58     
37714 F3FA 0544            byte >05, >44, >4c, >5c                             ; Edge 24
     F3FC 4C5C     
37715 F3FE 0544            byte >05, >44, >58, >5c                             ; Edge 25
     F400 585C     
37716 F402 1E21            byte >1e, >21, >00, >08                             ; Edge 26
     F404 0008     
37717 F406 1E31            byte >1e, >31, >00, >0c                             ; Edge 27
     F408 000C     
37718               
37719               SHIP_MAMBA_FACES:
37720                                                                          ; normal_x, normal_y, normal_z, visibility
37721 F40A 5E00            byte >5e, >00, >18, >02                             ; Face 0
     F40C 1802     
37722 F40E 1E00            byte >1e, >00, >18, >02                             ; Face 1
     F410 1802     
37723 F412 9E20            byte >9e, >20, >40, >10                             ; Face 2
     F414 4010     
37724 F416 1E20            byte >1e, >20, >40, >10                             ; Face 3
     F418 4010     
37725 F41A 3E00            byte >3e, >00, >00, >7f                             ; Face 4
     F41C 007F     
37726               
37727               * ******************************************************************************
37728               *
37729               * Name: SHIP_COBRA_MK_3
37730               * Type: Variable
37731               * Category: Drawing ships
37732               * Summary: Ship blueprint for a Cobra Mk III
37733               * Deep dive: Ship blueprints
37734               *
37735               * ******************************************************************************
37736               
37737               SHIP_COBRA_MK_3:
37738 F41E 03              byte >03                                            ; Max. canisters on demise = 3
37739 F420 2341            data 95 * 95                                        ; Targetable area          = 95 * 95
37740               
37741 F422 BE              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)%256  ; Edges data offset (low)
37742 F423   56            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)%256  ; Faces data offset (low)
37743               
37744 F424 99              byte >99                                            ; Max. edge count          = (153 - 1) / 4 = 38
37745 F425   54            byte >54                                            ; Gun vertex               = 84 / 4 = 21
37746 F426 2A              byte >2a                                            ; Explosion count          = 9, as (4 * n) + 6 = 42
37747 F427   A8            byte >a8                                            ; Number of vertices       = 168 / 6 = 28
37748 F428 26              byte >26                                            ; Number of edges          = 38
37749 F42A 0000            data >0000                                          ; Bounty                   = 0
37750 F42C 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
37751 F42D   32            byte >32                                            ; Visibility distance      = 50
37752 F42E 96              byte >96                                            ; Max. energy              = 150
37753 F42F   1C            byte >1c                                            ; Max. speed               = 28
37754               
37755 F430 00              byte (SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)/256  ; Edges data offset (low)
37756 F431   01            byte (SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)/256  ; Faces data offset (low)
37757               
37758 F432 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
37759 F433   13            byte >13                                            ; Laser power              = 2
37760                                                                          ; Missiles                 = 3
37761               
37762               SHIP_COBRA_MK_3_VERTICES:
37763                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37764 F434 2000            byte >20, >00, >4c, >1f, >ff, >ff                   ; Vertex 0
     F436 4C1F     
     F438 FFFF     
37765 F43A 2000            byte >20, >00, >4c, >9f, >ff, >ff                   ; Vertex 1
     F43C 4C9F     
     F43E FFFF     
37766 F440 001A            byte >00, >1a, >18, >1f, >ff, >ff                   ; Vertex 2
     F442 181F     
     F444 FFFF     
37767 F446 7803            byte >78, >03, >08, >ff, >73, >aa                   ; Vertex 3
     F448 08FF     
     F44A 73AA     
37768 F44C 7803            byte >78, >03, >08, >7f, >84, >cc                   ; Vertex 4
     F44E 087F     
     F450 84CC     
37769 F452 5810            byte >58, >10, >28, >bf, >ff, >ff                   ; Vertex 5
     F454 28BF     
     F456 FFFF     
37770 F458 5810            byte >58, >10, >28, >3f, >ff, >ff                   ; Vertex 6
     F45A 283F     
     F45C FFFF     
37771 F45E 8008            byte >80, >08, >28, >7f, >98, >cc                   ; Vertex 7
     F460 287F     
     F462 98CC     
37772 F464 8008            byte >80, >08, >28, >ff, >97, >aa                   ; Vertex 8
     F466 28FF     
     F468 97AA     
37773 F46A 001A            byte >00, >1a, >28, >3f, >65, >99                   ; Vertex 9
     F46C 283F     
     F46E 6599     
37774 F470 2018            byte >20, >18, >28, >ff, >a9, >bb                   ; Vertex 10
     F472 28FF     
     F474 A9BB     
37775 F476 2018            byte >20, >18, >28, >7f, >b9, >cc                   ; Vertex 11
     F478 287F     
     F47A B9CC     
37776 F47C 2408            byte >24, >08, >28, >b4, >99, >99                   ; Vertex 12
     F47E 28B4     
     F480 9999     
37777 F482 080C            byte >08, >0c, >28, >b4, >99, >99                   ; Vertex 13
     F484 28B4     
     F486 9999     
37778 F488 080C            byte >08, >0c, >28, >34, >99, >99                   ; Vertex 14
     F48A 2834     
     F48C 9999     
37779 F48E 2408            byte >24, >08, >28, >34, >99, >99                   ; Vertex 15
     F490 2834     
     F492 9999     
37780 F494 240C            byte >24, >0c, >28, >74, >99, >99                   ; Vertex 16
     F496 2874     
     F498 9999     
37781 F49A 0810            byte >08, >10, >28, >74, >99, >99                   ; Vertex 17
     F49C 2874     
     F49E 9999     
37782 F4A0 0810            byte >08, >10, >28, >f4, >99, >99                   ; Vertex 18
     F4A2 28F4     
     F4A4 9999     
37783 F4A6 240C            byte >24, >0c, >28, >f4, >99, >99                   ; Vertex 19
     F4A8 28F4     
     F4AA 9999     
37784 F4AC 0000            byte >00, >00, >4c, >06, >b0, >bb                   ; Vertex 20
     F4AE 4C06     
     F4B0 B0BB     
37785 F4B2 0000            byte >00, >00, >5a, >1f, >b0, >bb                   ; Vertex 21
     F4B4 5A1F     
     F4B6 B0BB     
37786 F4B8 5006            byte >50, >06, >28, >e8, >99, >99                   ; Vertex 22
     F4BA 28E8     
     F4BC 9999     
37787 F4BE 5006            byte >50, >06, >28, >a8, >99, >99                   ; Vertex 23
     F4C0 28A8     
     F4C2 9999     
37788 F4C4 5800            byte >58, >00, >28, >a6, >99, >99                   ; Vertex 24
     F4C6 28A6     
     F4C8 9999     
37789 F4CA 5006            byte >50, >06, >28, >28, >99, >99                   ; Vertex 25
     F4CC 2828     
     F4CE 9999     
37790 F4D0 5800            byte >58, >00, >28, >26, >99, >99                   ; Vertex 26
     F4D2 2826     
     F4D4 9999     
37791 F4D6 5006            byte >50, >06, >28, >68, >99, >99                   ; Vertex 27
     F4D8 2868     
     F4DA 9999     
37792               
37793               SHIP_COBRA_MK_3_EDGES:
37794                                                                          ; vertex1, vertex2, face1, face2, visibility
37795 F4DC 1FB0            byte >1f, >b0, >00, >04                             ; Edge 0
     F4DE 0004     
37796 F4E0 1FC4            byte >1f, >c4, >00, >10                             ; Edge 1
     F4E2 0010     
37797 F4E4 1FA3            byte >1f, >a3, >04, >0c                             ; Edge 2
     F4E6 040C     
37798 F4E8 1FA7            byte >1f, >a7, >0c, >20                             ; Edge 3
     F4EA 0C20     
37799 F4EC 1FC8            byte >1f, >c8, >10, >1c                             ; Edge 4
     F4EE 101C     
37800 F4F0 1F98            byte >1f, >98, >18, >1c                             ; Edge 5
     F4F2 181C     
37801 F4F4 1F96            byte >1f, >96, >18, >24                             ; Edge 6
     F4F6 1824     
37802 F4F8 1F95            byte >1f, >95, >14, >24                             ; Edge 7
     F4FA 1424     
37803 F4FC 1F97            byte >1f, >97, >14, >20                             ; Edge 8
     F4FE 1420     
37804 F500 1F51            byte >1f, >51, >08, >14                             ; Edge 9
     F502 0814     
37805 F504 1F62            byte >1f, >62, >08, >18                             ; Edge 10
     F506 0818     
37806 F508 1F73            byte >1f, >73, >0c, >14                             ; Edge 11
     F50A 0C14     
37807 F50C 1F84            byte >1f, >84, >10, >18                             ; Edge 12
     F50E 1018     
37808 F510 1F10            byte >1f, >10, >04, >08                             ; Edge 13
     F512 0408     
37809 F514 1F20            byte >1f, >20, >00, >08                             ; Edge 14
     F516 0008     
37810 F518 1FA9            byte >1f, >a9, >20, >28                             ; Edge 15
     F51A 2028     
37811 F51C 1FB9            byte >1f, >b9, >28, >2c                             ; Edge 16
     F51E 282C     
37812 F520 1FC9            byte >1f, >c9, >1c, >2c                             ; Edge 17
     F522 1C2C     
37813 F524 1FBA            byte >1f, >ba, >04, >28                             ; Edge 18
     F526 0428     
37814 F528 1FCB            byte >1f, >cb, >00, >2c                             ; Edge 19
     F52A 002C     
37815 F52C 1D31            byte >1d, >31, >04, >14                             ; Edge 20
     F52E 0414     
37816 F530 1D42            byte >1d, >42, >00, >18                             ; Edge 21
     F532 0018     
37817 F534 06B0            byte >06, >b0, >50, >54                             ; Edge 22
     F536 5054     
37818 F538 1499            byte >14, >99, >30, >34                             ; Edge 23
     F53A 3034     
37819 F53C 1499            byte >14, >99, >48, >4c                             ; Edge 24
     F53E 484C     
37820 F540 1499            byte >14, >99, >38, >3c                             ; Edge 25
     F542 383C     
37821 F544 1499            byte >14, >99, >40, >44                             ; Edge 26
     F546 4044     
37822 F548 1399            byte >13, >99, >3c, >40                             ; Edge 27
     F54A 3C40     
37823 F54C 1199            byte >11, >99, >38, >44                             ; Edge 28
     F54E 3844     
37824 F550 1399            byte >13, >99, >34, >48                             ; Edge 29
     F552 3448     
37825 F554 1399            byte >13, >99, >30, >4c                             ; Edge 30
     F556 304C     
37826 F558 1E65            byte >1e, >65, >08, >24                             ; Edge 31
     F55A 0824     
37827 F55C 0699            byte >06, >99, >58, >60                             ; Edge 32
     F55E 5860     
37828 F560 0699            byte >06, >99, >5c, >60                             ; Edge 33
     F562 5C60     
37829 F564 0899            byte >08, >99, >58, >5c                             ; Edge 34
     F566 585C     
37830 F568 0699            byte >06, >99, >64, >68                             ; Edge 35
     F56A 6468     
37831 F56C 0699            byte >06, >99, >68, >6c                             ; Edge 36
     F56E 686C     
37832 F570 0899            byte >08, >99, >64, >6c                             ; Edge 37
     F572 646C     
37833               
37834               SHIP_COBRA_MK_3_FACES:
37835                                                                          ; normal_x, normal_y, normal_z, visibility
37836 F574 1F00            byte >1f, >00, >3e, >1f                             ; Face 0
     F576 3E1F     
37837 F578 9F12            byte >9f, >12, >37, >10                             ; Face 1
     F57A 3710     
37838 F57C 1F12            byte >1f, >12, >37, >10                             ; Face 2
     F57E 3710     
37839 F580 9F10            byte >9f, >10, >34, >0e                             ; Face 3
     F582 340E     
37840 F584 1F10            byte >1f, >10, >34, >0e                             ; Face 4
     F586 340E     
37841 F588 9F0E            byte >9f, >0e, >2f, >00                             ; Face 5
     F58A 2F00     
37842 F58C 1F0E            byte >1f, >0e, >2f, >00                             ; Face 6
     F58E 2F00     
37843 F590 9F3D            byte >9f, >3d, >66, >00                             ; Face 7
     F592 6600     
37844 F594 1F3D            byte >1f, >3d, >66, >00                             ; Face 8
     F596 6600     
37845 F598 3F00            byte >3f, >00, >00, >50                             ; Face 9
     F59A 0050     
37846 F59C DF07            byte >df, >07, >2a, >09                             ; Face 10
     F59E 2A09     
37847 F5A0 5F00            byte >5f, >00, >1e, >06                             ; Face 11
     F5A2 1E06     
37848 F5A4 5F07            byte >5f, >07, >2a, >09                             ; Face 12
     F5A6 2A09     
37849               
37850               * ******************************************************************************
37851               *
37852               * Name: SHIP_THARGOID
37853               * Type: Variable
37854               * Category: Drawing ships
37855               * Summary: Ship blueprint for a Thargoid mothership
37856               * Deep dive: Ship blueprints
37857               *
37858               * ******************************************************************************
37859               
37860               SHIP_THARGOID:
37861 F5A8 00              byte >00                                            ; Max. canisters on demise = 0
37862 F5AA 2649            data 99 * 99                                        ; Targetable area          = 99 * 99
37863               
37864 F5AC 8E              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)%256      ; Edges data offset (low)
37865 F5AD   F6            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)%256      ; Faces data offset (low)
37866               
37867 F5AE 65              byte >65                                            ; Max. edge count          = (101 - 1) / 4 = 25
37868 F5AF   3C            byte >3c                                            ; Gun vertex               = 60 / 4 = 15
37869 F5B0 26              byte >26                                            ; Explosion count          = 8, as (4 * n) + 6 = 38
37870 F5B1   78            byte >78                                            ; Number of vertices       = 120 / 6 = 20
37871 F5B2 1A              byte >1a                                            ; Number of edges          = 26
37872 F5B4 F401            data >f401                                          ; Bounty                   = 500
37873 F5B6 28              byte >28                                            ; Number of faces          = 40 / 4 = 10
37874 F5B7   37            byte >37                                            ; Visibility distance      = 55
37875 F5B8 F0              byte >f0                                            ; Max. energy              = 240
37876 F5B9   27            byte >27                                            ; Max. speed               = 39
37877               
37878 F5BA 00              byte (SHIP_THARGOID_EDGES - SHIP_THARGOID)/256      ; Edges data offset (high)
37879 F5BB   00            byte (SHIP_THARGOID_FACES - SHIP_THARGOID)/256      ; Faces data offset (high)
37880               
37881 F5BC 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
37882 F5BD   16            byte >16                                            ; Laser power              = 2
37883                                                                          ; Missiles                 = 6
37884               
37885               SHIP_THARGOID_VERTICES:
37886                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37887 F5BE 2030            byte >20, >30, >30, >5f, >40, >88                   ; Vertex 0
     F5C0 305F     
     F5C2 4088     
37888 F5C4 2044            byte >20, >44, >00, >5f, >10, >44                   ; Vertex 1
     F5C6 005F     
     F5C8 1044     
37889 F5CA 2030            byte >20, >30, >30, >7f, >21, >44                   ; Vertex 2
     F5CC 307F     
     F5CE 2144     
37890 F5D0 2000            byte >20, >00, >44, >3f, >32, >44                   ; Vertex 3
     F5D2 443F     
     F5D4 3244     
37891 F5D6 2030            byte >20, >30, >30, >3f, >43, >55                   ; Vertex 4
     F5D8 303F     
     F5DA 4355     
37892 F5DC 2044            byte >20, >44, >00, >1f, >54, >66                   ; Vertex 5
     F5DE 001F     
     F5E0 5466     
37893 F5E2 2030            byte >20, >30, >30, >1f, >64, >77                   ; Vertex 6
     F5E4 301F     
     F5E6 6477     
37894 F5E8 2000            byte >20, >00, >44, >1f, >74, >88                   ; Vertex 7
     F5EA 441F     
     F5EC 7488     
37895 F5EE 1874            byte >18, >74, >74, >df, >80, >99                   ; Vertex 8
     F5F0 74DF     
     F5F2 8099     
37896 F5F4 18A4            byte >18, >a4, >00, >df, >10, >99                   ; Vertex 9
     F5F6 00DF     
     F5F8 1099     
37897 F5FA 1874            byte >18, >74, >74, >ff, >21, >99                   ; Vertex 10
     F5FC 74FF     
     F5FE 2199     
37898 F600 1800            byte >18, >00, >a4, >bf, >32, >99                   ; Vertex 11
     F602 A4BF     
     F604 3299     
37899 F606 1874            byte >18, >74, >74, >bf, >53, >99                   ; Vertex 12
     F608 74BF     
     F60A 5399     
37900 F60C 18A4            byte >18, >a4, >00, >9f, >65, >99                   ; Vertex 13
     F60E 009F     
     F610 6599     
37901 F612 1874            byte >18, >74, >74, >9f, >76, >99                   ; Vertex 14
     F614 749F     
     F616 7699     
37902 F618 1800            byte >18, >00, >a4, >9f, >87, >99                   ; Vertex 15
     F61A A49F     
     F61C 8799     
37903 F61E 1840            byte >18, >40, >50, >9e, >99, >99                   ; Vertex 16
     F620 509E     
     F622 9999     
37904 F624 1840            byte >18, >40, >50, >be, >99, >99                   ; Vertex 17
     F626 50BE     
     F628 9999     
37905 F62A 1840            byte >18, >40, >50, >fe, >99, >99                   ; Vertex 18
     F62C 50FE     
     F62E 9999     
37906 F630 1840            byte >18, >40, >50, >de, >99, >99                   ; Vertex 19
     F632 50DE     
     F634 9999     
37907               
37908               SHIP_THARGOID_EDGES:
37909                                                                          ; vertex1, vertex2, face1, face2, visibility
37910 F636 1F84            byte >1f, >84, >00, >1c                             ; Edge 0
     F638 001C     
37911 F63A 1F40            byte >1f, >40, >00, >04                             ; Edge 1
     F63C 0004     
37912 F63E 1F41            byte >1f, >41, >04, >08                             ; Edge 2
     F640 0408     
37913 F642 1F42            byte >1f, >42, >08, >0c                             ; Edge 3
     F644 080C     
37914 F646 1F43            byte >1f, >43, >0c, >10                             ; Edge 4
     F648 0C10     
37915 F64A 1F54            byte >1f, >54, >10, >14                             ; Edge 5
     F64C 1014     
37916 F64E 1F64            byte >1f, >64, >14, >18                             ; Edge 6
     F650 1418     
37917 F652 1F74            byte >1f, >74, >18, >1c                             ; Edge 7
     F654 181C     
37918 F656 1F80            byte >1f, >80, >00, >20                             ; Edge 8
     F658 0020     
37919 F65A 1F10            byte >1f, >10, >04, >24                             ; Edge 9
     F65C 0424     
37920 F65E 1F21            byte >1f, >21, >08, >28                             ; Edge 10
     F660 0828     
37921 F662 1F32            byte >1f, >32, >0c, >2c                             ; Edge 11
     F664 0C2C     
37922 F666 1F53            byte >1f, >53, >10, >30                             ; Edge 12
     F668 1030     
37923 F66A 1F65            byte >1f, >65, >14, >34                             ; Edge 13
     F66C 1434     
37924 F66E 1F76            byte >1f, >76, >18, >38                             ; Edge 14
     F670 1838     
37925 F672 1F87            byte >1f, >87, >1c, >3c                             ; Edge 15
     F674 1C3C     
37926 F676 1F98            byte >1f, >98, >20, >3c                             ; Edge 16
     F678 203C     
37927 F67A 1F90            byte >1f, >90, >20, >24                             ; Edge 17
     F67C 2024     
37928 F67E 1F91            byte >1f, >91, >24, >28                             ; Edge 18
     F680 2428     
37929 F682 1F92            byte >1f, >92, >28, >2c                             ; Edge 19
     F684 282C     
37930 F686 1F93            byte >1f, >93, >2c, >30                             ; Edge 20
     F688 2C30     
37931 F68A 1F95            byte >1f, >95, >30, >34                             ; Edge 21
     F68C 3034     
37932 F68E 1F96            byte >1f, >96, >34, >38                             ; Edge 22
     F690 3438     
37933 F692 1F97            byte >1f, >97, >38, >3c                             ; Edge 23
     F694 383C     
37934 F696 1E99            byte >1e, >99, >40, >44                             ; Edge 24
     F698 4044     
37935 F69A 1E99            byte >1e, >99, >48, >4c                             ; Edge 25
     F69C 484C     
37936               
37937               SHIP_THARGOID_FACES:
37938                                                                          ; normal_x, normal_y, normal_z, visibility
37939 F69E 5F67            byte >5f, >67, >3c, >19                             ; Face 0
     F6A0 3C19     
37940 F6A2 7F67            byte >7f, >67, >3c, >19                             ; Face 1
     F6A4 3C19     
37941 F6A6 7F67            byte >7f, >67, >19, >3c                             ; Face 2
     F6A8 193C     
37942 F6AA 3F67            byte >3f, >67, >19, >3c                             ; Face 3
     F6AC 193C     
37943 F6AE 1F40            byte >1f, >40, >00, >00                             ; Face 4
     F6B0 0000     
37944 F6B2 3F67            byte >3f, >67, >3c, >19                             ; Face 5
     F6B4 3C19     
37945 F6B6 1F67            byte >1f, >67, >3c, >19                             ; Face 6
     F6B8 3C19     
37946 F6BA 1F67            byte >1f, >67, >19, >3c                             ; Face 7
     F6BC 193C     
37947 F6BE 5F67            byte >5f, >67, >19, >3c                             ; Face 8
     F6C0 193C     
37948 F6C2 9F30            byte >9f, >30, >00, >00                             ; Face 9
     F6C4 0000     
37949               
37950               * ******************************************************************************
37951               *
37952               * Name: SHIP_CORIOLIS
37953               * Type: Variable
37954               * Category: Drawing ships
37955               * Summary: Ship blueprint for a Coriolis space station
37956               * Deep dive: Ship blueprints
37957               *
37958               * ******************************************************************************
37959               
37960               SHIP_CORIOLIS:
37961 F6C6 00              byte >00                                            ; Max. canisters on demise = 0
37962 F6C8 6400            data 160 * 160                                      ; Targetable area          = 160 * 160
37963               
37964 F6CA 76              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)%256      ; Edges data offset (low)
37965 F6CB   E6            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)%256      ; Faces data offset (low)
37966               
37967 F6CC 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
37968 F6CD   00            byte >00                                            ; Gun vertex               = 0
37969 F6CE 36              byte >36                                            ; Explosion count          = 12, as (4 * n) + 6 = 54
37970 F6CF   60            byte >60                                            ; Number of vertices       = 96 / 6 = 16
37971 F6D0 1C              byte >1c                                            ; Number of edges          = 28
37972 F6D2 0000            data >0000                                          ; Bounty                   = 0
37973 F6D4 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
37974 F6D5   78            byte >78                                            ; Visibility distance      = 120
37975 F6D6 F0              byte >f0                                            ; Max. energy              = 240
37976 F6D7   00            byte >00                                            ; Max. speed               = 0
37977               
37978 F6D8 00              byte (SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)/256      ; Edges data offset (high)
37979 F6D9   00            byte (SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)/256      ; Faces data offset (high)
37980               
37981 F6DA 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
37982 F6DB   06            byte >06                                            ; Laser power              = 0
37983                                                                          ; Missiles                 = 6
37984               
37985               SHIP_CORIOLIS_VERTICES:
37986                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
37987 F6DC A000            byte >a0, >00, >a0, >1f, >10, >62                   ; Vertex 0
     F6DE A01F     
     F6E0 1062     
37988 F6E2 00A0            byte >00, >a0, >a0, >1f, >20, >83                   ; Vertex 1
     F6E4 A01F     
     F6E6 2083     
37989 F6E8 A000            byte >a0, >00, >a0, >9f, >30, >74                   ; Vertex 2
     F6EA A09F     
     F6EC 3074     
37990 F6EE 00A0            byte >00, >a0, >a0, >5f, >10, >54                   ; Vertex 3
     F6F0 A05F     
     F6F2 1054     
37991 F6F4 A0A0            byte >a0, >a0, >00, >5f, >51, >a6                   ; Vertex 4
     F6F6 005F     
     F6F8 51A6     
37992 F6FA A0A0            byte >a0, >a0, >00, >1f, >62, >b8                   ; Vertex 5
     F6FC 001F     
     F6FE 62B8     
37993 F700 A0A0            byte >a0, >a0, >00, >9f, >73, >c8                   ; Vertex 6
     F702 009F     
     F704 73C8     
37994 F706 A0A0            byte >a0, >a0, >00, >df, >54, >97                   ; Vertex 7
     F708 00DF     
     F70A 5497     
37995 F70C A000            byte >a0, >00, >a0, >3f, >a6, >db                   ; Vertex 8
     F70E A03F     
     F710 A6DB     
37996 F712 00A0            byte >00, >a0, >a0, >3f, >b8, >dc                   ; Vertex 9
     F714 A03F     
     F716 B8DC     
37997 F718 A000            byte >a0, >00, >a0, >bf, >97, >dc                   ; Vertex 10
     F71A A0BF     
     F71C 97DC     
37998 F71E 00A0            byte >00, >a0, >a0, >7f, >95, >da                   ; Vertex 11
     F720 A07F     
     F722 95DA     
37999 F724 0A1E            byte >0a, >1e, >a0, >5e, >00, >00                   ; Vertex 12
     F726 A05E     
     F728 0000     
38000 F72A 0A1E            byte >0a, >1e, >a0, >1e, >00, >00                   ; Vertex 13
     F72C A01E     
     F72E 0000     
38001 F730 0A1E            byte >0a, >1e, >a0, >9e, >00, >00                   ; Vertex 14
     F732 A09E     
     F734 0000     
38002 F736 0A1E            byte >0a, >1e, >a0, >de, >00, >00                   ; Vertex 15
     F738 A0DE     
     F73A 0000     
38003               
38004               SHIP_CORIOLIS_EDGES:
38005                                                                          ; vertex1, vertex2, face1, face2, visibility
38006 F73C 1F10            byte >1f, >10, >00, >0c                             ; Edge 0
     F73E 000C     
38007 F740 1F20            byte >1f, >20, >00, >04                             ; Edge 1
     F742 0004     
38008 F744 1F30            byte >1f, >30, >04, >08                             ; Edge 2
     F746 0408     
38009 F748 1F40            byte >1f, >40, >08, >0c                             ; Edge 3
     F74A 080C     
38010 F74C 1F51            byte >1f, >51, >0c, >10                             ; Edge 4
     F74E 0C10     
38011 F750 1F61            byte >1f, >61, >00, >10                             ; Edge 5
     F752 0010     
38012 F754 1F62            byte >1f, >62, >00, >14                             ; Edge 6
     F756 0014     
38013 F758 1F82            byte >1f, >82, >14, >04                             ; Edge 7
     F75A 1404     
38014 F75C 1F83            byte >1f, >83, >04, >18                             ; Edge 8
     F75E 0418     
38015 F760 1F73            byte >1f, >73, >08, >18                             ; Edge 9
     F762 0818     
38016 F764 1F74            byte >1f, >74, >08, >1c                             ; Edge 10
     F766 081C     
38017 F768 1F54            byte >1f, >54, >0c, >1c                             ; Edge 11
     F76A 0C1C     
38018 F76C 1FDA            byte >1f, >da, >20, >2c                             ; Edge 12
     F76E 202C     
38019 F770 1FDB            byte >1f, >db, >20, >24                             ; Edge 13
     F772 2024     
38020 F774 1FDC            byte >1f, >dc, >24, >28                             ; Edge 14
     F776 2428     
38021 F778 1FD9            byte >1f, >d9, >28, >2c                             ; Edge 15
     F77A 282C     
38022 F77C 1FA5            byte >1f, >a5, >10, >2c                             ; Edge 16
     F77E 102C     
38023 F780 1FA6            byte >1f, >a6, >10, >20                             ; Edge 17
     F782 1020     
38024 F784 1FB6            byte >1f, >b6, >14, >20                             ; Edge 18
     F786 1420     
38025 F788 1FB8            byte >1f, >b8, >14, >24                             ; Edge 19
     F78A 1424     
38026 F78C 1FC8            byte >1f, >c8, >18, >24                             ; Edge 20
     F78E 1824     
38027 F790 1FC7            byte >1f, >c7, >18, >28                             ; Edge 21
     F792 1828     
38028 F794 1F97            byte >1f, >97, >1c, >28                             ; Edge 22
     F796 1C28     
38029 F798 1F95            byte >1f, >95, >1c, >2c                             ; Edge 23
     F79A 1C2C     
38030 F79C 1E00            byte >1e, >00, >30, >34                             ; Edge 24
     F79E 3034     
38031 F7A0 1E00            byte >1e, >00, >34, >38                             ; Edge 25
     F7A2 3438     
38032 F7A4 1E00            byte >1e, >00, >38, >3c                             ; Edge 26
     F7A6 383C     
38033 F7A8 1E00            byte >1e, >00, >3c, >30                             ; Edge 27
     F7AA 3C30     
38034               
38035               SHIP_CORIOLIS_FACES:
38036                                                                          ; normal_x, normal_y, normal_z, visibility
38037 F7AC 1F00            byte >1f, >00, >00, >a0                             ; Face 0
     F7AE 00A0     
38038 F7B0 5F6B            byte >5f, >6b, >6b, >6b                             ; Face 1
     F7B2 6B6B     
38039 F7B4 1F6B            byte >1f, >6b, >6b, >6b                             ; Face 2
     F7B6 6B6B     
38040 F7B8 9F6B            byte >9f, >6b, >6b, >6b                             ; Face 3
     F7BA 6B6B     
38041 F7BC DF6B            byte >df, >6b, >6b, >6b                             ; Face 4
     F7BE 6B6B     
38042 F7C0 5F00            byte >5f, >00, >a0, >00                             ; Face 5
     F7C2 A000     
38043 F7C4 1FA0            byte >1f, >a0, >00, >00                             ; Face 6
     F7C6 0000     
38044 F7C8 9FA0            byte >9f, >a0, >00, >00                             ; Face 7
     F7CA 0000     
38045 F7CC 1F00            byte >1f, >00, >a0, >00                             ; Face 8
     F7CE A000     
38046 F7D0 FF6B            byte >ff, >6b, >6b, >6b                             ; Face 9
     F7D2 6B6B     
38047 F7D4 7F6B            byte >7f, >6b, >6b, >6b                             ; Face 10
     F7D6 6B6B     
38048 F7D8 3F6B            byte >3f, >6b, >6b, >6b                             ; Face 11
     F7DA 6B6B     
38049 F7DC BF6B            byte >bf, >6b, >6b, >6b                             ; Face 12
     F7DE 6B6B     
38050 F7E0 3F00            byte >3f, >00, >00, >a0                             ; Face 13
     F7E2 00A0     
38051               
38052               * ******************************************************************************
38053               *
38054               * Name: SHIP_MISSILE
38055               * Type: Variable
38056               * Category: Drawing ships
38057               * Summary: Ship blueprint for a missile
38058               * Deep dive: Ship blueprints
38059               *
38060               * ******************************************************************************
38061               
38062               SHIP_MISSILE:
38063 F7E4 00              byte >00                                            ; Max. canisters on demise = 0
38064 F7E6 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
38065               
38066 F7E8 7C              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)%256        ; Edges data offset (low)
38067 F7E9   DC            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)%256        ; Faces data offset (low)
38068               
38069 F7EA 51              byte >51                                            ; Max. edge count          = (81 - 1) / 4 = 20
38070 F7EB   00            byte >00                                            ; Gun vertex               = 0
38071 F7EC 0A              byte >0a                                            ; Explosion count          = 1, as (4 * n) + 6 = 10
38072 F7ED   66            byte >66                                            ; Number of vertices       = 102 / 6 = 17
38073 F7EE 18              byte >18                                            ; Number of edges          = 24
38074 F7F0 0000            data >0000                                          ; Bounty                   = 0
38075 F7F2 24              byte >24                                            ; Number of faces          = 36 / 4 = 9
38076 F7F3   0E            byte >0e                                            ; Visibility distance      = 14
38077 F7F4 02              byte >02                                            ; Max. energy              = 2
38078 F7F5   2C            byte >2c                                            ; Max. speed               = 44
38079               
38080 F7F6 00              byte (SHIP_MISSILE_EDGES - SHIP_MISSILE)/256        ; Edges data offset (high)
38081 F7F7   00            byte (SHIP_MISSILE_FACES - SHIP_MISSILE)/256        ; Faces data offset (high)
38082               
38083 F7F8 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
38084 F7F9   00            byte >00                                            ; Laser power              = 0
38085                                                                          ; Missiles                 = 0
38086               
38087               SHIP_MISSILE_VERTICES:
38088                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
38089 F7FA 0000            byte >00, >00, >44, >1f, >10, >32                   ; Vertex 0
     F7FC 441F     
     F7FE 1032     
38090 F800 0808            byte >08, >08, >24, >5f, >21, >54                   ; Vertex 1
     F802 245F     
     F804 2154     
38091 F806 0808            byte >08, >08, >24, >1f, >32, >74                   ; Vertex 2
     F808 241F     
     F80A 3274     
38092 F80C 0808            byte >08, >08, >24, >9f, >30, >76                   ; Vertex 3
     F80E 249F     
     F810 3076     
38093 F812 0808            byte >08, >08, >24, >df, >10, >65                   ; Vertex 4
     F814 24DF     
     F816 1065     
38094 F818 0808            byte >08, >08, >2c, >3f, >74, >88                   ; Vertex 5
     F81A 2C3F     
     F81C 7488     
38095 F81E 0808            byte >08, >08, >2c, >7f, >54, >88                   ; Vertex 6
     F820 2C7F     
     F822 5488     
38096 F824 0808            byte >08, >08, >2c, >ff, >65, >88                   ; Vertex 7
     F826 2CFF     
     F828 6588     
38097 F82A 0808            byte >08, >08, >2c, >bf, >76, >88                   ; Vertex 8
     F82C 2CBF     
     F82E 7688     
38098 F830 0C0C            byte >0c, >0c, >2c, >28, >74, >88                   ; Vertex 9
     F832 2C28     
     F834 7488     
38099 F836 0C0C            byte >0c, >0c, >2c, >68, >54, >88                   ; Vertex 10
     F838 2C68     
     F83A 5488     
38100 F83C 0C0C            byte >0c, >0c, >2c, >e8, >65, >88                   ; Vertex 11
     F83E 2CE8     
     F840 6588     
38101 F842 0C0C            byte >0c, >0c, >2c, >a8, >76, >88                   ; Vertex 12
     F844 2CA8     
     F846 7688     
38102 F848 0808            byte >08, >08, >0c, >a8, >76, >77                   ; Vertex 13
     F84A 0CA8     
     F84C 7677     
38103 F84E 0808            byte >08, >08, >0c, >e8, >65, >66                   ; Vertex 14
     F850 0CE8     
     F852 6566     
38104 F854 0808            byte >08, >08, >0c, >28, >74, >77                   ; Vertex 15
     F856 0C28     
     F858 7477     
38105 F85A 0808            byte >08, >08, >0c, >68, >54, >55                   ; Vertex 16
     F85C 0C68     
     F85E 5455     
38106               
38107               SHIP_MISSILE_EDGES:
38108                                                                          ; vertex1, vertex2, face1, face2, visibility
38109 F860 1F21            byte >1f, >21, >00, >04                             ; Edge 0
     F862 0004     
38110 F864 1F32            byte >1f, >32, >00, >08                             ; Edge 1
     F866 0008     
38111 F868 1F30            byte >1f, >30, >00, >0c                             ; Edge 2
     F86A 000C     
38112 F86C 1F10            byte >1f, >10, >00, >10                             ; Edge 3
     F86E 0010     
38113 F870 1F24            byte >1f, >24, >04, >08                             ; Edge 4
     F872 0408     
38114 F874 1F51            byte >1f, >51, >04, >10                             ; Edge 5
     F876 0410     
38115 F878 1F60            byte >1f, >60, >0c, >10                             ; Edge 6
     F87A 0C10     
38116 F87C 1F73            byte >1f, >73, >08, >0c                             ; Edge 7
     F87E 080C     
38117 F880 1F74            byte >1f, >74, >08, >14                             ; Edge 8
     F882 0814     
38118 F884 1F54            byte >1f, >54, >04, >18                             ; Edge 9
     F886 0418     
38119 F888 1F65            byte >1f, >65, >10, >1c                             ; Edge 10
     F88A 101C     
38120 F88C 1F76            byte >1f, >76, >0c, >20                             ; Edge 11
     F88E 0C20     
38121 F890 1F86            byte >1f, >86, >1c, >20                             ; Edge 12
     F892 1C20     
38122 F894 1F87            byte >1f, >87, >14, >20                             ; Edge 13
     F896 1420     
38123 F898 1F84            byte >1f, >84, >14, >18                             ; Edge 14
     F89A 1418     
38124 F89C 1F85            byte >1f, >85, >18, >1c                             ; Edge 15
     F89E 181C     
38125 F8A0 0885            byte >08, >85, >18, >28                             ; Edge 16
     F8A2 1828     
38126 F8A4 0887            byte >08, >87, >14, >24                             ; Edge 17
     F8A6 1424     
38127 F8A8 0887            byte >08, >87, >20, >30                             ; Edge 18
     F8AA 2030     
38128 F8AC 0885            byte >08, >85, >1c, >2c                             ; Edge 19
     F8AE 1C2C     
38129 F8B0 0874            byte >08, >74, >24, >3c                             ; Edge 20
     F8B2 243C     
38130 F8B4 0854            byte >08, >54, >28, >40                             ; Edge 21
     F8B6 2840     
38131 F8B8 0876            byte >08, >76, >30, >34                             ; Edge 22
     F8BA 3034     
38132 F8BC 0865            byte >08, >65, >2c, >38                             ; Edge 23
     F8BE 2C38     
38133               
38134               SHIP_MISSILE_FACES:
38135                                                                          ; normal_x, normal_y, normal_z, visibility
38136 F8C0 9F40            byte >9f, >40, >00, >10                             ; Face 0
     F8C2 0010     
38137 F8C4 5F00            byte >5f, >00, >40, >10                             ; Face 1
     F8C6 4010     
38138 F8C8 1F40            byte >1f, >40, >00, >10                             ; Face 2
     F8CA 0010     
38139 F8CC 1F00            byte >1f, >00, >40, >10                             ; Face 3
     F8CE 4010     
38140 F8D0 1F20            byte >1f, >20, >00, >00                             ; Face 4
     F8D2 0000     
38141 F8D4 5F00            byte >5f, >00, >20, >00                             ; Face 5
     F8D6 2000     
38142 F8D8 9F20            byte >9f, >20, >00, >00                             ; Face 6
     F8DA 0000     
38143 F8DC 1F00            byte >1f, >00, >20, >00                             ; Face 7
     F8DE 2000     
38144 F8E0 3F00            byte >3f, >00, >00, >b0                             ; Face 8
     F8E2 00B0     
38145               
38146               * ******************************************************************************
38147               *
38148               * Name: SHIP_ASTEROID
38149               * Type: Variable
38150               * Category: Drawing ships
38151               * Summary: Ship blueprint for an asteroid
38152               * Deep dive: Ship blueprints
38153               *
38154               * ******************************************************************************
38155               
38156               SHIP_ASTEROID:
38157 F8E4 00              byte >00                                            ; Max. canisters on demise = 0
38158 F8E6 1900            data 80 * 80                                        ; Targetable area          = 80 * 80
38159               
38160 F8E8 4C              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)%256      ; Edges data offset (low)
38161 F8E9   A0            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)%256      ; Faces data offset (low)
38162               
38163 F8EA 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
38164 F8EB   00            byte >00                                            ; Gun vertex               = 0
38165 F8EC 22              byte >22                                            ; Explosion count          = 7, as (4 * n) + 6 = 34
38166 F8ED   36            byte >36                                            ; Number of vertices       = 54 / 6 = 9
38167 F8EE 15              byte >15                                            ; Number of edges          = 21
38168 F8F0 0500            data >0500                                          ; Bounty                   = 5
38169 F8F2 38              byte >38                                            ; Number of faces          = 56 / 4 = 14
38170 F8F3   32            byte >32                                            ; Visibility distance      = 50
38171 F8F4 3C              byte >3c                                            ; Max. energy              = 60
38172 F8F5   1E            byte >1e                                            ; Max. speed               = 30
38173               
38174 F8F6 00              byte (SHIP_ASTEROID_EDGES - SHIP_ASTEROID)/256      ; Edges data offset (high)
38175 F8F7   00            byte (SHIP_ASTEROID_FACES - SHIP_ASTEROID)/256      ; Faces data offset (high)
38176               
38177 F8F8 01              byte >01                                            ; Normals are scaled by    = 2^1 = 2
38178 F8F9   00            byte >00                                            ; Laser power              = 0
38179                                                                          ; Missiles                 = 0
38180               
38181               SHIP_ASTEROID_VERTICES:
38182                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
38183 F8FA 0050            byte >00, >50, >00, >1f, >ff, >ff                   ; Vertex 0
     F8FC 001F     
     F8FE FFFF     
38184 F900 500A            byte >50, >0a, >00, >df, >ff, >ff                   ; Vertex 1
     F902 00DF     
     F904 FFFF     
38185 F906 0050            byte >00, >50, >00, >5f, >ff, >ff                   ; Vertex 2
     F908 005F     
     F90A FFFF     
38186 F90C 4628            byte >46, >28, >00, >5f, >ff, >ff                   ; Vertex 3
     F90E 005F     
     F910 FFFF     
38187 F912 3C32            byte >3c, >32, >00, >1f, >65, >dc                   ; Vertex 4
     F914 001F     
     F916 65DC     
38188 F918 3200            byte >32, >00, >3c, >1f, >ff, >ff                   ; Vertex 5
     F91A 3C1F     
     F91C FFFF     
38189 F91E 2800            byte >28, >00, >46, >9f, >10, >32                   ; Vertex 6
     F920 469F     
     F922 1032     
38190 F924 001E            byte >00, >1e, >4b, >3f, >ff, >ff                   ; Vertex 7
     F926 4B3F     
     F928 FFFF     
38191 F92A 0032            byte >00, >32, >3c, >7f, >98, >ba                   ; Vertex 8
     F92C 3C7F     
     F92E 98BA     
38192               
38193               SHIP_ASTEROID_EDGES:
38194                                                                          ; vertex1, vertex2, face1, face2, visibility
38195 F930 1F72            byte >1f, >72, >00, >04                             ; Edge 0
     F932 0004     
38196 F934 1FD6            byte >1f, >d6, >00, >10                             ; Edge 1
     F936 0010     
38197 F938 1FC5            byte >1f, >c5, >0c, >10                             ; Edge 2
     F93A 0C10     
38198 F93C 1FB4            byte >1f, >b4, >08, >0c                             ; Edge 3
     F93E 080C     
38199 F940 1FA3            byte >1f, >a3, >04, >08                             ; Edge 4
     F942 0408     
38200 F944 1F32            byte >1f, >32, >04, >18                             ; Edge 5
     F946 0418     
38201 F948 1F31            byte >1f, >31, >08, >18                             ; Edge 6
     F94A 0818     
38202 F94C 1F41            byte >1f, >41, >08, >14                             ; Edge 7
     F94E 0814     
38203 F950 1F10            byte >1f, >10, >14, >18                             ; Edge 8
     F952 1418     
38204 F954 1F60            byte >1f, >60, >00, >14                             ; Edge 9
     F956 0014     
38205 F958 1F54            byte >1f, >54, >0c, >14                             ; Edge 10
     F95A 0C14     
38206 F95C 1F20            byte >1f, >20, >00, >18                             ; Edge 11
     F95E 0018     
38207 F960 1F65            byte >1f, >65, >10, >14                             ; Edge 12
     F962 1014     
38208 F964 1FA8            byte >1f, >a8, >04, >20                             ; Edge 13
     F966 0420     
38209 F968 1F87            byte >1f, >87, >04, >1c                             ; Edge 14
     F96A 041C     
38210 F96C 1FD7            byte >1f, >d7, >00, >1c                             ; Edge 15
     F96E 001C     
38211 F970 1FDC            byte >1f, >dc, >10, >1c                             ; Edge 16
     F972 101C     
38212 F974 1FC9            byte >1f, >c9, >0c, >1c                             ; Edge 17
     F976 0C1C     
38213 F978 1FB9            byte >1f, >b9, >0c, >20                             ; Edge 18
     F97A 0C20     
38214 F97C 1FBA            byte >1f, >ba, >08, >20                             ; Edge 19
     F97E 0820     
38215 F980 1F98            byte >1f, >98, >1c, >20                             ; Edge 20
     F982 1C20     
38216               
38217               SHIP_ASTEROID_FACES:
38218                                                                          ; normal_x, normal_y, normal_z, visibility
38219 F984 1F09            byte >1f, >09, >42, >51                             ; Face 0
     F986 4251     
38220 F988 5F09            byte >5f, >09, >42, >51                             ; Face 1
     F98A 4251     
38221 F98C 9F48            byte >9f, >48, >40, >1f                             ; Face 2
     F98E 401F     
38222 F990 DF40            byte >df, >40, >49, >2f                             ; Face 3
     F992 492F     
38223 F994 5F2D            byte >5f, >2d, >4f, >41                             ; Face 4
     F996 4F41     
38224 F998 1F87            byte >1f, >87, >0f, >23                             ; Face 5
     F99A 0F23     
38225 F99C 1F26            byte >1f, >26, >4c, >46                             ; Face 6
     F99E 4C46     
38226 F9A0 BF42            byte >bf, >42, >3b, >27                             ; Face 7
     F9A2 3B27     
38227 F9A4 FF43            byte >ff, >43, >0f, >50                             ; Face 8
     F9A6 0F50     
38228 F9A8 7F42            byte >7f, >42, >0e, >4b                             ; Face 9
     F9AA 0E4B     
38229 F9AC FF46            byte >ff, >46, >50, >28                             ; Face 10
     F9AE 5028     
38230 F9B0 7F3A            byte >7f, >3a, >66, >33                             ; Face 11
     F9B2 6633     
38231 F9B4 3F51            byte >3f, >51, >09, >43                             ; Face 12
     F9B6 0943     
38232 F9B8 3F2F            byte >3f, >2f, >5e, >3f                             ; Face 13
     F9BA 5E3F     
38233               
38234               * ******************************************************************************
38235               *
38236               * Name: SHIP_CANISTER
38237               * Type: Variable
38238               * Category: Drawing ships
38239               * Summary: Ship blueprint for a cargo canister
38240               * Deep dive: Ship blueprints
38241               *
38242               * ******************************************************************************
38243               
38244               SHIP_CANISTER:
38245 F9BC 00              byte >00                                            ; Max. canisters on demise = 0
38246 F9BE 0190            data 20 * 20                                        ; Targetable area          = 20 * 20
38247               
38248 F9C0 52              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)%256      ; Edges data offset (low)
38249 F9C1   8E            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)%256      ; Faces data offset (low)
38250               
38251 F9C2 31              byte >31                                            ; Max. edge count          = (49 - 1) / 4 = 12
38252 F9C3   00            byte >00                                            ; Gun vertex               = 0
38253 F9C4 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
38254 F9C5   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
38255 F9C6 0F              byte >0f                                            ; Number of edges          = 15
38256 F9C8 0000            data >0000                                          ; Bounty                   = 0
38257 F9CA 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
38258 F9CB   0C            byte >0c                                            ; Visibility distance      = 12
38259 F9CC 11              byte >11                                            ; Max. energy              = 17
38260 F9CD   0F            byte >0f                                            ; Max. speed               = 15
38261               
38262 F9CE 00              byte (SHIP_CANISTER_EDGES - SHIP_CANISTER)/256      ; Edges data offset (high)
38263 F9CF   00            byte (SHIP_CANISTER_FACES - SHIP_CANISTER)/256      ; Faces data offset (high)
38264               
38265 F9D0 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
38266 F9D1   00            byte >00                                            ; Laser power              = 0
38267                                                                          ; Missiles                 = 0
38268               
38269               SHIP_CANISTER_VERTICES:
38270                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
38271 F9D2 1810            byte >18, >10, >00, >1f, >10, >55                   ; Vertex 0
     F9D4 001F     
     F9D6 1055     
38272 F9D8 1805            byte >18, >05, >0f, >1f, >10, >22                   ; Vertex 1
     F9DA 0F1F     
     F9DC 1022     
38273 F9DE 180D            byte >18, >0d, >09, >5f, >20, >33                   ; Vertex 2
     F9E0 095F     
     F9E2 2033     
38274 F9E4 180D            byte >18, >0d, >09, >7f, >30, >44                   ; Vertex 3
     F9E6 097F     
     F9E8 3044     
38275 F9EA 1805            byte >18, >05, >0f, >3f, >40, >55                   ; Vertex 4
     F9EC 0F3F     
     F9EE 4055     
38276 F9F0 1810            byte >18, >10, >00, >9f, >51, >66                   ; Vertex 5
     F9F2 009F     
     F9F4 5166     
38277 F9F6 1805            byte >18, >05, >0f, >9f, >21, >66                   ; Vertex 6
     F9F8 0F9F     
     F9FA 2166     
38278 F9FC 180D            byte >18, >0d, >09, >df, >32, >66                   ; Vertex 7
     F9FE 09DF     
     FA00 3266     
38279 FA02 180D            byte >18, >0d, >09, >ff, >43, >66                   ; Vertex 8
     FA04 09FF     
     FA06 4366     
38280 FA08 1805            byte >18, >05, >0f, >bf, >54, >66                   ; Vertex 9
     FA0A 0FBF     
     FA0C 5466     
38281               
38282               SHIP_CANISTER_EDGES:
38283                                                                          ; vertex1, vertex2, face1, face2, visibility
38284 FA0E 1F10            byte >1f, >10, >00, >04                             ; Edge 0
     FA10 0004     
38285 FA12 1F20            byte >1f, >20, >04, >08                             ; Edge 1
     FA14 0408     
38286 FA16 1F30            byte >1f, >30, >08, >0c                             ; Edge 2
     FA18 080C     
38287 FA1A 1F40            byte >1f, >40, >0c, >10                             ; Edge 3
     FA1C 0C10     
38288 FA1E 1F50            byte >1f, >50, >00, >10                             ; Edge 4
     FA20 0010     
38289 FA22 1F51            byte >1f, >51, >00, >14                             ; Edge 5
     FA24 0014     
38290 FA26 1F21            byte >1f, >21, >04, >18                             ; Edge 6
     FA28 0418     
38291 FA2A 1F32            byte >1f, >32, >08, >1c                             ; Edge 7
     FA2C 081C     
38292 FA2E 1F43            byte >1f, >43, >0c, >20                             ; Edge 8
     FA30 0C20     
38293 FA32 1F54            byte >1f, >54, >10, >24                             ; Edge 9
     FA34 1024     
38294 FA36 1F61            byte >1f, >61, >14, >18                             ; Edge 10
     FA38 1418     
38295 FA3A 1F62            byte >1f, >62, >18, >1c                             ; Edge 11
     FA3C 181C     
38296 FA3E 1F63            byte >1f, >63, >1c, >20                             ; Edge 12
     FA40 1C20     
38297 FA42 1F64            byte >1f, >64, >20, >24                             ; Edge 13
     FA44 2024     
38298 FA46 1F65            byte >1f, >65, >24, >14                             ; Edge 14
     FA48 2414     
38299               
38300               SHIP_CANISTER_FACES:
38301                                                                          ; normal_x, normal_y, normal_z, visibility
38302 FA4A 1F60            byte >1f, >60, >00, >00                             ; Face 0
     FA4C 0000     
38303 FA4E 1F00            byte >1f, >00, >29, >1e                             ; Face 1
     FA50 291E     
38304 FA52 5F00            byte >5f, >00, >12, >30                             ; Face 2
     FA54 1230     
38305 FA56 5F00            byte >5f, >00, >33, >00                             ; Face 3
     FA58 3300     
38306 FA5A 7F00            byte >7f, >00, >12, >30                             ; Face 4
     FA5C 1230     
38307 FA5E 3F00            byte >3f, >00, >29, >1e                             ; Face 5
     FA60 291E     
38308 FA62 9F60            byte >9f, >60, >00, >00                             ; Face 6
     FA64 0000     
38309               
38310               * ******************************************************************************
38311               *
38312               * Name: SHIP_THARGON
38313               * Type: Variable
38314               * Category: Drawing ships
38315               * Summary: Ship blueprint for a Thargon
38316               * Deep dive: Ship blueprints
38317               *
38318               * ------------------------------------------------------------------------------
38319               *
38320               * The ship blueprint for the Thargon reuses the edges data from the cargo
38321               * canister, so the edges data offset is negative.
38322               *
38323               * ******************************************************************************
38324               
38325               SHIP_THARGON:
38326 FA66 00              byte >00                                            ; Max. canisters on demise = 0
38327 FA68 0640            data 40 * 40                                        ; Targetable area          = 40 * 40
38328               
38329 FA6A 58              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)%256       ; Edges from canister
38330 FA6B   52            byte (SHIP_THARGON_FACES - SHIP_THARGON)%256        ; Faces data offset (low)
38331               
38332 FA6C 41              byte >41                                            ; Max. edge count          = (65 - 1) / 4 = 16
38333 FA6D   00            byte >00                                            ; Gun vertex               = 0
38334 FA6E 12              byte >12                                            ; Explosion count          = 3, as (4 * n) + 6 = 18
38335 FA6F   3C            byte >3c                                            ; Number of vertices       = 60 / 6 = 10
38336 FA70 0F              byte >0f                                            ; Number of edges          = 15
38337 FA72 3200            data >3200                                          ; Bounty                   = 50
38338 FA74 1C              byte >1c                                            ; Number of faces          = 28 / 4 = 7
38339 FA75   14            byte >14                                            ; Visibility distance      = 20
38340 FA76 14              byte >14                                            ; Max. energy              = 20
38341 FA77   1E            byte >1e                                            ; Max. speed               = 30
38342               
38343 FA78 00              byte (SHIP_CANISTER_EDGES - SHIP_THARGON)/256       ; Edges from canister
38344 FA79   00            byte (SHIP_THARGON_FACES - SHIP_THARGON)/256        ; Faces data offset (high)
38345               
38346 FA7A 02              byte >02                                            ; Normals are scaled by    = 2^2 = 4
38347 FA7B   10            byte >10                                            ; Laser power              = 2
38348                                                                          ; Missiles                 = 0
38349               
38350               SHIP_THARGON_VERTICES:
38351                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
38352 FA7C 0900            byte >09, >00, >28, >9f, >01, >55                   ; Vertex 0
     FA7E 289F     
     FA80 0155     
38353 FA82 0926            byte >09, >26, >0c, >df, >01, >22                   ; Vertex 1
     FA84 0CDF     
     FA86 0122     
38354 FA88 0918            byte >09, >18, >20, >ff, >02, >33                   ; Vertex 2
     FA8A 20FF     
     FA8C 0233     
38355 FA8E 0918            byte >09, >18, >20, >bf, >03, >44                   ; Vertex 3
     FA90 20BF     
     FA92 0344     
38356 FA94 0926            byte >09, >26, >0c, >9f, >04, >55                   ; Vertex 4
     FA96 0C9F     
     FA98 0455     
38357 FA9A 0900            byte >09, >00, >08, >3f, >15, >66                   ; Vertex 5
     FA9C 083F     
     FA9E 1566     
38358 FAA0 090A            byte >09, >0a, >0f, >7f, >12, >66                   ; Vertex 6
     FAA2 0F7F     
     FAA4 1266     
38359 FAA6 0906            byte >09, >06, >1a, >7f, >23, >66                   ; Vertex 7
     FAA8 1A7F     
     FAAA 2366     
38360 FAAC 0906            byte >09, >06, >1a, >3f, >34, >66                   ; Vertex 8
     FAAE 1A3F     
     FAB0 3466     
38361 FAB2 090A            byte >09, >0a, >0f, >3f, >45, >66                   ; Vertex 9
     FAB4 0F3F     
     FAB6 4566     
38362               
38363               SHIP_THARGON_FACES:
38364                                                                          ; normal_x, normal_y, normal_z, visibility
38365 FAB8 9F24            byte >9f, >24, >00, >00                             ; Face 0
     FABA 0000     
38366 FABC 5F14            byte >5f, >14, >05, >07                             ; Face 1
     FABE 0507     
38367 FAC0 7F2E            byte >7f, >2e, >2a, >0e                             ; Face 2
     FAC2 2A0E     
38368 FAC4 3F24            byte >3f, >24, >00, >68                             ; Face 3
     FAC6 0068     
38369 FAC8 3F2E            byte >3f, >2e, >2a, >0e                             ; Face 4
     FACA 2A0E     
38370 FACC 1F14            byte >1f, >14, >05, >07                             ; Face 5
     FACE 0507     
38371 FAD0 1F24            byte >1f, >24, >00, >00                             ; Face 6
     FAD2 0000     
38372               
38373               * ******************************************************************************
38374               *
38375               * Name: SHIP_ESCAPE_POD
38376               * Type: Variable
38377               * Category: Drawing ships
38378               * Summary: Ship blueprint for an escape pod
38379               * Deep dive: Ship blueprints
38380               *
38381               * ******************************************************************************
38382               
38383               SHIP_ESCAPE_POD:
38384 FAD4 00              byte >00                                            ; Max. canisters on demise = 0
38385 FAD6 0100            data 16 * 16                                        ; Targetable area          = 16 * 16
38386               
38387 FAD8 2E              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)%256  ; Edges data offset (low)
38388 FAD9   46            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)%256  ; Faces data offset (low)
38389               
38390 FADA 19              byte >19                                            ; Max. edge count          = (25 - 1) / 4 = 6
38391 FADB   00            byte >00                                            ; Gun vertex               = 0
38392 FADC 16              byte >16                                            ; Explosion count          = 4, as (4 * n) + 6 = 22
38393 FADD   18            byte >18                                            ; Number of vertices       = 24 / 6 = 4
38394 FADE 06              byte >06                                            ; Number of edges          = 6
38395 FAE0 0000            data >0000                                          ; Bounty                   = 0
38396 FAE2 10              byte >10                                            ; Number of faces          = 16 / 4 = 4
38397 FAE3   08            byte >08                                            ; Visibility distance      = 8
38398 FAE4 11              byte >11                                            ; Max. energy              = 17
38399 FAE5   08            byte >08                                            ; Max. speed               = 8
38400               
38401 FAE6 00              byte (SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)/256  ; Edges data offset (high)
38402 FAE7   00            byte (SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)/256  ; Faces data offset (high)
38403               
38404 FAE8 03              byte >03                                            ; Normals are scaled by    =  2^3 = 8
38405 FAE9   00            byte >00                                            ; Laser power              = 0
38406                                                                          ; Missiles                 = 0
38407               
38408               SHIP_ESCAPE_POD_VERTICES:
38409                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
38410 FAEA 0700            byte >07, >00, >24, >9f, >12, >33                   ; Vertex 0
     FAEC 249F     
     FAEE 1233     
38411 FAF0 070E            byte >07, >0e, >0c, >ff, >02, >33                   ; Vertex 1
     FAF2 0CFF     
     FAF4 0233     
38412 FAF6 070E            byte >07, >0e, >0c, >bf, >01, >33                   ; Vertex 2
     FAF8 0CBF     
     FAFA 0133     
38413 FAFC 1500            byte >15, >00, >00, >1f, >01, >22                   ; Vertex 3
     FAFE 001F     
     FB00 0122     
38414               
38415               SHIP_ESCAPE_POD_EDGES:
38416                                                                          ; vertex1, vertex2, face1, face2, visibility
38417 FB02 1F23            byte >1f, >23, >00, >04                             ; Edge 0
     FB04 0004     
38418 FB06 1F03            byte >1f, >03, >04, >08                             ; Edge 1
     FB08 0408     
38419 FB0A 1F01            byte >1f, >01, >08, >0c                             ; Edge 2
     FB0C 080C     
38420 FB0E 1F12            byte >1f, >12, >0c, >00                             ; Edge 3
     FB10 0C00     
38421 FB12 1F13            byte >1f, >13, >00, >08                             ; Edge 4
     FB14 0008     
38422 FB16 1F02            byte >1f, >02, >0c, >04                             ; Edge 5
     FB18 0C04     
38423               
38424               SHIP_ESCAPE_POD_FACES:
38425                                                                          ; normal_x, normal_y, normal_z, visibility
38426 FB1A 3F1A            byte >3f, >1a, >00, >3d                             ; Face 0
     FB1C 003D     
38427 FB1E 1F13            byte >1f, >13, >33, >0f                             ; Face 1
     FB20 330F     
38428 FB22 5F13            byte >5f, >13, >33, >0f                             ; Face 2
     FB24 330F     
38429 FB26 9F38            byte >9f, >38, >00, >00                             ; Face 3
     FB28 0000     
38430               
38431               * ******************************************************************************
38432               *
38433               * Save SHIPS.bin
38434               *
38435               * ******************************************************************************
38436               
38437                      ; PRINT "SHIPS"
38438                      ; PRINT "Assembled at ", ~CODE_SHIPS%
38439                      ; PRINT "Ends at ", ~P%
38440                      ; PRINT "Code size is ", ~(P% - CODE_SHIPS%)
38441                      ; PRINT "Execute at ", ~LOAD%
38442                      ; PRINT "Reload at ", ~LOAD_SHIPS%
38443               
38444                      ; PRINT "S.SHIPS ", ~CODE_SHIPS%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_SHIPS%
38445                      ; SAVE "3-assembled-output/SHIPS.bin", CODE_SHIPS%, P%, LOAD%
38446               
38447               * ******************************************************************************
38448               *
38449               * ELITE PYTHON SHIP BLUEPRINT FILE
38450               *
38451               * Produces the binary file PYTHON.bin that gets loaded by elite-bcfs.asm.
38452               *
38453               * ******************************************************************************
38454               
38455                      ; CLEAR 0, &7F00                ; CLEAR 0, &7F00
38456               
38457               LOAD_PYTHON.:
38458                      equ >1B00
38459               
38460               * ORG CODE_PYTHON%
38461               
38462               * ******************************************************************************
38463               *
38464               * Name: SHIP_PYTHON
38465               * Type: Variable
38466               * Category: Drawing ships
38467               * Summary: Ship blueprint for a Python
38468               * Deep dive: Ship blueprints
38469               *
38470               * ******************************************************************************
38471               
38472               SHIP_PYTHON:
38473 FB2A 03              byte >03                                            ; Max. canisters on demise = 3
38474 FB2C 3840            data 120 * 120                                      ; Targetable area          = 120 * 120
38475               
38476 FB2E 58              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)%256          ; Edges data offset (low)
38477 FB2F   C0            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)%256          ; Faces data offset (low)
38478               
38479 FB30 55              byte >55                                            ; Max. edge count          = (85 - 1) / 4 = 21
38480 FB31   00            byte >00                                            ; Gun vertex               = 0
38481 FB32 2E              byte >2e                                            ; Explosion count          = 10, as (4 * n) + 6 = 46
38482 FB33   42            byte >42                                            ; Number of vertices       = 66 / 6 = 11
38483 FB34 1A              byte >1a                                            ; Number of edges          = 26
38484 FB36 C800            data >c800                                          ; Bounty                   = 200
38485 FB38 34              byte >34                                            ; Number of faces          = 52 / 4 = 13
38486 FB39   28            byte >28                                            ; Visibility distance      = 40
38487 FB3A FA              byte >fa                                            ; Max. energy              = 250
38488 FB3B   14            byte >14                                            ; Max. speed               = 20
38489               
38490 FB3C 00              byte (SHIP_PYTHON_EDGES - SHIP_PYTHON)/256          ; Edges data offset (high)
38491 FB3D   00            byte (SHIP_PYTHON_FACES - SHIP_PYTHON)/256          ; Faces data offset (high)
38492               
38493 FB3E 00              byte >00                                            ; Normals are scaled by    = 2^0 = 1
38494 FB3F   1B            byte >1b                                            ; Laser power              = 3
38495                                                                          ; Missiles                 = 3
38496               
38497               SHIP_PYTHON_VERTICES:
38498                                                                          ; x,    y,    z, face1, face2, face3, face4, visibility
38499 FB40 0000            byte >00, >00, >e0, >1f, >10, >32                   ; Vertex 0
     FB42 E01F     
     FB44 1032     
38500 FB46 0030            byte >00, >30, >30, >1e, >10, >54                   ; Vertex 1
     FB48 301E     
     FB4A 1054     
38501 FB4C 6000            byte >60, >00, >10, >3f, >ff, >ff                   ; Vertex 2
     FB4E 103F     
     FB50 FFFF     
38502 FB52 6000            byte >60, >00, >10, >bf, >ff, >ff                   ; Vertex 3
     FB54 10BF     
     FB56 FFFF     
38503 FB58 0030            byte >00, >30, >20, >3e, >54, >98                   ; Vertex 4
     FB5A 203E     
     FB5C 5498     
38504 FB5E 0018            byte >00, >18, >70, >3f, >89, >cc                   ; Vertex 5
     FB60 703F     
     FB62 89CC     
38505 FB64 3000            byte >30, >00, >70, >bf, >b8, >cc                   ; Vertex 6
     FB66 70BF     
     FB68 B8CC     
38506 FB6A 3000            byte >30, >00, >70, >3f, >a9, >cc                   ; Vertex 7
     FB6C 703F     
     FB6E A9CC     
38507 FB70 0030            byte >00, >30, >30, >5e, >32, >76                   ; Vertex 8
     FB72 305E     
     FB74 3276     
38508 FB76 0030            byte >00, >30, >20, >7e, >76, >ba                   ; Vertex 9
     FB78 207E     
     FB7A 76BA     
38509 FB7C 0018            byte >00, >18, >70, >7e, >ba, >cc                   ; Vertex 10
     FB7E 707E     
     FB80 BACC     
38510               
38511               SHIP_PYTHON_EDGES:
38512                                                                          ; vertex1, vertex2, face1, face2, visibility
38513 FB82 1E32            byte >1e, >32, >00, >20                             ; Edge 0
     FB84 0020     
38514 FB86 1F20            byte >1f, >20, >00, >0c                             ; Edge 1
     FB88 000C     
38515 FB8A 1F31            byte >1f, >31, >00, >08                             ; Edge 2
     FB8C 0008     
38516 FB8E 1E10            byte >1e, >10, >00, >04                             ; Edge 3
     FB90 0004     
38517 FB92 1D59            byte >1d, >59, >08, >10                             ; Edge 4
     FB94 0810     
38518 FB96 1D51            byte >1d, >51, >04, >08                             ; Edge 5
     FB98 0408     
38519 FB9A 1D37            byte >1d, >37, >08, >20                             ; Edge 6
     FB9C 0820     
38520 FB9E 1D40            byte >1d, >40, >04, >0c                             ; Edge 7
     FBA0 040C     
38521 FBA2 1D62            byte >1d, >62, >0c, >20                             ; Edge 8
     FBA4 0C20     
38522 FBA6 1DA7            byte >1d, >a7, >08, >24                             ; Edge 9
     FBA8 0824     
38523 FBAA 1D84            byte >1d, >84, >0c, >10                             ; Edge 10
     FBAC 0C10     
38524 FBAE 1DB6            byte >1d, >b6, >0c, >24                             ; Edge 11
     FBB0 0C24     
38525 FBB2 0588            byte >05, >88, >0c, >14                             ; Edge 12
     FBB4 0C14     
38526 FBB6 05BB            byte >05, >bb, >0c, >28                             ; Edge 13
     FBB8 0C28     
38527 FBBA 0599            byte >05, >99, >08, >14                             ; Edge 14
     FBBC 0814     
38528 FBBE 05AA            byte >05, >aa, >08, >28                             ; Edge 15
     FBC0 0828     
38529 FBC2 1FA9            byte >1f, >a9, >08, >1c                             ; Edge 16
     FBC4 081C     
38530 FBC6 1FB8            byte >1f, >b8, >0c, >18                             ; Edge 17
     FBC8 0C18     
38531 FBCA 1FC8            byte >1f, >c8, >14, >18                             ; Edge 18
     FBCC 1418     
38532 FBCE 1FC9            byte >1f, >c9, >14, >1c                             ; Edge 19
     FBD0 141C     
38533 FBD2 1DAC            byte >1d, >ac, >1c, >28                             ; Edge 20
     FBD4 1C28     
38534 FBD6 1DCB            byte >1d, >cb, >18, >28                             ; Edge 21
     FBD8 1828     
38535 FBDA 1D98            byte >1d, >98, >10, >14                             ; Edge 22
     FBDC 1014     
38536 FBDE 1DBA            byte >1d, >ba, >24, >28                             ; Edge 23
     FBE0 2428     
38537 FBE2 1D54            byte >1d, >54, >04, >10                             ; Edge 24
     FBE4 0410     
38538 FBE6 1D76            byte >1d, >76, >20, >24                             ; Edge 25
     FBE8 2024     
38539               
38540               SHIP_PYTHON_FACES:
38541                                                                          ; normal_x, normal_y, normal_z, visibility
38542 FBEA 9E1B            byte >9e, >1b, >28, >0b                             ; Face 0
     FBEC 280B     
38543 FBEE 1E1B            byte >1e, >1b, >28, >0b                             ; Face 1
     FBF0 280B     
38544 FBF2 DE1B            byte >de, >1b, >28, >0b                             ; Face 2
     FBF4 280B     
38545 FBF6 5E1B            byte >5e, >1b, >28, >0b                             ; Face 3
     FBF8 280B     
38546 FBFA 9E13            byte >9e, >13, >26, >00                             ; Face 4
     FBFC 2600     
38547 FBFE 1E13            byte >1e, >13, >26, >00                             ; Face 5
     FC00 2600     
38548 FC02 DE13            byte >de, >13, >26, >00                             ; Face 6
     FC04 2600     
38549 FC06 5E13            byte >5e, >13, >26, >00                             ; Face 7
     FC08 2600     
38550 FC0A BE19            byte >be, >19, >25, >0b                             ; Face 8
     FC0C 250B     
38551 FC0E 3E19            byte >3e, >19, >25, >0b                             ; Face 9
     FC10 250B     
38552 FC12 7E19            byte >7e, >19, >25, >0b                             ; Face 10
     FC14 250B     
38553 FC16 FE19            byte >fe, >19, >25, >0b                             ; Face 11
     FC18 250B     
38554 FC1A 3E00            byte >3e, >00, >00, >70                             ; Face 12
     FC1C 0070     
38555               
38556 FC1E                 bss 11                                              ; This space appears to be unused
38557               
38558               * ******************************************************************************
38559               *
38560               * Name: SVN
38561               * Type: Variable
38562               * Category: Save and load
38563               * Summary: The "saving in progress" flag
38564               *
38565               * ******************************************************************************
38566               
38567               SVN:
38568 FC29                 bss 1                                               ; "Saving in progress" flag
38569                                                                          ;
38570                                                                          ; * Non-zero while we are saving a commander
38571                                                                          ;
38572                                                                          ; * 0 otherwise
38573               
38574               * ******************************************************************************
38575               *
38576               * Name: VEC
38577               * Type: Variable
38578               * Category: Drawing the screen
38579               * Summary: The original value of the IRQ1 vector
38580               *
38581               * ******************************************************************************
38582               
38583               VEC:
38584               * SKIP 2                 \ VEC = &7FFE
38585                                                                          ;
38586                                                                          ; This gets set to the value of the original IRQ1 vector
38587                                                                          ; by the loading process
38588               * ******************************************************************************
38589               *
38590               * Save PYTHON.bin
38591               *
38592               * ******************************************************************************
38593                      ; PRINT "PYTHON"
38594                      ; PRINT "Assembled at ", ~CODE_PYTHON%
38595                      ; PRINT "Ends at ", ~P%
38596                      ; PRINT "Code size is ", ~(P% - CODE_PYTHON%)
38597                      ; PRINT "Execute at ", ~LOAD%
38598                      ; PRINT "Reload at ", ~LOAD_PYTHON%
38599               
38600                      ; PRINT "S.PYTHON ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_PYTHON%
38601                      ; SAVE "3-assembled-output/PYTHON.bin", CODE_PYTHON%, P%, LOAD%
38602               
38603               * ******************************************************************************
38604               *
38605               * Show free space
38606               *
38607               * ******************************************************************************
38608               
38609                      ; PRINT "ELITE game code ", ~(&6000-P%), " bytes free"
38610                      ; PRINT "Ends at ", ~P%
                   < main.a99
0004                      aorg >FE00
0005                      copy "entry.a99"
     **** ****     > entry.a99
0001 FE00 0300  22        limi 0
     FE02 0000     
0002 FE04 02E0  18        lwpi workspace
     FE06 8300     
0003 FE08 020A  20        li   rsp,STACK.
     FE0A 0100     
0004 FE0C 0209  20        li   rvdpwd,vdpwd
     FE0E 8C00     
0005 FE10 04C6  14        clr  rzero
0006 FE12 0207  20        li   rone,>0100
     FE14 0100     
0007 FE16 0208  20        li   rmone,>ff00
     FE18 FF00     
0008 FE1A 06A0  32        bl   @graphics_mode
     FE1C FE94     
0009 FE1E 0460  28        b    @TT170
     FE20 CCFC     
0010               
                   < main.a99
0006                      copy "subroutines.a99"
     **** ****     > subroutines.a99
0001               OSBYTE:
0002 FE22 1008  14        jmp rts
0003               OSWORD:
0004 FE24 1007  14        jmp rts
0005               OSFILE:
0006 FE26 1006  14        jmp rts
0007               
0008               jsr:
0009 FE28 D68B  30        movb r11,*rsp
0010 FE2A 060A  14        dec  rsp
0011 FE2C 06CB  14        swpb r11
0012 FE2E D68B  30        movb r11,*rsp
0013 FE30 060A  14        dec  rsp
0014 FE32 0450  20        b    *rtmp
0015               
0016               rts:
0017 FE34 058A  14        inc  rsp
0018 FE36 D2FA  28        movb *rsp+,r11
0019 FE38 06CB  14        swpb r11
0020 FE3A D2DA  26        movb *rsp,r11
0021 FE3C 045B  20        b    *r11
0022               
0023               rola:
0024 FE3E 1702  14        jnc  !
0025 FE40 026D  22        ori  ra,>0080
     FE42 0080     
0026               !:
0027 FE44 1002  14        jmp  !
0028 FE46 024D  22        andi ra,>ff7f
     FE48 FF7F     
0029               !:
0030 FE4A 0A1D  18        sla  ra,1
0031 FE4C 045B  20        rt
0032               
0033               rol:
0034 FE4E D014  26        movb *rarg1,rtmp
0035 FE50 1702  14        jnc  !
0036 FE52 0260  22        ori  rtmp,>0080
     FE54 0080     
0037               !:
0038 FE56 1002  14        jmp  !
0039 FE58 0240  22        andi rtmp,>ff7f
     FE5A FF7F     
0040               !:
0041 FE5C 0A10  18        sla  rtmp,1
0042 FE5E C500  30        mov  rtmp,*rarg1
0043 FE60 045B  20        rt
0044               
0045               rora:
0046 FE62 1702  14        jnc  !
0047 FE64 026D  22        ori  ra,>0001
     FE66 0001     
0048               !:
0049 FE68 1002  14        jmp  !
0050 FE6A 024D  22        andi ra,>fffe
     FE6C FFFE     
0051               !:
0052 FE6E 0B1D  18        src  ra,1
0053 FE70 024D  22        andi ra,>0080
     FE72 0080     
0054 FE74 C00D  18        mov  ra,rtmp
0055 FE76 0A90  34        sla  rtmp,9
0056 FE78 045B  20        rt
0057               
0058               ror:
0059 FE7A D014  26        movb *rarg1,rtmp
0060 FE7C 1702  14        jnc  !
0061 FE7E 0260  22        ori  rtmp,>0001
     FE80 0001     
0062               !:
0063 FE82 1002  14        jmp  !
0064 FE84 0240  22        andi rtmp,>fffe
     FE86 FFFE     
0065               !:
0066 FE88 0B10  18        src  rtmp,1
0067 FE8A D500  30        movb rtmp,*rarg1
0068 FE8C 0240  22        andi rtmp,>0080
     FE8E 0080     
0069 FE90 0A90  34        sla  rtmp,9
0070 FE92 045B  20        rt
                   < main.a99
0007                      copy "vdp.a99"
     **** ****     > vdp.a99
0001               *********************************************************************************
0002               *
0003               * Set graphics mode
0004               *
0005               graphics_mode:
0006 FE94 C0CB  18        mov  r11,rtmp4
0007 FE96 0201  20        li   rtmp2,vregs2
     FE98 FEDE     
0008               graphics_mode_1:
0009 FE9A C031  30        mov  *rtmp2+,rtmp
0010 FE9C 111F  14        jlt  graphics_mode_2
0011 FE9E 06A0  32        bl   @vwtr                      ; Set register
     FEA0 FEF0     
0012 FEA2 10FB  14        jmp  graphics_mode_1
0013               *      Init name table
0014 FEA4 0200  20        li   rtmp,name_table
     FEA6 3800     
0015 FEA8 06A0  32        bl   @vwad
     FEAA FF02     
0016 FEAC 04C1  14        clr  rtmp2
0017 FEAE 0202  20        li   rtmp3,>300
     FEB0 0300     
0018               init_vdp_ram_1:
0019 FEB2 D641  30        movb rtmp2,*rvdpwd
0020 FEB4 0220  22        ai   rtmp,>0100
     FEB6 0100     
0021 FEB8 0602  14        dec  rtmp3
0022 FEBA 16FB  14        jne   init_vdp_ram_1
0023               *      Init patterms
0024 FEBC 0200  20        li   rtmp,pattern_table
     FEBE 0000     
0025 FEC0 0200  20        li   rtmp,>0000
     FEC2 0000     
0026 FEC4 0202  20        li   rtmp3,>1800
     FEC6 1800     
0027 FEC8 06A0  32        bl   @vsmw
     FECA FF40     
0028               *      Init colors
0029 FECC 0200  20        li   rtmp,color_table
     FECE 2000     
0030 FED0 0201  20        li   rtmp2,>f100
     FED2 F100     
0031 FED4 0202  20        li   rtmp3,>1800
     FED6 1800     
0032 FED8 06A0  32        bl   @vsmw
     FEDA FF40     
0033               *      Return
0034               graphics_mode_2:
0035 FEDC 0453  20        b    *rtmp4
0036               *      VDP registers
0037               vregs2:
0038 FEDE 0002            byte >00,>02                        ; Graphics II mode
0039 FEE0 01E2            byte >01,>e2                        ; 16K, display on, interrupts enabled
0040 FEE2 020E            byte >02,name_table/>400            ; Name table
0041 FEE4 03FF            byte >03,>ff                        ; Color table
0042 FEE6 0403            byte >04,pattern_table/>800+>03     ; Pattern table
0043 FEE8 0576            byte >05,sprite_attr_table/>80      ; Sprite attribute table
0044 FEEA 0603            byte >06,sprite_pattern_table/>800  ; Sprite pattern table
0045 FEEC 0701            byte >07,>01                        ; Backdrop color
0046 FEEE FFFF            data -1
0047               *// graphics_mode
0048               
0049               *********************************************************************
0050               *
0051               * VDP Write To Register
0052               *
0053               * rtmp MSB: VDP register to write to
0054               * rtmp LSB: Value to write
0055               *
0056               vwtr:
0057 FEF0 06C0  14        swpb rtmp
0058 FEF2 D800  30        movb rtmp,@vdpwa                ; Send low byte (value) to write to VDP register
     FEF4 8C02     
0059 FEF6 06C0  14        swpb rtmp
0060 FEF8 0260  22        ori  rtmp,>8000                 ; Set up a VDP register write operation (10)
     FEFA 8000     
0061 FEFC D800  30        movb rtmp,@vdpwa                ; Send high byte (address) of VDP register
     FEFE 8C02     
0062 FF00 045B  20        rt
0063               *// vwtr
0064               
0065               *********************************************************************
0066               *
0067               * VDP Set Write Address
0068               *
0069               * rtmp: Write address in VDP RAM
0070               *
0071               vwad:
0072 FF02 06C0  14        swpb rtmp
0073 FF04 D800  30        movb rtmp,@vdpwa                ; Send low byte of VDP RAM write address
     FF06 8C02     
0074 FF08 06C0  14        swpb rtmp
0075 FF0A 0260  22        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF0C 4000     
0076 FF0E D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF10 8C02     
0077 FF12 045B  20        rt
0078               *// vwad
0079               
0080               *********************************************************************
0081               *
0082               * VDP Single Byte Write
0083               *
0084               * rtmp: Write address in VDP RAM
0085               * rtmp2: MSB of rtmp2 sent to VDP RAM
0086               *
0087               vsbw:
0088 FF14 06C0  14        swpb rtmp
0089 FF16 D800  30        movb rtmp,@vdpwa                ; Send low byte of VDP RAM write address
     FF18 8C02     
0090 FF1A 06C0  14        swpb rtmp
0091 FF1C 0260  22        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF1E 4000     
0092 FF20 D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF22 8C02     
0093 FF24 D641  30        movb rtmp2,*rvdpwd              ; Write byte to VDP RAM
0094 FF26 045B  20        rt
0095               *// vsbw
0096               
0097               *********************************************************************
0098               *
0099               * VDP multiple Byte Write
0100               *
0101               * rtmp: Write address in VDP RAM
0102               * rtmp2: Starting read address in CPU RAM
0103               * rtmp3: Number of bytes to send
0104               *
0105               vmbw:
0106 FF28 06C0  14        swpb rtmp
0107 FF2A D800  30        movb rtmp,@vdpwa                ; Send low byte of VDP RAM write address
     FF2C 8C02     
0108 FF2E 06C0  14        swpb rtmp
0109 FF30 0260  22        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF32 4000     
0110 FF34 D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF36 8C02     
0111               vmbw_1:
0112 FF38 D670  40        movb *rtmp+,*rvdpwd             ; Write byte to VDP RAM
0113 FF3A 0602  14        dec  rtmp3
0114 FF3C 16FD  14        jne  vmbw_1
0115 FF3E 045B  20        rt
0116               *// vmbw
0117               
0118               *********************************************************************
0119               *
0120               * VDP Single Byte Multiple Write
0121               *
0122               * rtmp: Write address in VDP RAM
0123               * rtmp2: MSB of  sent to VDP RAM
0124               * rtmp3: Number of bytes to write to VDP RAM
0125               *
0126               vsmw:
0127 FF40 06C0  14        swpb rtmp
0128 FF42 D800  30        movb  rtmp,@vdpwa               ; Send low byte of VDP RAM write address
     FF44 8C02     
0129 FF46 06C0  14        swpb rtmp
0130 FF48 0260  22        ori  rtmp,>4000                 ; Set read/write bits 14 and 15 to write (01)
     FF4A 4000     
0131 FF4C D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF4E 8C02     
0132               vsmw_1:
0133 FF50 D641  30        movb rtmp2,*rvdpwd              ; Write byte to VDP RAM
0134 FF52 0602  14        dec  rtmp3                      ; Byte counter
0135 FF54 16FD  14        jne  vsmw_1
0136 FF56 045B  20        rt
0137               *// vsmw
0138               
0139               *********************************************************************
0140               *
0141               * Copy screen buffer to VDP
0142               *
0143               display_scr_buffer:
0144 FF58 04E0  26        clr  @vdpwa                     ; Send low byte of VDP RAM write address
     FF5A 8C02     
0145 FF5C 0200  20        li   rtmp,pattern_table+>4000
     FF5E 4000     
0146 FF60 D800  30        movb rtmp,@vdpwa                ; Send high byte of VDP RAM write address
     FF62 8C02     
0147 FF64 0201  20        li   rtmp2,scr_buffer
     FF66 6000     
0148 FF68 0202  20        li   rtmp3,>1800/8
     FF6A 0300     
0149               display_scr_buffer_1:
0150 FF6C D671  40        movb *rtmp2+,*rvdpwd            ; Send by to VDP
0151 FF6E D671  40        movb *rtmp2+,*rvdpwd            ; ...
0152 FF70 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0153 FF72 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0154 FF74 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0155 FF76 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0156 FF78 D671  40        movb *rtmp2+,*rvdpwd            ; ...
0157 FF7A D671  40        movb *rtmp2+,*rvdpwd            ; ...
0158 FF7C 0602  14        dec  rtmp3                      ; Counter
0159 FF7E 16F6  14        jne  display_scr_buffer_1       ; Loop
0160 FF80 045B  20        rt
0161               display_scr_buffer_end:
0162                      equ  $
0163               *// display_scr_buffer
                   < main.a99
